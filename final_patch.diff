diff --git a/os/arch/arm/src/amebalite/Make.defs b/os/arch/arm/src/amebalite/Make.defs
index f332a4611..8590a9ee3 100644
--- a/os/arch/arm/src/amebalite/Make.defs
+++ b/os/arch/arm/src/amebalite/Make.defs
@@ -137,6 +137,8 @@ ARCH_SRCDIR = $(TOPDIR)/arch/$(CONFIG_ARCH)/src/
 CFLAGS+= -mcmse
 
 CFLAGS += -I$(ARCH_SRCDIR)/armv8-m
+CFLAGS += -I$(TOPDIR)/board/$(CONFIG_ARCH_BOARD)/src/component/os/tizenrt
+CFLAGS += -I$(TOPDIR)/board/$(CONFIG_ARCH_BOARD)/src/component/os_dep
 CFLAGS += -I$(TOPDIR)/board/$(CONFIG_ARCH_BOARD)/src/component/soc/amebalite/fwlib/include
 CFLAGS += -I$(TOPDIR)/board/$(CONFIG_ARCH_BOARD)/src/component/os/freertos
 #CFLAGS += -I$(TOPDIR)/board/$(CONFIG_ARCH_BOARD)/src/component/os/freertos/freertos_v10.2.0/Source/include/		#KAI	freertos is not in folder
@@ -151,9 +153,10 @@ CFLAGS += -I$(TOPDIR)/board/$(CONFIG_ARCH_BOARD)/src/component/soc/amebalite/app
 CFLAGS += -I$(TOPDIR)/board/$(CONFIG_ARCH_BOARD)/src/component/soc/amebalite/swlib
 CFLAGS += -I$(TOPDIR)/board/$(CONFIG_ARCH_BOARD)/src/component/soc/amebalite/misc
 CFLAGS += -I$(TOPDIR)/board/$(CONFIG_ARCH_BOARD)/src/project/realtek_amebaLite_va0_example/inc/inc_km4
-CFLAGS += -I$(TOPDIR)/board/$(CONFIG_ARCH_BOARD)/src/component/stdlib
+#CFLAGS += -I$(TOPDIR)/board/$(CONFIG_ARCH_BOARD)/src/component/stdlib
 CFLAGS += -I$(TOPDIR)/board/$(CONFIG_ARCH_BOARD)/src/component/wifi/api
 CFLAGS += -I$(TOPDIR)/board/$(CONFIG_ARCH_BOARD)/src/component/wifi/driver/include
+CFLAGS += -I$(TOPDIR)/board/$(CONFIG_ARCH_BOARD)/src/component/wifi/driver/src/intf
 CFLAGS += -I$(TOPDIR)/board/$(CONFIG_ARCH_BOARD)/src/component/wifi/wifi_config
 CFLAGS += -I$(TOPDIR)/board/$(CONFIG_ARCH_BOARD)/src/component/wifi/wifi_fast_connect
 #CFLAGS += -I$(TOPDIR)/board/$(CONFIG_ARCH_BOARD)/src/component/example			#Not placed in smart
@@ -165,8 +168,7 @@ CFLAGS += -I$(TOPDIR)/board/$(CONFIG_ARCH_BOARD)/src/component/mbed/api/
 CFLAGS += -I$(TOPDIR)/board/$(CONFIG_ARCH_BOARD)/src/component/mbed/hal/
 CFLAGS += -I$(TOPDIR)/board/$(CONFIG_ARCH_BOARD)/src/component/mbed/hal_ext/
 
-CFLAGS += -I$(TOPDIR)/board/$(CONFIG_ARCH_BOARD)/src/component/os/os_dep/include
-CFLAGS += -I$(TOPDIR)/board/$(CONFIG_ARCH_BOARD)/src/component/os/tizenrt
+#CFLAGS += -I$(TOPDIR)/board/$(CONFIG_ARCH_BOARD)/src/component/os/os_dep/include
 
 CHIP_ASRCS  =
 CHIP_CSRCS = amebalite_start.c
diff --git a/os/arch/arm/src/amebalite/amebalite_enet.c b/os/arch/arm/src/amebalite/amebalite_enet.c
index bedc7c839..adcd9e97c 100644
--- a/os/arch/arm/src/amebalite/amebalite_enet.c
+++ b/os/arch/arm/src/amebalite/amebalite_enet.c
@@ -65,7 +65,7 @@
 #include <tinyara/kmalloc.h>
 #include <tinyara/netmgr/netdev_mgr.h>
 #include <tinyara/ble/ble_manager.h>
-#include "wifi_structures.h"
+#include "wifi_conf.h"
 
 //for concurrent mode, not supported now
 //#define RTK_CONCURRENT_MODE
@@ -79,11 +79,13 @@ extern err_t low_level_output(struct netdev *dev, uint8_t *data, uint16_t dlen);
 extern struct trwifi_ops g_trwifi_drv_ops;
 extern struct trble_ops g_trble_drv_ops;
 
+#ifdef CONFIG_PROMISC
 extern void wifi_init_packet_filter(void);
 extern int wifi_add_packet_filter(unsigned char filter_id, rtw_packet_filter_pattern_t *patt, rtw_packet_filter_rule_t rule);
 extern int wifi_enable_packet_filter(unsigned char filter_id);
 extern int wifi_disable_packet_filter(unsigned char filter_id);
 extern int wifi_remove_packet_filter(unsigned char filter_id);
+#endif
 
 #define MULTICAST_IP_TO_MAC(ip) { (u8)0x01, \
 				  (u8)0x00, \
@@ -121,6 +123,7 @@ int rtk_set_multicast_packet_filters(int dev_index, const u8 *addr){
 
 	rule = RTW_POSITIVE_MATCHING;
 
+#ifdef CONFIG_PROMISC
 	wifi_init_packet_filter();
 	ret = wifi_add_packet_filter(dev_index, &packet_filter, rule);
 	if (ret != 0){
@@ -132,12 +135,14 @@ int rtk_set_multicast_packet_filters(int dev_index, const u8 *addr){
 		vddbg("wifi_enable_packet_filter fail, ret = %d\n",ret);
 		return ret;
 	}
+#endif
 	return ret;
 }
 
 int rtk_clear_packet_filters(int dev_index){
 	int ret = 0;
 
+#ifdef CONFIG_PROMISC
 	ret = wifi_disable_packet_filter(dev_index);
 	if (ret != 0){
 		vddbg("wifi_disable_packet_filter fail, ret = %d\n",ret);
@@ -148,7 +153,7 @@ int rtk_clear_packet_filters(int dev_index){
 		vddbg("wifi_remove_packet_filter fail, ret = %d\n",ret);
 		return ret;
 	}
-
+#endif
 	return ret;
 }
 
@@ -198,6 +203,7 @@ struct netdev* amebalite_register_dev(int sizeof_priv)
 
 void up_netinitialize(void)
 {
+	rtw_printf("Pass netinitialize\n");
 #ifdef CONFIG_AMEBALITE_WIFI
 	int alloc_size;
 	//struct netdev *dev = NULL;
@@ -221,4 +227,5 @@ void up_netinitialize(void)
 		rtw_printf("Failed to register amebad netdev\n");
 	}
 #endif
+	rtw_printf("Pass netinitialize\n");
 }
diff --git a/os/board/rtl8720e/src/Makefile b/os/board/rtl8720e/src/Makefile
old mode 100644
new mode 100755
index 83996f31c..05755b066
--- a/os/board/rtl8720e/src/Makefile
+++ b/os/board/rtl8720e/src/Makefile
@@ -79,13 +79,13 @@ include component/soc/amebalite/fwlib/ram_km4/Make.defs
 include component/soc/amebalite/fwlib/ram_common/Make.defs
 include component/soc/amebalite/fwlib/usrcfg/Make.defs
 include component/lwip/api/Make.defs
+include component/os_dep/Make.defs
 include component/wifi/Make.defs
 include component/wifi/inic/Make.defs
+include component/wifi/driver/src/core/Make.defs
 include component/wifi/driver/src/core/option/Make.defs
-include component/wifi/driver/src/osdep/freertos/Make.defs
 include component/ssl/mbedtls_ram_map/rom/Make.defs
 include component/mbed/targets/hal/rtl8720e/Make.defs
-include component/os/os_dep/Make.defs
 include component/os/tizenrt/Make.defs
 
 ifeq ($(CONFIG_AMEBALITE_WIFI),y)
@@ -117,7 +117,7 @@ BOARD_SRCDIR = 	$(TOPDIR)/board
 PROJ_DIR = 	$(BOARD_SRCDIR)/$(CONFIG_ARCH_BOARD)/src/project/realtek_amebaLite_va0_example
 COMPONENT_DIR = $(BOARD_SRCDIR)/$(CONFIG_ARCH_BOARD)/src/component
 DIR_WIFI = 	$(BOARD_SRCDIR)/$(CONFIG_ARCH_BOARD)/src/component/wifi
-DIR_OSDEP = 	$(BOARD_SRCDIR)/$(CONFIG_ARCH_BOARD)/src/component/os/os_dep
+DIR_OSDEP = 	$(BOARD_SRCDIR)/$(CONFIG_ARCH_BOARD)/src/component/os_dep
 DIR_OS = 	$(BOARD_SRCDIR)/$(CONFIG_ARCH_BOARD)/src/component/os
 DIR_MBED = 	$(BOARD_SRCDIR)/$(CONFIG_ARCH_BOARD)/src/component/mbed/targets/hal/rtl8720e
 ifeq ($(CONFIG_AMEBALITE_BLE),y)
@@ -138,23 +138,22 @@ CFLAGS += -I$(TARGETDIR)/app/monitor/include
 CFLAGS += -I$(TARGETDIR)/app/xmodem
 CFLAGS += -I$(TARGETDIR)/swlib
 CFLAGS += -I$(TARGETDIR)/misc
-CFLAGS += -I$(COMPONENT_DIR)/stdlib
+CFLAGS += -I$(COMPONENT_DIR)/os_dep
 
 CFLAGS += -I$(COMPONENT_DIR)/wifi
 CFLAGS += -I$(COMPONENT_DIR)/wifi/api
 CFLAGS += -I$(COMPONENT_DIR)/wifi/driver/include
-CFLAGS += -I$(COMPONENT_DIR)/wifi/driver/src/osdep
+CFLAGS += -I$(COMPONENT_DIR)/wifi/driver/src/intf
 CFLAGS += -I$(COMPONENT_DIR)/wifi/inic
 CFLAGS += -I$(COMPONENT_DIR)/wifi/wifi_config
-CFLAGS += -I$(COMPONENT_DIR)/wifi/wifi_fw/amebalite/include
+#CFLAGS += -I$(COMPONENT_DIR)/wifi/wifi_fw/amebalite/include
 CFLAGS += -I$(COMPONENT_DIR)/wifi/driver/include
-CFLAGS += -I$(COMPONENT_DIR)/wifi/driver/src/hal/phydm
-CFLAGS += -I$(COMPONENT_DIR)/wifi/driver/src/hal/phy_g6/bb
-CFLAGS += -I$(COMPONENT_DIR)/wifi/driver/src/hal/rtl8720e
-CFLAGS += -I$(COMPONENT_DIR)/wifi/driver/src/osdep
-CFLAGS += -I$(COMPONENT_DIR)/wifi/driver/src/hal
-CFLAGS += -I$(COMPONENT_DIR)/wifi/driver/src/hci
-CFLAGS += -I$(COMPONENT_DIR)/wifi/driver/src/phl
+#CFLAGS += -I$(COMPONENT_DIR)/wifi/driver/src/hal/phydm
+#CFLAGS += -I$(COMPONENT_DIR)/wifi/driver/src/hal/phy_g6/bb
+#CFLAGS += -I$(COMPONENT_DIR)/wifi/driver/src/hal/rtl8720e
+#CFLAGS += -I$(COMPONENT_DIR)/wifi/driver/src/hal
+#CFLAGS += -I$(COMPONENT_DIR)/wifi/driver/src/hci
+#CFLAGS += -I$(COMPONENT_DIR)/wifi/driver/src/phl
 CFLAGS += -I$(COMPONENT_DIR)/wifi/driver/src/core/option
 CFLAGS += -I$(COMPONENT_DIR)/wifi/wpa_supplicant/src/crypto
 CFLAGS += -I$(COMPONENT_DIR)/lwip/api
@@ -162,13 +161,13 @@ CFLAGS += -I$(COMPONENT_DIR)/ssl/mbedtls_ram_map/rom
 
 CFLAGS += -I$(COMPONENT_DIR)/os/tizenrt
 CFLAGS += -I$(DIR_MBED)
-CFLAGS += -I$(DIR_OSDEP)/include
+CFLAGS += -I$(DIR_OSDEP)
 CFLAGS += -I$(DIR_WIFI)/wpa_supplicant/src
+CFLAGS += -I$(DIR_WIFI)/wifi_fast_connect
 CFLAGS += -I$(COMPONENT_DIR)/mbed/api
 CFLAGS += -I$(COMPONENT_DIR)/mbed/hal
 CFLAGS += -I$(COMPONENT_DIR)/mbed/hal_ext
 CFLAGS += -I$(COMPONENT_DIR)/mbed/targets/hal/rtl8720e
-CFLAGS += -I$(COMPONENT_DIR)/os/os_dep/include
 CFLAGS += -I$(TOPDIR)/net/netmgr
 
 ifeq ($(CONFIG_AMEBALITE_BLE),y)
diff --git a/os/board/rtl8720e/src/component/lwip/api/lwip_netconf.c b/os/board/rtl8720e/src/component/lwip/api/lwip_netconf.c
old mode 100644
new mode 100755
index ef954749b..989a2d94f
--- a/os/board/rtl8720e/src/component/lwip/api/lwip_netconf.c
+++ b/os/board/rtl8720e/src/component/lwip/api/lwip_netconf.c
@@ -5,7 +5,7 @@
 #include "wifi_ind.h"
 #endif
 
-#include <platform_stdlib.h>
+#include "platform_stdlib.h"
 #include "osdep_service.h"
 
 #if defined(CONFIG_FAST_DHCP) && CONFIG_FAST_DHCP
@@ -521,7 +521,6 @@ void LwIP_etharp_request(uint8_t idx, const ip4_addr_t *ipaddr)
 	etharp_request(pnetif, ipaddr);
 }
 
-#if !defined(CONFIG_MBED_ENABLED)
 int netif_get_idx(struct netif *pnetif)
 {
 #if (CONFIG_LWIP_LAYER == 1)
@@ -532,6 +531,8 @@ int netif_get_idx(struct netif *pnetif)
 		return 0;
 	case 1:
 		return 1;
+	case 2:
+		return 2;
 	default:
 		return -1;
 	}
@@ -540,7 +541,6 @@ int netif_get_idx(struct netif *pnetif)
 	return -1;
 #endif
 }
-#endif
 
 void LwIP_netif_set_up(uint8_t idx)
 {
@@ -558,12 +558,19 @@ void LwIP_netif_set_link_up(uint8_t idx)
 {
 	struct netif *pnetif = &xnetif[idx];
 	netifapi_netif_set_link_up(pnetif);
+	if (idx == SOFTAP_WLAN_INDEX) {
+		/*need modify the default netif to the interface you want to use to send broadcast packtes in concurrent mode*/
+		netifapi_netif_set_default(&xnetif[SOFTAP_WLAN_INDEX]);
+	}
 }
 
 void LwIP_netif_set_link_down(uint8_t idx)
 {
 	struct netif *pnetif = &xnetif[idx];
 	netifapi_netif_set_link_down(pnetif);
+	if (idx == SOFTAP_WLAN_INDEX) {
+		netifapi_netif_set_default(&xnetif[STA_WLAN_INDEX]);
+	}
 }
 
 uint8_t *LwIP_GetMAC(uint8_t idx)
diff --git a/os/board/rtl8720e/src/component/lwip/api/lwip_netconf.h b/os/board/rtl8720e/src/component/lwip/api/lwip_netconf.h
old mode 100644
new mode 100755
index 8acb83332..bdf4c9fdf
--- a/os/board/rtl8720e/src/component/lwip/api/lwip_netconf.h
+++ b/os/board/rtl8720e/src/component/lwip/api/lwip_netconf.h
@@ -16,9 +16,8 @@ extern "C" {
 #endif
 
 /* Includes ------------------------------------------------------------------*/
-#include <platform_stdlib.h>
 #include "platform_opts.h"
-#include "autoconf.h"
+#include "rtw_wifi_constants.h"
 #include "lwipconf.h"
 #include "lwip/netifapi.h"
 // macros
diff --git a/os/board/rtl8720e/src/component/lwip/api/lwipopts.h b/os/board/rtl8720e/src/component/lwip/api/lwipopts.h
old mode 100644
new mode 100755
index 4e83bf60c..ef5d07f5e
--- a/os/board/rtl8720e/src/component/lwip/api/lwipopts.h
+++ b/os/board/rtl8720e/src/component/lwip/api/lwipopts.h
@@ -105,6 +105,7 @@ a lot of data that needs to be copied, this should be set high. */
 /* PBUF_POOL_SIZE: the number of buffers in the pbuf pool. */
 #if WIFI_LOGO_CERTIFICATION_CONFIG
 #define PBUF_POOL_SIZE          60 //for ping 10k test
+#define ARP_MAXAGE			720// modify 5min to 12min, for wifi6 logo 5.64.1 AP not response arp request in step10
 #define IP_REASS_MAXAGE		1
 #elif defined(ENABLE_AMAZON_COMMON)
 #define PBUF_POOL_SIZE          30
@@ -277,8 +278,7 @@ extern unsigned int sys_now(void);
 #endif
 #endif
 
-#if (defined(SUPPORT_UART_LOG_SERVICE) && (SUPPORT_UART_LOG_SERVICE)) \
-    || (defined(CONFIG_EXAMPLE_SPI_ATCMD) && (CONFIG_EXAMPLE_SPI_ATCMD))
+#if (defined(SUPPORT_UART_LOG_SERVICE) && (SUPPORT_UART_LOG_SERVICE))
 #undef  LWIP_SO_SNDTIMEO
 #define LWIP_SO_SNDTIMEO                        1
 
diff --git a/os/board/rtl8720e/src/component/network/coap/include/sn_coap_ameba_port.h b/os/board/rtl8720e/src/component/network/coap/include/sn_coap_ameba_port.h
old mode 100644
new mode 100755
index e8b9a6568..842529124
--- a/os/board/rtl8720e/src/component/network/coap/include/sn_coap_ameba_port.h
+++ b/os/board/rtl8720e/src/component/network/coap/include/sn_coap_ameba_port.h
@@ -12,7 +12,7 @@
 #include "diag.h"
 #include "platform_stdlib.h"
 #include "osdep_service.h"
-#include "wifi_constants.h"
+#include "rtw_wifi_constants.h"
 #include "wifi_conf.h"
 #include <lwipconf.h>
 #include <stdint.h>
diff --git a/os/board/rtl8720e/src/component/network/dhcp/dhcps.c b/os/board/rtl8720e/src/component/network/dhcp/dhcps.c
old mode 100644
new mode 100755
index 76c5240c6..3019e933f
--- a/os/board/rtl8720e/src/component/network/dhcp/dhcps.c
+++ b/os/board/rtl8720e/src/component/network/dhcp/dhcps.c
@@ -1,7 +1,7 @@
 
 #include "dhcps.h"
 #include "tcpip.h"
-#include "wifi_constants.h"
+#include "rtw_wifi_constants.h"
 #include "lwip_netconf.h"
 //static struct dhcp_server_state dhcp_server_state_machine;
 static uint8_t dhcp_server_state_machine = DHCP_SERVER_STATE_IDLE;
@@ -76,7 +76,7 @@ static void mark_ip_in_table(uint8_t d)
 		printf("\r\n ip_table.ip_range[3] = 0x%x\r\n", ip_table.ip_range[3]);
 #endif
 	} else if (128 < d && d <= 160) {
-		ip_table.ip_range[4] = MARK_RANGE5_IP_BIT(ip_table, d);
+		ip_table.ip_range[4] = MARK_RANGE5_IP_BIT(ip_table, d - 128);
 #if (debug_dhcps)
 		printf("\r\n ip_table.ip_range[4] = 0x%x\r\n", ip_table.ip_range[4]);
 #endif
@@ -888,11 +888,11 @@ static void dhcps_receive_udp_packet_handler(void *arg, struct udp_pcb *udp_pcb,
 	int16_t total_length_of_packet_buffer;
 	struct pbuf *merged_packet_buffer = NULL;
 
-	dhcp_message_repository = (struct dhcp_msg *)udp_packet_buffer->payload;
 	if (udp_packet_buffer == NULL) {
 		printf("\n\r Error!!!! System doesn't allocate any buffer \n\r");
 		return;
 	}
+	dhcp_message_repository = (struct dhcp_msg *)udp_packet_buffer->payload;
 	if (sender_port == DHCP_CLIENT_PORT) {
 		if (netif_get_idx(ip_current_input_netif()) == 0) {
 			pbuf_free(udp_packet_buffer);
@@ -1174,12 +1174,7 @@ void dhcps_init(struct netif *pnetif)
 	dhcps_num_of_available_ips = ((ntohl(dhcps_owned_last_ip.addr)
 								   - ntohl(dhcps_owned_first_ip.addr)) + 1);
 #endif
-#endif
 
-#if (defined(CONFIG_EXAMPLE_UART_ATCMD) && CONFIG_EXAMPLE_UART_ATCMD) || (defined(CONFIG_EXAMPLE_SPI_ATCMD) && CONFIG_EXAMPLE_SPI_ATCMD)
-#if IP_SOF_BROADCAST
-	dhcps_pcb->so_options |= SOF_BROADCAST;
-#endif /* IP_SOF_BROADCAST */
 #endif
 
 #if IS_USE_FIXED_IP
diff --git a/os/board/rtl8720e/src/component/network/dhcp/dhcps.h b/os/board/rtl8720e/src/component/network/dhcp/dhcps.h
old mode 100644
new mode 100755
index 19e812d49..7c1517626
--- a/os/board/rtl8720e/src/component/network/dhcp/dhcps.h
+++ b/os/board/rtl8720e/src/component/network/dhcp/dhcps.h
@@ -2,12 +2,9 @@
 #ifndef __DHCPS_H__
 #define __DHCPS_H__
 #include "lwipconf.h"
-#include "autoconf.h"
-#include "wifi_structures.h"
+#include "rtw_wifi_constants.h"
 #include "wifi_conf.h"
 
-#include <platform_stdlib.h>
-
 #define CONFIG_DHCPS_KEPT_CLIENT_INFO
 
 #define DHCP_POOL_START			100
diff --git a/os/board/rtl8720e/src/component/network/httpc/httpc.h b/os/board/rtl8720e/src/component/network/httpc/httpc.h
old mode 100644
new mode 100755
index e504d8e9b..c0842c754
--- a/os/board/rtl8720e/src/component/network/httpc/httpc.h
+++ b/os/board/rtl8720e/src/component/network/httpc/httpc.h
@@ -31,11 +31,6 @@
 #define HTTPC_DEBUG_ON           1    /*!< Enable httpc debug log */
 #define HTTPC_DEBUG_VERBOSE      2    /*!< Enable httpc verbose debug log */
 
-#define HTTPC_TLS_POLARSSL       0    /*!< Use PolarSSL for TLS when HTTPS */
-#define HTTPC_TLS_MBEDTLS        1    /*!< Use mbedTLS for TLS when HTTPS */
-
-#define HTTPC_USE_TLS            HTTPC_TLS_MBEDTLS
-
 /**
   * @brief  The structure is the context used for HTTP response header parsing.
   * @note   Only header string includes string terminator.
diff --git a/os/board/rtl8720e/src/component/network/httpc/httpc_tls.c b/os/board/rtl8720e/src/component/network/httpc/httpc_tls.c
old mode 100644
new mode 100755
index 08b9973a8..cf65e8c31
--- a/os/board/rtl8720e/src/component/network/httpc/httpc_tls.c
+++ b/os/board/rtl8720e/src/component/network/httpc/httpc_tls.c
@@ -19,33 +19,7 @@ int httpc_setsockopt_rcvtimeo(struct httpc_conn *conn, int recv_timeout)
 	return ret;
 }
 
-#if (HTTPC_USE_TLS == HTTPC_TLS_POLARSSL)
-#include "polarssl/ssl.h"
-#include "polarssl/memory.h"
-#include "polarssl/base64.h"
 
-struct httpc_tls {
-	ssl_context ctx;                 /*!< Context for PolarSSL */
-	x509_crt ca;                     /*!< CA certificates */
-	x509_crt cert;                   /*!< Certificate */
-	pk_context key;                  /*!< Private key */
-};
-
-static int _verify_func(void *data, x509_crt *crt, int depth, int *flags)
-{
-	char buf[1024];
-	x509_crt_info(buf, sizeof(buf) - 1, "", crt);
-
-	if (*flags) {
-		printf("\n[HTTPC] ERROR: certificate verify\n%s\n", buf);
-	} else {
-		printf("\n[HTTPC] Certificate verified\n%s\n", buf);
-	}
-
-	return 0;
-}
-
-#elif (HTTPC_USE_TLS == HTTPC_TLS_MBEDTLS)
 #include "mbedtls/ssl.h"
 #include "mbedtls/platform.h"
 #include "mbedtls/net_sockets.h"
@@ -101,7 +75,6 @@ static void *_calloc_func(size_t nmemb, size_t size)
 
 	return ptr;
 }
-#endif /* HTTPC_USE_POLARSSL */
 
 static int _random_func(void *p_rng, unsigned char *output, size_t output_len)
 {
@@ -114,80 +87,6 @@ static int _random_func(void *p_rng, unsigned char *output, size_t output_len)
 
 void *httpc_tls_new(int *sock, char *client_cert, char *client_key, char *ca_certs)
 {
-#if (HTTPC_USE_TLS == HTTPC_TLS_POLARSSL)
-	int ret = 0;
-	struct httpc_tls *tls = NULL;
-
-	memory_set_own(pvPortMalloc, vPortFree);
-	tls = (struct httpc_tls *) malloc(sizeof(struct httpc_tls));
-
-	if (tls) {
-		ssl_context *ssl = &tls->ctx;
-
-		memset(tls, 0, sizeof(struct httpc_tls));
-		x509_crt_init(&tls->ca);
-		x509_crt_init(&tls->cert);
-		pk_init(&tls->key);
-		if ((ret = ssl_init(ssl)) != 0) {
-			printf("\n[HTTPC] ERROR: ssl_init %d\n", ret);
-			ret = -1;
-			goto exit;
-		}
-		ssl_set_endpoint(ssl, SSL_IS_CLIENT);
-		ssl_set_authmode(ssl, SSL_VERIFY_NONE);
-		ssl_set_rng(ssl, _random_func, NULL);
-		ssl_set_bio(ssl, net_recv, sock, net_send, sock);
-
-		if (client_cert && client_key) {
-			if ((ret = x509_crt_parse(&tls->cert, (const unsigned char *) client_cert, strlen(client_cert))) != 0) {
-				printf("\n[HTTPC] ERROR: x509_crt_parse %d\n", ret);
-				ret = -1;
-				goto exit;
-			}
-
-			if ((ret = pk_parse_key(&tls->key, (const unsigned char *) client_key, strlen(client_key), NULL, 0)) != 0) {
-				printf("\n[HTTPC] ERROR: pk_parse_key %d\n", ret);
-				ret = -1;
-				goto exit;
-			}
-
-			if ((ret = ssl_set_own_cert(ssl, &tls->cert, &tls->key)) != 0) {
-				printf("\n[HTTPC] ERROR: ssl_set_own_cert %d\n", ret);
-				ret = -1;
-				goto exit;
-			}
-		}
-
-		if (ca_certs) {
-			// set trusted ca certificates next to client certificate
-			if ((ret = x509_crt_parse(&tls->ca, (const unsigned char *) ca_certs, strlen(ca_certs))) != 0) {
-				printf("\n[HTTPC] ERROR: x509_crt_parse %d\n", ret);
-				ret = -1;
-				goto exit;
-			}
-
-			ssl_set_ca_chain(ssl, &tls->ca, NULL, NULL);
-			ssl_set_authmode(ssl, SSL_VERIFY_REQUIRED);
-			ssl_set_verify(ssl, _verify_func, NULL);
-		}
-	} else {
-		printf("\n[HTTPC] ERROR: malloc\n");
-		ret = -1;
-		goto exit;
-	}
-
-exit:
-	if (ret && tls) {
-		ssl_free(&tls->ctx);
-		x509_crt_free(&tls->ca);
-		x509_crt_free(&tls->cert);
-		pk_free(&tls->key);
-		free(tls);
-		tls = NULL;
-	}
-
-	return (void *) tls;
-#elif (HTTPC_USE_TLS == HTTPC_TLS_MBEDTLS)
 	int ret = 0;
 	struct httpc_tls *tls = NULL;
 
@@ -315,20 +214,12 @@ exit:
 	}
 
 	return (void *) tls;
-#endif
 }
 
 void httpc_tls_free(void *tls_in)
 {
 	struct httpc_tls *tls = (struct httpc_tls *) tls_in;
 
-#if (HTTPC_USE_TLS == HTTPC_TLS_POLARSSL)
-	ssl_free(&tls->ctx);
-	x509_crt_free(&tls->ca);
-	x509_crt_free(&tls->cert);
-	pk_free(&tls->key);
-	free(tls);
-#elif (HTTPC_USE_TLS == HTTPC_TLS_MBEDTLS)
 	mbedtls_ssl_free(&tls->ctx);
 	mbedtls_ssl_config_free(&tls->conf);
 	mbedtls_x509_crt_free(&tls->ca);
@@ -342,27 +233,11 @@ void httpc_tls_free(void *tls_in)
 #endif
 
 	free(tls);
-#endif
 }
 
 int httpc_tls_handshake(void *tls_in, char *host)
 {
 	struct httpc_tls *tls = (struct httpc_tls *) tls_in;
-
-#if (HTTPC_USE_TLS == HTTPC_TLS_POLARSSL)
-	int ret = 0;
-
-	ssl_set_hostname(&tls->ctx, host);
-
-	if ((ret = ssl_handshake(&tls->ctx)) != 0) {
-		printf("\n[HTTPC] ERROR: ssl_handshake %d\n", ret);
-		ret = -1;
-	} else {
-		printf("\n[HTTPC] Use ciphersuite %s\n", ssl_get_ciphersuite(&tls->ctx));
-	}
-
-	return ret;
-#elif (HTTPC_USE_TLS == HTTPC_TLS_MBEDTLS)
 	int ret = 0;
 
 	mbedtls_ssl_set_hostname(&tls->ctx, host);
@@ -375,54 +250,31 @@ int httpc_tls_handshake(void *tls_in, char *host)
 	}
 
 	return ret;
-#endif
 }
 
 void httpc_tls_close(void *tls_in)
 {
 	struct httpc_tls *tls = (struct httpc_tls *) tls_in;
 
-#if (HTTPC_USE_TLS == HTTPC_TLS_POLARSSL)
-	ssl_close_notify(&tls->ctx);
-#elif (HTTPC_USE_TLS == HTTPC_TLS_MBEDTLS)
 	mbedtls_ssl_close_notify(&tls->ctx);
-#endif
 }
 
 int httpc_tls_read(void *tls_in, uint8_t *buf, size_t buf_len)
 {
 	struct httpc_tls *tls = (struct httpc_tls *) tls_in;
 
-#if (HTTPC_USE_TLS == HTTPC_TLS_POLARSSL)
-	return ssl_read(&tls->ctx, buf, buf_len);
-#elif (HTTPC_USE_TLS == HTTPC_TLS_MBEDTLS)
 	return mbedtls_ssl_read(&tls->ctx, buf, buf_len);
-#endif
 }
 
 int httpc_tls_write(void *tls_in, uint8_t *buf, size_t buf_len)
 {
 	struct httpc_tls *tls = (struct httpc_tls *) tls_in;
 
-#if (HTTPC_USE_TLS == HTTPC_TLS_POLARSSL)
-	return ssl_write(&tls->ctx, buf, buf_len);
-#elif (HTTPC_USE_TLS == HTTPC_TLS_MBEDTLS)
 	return mbedtls_ssl_write(&tls->ctx, buf, buf_len);
-#endif
 }
 
 int httpc_base64_encode(uint8_t *data, size_t data_len, char *base64_buf, size_t buf_len)
 {
-#if (HTTPC_USE_TLS == HTTPC_TLS_POLARSSL)
-	int ret = 0;
-
-	if ((ret = base64_encode(base64_buf, &buf_len, data, data_len)) != 0) {
-		printf("\n[HTTPC] ERROR: base64_encode %d\n", ret);
-		ret = -1;
-	}
-
-	return ret;
-#elif (HTTPC_USE_TLS == HTTPC_TLS_MBEDTLS)
 	int ret = 0;
 	size_t output_len = 0;
 
@@ -432,14 +284,10 @@ int httpc_base64_encode(uint8_t *data, size_t data_len, char *base64_buf, size_t
 	}
 
 	return ret;
-#endif
 }
 
 int httpc_tls_set_ciphersuites(struct httpc_conn *conn, int *ciphersuites)
 {
-#if (HTTPC_USE_TLS == HTTPC_TLS_POLARSSL)
-	return -1;
-#elif (HTTPC_USE_TLS == HTTPC_TLS_MBEDTLS)
 	mbedtls_ssl_context *ssl_ctx = (mbedtls_ssl_context *) conn->tls;
 
 	if (ssl_ctx) {
@@ -452,5 +300,4 @@ int httpc_tls_set_ciphersuites(struct httpc_conn *conn, int *ciphersuites)
 	}
 
 	return -1;
-#endif
 }
diff --git a/os/board/rtl8720e/src/component/network/iperf/iperf.c b/os/board/rtl8720e/src/component/network/iperf/iperf.c
old mode 100644
new mode 100755
index c5484949f..73b213b38
--- a/os/board/rtl8720e/src/component/network/iperf/iperf.c
+++ b/os/board/rtl8720e/src/component/network/iperf/iperf.c
@@ -1,10 +1,9 @@
-#include "freertos_service.h"
+#include "osdep_service.h"
 #include "task.h"
 #include "main.h"
-#include "osdep_service.h"
+#include "lwip/sockets.h"
 
 #include <lwipconf.h>
-#include <platform_stdlib.h>
 #if defined(CONFIG_AS_INIC_AP)
 #define BSD_STACK_SIZE		    1024
 #else
@@ -48,6 +47,8 @@ struct iperf_data_t {
 	//uint8_t  terminate;
 	uint8_t  bidirection;
 	uint16_t  is_sub_stream; //Byte[1] : this client stream is created by bidirection parameter, Byte[0] : main stream id
+	struct iperf_data_t *prev;
+	struct iperf_data_t *next;
 };
 
 struct iperf_tcp_client_hdr {
@@ -92,6 +93,7 @@ struct iperf_udp_server_hdr {
 
 uint8_t g_is_iperf_init = 0;
 struct stream_id_t g_stream_id[MULTI_STREAM_NUM];
+struct iperf_data_t *stream_data_head = NULL;
 
 _mutex g_tptest_log_mutex = NULL;
 _mutex g_tptest_mutex = NULL;
@@ -159,24 +161,26 @@ struct iperf_data_t *init_stream_data(uint8_t protocol, uint8_t role)
 {
 	int8_t i = 0, stream_id = -1;
 	struct iperf_data_t *stream_data = NULL;
+	struct iperf_data_t *stream_data_tail = NULL;
 
 	for (i = 0; i < MULTI_STREAM_NUM; i++) {
 		if (g_stream_id[i].id_used == 0) {
 			g_stream_id[i].id_used = 1;
+			g_stream_id[i].terminate = 0;
 			stream_id = i;
 			break;
 		}
 	}
 
 	if (stream_id == -1) {
-		tptest_res_log("\n\r[ERROR] stream reach limit(%d)!\n", MULTI_STREAM_NUM);
+		tptest_res_log("\n\r[ERROR] stream reach limit(%d)!\n\r", MULTI_STREAM_NUM);
 		return NULL;
 	}
 
 	stream_data = pvPortMalloc(sizeof(struct iperf_data_t));
 	if (!stream_data) {
 		g_stream_id[stream_id].id_used = 0;
-		tptest_res_log("\n\r[ERROR] stream_data allocate failed!\n");
+		tptest_res_log("\n\r[ERROR] stream_data allocate failed!\n\r");
 		return NULL;
 	}
 
@@ -198,6 +202,21 @@ struct iperf_data_t *init_stream_data(uint8_t protocol, uint8_t role)
 		stream_data->bandwidth = DEFAULT_UDP_BANDWIDTH;
 		stream_data->tos_value = DEFAULT_UDP_TOS_VALUE;
 	}
+
+	if (stream_data_head == NULL) {
+		stream_data_head = stream_data;
+		stream_data_head->prev = NULL;
+		stream_data_head->next = NULL;
+	} else {
+		stream_data_tail = stream_data_head;
+		while (stream_data_tail->next != NULL) {
+			stream_data_tail = stream_data_tail->next;
+		}
+		stream_data_tail->next = stream_data;
+		stream_data->prev = stream_data_tail;
+		stream_data->next = NULL;
+	}
+
 	return stream_data;
 }
 
@@ -205,6 +224,19 @@ struct iperf_data_t *init_stream_data(uint8_t protocol, uint8_t role)
 void free_stream_data(struct iperf_data_t *stream_data)
 {
 	if (stream_data) {
+
+		if (stream_data == stream_data_head) {
+			stream_data_head = stream_data_head->next;
+			if (stream_data_head != NULL) {
+				stream_data_head->prev = NULL;
+			}
+		} else if (stream_data->next != NULL) {
+			(stream_data->next)->prev = stream_data->prev;
+			(stream_data->prev)->next = stream_data->next;
+		} else {
+			(stream_data->prev)->next = NULL;
+		}
+
 		g_stream_id[stream_data->stream_id].id_used = 0;
 		g_stream_id[stream_data->stream_id].terminate = 0;
 		vPortFree(stream_data);
@@ -261,7 +293,7 @@ int tcp_client_func(struct iperf_data_t iperf_data)
 
 	tcp_client_buffer = pvPortMalloc(iperf_data.buf_size);
 	if (!tcp_client_buffer) {
-		tptest_res_log("\n\r[ERROR] %s: Alloc buffer failed", __func__);
+		tptest_res_log("\n\r[ERROR] %s: Alloc buffer failed\n\r", __func__);
 		goto exit2;
 	}
 
@@ -272,7 +304,7 @@ int tcp_client_func(struct iperf_data_t iperf_data)
 
 	//create socket
 	if ((iperf_data.client_fd = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP)) < 0) {
-		tptest_res_log("\n\r[ERROR] %s: Create TCP socket failed", __func__);
+		tptest_res_log("\n\r[ERROR] %s: Create TCP socket failed\n\r", __func__);
 		goto exit2;
 	}
 
@@ -282,15 +314,15 @@ int tcp_client_func(struct iperf_data_t iperf_data)
 	ser_addr.sin_port = htons(iperf_data.port);
 	ser_addr.sin_addr.s_addr = inet_addr((char const *)iperf_data.server_ip);
 
-	tptest_res_log("\n\r%s: Server IP=%s, port=%d", __func__, iperf_data.server_ip, iperf_data.port);
-	tptest_res_log("\n\r%s: Create socket fd = %d", __func__, iperf_data.client_fd);
+	tptest_res_log("%s: Server IP=%s, port=%d\n\r", __func__, iperf_data.server_ip, iperf_data.port);
+	tptest_res_log("%s: Create socket fd = %d\n\r", __func__, iperf_data.client_fd);
 
 	//Connecting to server
 	if (connect(iperf_data.client_fd, (struct sockaddr *)&ser_addr, sizeof(ser_addr)) < 0) {
-		tptest_res_log("\n\r[ERROR] %s: Connect to server failed", __func__);
+		tptest_res_log("\n\r[ERROR] %s: Connect to server failed\n\r", __func__);
 		goto exit1;
 	}
-	tptest_res_log("\n\r%s: Connect to server successfully", __func__);
+	tptest_res_log("%s: Connect to server successfully\n\r", __func__);
 
 	// For "iperf -d" command, send first packet with iperf client header
 	if (iperf_data.bidirection) {
@@ -301,7 +333,7 @@ int tcp_client_func(struct iperf_data_t iperf_data)
 		client_hdr.mWinband = 0;
 		client_hdr.mAmount = htonl(~(iperf_data.time * 100) + 1);
 		if (send(iperf_data.client_fd, (char *) &client_hdr, sizeof(client_hdr), 0) <= 0) {
-			tptest_res_log("\n\r[ERROR] %s: TCP client send data error", __func__);
+			tptest_res_log("\n\r[ERROR] %s: TCP client send data error\n\r", __func__);
 			goto exit1;
 		}
 	}
@@ -313,7 +345,7 @@ int tcp_client_func(struct iperf_data_t iperf_data)
 		report_start_time = start_time;
 		while (((end_time - start_time) <= (configTICK_RATE_HZ * iperf_data.time)) && (!g_stream_id[iperf_data.stream_id].terminate)) {
 			if (send(iperf_data.client_fd, tcp_client_buffer, iperf_data.buf_size, 0) <= 0) {
-				tptest_res_log("\n\r[ERROR] %s: TCP client send data error", __func__);
+				tptest_res_log("\n\r[ERROR] %s: TCP client send data error\n\r", __func__);
 				goto exit1;
 			}
 			total_size += iperf_data.buf_size;
@@ -329,7 +361,7 @@ int tcp_client_func(struct iperf_data_t iperf_data)
 			}
 
 			if ((iperf_data.report_interval != DEFAULT_REPORT_INTERVAL) && ((end_time - report_start_time) >= (configTICK_RATE_HZ * iperf_data.report_interval))) {
-				tptest_res_log("\n\rtcp_c: id[%d] Send %d KBytes in %d ms, %d Kbits/sec", iperf_data.stream_id, (int)(report_size / KB), (int)(end_time - report_start_time),
+				tptest_res_log("tcp_c: id[%d] Send %d KBytes in %d ms, %d Kbits/sec\n\r", iperf_data.stream_id, (int)(report_size / KB), (int)(end_time - report_start_time),
 							   (int)((report_size * 8) / (end_time - report_start_time)));
 				report_start_time = end_time;
 				bandwidth_time = end_time;
@@ -344,7 +376,7 @@ int tcp_client_func(struct iperf_data_t iperf_data)
 		report_start_time = start_time;
 		while ((total_size < iperf_data.total_size) && (!g_stream_id[iperf_data.stream_id].terminate)) {
 			if (send(iperf_data.client_fd, tcp_client_buffer, iperf_data.buf_size, 0) <= 0) {
-				tptest_res_log("\n\r[ERROR] %s: TCP client send data error", __func__);
+				tptest_res_log("\n\r[ERROR] %s: TCP client send data error\n\r", __func__);
 				goto exit1;
 			}
 			total_size += iperf_data.buf_size;
@@ -360,7 +392,7 @@ int tcp_client_func(struct iperf_data_t iperf_data)
 			}
 
 			if ((iperf_data.report_interval != DEFAULT_REPORT_INTERVAL) && ((end_time - report_start_time) >= (configTICK_RATE_HZ * iperf_data.report_interval))) {
-				tptest_res_log("\n\rtcp_c: id[%d] Send %d KBytes in %d ms, %d Kbits/sec", iperf_data.stream_id, (int)(report_size / KB), (int)(end_time - report_start_time),
+				tptest_res_log("tcp_c: id[%d] Send %d KBytes in %d ms, %d Kbits/sec\n\r", iperf_data.stream_id, (int)(report_size / KB), (int)(end_time - report_start_time),
 							   (int)((report_size * 8) / (end_time - report_start_time)));
 				report_start_time = end_time;
 				bandwidth_time = end_time;
@@ -370,13 +402,17 @@ int tcp_client_func(struct iperf_data_t iperf_data)
 		}
 	}
 
+	if (g_stream_id[iperf_data.stream_id].terminate) {
+		tptest_res_log("TCP Client terminated\n\r");
+	}
+
 	if (iperf_data.is_sub_stream && SUBSTREAM_FLAG) {
 		//This stream is created by bidirectional parameter
-		tptest_res_log("\n\rtcp_c: [END] id[%d] Bidirection Totally send %d KBytes in %d ms, %d Kbits/sec", iperf_data.is_sub_stream & 0xff, (int)(total_size / KB),
+		tptest_res_log("tcp_c: [END] id[%d] Bidirection Totally send %d KBytes in %d ms, %d Kbits/sec\n\r", iperf_data.is_sub_stream & 0xff, (int)(total_size / KB),
 					   (int)(end_time - start_time),
 					   (int)((total_size * 8) / (end_time - start_time)));
 	} else {
-		tptest_res_log("\n\rtcp_c: [END] id[%d] Totally send %d KBytes in %d ms, %d Kbits/sec", iperf_data.stream_id, (int)(total_size / KB),
+		tptest_res_log("tcp_c: [END] id[%d] Totally send %d KBytes in %d ms, %d Kbits/sec\n\r", iperf_data.stream_id, (int)(total_size / KB),
 					   (int)(end_time - start_time),
 					   (int)((total_size * 8) / (end_time - start_time)));
 	}
@@ -384,7 +420,7 @@ int tcp_client_func(struct iperf_data_t iperf_data)
 exit1:
 	closesocket(iperf_data.client_fd);
 exit2:
-	tptest_res_log("\n\r%s: Close client socket", __func__);
+	tptest_res_log("%s: Close client socket\n\r", __func__);
 	if (tcp_client_buffer) {
 		vPortFree(tcp_client_buffer);
 		tcp_client_buffer = NULL;
@@ -404,20 +440,23 @@ int tcp_server_func(struct iperf_data_t iperf_data)
 	struct iperf_tcp_client_hdr client_hdr;
 	char *tcp_server_buffer = NULL;
 	struct iperf_data_t *tcp_client_data = NULL;
+	int socket_connect = 0;
+	fd_set read_fds;
+	struct timeval select_timeout;
 
 	tcp_server_buffer = pvPortMalloc(iperf_data.buf_size);
 	if (!tcp_server_buffer) {
-		tptest_res_log("\n\r[ERROR] %s: Alloc buffer failed", __func__);
-		goto exit4;
+		tptest_res_log("\n\r[ERROR] %s: Alloc buffer failed\n\r", __func__);
+		goto exit3;
 	}
 
 	//create socket
 	if ((iperf_data.server_fd = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP)) < 0) {
-		tptest_res_log("\n\r[ERROR] %s: Create socket failed", __func__);
-		goto exit4;
+		tptest_res_log("\n\r[ERROR] %s: Create socket failed\n\r", __func__);
+		goto exit3;
 	}
 
-	tptest_res_log("\n\r%s: Create socket fd = %d", __func__, iperf_data.server_fd);
+	tptest_res_log("%s: Create socket fd = %d\n\r", __func__, iperf_data.server_fd);
 
 	setsockopt(iperf_data.server_fd, SOL_SOCKET, SO_REUSEADDR, (const char *) &n, sizeof(n));
 
@@ -429,24 +468,38 @@ int tcp_server_func(struct iperf_data_t iperf_data)
 
 	// binding the TCP socket to the TCP server address
 	if (bind(iperf_data.server_fd, (struct sockaddr *)&ser_addr, sizeof(ser_addr)) < 0) {
-		tptest_res_log("\n\r[ERROR] %s: Bind socket failed", __func__);
-		goto exit3;
+		tptest_res_log("\n\r[ERROR] %s: Bind socket failed\n\r", __func__);
+		goto exit2;
 	}
-	tptest_res_log("\n\r%s: Bind socket successfully", __func__);
+	tptest_res_log("%s: Bind socket successfully\n\r", __func__);
 
 	//Make it listen to socket with max 20 connections
 	if (listen(iperf_data.server_fd, 20) != 0) {
-		tptest_res_log("\n\r[ERROR] %s: Listen socket failed", __func__);
-		goto exit3;
+		tptest_res_log("\n\r[ERROR] %s: Listen socket failed\n\r", __func__);
+		goto exit2;
 	}
-	tptest_res_log("\n\r%s: Listen port %d", __func__, iperf_data.port);
-
-//Restart:
-	if ((iperf_data.client_fd = accept(iperf_data.server_fd, (struct sockaddr *)&client_addr, (u32_t *)&addrlen)) < 0) {
-		tptest_res_log("\n\r[ERROR] %s: Accept TCP client socket error!", __func__);
-		goto exit3;
+	tptest_res_log("%s: Listen port %d\n\r", __func__, iperf_data.port);
+
+	select_timeout.tv_sec = 0;
+	select_timeout.tv_usec = 500000; //500ms
+
+	while (!socket_connect && !g_stream_id[iperf_data.stream_id].terminate) {
+		FD_ZERO(&read_fds);
+		FD_SET(iperf_data.server_fd, &read_fds);
+		if (select(iperf_data.server_fd + 1, &read_fds, NULL, NULL, &select_timeout)) {
+			if (FD_ISSET(iperf_data.server_fd, &read_fds)) {
+				if ((iperf_data.client_fd = accept(iperf_data.server_fd, (struct sockaddr *)&client_addr, (u32_t *)&addrlen)) < 0) {
+					tptest_res_log("\n\r[ERROR] %s: Accept TCP client socket error!\n\r", __func__);
+					goto exit2;
+				}
+				socket_connect = 1;
+				tptest_res_log("%s: Accept connection successfully\n\r", __func__);
+			}
+		}
+	}
+	if (g_stream_id[iperf_data.stream_id].terminate) {
+		goto exit2;
 	}
-	tptest_res_log("\n\r%s: Accept connection successfully", __func__);
 
 	recv_size = recv(iperf_data.client_fd, tcp_server_buffer, iperf_data.buf_size, 0);
 	if (!iperf_data.bidirection) { //Server
@@ -457,8 +510,8 @@ int tcp_server_func(struct iperf_data_t iperf_data)
 			tcp_client_data = init_stream_data('t', 'c');
 			rtw_mutex_put(&g_tptest_mutex);
 			if (tcp_client_data == NULL) {
-				tptest_res_log("\n\r[ERROR] init_stream_data failed!\n");
-				goto exit2;
+				tptest_res_log("\n\r[ERROR] init_stream_data failed!\n\r");
+				goto exit1;
 			}
 			if (client_hdr.mAmount != 0) {
 				client_hdr.mAmount = ntohl(client_hdr.mAmount);
@@ -477,7 +530,10 @@ int tcp_server_func(struct iperf_data_t iperf_data)
 
 			if (xTaskCreate(iperf_test_handler, "iperf_test_handler", BSD_STACK_SIZE, (void *) tcp_client_data, tskIDLE_PRIORITY + 1 + PRIORITIE_OFFSET,
 							&tcp_client_data->task) != pdPASS) {
-				tptest_res_log("\n\rTCP ERROR: Create TCP client task failed.");
+				tptest_res_log("\n\rTCP ERROR: Create TCP client task failed.\n\r");
+				rtw_mutex_get(&g_tptest_mutex);
+				free_stream_data(tcp_client_data);
+				rtw_mutex_put(&g_tptest_mutex);
 				goto exit1;
 			}
 		}
@@ -489,10 +545,10 @@ int tcp_server_func(struct iperf_data_t iperf_data)
 	while (!g_stream_id[iperf_data.stream_id].terminate) {
 		recv_size = recv(iperf_data.client_fd, tcp_server_buffer, iperf_data.buf_size, 0);  //MSG_DONTWAIT   MSG_WAITALL
 		if (recv_size < 0) {
-			tptest_res_log("\n\r[ERROR] %s: Receive data failed", __func__);
-			goto exit2;
+			tptest_res_log("\n\r[ERROR] %s: Receive data failed\n\r", __func__);
+			goto exit1;
 		} else if (recv_size == 0) {
-			//tptest_res_log("\n\r%s: [END] Totally receive %d KBytes in %d ms, %d Kbits/sec",__func__, (uint32_t) (total_size/KB),(uint32_t) (end_time-start_time),((uint32_t) (total_size*8)/(end_time - start_time)));
+			//tptest_res_log("%s: [END] Totally receive %d KBytes in %d ms, %d Kbits/sec\n\r",__func__, (uint32_t) (total_size/KB),(uint32_t) (end_time-start_time),((uint32_t) (total_size*8)/(end_time - start_time)));
 			//total_size=0;
 			//close(iperf_data.client_fd);
 			//goto Restart;
@@ -502,31 +558,31 @@ int tcp_server_func(struct iperf_data_t iperf_data)
 		total_size += recv_size;
 		report_size += recv_size;
 		if ((iperf_data.report_interval != DEFAULT_REPORT_INTERVAL) && ((end_time - report_start_time) >= (configTICK_RATE_HZ * iperf_data.report_interval))) {
-			tptest_res_log("\n\rtcp_s: id[%d] Receive %d KBytes in %d ms, %d Kbits/sec", iperf_data.stream_id, (int)(report_size / KB), (int)(end_time - report_start_time),
+			tptest_res_log("tcp_s: id[%d] Receive %d KBytes in %d ms, %d Kbits/sec\n\r", iperf_data.stream_id, (int)(report_size / KB), (int)(end_time - report_start_time),
 						   (int)((report_size * 8) / (end_time - report_start_time)));
 			report_start_time = end_time;
 			report_size = 0;
 		}
 	}
 
-	tptest_res_log("\n\rtcp_s: [END] id[%d] Totally receive %d KBytes in %d ms, %d Kbits/sec", iperf_data.stream_id, (int)(total_size / KB),
-				   (int)(end_time - start_time),
-				   (int)((total_size * 8) / (end_time - start_time)));
+	if (total_size != 0) {
+		tptest_res_log("tcp_s: [END] id[%d] Totally receive %d KBytes in %d ms, %d Kbits/sec\n\r", iperf_data.stream_id, (int)(total_size / KB),
+					   (int)(end_time - start_time),
+					   (int)((total_size * 8) / (end_time - start_time)));
+	}
 
 exit1:
-	rtw_mutex_get(&g_tptest_mutex);
-	free_stream_data(tcp_client_data);
-	rtw_mutex_put(&g_tptest_mutex);
-
-exit2:
 	// close the connected socket after receiving from connected TCP client
 	close(iperf_data.client_fd);
 
-exit3:
+exit2:
 	// close the listening socket
 	close(iperf_data.server_fd);
+	if (g_stream_id[iperf_data.stream_id].terminate) {
+		tptest_res_log("TCP Server terminated\n\r");
+	}
 
-exit4:
+exit3:
 	if (tcp_server_buffer) {
 		vPortFree(tcp_server_buffer);
 		tcp_server_buffer = NULL;
@@ -545,15 +601,11 @@ int udp_client_func(struct iperf_data_t iperf_data)
 	u32_t now;
 	uint32_t id_cnt = 0;
 	int tos_value = (int)iperf_data.tos_value;// fix optlen check fail issue in lwip_setsockopt_impl
-	extern int			skbbuf_used_num;
-	extern int			skbdata_used_num;
-	extern int			max_local_skb_num;
-	extern int			max_skb_buf_num;
 	char *udp_client_buffer = NULL;
 
 	udp_client_buffer = pvPortMalloc(iperf_data.buf_size);
 	if (!udp_client_buffer) {
-		tptest_res_log("\n\r[ERROR] %s: Alloc buffer failed", __func__);
+		tptest_res_log("\n\r[ERROR] %s: Alloc buffer failed\n\r", __func__);
 		goto exit2;
 	}
 
@@ -564,7 +616,7 @@ int udp_client_func(struct iperf_data_t iperf_data)
 
 	//create socket
 	if ((iperf_data.client_fd = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP)) < 0) {
-		tptest_res_log("\n\r[ERROR] %s: Create UDP socket failed", __func__);
+		tptest_res_log("\n\r[ERROR] %s: Create UDP socket failed\n\r", __func__);
 		goto exit2;
 	}
 
@@ -574,11 +626,11 @@ int udp_client_func(struct iperf_data_t iperf_data)
 	ser_addr.sin_port = htons(iperf_data.port);
 	ser_addr.sin_addr.s_addr = inet_addr((char const *)iperf_data.server_ip);
 
-	tptest_res_log("\n\r%s: Server IP=%s, port=%d", __func__, iperf_data.server_ip, iperf_data.port);
-	tptest_res_log("\n\r%s: Create socket fd = %d", __func__, iperf_data.client_fd);
+	tptest_res_log("%s: Server IP=%s, port=%d\n\r", __func__, iperf_data.server_ip, iperf_data.port);
+	tptest_res_log("%s: Create socket fd = %d\n\r", __func__, iperf_data.client_fd);
 
 	if (setsockopt(iperf_data.client_fd, IPPROTO_IP, IP_TOS, &tos_value, sizeof(tos_value)) != 0) {
-		tptest_res_log("\n\r[ERROR] %s: Set sockopt failed", __func__);
+		tptest_res_log("\n\r[ERROR] %s: Set sockopt failed\n\r", __func__);
 		goto exit1;
 	}
 
@@ -627,7 +679,7 @@ int udp_client_func(struct iperf_data_t iperf_data)
 			}
 
 			if ((iperf_data.report_interval != DEFAULT_REPORT_INTERVAL) && ((end_time - report_start_time) >= (configTICK_RATE_HZ * iperf_data.report_interval))) {
-				tptest_res_log("\n\rudp_c: id[%d] Send %d KBytes in %d ms, %d Kbits/sec", iperf_data.stream_id, (int)(report_size / KB), (int)(end_time - report_start_time),
+				tptest_res_log("udp_c: id[%d] Send %d KBytes in %d ms, %d Kbits/sec\n\r", iperf_data.stream_id, (int)(report_size / KB), (int)(end_time - report_start_time),
 							   (int)((report_size * 8) / (end_time - report_start_time)));
 				report_start_time = end_time;
 				bandwidth_time = end_time;
@@ -647,11 +699,8 @@ int udp_client_func(struct iperf_data_t iperf_data)
 			client_hdr.tv_sec  = htonl(now / 1000);
 			client_hdr.tv_usec = htonl((now % 1000) * 1000);
 			memcpy(udp_client_buffer, &client_hdr, sizeof(client_hdr));
-			while ((skbdata_used_num > (max_skb_buf_num - 5)) || (skbbuf_used_num > (max_local_skb_num - 5))) {
-				vTaskDelay(1);
-			}
 			if (sendto(iperf_data.client_fd, udp_client_buffer, iperf_data.buf_size, 0, (struct sockaddr *)&ser_addr, addrlen) < 0) {
-				//tptest_res_log("\n\r[ERROR] %s: UDP client send data error",__func__);
+				//tptest_res_log("[ERROR] %s: UDP client send data error\n\r",__func__);
 			} else {
 				total_size += iperf_data.buf_size;
 				bandwidth_size += iperf_data.buf_size;
@@ -668,7 +717,7 @@ int udp_client_func(struct iperf_data_t iperf_data)
 			}
 
 			if ((iperf_data.report_interval != DEFAULT_REPORT_INTERVAL) && ((end_time - report_start_time) >= (configTICK_RATE_HZ * iperf_data.report_interval))) {
-				tptest_res_log("\n\rudp_c: id[%d] Send %d KBytes in %d ms, %d Kbits/sec", iperf_data.stream_id, (int)(report_size / KB), (int)(end_time - report_start_time),
+				tptest_res_log("udp_c: id[%d] Send %d KBytes in %d ms, %d Kbits/sec\n\r", iperf_data.stream_id, (int)(report_size / KB), (int)(end_time - report_start_time),
 							   (int)((report_size * 8) / (end_time - report_start_time)));
 				report_start_time = end_time;
 				bandwidth_time = end_time;
@@ -678,13 +727,17 @@ int udp_client_func(struct iperf_data_t iperf_data)
 		}
 	}
 
+	if (g_stream_id[iperf_data.stream_id].terminate) {
+		tptest_res_log("UDP Client terminated\n\r");
+	}
+
 	if (iperf_data.is_sub_stream && SUBSTREAM_FLAG) {
 		//This stream is created by bidirectional parameter
-		tptest_res_log("\n\rudp_c: [END] id[%d] Bidirection Totally send %d KBytes in %d ms, %d Kbits/sec", iperf_data.is_sub_stream & 0xff, (int)(total_size / KB),
+		tptest_res_log("udp_c: [END] id[%d] Bidirection Totally send %d KBytes in %d ms, %d Kbits/sec\n\r", iperf_data.is_sub_stream & 0xff, (int)(total_size / KB),
 					   (int)(end_time - start_time),
 					   (int)((total_size * 8) / (end_time - start_time)));
 	} else {
-		tptest_res_log("\n\rudp_c: [END] id[%d] Totally send %d KBytes in %d ms, %d Kbits/sec", iperf_data.stream_id, (int)(total_size / KB),
+		tptest_res_log("udp_c: [END] id[%d] Totally send %d KBytes in %d ms, %d Kbits/sec\n\r", iperf_data.stream_id, (int)(total_size / KB),
 					   (int)(end_time - start_time),
 					   (int)((total_size * 8) / (end_time - start_time)));
 	}
@@ -732,11 +785,11 @@ int udp_client_func(struct iperf_data_t iperf_data)
 
 				UDP_Hdr = (struct iperf_udp_datagram *) udp_client_buffer;
 				hdr = (struct iperf_udp_server_hdr *)(UDP_Hdr + 1);
-				tptest_res_log("\n\r%s: Server Report", __func__);
+				tptest_res_log("%s: Server Report\n\r", __func__);
 				if ((ntohl(hdr->flags) & 0x80000000) != 0) {
 					stop_ms = ntohl(hdr->stop_sec) * 1000 + ntohl(hdr->stop_usec) / 1000;
 					total_len = (((uint64_t) ntohl(hdr->total_len1)) << 32) + ntohl(hdr->total_len2);
-					tptest_res_log("\n\rudp_c: [END] id[%d] Totally send %d KBytes in %d ms, %d Kbits/sec", iperf_data.stream_id, (int)(total_len / KB), (int)stop_ms,
+					tptest_res_log("udp_c: [END] id[%d] Totally send %d KBytes in %d ms, %d Kbits/sec\n\r", iperf_data.stream_id, (int)(total_len / KB), (int)stop_ms,
 								   (int)(total_len * 8 / stop_ms));
 				}
 			}
@@ -746,7 +799,7 @@ int udp_client_func(struct iperf_data_t iperf_data)
 exit1:
 	close(iperf_data.client_fd);
 exit2:
-	tptest_res_log("\n\r%s: Close client socket", __func__);
+	tptest_res_log("%s: Close client socket\n\r", __func__);
 	if (udp_client_buffer) {
 		vPortFree(udp_client_buffer);
 		udp_client_buffer = NULL;
@@ -767,19 +820,22 @@ int udp_server_func(struct iperf_data_t iperf_data)
 	uint8_t time_boundary = 0, size_boundary = 0;
 	char *udp_server_buffer = NULL;
 	struct iperf_data_t *udp_client_data = NULL;
+	int socket_connect = 0;
+	fd_set read_fds;
+	struct timeval select_timeout;
 
 	udp_server_buffer = pvPortMalloc(iperf_data.buf_size);
 	if (!udp_server_buffer) {
-		tptest_res_log("\n\r[ERROR] %s: Alloc buffer failed", __func__);
-		goto exit3;
+		tptest_res_log("\n\r[ERROR] %s: Alloc buffer failed\n\r", __func__);
+		goto exit2;
 	}
 
 	//create socket
 	if ((iperf_data.server_fd = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP)) < 0) {
-		tptest_res_log("\n\r[ERROR] %s: Create socket failed", __func__);
-		goto exit3;
+		tptest_res_log("\n\r[ERROR] %s: Create socket failed\n\r", __func__);
+		goto exit2;
 	}
-	tptest_res_log("\n\r%s: Create socket fd = %d, port = %d", __func__, iperf_data.server_fd, iperf_data.port);
+	tptest_res_log("%s: Create socket fd = %d, port = %d\n\r", __func__, iperf_data.server_fd, iperf_data.port);
 
 	setsockopt(iperf_data.server_fd, SOL_SOCKET, SO_REUSEADDR, (const char *) &n, sizeof(n));
 
@@ -791,14 +847,30 @@ int udp_server_func(struct iperf_data_t iperf_data)
 
 	// binding the UDP socket to the UDP server address
 	if (bind(iperf_data.server_fd, (struct sockaddr *)&ser_addr, sizeof(ser_addr)) < 0) {
-		tptest_res_log("\n\r[ERROR] %s: Bind socket failed", __func__);
-		goto exit2;
+		tptest_res_log("\n\r[ERROR] %s: Bind socket failed\n\r", __func__);
+		goto exit1;
 	}
 
-	tptest_res_log("\n\r%s: Bind socket successfully", __func__);
+	tptest_res_log("%s: Bind socket successfully\n\r", __func__);
+
+	select_timeout.tv_sec = 0;
+	select_timeout.tv_usec = 500000; //500ms
+
+	while (!socket_connect && !g_stream_id[iperf_data.stream_id].terminate) {
+		FD_ZERO(&read_fds);
+		FD_SET(iperf_data.server_fd, &read_fds);
+		if (select(iperf_data.server_fd + 1, &read_fds, NULL, NULL, &select_timeout)) {
+			if (FD_ISSET(iperf_data.server_fd, &read_fds)) {
+				//wait for first packet to start
+				recv_size = recvfrom(iperf_data.server_fd, udp_server_buffer, iperf_data.buf_size, 0, (struct sockaddr *) &client_addr, (u32_t *)&addrlen);
+				socket_connect = 1;
+			}
+		}
+	}
+	if (g_stream_id[iperf_data.stream_id].terminate) {
+		goto exit1;
+	}
 
-	//wait for first packet to start
-	recv_size = recvfrom(iperf_data.server_fd, udp_server_buffer, iperf_data.buf_size, 0, (struct sockaddr *) &client_addr, (u32_t *)&addrlen);
 	total_size += recv_size;
 	report_size += recv_size;
 	start_time = xTaskGetTickCount();
@@ -807,8 +879,6 @@ int udp_server_func(struct iperf_data_t iperf_data)
 	if (!iperf_data.bidirection) { //Server
 		//parser the amount of udp iperf setting
 		memcpy(&client_hdr, udp_server_buffer, sizeof(client_hdr));
-		printf("\nclient_hdr.mAmount = %x\n", (unsigned int)client_hdr.mAmount);
-
 		if (client_hdr.mAmount != 0) {
 			client_hdr.mAmount = ntohl(client_hdr.mAmount);
 			if (client_hdr.mAmount > 0x7fffffff) {
@@ -818,7 +888,6 @@ int udp_server_func(struct iperf_data_t iperf_data)
 				size_boundary = 1;
 			}
 		} else {
-			printf("\nNo boundary\n");
 			//set receive timeout
 			int recv_timeout = 500;
 
@@ -836,8 +905,8 @@ int udp_server_func(struct iperf_data_t iperf_data)
 			udp_client_data = init_stream_data('u', 'c');
 			rtw_mutex_put(&g_tptest_mutex);
 			if (udp_client_data == NULL) {
-				tptest_res_log("\n\r[ERROR] init_stream_data failed!\n");
-				goto exit2;
+				tptest_res_log("[ERROR] init_stream_data failed!\n\r");
+				goto exit1;
 			}
 			if (time_boundary) {
 				udp_client_data->time = client_hdr.mAmount;
@@ -853,7 +922,10 @@ int udp_server_func(struct iperf_data_t iperf_data)
 			udp_client_data->is_sub_stream = SUBSTREAM_FLAG | iperf_data.stream_id;
 			if (xTaskCreate(iperf_test_handler, "iperf_test_handler", BSD_STACK_SIZE, (void *) udp_client_data, tskIDLE_PRIORITY + 1 + PRIORITIE_OFFSET,
 							&udp_client_data->task) != pdPASS) {
-				tptest_res_log("\r\nUDP ERROR: Create UDP client task failed.");
+				tptest_res_log("\n\rUDP ERROR: Create UDP client task failed.\n\r");
+				rtw_mutex_get(&g_tptest_mutex);
+				free_stream_data(udp_client_data);
+				rtw_mutex_put(&g_tptest_mutex);
 				goto exit1;
 			}
 		}
@@ -871,7 +943,7 @@ int udp_server_func(struct iperf_data_t iperf_data)
 		while (((end_time - start_time) <= (configTICK_RATE_HZ * client_hdr.mAmount))  && (!g_stream_id[iperf_data.stream_id].terminate)) {
 			recv_size = recvfrom(iperf_data.server_fd, udp_server_buffer, iperf_data.buf_size, 0, (struct sockaddr *) &client_addr, (u32_t *)&addrlen);
 			if (recv_size < 0) {
-				tptest_res_log("\n\r[ERROR] %s: Receive data failed", __func__);
+				tptest_res_log("\n\r[ERROR] %s: Receive data failed\n\r", __func__);
 				goto exit1;
 			}
 
@@ -888,7 +960,7 @@ int udp_server_func(struct iperf_data_t iperf_data)
 			total_size += recv_size;
 			report_size += recv_size;
 			if ((iperf_data.report_interval != DEFAULT_REPORT_INTERVAL) && ((end_time - report_start_time) >= (configTICK_RATE_HZ * iperf_data.report_interval))) {
-				tptest_res_log("\n\rudp_s: id[%d] Receive %d KBytes in %d ms, %d Kbits/sec", iperf_data.stream_id, (int)(report_size / KB), (int)(end_time - report_start_time),
+				tptest_res_log("udp_s: id[%d] Receive %d KBytes in %d ms, %d Kbits/sec\n\r", iperf_data.stream_id, (int)(report_size / KB), (int)(end_time - report_start_time),
 							   (int)((report_size * 8) / (end_time - report_start_time)));
 				report_start_time = end_time;
 				report_size = 0;
@@ -898,7 +970,7 @@ int udp_server_func(struct iperf_data_t iperf_data)
 		while ((total_size < client_hdr.mAmount) && (!g_stream_id[iperf_data.stream_id].terminate)) {
 			recv_size = recvfrom(iperf_data.server_fd, udp_server_buffer, iperf_data.buf_size, 0, (struct sockaddr *) &client_addr, (u32_t *)&addrlen);
 			if (recv_size < 0) {
-				tptest_res_log("\n\r[ERROR] %s: Receive data failed", __func__);
+				tptest_res_log("\n\r[ERROR] %s: Receive data failed\n\r", __func__);
 				goto exit1;
 			}
 
@@ -915,7 +987,7 @@ int udp_server_func(struct iperf_data_t iperf_data)
 			total_size += recv_size;
 			report_size += recv_size;
 			if ((iperf_data.report_interval != DEFAULT_REPORT_INTERVAL) && ((end_time - report_start_time) >= (configTICK_RATE_HZ * iperf_data.report_interval))) {
-				tptest_res_log("\n\rudp_s: id[%d] Receive %d KBytes in %d ms, %d Kbits/sec", iperf_data.stream_id, (int)(report_size / KB), (int)(end_time - report_start_time),
+				tptest_res_log("udp_s: id[%d] Receive %d KBytes in %d ms, %d Kbits/sec\n\r", iperf_data.stream_id, (int)(report_size / KB), (int)(end_time - report_start_time),
 							   (int)((report_size * 8) / (end_time - report_start_time)));
 				report_start_time = end_time;
 				report_size = 0;
@@ -925,7 +997,7 @@ int udp_server_func(struct iperf_data_t iperf_data)
 		while (!g_stream_id[iperf_data.stream_id].terminate) {
 			recv_size = recvfrom(iperf_data.server_fd, udp_server_buffer, iperf_data.buf_size, 0, (struct sockaddr *) &client_addr, (u32_t *)&addrlen);
 			if (recv_size < 0) {
-				tptest_res_log("\n\r%s: Receive data timeout", __func__);
+				tptest_res_log("%s: Receive data timeout\n\r", __func__);
 				goto exit1;
 			}
 
@@ -942,7 +1014,7 @@ int udp_server_func(struct iperf_data_t iperf_data)
 			total_size += recv_size;
 			report_size += recv_size;
 			if ((iperf_data.report_interval != DEFAULT_REPORT_INTERVAL) && ((end_time - report_start_time) >= (configTICK_RATE_HZ * iperf_data.report_interval))) {
-				tptest_res_log("\n\rudp_s: id[%d] Receive %d KBytes in %d ms, %d Kbits/sec", iperf_data.stream_id, (int)(report_size / KB), (int)(end_time - report_start_time),
+				tptest_res_log("udp_s: id[%d] Receive %d KBytes in %d ms, %d Kbits/sec\n\r", iperf_data.stream_id, (int)(report_size / KB), (int)(end_time - report_start_time),
 							   (int)((report_size * 8) / (end_time - report_start_time)));
 				report_start_time = end_time;
 				report_size = 0;
@@ -950,21 +1022,20 @@ int udp_server_func(struct iperf_data_t iperf_data)
 		}
 	}
 
-exit1:
-	tptest_res_log("\n\rudp_s: [END] id[%d] Totally receive %d KBytes in %d ms, %d Kbits/sec", iperf_data.stream_id, (int)(total_size / KB),
-				   (int)(end_time - start_time),
-				   (int)((uint64_t)(total_size * 8) / (end_time - start_time)));
-
-
-	rtw_mutex_get(&g_tptest_mutex);
-	free_stream_data(udp_client_data);
-	rtw_mutex_put(&g_tptest_mutex);
+	if (total_size != 0) {
+		tptest_res_log("udp_s: [END] id[%d] Totally receive %d KBytes in %d ms, %d Kbits/sec\n\r", iperf_data.stream_id, (int)(total_size / KB),
+					   (int)(end_time - start_time),
+					   (int)((uint64_t)(total_size * 8) / (end_time - start_time)));
+	}
 
-exit2:
+exit1:
 	// close the listening socket
 	close(iperf_data.server_fd);
+	if (g_stream_id[iperf_data.stream_id].terminate) {
+		tptest_res_log("UDP Server terminated\n\r");
+	}
 
-exit3:
+exit2:
 	if (udp_server_buffer) {
 		vPortFree(udp_server_buffer);
 		udp_server_buffer = NULL;
@@ -980,30 +1051,34 @@ static void iperf_test_handler(void *param)
 	vTaskDelay(100);
 	if (stream_data->protocol == 'u') {
 		if (stream_data->role == 'c') {
-			tptest_res_log("\n\rStart UDP client! id = [%d]", stream_data->stream_id);
+			tptest_res_log("Start UDP client! id = [%d]\n\r", stream_data->stream_id);
 			udp_client_func(stream_data[0]);
-			tptest_res_log("\n\rUDP client stopped!");
+			tptest_res_log("UDP client stopped!\n\r");
 		} else if (stream_data->role == 's') {
-			tptest_res_log("\n\rStart UDP server! id = [%d]", stream_data->stream_id);
+			tptest_res_log("Start UDP server! id = [%d]\n\r", stream_data->stream_id);
 			udp_server_func(stream_data[0]);
-			tptest_res_log("\n\rUDP server stopped!");
+			tptest_res_log("UDP server stopped!\n\r");
 		}
 	} else if (stream_data->protocol == 't') {
 		if (stream_data->role == 'c') {
-			tptest_res_log("\n\rStart TCP client! id = [%d]", stream_data->stream_id);
+			tptest_res_log("Start TCP client! id = [%d]\n\r", stream_data->stream_id);
 			tcp_client_func(stream_data[0]);
-			tptest_res_log("\n\rTCP client stopped!");
+			tptest_res_log("TCP client stopped!\n\r");
 		} else if (stream_data->role == 's') {
-			tptest_res_log("\n\rStart TCP server! id = [%d]", stream_data->stream_id);
+			tptest_res_log("Start TCP server! id = [%d]\n\r", stream_data->stream_id);
 			tcp_server_func(stream_data[0]);
-			tptest_res_log("\n\rTCP server stopped!");
+			tptest_res_log("TCP server stopped!\n\r");
 		}
 	} else {
-		tptest_res_log("\n\r[ERROR] Wrong data");
+		tptest_res_log("\n\r[ERROR] Wrong data\n\r");
 	}
 
+	rtw_mutex_get(&g_tptest_mutex);
+	free_stream_data(stream_data);
+	rtw_mutex_put(&g_tptest_mutex);
+
 #if defined(INCLUDE_uxTaskGetStackHighWaterMark) && (INCLUDE_uxTaskGetStackHighWaterMark == 1)
-	tptest_res_log("\n\rMin available stack size of %s = %d * %d bytes", __FUNCTION__, uxTaskGetStackHighWaterMark(NULL), sizeof(portBASE_TYPE));
+	tptest_res_log("Min available stack size of %s = %d * %d bytes\n\r", __FUNCTION__, uxTaskGetStackHighWaterMark(NULL), sizeof(portBASE_TYPE));
 #endif
 
 	vTaskDelete(NULL);
@@ -1015,7 +1090,9 @@ void cmd_iperf(int argc, char **argv)
 	uint8_t stream_id;
 	struct iperf_data_t *stream_data = NULL;
 	struct iperf_data_t *stream_data_s = NULL;
+	struct iperf_data_t *stream_data_list = NULL;
 	uint8_t protocol = 0;
+	int i = 0;
 
 	iperf_init();
 	rtw_mutex_get(&g_tptest_mutex);
@@ -1038,7 +1115,7 @@ void cmd_iperf(int argc, char **argv)
 			if (strcmp(argv[argv_count - 1], "-s") == 0) {
 				stream_data = init_stream_data(protocol, 's');
 				if (stream_data == NULL) {
-					tptest_res_log("\n\r[ERROR] init_stream_data failed!\n");
+					tptest_res_log("\n\r[ERROR] init_stream_data failed!\n\r");
 					goto exit;
 				}
 				argv_count++;
@@ -1048,6 +1125,14 @@ void cmd_iperf(int argc, char **argv)
 					g_stream_id[stream_id].terminate = 1;
 					rtw_mutex_put(&g_tptest_mutex);
 					return;
+				} else if (argc == 2) {
+					for (i = 0; i < MULTI_STREAM_NUM; i++) {
+						if (g_stream_id[i].id_used) {
+							g_stream_id[i].terminate = 1;
+						}
+					}
+					rtw_mutex_put(&g_tptest_mutex);
+					return;
 				} else {
 					goto exit;
 				}
@@ -1057,12 +1142,25 @@ void cmd_iperf(int argc, char **argv)
 				}
 				stream_data = init_stream_data(protocol, 'c');
 				if (stream_data == NULL) {
-					tptest_res_log("\n\r[ERROR] init_stream_data failed!\n");
+					tptest_res_log("\n\r[ERROR] init_stream_data failed!\n\r");
 					goto exit;
 				}
 				strncpy((char *)stream_data->server_ip, argv[2], sizeof(stream_data->server_ip) - 1);
 				stream_data->server_ip[sizeof(stream_data->server_ip) - 1] = '\0';
 				argv_count += 2;
+			} else if (strcmp(argv[argv_count - 1], "?") == 0) {
+				if (argc == 2) {
+					stream_data_list = stream_data_head;
+					while (stream_data_list != NULL) {
+						tptest_res_log("[%d] %s_%s, port=%d\n\r", stream_data_list->stream_id, (stream_data_list->protocol == 't' ? "tcp" : "udp"),
+									   (stream_data_list->role == 'c' ? "client" : "server"), stream_data_list->port);
+						stream_data_list = stream_data_list->next;
+					}
+					rtw_mutex_put(&g_tptest_mutex);
+					return;
+				} else {
+					goto exit;
+				}
 			} else {
 				goto exit;
 			}
@@ -1139,14 +1237,14 @@ void cmd_iperf(int argc, char **argv)
 	if (stream_data->role == 's') {
 		if (xTaskCreate(iperf_test_handler, "iperf_test_handler", BSD_STACK_SIZE, (void *) stream_data, tskIDLE_PRIORITY + 2 + PRIORITIE_OFFSET,
 						&stream_data->task) != pdPASS) {
-			tptest_res_log("\r\nUDP ERROR: Create UDP server task failed.");
+			tptest_res_log("UDP ERROR: Create UDP server task failed.\n\r");
 			goto exit;
 		}
 	} else if (stream_data->role == 'c') {
 		if (stream_data->bidirection == 1) {
 			stream_data_s = init_stream_data(protocol, 's');
 			if (stream_data_s == NULL) {
-				tptest_res_log("\n\r[ERROR] init_stream_data failed!\n");
+				tptest_res_log("[ERROR] init_stream_data failed!\n\r");
 				goto exit;
 			}
 			stream_data_s->bidirection = 1;
@@ -1155,13 +1253,13 @@ void cmd_iperf(int argc, char **argv)
 			stream_data_s->total_size = stream_data->total_size;
 			if (xTaskCreate(iperf_test_handler, "iperf_test_handler", BSD_STACK_SIZE, (void *) stream_data_s, tskIDLE_PRIORITY + 2 + PRIORITIE_OFFSET,
 							&stream_data_s->task) != pdPASS) {
-				tptest_res_log("\r\nUDP ERROR: Create UDP server task failed.");
+				tptest_res_log("UDP ERROR: Create UDP server task failed.\n\r");
 				goto exit;
 			}
 		}
 		if (xTaskCreate(iperf_test_handler, "iperf_test_handler", BSD_STACK_SIZE, (void *) stream_data, tskIDLE_PRIORITY + 1 + PRIORITIE_OFFSET,
 						&stream_data->task) != pdPASS) {
-			tptest_res_log("\r\nUDP ERROR: Create UDP client task failed.");
+			tptest_res_log("UDP ERROR: Create UDP client task failed.\n\r");
 			vTaskDelete(stream_data_s->task);
 			goto exit;
 		}
@@ -1179,7 +1277,8 @@ exit:
 		printf("\n\r[ATWT] Command format ERROR!\n");
 		printf("\n\r[ATWT] Usage: ATWT=[-s|-c,host|stop],[options]\n");
 		printf("\n\r   Client/Server:\n");
-		printf("  \r	 stop  #		terminate specific stream id\n");
+		printf("  \r	  ?     		List all stream status\n");
+		printf("  \r	 stop  #		terminate specific stream id or terminate all stream if no id specified\n");
 		printf("  \r	 -i    #		seconds between periodic bandwidth reports\n");
 		printf("  \r	 -l    #		length of buffer to read or write (default 1460 Bytes)\n");
 		printf("  \r	 -p    #		server port to listen on/connect to (default 5001)\n");
@@ -1197,7 +1296,8 @@ exit:
 		printf("\n\r[ATWU] Command format ERROR!\n");
 		printf("\n\r[ATWU] Usage: ATWU=[-s|-c,host|stop][options]\n");
 		printf("\n\r   Client/Server:\n");
-		printf("  \r     stop  #        terminate specific stream id\n");
+		printf("  \r	  ?     		List all stream status\n");
+		printf("  \r     stop  #        terminate specific stream id or terminate all stream if no id specified\n");
 		printf("  \r     -i    #        seconds between periodic bandwidth reports\n");
 		printf("  \r     -l    #        length of buffer to read or write (default 1460 Bytes)\n");
 		printf("  \r     -p    #        server port to listen on/connect to (default 5001)\n");
diff --git a/os/board/rtl8720e/src/component/network/iperf3/iperf_api.c b/os/board/rtl8720e/src/component/network/iperf3/iperf_api.c
old mode 100644
new mode 100755
index 3c1d0bfab..3d060be6a
--- a/os/board/rtl8720e/src/component/network/iperf3/iperf_api.c
+++ b/os/board/rtl8720e/src/component/network/iperf3/iperf_api.c
@@ -583,7 +583,7 @@ iperf_on_connect(struct iperf_test *test)
 	const char *rfc1123_fmt = "%a, %d %b %Y %H:%M:%S GMT";
 	char now_str[100];
 	char ipr[INET6_ADDRSTRLEN];
-	int port;
+	int port = 0;
 	struct sockaddr_storage sa;
 	struct sockaddr_in *sa_inP;
 #if defined (LWIP_IPV6) && LWIP_IPV6
@@ -964,6 +964,7 @@ iperf_parse_arguments(struct iperf_test *test, int argc, char **argv)
 			memset(xbe, 0, sizeof(*xbe));
 			xbe->name = strdup(optarg);
 			if (!xbe->name) {
+				free(xbe);
 				i_errno = IESETSCTPBINDX;
 				return -1;
 			}
@@ -2101,7 +2102,8 @@ void
 connect_msg(struct iperf_stream *sp)
 {
 	char ipl[INET6_ADDRSTRLEN], ipr[INET6_ADDRSTRLEN];
-	int lport, rport;
+	int lport = 0;
+	int rport = 0;
 
 	if (getsockdomain(sp->socket) == AF_INET) {
 		inet_ntop(AF_INET, (void *) & ((struct sockaddr_in *) &sp->local_addr)->sin_addr, ipl, sizeof(ipl));
diff --git a/os/board/rtl8720e/src/component/network/rtsp/rtsp_api.c b/os/board/rtl8720e/src/component/network/rtsp/rtsp_api.c
old mode 100644
new mode 100755
index 6ba286459..281debb60
--- a/os/board/rtl8720e/src/component/network/rtsp/rtsp_api.c
+++ b/os/board/rtl8720e/src/component/network/rtsp/rtsp_api.c
@@ -11,7 +11,7 @@
 
 #include "wifi_conf.h"
 #include "lwip_netconf.h"	// for LwIP_GetMAC
-#include "rtw_byteorder.h"// for _htons
+#include "rtw_wifi_constants.h"// for _htons
 
 #define RTSP_CTX_ID_BASE	0
 static uint32_t rtsp_ctx_id_bitmap = 0;
diff --git a/os/board/rtl8720e/src/component/network/websocket/libwsclient.h b/os/board/rtl8720e/src/component/network/websocket/libwsclient.h
old mode 100644
new mode 100755
index 1c1bfa629..f38401308
--- a/os/board/rtl8720e/src/component/network/websocket/libwsclient.h
+++ b/os/board/rtl8720e/src/component/network/websocket/libwsclient.h
@@ -59,6 +59,7 @@ struct rsv_bits_field {
 typedef struct send_buf_t {
 	uint8_t *txbuf;
 	int tx_len;
+	int send_offset;
 } send_buf;
 
 struct _wsclient_context;
@@ -88,6 +89,7 @@ typedef struct _wsclient_context {
 	int rx_len;
 	void *tls;
 	int max_queue_size;
+	int wsclient_reallength;
 	int stable_buf_num;
 	int ready_send_buf_num;
 	int recycle_send_buf_num;
@@ -99,6 +101,7 @@ typedef struct _wsclient_context {
 	struct rsv_bits_field rxRsvBits;
 	uint8_t *receivedData;
 	struct ws_fun_ops fun_ops;
+	_mutex queue_mutex;
 } wsclient_context;
 /*******************************************************************/
 
diff --git a/os/board/rtl8720e/src/component/network/websocket/wsclient_api.h b/os/board/rtl8720e/src/component/network/websocket/wsclient_api.h
old mode 100644
new mode 100755
index 38509a087..28fbcddb1
--- a/os/board/rtl8720e/src/component/network/websocket/wsclient_api.h
+++ b/os/board/rtl8720e/src/component/network/websocket/wsclient_api.h
@@ -107,6 +107,14 @@ void ws_poll(int timeout, wsclient_context **wsclient);
 **************************************************************************************************/
 void ws_dispatch(void (*callback)(wsclient_context **, int)) ;
 
+/*************************************************************************************************
+** Function Name  : ws_pong
+** Description    : callback function when getting pong message from server
+** Input          : function that resolve the pong message received
+** Return         : None
+**************************************************************************************************/
+void ws_pong(void (*callback)(wsclient_context **)) ;
+
 /*************************************************************************************************
 ** Function Name  : ws_getReadyState
 ** Description    : Getting the connection status
@@ -163,4 +171,12 @@ int ws_handshake_header_custom_token(wsclient_context *wsclient, char *cus, int
 ** Return         : result(0:ok, -1:fail)
 **************************************************************************************************/
 int ws_multisend_opts(wsclient_context *wsclient, int stable_buf_num);
+
+/*************************************************************************************************
+** Function Name  : ws_set_senddata_block_time
+** Description    : set ws_sendData block time. Default is non-block.
+** Input          : ms: the max block time
+** Return         : none
+**************************************************************************************************/
+void ws_set_senddata_block_time(uint32_t ms);
 #endif
\ No newline at end of file
diff --git a/os/board/rtl8720e/src/component/network/websocket/wsserver_tls.c b/os/board/rtl8720e/src/component/network/websocket/wsserver_tls.c
old mode 100644
new mode 100755
index ae32c2928..7b8f82ef6
--- a/os/board/rtl8720e/src/component/network/websocket/wsserver_tls.c
+++ b/os/board/rtl8720e/src/component/network/websocket/wsserver_tls.c
@@ -152,8 +152,11 @@ exit:
 		ret = -1;
 		goto exit;
 	}
-
+#if defined(MBEDTLS_VERSION_NUMBER) && (MBEDTLS_VERSION_NUMBER == 0x03000000)
+	if ((ret = mbedtls_pk_parse_key(&wss_key, (const unsigned char *) server_key, strlen(server_key) + 1, NULL, 0, rtw_get_random_bytes_f_rng, (void *)1)) != 0) {
+#else
 	if ((ret = mbedtls_pk_parse_key(&wss_key, (const unsigned char *) server_key, strlen(server_key) + 1, NULL, 0)) != 0) {
+#endif
 		printf("\n[WS_SERVER] ERROR: mbedtls_pk_parse_key %d\n", ret);
 		ret = -1;
 		goto exit;
diff --git a/os/board/rtl8720e/src/component/os/os_dep/include/osdep_service.h b/os/board/rtl8720e/src/component/os/os_dep/include/osdep_service.h
deleted file mode 100644
index 0f6665d4f..000000000
--- a/os/board/rtl8720e/src/component/os/os_dep/include/osdep_service.h
+++ /dev/null
@@ -1,1375 +0,0 @@
-/******************************************************************************
- * Copyright (c) 2013-2016 Realtek Semiconductor Corp.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- ******************************************************************************/
-
-#ifndef __OSDEP_SERVICE_H_
-#define __OSDEP_SERVICE_H_
-
-/** @addtogroup RTOS
- *  @{
- */
-
-/*************************** OS dep feature enable *******************************/
-
-/******************************************************
- *                    Macros
- ******************************************************/
-
-#if defined(CONFIG_PLATFORM_8721D) || (defined CONFIG_PLATFORM_AMEBAD2) || (defined CONFIG_PLATFORM_AMEBALITE) || (defined CONFIG_PLATFORM_AMEBADPLUS) || (defined CONFIG_PLATFORM_8735B)
-#define CONFIG_PLATFORM_AMEBA_X 1
-#else
-#define CONFIG_PLATFORM_AMEBA_X 0
-#endif
-
-#if defined(CONFIG_PLATFORM_AMEBA_X) && (CONFIG_PLATFORM_AMEBA_X == 1)
-#define CONFIG_MEM_MONITOR	MEM_MONITOR_SIMPLE
-#else
-#define CONFIG_MEM_MONITOR	MEM_MONITOR_SIMPLE
-#endif
-
-#if defined(CONFIG_PLATFORM_8735B)
-#include <platform_conf.h>
-#include <basic_types.h>
-#if (CONFIG_CMSIS_FREERTOS_EN==1)
-#define PLATFORM_FREERTOS 1
-#endif
-#else
-#if defined(CONFIG_PLATFORM_AMEBA_X) && (CONFIG_PLATFORM_AMEBA_X == 1)
-#include "platform_autoconf.h"
-#endif
-#endif
-
-#if defined(PLATFORM_ALIOS)
-#include "alios_service.h"
-#elif defined(PLATFORM_FREERTOS)
-//#include "freertos_service.h"
-#elif defined(PLATFORM_ECOS)
-#include "ecos/ecos_service.h"
-#elif defined(PLATFORM_CMSIS_RTOS)
-#include "cmsis_rtos_service.h"
-#elif defined(CONFIG_PLATFOMR_CUSTOMER_RTOS)
-#include "customer_rtos_service.h"
-#endif
-#include "tizenrt_service.h"
-
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-/* Define compilor specific symbol */
-
-/*************************** inline functions *******************************/
-#if defined ( __ICCARM__ )
-#define __inline__                      inline
-#define __inline                        inline
-#define __inline_definition			//In dialect C99, inline means that a function's definition is provided
-//only for inlining, and that there is another definition
-//(without inline) somewhere else in the program.
-//That means that this program is incomplete, because if
-//add isn't inlined (for example, when compiling without optimization),
-//then main will have an unresolved reference to that other definition.
-
-// Do not inline function is the function body is defined .c file and this
-// function will be called somewhere else, otherwise there is compile error
-#elif defined ( __CC_ARM   )
-#define __inline__			__inline	//__linine__ is not supported in keil compilor, use __inline instead
-#define inline				__inline
-#define __inline_definition			// for dialect C99
-#elif defined   (  __GNUC__  )
-#define __inline__                      inline
-#define __inline                        inline
-#define __inline_definition	inline
-#endif
-
-#include <stdio.h>
-
-//#if defined(CONFIG_PLATFORM_AMEBA_X) && (CONFIG_PLATFORM_AMEBA_X == 0)
-
-#ifndef SUCCESS
-#define SUCCESS	0
-#endif
-#ifndef FAIL
-#define FAIL	(-1)
-#endif
-
-#ifndef _SUCCESS
-#define _SUCCESS	1
-#endif
-#ifndef _FAIL
-#define _FAIL	0
-#endif
-#ifndef FALSE
-#define FALSE   0
-#endif
-
-#ifndef false
-#define false 0
-#endif
-
-#ifndef TRUE
-#define TRUE    (!FALSE)
-#endif
-
-#ifndef true
-#define true (!false)
-#endif
-
-
-#ifndef DBG_8195A
-#define DBG_8195A
-#endif
-
-#define _TRUE        TRUE
-#define _FALSE	     FALSE
-
-//#endif
-
-#define RTW_RX_HANDLED			2
-#define RTW_RFRAME_UNAVAIL		3
-#define RTW_RFRAME_PKT_UNAVAIL	4
-#define RTW_RBUF_UNAVAIL		5
-#define RTW_RBUF_PKT_UNAVAIL	6
-#define RTW_SDIO_READ_PORT_FAIL	7
-
-
-#define RTW_MAX_DELAY			0xFFFFFFFF
-#define RTW_WAIT_FOREVER		0xFFFFFFFF
-
-#if( configSUPPORT_STATIC_ALLOCATION == 1 )
-#ifdef CONFIG_WLAN
-#define MAX_MUTEX_BUF_NUM		109
-#define MAX_TIMER_BUF_NUM		52
-#else
-#define MAX_MUTEX_BUF_NUM		5
-#define MAX_TIMER_BUF_NUM		5
-#endif
-#endif
-
-
-/******************************************************
- *                    Constants
- ******************************************************/
-/**
-  * @brief  Definitions returned by xTaskGetSchedulerState().
-  */
-
-#define OS_SCHEDULER_NOT_STARTED	0
-#define OS_SCHEDULER_RUNNING		1
-#define OS_SCHEDULER_SUSPENDED		2
-
-/******************************************************
- *                    Structures
- ******************************************************/
-struct timer_list {
-	struct list_head list;
-	_timerHandle 	timer_hdl;
-	unsigned long	data;
-	void (*function)(void *);
-};
-
-/******************************************************
- *                 Type Definitions
- ******************************************************/
-typedef thread_return(*thread_func_t)(thread_context context);
-typedef void (*TIMER_FUN)(void *context);
-typedef int (*event_handler_t)(char *buf, int buf_len, int flags, void *user_data);
-
-#define CONFIG_THREAD_COMM_SEMA
-struct task_struct {
-	const char *task_name;
-	pid_t task;	/* I: workqueue thread */
-
-#ifdef CONFIG_THREAD_COMM_SIGNAL
-	const char *name;	/* I: workqueue thread name */
-	uint32_t queue_num;		/* total signal num */
-	uint32_t cur_queue_num;	/* cur signal num should < queue_num */
-#elif defined(CONFIG_THREAD_COMM_SEMA)
-	_sema wakeup_sema;    /* for internal use only */
-	_sema terminate_sema; /* for internal use only */
-#endif
-	uint32_t blocked;          /* for internal use only */
-	uint32_t callback_running; /* for internal use only */
-};
-
-#ifdef CONFIG_THREAD_COMM_SIGNAL
-struct work_struct;
-typedef void (*work_func_t)(void *context);
-struct work_struct {
-	_list list;
-	uint32_t data;
-	work_func_t func;
-	void *context;
-	struct task_struct *used_wq;
-};
-
-struct delayed_work {
-	struct work_struct work;
-	struct timer_list timer;
-};
-#endif
-
-/*************************** Memory Management *******************************/
-void	*_rtw_vmalloc(uint32_t sz);
-void	*_rtw_zvmalloc(uint32_t sz);
-void	_rtw_vmfree(uint8_t *pbuf, uint32_t sz);
-void	*_rtw_zmalloc(uint32_t sz);
-void	*_rtw_malloc(uint32_t sz);
-void  *_rtw_calloc(uint32_t nelements, uint32_t elmentSize);
-void	_rtw_mfree(uint8_t *pbuf, uint32_t sz);
-
-/**
- * @brief  This function allocates the virtually contiguous memory.
- * @param[in] sz: The size of memory to be allocated.
- * @return	  The pointer to the beginning of the memory
- */
-void	*rtw_vmalloc(uint32_t sz);
-
-/**
- * @brief  This function allocates the virtually contiguous memory
- *		   and the values of the memory are setted to 0.
- * @param[in] sz: The size of memory to be allocated.
- * @return	  The pointer to the beginning of the memory
- */
-void	*rtw_zvmalloc(uint32_t sz);
-
-/**
- * @brief  This function frees the virtually contiguous memory.
- * @param[in] pbuf: The pointer to the beginning of the memory to be free
- * @param[in] sz: The size of memory allocated.
- * @return	  None
- */
-void	rtw_vmfree(uint8_t *pbuf, uint32_t sz);
-
-/**
- * @brief  This function allocates the memory
- *		   and the values of the memory are setted to 0.
- * @param[in] sz: The size of memory to be allocated.
- * @return	  The pointer to the beginning of the memory
- */
-void	*rtw_zmalloc(uint32_t sz);
-
-/**
- * @brief  This function allocates the memory.
- * @param[in] sz: The size of memory to be allocated.
- * @return	  The pointer to the beginning of the memory
- */
-void	*rtw_malloc(uint32_t sz);
-
-/**
- * @brief  This function allocates the memory, nlements*elementSize bytes in size.
- * @param[in] nelements: The number of elements.
- * @param[in] elementSize: The size of each element
- * @return	  The pointer to the beginning of the memory
- */
-void	*rtw_calloc(uint32_t nelements, uint32_t elmentSize);
-
-/**
- * @brief  This function frees the virtually contiguous memory.
- * @param[in] pbuf: The pointer to the beginning of the memory to be free
- * @param[in] sz: The size of memory allocated.
- * @return	  None
- */
-void	rtw_mfree(uint8_t *pbuf, uint32_t sz);
-
-#define rtw_free(buf)		rtw_mfree((uint8_t *)buf, 0)
-
-/**
- * @brief  This function allocates a 2 dimensional array memory.
- * @param[in] h: The height of the 2D array.
- * @param[in] w: The width of the 2D array.
- * @param[in] size: The size of the each charactor in array.
- * @return	  the pointer to the beginning of the block
- */
-void	*rtw_malloc2d(int h, int w, int size);
-
-/**
- * @brief  This function deallocates the block of memory previously allocated to make it available again.
- * @param[in] pbuf: Pointer to a memory block previously allocated.
- * @param[in] h: The height of the 2D array.
- * @param[in] w: The width of the 2D array.
- * @param[in] size: The size of the each charactor in array.
- * @return	  None
- */
-void	rtw_mfree2d(void *pbuf, int h, int w, int size);
-
-/**
- * @brief  This function copies the values of "sz" bytes from the location pointed to by "src"
- *         directly to the memory block pointed to by "des".
- * @param[in] dst: Pointer to the destination array where the content is to be copied, type-casted to a pointer of type void*.
- * @param[in] src: Pointer to the source of data to be copied, type-casted to a pointer of type void*.
- * @param[in] sz: Size of memory to copy.
- * @return	  None
- */
-void	rtw_memcpy(void *dst, void *src, uint32_t sz);
-
-/**
- * @brief  This function compares the first "sz" bytes of the block of memory pointed by "dst"
- *		   to the first "sz" bytes pointed by "src".
- * @param[in] dst: Pointer to block of memory to be compared.
- * @param[in] src: pointer to block of memory to compare.
- * @param[in] sz: Size of memory to compare.
- * @return	<0: The first byte that does not match in both memory blocks has a lower value in dst than in src.
- * @return	0: The contents of both memory blocks are equal.
- * @return	<0: The first byte that does not match in both memory blocks has a greater value in dst than in src.
- */
-int	rtw_memcmp(void *dst, void *src, uint32_t sz);
-
-/**
- * @brief  This function sets the first "sz" bytes of the block of memory pointed by "pbuf" to the specified "c".
- * @param[in] pbuf: Pointer to the block of memory to fill.
- * @param[in] c: Value to be set.
- * @param[in] sz: Size of memory to be set to the value "c".
- * @return	  None
- */
-void	rtw_memset(void *pbuf, int c, uint32_t sz);
-/*************************** End Memory Management *******************************/
-
-/*************************** List *******************************/
-
-/**
- * @brief  This function initializes the head of the list.
- * @param[in] list: Pointer to the list to be initialized.
- * @return	  None
- */
-void	rtw_init_listhead(_list *list);
-
-/**
- * @brief  This function tests whether a list is empty.
- * @param[in] phead: Pointer to the list to test.
- * @return	  _TRUE/_FALSE
- */
-uint32_t	rtw_is_list_empty(_list *phead);
-
-/**
- * @brief  This function adds a new entry after "phead" for the list.
- * @param[in] plist: Pointer to the list to be added.
- * @param[in] phead: List head to add it after.
- * @return	  None
- */
-void	rtw_list_insert_head(_list *plist, _list *phead);
-
-/**
- * @brief  This function adds a new entry before "phead" for the list.
- * @param[in] plist: Pointer to the list to be added.
- * @param[in] phead: List head to add it before.
- * @return	  None
- */
-void	rtw_list_insert_tail(_list *plist, _list *phead);
-
-/**
- * @brief  This function deletes entry from list and reinitialize it.
- * @param[in] plist: The element to delete from the list.
- * @return	  None
- * @note	  Caller must check if the list is empty before calling rtw_list_delete
- */
-void	rtw_list_delete(_list *plist);
-/*************************** End List *******************************/
-
-
-/*************************** Semaphores *******************************/
-/**
- * @brief  This function initializes the unnamed semaphore referred to by "sema" to the value "init_val".
- * @param[in] sema: Pointer to the semaphore handle to be initialized.
- * @param[in] init_val: Initial value for semaphore.
- * @return	  None
- */
-void	rtw_init_sema(_sema *sema, int init_val);
-
-/**
- * @brief  This function deletes the semaphore.
- * @param[in] sema: The semaphore to be deleted.
- * @return	  None
- */
-void	rtw_free_sema(_sema *sema);
-
-/**
- * @brief  This function releases the semaphore.
- *		   This macro must not be used from an ISR.
- * @param[in] sema: The semaphore to be released.
- * @return	  None
- */
-void	rtw_up_sema(_sema	*sema);
-
-/**
- * @brief  This function releases the semaphore.
- *		   This macro can be used from an ISR.
- * @param[in] sema: The semaphore to be released.
- * @return	  None
- */
-void	rtw_up_sema_from_isr(_sema *sema);
-
-/**
- * @brief  This function acquires the semaphore. If no more tasks are allowed to acquire the semaphore,
- *		   calling this function will put the task to sleep until the semaphore is up.
- * @param[in] sema: The semaphore to be acquired.
- * @return	pdTRUE: The semaphore was obtained.
- * @return	pdFALSE: Obtain the semaphore failed.
- */
-uint32_t	rtw_down_sema(_sema *sema);
-
-/**
- * @brief  This function acquires the semaphore. If no more tasks are allowed to acquire the semaphore,
- *		   calling this function will put the task to sleep until the semaphore is up.
- * @param[in] sema: The semaphore to be acquired.
- * @param[in] timeout: The time in ms to wait for the semaphore to become available.
- * @return	pdTRUE: The semaphore was obtained.
- * @return	pdFALSE: Timeout without the semaphore becoming available.
- */
-uint32_t	rtw_down_timeout_sema(_sema *sema, uint32_t timeout);
-/*************************** End Semaphores *******************************/
-
-/*************************** Mutexes *******************************/
-/**
- * @brief  This function implements a mutex semaphore by using the existing queue mechanism.
- * @param[in] pmutex: Pointer to the created mutex semaphore.
- * @return	  None
- */
-void	rtw_mutex_init(_mutex *pmutex);
-
-/**
- * @brief  This function deletes the mutex semaphore.
- * @param[in] pmutex: Pointer to the mutex semaphore to be deleted.
- * @return	  None
- */
-void	rtw_mutex_free(_mutex *pmutex);
-
-/**
- * @brief  This function releases a mutex semaphore.
- * @param[in] pmutex: Pointer to the mutex semaphore to be released.
- * @return	  None
- */
-void	rtw_mutex_put(_mutex *pmutex);
-
-/**
- * @brief  This function obtains a mutex semaphore.
- * @param[in] pmutex: Pointer to the mutex semaphore being taken - obtained when
- *			  the mutex semaphore was created.
- * @return	  None
- */
-void	rtw_mutex_get(_mutex *pmutex);
-
-/**
- * @brief  This function obtains a mutex semaphore with a timeout setting.
- * @param[in] pmutex: Pointer to the mutex semaphore being taken - obtained when
- *			  the mutex semaphore was created.
- * @param[in] timeout: The time in ms to wait for the semaphore to become available.
- * @return	0: The semaphore was obtained.
- * @return	-1: Timeout without the semaphore becoming available.
- */
-int	rtw_mutex_get_timeout(_mutex *pmutex, uint32_t timeout_ms);
-/*************************** End Mutexes *******************************/
-
-/*************************** SchedulerControl *******************************/
-/**
- * @brief  This function marks the start of a critical code region.
- * 		   Preemptive context switches cannot occur when in a critical region.
- * @param[in] plock: Pointer to the spin lock semaphore.
- * @param[in] pirqL: Pointer to the IRQ.
- * @return	  None
- * @note: This may alter the stack (depending on the portable implementation)
- * so must be used with care!
- */
-void	rtw_enter_critical(_lock *plock, _irqL *pirqL);
-
-/**
- * @brief  This function marks end of a critical code region. Preemptive context
- * switches cannot occur when in a critical region.
- * @param[in] plock: Pointer to the spin lock semaphore.
- * @param[in] pirqL: Pointer to the IRQ.
- * @return	  None
- * @note: This may alter the stack (depending on the portable implementation)
- * so must be used with care!
- */
-void	rtw_exit_critical(_lock *plock, _irqL *pirqL);
-
-/**
- * @brief  This function marks the start of a critical code region from isr.
- * @param[in] plock: Pointer to the spin lock semaphore.
- * @param[in] pirqL: Pointer to the IRQ.
- * @return	  None
- */
-void	rtw_enter_critical_from_isr(_lock *plock, _irqL *pirqL);
-
-/**
- * @brief  This function marks the end of a critical code region from isr.
- * @param[in] plock: Pointer to the spin lock semaphore.
- * @param[in] pirqL: Pointer to the IRQ.
- * @return	  None
- */
-void	rtw_exit_critical_from_isr(_lock *plock, _irqL *pirqL);
-
-/**
- * @brief  This function obtains a spin lock semaphore.
- * @param[in] plock: Pointer to the spin lock semaphore being taken - obtained when
- *			  the mutex semaphore was created.
- * @param[in] pirqL: Pointer to the IRQ.
- * @return	  None
- */
-void	rtw_enter_critical_bh(_lock *plock, _irqL *pirqL);
-
-/**
- * @brief  This function releases a spin lock semaphore.
- * @param[in] plock: Pointer to the spin lock semaphore to be released.
- * @param[in] pirqL: Pointer to the IRQ.
- * @return	  None
- */
-void	rtw_exit_critical_bh(_lock *plock, _irqL *pirqL);
-
-/**
- * @brief  This function obtains a semaphore.
- * @param[in] pmutex: The handle to the mutex semaphore to be obtained.
- * @param[in] pirqL: Pointer to the IRQ.
- * @return	  None
- */
-int		rtw_enter_critical_mutex(_mutex *pmutex, _irqL *pirqL);
-
-/**
- * @brief  This function releases a semaphore.
- * @param[in] pmutex: The handle to the mutex semaphore to be released.
- * @param[in] pirqL: Pointer to the IRQ.
- * @return	  None
- */
-void	rtw_exit_critical_mutex(_mutex *pmutex, _irqL *pirqL);
-
-/**
- * @brief  This function will lock cpu. Can be used when xip active and want to do some flash operation.
- * @return	  None
- */
-void	rtw_cpu_lock(void);
-
-/**
-* @brief  This function unlock cpu.
-* @return	  None
-*/
-void	rtw_cpu_unlock(void);
-
-/*************************** End SchedulerControl *******************************/
-
-/*************************** Semaphores *******************************/
-
-/**
- * @brief  This function implements a spin lock semaphore by using the existing queue mechanism.
- * @param[in] plock: Pointer to the created spin lock semaphore.
- * @return	  None
- */
-void	rtw_spinlock_init(_lock *plock);
-
-/**
- * @brief  This function deletes the spin lock semaphore.
- * @param[in] pmutex: Pointer to the spin lock semaphore to be deleted.
- * @return	  None
- */
-void	rtw_spinlock_free(_lock *plock);
-
-/**
- * @brief  This function obtains a spin lock semaphore.
- * @param[in] plock: Pointer to the spin lock semaphore being taken - obtained when
- *			  the mutex semaphore was created.
- * @return	  None
- */
-void	rtw_spin_lock(_lock *plock);
-
-/**
- * @brief  This function releases a spin lock semaphore.
- * @param[in] plock: Pointer to the spin lock semaphore to be released.
- * @return	  None
- */
-void	rtw_spin_unlock(_lock *plock);
-
-/**
- * @brief  This function marks the start of a critical code region and
- *		   obtains a spin lock semaphore.
- * @param[in] plock: Pointer to the spin lock semaphore being taken - obtained when
- *			  the mutex semaphore was created.
- * @param[in] irqL: Pointer to the IRQ.
- * @return	  None
- */
-void	rtw_spinlock_irqsave(_lock *plock, _irqL *irqL);
-
-/**
- * @brief  This function releases a spin lock semaphore and
- 		   marks the end of a critical code region.
- * @param[in] plock: Pointer to the spin lock semaphore to be released.
- * @param[in] irqL: Pointer to the IRQ.
- * @return	  None
- */
-void	rtw_spinunlock_irqsave(_lock *plock, _irqL *irqL);
-/*************************** End Semaphores *******************************/
-
-/*************************** Queues *******************************/
-
-/**
- * @brief  This function creates a new queue instance.
- * @param[in] queue: The handle to the newly created queue.
- * @param[in] name: The name of the queue
- * @param[in] message_size: The number of bytes each message in the queue will require.
- * @param[in] number_of_messages: The maximum number of messages that kthe queue can contain.
- * @return	  0: Creating queue success
- * @return	  -1: Creating queue fail
- */
-int rtw_init_xqueue(_xqueue *queue, const char *name, uint32_t message_size, uint32_t number_of_messages);
-
-/**
- * @brief  This function posts a message to the back of a queue.
- *		   The message is queued by copy, not by reference.
- * @param[in] queue: The handle to the queue on which the message is to be posted.
- * @param[in] message: The pointer to the message that is to be placed on the queue.
- * @param[in] timeout_ms: The maximum amout of time the task should block waiting for
- 			              the space to become available on the queue, should it already be full.
- 			              The time is defined in ms.
- * @return	  0: The message was successfully posted.
- * @return	  -1: The message was not posted.
- */
-int rtw_push_to_xqueue(_xqueue *queue, void *message, uint32_t timeout_ms);
-
-/**
- * @brief  This function receives a message from a queue.
- *		   The message is recieved by copy so a buffer adequate size must be provided.
- * @param[in] queue: The handle to the queue from which the message is to be received.
- * @param[in] message: The pointer to the buffer into which the received message will be copied.
- * @param[in] timeout_ms: The maximum amout of time the task should block waiting for a message to
- *						  receive should the queue be empty at the time of the call.
- 			              The time is defined in ms.
- * @return	  0: A message was successfully received from the queue.
- * @return	  -1: No message was received from the queue.
- */
-int rtw_pop_from_xqueue(_xqueue *queue, void *message, uint32_t timeout_ms);
-
-int rtw_peek_from_xqueue(_xqueue *queue, void *message, uint32_t timeout_ms);
-
-/**
- * @brief  Delete a queue - freeing all the memory allocated for storing of messages placed on the queue.
- * @param[in] queue: The handle to the queue to be deleted.
- * @return	  0: The queue was successfully deleted.
- * @return	  -1: The queue was not empty so cannot be deleted.
- */
-int rtw_deinit_xqueue(_xqueue *queue);
-
-/**
- * @brief  This function creates a new queue instance.
- * @param[in] pqueue: The handle to the newly created queue.
- * @return	 None
- */
-void	rtw_init_queue(_queue	*pqueue);
-void	rtw_deinit_queue(_queue	*pqueue);
-uint32_t	rtw_is_queue_empty(_queue *pqueue);
-
-/**
- * @brief  This function tests whether the queue is empty.
- * @param[in] pqueue: The handle to the queue to be tested.
- * @return	 None
- */
-uint32_t	rtw_queue_empty(_queue	*pqueue);
-
-/**
- * @brief  This function tests whether the "pelement" is at the "queue".
- * @param[in] queue: The pointer to the queue that to be tested.
- * @param[in] pelement: The element that to be tested.
- * @return	 _TRUE/_FALSE
- */
-uint32_t	rtw_end_of_queue_search(_list *queue, _list *pelement);
-_list *rtw_get_queue_head(_queue	*queue);
-/*************************** End Queues *******************************/
-
-/*************************** Time Management *******************************/
-
-/**
- * @brief  Get the count of ticks since the vTaskStartScheduler was called.
- * @return	The count of ticks since the vTaskStartScheduler was called.
- */
-uint32_t	rtw_get_current_time(void);
-
-/**
- * @brief  Convert system time to milliseconds.
- * @param[in] systime: The system time to be converted.
- * @return : The milliseconds that converted by the system time.
- */
-uint32_t	rtw_systime_to_ms(uint32_t systime);
-
-/**
- * @brief  Convert system time to seconds.
- * @param[in] systime: The system time to be converted.
- * @return : The seconds that converted by the system time.
- */
-uint32_t rtw_systime_to_sec(uint32_t systime);
-
-/**
- * @brief  Convert milliseconds to system time.
- * @param[in] systime: The milliseconds to be converted.
- * @return : The system time that converted by the milliseconds.
- */
-uint32_t	rtw_ms_to_systime(uint32_t ms);
-
-/**
- * @brief  Convert seconds to system time.
- * @param[in] systime: The seconds to be converted.
- * @return : The system time that converted by the seconds.
- */
-uint32_t	rtw_sec_to_systime(uint32_t sec);
-
-/**
- * @brief  Get the passing time from the "start" in milliseconds.
- * @param[in] start: The start time which is in system time format.
- * @return : The passing time from "start" in milliseconds.
- */
-int32_t	rtw_get_passing_time_ms(uint32_t start);
-
-/**
- * @brief  Get the interval time from the "start" to "end" in milliseconds.
- * @param[in] start: The start time which is in system time format.
- * @param[in] end: The end time which is in system time format.
- * @return : The interval time from "start" to "end" in milliseconds.
- */
-int32_t	rtw_get_time_interval_ms(uint32_t start, uint32_t end);
-/*************************** End Time Management *******************************/
-
-/**
- * @brief  This function suspends execution of the calling thread for "ms" milliseconds.
- * @param[in] ms: The time that the function sleep in milliseconds
- * @return	  None
-*/
-void	rtw_msleep_os(int ms);
-
-/**
- * @brief  This function suspends execution of the calling thread for "us" microseconds.
- * @param[in] ms: The time that the function sleep in microseconds
- * @return	  None
-*/
-void	rtw_usleep_os(int us);
-
-/**
- * @brief  This function converts the initial portion of the string to integer.
- * @param[in] s: The pointer to the string to be converted.
- * @return	  The converted value.
-*/
-uint32_t 	rtw_atoi(uint8_t *s);
-
-/**
- * @brief  This function delays a task for the giving time in milliseconds.
- * @param[in] ms: The amount of time, in milliseconds, that the calling task should block.
- * @return	  None
-*/
-void	rtw_mdelay_os(int ms);
-
-/**
- * @brief  This function delays a task for the giving time in microseconds.
- * @param[in] ms: The amount of time, in microseconds, that the calling task should block.
- * @return	  None
-*/
-void	rtw_udelay_os(int us);
-
-/**
- * @brief  This function for forcing a context switch.
- * @return	  None
-*/
-void	rtw_yield_os(void);
-
-
-uint64_t	rtw_modular64(uint64_t x, uint64_t y);
-
-/**
- * @brief  This function generates random bytes.
- * @param[in] dst: The pointer to the buffer to store the random bytes.
- * @param[in] size: The size of the random bytes.
- * @return	  0
-*/
-int	rtw_get_random_bytes(void *dst, uint32_t size);
-
-/**
- * @brief  This function gets the available heap size.
- * @return	  The value of the available heap size.
-*/
-uint32_t	rtw_getFreeHeapSize(void);
-
-void	flush_signals_thread(void);
-
-/**
- * @brief  This function indicates that the WLAN needs to stay on which means cannot go into power saving mode.
- * @return  None
- * @note  Defining configUSE_WAKELOCK_PMU 1 in "FreeRTOSConfig.h" needs to be done before compiling,
- *			or this API won't be effective.
- */
-void	rtw_acquire_wakelock(void);
-
-/**
- * @brief  This function indicates that the WLAN does not need to stay on which means can go into power saving mode.
- * @return  None
- * @note  Defining configUSE_WAKELOCK_PMU 1 in "FreeRTOSConfig.h" needs to be done before compiling,
- *			or this API won't be effective.
- */
-void	rtw_release_wakelock(void);
-void rtw_wakelock_timeout(uint32_t timeout);
-
-/*********************************** Thread related *****************************************/
-
-/**
- * @brief  This function creates a new task and adds it to the list of tasks that are ready to run.
- * @param[in] task:  The task stucture which will store the task related infomation.
- * @param[in] name: A descriptive name for the task.
- * @param[in] stack_size: The size of the task stack specified as the variables the stack can hold.
- * @param[in] priority: The priority at which the task should run.
- * @param[in] func: The task entry function.
- * @param[in] thctx: The pointer that will be used as the parameter for the task being created.
- * @return  pdPASS: The task was successfully created and added to a ready list.
- * @return  other error code defined in the file errors.h.
- * @note  For the task name, please do not use "rtw_little_wifi_mcu_thread", "rtw_check_in_req_state_thread",
- 		  "rtw_TDMA_change_state_thread", "xmit_thread", "recv_thread", "rtw_recv_tasklet", "rtw_xmit_tasklet",
- 		  "rtw_interrupt_thread", "cmd_thread", "usb_init", "MSC_BULK_CMD" and "MSC_BULK_DATA".
- */
-int	rtw_create_task(struct task_struct *task, const char *name, uint32_t  stack_size, uint32_t priority, thread_func_t func, void *thctx);
-
-/**
- * @brief  This function deletes a task.
- * @param[in] task:  The task stucture which will be deleted.
- * @return  None
- */
-void rtw_delete_task(struct task_struct *task);
-
-/**
- * @brief  This function wake up a task.
- * @param[in] task:  The task stucture which will be waked up.
- * @return  None
- */
-void rtw_wakeup_task(struct task_struct *task);
-
-void rtw_set_priority_task(void *task, uint32_t NewPriority);
-
-int rtw_get_priority_task(void *task);
-
-void rtw_suspend_task(void *task);
-
-void rtw_resume_task(void *task);
-
-void rtw_suspend_task_all(void);
-
-void rtw_resume_task_all(void);
-
-
-#if 0 //TODO
-void	rtw_init_delayed_work(struct delayed_work *dwork, work_func_t func, const char *name);
-void	rtw_deinit_delayed_work(struct delayed_work *dwork);
-int		rtw_queue_delayed_work(struct workqueue_struct *wq, struct delayed_work *dwork, uint32_t delay, void *context);
-BOOLEAN rtw_cancel_delayed_work(struct delayed_work *dwork);
-#endif
-
-/**
- * @brief  This function prints the name of the thread in DBG_INFO.
- * @param[in] name:  The name of the thread.
- * @return  None
- */
-void	rtw_thread_enter(char *name);
-
-/**
- * @brief  This function exits the calling thread.
- * @return  None
- */
-void	rtw_thread_exit(void);
-
-/**
- * @brief  This function gets the scheduler state of the calling thread.
- * @return  OS_SCHEDULER_NOT_STARTED
- * @return  OS_SCHEDULER_RUNNING
- * @return  OS_SCHEDULER_SUSPENDED
- */
-uint8_t		rtw_get_scheduler_state(void);
-
-/**
- * @brief  This function creats secure stack for threads.
- * @param[in] secure_stack_size:  The size of the secure stack for this thread, the unit is byte.
- * @return  None
- */
-void rtw_create_secure_context(uint32_t secure_stack_size);
-
-/*************************** End Threads *******************************/
-#define rtw_warn_on(condition) do {} while (0)
-
-
-/*************************** Timers *******************************/
-
-/**
- * @brief  This function creates a new software timer instance.
- * @param[in] pcTimerName:  A text name that is assigned to the timer.
- * @param[in] xTimerPeriodInTicks: The timer period which is defined in tick periods.
- * @param[in] uxAutoReload: If uxAutoReload is set to pdTRUE then the timer will
- * expire repeatedly with a frequency set by the xTimerPeriodInTicks parameter.  If
- * uxAutoReload is set to pdFALSE then the timer will be a one-shot timer and
- * enter the dormant state after it expires.
- * @param[in] pvTimerID: An identifier that is assigned to the timer being created.
- * @param[in] pxCallbackFunction: The function to call when the timer expires.
- * @return  If the timer is successfully create then a handle to the newly
- * created timer is returned.  If the timer cannot be created, then 0 is returned.
- */
-_timerHandle rtw_timerCreate(const signed char *pcTimerName,
-							 osdepTickType xTimerPeriodInTicks,
-							 uint32_t uxAutoReload,
-							 void *pvTimerID,
-							 TIMER_FUN pxCallbackFunction);
-
-/**
- * @brief  This function deletes a timer that was previously created using rtw_timerCreate.
- * @param[in] xTimer:  The handle of the timer being deleted.
- * @param[in] xBlockTime: Specifies th etime, in ticks, that the calling task should be held in the Blocked
- *						  State to wait for the delete command to be successfully sent to the timer command queue,
- *						  should the queue already be full when rtw_timerDelete was called.
- * @return  pdFAIL will be returned if the delete command could not be sent to
- * the timer command queue even after xTicksToWait ticks had passed.  pdPASS will
- * be returned if the command was successfully sent to the timer command queue.
- * When the command is actually processed will depend on the priority of the
- * timer service/daemon task relative to other tasks in the system.
- */
-uint32_t rtw_timerDelete(_timerHandle xTimer, osdepTickType xBlockTime);
-
-/**
- * @brief  This function queries a timer to see if it is active or dormant.
- * @param[in] xTimer:  The timer being queried.
- * @return  pdFALSE will be returned if the timer is dormant.  A value other than
- * pdFALSE will be returned if the timer is active.
- * @note  A timer will be dormant if:
- *     1) It has been created but not started, or
- *     2) It is an expired one-shot timer that has not been restarted.
- */
-uint32_t rtw_timerIsTimerActive(_timerHandle xTimer);
-
-/**
- * @brief  This function stops a timer that was previously started.
- * @param[in] xTimer:  The handle of the timer being stopped.
- * @param[in] xBlockTime:  Specifies the time, in ticks, that the calling task should
- * be held in the Blocked state to wait for the stop command to be successfully
- * sent to the timer command queue, should the queue already be full when
- * rtw_timerStop() was called.
- * @return  pdFAIL will be returned if the stop command could not be sent to
- * the timer command queue even after xTicksToWait ticks had passed.  pdPASS will
- * be returned if the command was successfully sent to the timer command queue.
- * When the command is actually processed will depend on the priority of the
- * timer service/daemon task relative to other tasks in the system.
- */
-uint32_t rtw_timerStop(_timerHandle xTimer, osdepTickType xBlockTime);
-
-/**
- * @brief  This function changes the period of a timer that was previously created.
- * @param[in] xTimer:  The handle of the timer that is having its period changed.
- * @param[in] xNewPeriod:  The new period for xTimer.
- * @param[in] xBlockTime:  Specifies the time, in ticks, that the calling task should
- * be held in the Blocked state to wait for the change period command to be
- * successfully sent to the timer command queue, should the queue already be
- * full when rtw_timerChangePeriod() was called.
- * @return  pdFAIL will be returned if the change period command could not be
- * sent to the timer command queue even after xTicksToWait ticks had passed.
- * pdPASS will be returned if the command was successfully sent to the timer
- * command queue.  When the command is actually processed will depend on the
- * priority of the timer service/daemon task relative to other tasks in the
- * system.
- */
-uint32_t rtw_timerChangePeriod(_timerHandle xTimer,
-							   osdepTickType xNewPeriod,
-							   osdepTickType xBlockTime);
-
-void *rtw_timerGetID(_timerHandle xTimer);
-
-uint32_t  rtw_timerStart(_timerHandle xTimer, osdepTickType xBlockTime);
-
-uint32_t  rtw_timerStartFromISR(_timerHandle xTimer,
-								osdepBASE_TYPE *pxHigherPriorityTaskWoken);
-
-uint32_t  rtw_timerStopFromISR(_timerHandle xTimer,
-							   osdepBASE_TYPE *pxHigherPriorityTaskWoken);
-
-uint32_t  rtw_timerResetFromISR(_timerHandle xTimer,
-								osdepBASE_TYPE *pxHigherPriorityTaskWoken);
-
-uint32_t  rtw_timerChangePeriodFromISR(_timerHandle xTimer,
-									   osdepTickType xNewPeriod,
-									   osdepBASE_TYPE *pxHigherPriorityTaskWoken);
-
-uint32_t  rtw_timerReset(_timerHandle xTimer,
-						 osdepTickType xBlockTime);
-
-
-/*************************** End Timers *******************************/
-#ifdef LIST_CONTAINOR
-#undef LIST_CONTAINOR
-#endif
-#define LIST_CONTAINOR(ptr, type, member) \
-	((type *)(void*)((char *)(ptr)-(unsigned int)((char *)&((type *)(void*)ptr)->member - (char *)ptr)))
-
-#ifndef time_after
-#define time_after(a,b)	((long)(b) - (long)(a) < 0)
-#endif
-#ifndef time_before
-#define time_before(a,b)	time_after(b,a)
-#endif
-#ifndef time_after_eq
-#define time_after_eq(a,b)	((long)(a) - (long)(b) >= 0)
-#endif
-#ifndef time_before_eq
-#define time_before_eq(a,b)	time_after_eq(b,a)
-#endif
-
-#define _RND(sz, r) ((((sz)+((r)-1))/(r))*(r))
-#define RND4(x)	(((x >> 2) + (((x & 3) == 0) ?  0: 1)) << 2)
-
-__inline static uint32_t _RND4(uint32_t sz)
-{
-	uint32_t	val;
-
-	val = ((sz >> 2) + ((sz & 3) ? 1 : 0)) << 2;
-
-	return val;
-}
-
-__inline static uint32_t _RND8(uint32_t sz)
-{
-	uint32_t	val;
-
-	val = ((sz >> 3) + ((sz & 7) ? 1 : 0)) << 3;
-
-	return val;
-}
-
-__inline static uint32_t _RND128(uint32_t sz)
-{
-	uint32_t	val;
-
-	val = ((sz >> 7) + ((sz & 127) ? 1 : 0)) << 7;
-
-	return val;
-}
-
-__inline static uint32_t _RND256(uint32_t sz)
-{
-	uint32_t	val;
-
-	val = ((sz >> 8) + ((sz & 255) ? 1 : 0)) << 8;
-
-	return val;
-}
-
-__inline static uint32_t _RND512(uint32_t sz)
-{
-	uint32_t	val;
-
-	val = ((sz >> 9) + ((sz & 511) ? 1 : 0)) << 9;
-
-	return val;
-}
-
-__inline static uint32_t bitshift(uint32_t bitmask)
-{
-	uint32_t i;
-
-	for (i = 0; i <= 31; i++)
-		if (((bitmask >> i) &  0x1) == 1) {
-			break;
-		}
-
-	return i;
-}
-
-#define rtw_min(a, b) ((a > b) ? b : a)
-#define rtw_is_range_a_in_b(hi_a, lo_a, hi_b, lo_b) (((hi_a) <= (hi_b)) && ((lo_a) >= (lo_b)))
-#define rtw_is_range_overlap(hi_a, lo_a, hi_b, lo_b) (((hi_a) > (lo_b)) && ((lo_a) < (hi_b)))
-
-/* Macros for handling unaligned memory accesses */
-
-#define RTW_GET_BE16(a) ((uint16_t) (((a)[0] << 8) | (a)[1]))
-#define RTW_PUT_BE16(a, val)			\
-	do {					\
-		(a)[0] = ((uint16_t) (val)) >> 8;	\
-		(a)[1] = ((uint16_t) (val)) & 0xff;	\
-	} while (0)
-
-#define RTW_GET_LE16(a) ((uint16_t) (((a)[1] << 8) | (a)[0]))
-#define RTW_PUT_LE16(a, val)			\
-	do {					\
-		(a)[1] = ((uint16_t) (val)) >> 8;	\
-		(a)[0] = ((uint16_t) (val)) & 0xff;	\
-	} while (0)
-
-#define RTW_GET_BE24(a) ((((uint32_t) (a)[0]) << 16) | (((uint32_t) (a)[1]) << 8) | \
-			 ((uint32_t) (a)[2]))
-#define RTW_PUT_BE24(a, val)					\
-	do {							\
-		(a)[0] = (uint8_t) ((((uint32_t) (val)) >> 16) & 0xff);	\
-		(a)[1] = (uint8_t) ((((uint32_t) (val)) >> 8) & 0xff);	\
-		(a)[2] = (uint8_t) (((uint32_t) (val)) & 0xff);		\
-	} while (0)
-
-#define RTW_GET_BE32(a) ((((uint32_t) (a)[0]) << 24) | (((uint32_t) (a)[1]) << 16) | \
-			 (((uint32_t) (a)[2]) << 8) | ((uint32_t) (a)[3]))
-#define RTW_PUT_BE32(a, val)					\
-	do {							\
-		(a)[0] = (uint8_t) ((((uint32_t) (val)) >> 24) & 0xff);	\
-		(a)[1] = (uint8_t) ((((uint32_t) (val)) >> 16) & 0xff);	\
-		(a)[2] = (uint8_t) ((((uint32_t) (val)) >> 8) & 0xff);	\
-		(a)[3] = (uint8_t) (((uint32_t) (val)) & 0xff);		\
-	} while (0)
-
-#define RTW_GET_LE32(a) ((((uint32_t) (a)[3]) << 24) | (((uint32_t) (a)[2]) << 16) | \
-			 (((uint32_t) (a)[1]) << 8) | ((uint32_t) (a)[0]))
-#define RTW_PUT_LE32(a, val)					\
-	do {							\
-		(a)[3] = (uint8_t) ((((uint32_t) (val)) >> 24) & 0xff);	\
-		(a)[2] = (uint8_t) ((((uint32_t) (val)) >> 16) & 0xff);	\
-		(a)[1] = (uint8_t) ((((uint32_t) (val)) >> 8) & 0xff);	\
-		(a)[0] = (uint8_t) (((uint32_t) (val)) & 0xff);		\
-	} while (0)
-
-#define RTW_GET_BE64(a) ((((uint64_t) (a)[0]) << 56) | (((uint64_t) (a)[1]) << 48) | \
-			 (((uint64_t) (a)[2]) << 40) | (((uint64_t) (a)[3]) << 32) | \
-			 (((uint64_t) (a)[4]) << 24) | (((uint64_t) (a)[5]) << 16) | \
-			 (((uint64_t) (a)[6]) << 8) | ((uint64_t) (a)[7]))
-#define RTW_PUT_BE64(a, val)				\
-	do {						\
-		(a)[0] = (uint8_t) (((uint64_t) (val)) >> 56);	\
-		(a)[1] = (uint8_t) (((uint64_t) (val)) >> 48);	\
-		(a)[2] = (uint8_t) (((uint64_t) (val)) >> 40);	\
-		(a)[3] = (uint8_t) (((uint64_t) (val)) >> 32);	\
-		(a)[4] = (uint8_t) (((uint64_t) (val)) >> 24);	\
-		(a)[5] = (uint8_t) (((uint64_t) (val)) >> 16);	\
-		(a)[6] = (uint8_t) (((uint64_t) (val)) >> 8);	\
-		(a)[7] = (uint8_t) (((uint64_t) (val)) & 0xff);	\
-	} while (0)
-
-#define RTW_GET_LE64(a) ((((uint64_t) (a)[7]) << 56) | (((uint64_t) (a)[6]) << 48) | \
-			 (((uint64_t) (a)[5]) << 40) | (((uint64_t) (a)[4]) << 32) | \
-			 (((uint64_t) (a)[3]) << 24) | (((uint64_t) (a)[2]) << 16) | \
-			 (((uint64_t) (a)[1]) << 8) | ((uint64_t) (a)[0]))
-
-struct osdep_service_ops {
-	void *(*rtw_vmalloc)(uint32_t sz);
-	void *(*rtw_zvmalloc)(uint32_t sz);
-	void (*rtw_vmfree)(uint8_t *pbuf, uint32_t sz);
-	void *(*rtw_malloc)(uint32_t sz);
-	void *(*rtw_zmalloc)(uint32_t sz);
-	void (*rtw_mfree)(uint8_t *pbuf, uint32_t sz);
-	void (*rtw_memcpy)(void *dst, void *src, uint32_t sz);
-	int (*rtw_memcmp)(void *dst, void *src, uint32_t sz);
-	void (*rtw_memset)(void *pbuf, int c, uint32_t sz);
-	void (*rtw_init_sema)(_sema *sema, int init_val);
-	void (*rtw_free_sema)(_sema *sema);
-	void (*rtw_up_sema)(_sema *sema);
-	void (*rtw_up_sema_from_isr)(_sema *sema);
-	uint32_t(*rtw_down_timeout_sema)(_sema *sema, uint32_t timeout);
-	void (*rtw_mutex_init)(_mutex *pmutex);
-	void (*rtw_mutex_free)(_mutex *pmutex);
-	void (*rtw_mutex_get)(_mutex *pmutex);
-	int (*rtw_mutex_get_timeout)(_mutex *pmutex, uint32_t timeout_ms);
-	void (*rtw_mutex_put)(_mutex *pmutex);
-	void (*rtw_enter_critical)(_lock *plock, _irqL *pirqL);
-	void (*rtw_exit_critical)(_lock *plock, _irqL *pirqL);
-	void (*rtw_enter_critical_from_isr)(_lock *plock, _irqL *pirqL);
-	void (*rtw_exit_critical_from_isr)(_lock *plock, _irqL *pirqL);
-	void (*rtw_enter_critical_bh)(_lock *plock, _irqL *pirqL);
-	void (*rtw_exit_critical_bh)(_lock *plock, _irqL *pirqL);
-	int (*rtw_enter_critical_mutex)(_mutex *pmutex, _irqL *pirqL);
-	void (*rtw_exit_critical_mutex)(_mutex *pmutex, _irqL *pirqL);
-	void (*rtw_cpu_lock)(void);
-	void (*rtw_cpu_unlock)(void);
-	void (*rtw_spinlock_init)(_lock *plock);
-	void (*rtw_spinlock_free)(_lock *plock);
-	void (*rtw_spin_lock)(_lock *plock);
-	void (*rtw_spin_unlock)(_lock *plock);
-	void (*rtw_spinlock_irqsave)(_lock *plock, _irqL *irqL);
-	void (*rtw_spinunlock_irqsave)(_lock *plock, _irqL *irqL);
-	int (*rtw_init_xqueue)(_xqueue *queue, const char *name, uint32_t message_size, uint32_t number_of_messages);
-	int (*rtw_push_to_xqueue)(_xqueue *queue, void *message, uint32_t timeout_ms);
-	int (*rtw_pop_from_xqueue)(_xqueue *queue, void *message, uint32_t timeout_ms);
-	int (*rtw_peek_from_xqueue)(_xqueue *queue, void *message, uint32_t timeout_ms);
-	int (*rtw_deinit_xqueue)(_xqueue *queue);
-	uint32_t(*rtw_get_current_time)(void);
-	uint32_t(*rtw_systime_to_ms)(uint32_t systime);
-	uint32_t(*rtw_systime_to_sec)(uint32_t systime);
-	uint32_t(*rtw_ms_to_systime)(uint32_t ms);
-	uint32_t(*rtw_sec_to_systime)(uint32_t sec);
-	void (*rtw_msleep_os)(int ms);
-	void (*rtw_usleep_os)(int us);
-	void (*rtw_mdelay_os)(int ms);
-	void (*rtw_udelay_os)(int us);
-	void (*rtw_yield_os)(void);
-	void (*ATOMIC_SET)(ATOMIC_T *v, int i);
-	int (*ATOMIC_READ)(ATOMIC_T *v);
-	void (*ATOMIC_ADD)(ATOMIC_T *v, int i);
-	void (*ATOMIC_SUB)(ATOMIC_T *v, int i);
-	void (*ATOMIC_INC)(ATOMIC_T *v);
-	void (*ATOMIC_DEC)(ATOMIC_T *v);
-	int (*ATOMIC_ADD_RETURN)(ATOMIC_T *v, int i);
-	int (*ATOMIC_SUB_RETURN)(ATOMIC_T *v, int i);
-	int (*ATOMIC_INC_RETURN)(ATOMIC_T *v);
-	int (*ATOMIC_DEC_RETURN)(ATOMIC_T *v);
-	uint64_t(*rtw_modular64)(uint64_t x, uint64_t y);
-	int (*rtw_get_random_bytes)(void *dst, uint32_t size);
-	uint32_t(*rtw_getFreeHeapSize)(void);
-	int (*rtw_create_task)(struct task_struct *task, const char *name, uint32_t stack_size, uint32_t priority, thread_func_t func, void *thctx);
-	void (*rtw_delete_task)(struct task_struct *task);
-	void (*rtw_wakeup_task)(struct task_struct *task);
-	void (*rtw_set_priority_task)(void *task, uint32_t NewPriority);
-	int (*rtw_get_priority_task)(void *task);
-	void (*rtw_suspend_task)(void *task);
-	void (*rtw_resume_task)(void *task);
-	void (*rtw_suspend_task_all)(void);
-	void (*rtw_resume_task_all)(void);
-
-#if 0	//TODO
-	void (*rtw_init_delayed_work)(struct delayed_work *dwork, work_func_t func, const char *name);
-	void (*rtw_deinit_delayed_work)(struct delayed_work *dwork);
-	int (*rtw_queue_delayed_work)(struct workqueue_struct *wq, struct delayed_work *dwork, unsigned long delay, void *context);
-	BOOLEAN(*rtw_cancel_delayed_work)(struct delayed_work *dwork);
-#endif
-	void (*rtw_thread_enter)(char *name);
-	void (*rtw_thread_exit)(void);
-	_timerHandle(*rtw_timerCreate)(const signed char *pcTimerName,
-								   osdepTickType xTimerPeriodInTicks,
-								   uint32_t uxAutoReload,
-								   void *pvTimerID,
-								   TIMER_FUN pxCallbackFunction);
-	uint32_t(*rtw_timerDelete)(_timerHandle xTimer,
-							   osdepTickType xBlockTime);
-	uint32_t(*rtw_timerIsTimerActive)(_timerHandle xTimer);
-	uint32_t(*rtw_timerStop)(_timerHandle xTimer,
-							 osdepTickType xBlockTime);
-	uint32_t(*rtw_timerChangePeriod)(_timerHandle xTimer,
-									 osdepTickType xNewPeriod,
-									 osdepTickType xBlockTime);
-	void *(*rtw_timerGetID)(_timerHandle xTimer);
-	uint32_t(*rtw_timerStart)(_timerHandle xTimer,
-							  osdepTickType xBlockTime);
-	uint32_t(*rtw_timerStartFromISR)(_timerHandle xTimer,
-									 osdepBASE_TYPE *pxHigherPriorityTaskWoken);
-
-	uint32_t(*rtw_timerStopFromISR)(_timerHandle xTimer,
-									osdepBASE_TYPE *pxHigherPriorityTaskWoken);
-
-	uint32_t(*rtw_timerResetFromISR)(_timerHandle xTimer,
-									 osdepBASE_TYPE *pxHigherPriorityTaskWoken);
-
-	uint32_t(*rtw_timerChangePeriodFromISR)(_timerHandle xTimer,
-											osdepTickType xNewPeriod,
-											osdepBASE_TYPE *pxHigherPriorityTaskWoken);
-
-	uint32_t(*rtw_timerReset)(_timerHandle xTimer,
-							  osdepTickType xBlockTime);
-
-	void (*rtw_acquire_wakelock)(void);
-	void (*rtw_release_wakelock)(void);
-	void (*rtw_wakelock_timeout)(uint32_t timeoutMs);
-	uint8_t(*rtw_get_scheduler_state)(void);
-	void (*rtw_create_secure_context)(uint32_t secure_stack_size);
-	void *(*rtw_get_current_TaskHandle)(void);
-#if( configSUPPORT_STATIC_ALLOCATION == 1 )
-	void (*rtw_init_sema_static)(_sema *sema, int init_val, StaticSemaphore_t *xSemaphoreBuffer);
-	void (*rtw_mutex_init_static)(_mutex *pmutex, StaticSemaphore_t *xSemaphoreBuffer);
-	void (*rtw_spinlock_init_static)(_lock *plock, StaticSemaphore_t *xSemaphoreBuffer);
-#endif
-};
-
-#ifdef __cplusplus
-}
-#endif
-
-/*************************** ATOMIC Integer *******************************/
-
-/**
- * @brief  This function atomically sets the value of the variable.
- * @param[in] v: Pointer of type atomic_t that to be set value.
- * @param[in] i: Required value.
- * @return	  None
- * @note    The guaranteed useful range of an atomic_t is only 24 bits.
-*/
-void 	ATOMIC_SET(ATOMIC_T *v, int i);
-
-/**
- * @brief  This function atomically reads the value of the variable.
- * @param[in] v: Pointer of type atomic_t that to be read.
- * @return	  The value of the variable.
- * @note	The guaranteed useful range of an atomic_t is only 24 bits.
-*/
-int		ATOMIC_READ(ATOMIC_T *v);
-
-/**
- * @brief  This function adds "i" to the contained "v".
- * @param[in] v: Pointer of type atomic_t.
- * @param[in] i: value to add.
- * @return	  None
-*/
-void 	ATOMIC_ADD(ATOMIC_T *v, int i);
-
-/**
- * @brief  This function subtracts "i" from th econtained "v".
- * @param[in] v: Pointer of type atomic_t.
- * @param[in] i: value to subtract.
- * @return	  None
-*/
-void 	ATOMIC_SUB(ATOMIC_T *v, int i);
-
-/**
- * @brief  This function adds 1 to the contained "v".
- * @param[in] v: Pointer of type atomic_t.
- * @return	  None
-*/
-void 	ATOMIC_INC(ATOMIC_T *v);
-
-/**
- * @brief  This function subtracts 1 from th econtained "v".
- * @param[in] v: Pointer of type atomic_t.
- * @return	  None
-*/
-void 	ATOMIC_DEC(ATOMIC_T *v);
-
-/**
- * @brief  This function adds "i" to the contained "v" and returns the result.
- * @param[in] v: Pointer of type atomic_t.
- * @param[in] i: value to add.
- * @return	  None
-*/
-int 	ATOMIC_ADD_RETURN(ATOMIC_T *v, int i);
-
-/**
- * @brief  This function subtracts "i" from th econtained "v" and returns the result.
- * @param[in] v: Pointer of type atomic_t.
- * @param[in] i: value to subtract.
- * @return	  None
-*/
-int 	ATOMIC_SUB_RETURN(ATOMIC_T *v, int i);
-
-/**
- * @brief  This function adds 1 to the contained "v" and returns the result.
- * @param[in] v: Pointer of type atomic_t.
- * @return	  None
-*/
-int 	ATOMIC_INC_RETURN(ATOMIC_T *v);
-
-/**
- * @brief  This function subtracts 1 from th econtained "v" and returns the result.
- * @param[in] v: Pointer of type atomic_t.
- * @return	  None
-*/
-int 	ATOMIC_DEC_RETURN(ATOMIC_T *v);
-
-/**
- * @brief  This function subtracts 1 from th econtained "v" and test if the result equals 0.
- * @param[in] v: Pointer of type atomic_t.
- * @return	  0: The result after subtracting 1 is 0
- * @return	 -1: The result after subtracting 1 is not 0
-*/
-int ATOMIC_DEC_AND_TEST(ATOMIC_T *v);
-/*************************** End ATOMIC *******************************/
-
-/*\@}*/
-
-void init_mutex_pool(void);
-
-#endif	//#ifndef __OSDEP_SERVICE_H_
-
diff --git a/os/board/rtl8720e/src/component/os/os_dep/include/psram_reserve.h b/os/board/rtl8720e/src/component/os/os_dep/include/psram_reserve.h
deleted file mode 100644
index 884b41688..000000000
--- a/os/board/rtl8720e/src/component/os/os_dep/include/psram_reserve.h
+++ /dev/null
@@ -1,55 +0,0 @@
-#ifndef _PSRAM_RESERVE_H_
-#define _PSRAM_RESERVE_H_
-
-//#include <stdio.h>
-#include <stdint.h>
-#include <osdep_service.h>
-
-/* NOTE: struct size must be a 2's power! */
-typedef struct _PsramMemChunk {
-	struct _PsramMemChunk *next;
-	int size;
-} PsramMemChunk;
-
-typedef PsramMemChunk Psram_heap_buf_t;
-
-// A heap
-typedef struct Psram_Heap {
-	struct _PsramMemChunk *FreeList;	///< Head of the free list
-} Psram_Heap;
-
-
-/**
- * Utility macro to allocate a heap of size \a size.
- *
- * \param name Variable name for the heap.
- * \param size Heap size in bytes.
- */
-#define PSRAM_HEAP_DEFINE_BUF(name, size) \
-	Psram_heap_buf_t name[((size) + sizeof(Psram_heap_buf_t) - 1) / sizeof(Psram_heap_buf_t)]
-
-
-#define Psram_ROUND_UP2(x, pad) (((x) + ((pad) - 1)) & ~((pad) - 1))
-
-/// Initialize \a heap within the buffer pointed by \a memory which is of \a size bytes
-void Psram_heap_init(void);
-
-/// Allocate a chunk of memory of \a size bytes from the heap
-void *Psram_heap_allocmem(int size);
-
-/// Free a chunk of memory of \a size bytes from the heap
-void Psram_reserved_heap_freemem(void *mem, int size);
-
-int Psram_reserve_free_size(void);
-
-/**
- * \name Compatibility interface with C standard library
- * \{
- */
-void *Psram_reserve_malloc(int size);
-void *Psram_reserve_calloc(int num, int size);
-void Psram_reserve_free(void *mem);
-/** \} */
-
-extern int g_Psram_heap_inited;
-#endif /* _PSRAM_RESERVE_H_ */
diff --git a/os/board/rtl8720e/src/component/os/os_dep/include/tcm_heap.h b/os/board/rtl8720e/src/component/os/os_dep/include/tcm_heap.h
deleted file mode 100644
index 061e20c88..000000000
--- a/os/board/rtl8720e/src/component/os/os_dep/include/tcm_heap.h
+++ /dev/null
@@ -1,64 +0,0 @@
-#ifndef STRUCT_HEAP_H
-#define STRUCT_HEAP_H
-
-//#include <stdio.h>
-#include <stdint.h>
-#include <osdep_service.h>
-
-/* NOTE: struct size must be a 2's power! */
-typedef struct _MemChunk {
-	struct _MemChunk *next;
-	int size;
-} MemChunk;
-
-typedef MemChunk heap_buf_t;
-
-/// A heap
-typedef struct Heap {
-	struct _MemChunk *FreeList;     ///< Head of the free list
-} Heap;
-
-/**
- * Utility macro to allocate a heap of size \a size.
- *
- * \param name Variable name for the heap.
- * \param size Heap size in bytes.
- */
-#define HEAP_DEFINE_BUF(name, size) \
-	heap_buf_t name[((size) + sizeof(heap_buf_t) - 1) / sizeof(heap_buf_t)]
-
-/// Initialize \a heap within the buffer pointed by \a memory which is of \a size bytes
-void tcm_heap_init(void);
-
-/// Allocate a chunk of memory of \a size bytes from the heap
-void *tcm_heap_allocmem(int size);
-
-/// Free a chunk of memory of \a size bytes from the heap
-void tcm_heap_freemem(void *mem, int size);
-
-int tcm_heap_freeSpace(void);
-
-#define HNEW(heap, type) \
-	(type*)tcm_heap_allocmem(heap, sizeof(type))
-
-#define HNEWVEC(heap, type, nelem) \
-	(type*)tcm_heap_allocmem(heap, sizeof(type) * (nelem))
-
-#define HDELETE(heap, type, mem) \
-	tcm_heap_freemem(heap, mem, sizeof(type))
-
-#define HDELETEVEC(heap, type, nelem, mem) \
-	tcm_heap_freemem(heap, mem, sizeof(type) * (nelem))
-
-
-/**
- * \name Compatibility interface with C standard library
- * \{
- */
-void *tcm_heap_malloc(int size);
-void *tcm_heap_calloc(int size);
-void tcm_heap_free(void *mem);
-/** \} */
-
-
-#endif /* STRUCT_HEAP_H */
diff --git a/os/board/rtl8720e/src/component/os/os_dep/osdep_service.c b/os/board/rtl8720e/src/component/os/os_dep/osdep_service.c
deleted file mode 100644
index 8f84cbd0c..000000000
--- a/os/board/rtl8720e/src/component/os/os_dep/osdep_service.c
+++ /dev/null
@@ -1,1597 +0,0 @@
-/******************************************************************************
- *
- * Copyright(c) 2007 - 2012 Realtek Corporation. All rights reserved.
- *
- ******************************************************************************/
-#include <osdep_service.h>
-#if defined(CONFIG_USE_TCM_HEAP) && CONFIG_USE_TCM_HEAP
-#include "tcm_heap.h"
-#endif
-
-#define OSDEP_DBG(x, ...) do {} while(0)
-
-extern struct osdep_service_ops osdep_service;
-
-#if( configSUPPORT_STATIC_ALLOCATION == 1 )
-
-int max_mutex_num = MAX_MUTEX_BUF_NUM;
-struct mutex_buf {
-	struct list_head list;
-	StaticSemaphore_t mutex;
-};
-
-struct mutex_buf mutex_pool[MAX_MUTEX_BUF_NUM];
-static struct list_head wrapper_mutexbuf_list;
-int mutexbuf_used_num, mutex_dynamic_num;
-int max_mutexbuf_used_num;
-int mutexpool_flag = 0;
-
-static __inline__ void *get_mutex_from_poll(struct list_head *phead, int *count)
-{
-	StaticSemaphore_t *mutex;
-	struct list_head *plist;
-
-	if (mutexpool_flag == 0) {
-		return NULL;
-	}
-
-	save_and_cli();
-	if (list_empty(phead)) {
-		restore_flags();
-		return NULL;
-	}
-
-	plist = phead->next;
-	list_del_init(plist);
-
-	mutex = (StaticSemaphore_t *)((unsigned int)plist + sizeof(struct list_head));
-
-	*count = *count + 1;
-
-	restore_flags();
-
-	return (unsigned char *)mutex;
-}
-
-static void release_mutex_to_poll(unsigned char *buf, struct list_head *phead, int *count)
-{
-	struct list_head *plist;
-	plist = (struct list_head *)(((unsigned int)buf) - sizeof(struct list_head));
-	list_add_tail(plist, phead);
-
-	*count = *count - 1;
-}
-
-static u8 rtw_get_mutex_dynamic_flag(_sema sema)
-{
-	StaticSemaphore_t *pqueue = (StaticSemaphore_t *)sema;
-	return pqueue->ucDummy6;
-}
-
-#endif
-
-void init_mutex_pool(void)
-{
-#if( configSUPPORT_STATIC_ALLOCATION == 1 )
-	int i;
-
-	memset(mutex_pool, '\0', max_mutex_num * sizeof(struct mutex_buf));
-	INIT_LIST_HEAD(&wrapper_mutexbuf_list);
-
-	for (i = 0; i < max_mutex_num; i++) {
-		INIT_LIST_HEAD(&mutex_pool[i].list);
-		list_add_tail(&mutex_pool[i].list, &wrapper_mutexbuf_list);
-	}
-
-	mutexbuf_used_num = 0;
-	max_mutexbuf_used_num = 0;
-	mutex_dynamic_num = 0;
-
-	mutexpool_flag = 1;
-#endif
-}
-
-u16
-_htons(u16 n)
-{
-	return ((n & 0xff) << 8) | ((n & 0xff00) >> 8);
-}
-
-u16
-_ntohs(u16 n)
-{
-	return _htons(n);
-}
-
-u32
-_htonl(u32 n)
-{
-	return ((n & 0xff) << 24) |
-		   ((n & 0xff00) << 8) |
-		   ((n & 0xff0000UL) >> 8) |
-		   ((n & 0xff000000UL) >> 24);
-}
-
-u32
-_ntohl(u32 n)
-{
-	return _htonl(n);
-}
-
-/*
-* Translate the OS dependent @param error_code to OS independent RTW_STATUS_CODE
-* @return: one of RTW_STATUS_CODE
-*/
-int RTW_STATUS_CODE(int error_code)
-{
-	if (error_code >= 0) {
-		return _SUCCESS;
-	}
-
-	return _FAIL;
-}
-
-u32 rtw_atoi(u8 *s)
-{
-	int num = 0, flag = 0;
-	u32 i;
-
-	for (i = 0; i <= strlen((char *)s); i++) {
-		if (s[i] >= '0' && s[i] <= '9') {
-			num = num * 10 + s[i] - '0';
-		} else if (s[0] == '-' && i == 0) {
-			flag = 1;
-		} else {
-			break;
-		}
-	}
-
-	if (flag == 1) {
-		num = num * -1;
-	}
-
-	return (num);
-}
-#if defined(CONFIG_USE_TCM_HEAP) && CONFIG_USE_TCM_HEAP
-void *tcm_heap_malloc(int size);
-void *tcm_heap_calloc(int size);
-#endif
-void *_rtw_vmalloc(u32 sz)
-{
-	void *pbuf = NULL;
-#if defined(CONFIG_USE_TCM_HEAP) && CONFIG_USE_TCM_HEAP
-	pbuf = tcm_heap_malloc(sz);
-#endif
-	if (pbuf == NULL) {
-		if (osdep_service.rtw_vmalloc) {
-			pbuf = osdep_service.rtw_vmalloc(sz);
-		} else {
-			OSDEP_DBG("Not implement osdep service: rtw_vmalloc");
-		}
-	}
-	return pbuf;
-}
-
-void *_rtw_zvmalloc(u32 sz)
-{
-	void *pbuf = NULL;
-#if defined(CONFIG_USE_TCM_HEAP) && CONFIG_USE_TCM_HEAP
-	pbuf = tcm_heap_calloc(sz);
-#endif
-	if (pbuf == NULL) {
-		if (osdep_service.rtw_zvmalloc) {
-			pbuf = osdep_service.rtw_zvmalloc(sz);
-		} else {
-			OSDEP_DBG("Not implement osdep service: rtw_zvmalloc");
-		}
-	}
-	return pbuf;
-}
-
-void _rtw_vmfree(u8 *pbuf, u32 sz)
-{
-
-#if defined(CONFIG_USE_TCM_HEAP) && CONFIG_USE_TCM_HEAP
-	if ((u32)pbuf > 0x1FFF0000 && (u32)pbuf < 0x20000000) {
-		tcm_heap_free(pbuf);
-	} else
-#endif
-	{
-		if (osdep_service.rtw_vmfree) {
-			osdep_service.rtw_vmfree(pbuf, sz);
-		} else {
-			OSDEP_DBG("Not implement osdep service: rtw_vmfree");
-		}
-	}
-}
-
-void *_rtw_malloc(u32 sz)
-{
-	if (osdep_service.rtw_malloc) {
-		void *pbuf = osdep_service.rtw_malloc(sz);
-		return pbuf;
-	} else {
-		OSDEP_DBG("Not implement osdep service: rtw_malloc");
-	}
-
-	return NULL;
-}
-
-void *_rtw_zmalloc(u32 sz)
-{
-	if (osdep_service.rtw_zmalloc) {
-		void *pbuf = osdep_service.rtw_zmalloc(sz);
-		return pbuf;
-	} else {
-		OSDEP_DBG("Not implement osdep service: rtw_zmalloc");
-	}
-
-	return NULL;
-}
-
-void *_rtw_calloc(u32 nelements, u32 elementSize)
-{
-	u32 sz = nelements * elementSize;
-	void *pbuf = _rtw_zmalloc(sz);
-	return pbuf;
-}
-
-void _rtw_mfree(u8 *pbuf, u32 sz)
-{
-	if (osdep_service.rtw_mfree) {
-		osdep_service.rtw_mfree(pbuf, sz);
-	} else {
-		OSDEP_DBG("Not implement osdep service: rtw_mfree");
-	}
-}
-
-void *rtw_vmalloc(u32 sz)
-{
-	void *pbuf = _rtw_vmalloc(sz);
-#ifdef CONFIG_DEBUG_MM_HEAPINFO
-        if (pbuf)
-        {
-            DEBUG_SET_CALLER_ADDR(pbuf);
-        }
-#endif
-	return pbuf;
-}
-
-void *rtw_zvmalloc(u32 sz)
-{
-	void *pbuf = _rtw_zvmalloc(sz);
-#ifdef CONFIG_DEBUG_MM_HEAPINFO
-        if (pbuf)
-        {
-            DEBUG_SET_CALLER_ADDR(pbuf);
-        }
-#endif
-	return pbuf;
-}
-
-void rtw_vmfree(u8 *pbuf, u32 sz)
-{
-	_rtw_vmfree(pbuf, sz);
-}
-
-void *rtw_malloc(u32 sz)
-{
-	void *pbuf = _rtw_malloc(sz);
-#ifdef CONFIG_DEBUG_MM_HEAPINFO
-        if (pbuf)
-        {
-            DEBUG_SET_CALLER_ADDR(pbuf);
-        }
-#endif
-	return pbuf;
-}
-
-void *rtw_zmalloc(u32 sz)
-{
-	void *pbuf = _rtw_zmalloc(sz);
-#ifdef CONFIG_DEBUG_MM_HEAPINFO
-        if (pbuf)
-        {
-            DEBUG_SET_CALLER_ADDR(pbuf);
-        }
-#endif
-	return pbuf;
-}
-
-void *rtw_calloc(u32 nelements, u32 elementSize)
-{
-	void *pbuf = _rtw_calloc(nelements, elementSize);
-#ifdef CONFIG_DEBUG_MM_HEAPINFO
-        if (pbuf)
-        {
-            DEBUG_SET_CALLER_ADDR(pbuf);
-        }
-#endif
-	return pbuf;
-}
-
-void rtw_mfree(u8 *pbuf, u32 sz)
-{
-	_rtw_mfree(pbuf, sz);
-}
-
-void *rtw_malloc2d(int h, int w, int size)
-{
-	int j;
-
-	void **a = (void **) rtw_zmalloc(h * sizeof(void *) + h * w * size);
-	if (a == NULL) {
-		OSDEP_DBG("%s: alloc memory fail!\n", __FUNCTION__);
-		return NULL;
-	}
-
-	for (j = 0; j < h; j++) {
-		a[j] = ((char *)(a + h)) + j * w * size;
-	}
-
-	return a;
-}
-
-void rtw_mfree2d(void *pbuf, int h, int w, int size)
-{
-	rtw_mfree((u8 *)pbuf, h * sizeof(void *) + w * h * size);
-}
-
-void rtw_memcpy(void *dst, void *src, u32 sz)
-{
-	if (osdep_service.rtw_memcpy) {
-		osdep_service.rtw_memcpy(dst, src, sz);
-	} else {
-		OSDEP_DBG("Not implement osdep service: rtw_memcpy");
-	}
-}
-
-int rtw_memcmp(void *dst, void *src, u32 sz)
-{
-	if (osdep_service.rtw_memcmp) {
-		return osdep_service.rtw_memcmp(dst, src, sz);
-	} else {
-		OSDEP_DBG("Not implement osdep service: rtw_memcmp");
-	}
-
-	return _FALSE;
-}
-
-void rtw_memset(void *pbuf, int c, u32 sz)
-{
-	if (osdep_service.rtw_memset) {
-		osdep_service.rtw_memset(pbuf, c, sz);
-	} else {
-		OSDEP_DBG("Not implement osdep service: rtw_memset");
-	}
-}
-
-void rtw_init_listhead(_list *list)
-{
-	INIT_LIST_HEAD(list);
-}
-
-/*
-For the following list_xxx operations,
-caller must guarantee the atomic context.
-Otherwise, there will be racing condition.
-*/
-u32 rtw_is_list_empty(_list *phead)
-{
-	if (list_empty(phead)) {
-		return _TRUE;
-	}
-
-	return _FALSE;
-}
-
-void rtw_list_insert_head(_list *plist, _list *phead)
-{
-	list_add(plist, phead);
-}
-
-void rtw_list_insert_tail(_list *plist, _list *phead)
-{
-	list_add_tail(plist, phead);
-}
-
-/*
-
-Caller must check if the list is empty before calling rtw_list_delete
-
-*/
-void rtw_list_delete(_list *plist)
-{
-	list_del_init(plist);
-}
-
-
-
-void rtw_init_sema(_sema *sema, int init_val)
-{
-#if( configSUPPORT_STATIC_ALLOCATION == 1 )
-	StaticSemaphore_t *mutex;
-
-	mutex = (StaticSemaphore_t *)get_mutex_from_poll(&wrapper_mutexbuf_list, &mutexbuf_used_num);
-
-	if (mutex == NULL) {
-		if (mutexpool_flag) {
-			mutex_dynamic_num++;
-			printf("static mutex is not avaliable. mutexbuf_used_num: %d\n", mutexbuf_used_num);
-		}
-		goto exit;
-	} else {
-		memset(mutex, '\0', sizeof(*mutex));
-		if (osdep_service.rtw_init_sema_static) {
-			osdep_service.rtw_init_sema_static(sema, init_val, mutex);
-		} else {
-			OSDEP_DBG("Not implement osdep service: rtw_init_sema_static");
-		}
-	}
-
-	if (mutexbuf_used_num > max_mutexbuf_used_num) {
-		max_mutexbuf_used_num = mutexbuf_used_num;
-	}
-
-	return;
-exit:
-#endif
-
-	if (osdep_service.rtw_init_sema) {
-		osdep_service.rtw_init_sema(sema, init_val);
-	} else {
-		OSDEP_DBG("Not implement osdep service: rtw_init_sema");
-	}
-}
-
-void rtw_free_sema(_sema *sema)
-{
-#if( configSUPPORT_STATIC_ALLOCATION == 1 )
-	if ((*sema) == NULL) {
-		return;
-	}
-	if (rtw_get_mutex_dynamic_flag(*sema)) {
-		save_and_cli();
-		release_mutex_to_poll((unsigned char *)*sema, &wrapper_mutexbuf_list, &mutexbuf_used_num);
-		restore_flags();
-	} else {
-		if (mutexpool_flag) {
-			mutex_dynamic_num--;
-		}
-	}
-#endif
-
-	if (osdep_service.rtw_free_sema) {
-		osdep_service.rtw_free_sema(sema);
-	} else {
-		OSDEP_DBG("Not implement osdep service: rtw_free_sema");
-	}
-}
-
-
-//#if defined(__GNUC__)
-#include <cmsis.h>
-//#endif
-#if defined(__GNUC__) && defined(CONFIG_PLATFORM_8735B)
-#include <cmsis_gcc.h>	// for __get_xPSR()
-#endif
-
-int rtw_in_interrupt(void)
-{
-#ifdef ARM_CORE_CA32
-	return (__get_mode() != CPSR_M_USR) && (__get_mode() != CPSR_M_SYS);
-#else
-#if defined(__ICCARM__)
-	return (__get_PSR() & 0x1FF) != 0;
-#elif defined(__GNUC__)
-
-#ifdef ARM_CORE_CM4
-	return (__get_xPSR() & 0x1FF) != 0;
-#elif defined(RSICV_CORE_KR4)
-	return plic_get_active_irq_id_ram() != 0;
-#else
-	return __get_IPSR() != 0;
-#endif
-
-#endif
-#endif
-}
-
-void rtw_up_sema(_sema *sema)
-{
-	if (rtw_in_interrupt()) {
-		if (osdep_service.rtw_up_sema_from_isr) {
-			osdep_service.rtw_up_sema_from_isr(sema);
-		} else {
-			OSDEP_DBG("Not implement osdep service: rtw_up_sema_from_isr");
-		}
-	} else {
-		if (osdep_service.rtw_up_sema) {
-			osdep_service.rtw_up_sema(sema);
-		} else {
-			OSDEP_DBG("Not implement osdep service: rtw_up_sema");
-		}
-	}
-}
-
-void rtw_up_sema_from_isr(_sema *sema)
-{
-	if (osdep_service.rtw_up_sema_from_isr) {
-		osdep_service.rtw_up_sema_from_isr(sema);
-	} else {
-		OSDEP_DBG("Not implement osdep service: rtw_up_sema_from_isr");
-	}
-}
-
-u32	rtw_down_timeout_sema(_sema *sema, u32 timeout)
-{
-	if (osdep_service.rtw_down_timeout_sema) {
-		return osdep_service.rtw_down_timeout_sema(sema, timeout);
-	} else {
-		OSDEP_DBG("Not implement osdep service: rtw_down_timeout_sema");
-	}
-
-	return _FAIL;
-}
-
-u32 rtw_down_sema(_sema *sema)
-{
-	while (rtw_down_timeout_sema(sema, RTW_MAX_DELAY) != _TRUE)
-//		rom_e_rtw_msg_871X_LEVEL(DOWN_SEMA_1, _drv_always_, "%s(%p) failed, retry\n",  __FUNCTION__, sema);
-		//OSDEP_DBG_LEVEL(_drv_always_, "%s(%p) failed, retry\n",  __FUNCTION__, sema);
-	{
-		OSDEP_DBG("%s(%p) failed, retry\n",  __FUNCTION__, sema);
-	}
-	return _TRUE;
-}
-
-void rtw_mutex_init(_mutex *pmutex)
-{
-#if( configSUPPORT_STATIC_ALLOCATION == 1 )
-	StaticSemaphore_t *mutex;
-
-	mutex = (StaticSemaphore_t *)get_mutex_from_poll(&wrapper_mutexbuf_list, &mutexbuf_used_num);
-
-	if (mutex == NULL) {
-		if (mutexpool_flag) {
-			mutex_dynamic_num++;
-			printf("static mutex is not avaliable. mutexbuf_used_num: %d\n", mutexbuf_used_num);
-		}
-		goto exit;
-	} else {
-		memset(mutex, '\0', sizeof(*mutex));
-		if (osdep_service.rtw_mutex_init_static) {
-			osdep_service.rtw_mutex_init_static(pmutex, mutex);
-		} else {
-			OSDEP_DBG("Not implement osdep service: rtw_mutex_init");
-		}
-	}
-
-	if (mutexbuf_used_num > max_mutexbuf_used_num) {
-		max_mutexbuf_used_num = mutexbuf_used_num;
-	}
-
-	return;
-exit:
-#endif
-
-	if (osdep_service.rtw_mutex_init) {
-		osdep_service.rtw_mutex_init(pmutex);
-	} else {
-		OSDEP_DBG("Not implement osdep service: rtw_mutex_init");
-	}
-}
-
-void rtw_mutex_free(_mutex *pmutex)
-{
-#if( configSUPPORT_STATIC_ALLOCATION == 1 )
-	if ((*pmutex) == NULL) {
-		return;
-	}
-	if (rtw_get_mutex_dynamic_flag(*pmutex)) {
-		save_and_cli();
-		release_mutex_to_poll((unsigned char *)*pmutex, &wrapper_mutexbuf_list, &mutexbuf_used_num);
-		restore_flags();
-	} else {
-		if (mutexpool_flag) {
-			mutex_dynamic_num--;
-		}
-	}
-#endif
-
-	if (osdep_service.rtw_mutex_free) {
-		osdep_service.rtw_mutex_free(pmutex);
-	} else {
-		OSDEP_DBG("Not implement osdep service: rtw_mutex_free");
-	}
-}
-
-void rtw_mutex_put(_mutex *pmutex)
-{
-	if (osdep_service.rtw_mutex_put) {
-		osdep_service.rtw_mutex_put(pmutex);
-	} else {
-		OSDEP_DBG("Not implement osdep service: rtw_mutex_put");
-	}
-}
-
-void rtw_mutex_get(_mutex *pmutex)
-{
-	if (osdep_service.rtw_mutex_get) {
-		osdep_service.rtw_mutex_get(pmutex);
-	} else {
-		OSDEP_DBG("Not implement osdep service: rtw_mutex_get");
-	}
-}
-
-int rtw_mutex_get_timeout(_mutex *pmutex, u32 timeout_ms)
-{
-	if (osdep_service.rtw_mutex_get_timeout) {
-		return osdep_service.rtw_mutex_get_timeout(pmutex, timeout_ms);
-	} else {
-		OSDEP_DBG("Not implement osdep service: rtw_mutex_get_timeout");
-		return -1;
-	}
-}
-
-void rtw_enter_critical(_lock *plock, _irqL *pirqL)
-{
-	if (rtw_in_interrupt()) {
-		if (osdep_service.rtw_enter_critical_from_isr) {
-			osdep_service.rtw_enter_critical_from_isr(plock, pirqL);
-		} else {
-			OSDEP_DBG("Not implement osdep service: rtw_enter_critical_from_isr");
-		}
-	} else {
-		if (osdep_service.rtw_enter_critical) {
-			osdep_service.rtw_enter_critical(plock, pirqL);
-		} else {
-			OSDEP_DBG("Not implement osdep service: rtw_enter_critical");
-		}
-	}
-}
-
-void rtw_exit_critical(_lock *plock, _irqL *pirqL)
-{
-	if (rtw_in_interrupt()) {
-		if (osdep_service.rtw_exit_critical_from_isr) {
-			osdep_service.rtw_exit_critical_from_isr(plock, pirqL);
-		} else {
-			OSDEP_DBG("Not implement osdep service: rtw_exit_critical_from_isr");
-		}
-	} else {
-		if (osdep_service.rtw_exit_critical) {
-			osdep_service.rtw_exit_critical(plock, pirqL);
-		} else {
-			OSDEP_DBG("Not implement osdep service: rtw_exit_critical");
-		}
-	}
-}
-
-void rtw_enter_critical_from_isr(_lock *plock, _irqL *pirqL)
-{
-	if (osdep_service.rtw_enter_critical) {
-		osdep_service.rtw_enter_critical(plock, pirqL);
-	} else {
-		OSDEP_DBG("Not implement osdep service: rtw_enter_critical_from_isr");
-	}
-}
-
-void rtw_exit_critical_from_isr(_lock *plock, _irqL *pirqL)
-{
-	if (osdep_service.rtw_exit_critical) {
-		osdep_service.rtw_exit_critical(plock, pirqL);
-	} else {
-		OSDEP_DBG("Not implement osdep service: rtw_exit_critical_from_isr");
-	}
-}
-
-void rtw_enter_critical_bh(_lock *plock, _irqL *pirqL)
-{
-	/* To avoid gcc warnings */
-	(void) pirqL;
-	rtw_spin_lock(plock);
-}
-
-void rtw_exit_critical_bh(_lock *plock, _irqL *pirqL)
-{
-	/* To avoid gcc warnings */
-	(void) pirqL;
-
-	rtw_spin_unlock(plock);
-}
-
-int rtw_enter_critical_mutex(_mutex *pmutex, _irqL *pirqL)
-{
-	if (osdep_service.rtw_enter_critical_mutex) {
-		return osdep_service.rtw_enter_critical_mutex(pmutex, pirqL);
-	} else {
-		OSDEP_DBG("Not implement osdep service: rtw_enter_critical_mutex");
-	}
-
-	return 0;
-}
-
-void rtw_exit_critical_mutex(_mutex *pmutex, _irqL *pirqL)
-{
-	if (osdep_service.rtw_exit_critical_mutex) {
-		osdep_service.rtw_exit_critical_mutex(pmutex, pirqL);
-	} else {
-		OSDEP_DBG("Not implement osdep service: rtw_exit_critical_mutex");
-	}
-}
-
-void rtw_cpu_lock(void)
-{
-	if (osdep_service.rtw_cpu_lock) {
-		osdep_service.rtw_cpu_lock();
-	} else {
-		OSDEP_DBG("Not implement osdep service: rtw_cpu_lock");
-	}
-}
-
-void rtw_cpu_unlock(void)
-{
-	if (osdep_service.rtw_cpu_unlock) {
-		osdep_service.rtw_cpu_unlock();
-	} else {
-		OSDEP_DBG("Not implement osdep service: rtw_cpu_unlock");
-	}
-}
-
-void	rtw_init_queue(_queue	*pqueue)
-{
-	rtw_init_listhead(&(pqueue->queue));
-	rtw_spinlock_init(&(pqueue->lock));
-}
-
-u32	  rtw_queue_empty(_queue	*pqueue)
-{
-	return (rtw_is_list_empty(&(pqueue->queue)));
-}
-
-
-u32 rtw_end_of_queue_search(_list *head, _list *plist)
-{
-	if (head == plist) {
-		return _TRUE;
-	} else {
-		return _FALSE;
-	}
-}
-
-#if 1
-void rtw_spinlock_init(_lock *plock)
-{
-#if( configSUPPORT_STATIC_ALLOCATION == 1 )
-	StaticSemaphore_t *mutex;
-
-	mutex = (StaticSemaphore_t *)get_mutex_from_poll(&wrapper_mutexbuf_list, &mutexbuf_used_num);
-
-	if (mutex == NULL) {
-		if (mutexpool_flag) {
-			mutex_dynamic_num++;
-			printf("static mutex is not avaliable. mutexbuf_used_num: %d\n", mutexbuf_used_num);
-		}
-		goto exit;
-	} else {
-		memset(mutex, '\0', sizeof(*mutex));
-		if (osdep_service.rtw_spinlock_init_static) {
-			osdep_service.rtw_spinlock_init_static(plock, mutex);
-		} else {
-			OSDEP_DBG("Not implement osdep service: rtw_mutex_init");
-		}
-	}
-
-	if (mutexbuf_used_num > max_mutexbuf_used_num) {
-		max_mutexbuf_used_num = mutexbuf_used_num;
-	}
-
-	return;
-exit:
-#endif
-
-	if (osdep_service.rtw_spinlock_init) {
-		osdep_service.rtw_spinlock_init(plock);
-	} else {
-		OSDEP_DBG("Not implement osdep service: rtw_spinlock_init");
-	}
-}
-
-
-void rtw_spinlock_free(_lock *plock)
-{
-#if( configSUPPORT_STATIC_ALLOCATION == 1 )
-	if ((*plock) == NULL) {
-		return;
-	}
-	if (rtw_get_mutex_dynamic_flag(*plock)) {
-		save_and_cli();
-		release_mutex_to_poll((unsigned char *)*plock, &wrapper_mutexbuf_list, &mutexbuf_used_num);
-		restore_flags();
-	} else {
-		if (mutexpool_flag) {
-			mutex_dynamic_num--;
-		}
-	}
-#endif
-
-	if (osdep_service.rtw_spinlock_free) {
-		osdep_service.rtw_spinlock_free(plock);
-	} else {
-		OSDEP_DBG("Not implement osdep service: rtw_spinlock_free");
-	}
-}
-
-void rtw_spin_lock(_lock *plock)
-{
-	if (osdep_service.rtw_spin_lock) {
-		osdep_service.rtw_spin_lock(plock);
-	} else {
-		OSDEP_DBG("Not implement osdep service: rtw_spin_lock");
-	}
-}
-
-void rtw_spin_unlock(_lock *plock)
-{
-	if (osdep_service.rtw_spin_unlock) {
-		osdep_service.rtw_spin_unlock(plock);
-	} else {
-		OSDEP_DBG("Not implement osdep service: rtw_spin_unlock");
-	}
-}
-
-void rtw_spinlock_irqsave(_lock *plock, _irqL *irqL)
-{
-	if (osdep_service.rtw_spinlock_irqsave) {
-		osdep_service.rtw_spinlock_irqsave(plock, irqL);
-	} else {
-		OSDEP_DBG("Not implement osdep service: rtw_spinlock_irqsave");
-	}
-}
-
-void rtw_spinunlock_irqsave(_lock *plock, _irqL *irqL)
-{
-	if (osdep_service.rtw_spinunlock_irqsave) {
-		osdep_service.rtw_spinunlock_irqsave(plock, irqL);
-	} else {
-		OSDEP_DBG("Not implement osdep service: rtw_spinunlock_irqsave");
-	}
-}
-#endif
-
-int rtw_init_xqueue(_xqueue *queue, const char *name, u32 message_size, u32 number_of_messages)
-{
-	if (osdep_service.rtw_init_xqueue) {
-		return (int)osdep_service.rtw_init_xqueue(queue, name, message_size, number_of_messages);
-	} else {
-		OSDEP_DBG("Not implement osdep service: rtw_init_xqueue");
-	}
-
-	return FAIL;
-}
-
-int rtw_push_to_xqueue(_xqueue *queue, void *message, u32 timeout_ms)
-{
-	if (osdep_service.rtw_push_to_xqueue) {
-		return (int)osdep_service.rtw_push_to_xqueue(queue, message, timeout_ms);
-	} else {
-		OSDEP_DBG("Not implement osdep service: rtw_push_to_xqueue");
-	}
-
-	return FAIL;
-}
-
-int rtw_pop_from_xqueue(_xqueue *queue, void *message, u32 timeout_ms)
-{
-	if (osdep_service.rtw_pop_from_xqueue) {
-		return (int)osdep_service.rtw_pop_from_xqueue(queue, message, timeout_ms);
-	} else {
-		OSDEP_DBG("Not implement osdep service: rtw_pop_from_xqueue");
-	}
-
-	return FAIL;
-}
-
-int rtw_peek_from_xqueue(_xqueue *queue, void *message, u32 timeout_ms)
-{
-	if (osdep_service.rtw_peek_from_xqueue) {
-		return (int)osdep_service.rtw_peek_from_xqueue(queue, message, timeout_ms);
-	} else {
-		OSDEP_DBG("Not implement osdep service: rtw_peek_from_xqueue");
-	}
-
-	return FAIL;
-}
-
-int rtw_deinit_xqueue(_xqueue *queue)
-{
-	if (osdep_service.rtw_deinit_xqueue) {
-		return (int)osdep_service.rtw_deinit_xqueue(queue);
-	} else {
-		OSDEP_DBG("Not implement osdep service: rtw_deinit_xqueue");
-	}
-
-	return FAIL;
-}
-
-#if 0
-void rtw_init_queue(_queue *pqueue)
-{
-	rtw_init_listhead(&(pqueue->queue));
-	rtw_mutex_init(&(pqueue->lock));
-}
-
-void	rtw_deinit_queue(_queue *pqueue)
-{
-	rtw_mutex_free(&(pqueue->lock));
-}
-
-u32 rtw_is_queue_empty(_queue *pqueue)
-{
-	return (rtw_is_list_empty(&(pqueue->queue)));
-}
-
-u32 rtw_end_of_queue_search(_list *head, _list *plist)
-{
-	if (head == plist) {
-		return _TRUE;
-	}
-
-	return _FALSE;
-}
-
-_list	*rtw_get_queue_head(_queue	*queue)
-{
-	return (&(queue->queue));
-}
-#endif
-
-uint32_t rtw_get_current_time(void)
-{
-	if (osdep_service.rtw_get_current_time) {
-		return osdep_service.rtw_get_current_time();
-	} else {
-		OSDEP_DBG("Not implement osdep service: rtw_get_current_time");
-	}
-
-	return 0;
-}
-
-u32 rtw_systime_to_ms(u32 systimer)
-{
-	if (osdep_service.rtw_systime_to_ms) {
-		return osdep_service.rtw_systime_to_ms(systimer);
-	} else {
-		OSDEP_DBG("Not implement osdep service: rtw_systime_to_ms");
-	}
-
-	return 0;
-}
-
-u32 rtw_systime_to_sec(u32 systimer)
-{
-	if (osdep_service.rtw_systime_to_sec) {
-		return osdep_service.rtw_systime_to_sec(systimer);
-	} else {
-		OSDEP_DBG("Not implement osdep service: rtw_systime_to_sec");
-	}
-
-	return 0;
-}
-
-u32 rtw_ms_to_systime(u32 ms)
-{
-	if (osdep_service.rtw_ms_to_systime) {
-		return osdep_service.rtw_ms_to_systime(ms);
-	} else {
-		OSDEP_DBG("Not implement osdep service: rtw_ms_to_systime");
-	}
-
-	return 0;
-}
-
-u32 rtw_sec_to_systime(u32 sec)
-{
-	if (osdep_service.rtw_sec_to_systime) {
-		return osdep_service.rtw_sec_to_systime(sec);
-	} else {
-		OSDEP_DBG("Not implement osdep service: rtw_sec_to_systime");
-	}
-
-	return 0;
-}
-
-// the input parameter start use the same unit as returned by rtw_get_current_time
-s32 rtw_get_passing_time_ms(u32 start)
-{
-	return rtw_systime_to_ms(rtw_get_current_time() - start);
-}
-
-s32 rtw_get_time_interval_ms(u32 start, u32 end)
-{
-	return rtw_systime_to_ms(end - start);
-}
-
-void rtw_msleep_os(int ms)
-{
-	if (osdep_service.rtw_msleep_os) {
-		osdep_service.rtw_msleep_os(ms);
-	} else {
-		OSDEP_DBG("Not implement osdep service: rtw_msleep_os");
-	}
-}
-
-void rtw_usleep_os(int us)
-{
-	if (osdep_service.rtw_usleep_os) {
-		osdep_service.rtw_usleep_os(us);
-	} else {
-		OSDEP_DBG("Not implement osdep service: rtw_usleep_os");
-	}
-}
-
-void rtw_mdelay_os(int ms)
-{
-	if (osdep_service.rtw_mdelay_os) {
-		osdep_service.rtw_mdelay_os(ms);
-	} else {
-		OSDEP_DBG("Not implement osdep service: rtw_mdelay_os");
-	}
-}
-
-void rtw_udelay_os(int us)
-{
-	if (osdep_service.rtw_udelay_os) {
-		osdep_service.rtw_udelay_os(us);
-	} else {
-		OSDEP_DBG("Not implement osdep service: rtw_udelay_os");
-	}
-}
-
-void rtw_yield_os(void)
-{
-	if (osdep_service.rtw_yield_os) {
-		osdep_service.rtw_yield_os();
-	} else {
-		OSDEP_DBG("Not implement osdep service: rtw_yield_os");
-	}
-}
-
-void ATOMIC_SET(ATOMIC_T *v, int i)
-{
-	if (osdep_service.ATOMIC_SET) {
-		osdep_service.ATOMIC_SET(v, i);
-	} else {
-		OSDEP_DBG("Not implement osdep service: ATOMIC_SET");
-	}
-}
-
-int ATOMIC_READ(ATOMIC_T *v)
-{
-	if (osdep_service.ATOMIC_READ) {
-		return osdep_service.ATOMIC_READ(v);
-	} else {
-		OSDEP_DBG("Not implement osdep service: ATOMIC_READ");
-	}
-
-	return 0;
-}
-
-void ATOMIC_ADD(ATOMIC_T *v, int i)
-{
-	if (osdep_service.ATOMIC_ADD) {
-		osdep_service.ATOMIC_ADD(v, i);
-	} else {
-		OSDEP_DBG("Not implement osdep service: ATOMIC_ADD");
-	}
-}
-
-void ATOMIC_SUB(ATOMIC_T *v, int i)
-{
-	if (osdep_service.ATOMIC_SUB) {
-		osdep_service.ATOMIC_SUB(v, i);
-	} else {
-		OSDEP_DBG("Not implement osdep service: ATOMIC_SUB");
-	}
-}
-
-void ATOMIC_INC(ATOMIC_T *v)
-{
-	if (osdep_service.ATOMIC_INC) {
-		osdep_service.ATOMIC_INC(v);
-	} else {
-		OSDEP_DBG("Not implement osdep service: ATOMIC_INC");
-	}
-}
-
-void ATOMIC_DEC(ATOMIC_T *v)
-{
-	if (osdep_service.ATOMIC_DEC) {
-		osdep_service.ATOMIC_DEC(v);
-	} else {
-		OSDEP_DBG("Not implement osdep service: ATOMIC_DEC");
-	}
-}
-
-int ATOMIC_ADD_RETURN(ATOMIC_T *v, int i)
-{
-	if (osdep_service.ATOMIC_ADD_RETURN) {
-		return osdep_service.ATOMIC_ADD_RETURN(v, i);
-	} else {
-		OSDEP_DBG("Not implement osdep service: ATOMIC_ADD_RETURN");
-	}
-
-	return 0;
-}
-
-int ATOMIC_SUB_RETURN(ATOMIC_T *v, int i)
-{
-	if (osdep_service.ATOMIC_SUB_RETURN) {
-		return osdep_service.ATOMIC_SUB_RETURN(v, i);
-	} else {
-		OSDEP_DBG("Not implement osdep service: ATOMIC_SUB_RETURN");
-	}
-
-	return 0;
-}
-
-int ATOMIC_INC_RETURN(ATOMIC_T *v)
-{
-	if (osdep_service.ATOMIC_INC_RETURN) {
-		return osdep_service.ATOMIC_INC_RETURN(v);
-	} else {
-		OSDEP_DBG("Not implement osdep service: ATOMIC_INC_RETURN");
-	}
-
-	return 0;
-}
-
-int ATOMIC_DEC_RETURN(ATOMIC_T *v)
-{
-	if (osdep_service.ATOMIC_DEC_RETURN) {
-		return osdep_service.ATOMIC_DEC_RETURN(v);
-	} else {
-		OSDEP_DBG("Not implement osdep service: ATOMIC_DEC_RETURN");
-	}
-
-	return 0;
-}
-
-int ATOMIC_DEC_AND_TEST(ATOMIC_T *v)
-{
-	return ATOMIC_DEC_RETURN(v) == 0;
-}
-
-u64 rtw_modular64(u64 x, u64 y)
-{
-	if (osdep_service.rtw_modular64) {
-		return osdep_service.rtw_modular64(x, y);
-	} else {
-		OSDEP_DBG("Not implement osdep service: rtw_modular64");
-	}
-
-	return 0;
-}
-
-int rtw_get_random_bytes(void *dst, u32 size)
-{
-	if (osdep_service.rtw_get_random_bytes) {
-		return osdep_service.rtw_get_random_bytes(dst, size);
-	} else {
-		OSDEP_DBG("Not implement osdep service: rtw_get_random_bytes");
-	}
-
-	return 0;
-}
-
-u32 rtw_getFreeHeapSize(void)
-{
-	if (osdep_service.rtw_getFreeHeapSize) {
-		return osdep_service.rtw_getFreeHeapSize();
-	} else {
-		OSDEP_DBG("Not implement osdep service: rtw_getFreeHeapSize");
-	}
-
-	return 0;
-}
-
-int rtw_netif_queue_stopped(void *pnetdev)
-{
-	/* To avoid gcc warnings */
-	(void) pnetdev;
-
-	return 0;
-}
-
-void rtw_netif_wake_queue(void *pnetdev)
-{
-	/* To avoid gcc warnings */
-	(void) pnetdev;
-}
-
-void rtw_netif_start_queue(void *pnetdev)
-{
-	/* To avoid gcc warnings */
-	(void) pnetdev;
-}
-
-void rtw_netif_stop_queue(void *pnetdev)
-{
-	/* To avoid gcc warnings */
-	(void) pnetdev;
-}
-
-void flush_signals_thread(void)
-{
-}
-
-void rtw_acquire_wakelock(void)
-{
-	if (osdep_service.rtw_acquire_wakelock) {
-		osdep_service.rtw_acquire_wakelock();
-	} else {
-		OSDEP_DBG("Not implement osdep service: rtw_acquire_wakelock");
-	}
-}
-
-void rtw_release_wakelock(void)
-{
-	if (osdep_service.rtw_release_wakelock) {
-		osdep_service.rtw_release_wakelock();
-	} else {
-		OSDEP_DBG("Not implement osdep service: rtw_release_wakelock");
-	}
-}
-
-void rtw_wakelock_timeout(u32 timeoutms)
-{
-	if (osdep_service.rtw_wakelock_timeout) {
-		osdep_service.rtw_wakelock_timeout(timeoutms);
-	} else {
-		OSDEP_DBG("Not implement osdep service: rtw_wakelock_timeout");
-	}
-}
-
-int rtw_create_task(struct task_struct *task, const char *name,
-					u32 stack_size, u32 priority, thread_func_t func, void *thctx)
-{
-	if (osdep_service.rtw_create_task) {
-		return osdep_service.rtw_create_task(task, name, stack_size, priority, func, thctx);
-	} else {
-		OSDEP_DBG("Not implement osdep service: rtw_create_task");
-	}
-	return 1;
-}
-void rtw_delete_task(struct task_struct *task)
-{
-	if (osdep_service.rtw_delete_task) {
-		osdep_service.rtw_delete_task(task);
-	} else {
-		OSDEP_DBG("Not implement osdep service: rtw_delete_task");
-	}
-
-	return;
-}
-void rtw_wakeup_task(struct task_struct *task)
-{
-	if (osdep_service.rtw_wakeup_task) {
-		osdep_service.rtw_wakeup_task(task);
-	} else {
-		OSDEP_DBG("Not implement osdep service: rtw_wakeup_task");
-	}
-
-	return;
-}
-
-void rtw_set_priority_task(void *task, u32 NewPriority)
-{
-	if (osdep_service.rtw_set_priority_task) {
-		osdep_service.rtw_set_priority_task(task, NewPriority);
-	} else {
-		OSDEP_DBG("Not implement osdep service: rtw_set_priority_task");
-	}
-
-	return;
-}
-
-int rtw_get_priority_task(void *task)
-{
-	if (osdep_service.rtw_get_priority_task) {
-		return osdep_service.rtw_get_priority_task(task);
-	} else {
-		OSDEP_DBG("Not implement osdep service: rtw_get_priority_task");
-	}
-
-	return -1;
-}
-
-void rtw_suspend_task(void *task)
-{
-	if (osdep_service.rtw_suspend_task) {
-		osdep_service.rtw_suspend_task(task);
-	} else {
-		OSDEP_DBG("Not implement osdep service: rtw_suspend_task");
-	}
-
-	return;
-}
-
-void rtw_resume_task(void *task)
-{
-	if (osdep_service.rtw_resume_task) {
-		osdep_service.rtw_resume_task(task);
-	} else {
-		OSDEP_DBG("Not implement osdep service: rtw_resume_task");
-	}
-
-	return;
-}
-
-void rtw_suspend_task_all(void)
-{
-	if (osdep_service.rtw_suspend_task_all) {
-		osdep_service.rtw_suspend_task_all();
-	} else {
-		OSDEP_DBG("Not implement osdep service: rtw_suspend_task_all");
-	}
-
-	return;
-}
-
-void rtw_resume_task_all(void)
-{
-	if (osdep_service.rtw_resume_task_all) {
-		osdep_service.rtw_resume_task_all();
-	} else {
-		OSDEP_DBG("Not implement osdep service: rtw_resume_task_all");
-	}
-
-	return;
-}
-
-_timerHandle rtw_timerCreate(const signed char *pcTimerName,
-							 osdepTickType xTimerPeriodInTicks,
-							 u32 uxAutoReload,
-							 void *pvTimerID,
-							 TIMER_FUN pxCallbackFunction)
-{
-	if (osdep_service.rtw_timerCreate){
-		return osdep_service.rtw_timerCreate(pcTimerName, xTimerPeriodInTicks, uxAutoReload,
-											 pvTimerID, pxCallbackFunction);
-	} else {
-		OSDEP_DBG("Not implement osdep service: rtw_timerCreate");
-	}
-
-	return 0;
-}
-
-u32 rtw_timerDelete(_timerHandle xTimer,
-					osdepTickType xBlockTime)
-{
-	if (osdep_service.rtw_timerDelete) {
-		return osdep_service.rtw_timerDelete(xTimer, xBlockTime);
-	} else {
-		OSDEP_DBG("Not implement osdep service: rtw_timerDelete");
-	}
-
-	return 0;
-}
-
-u32 rtw_timerIsTimerActive(_timerHandle xTimer)
-{
-	if (osdep_service.rtw_timerIsTimerActive) {
-		return osdep_service.rtw_timerIsTimerActive(xTimer);
-	} else {
-		OSDEP_DBG("Not implement osdep service: rtw_timerIsTimerActive");
-	}
-
-	return 0;
-}
-
-u32  rtw_timerStop(_timerHandle xTimer,
-				   osdepTickType xBlockTime)
-{
-	if (osdep_service.rtw_timerStop) {
-		return osdep_service.rtw_timerStop(xTimer, xBlockTime);
-	} else {
-		OSDEP_DBG("Not implement osdep service: rtw_timerStop");
-	}
-
-	return 0;
-}
-
-u32  rtw_timerChangePeriod(_timerHandle xTimer,
-						   osdepTickType xNewPeriod,
-						   osdepTickType xBlockTime)
-{
-	if (osdep_service.rtw_timerChangePeriod) {
-		return osdep_service.rtw_timerChangePeriod(xTimer, xNewPeriod, xBlockTime);
-	} else {
-		OSDEP_DBG("Not implement osdep service: rtw_timerChangePeriod");
-	}
-
-	return 0;
-}
-
-void *rtw_timerGetID(_timerHandle xTimer)
-{
-	if (osdep_service.rtw_timerGetID) {
-		return osdep_service.rtw_timerGetID(xTimer);
-	} else {
-		OSDEP_DBG("Not implement osdep service: rtw_timerGetID");
-	}
-
-	return NULL;
-}
-
-u32  rtw_timerStart(_timerHandle xTimer, osdepTickType xBlockTime)
-{
-	if (osdep_service.rtw_timerStart) {
-		return osdep_service.rtw_timerStart(xTimer, xBlockTime);
-	} else {
-		OSDEP_DBG("Not implement osdep service: rtw_timerStart");
-	}
-
-	return 0;
-}
-
-u32  rtw_timerStartFromISR(_timerHandle xTimer,
-						   osdepBASE_TYPE *pxHigherPriorityTaskWoken)
-{
-	if (osdep_service.rtw_timerStartFromISR) {
-		return osdep_service.rtw_timerStartFromISR(xTimer, pxHigherPriorityTaskWoken);
-	} else {
-		OSDEP_DBG("Not implement osdep service: rtw_timerStartFromISR");
-	}
-
-	return 0;
-}
-
-u32  rtw_timerStopFromISR(_timerHandle xTimer,
-						  osdepBASE_TYPE *pxHigherPriorityTaskWoken)
-{
-	if (osdep_service.rtw_timerStopFromISR) {
-		return osdep_service.rtw_timerStopFromISR(xTimer, pxHigherPriorityTaskWoken);
-	} else {
-		OSDEP_DBG("Not implement osdep service: rtw_timerStopFromISR");
-	}
-
-	return 0;
-}
-
-u32  rtw_timerResetFromISR(_timerHandle xTimer,
-						   osdepBASE_TYPE *pxHigherPriorityTaskWoken)
-{
-	if (osdep_service.rtw_timerResetFromISR) {
-		return osdep_service.rtw_timerResetFromISR(xTimer, pxHigherPriorityTaskWoken);
-	} else {
-		OSDEP_DBG("Not implement osdep service: rtw_timerResetFromISR");
-	}
-
-	return 0;
-}
-
-u32  rtw_timerChangePeriodFromISR(_timerHandle xTimer,
-								  osdepTickType xNewPeriod,
-								  osdepBASE_TYPE *pxHigherPriorityTaskWoken)
-{
-	if (osdep_service.rtw_timerChangePeriodFromISR) {
-		return osdep_service.rtw_timerChangePeriodFromISR(xTimer, xNewPeriod, pxHigherPriorityTaskWoken);
-	} else {
-		OSDEP_DBG("Not implement osdep service: rtw_timerChangePeriodFromISR");
-	}
-
-	return 0;
-}
-
-u32  rtw_timerReset(_timerHandle xTimer,
-					osdepTickType xBlockTime)
-{
-	if (osdep_service.rtw_timerReset) {
-		return osdep_service.rtw_timerReset(xTimer, xBlockTime);
-	} else {
-		OSDEP_DBG("Not implement osdep service: rtw_timerReset");
-	}
-
-	return 0;
-}
-
-
-#if 0 //TODO
-void rtw_init_delayed_work(struct delayed_work *dwork, work_func_t func, const char *name)
-{
-	if (osdep_service.rtw_init_delayed_work) {
-		osdep_service.rtw_init_delayed_work(dwork, func, name);
-	} else {
-		OSDEP_DBG("Not implement osdep service: rtw_init_delayed_work");
-	}
-
-	return;
-}
-
-void rtw_deinit_delayed_work(struct delayed_work *dwork)
-{
-	if (osdep_service.rtw_deinit_delayed_work) {
-		osdep_service.rtw_deinit_delayed_work(dwork);
-	} else {
-		OSDEP_DBG("Not implement osdep service: rtw_deinit_delayed_work");
-	}
-
-	return;
-}
-
-int rtw_queue_delayed_work(struct workqueue_struct *wq,
-						   struct delayed_work *dwork, u32 delay, void *context)
-{
-	if (osdep_service.rtw_queue_delayed_work) {
-		osdep_service.rtw_queue_delayed_work(wq, dwork, delay, context);
-	} else {
-		OSDEP_DBG("Not implement osdep service: rtw_queue_delayed_work");
-	}
-
-	return;
-}
-
-BOOLEAN rtw_cancel_delayed_work(struct delayed_work *dwork)
-{
-	if (osdep_service.rtw_cancel_delayed_work) {
-		osdep_service.rtw_cancel_delayed_work(dwork);
-	} else {
-		OSDEP_DBG("Not implement osdep service: rtw_cancel_delayed_work");
-	}
-
-	return;
-}
-#endif
-void rtw_thread_enter(char *name)
-{
-	if (osdep_service.rtw_thread_enter) {
-		osdep_service.rtw_thread_enter(name);
-	} else {
-		OSDEP_DBG("Not implement osdep service: rtw_thread_enter");
-	}
-}
-
-void rtw_thread_exit()
-{
-	if (osdep_service.rtw_thread_exit) {
-		osdep_service.rtw_thread_exit();
-	} else {
-		OSDEP_DBG("Not implement osdep service: rtw_thread_exit");
-	}
-}
-
-u8 rtw_get_scheduler_state()
-{
-	// OS_SCHEDULER_NOT_STARTED	0
-	// OS_SCHEDULER_RUNNING		1
-	// OS_SCHEDULER_SUSPENDED	2
-	// OS_SCHEDULER_UNREACHABLE	3
-	if (osdep_service.rtw_get_scheduler_state) {
-		return osdep_service.rtw_get_scheduler_state();
-	} else {
-		OSDEP_DBG("Not implement osdep service: rtw_get_scheduler_state");
-		return 3;
-	}
-}
-
-void rtw_create_secure_context(u32 secure_stack_size)
-{
-	if (osdep_service.rtw_create_secure_context) {
-		osdep_service.rtw_create_secure_context(secure_stack_size);
-	} else {
-		OSDEP_DBG("Not implement osdep service: rtw_create_secure_context");
-	}
-}
-
-void *rtw_get_current_TaskHandle(void)
-{
-	if (osdep_service.rtw_get_current_TaskHandle) {
-		return osdep_service.rtw_get_current_TaskHandle();
-	} else {
-		OSDEP_DBG("Not implement osdep service: rtw_get_current_TaskHandle");
-	}
-
-	return NULL;
-}
\ No newline at end of file
diff --git a/os/board/rtl8720e/src/component/os/os_dep/psram_reserve.c b/os/board/rtl8720e/src/component/os/os_dep/psram_reserve.c
deleted file mode 100644
index b324af540..000000000
--- a/os/board/rtl8720e/src/component/os/os_dep/psram_reserve.c
+++ /dev/null
@@ -1,231 +0,0 @@
-#include <string.h>		// memset()
-#include <psram_reserve.h>
-//#include <ameba_soc.h>
-
-static struct Psram_Heap g_Psram_heap;
-
-int g_Psram_heap_inited = 0;
-static	_lock	Psram_heap_lock;
-
-#define configTOTAL_PSRAM_HEAP_SIZE		(0x200000)
-#define configBYTE_PSRAM_ALIGNMENT			32
-
-//PSRAM_HEAP_SECTION
-static unsigned char psRAMHeap[configTOTAL_PSRAM_HEAP_SIZE];
-
-void Psram_heap_init(void)
-{
-	/* Initialize heap with a single big chunk */
-	g_Psram_heap.FreeList = (PsramMemChunk *)(psRAMHeap);
-	g_Psram_heap.FreeList->next = NULL;
-	g_Psram_heap.FreeList->size = configTOTAL_PSRAM_HEAP_SIZE;
-
-	g_Psram_heap_inited = 1;
-
-	rtw_spinlock_init(&Psram_heap_lock);
-}
-
-/**
-  * @brief  allocate free memory from PSRAM.
-  * @param  size: size of the memory you want.
-  * @retval: header address of the memory allocated.
-  */
-void *Psram_heap_allocmem(int size)
-{
-	PsramMemChunk *chunk, *prev;
-	struct Psram_Heap *h = &g_Psram_heap;
-	_irqL 	irqL;
-
-	rtw_enter_critical(&Psram_heap_lock, &irqL);
-
-	if (!g_Psram_heap_inited)	{
-		Psram_heap_init();
-	}
-
-	/* Round size up to the allocation granularity */
-	size = Psram_ROUND_UP2(size, configBYTE_PSRAM_ALIGNMENT);
-
-	/* Handle allocations of 0 bytes */
-	if (!size) {
-		size = sizeof(PsramMemChunk);
-	}
-
-	/* Walk on the free list looking for any chunk big enough to
-	 * fit the requested block size.
-	 */
-	for (prev = (PsramMemChunk *)&h->FreeList, chunk = h->FreeList;
-		 chunk;
-		 prev = chunk, chunk = chunk->next) {
-		if (chunk->size >= size) {
-			if (chunk->size == size) {
-				/* Just remove this chunk from the free list */
-				prev->next = chunk->next;
-
-				rtw_exit_critical(&Psram_heap_lock, &irqL);
-
-				return (void *)chunk;
-			} else {
-				/* Allocate from the END of an existing chunk */
-				chunk->size -= size;
-				void *result = (void *)((uint8_t *)chunk + chunk->size);
-
-				rtw_exit_critical(&Psram_heap_lock, &irqL);
-
-				return result;
-			}
-		}
-	}
-
-	rtw_exit_critical(&Psram_heap_lock, &irqL);
-
-	return NULL; /* fail */
-}
-
-
-/**
-  * @brief  free memory in PSRAM.
-  * @param  mem: header address of the memory to be freed.
-  * @param  size: size of the memory.
-  * @retval none
-  */
-void Psram_reserved_heap_freemem(void *mem, int size)
-{
-	PsramMemChunk *prev;
-	struct Psram_Heap *h = &g_Psram_heap;
-	_irqL 	irqL;
-
-	rtw_enter_critical(&Psram_heap_lock, &irqL);
-
-	if (!g_Psram_heap_inited)	{
-		Psram_heap_init();
-	}
-
-	/* Round size up to the allocation granularity */
-	size = Psram_ROUND_UP2(size, configBYTE_PSRAM_ALIGNMENT);
-
-	/* Handle allocations of 0 bytes */
-	if (!size) {
-		size = sizeof(PsramMemChunk);
-	}
-
-	/* Special cases: first chunk in the free list or memory completely full */
-	if (((uint8_t *)mem) < ((uint8_t *)h->FreeList) || !h->FreeList) {
-		/* Insert memory block before the current free list head */
-		prev = (PsramMemChunk *)mem;
-		prev->next = h->FreeList;
-		prev->size = size;
-		h->FreeList = prev;
-	} else { /* Normal case: not the first chunk in the free list */
-		/*
-		 * Walk on the free list. Stop at the insertion point (when mem
-		 * is between prev and prev->next)
-		 */
-		prev = h->FreeList;
-		while (prev->next < (PsramMemChunk *)mem && prev->next) {
-			prev = prev->next;
-		}
-
-		/* Should it be merged with previous block? */
-		if (((uint8_t *)prev) + prev->size == ((uint8_t *)mem)) {
-			/* Yes */
-			prev->size += size;
-		} else { /* not merged with previous chunk */
-			PsramMemChunk *curr = (PsramMemChunk *)mem;
-
-			/* insert it after the previous node
-			 * and move the 'prev' pointer forward
-			 * for the following operations
-			 */
-			curr->next = prev->next;
-			curr->size = size;
-			prev->next = curr;
-
-			/* Adjust for the following test */
-			prev = curr;
-		}
-	}
-
-	/* Also merge with next chunk? */
-	if (((uint8_t *)prev) + prev->size == ((uint8_t *)prev->next)) {
-		prev->size += prev->next->size;
-		prev->next = prev->next->next;
-	}
-
-	rtw_exit_critical(&Psram_heap_lock, &irqL);
-}
-
-/**
-  * @brief  get the free memory size in PSRAM.
-  * @retval size of free momery in PSRAM.
-  */
-int Psram_reserve_free_size(void)
-{
-	int free_mem = 0;
-	struct Psram_Heap *h = &g_Psram_heap;
-	_irqL 	irqL;
-	PsramMemChunk *chunk;
-
-	rtw_enter_critical(&Psram_heap_lock, &irqL);
-
-	if (!g_Psram_heap_inited)	{
-		Psram_heap_init();
-	}
-
-	for (chunk = h->FreeList; chunk; chunk = chunk->next) {
-		free_mem += chunk->size;
-	}
-
-	rtw_exit_critical(&Psram_heap_lock, &irqL);
-	return free_mem;
-}
-
-/**
-  * @brief  allocate free memory from PSRAM.
-  * @param  size: size of the memory you want.
-  * @retval: header address of the memory allocated.
-  */
-void *Psram_reserve_malloc(int size)
-{
-	int *mem;
-
-	size += sizeof(int);
-	if ((mem = (int *)Psram_heap_allocmem(size))) {
-		*mem++ = size;
-	}
-
-	return (void *)mem;
-}
-
-/**
-  * @brief allocate several continuous blocks of free memory from PSRAM.
-  * @param  num: num of blocks you want.
-  * @param  size: size of every block.
-  * @retval: header address of the memory allocated.
-  */
-void *Psram_reserve_calloc(int num, int size)
-{
-	void *mem;
-
-	if ((mem = Psram_reserve_malloc(num * size))) {
-		memset(mem, 0, num * size);
-	}
-
-	return mem;
-}
-
-/**
-  * @brief  free memory in PSRAM.
-  * @param  mem: header address of the memory to be freed.
-  * @retval none
-  */
-void Psram_reserve_free(void *mem)
-{
-	int *_mem = (int *)mem;
-
-	if (_mem) {
-		--_mem;
-		Psram_reserved_heap_freemem(_mem, *_mem);
-	}
-}
-
-
diff --git a/os/board/rtl8720e/src/component/os/os_dep/tcm_heap.c b/os/board/rtl8720e/src/component/os/os_dep/tcm_heap.c
deleted file mode 100644
index 2bb52cfc0..000000000
--- a/os/board/rtl8720e/src/component/os/os_dep/tcm_heap.c
+++ /dev/null
@@ -1,365 +0,0 @@
-//#include <autoconf.h>
-#include "tcm_heap.h"
-
-#include <string.h>    // memset()
-
-#include <osdep_service.h>
-
-//#define _DEBUG
-
-#if CONFIG_USE_TCM_HEAP
-#define FREE_FILL_CODE     0xDEAD
-#define ALLOC_FILL_CODE    0xBEEF
-
-#define ROUND_UP2(x, pad) (((x) + ((pad) - 1)) & ~((pad) - 1))
-
-#define TCM_HEAP_SIZE	(40*1024)
-
-static struct Heap g_tcm_heap;
-
-#if defined (__ICCARM__)
-#pragma location=".tcm.heap"
-#else
-__attribute__((section(".tcm.heap")))
-#endif
-HEAP_DEFINE_BUF(tcm_heap, TCM_HEAP_SIZE);
-//unsigned char tcm_heap[TCM_HEAP_SIZE];
-
-static int g_heap_inited = 0;
-static	_lock	tcm_lock;
-#if defined(PLATFORM_FREERTOS)
-extern void vPortSetExtFree(void (*free)(void *p), uint32_t upper, uint32_t lower);
-#elif defined(PLATFORM_CMSIS_RTOS)
-extern void rtw_set_mfree_ext(void (*free)(void *p), uint32_t upper, uint32_t lower);
-#endif
-void tcm_heap_init(void)
-{
-	//#ifdef _DEBUG
-	//memset(memory, FREE_FILL_CODE, size);
-	//#endif
-
-	//ASSERT2(((int)memory % alignof(heap_buf_t)) == 0,
-	//"memory buffer is unaligned, please use the HEAP_DEFINE_BUF() macro to declare heap buffers!\n");
-
-	/* Initialize heap with a single big chunk */
-	g_tcm_heap.FreeList = (MemChunk *)&tcm_heap;
-	g_tcm_heap.FreeList->next = NULL;
-	g_tcm_heap.FreeList->size = sizeof(tcm_heap);
-
-	g_heap_inited = 1;
-	rtw_spinlock_init(&tcm_lock);
-
-#if defined(PLATFORM_FREERTOS)
-	// let RTOS know how to free memory if using as task stack
-	vPortSetExtFree(tcm_heap_free, 0x20000000, 0x1fff0000);
-#elif defined(PLATFORM_CMSIS_RTOS)
-	rtw_set_mfree_ext(tcm_heap_free, 0x20000000, 0x1fff0000);
-#endif
-}
-
-void tcm_heap_dump(void)
-{
-	MemChunk *chunk, *prev;
-	struct Heap *h = &g_tcm_heap;
-
-	printf("---Free List--\n\r");
-	for (prev = (MemChunk *)&h->FreeList, chunk = h->FreeList;
-		 chunk;
-		 prev = chunk, chunk = chunk->next) {
-		printf(" prev %x, chunk %x, size %d \n\r", prev, chunk, chunk->size);
-	}
-	printf("--------------\n\r");
-}
-
-void *tcm_heap_allocmem(int size)
-{
-	MemChunk *chunk, *prev;
-	struct Heap *h = &g_tcm_heap;
-	_irqL 	irqL;
-
-	rtw_enter_critical(&tcm_lock, &irqL);
-
-	if (!g_heap_inited)	{
-		tcm_heap_init();
-	}
-
-	/* Round size up to the allocation granularity */
-	size = ROUND_UP2(size, sizeof(MemChunk));
-
-	/* Handle allocations of 0 bytes */
-	if (!size) {
-		size = sizeof(MemChunk);
-	}
-
-	/* Walk on the free list looking for any chunk big enough to
-	 * fit the requested block size.
-	 */
-	for (prev = (MemChunk *)&h->FreeList, chunk = h->FreeList;
-		 chunk;
-		 prev = chunk, chunk = chunk->next) {
-		if (chunk->size >= size) {
-			if (chunk->size == size) {
-				/* Just remove this chunk from the free list */
-				prev->next = chunk->next;
-#ifdef _DEBUG
-				memset(chunk, ALLOC_FILL_CODE, size);
-#endif
-
-				rtw_exit_critical(&tcm_lock, &irqL);
-				//printf("----ALLOC1-----\n\r");
-				//tcm_heap_dump();
-				//printf("--------------\n\r");
-				return (void *)chunk;
-			} else {
-				/* Allocate from the END of an existing chunk */
-				chunk->size -= size;
-#ifdef _DEBUG
-				memset((uint8_t *)chunk + chunk->size, ALLOC_FILL_CODE, size);
-#endif
-				rtw_exit_critical(&tcm_lock, &irqL);
-				//printf("----ALLOC2-----\n\r");
-				//tcm_heap_dump();
-				//printf("--------------\n\r");
-
-				return (void *)((uint8_t *)chunk + chunk->size);
-			}
-		}
-	}
-
-	rtw_exit_critical(&tcm_lock, &irqL);
-	//printf("----ALLOC3-----\n\r");
-	//tcm_heap_dump();
-	//printf("--------------\n\r");
-	return NULL; /* fail */
-}
-
-
-void tcm_heap_freemem(void *mem, int size)
-{
-	MemChunk *prev;
-	//ASSERT(mem);
-	struct Heap *h = &g_tcm_heap;
-	_irqL 	irqL;
-
-	rtw_enter_critical(&tcm_lock, &irqL);
-
-	if (!g_heap_inited)	{
-		tcm_heap_init();
-	}
-
-#ifdef _DEBUG
-	memset(mem, FREE_FILL_CODE, size);
-#endif
-
-	/* Round size up to the allocation granularity */
-	size = ROUND_UP2(size, sizeof(MemChunk));
-
-	/* Handle allocations of 0 bytes */
-	if (!size) {
-		size = sizeof(MemChunk);
-	}
-
-	/* Special cases: first chunk in the free list or memory completely full */
-	//ASSERT((uint8_t*)mem != (uint8_t*)h->FreeList);
-	if (((uint8_t *)mem) < ((uint8_t *)h->FreeList) || !h->FreeList) {
-		/* Insert memory block before the current free list head */
-		prev = (MemChunk *)mem;
-		prev->next = h->FreeList;
-		prev->size = size;
-		h->FreeList = prev;
-	} else { /* Normal case: not the first chunk in the free list */
-		/*
-		 * Walk on the free list. Stop at the insertion point (when mem
-		 * is between prev and prev->next)
-		 */
-		prev = h->FreeList;
-		while (prev->next < (MemChunk *)mem && prev->next) {
-			prev = prev->next;
-		}
-
-		/* Make sure mem is not *within* prev */
-		//ASSERT((uint8_t*)mem >= (uint8_t*)prev + prev->size);
-
-		/* Should it be merged with previous block? */
-		if (((uint8_t *)prev) + prev->size == ((uint8_t *)mem)) {
-			/* Yes */
-			prev->size += size;
-		} else { /* not merged with previous chunk */
-			MemChunk *curr = (MemChunk *)mem;
-
-			/* insert it after the previous node
-			 * and move the 'prev' pointer forward
-			 * for the following operations
-			 */
-			curr->next = prev->next;
-			curr->size = size;
-			prev->next = curr;
-
-			/* Adjust for the following test */
-			prev = curr;
-		}
-	}
-
-	/* Also merge with next chunk? */
-	if (((uint8_t *)prev) + prev->size == ((uint8_t *)prev->next)) {
-		prev->size += prev->next->size;
-		prev->next = prev->next->next;
-
-		/* There should be only one merge opportunity, becuase we always merge on free */
-		//ASSERT((uint8_t*)prev + prev->size != (uint8_t*)prev->next);
-	}
-
-	rtw_exit_critical(&tcm_lock, &irqL);
-	//printf("---FREE %x--\n\r", mem);
-	//tcm_heap_dump();
-	//printf("--------------\n\r");
-
-}
-
-int tcm_heap_freeSpace(void)
-{
-	int free_mem = 0;
-	struct Heap *h = &g_tcm_heap;
-	_irqL 	irqL;
-	MemChunk *chunk;
-
-	rtw_enter_critical(&tcm_lock, &irqL);
-
-	if (!g_heap_inited)	{
-		tcm_heap_init();
-	}
-
-	for (chunk = h->FreeList; chunk; chunk = chunk->next) {
-		free_mem += chunk->size;
-	}
-
-	rtw_exit_critical(&tcm_lock, &irqL);
-	return free_mem;
-}
-
-
-/**
- * Standard malloc interface
- */
-void *tcm_heap_malloc(int size)
-{
-#if defined(PLATFORM_CMSIS_RTOS)
-	int64_t *mem;
-	// Make sure that block is 8-byte aligned
-	size = (size + 7U) & ~((uint32_t)7U);
-	size += sizeof(int64_t);
-	mem = (int64_t *)tcm_heap_allocmem(size);
-#else
-	int *mem;
-	size += sizeof(int);
-	mem = (int *)tcm_heap_allocmem(size);
-#endif
-
-
-	if (mem) {
-		*mem++ = size;
-	}
-
-	return mem;
-}
-
-/**
- * Standard calloc interface
- */
-void *tcm_heap_calloc(int size)
-{
-	void *mem;
-	mem = tcm_heap_malloc(size);
-	if (mem) {
-		memset(mem, 0, size);
-	}
-
-	return mem;
-}
-
-/**
- * Free a block of memory, determining its size automatically.
- *
- * \param h    Heap from which the block was allocated.
- * \param mem  Pointer to a block of memory previously allocated with
- *             either heap_malloc() or heap_calloc().
- *
- * \note If \a mem is a NULL pointer, no operation is performed.
- *
- * \note Freeing the same memory block twice has undefined behavior.
- *
- * \note This function works like the ANSI C free().
- */
-void tcm_heap_free(void *mem)
-{
-#if defined(PLATFORM_CMSIS_RTOS)
-	int64_t *_mem = (int64_t *)mem;
-#else
-	int *_mem = (int *)mem;
-#endif
-
-	if (_mem) {
-		--_mem;
-		tcm_heap_freemem(_mem, *_mem);
-	}
-}
-
-
-static void alloc_test(int size, int test_len)
-{
-	//Simple test
-	uint8_t *a[100];
-	int i, j;
-
-	for (i = 0; i < test_len; i++) {
-		a[i] = tcm_heap_allocmem(size);
-		//ASSERT(a[i]);
-		for (j = 0; j < size; j++) {
-			a[i][j] = i;
-		}
-	}
-
-	//ASSERT(heap_freeSpace(&h) == HEAP_SIZE - test_len * ROUND_UP2(size, sizeof(MemChunk)));
-
-	for (i = 0; i < test_len; i++) {
-		for (j = 0; j < size; j++) {
-			printf("a[%d][%d] = %d\n", i, j, a[i][j]);
-			//ASSERT(a[i][j] == i);
-		}
-		tcm_heap_freemem(a[i], size);
-	}
-	//ASSERT(heap_freeSpace(&h) == HEAP_SIZE);
-}
-
-#define ALLOC_SIZE 256
-#define ALLOC_SIZE2 1024
-#define TEST_LEN 20
-#define TEST_LEN2 10
-#define HEAP_SIZE 59*1024
-int tcm_heap_testRun(void)
-{
-	alloc_test(ALLOC_SIZE, TEST_LEN);
-	alloc_test(ALLOC_SIZE2, TEST_LEN2);
-	/* Try to allocate the whole heap */
-	uint8_t *b = tcm_heap_allocmem(HEAP_SIZE);
-	int j;
-	//ASSERT(b);
-	//ASSERT(heap_freeSpace(&h) == 0);
-
-	//ASSERT(!heap_allocmem(&h, HEAP_SIZE));
-
-	for (j = 0; j < HEAP_SIZE; j++) {
-		b[j] = j;
-	}
-
-	for (j = 0; j < HEAP_SIZE; j++) {
-		printf("b[%d] = %d\n", j, j);
-		//ASSERT(b[j] == (j & 0xff));
-	}
-	tcm_heap_freemem(b, HEAP_SIZE);
-	//ASSERT(heap_freeSpace(&h) == HEAP_SIZE);
-
-	return 0;
-}
-
-#endif
diff --git a/os/board/rtl8720e/src/component/os/tizenrt/Make.defs b/os/board/rtl8720e/src/component/os/tizenrt/Make.defs
old mode 100644
new mode 100755
index bbb3a72ba..d8a6c8622
--- a/os/board/rtl8720e/src/component/os/tizenrt/Make.defs
+++ b/os/board/rtl8720e/src/component/os/tizenrt/Make.defs
@@ -49,12 +49,11 @@
 #
 ############################################################################
 
-CSRCS += tizenrt_service.c \
-       lwip_intf_tizenrt.c \
+CSRCS += lwip_intf_tizenrt.c \
        ethernetif_tizenrt.c
 
-CSRCS += rtk_netmgr.c \
-	 rtk_blemgr.c \
+CSRCS += rtk_blemgr.c \
+	 rtk_netmgr.c \
 
 DEPPATH += --dep-path component/os/tizenrt
 VPATH += :component/os/tizenrt
diff --git a/os/board/rtl8720e/src/component/os/tizenrt/ethernetif_tizenrt.c b/os/board/rtl8720e/src/component/os/tizenrt/ethernetif_tizenrt.c
old mode 100644
new mode 100755
diff --git a/os/board/rtl8720e/src/component/os/tizenrt/ethernetif_tizenrt.h b/os/board/rtl8720e/src/component/os/tizenrt/ethernetif_tizenrt.h
old mode 100644
new mode 100755
diff --git a/os/board/rtl8720e/src/component/os/tizenrt/freertos_pmu.h b/os/board/rtl8720e/src/component/os/tizenrt/freertos_pmu.h
old mode 100644
new mode 100755
diff --git a/os/board/rtl8720e/src/component/os/tizenrt/lwip_intf_tizenrt.c b/os/board/rtl8720e/src/component/os/tizenrt/lwip_intf_tizenrt.c
old mode 100644
new mode 100755
index 7fcac7584..e62d15a72
--- a/os/board/rtl8720e/src/component/os/tizenrt/lwip_intf_tizenrt.c
+++ b/os/board/rtl8720e/src/component/os/tizenrt/lwip_intf_tizenrt.c
@@ -18,12 +18,13 @@
 #include <lwip/init.h>
 #include <lwip/netif.h>
 #include <osdep_service.h>
-#include "autoconf.h"
+#include "rtw_autoconf.h"
+//#include "rtw_adapter.h"
 
 #include <tinyara/netmgr/netdev_mgr.h>
 #include <sys/socket.h>
 #include <netdev_mgr_internal.h>
-#include "wifi_constants.h"
+#include "rtw_wifi_constants.h"
 #include <net/if.h>
 
 #ifndef WLAN0_NAME
@@ -106,7 +107,7 @@ int rltk_wlan_send(int idx, struct eth_drv_sg *sg_list, int sg_len, int total_le
 
 	unsigned int irq_flags = save_and_cli();
 	/*if (rltk_wlan_check_isup(idx)) {
-		rltk_wlan_tx_inc(idx);
+		wifi_if_tx_inc(idx);
 	} else {
 		DBG_ERR("netif is DOWN");
 		restore_flags(irq_flags);
@@ -129,7 +130,7 @@ int rltk_wlan_send(int idx, struct eth_drv_sg *sg_list, int sg_len, int total_le
 		Mac_data += sg_list->len;
 	}
 
-	skb = (struct sk_buff *)rltk_wlan_alloc_skb_0copy();
+	skb = (struct sk_buff *)wifi_if_alloc_skb_0copy();
 	if (skb == NULL) {
 		ndbg("\r\nrltk_wlan_alloc_skb()failed!\r\n");
 		goto exit;
@@ -141,7 +142,7 @@ int rltk_wlan_send(int idx, struct eth_drv_sg *sg_list, int sg_len, int total_le
 	skb->len = total_len;
 	ret = 0;
 #else
-	skb = rltk_wlan_alloc_skb(total_len);
+	skb = wifi_if_alloc_skb(total_len);
 #endif
 
 	if (skb == NULL) {
@@ -156,11 +157,11 @@ int rltk_wlan_send(int idx, struct eth_drv_sg *sg_list, int sg_len, int total_le
 	}
 #endif
 
-	rltk_wlan_send_skb(idx, skb);
+	wifi_if_send_skb(idx, skb);
 
 exit:
 	irq_flags = save_and_cli();
-	//rltk_wlan_tx_dec(idx);
+	//wifi_if_tx_dec(idx);
 	restore_flags(irq_flags);
 	return ret;
 #endif
@@ -185,7 +186,7 @@ void rltk_wlan_recv(int idx, struct eth_drv_sg *sg_list, int sg_len)
 		DBG_ERR("skb is NULL");
 		return;
 	}
-	skb = rltk_wlan_get_recv_skb(idx);
+	skb = wifi_if_get_recv_skb(idx);
 	DBG_ASSERT(skb, "No pending rx skb");
 
 	for (last_sg = &sg_list[sg_len]; sg_list < last_sg; ++sg_list) {
diff --git a/os/board/rtl8720e/src/component/os/tizenrt/lwip_intf_tizenrt.h b/os/board/rtl8720e/src/component/os/tizenrt/lwip_intf_tizenrt.h
old mode 100644
new mode 100755
index 556de543f..0ce7892da
--- a/os/board/rtl8720e/src/component/os/tizenrt/lwip_intf_tizenrt.h
+++ b/os/board/rtl8720e/src/component/os/tizenrt/lwip_intf_tizenrt.h
@@ -17,46 +17,33 @@
 #ifndef __LWIP_INTF_H__
 #define __LWIP_INTF_H__
 
-#ifdef __cplusplus
+#ifdef	__cplusplus
 extern "C" {
 #endif
 
 #include "platform_opts.h"
-#include <skbuff.h>
+#include <rtw_skbuff.h>
 
 struct netif;
 
 //----- ------------------------------------------------------------------
 // Ethernet Buffer
 //----- ------------------------------------------------------------------
-#if defined(CONFIG_MBED_ENABLED)
-struct eth_drv_sg {
-	unsigned int buf;
-	unsigned int len;
-};
-
-#define MAX_ETH_DRV_SG 32
-#define MAX_ETH_MSG 1540
-#else
-#include "ethernetif_tizenrt.h" // moved to ethernetif.h by jimmy 12/2/2015
+#if defined(CONFIG_LWIP_LAYER) && CONFIG_LWIP_LAYER
+#include "ethernetif_tizenrt.h"  // moved to ethernetif.h by jimmy 12/2/2015
 #endif
 //----- ------------------------------------------------------------------
 // Wlan Interface Provided
 //----- ------------------------------------------------------------------
-unsigned char rltk_wlan_check_isup(int idx);
-void rltk_wlan_tx_inc(int idx);
-void rltk_wlan_tx_dec(int idx);
-struct sk_buff *rltk_wlan_get_recv_skb(int idx);
-struct sk_buff *rltk_wlan_alloc_skb(unsigned int total_len);
+void wifi_if_tx_inc(int idx);
+void wifi_if_tx_dec(int idx);
+struct sk_buff *wifi_if_get_recv_skb(int idx);
+struct sk_buff *wifi_if_alloc_skb(unsigned int total_len);
 void rltk_wlan_set_netif_info(int idx_wlan, void *dev, unsigned char *dev_addr);
-void rltk_wlan_send_skb(int idx, struct sk_buff *skb); //struct sk_buff as defined above comment line
+void wifi_if_send_skb(int idx, struct sk_buff *skb);	//struct sk_buff as defined above comment line
+#if defined(CONFIG_LWIP_LAYER) && CONFIG_LWIP_LAYER
 int rltk_wlan_send(int idx, struct eth_drv_sg *sg_list, int sg_len, int total_len);
 void rltk_wlan_recv(int idx, struct eth_drv_sg *sg_list, int sg_len);
-unsigned char rltk_wlan_running(unsigned char idx); // interface is up. 0: interface is down
-
-#if defined(CONFIG_MBED_ENABLED)
-typedef void (*emac_callback)(void *param, struct netif *netif, unsigned int len);
-void set_callback_func(emac_callback p, void *data);
 #endif
 
 //----- ------------------------------------------------------------------
@@ -67,8 +54,9 @@ int netif_is_valid_IP(int idx, unsigned char *ip_dest);
 int netif_get_idx(struct netif *pnetif);
 int netif_get_hwaddr(int idx_wlan, uint8_t *dev_addr);
 void netif_rx(int idx, unsigned int len);
-void netif_post_sleep_processing(void);
-void netif_pre_sleep_processing(void);
+#if defined(CONFIG_LWIP_LAYER) && CONFIG_LWIP_LAYER
+extern void ethernetif_recv(struct netif *netif, int total_len);
+#endif //CONFIG_LWIP_LAYER == 1
 
 #ifdef CONFIG_WOWLAN
 extern unsigned char *rltk_wlan_get_ip(int idx);
@@ -76,7 +64,7 @@ extern unsigned char *rltk_wlan_get_gw(int idx);
 extern unsigned char *rltk_wlan_get_gwmask(int idx);
 #endif
 
-#ifdef __cplusplus
+#ifdef	__cplusplus
 }
 #endif
 
diff --git a/os/board/rtl8720e/src/component/os/tizenrt/rtk_ble_utils.h b/os/board/rtl8720e/src/component/os/tizenrt/rtk_ble_utils.h
old mode 100644
new mode 100755
diff --git a/os/board/rtl8720e/src/component/os/tizenrt/rtk_blemgr.c b/os/board/rtl8720e/src/component/os/tizenrt/rtk_blemgr.c
old mode 100644
new mode 100755
diff --git a/os/board/rtl8720e/src/component/os/tizenrt/rtk_netmgr.c b/os/board/rtl8720e/src/component/os/tizenrt/rtk_netmgr.c
old mode 100644
new mode 100755
index 284f63202..8139a9f04
--- a/os/board/rtl8720e/src/component/os/tizenrt/rtk_netmgr.c
+++ b/os/board/rtl8720e/src/component/os/tizenrt/rtk_netmgr.c
@@ -25,7 +25,7 @@
 #include <tinyara/lwnl/lwnl.h>
 #include <tinyara/net/if/wifi.h>
 #include <tinyara/netmgr/netdev_mgr.h>
-#include "freertos/wrapper.h"
+// #include "freertos/wrapper.h"
 #include "osdep_service.h"
 /* WLAN CONFIG ---------------------------------------------------------------*/
 #define RTK_OK          0		/*!< RTK_err_t value indicating success (no error) */
diff --git a/os/board/rtl8720e/src/component/os/tizenrt/rtk_wifi_utils.h b/os/board/rtl8720e/src/component/os/tizenrt/rtk_wifi_utils.h
old mode 100644
new mode 100755
index afc13358d..7b74420c0
--- a/os/board/rtl8720e/src/component/os/tizenrt/rtk_wifi_utils.h
+++ b/os/board/rtl8720e/src/component/os/tizenrt/rtk_wifi_utils.h
@@ -27,8 +27,11 @@
 #define __RTK_WIFI_UTILS_H
 
 #include <sys/types.h>
-#include "wifi_constants.h"
-#include "wifi_structures.h"
+#include "rom_rtw_rf.h"
+#include "rom_rtw_structs.h"
+#include "rom_rtw_defs.h"
+#include "rtw_wifi_constants.h"
+#include "rtw_wifi_struct.h"
 #include <tinyara/net/if/wifi.h>
 
 /* rtk return values */
diff --git a/os/board/rtl8720e/src/component/os/tizenrt/tizenrt_service.c b/os/board/rtl8720e/src/component/os/tizenrt/tizenrt_service.c
deleted file mode 100644
index cec6c6a60..000000000
--- a/os/board/rtl8720e/src/component/os/tizenrt/tizenrt_service.c
+++ /dev/null
@@ -1,1359 +0,0 @@
-/******************************************************************************
- * Copyright (c) 2013-2016, Realtek Semiconductor Corp.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- ******************************************************************************/
-
-#include <osdep_service.h>
-#include <stdio.h>
-//#include "ameba_cache.h"
-#include <tinyara/sched.h>
-#include "../../../kernel/sched/sched.h"
-#include <basic_types.h>
-#include <ameba_vector.h>
-#include <ameba.h>
-/********************* os depended utilities ********************/
-
-#ifndef USE_MUTEX_FOR_SPINLOCK
-#define USE_MUTEX_FOR_SPINLOCK 1
-#endif
-
-#if defined(CONFIG_PLATFORM_TIZENRT_OS)
-#define USE_PTHREAD_MUTEX 0		//todo
-#endif
-
-/******************************************************************************
- *                    Misc Function
- ******************************************************************************/
-extern void timer_wrapper(_timerHandle timer_hdl);
-struct _tizenrt_timer_entry {
-	struct list_head list;
-	struct timer_list_priv *timer;
-};
-
-static _list _tizenrt_timer_table;
-static _mutex _tizenrt_timer_mutex = NULL;
-#if 1 //Justin: temporary solution for enter critical code for tizenRT
-static irqstate_t initial_tizen_flags, up_tizen_flag;
-static int flagcnt = 0;
-#endif
-
-unsigned int save_and_cli(void)
-{
-	return irqsave();
-}
-
-void restore_flags(unsigned int flag)
-{
-	irqrestore(flag);
-}
-
-void cli()
-{
-}
-
-/* Not needed on 64bit architectures */
-static unsigned int __div64_32(u64 *n, unsigned int base)
-{
-	u64 rem = *n;
-	u64 b = base;
-	u64 res, d = 1;
-	unsigned int high = rem >> 32;
-
-	/* Reduce the thing a bit first */
-	res = 0;
-	if (high >= base) {
-		high /= base;
-		res = (u64) high << 32;
-		rem -= (u64)(high * base) << 32;
-	}
-
-	while ((u64) b > 0 && b < rem) {
-		b = b + b;
-		d = d + d;
-	}
-
-	do {
-		if (rem >= b) {
-			rem -= b;
-			res += d;
-		}
-		b >>= 1;
-		d >>= 1;
-	} while (d);
-
-	*n = res;
-	return rem;
-}
-
-u32 _tizenrt_end_of_queue_search(_list *head, _list *plist)
-{
-	if (head == plist)
-		return _TRUE;
-	else
-		return _FALSE;
-}
-
-static void _tizenrt_mutex_get(_mutex *plock);
-static void _tizenrt_mutex_put(_lock *plock);
-void _tizenrt_timer_wrapper(void *timer)
-{
-	_list *plist;
-	struct _tizenrt_timer_entry *timer_entry = NULL;
-
-	_tizenrt_mutex_get(&_tizenrt_timer_mutex);
-	plist = get_next(&_tizenrt_timer_table);
-	while ((_tizenrt_end_of_queue_search(&_tizenrt_timer_table, plist)) == _FALSE) {
-		timer_entry = LIST_CONTAINOR(plist, struct _tizenrt_timer_entry, list);
-		if (timer_entry->timer == timer) {
-			break;
-		}
-		plist = get_next(plist);
-	}
-	_tizenrt_mutex_put(&_tizenrt_timer_mutex);
-
-	if (plist == &_tizenrt_timer_table) {
-		return;
-	}
-	timer_entry->timer->live = 0;
-
-	if (timer_entry->timer->function) {
-		timer_entry->timer->function(timer);
-	}
-}
-
-/********************* os depended service ********************/
-
-void *_tizenrt_malloc(u32 sz)
-{
-	return kmm_malloc(sz);
-}
-
-void *_tizenrt_zmalloc(u32 sz)
-{
-	return kmm_zalloc(sz);
-}
-
-void _tizenrt_mfree(u8 *pbuf, u32 sz)
-{
-	/* To avoid gcc warnings */
-	(void)sz;
-
-	kmm_free(pbuf);
-}
-
-static void _tizenrt_memcpy(void *dst, void *src, u32 sz)
-{
-	memcpy(dst, src, sz);
-}
-
-static int _tizenrt_memcmp(void *dst, void *src, u32 sz)
-{
-	if (!(memcmp(dst, src, sz))) {
-		return 1;
-	}
-
-	return 0;
-}
-
-static void _tizenrt_memset(void *pbuf, int c, u32 sz)
-{
-	memset(pbuf, c, sz);
-}
-
-static void _tizenrt_init_sema(_sema *sema, int init_val)
-{
-	if (*sema == NULL) {
-		*sema = (_sema) _tizenrt_zmalloc(sizeof(sem_t));
-		if (*sema == NULL) {
-			DBG_ERR("Failed to kmm_zalloc\n");
-			return;
-		}
-#ifdef CONFIG_DEBUG_MM_HEAPINFO
-		DEBUG_SET_CALLER_ADDR(*sema);
-#endif
-	} else {
-		DBG_ERR("Already inited\n");
-		return;
-	}
-	int ret = sem_init((sem_t *)(*sema), 0, init_val);
-	if (ret != OK) {
-		DBG_ERR("Failed to sem_init\n");
-		_tizenrt_mfree(*sema, sizeof(sem_t));
-		return;
-	}
-}
-
-static void _tizenrt_free_sema(_sema *sema)
-{
-	int i;
-	if (*sema != NULL) {
-		i = sem_destroy(*sema);
-		if (i == 0) {
-			kmm_free(*sema);
-		} else {
-			DBG_ERR("Fail!!!\n");
-		}
-	}
-	*sema = NULL;
-}
-
-static void _tizenrt_up_sema(_sema *sema)
-{
-	sem_post((sem_t *)(*sema));
-}
-
-static void _tizenrt_up_sema_from_isr(_sema *sema)
-{
-	sem_post((sem_t *)(*sema));
-}
-
-static u32 _tizenrt_down_sema(_sema *sema, u32 timeout)
-{
-	struct timespec ts;
-	int ret;
-	if (timeout == RTW_MAX_DELAY) {
-		ret = sem_wait((sem_t *)(*sema));
-	} else {
-		clock_gettime(CLOCK_REALTIME, &ts);
-		ts.tv_sec += timeout / 1000;
-		ret = sem_timedwait((sem_t *)(*sema), &ts);
-	}
-	if (ret != OK) {
-		return _FAIL;
-	} else {
-		return _SUCCESS;
-	}
-}
-
-static void _tizenrt_mutex_init(_mutex *pmutex)
-{
-#if USE_PTHREAD_MUTEX
-	pthread_mutexattr_t mutex_attr;
-	int err;
-
-	if (*pmutex == NULL) {
-		*pmutex = _tizenrt_zmalloc(sizeof(pthread_mutex_t));
-		if (*pmutex == NULL) {
-			DBG_ERR("Failed\n");
-			goto err_exit;
-		}
-#ifdef CONFIG_DEBUG_MM_HEAPINFO
-		DEBUG_SET_CALLER_ADDR(*pmutex);
-#endif
-	}
-	err = pthread_mutexattr_init(&mutex_attr);
-	if (err) {
-		DBG_ERR("pthread_mutexattr_init failed with error code (%d).\n", err);
-		goto err_exit;
-	}
-	err = pthread_mutexattr_settype(&mutex_attr, PTHREAD_MUTEX_RECURSIVE);
-	if (err) {
-		DBG_ERR("pthread_mutexattr_settype failed with error code (%d).\n", err);
-		goto err_exit;
-	}
-	err = pthread_mutex_init((pthread_mutex_t *)(*pmutex), &mutex_attr);
-	if (err) {
-		DBG_ERR("pthread_mutex_init failed with error code (%d).\n", err);
-		goto err_exit;
-	}
-	return;
-err_exit:
-	if (*pmutex) {
-		_tizenrt_mfree(*pmutex);
-	}
-	return;
-#else
-	if (*pmutex == NULL) {
-		*pmutex = _tizenrt_zmalloc(sizeof(sem_t));
-		if (*pmutex == NULL) {
-			DBG_ERR("Failed\n");
-			return;
-		}
-#ifdef CONFIG_DEBUG_MM_HEAPINFO
-		DEBUG_SET_CALLER_ADDR(*pmutex);
-#endif
-	}
-	sem_init(*pmutex, 0, 1);
-	sem_setprotocol(*pmutex, SEM_PRIO_NONE);
-#endif
-}
-
-static void _tizenrt_mutex_free(_mutex *pmutex)
-{
-#if USE_PTHREAD_MUTEX
-	if (*pmutex == NULL) {
-		return;
-	}
-	int err = pthread_mutex_destroy((pthread_mutex_t *)(*pmutex));
-	if (err) {
-		DBG_ERR("pthread_mutex_destroy failed with error code (%d).\n", err);
-	}
-	_tizenrt_mfree(*pmutex);
-#else
-	int i;
-	if (*pmutex != NULL) {
-		i = sem_destroy(*pmutex);
-		if (i == 0) {
-			kmm_free(*pmutex);
-		} else {
-			DBG_ERR("Fail!!!\n");
-		}
-	}
-#endif
-	*pmutex = NULL;
-}
-
-static void _tizenrt_mutex_get(_mutex *plock)
-{
-#if USE_PTHREAD_MUTEX
-	int err = pthread_mutex_lock((pthread_mutex_t *)(*plock));
-	if (err) {
-		DBG_ERR("Failed to acquire lock. Error code: (%d).\n", err);
-	}
-#else
-	int temp;
-	temp = sem_wait(*plock);
-	if (temp != 0) {
-		DBG_ERR("Failed!\n");
-	}
-#endif
-}
-
-static int _tizenrt_mutex_get_timeout(_mutex *plock, u32 timeout_ms)
-{
-	struct timespec ts;
-	clock_gettime(CLOCK_REALTIME, &ts);
-	ts.tv_sec += timeout_ms / 1000;
-	if (sem_timedwait(*plock, &ts) < 0) {
-		return _FAIL;
-	} else {
-		return _SUCCESS;
-	}
-}
-
-#if 1 //Justin: temporary solution for enter critical code for tizenRT
-void save_and_cli_temp(void);
-void restore_flags_temp(void);
-void save_and_cli_temp()
-{
-	if(flagcnt){
-		up_tizen_flag = irqsave();
-	}else{
-		initial_tizen_flags = irqsave();
-	}
-	flagcnt++;
-}
-
-void restore_flags_temp()
-{
-	flagcnt--;
-	if(flagcnt){
-		irqrestore(up_tizen_flag);
-	}else{
-		irqrestore(initial_tizen_flags);
-	}
-}
-#endif
-
-static void _tizenrt_mutex_put(_lock *plock)
-{
-	sem_post(*plock);
-}
-
-static void _tizenrt_enter_critical(_lock *plock, _irqL *pirqL)
-{
-#if 1 //temporary solution for enter critical code for tizenRT
-	save_and_cli_temp();
-#else 
-	//printf("\n"); //suppress meaningless printout
-#endif
-}
-
-static void _tizenrt_exit_critical(_lock *plock, _irqL *pirqL)
-{
-#if 1 //temporary solution for enter critical code for tizenRT
-	restore_flags_temp();
-#else 
-	//printf("\n"); //suppress meaningless printout
-#endif
-}
-
-static void _tizenrt_enter_critical_from_isr(_lock *plock, _irqL *pirqL)
-{
-	DBG_INFO("\n");
-}
-
-static void _tizenrt_exit_critical_from_isr(_lock *plock, _irqL *pirqL)
-{
-	DBG_INFO("\n");
-}
-
-static int _tizenrt_enter_critical_mutex(_mutex *pmutex, _irqL *pirqL)
-{
-	int temp;
-	temp = sem_wait(*pmutex);
-	if (temp != 0) {
-		DBG_ERR("Failed!\n");
-	}
-	return temp;
-}
-
-static void _tizenrt_exit_critical_mutex(_mutex *pmutex, _irqL *pirqL)
-{
-	sem_post(*pmutex);
-}
-
-#if defined(CONFIG_PLATFORM_8195BHP)
-#include "timer_api.h"
-static gtimer_t tmp_timer_obj;
-#endif
-static void _tizenrt_cpu_lock(void)
-{
-#if defined(CONFIG_PLATFORM_8195BHP)
-	__disable_irq();
-	icache_disable();
-	dcache_disable();
-
-	gtimer_init(&tmp_timer_obj, 0xff);
-	gtimer_reload(&tmp_timer_obj, 400 * 1000);	// 4s
-	gtimer_start(&tmp_timer_obj);
-#endif
-}
-
-static void _tizenrt_cpu_unlock(void)
-{
-#if defined(CONFIG_PLATFORM_8195BHP)
-	int duration = (int)gtimer_read_us(&tmp_timer_obj) / 1000;
-	gtimer_deinit(&tmp_timer_obj);
-	/* compensate rtos tick */
-	vTaskIncTick(duration);
-	icache_enable();
-	icache_invalidate();
-	__enable_irq();
-#endif
-}
-
-static void _tizenrt_spinlock_init(_lock *plock)
-{
-	if (*plock == NULL) {
-		*plock = _tizenrt_zmalloc(sizeof(sem_t));
-		if (*plock == NULL) {
-			DBG_ERR("Failed\n");
-			return;
-		}
-#ifdef CONFIG_DEBUG_MM_HEAPINFO
-		DEBUG_SET_CALLER_ADDR(*plock);
-#endif
-	}
-	sem_init(*plock, 0, 1);
-	sem_setprotocol(*plock, SEM_PRIO_NONE);
-}
-
-static void _tizenrt_spinlock_free(_lock *plock)
-{
-	int i;
-	if (*plock != NULL) {
-		i = sem_destroy(*plock);
-		if (i == 0) {
-			kmm_free(*plock);
-		} else {
-			DBG_ERR("Fail!!!\n");
-		}
-	}
-	*plock = NULL;
-}
-
-static void _tizenrt_spinlock(_lock *plock)
-{
-	int temp;
-	temp = sem_wait(*plock);
-	if (temp != 0) {
-		DBG_ERR("Failed!\n");
-	}
-}
-
-static void _tizenrt_spinunlock(_lock *plock)
-{
-	sem_post(*plock);
-}
-
-static void _tizenrt_spinlock_irqsave(_lock *plock, _irqL *irqL)
-{
-	DBG_INFO("\n");
-	/* save_and_cli(); */
-	_tizenrt_spinlock(plock);
-}
-
-static void _tizenrt_spinunlock_irqsave(_lock *plock, _irqL *irqL)
-{
-	DBG_INFO("\n");
-	_tizenrt_spinunlock(plock);
-	/* restore_flags(); */
-}
-
-static int _tizenrt_init_xqueue(_xqueue *queue, const char *name, u32 message_size, u32 number_of_messages)
-{
-	DBG_INFO("\n");
-	return 0;
-}
-
-static int _tizenrt_push_to_xqueue(_xqueue *queue, void *message, u32 timeout_ms)
-{
-	DBG_INFO("\n");
-	return 0;
-}
-
-static int _tizenrt_pop_from_xqueue(_xqueue *queue, void *message, u32 timeout_ms)
-{
-	DBG_INFO("\n");
-	return 0;
-}
-
-static int _tizenrt_peek_from_xqueue( _xqueue* queue, void* message, u32 timeout_ms )
-{
-	DBG_INFO("\n");
-	return 0;
-}
-
-static int _tizenrt_deinit_xqueue(_xqueue *queue)
-{
-	DBG_INFO("\n");
-	return 0;
-}
-
-static u32 _tizenrt_get_current_time(void)
-{
-	return (u32) clock();
-}
-
-static u32 _tizenrt_systime_to_ms(u32 sys_time)
-{
-
-	return (sys_time * 1000L / TICK_PER_SEC);
-}
-
-static u32 _tizenrt_systime_to_sec(u32 sys_time)
-{
-
-	return (sys_time / TICK_PER_SEC);
-}
-
-static u32 _tizenrt_ms_to_systime(u32 ms)
-{
-
-	return (ms * TICK_PER_SEC / 1000L);
-}
-
-static u32 _tizenrt_sec_to_systime(u32 sec)
-{
-
-	return (sec * TICK_PER_SEC);
-}
-
-static void _tizenrt_msleep_os(int ms)
-{
-	usleep((unsigned int)ms * 1000);
-}
-
-static void _tizenrt_usleep_os(int us)
-{
-	usleep((unsigned int)us);
-}
-
-static void _tizenrt_mdelay_os(int ms)
-{
-	up_mdelay((unsigned long)ms);
-}
-
-static void _tizenrt_udelay_os(int us)
-{
-	up_udelay((unsigned long)us);
-}
-
-static void _tizenrt_yield_os(void)
-{
-	sched_yield();
-}
-
-static void _tizenrt_ATOMIC_SET(ATOMIC_T *v, int i)
-{
-	atomic_set(v, i);
-}
-
-static int _tizenrt_ATOMIC_READ(ATOMIC_T *v)
-{
-	return atomic_read(v);
-}
-
-static void _tizenrt_ATOMIC_ADD(ATOMIC_T *v, int i)
-{
-	unsigned int irq_flags = save_and_cli();
-	v->counter += i;
-	restore_flags(irq_flags);
-}
-
-static void _tizenrt_ATOMIC_SUB(ATOMIC_T *v, int i)
-{
-	unsigned int irq_flags = save_and_cli();
-	v->counter -= i;
-	restore_flags(irq_flags);
-}
-
-static void _tizenrt_ATOMIC_INC(ATOMIC_T *v)
-{
-	_tizenrt_ATOMIC_ADD(v, 1);
-}
-
-static void _tizenrt_ATOMIC_DEC(ATOMIC_T *v)
-{
-	_tizenrt_ATOMIC_SUB(v, 1);
-}
-
-static int _tizenrt_ATOMIC_ADD_RETURN(ATOMIC_T *v, int i)
-{
-	int temp;
-
-	unsigned int irq_flags = save_and_cli();
-	temp = v->counter;
-	temp += i;
-	v->counter = temp;
-	restore_flags(irq_flags);
-
-	return temp;
-}
-
-static int _tizenrt_ATOMIC_SUB_RETURN(ATOMIC_T *v, int i)
-{
-	int temp;
-
-	unsigned int irq_flags = save_and_cli();
-	temp = v->counter;
-	temp -= i;
-	v->counter = temp;
-	restore_flags(irq_flags);
-
-	return temp;
-}
-
-static int _tizenrt_ATOMIC_INC_RETURN(ATOMIC_T *v)
-{
-	return _tizenrt_ATOMIC_ADD_RETURN(v, 1);
-}
-
-static int _tizenrt_ATOMIC_DEC_RETURN(ATOMIC_T *v)
-{
-	return _tizenrt_ATOMIC_SUB_RETURN(v, 1);
-}
-
-static u64 _tizenrt_modular64(u64 n, u64 base)
-{
-	unsigned int __base = (base);
-	unsigned int __rem;
-
-	if (((n) >> 32) == 0) {
-		__rem = (unsigned int)(n) % __base;
-		(n) = (unsigned int)(n) / __base;
-	} else {
-		__rem = __div64_32(&(n), __base);
-	}
-
-	return __rem;
-}
-
-/* Refer to ecos bsd tcpip codes */
-static int _tizenrt_arc4random(void)
-{
-#if defined(CONFIG_PLATFORM_AMEBALITE)
-	int value = (int)_rand();
-	return value;
-
-#else
-
-	u32 res = xTaskGetTickCount();
-	static unsigned long seed = 0xDEADB00B;
-
-#if defined(CONFIG_PLATFORM_8711B)
-	if (random_seed) {
-		seed = random_seed;
-		random_seed = 0;
-	}
-#endif
-	seed = ((seed & 0x007F00FF) << 7) ^ ((seed & 0x0F80FF00) >> 8) ^	// be sure to stir those low bits
-		   (res << 13) ^ (res >> 9);	// using the clock too!
-	return (int)seed;
-#endif
-}
-
-static int _tizenrt_get_random_bytes(void *buf, size_t len)
-{
-	unsigned int ranbuf;
-	unsigned int *lp;
-	int i, count;
-	count = len / sizeof(unsigned int);
-	lp = (unsigned int *)buf;
-
-	for (i = 0; i < count; i++) {
-		lp[i] = _tizenrt_arc4random();
-		len -= sizeof(unsigned int);
-	}
-
-	if (len > 0) {
-		ranbuf = _tizenrt_arc4random();
-		_tizenrt_memcpy(&lp[i], &ranbuf, len);
-	}
-	return 0;
-}
-
-static u32 _tizenrt_GetFreeHeapSize(void)
-{
-	return 0;
-}
-
-static int wrapper_thread(int argc, char *argv[])
-{
-	int func_addr, ctx_addr;
-	thread_func_t func;
-	void *thctx;
-	if (argc != 3) {
-		DBG_ERR("%s error\n", argv[0]);
-		return -1;
-	}
-	/* Arguments : [0] task name [1] func addr, [2] ctx addr */
-	func_addr = strtoul(argv[1], NULL, 16);
-	ctx_addr = strtoul(argv[2], NULL, 16);
-	func = (thread_func_t)func_addr;
-	thctx = (void *)ctx_addr;
-	func(thctx);
-	return OK;
-}
-static int _tizenrt_create_task(struct task_struct *ptask, const char *name, u32 stack_size, u32 priority, thread_func_t func, void *thctx)
-{
-#if USE_PTHREAD_MUTEX
-	pthread_attr_t attr;
-	struct sched_param sparam;
-	int res = 0;
-
-	pthread_t tid;
-
-	res = pthread_attr_init(&attr);
-	if (res != OK) {
-		DBG_ERR("Failed to pthread_attr_init\n");
-		goto err_exit;
-	}
-
-	stack_size *= sizeof(uint32_t);
-	res = pthread_attr_setstacksize(&attr, stack_size);
-	if (res != OK) {
-		DBG_ERR("Failed to pthread_attr_setstacksize\n");
-		goto err_exit;
-	}
-
-	sparam.sched_priority = PTHREAD_DEFAULT_PRIORITY + priority;
-
-	res = pthread_attr_setschedparam(&attr, &sparam);
-	if (res != OK) {
-		DBG_ERR("Failed to pthread_attr_setschedparam\n");
-		goto err_exit;
-	}
-
-	res = pthread_create(&tid, &attr, (pthread_startroutine_t) func, thctx);
-	if (res != OK) {
-		DBG_ERR("Failed to pthread_create\n");
-		goto err_exit;
-	}
-	if (tid == 0) {
-		DBG_ERR("Create the task %s failed! .\n", name);
-		goto err_exit;
-	}
-	ptask->task = tid;
-	ptask->task_name = name;
-	return _SUCCESS;
-err_exit:
-	ptask->task = -1;
-	ptask->task_name = NULL;
-	return _FAIL;
-#else
-	int func_addr, ctx_addr;
-	pid_t pid;
-	char str_func_addr[9];
-	char str_ctx_addr[9];
-	char *task_info[3];
-	priority = SCHED_PRIORITY_DEFAULT + priority;
-	priority = (priority > SCHED_PRIORITY_MAX || priority < SCHED_PRIORITY_MIN)?SCHED_PRIORITY_DEFAULT:priority;
-	if(strncmp(name, "rtw_interrupt_thread", strlen("rtw_interrupt_thread") + 1) == 0) priority = 106;
-	if(strncmp(name, "rtw_recv_tasklet", strlen("rtw_recv_tasklet") + 1) == 0) priority = 105;
-	if(strncmp(name, "rtw_xmit_tasklet", strlen("rtw_xmit_tasklet") + 1) == 0) priority = 105;
-	if(strncmp(name, "cmd_thread", strlen("cmd_thread") + 1) == 0) priority = 105;
-	if(strncmp(name, "tcp_server_handler", strlen("tcp_server_handler") + 1) == 0) priority = 105;
-
-	stack_size *= sizeof(uint32_t);
-	func_addr = (int)func;
-	ctx_addr = (int)thctx;
-	task_info[0] = itoa(func_addr, str_func_addr, 16);
-	task_info[1] = itoa(ctx_addr, str_ctx_addr, 16);
-	task_info[2] = NULL;
-	pid = kernel_thread(name, priority, stack_size, wrapper_thread, (char * const *)task_info);
-	if (pid == ERROR) {
-		DBG_ERR("%s fail\n", name);
-		return _FAIL;
-	}
-	ptask->task = (pid_t)pid;
-	ptask->task_name = name;
-	return _SUCCESS;
-#endif
-}
-
-static void _tizenrt_delete_task(struct task_struct *ptask)
-{
-#if USE_PTHREAD_MUTEX
-	int status = 0;
-	pthread_t tid = (pthread_t) ptask->task;
-	if (!ptask->task || tid == 0) {
-		DBG_ERR("ptask is NULL %s!\n", ptask->task_name);
-		return;
-	}
-	status = pthread_cancel(tid);
-	if (status != OK) {
-		DBG_ERR("Failed, status=%d!\n", status);
-		return;
-	}
-	ptask->task = -1;
-#else
-	pid_t pid;
-	int status;
-	pid = (pid_t) ptask->task;
-	status = task_delete(pid);
-	if (status != OK) {
-		DBG_ERR("Failed, status=%d!\n", status);
-	}
-	ptask->task = -1;
-#endif
-	return;
-}
-
-static void _tizenrt_set_priority_task(void* task, u32 NewPriority)
-{
-	FAR struct tcb_s *rtcb = sched_gettcb(*(pid_t *)task);
-	DBG_INFO("\n");
-
-	if (rtcb == NULL) {
-		DBG_ERR("Failed to get main task %d!\n", *(pid_t *)task);
-		return;
-	}
-
-	sched_setpriority(rtcb, NewPriority + SCHED_PRIORITY_DEFAULT);
-	return;
-}
-
-static int _tizenrt_get_priority_task(void *task)
-{
-	FAR struct tcb_s *rtcb = sched_gettcb(*(pid_t *)task);
-	DBG_INFO("\n");
-
-	if (rtcb == NULL) {
-		DBG_ERR("Failed to get main task %d!\n", *(pid_t *)task);
-		return _FAIL;
-	}
-
-	return rtcb->sched_priority - SCHED_PRIORITY_DEFAULT;
-}
-
-static void _tizenrt_suspend_task(void *task)
-{
-	FAR struct tcb_s *rtcb = sched_gettcb(*(pid_t *)task);
-	DBG_INFO("\n");
-
-	if (rtcb == NULL) {
-		DBG_ERR("Failed to get main task %d!\n", *(pid_t *)task);
-		return;
-	}
-
-	return;
-}
-
-static void _tizenrt_resume_task(void *task)
-{
-	FAR struct tcb_s *rtcb = sched_gettcb(*(pid_t *)task);
-	DBG_INFO("\n");
-
-	if (rtcb == NULL) {
-		DBG_ERR("Failed to get main task %d!\n", *(pid_t *)task);
-		return;
-	}
-
-	return;
-}
-
-static void _tizenrt_suspend_task_all(void)
-{
-	DBG_INFO("\n");
-	return;
-}
-
-static void _tizenrt_resume_task_all(void)
-{
-	DBG_INFO("\n");
-	return;
-}
-
-static void _tizenrt_thread_enter(char *name)
-{
-	DBG_INFO("RTKTHREAD %s\n", name);
-}
-
-static void _tizenrt_thread_exit(void)
-{
-	DBG_INFO("RTKTHREAD exit\n");
-#if USE_PTHREAD_MUTEX
-	pthread_exit(NULL);
-#else
-	exit(EXIT_SUCCESS);
-#endif
-}
-
-_timerHandle _tizenrt_timerCreate(const signed char *pcTimerName, osdepTickType xTimerPeriodInTicks, uint32_t uxAutoReload, void *pvTimerID, TIMER_FUN pxCallbackFunction)
-{
-	struct timer_list_priv *timer = (struct timer_list_priv *)_tizenrt_zmalloc(sizeof(struct timer_list_priv));
-	if (timer == NULL) {
-		DBG_ERR("Fail to alloc priv\n");
-		return NULL;
-	}
-#ifdef CONFIG_DEBUG_MM_HEAPINFO
-	DEBUG_SET_CALLER_ADDR(timer);
-#endif
-	timer->work_hdl = (struct work_s *)_tizenrt_zmalloc(sizeof(struct work_s));
-	if (timer->work_hdl == NULL) {
-		DBG_ERR("Fail to alloc timer->work_hdl\n");
-		kmm_free(timer);
-		return NULL;
-	}
-#ifdef CONFIG_DEBUG_MM_HEAPINFO
-	DEBUG_SET_CALLER_ADDR(timer->work_hdl);
-#endif
-	timer->live = 0;
-	timer->timevalue = xTimerPeriodInTicks;
-	timer->data = pvTimerID;
-	timer->function = pxCallbackFunction;
-
-	if(_tizenrt_timer_mutex == NULL) {
-		unsigned int irq_flags = save_and_cli();
-		if(_tizenrt_timer_mutex == NULL) {
-			_tizenrt_mutex_init(&_tizenrt_timer_mutex);
-			INIT_LIST_HEAD(&_tizenrt_timer_table);
-		}
-		restore_flags(irq_flags);
-	}
-
-	struct _tizenrt_timer_entry *timer_entry;
-	timer_entry = (struct _tizenrt_timer_entry *)_tizenrt_zmalloc(sizeof(struct _tizenrt_timer_entry));
-	if (timer_entry == NULL) {
-		kmm_free(timer->work_hdl);
-		kmm_free(timer);
-		return NULL;
-	}
-#ifdef CONFIG_DEBUG_MM_HEAPINFO
-	DEBUG_SET_CALLER_ADDR(timer_entry);
-#endif
-	timer_entry->timer = timer;
-
-	_tizenrt_mutex_get(&_tizenrt_timer_mutex);
-	list_add(&(timer_entry->list), &_tizenrt_timer_table);
-	_tizenrt_mutex_put(&_tizenrt_timer_mutex);
-
-	return (_timerHandle) timer;
-}
-
-u32 _tizenrt_timerDelete(_timerHandle xTimer, osdepTickType xBlockTime)
-{
-	struct timer_list_priv *timer = (struct timer_list_priv *)xTimer;
-
-	_list *plist;
-	struct _tizenrt_timer_entry *timer_entry;
-
-	int ret = work_cancel(LPWORK, timer->work_hdl);
-	if (ret != OK && ret != -ENOENT) {
-		DBG_ERR(" failed! ret = %d\n", ret);
-		return _FAIL;
-	}
-
-	_tizenrt_mutex_get(&_tizenrt_timer_mutex);
-	plist = get_next(&_tizenrt_timer_table);
-	while ((_tizenrt_end_of_queue_search(&_tizenrt_timer_table, plist)) == _FALSE) {
-		timer_entry = LIST_CONTAINOR(plist, struct _tizenrt_timer_entry, list);
-		if (timer_entry->timer == timer) {
-			list_del_init(plist);
-			kmm_free(timer_entry);
-			break;
-		}
-		plist = get_next(plist);
-	}
-	_tizenrt_mutex_put(&_tizenrt_timer_mutex);
-	if (plist == &_tizenrt_timer_table) {
-		return _FAIL;
-	}
-
-	timer->data = NULL;
-	timer->timer_hdl = NULL;
-	timer->timevalue = 0;
-	timer->live = 0;
-	kmm_free(timer->work_hdl);
-	kmm_free(timer);
-	return _SUCCESS;
-}
-
-u32 _tizenrt_timerIsTimerActive(_timerHandle xTimer)
-{
-	struct timer_list_priv *timer = (struct timer_list_priv *)xTimer;
-
-	return timer->live;
-}
-
-u32 _tizenrt_timerStop(_timerHandle xTimer, osdepTickType xBlockTime)
-{
-	struct timer_list_priv *timer = (struct timer_list_priv *)xTimer;
-
-	int ret = work_cancel(LPWORK, timer->work_hdl);
-	if (ret != OK && ret != -ENOENT) {
-		DBG_ERR(" failed! ret = %d\n", ret);
-		return _FAIL;
-	}
-
-	timer->timevalue = 0;
-	timer->live = 0;
-	return _SUCCESS;
-}
-
-u32 _tizenrt_timerChangePeriod(_timerHandle xTimer, osdepTickType xNewPeriod, osdepTickType xBlockTime)
-{
-	int ret;
-	struct timer_list_priv *timer = (struct timer_list_priv *)xTimer;
-	ret = work_queue(LPWORK, timer->work_hdl, _tizenrt_timer_wrapper, (void *)(timer), xNewPeriod);
-	if (ret == -EALREADY) {
-		if (work_cancel(LPWORK, timer->work_hdl) != OK) {
-			DBG_ERR("Failed!\n");
-			return _FAIL;
-		}
-		if (work_queue(LPWORK, timer->work_hdl, _tizenrt_timer_wrapper, (void *)(timer), xNewPeriod)) {
-			DBG_ERR("Failed!\n");
-			return _FAIL;
-		}
-	}
-	timer->live = 1;
-
-	return _SUCCESS;
-}
-
-void *_tizenrt_timerGetID(_timerHandle xTimer)
-{
-	struct timer_list_priv *timer = (struct timer_list_priv *)xTimer;
-	return timer->data;
-}
-
-u32 _tizenrt_timerStart(_timerHandle xTimer, osdepTickType xBlockTime)
-{
-	DBG_INFO("\n");
-	return 0;
-}
-
-u32 _tizenrt_timerStartFromISR(_timerHandle xTimer, osdepBASE_TYPE *pxHigherPriorityTaskWoken)
-{
-	DBG_INFO("\n");
-	return 0;
-}
-
-u32 _tizenrt_timerStopFromISR(_timerHandle xTimer, osdepBASE_TYPE *pxHigherPriorityTaskWoken)
-{
-	DBG_INFO("\n");
-	return 0;
-}
-
-u32 _tizenrt_timerResetFromISR(_timerHandle xTimer, osdepBASE_TYPE *pxHigherPriorityTaskWoken)
-{
-	DBG_INFO("\n");
-	return 0;
-}
-
-u32 _tizenrt_timerChangePeriodFromISR(_timerHandle xTimer, osdepTickType xNewPeriod, osdepBASE_TYPE *pxHigherPriorityTaskWoken)
-{
-	DBG_INFO("\n");
-	return 0;
-}
-
-u32 _tizenrt_timerReset(_timerHandle xTimer, osdepTickType xBlockTime)
-{
-	DBG_INFO("\n");
-	return 0;
-}
-
-void _tizenrt_acquire_wakelock(void)
-{
-}
-
-void _tizenrt_release_wakelock(void)
-{
-}
-
-void _tizenrt_wakelock_timeout(uint32_t timeout)
-{
-}
-
-u8 _tizenrt_get_scheduler_state(void)
-{
-	DBG_INFO("\n");
-	return 0;
-}
-
-static IRQ_FUN TizenUserIrqFunTable[MAX_PERIPHERAL_IRQ_NUM];
-static int wrapper_IrqFun(int irq, FAR void *context, FAR void *arg)
-{
-	if (irq < AMEBALITE_IRQ_FIRST) {
-		DBG_INFO("INT %d should not come here\n", irq);
-		return OK;
-	}
-	__NVIC_ClearPendingIRQ(irq - AMEBALITE_IRQ_FIRST);
-	if (TizenUserIrqFunTable[irq - AMEBALITE_IRQ_FIRST] != NULL) {
-		TizenUserIrqFunTable[irq - AMEBALITE_IRQ_FIRST]((VOID *)(arg));
-	} else {
-		DBG_INFO("INT_Entry Irq %d Fun Not Assign!!!!!\n", irq - AMEBALITE_IRQ_FIRST);
-	}
-	return OK;
-}
-
-/* AmebaLite compile cannot find this define so hardcoded here */
-#define __NVIC_PRIO_BITS 3	/**< Number of priority bits implemented in the NVIC */
-BOOL irq_register_ram(IRQ_FUN IrqFun, IRQn_Type IrqNum, u32 Data, u32 Priority)
-{
-	if (IrqNum < 0) {
-		DBG_INFO("INT %d should not come here\n", IrqNum);
-		return _TRUE;
-	}
-
-	if (IrqNum == WL_DMA_IRQ || IrqNum == WL_PROTOCOL_IRQ) {
-		Priority = 4;
-	}
-	TizenUserIrqFunTable[IrqNum] = (IRQ_FUN)((u32) IrqFun | 0x1);
-	Priority = (Priority << (8 - __NVIC_PRIO_BITS));
-	irq_attach(IrqNum + AMEBALITE_IRQ_FIRST, wrapper_IrqFun, (void *)Data);
-	up_prioritize_irq(IrqNum + AMEBALITE_IRQ_FIRST, Priority);	//Need to fix, because it can't get the same result as __NVIC_SetPriority
-	return _TRUE;
-}
-
-BOOL irq_unregister_ram(IRQn_Type IrqNum)
-{
-	if (IrqNum < 0) {
-		DBG_INFO("INT %d should not come here\n", IrqNum);
-		return _TRUE;
-	}
-	irq_detach(IrqNum);
-	TizenUserIrqFunTable[IrqNum] = NULL;
-	return _TRUE;
-}
-
-void irq_enable_ram(IRQn_Type IrqNum)
-{
-	if (IrqNum < 0) {
-		DBG_INFO("INT %d should not come here\n", IrqNum);
-		return;
-	}
-	up_enable_irq(IrqNum + AMEBALITE_IRQ_FIRST);
-}
-
-void irq_disable_ram(IRQn_Type IrqNum)
-{
-	if (IrqNum < 0) {
-		DBG_INFO("INT %d should not come here\n", IrqNum);
-		return;
-	}
-	up_disable_irq(IrqNum + AMEBALITE_IRQ_FIRST);
-}
-
-int __wrap_printf(const char *format, ...)
-{
-	int ret = 0;
-	va_list args;
-	va_start(args, (const char *)format);
-	ret = rtw_printf((const char *)format, args);
-	va_end(args);
-	return ret;
-}
-
-void shell_switch_ipc_int(VOID *Data, u32 IrqStatus, u32 ChanNum)
-{
-	DBG_INFO("\n");
-}
-
-uint32_t *vTaskStackAddr(void)
-{
-	struct tcb_s *rtcb = this_task();
-	/* Get the limits on the user stack memory */
-	return (uint32_t *)rtcb->adj_stack_ptr;
-}
-
-uint32_t vTaskStackSize(void)
-{
-	struct tcb_s *rtcb = this_task();
-	return (uint32_t)rtcb->adj_stack_size;
-}
-
-char * vTaskName(void)
-{
-	struct tcb_s *rtcb = this_task();
-	return (char *)rtcb->name;
-}
-
-void vPortEnterCritical(void)
-{
-	printf("\n");
-}
-
-void vPortExitCritical(void)
-{
-	printf("\n");
-}
-
-void vTaskDelay(int ms)
-{
-	_tizenrt_mdelay_os(ms);
-}
-
-int rtw_printf(const char *format,...)
-{
-	int ret = 0;
-#ifdef CONFIG_DEBUG_LWNL80211_VENDOR_DRV_INFO
-	va_list ap;
-	va_start(ap, format);
-#ifdef CONFIG_LOGM
-	ret = logm_internal(LOGM_NORMAL, LOGM_IDX, LOGM_INF, format, ap);
-#else
-	ret = vsyslog(LOG_INFO, format, ap);
-#endif
-	va_end(ap);
-#endif
-	return ret;
-}
-
-int rtw_printf_info(const char *format,...)
-{
-	va_list ap;
-	int ret = 0;
-	va_start(ap, format);
-#ifdef CONFIG_LOGM
-	ret = logm_internal(LOGM_NORMAL, LOGM_IDX, LOGM_INF, format, ap);
-#else
-	ret = vsyslog(LOG_INFO, format, ap);
-#endif
-	va_end(ap);
-	return ret;
-}
-
-const struct osdep_service_ops osdep_service = {
-	_tizenrt_malloc,			//rtw_vmalloc
-	_tizenrt_zmalloc,			//rtw_zvmalloc
-	_tizenrt_mfree,				//rtw_vmfree
-	_tizenrt_malloc,			//rtw_malloc
-	_tizenrt_zmalloc,			//rtw_zmalloc
-	_tizenrt_mfree,				//rtw_mfree
-	_tizenrt_memcpy,			//rtw_memcpy
-	_tizenrt_memcmp,			//rtw_memcmp
-	_tizenrt_memset,			//rtw_memset
-	_tizenrt_init_sema,			//rtw_init_sema
-	_tizenrt_free_sema,			//rtw_free_sema
-	_tizenrt_up_sema,			//rtw_up_sema
-	_tizenrt_up_sema_from_isr,	//rtw_up_sema_from_isr
-	_tizenrt_down_sema,			//rtw_down_sema
-	_tizenrt_mutex_init,		//rtw_mutex_init
-	_tizenrt_mutex_free,		//rtw_mutex_free
-	_tizenrt_mutex_get,			//rtw_mutex_get
-	_tizenrt_mutex_get_timeout,	//rtw_mutex_get_timeout
-	_tizenrt_mutex_put,			//rtw_mutex_put
-	_tizenrt_enter_critical,	//rtw_enter_critical
-	_tizenrt_exit_critical,		//rtw_exit_critical
-	_tizenrt_enter_critical_from_isr,	//rtw_enter_critical_from_isr
-	_tizenrt_exit_critical_from_isr,	//rtw_exit_critical_from_isr
-	NULL,						//rtw_enter_critical_bh
-	NULL,						//rtw_exit_critical_bh
-	_tizenrt_enter_critical_mutex,	//rtw_enter_critical_mutex
-	_tizenrt_exit_critical_mutex,	//rtw_exit_critical_mutex
-	_tizenrt_cpu_lock,
-	_tizenrt_cpu_unlock,
-	_tizenrt_spinlock_init,		//rtw_spinlock_init
-	_tizenrt_spinlock_free,		//rtw_spinlock_free
-	_tizenrt_spinlock,			//rtw_spin_lock
-	_tizenrt_spinunlock,		//rtw_spin_unlock
-	_tizenrt_spinlock_irqsave,	//rtw_spinlock_irqsave
-	_tizenrt_spinunlock_irqsave,	//rtw_spinunlock_irqsave
-	_tizenrt_init_xqueue,		//rtw_init_xqueue
-	_tizenrt_push_to_xqueue,	//rtw_push_to_xqueue
-	_tizenrt_pop_from_xqueue,	//rtw_pop_from_xqueue
-	_tizenrt_peek_from_xqueue,		//rtw_peek_from_xqueue
-	_tizenrt_deinit_xqueue,		//rtw_deinit_xqueue
-	_tizenrt_get_current_time,	//rtw_get_current_time
-	_tizenrt_systime_to_ms,		//rtw_systime_to_ms
-	_tizenrt_systime_to_sec,	//rtw_systime_to_sec
-	_tizenrt_ms_to_systime,		//rtw_ms_to_systime
-	_tizenrt_sec_to_systime,	//rtw_sec_to_systime
-	_tizenrt_msleep_os,			//rtw_msleep_os
-	_tizenrt_usleep_os,			//rtw_usleep_os
-	_tizenrt_mdelay_os,			//rtw_mdelay_os
-	_tizenrt_udelay_os,			//rtw_udelay_os
-	_tizenrt_yield_os,			//rtw_yield_os
-
-	_tizenrt_ATOMIC_SET,		//ATOMIC_SET
-	_tizenrt_ATOMIC_READ,		//ATOMIC_READ
-	_tizenrt_ATOMIC_ADD,		//ATOMIC_ADD
-	_tizenrt_ATOMIC_SUB,		//ATOMIC_SUB
-	_tizenrt_ATOMIC_INC,		//ATOMIC_INC
-	_tizenrt_ATOMIC_DEC,		//ATOMIC_DEC
-	_tizenrt_ATOMIC_ADD_RETURN,	//ATOMIC_ADD_RETURN
-	_tizenrt_ATOMIC_SUB_RETURN,	//ATOMIC_SUB_RETURN
-	_tizenrt_ATOMIC_INC_RETURN,	//ATOMIC_INC_RETURN
-	_tizenrt_ATOMIC_DEC_RETURN,	//ATOMIC_DEC_RETURN
-
-	_tizenrt_modular64,			//rtw_modular64
-	_tizenrt_get_random_bytes,	//rtw_get_random_bytes
-	_tizenrt_GetFreeHeapSize,	//rtw_getFreeHeapSize
-
-	_tizenrt_create_task,		//rtw_create_task
-	_tizenrt_delete_task,		//rtw_delete_task
-	NULL,			//rtw_wakeup_task
-	_tizenrt_set_priority_task,	//rtw_set_priority_task
-	_tizenrt_get_priority_task,	//rtw_get_priority_task
-	_tizenrt_suspend_task,			//rtw_suspend_task
-	_tizenrt_resume_task,			//rtw_resume_task
-	_tizenrt_suspend_task_all,		//rtw_suspend_task_all
-	_tizenrt_resume_task_all,		//rtw_resume_task_all
-
-	_tizenrt_thread_enter,		//rtw_thread_enter
-	_tizenrt_thread_exit,		//rtw_thread_exit
-
-	_tizenrt_timerCreate,		//rtw_timerCreate,
-	_tizenrt_timerDelete,		//rtw_timerDelete,
-	_tizenrt_timerIsTimerActive,	//rtw_timerIsTimerActive,
-	_tizenrt_timerStop,			//rtw_timerStop,
-	_tizenrt_timerChangePeriod,	//rtw_timerChangePeriod
-	_tizenrt_timerGetID,		//rtw_timerGetID
-	_tizenrt_timerStart,		//rtw_timerStart
-	_tizenrt_timerStartFromISR,	//rtw_timerStartFromISR
-	_tizenrt_timerStopFromISR,	//rtw_timerStopFromISR
-	_tizenrt_timerResetFromISR,	//rtw_timerResetFromISR
-	_tizenrt_timerChangePeriodFromISR,	//rtw_timerChangePeriodFromISR
-	_tizenrt_timerReset,		//rtw_timerReset
-
-	_tizenrt_acquire_wakelock,	//rtw_acquire_wakelock
-	_tizenrt_release_wakelock,	//rtw_release_wakelock
-	_tizenrt_wakelock_timeout,	//rtw_wakelock_timeout
-	_tizenrt_get_scheduler_state,	//rtw_get_scheduler_state
-	NULL,						// rtw_create_secure_context
-	NULL,						//rtw_get_current_TaskHandle
-};
diff --git a/os/board/rtl8720e/src/component/os/os_dep/Make.defs b/os/board/rtl8720e/src/component/os_dep/Make.defs
old mode 100644
new mode 100755
similarity index 81%
rename from os/board/rtl8720e/src/component/os/os_dep/Make.defs
rename to os/board/rtl8720e/src/component/os_dep/Make.defs
index 753b618a8..17afa0924
--- a/os/board/rtl8720e/src/component/os/os_dep/Make.defs
+++ b/os/board/rtl8720e/src/component/os_dep/Make.defs
@@ -36,7 +36,7 @@
 #
 # THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 # "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
-# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANT ABILITY AND FITNESS
+# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
 # FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
 # COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
 # INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
@@ -49,10 +49,19 @@
 #
 ############################################################################
 
-CSRCS += osdep_service.c \
-	 device_lock.c \
-	 timer_service.c \
-	 psram_reserve.c \
-	 
-DEPPATH += --dep-path component/os/os_dep
-VPATH += :component/os/os_dep
+CSRCS += osdep_service_atomic.c \
+         osdep_service_critical.c \
+         osdep_service_list.c \
+         osdep_service_memory.c \
+         osdep_service_misc.c \
+         osdep_service_mutex.c \
+         osdep_service_queue.c \
+         osdep_service_sem.c \
+         osdep_service_task.c \
+         osdep_service_time.c \
+         osdep_service_timer.c \
+         device_lock.c \
+         sram0_reserve.c \
+
+DEPPATH += --dep-path component/os_dep
+VPATH += :component/os_dep
diff --git a/os/board/rtl8720e/src/component/soc/amebalite/fwlib/include/basic_types.h b/os/board/rtl8720e/src/component/os_dep/basic_types.h
old mode 100644
new mode 100755
similarity index 85%
rename from os/board/rtl8720e/src/component/soc/amebalite/fwlib/include/basic_types.h
rename to os/board/rtl8720e/src/component/os_dep/basic_types.h
index 8c487d43c..d46ae9674
--- a/os/board/rtl8720e/src/component/soc/amebalite/fwlib/include/basic_types.h
+++ b/os/board/rtl8720e/src/component/os_dep/basic_types.h
@@ -19,9 +19,7 @@
  ******************************************************************************/
 #ifndef __BASIC_TYPES_H__
 #define __BASIC_TYPES_H__
-#include "platform_autoconf.h"
 
-//#define PLATFORM_FREERTOS
 #include <stdint.h>
 #include <stddef.h> /* for size_t */
 
@@ -39,6 +37,9 @@
 #undef _FAIL
 #define _FAIL		0
 
+#undef _PASS
+#define _PASS		1
+
 #ifndef FALSE
 #define FALSE   0
 #endif
@@ -94,31 +95,35 @@ typedef unsigned long long      __uint64_t;
 #define s64                     int64_t
 #define u64                     uint64_t
 
-#ifdef CONFIG_MBED_ENABLED
+typedef int8_t                  i8;
+typedef int16_t                 i16;
+typedef int32_t                 i32;
+
+typedef uint8_t __u8;
+typedef int8_t __s8;
+typedef uint16_t __u16;
+typedef int16_t __s16;
+typedef uint32_t __u32;
+typedef int32_t __s32;
+typedef	uint64_t __u64;
+typedef int64_t                 __s64;
+typedef int8_t                  __i8;
+typedef int16_t                 __i16;
+typedef int32_t                 __i32;
+
+
 #ifndef BOOL
 typedef unsigned char           BOOL;
 #endif
+#ifndef __cplusplus
 #ifndef bool
 typedef unsigned char           bool;
 #endif
-#else
-#ifndef BOOL
-typedef unsigned char           BOOL;
-#endif
-#ifdef __cplusplus
-#else
-#ifndef bool
-typedef unsigned char           bool;
 #endif
-#endif
-#endif
-
-typedef uint8_t UCHAR;
-typedef uint16_t USHORT;
-typedef uint32_t UINT;
-typedef uint32_t ULONG;
 
-//typedef struct { volatile int counter; } atomic_t;
+#ifndef boolean
+#define boolean				bool
+#endif
 
 typedef enum _RTK_STATUS_ {
 	_EXIT_SUCCESS = 0,
@@ -139,6 +144,7 @@ typedef void *PVOID;
 typedef     u32 dma_addr_t;
 
 typedef     void (*proc_t)(void *);
+
 #ifndef CONFIG_PLATFORM_TIZENRT_OS
 typedef     unsigned int __kernel_size_t;
 #endif
@@ -170,6 +176,13 @@ typedef	    __kernel_ssize_t	SSIZE_T;
 #define   DISABLE   0
 #endif
 
+#ifndef SET_NS_STATE
+#define   SET_NS_STATE   (1)
+#endif
+
+#ifndef SET_S_STATE
+#define   SET_S_STATE    (0)
+#endif
 
 #ifndef BIT0
 #define BIT0	0x0001
@@ -212,7 +225,21 @@ typedef	    __kernel_ssize_t	SSIZE_T;
 #define BIT(__n)       (1U<<(__n))
 #endif
 
-#if defined (__ICCARM__)
+#if   defined ( __CC_ARM )                                            /* ARM Compiler 4/5 */
+#define SECTION(_name)      __attribute__ ((__section__(_name)))
+#define ALIGNMTO(_bound)    __attribute__ ((aligned (_bound)))
+#define _PACKED_            __attribute__ ((packed))
+#define _LONG_CALL_
+#define _WEAK               __attribute__ ((weak))
+#define __NO_INLINE         __attribute__ ((noinline))
+#elif defined (__ARMCC_VERSION) && (__ARMCC_VERSION >= 6010050)       /* ARM Compiler 6 */
+#define SECTION(_name)      __attribute__ ((__section__(_name)))
+#define ALIGNMTO(_bound)    __attribute__ ((aligned (_bound)))
+#define _PACKED_            __attribute__ ((packed))
+#define _LONG_CALL_
+#define _WEAK               __attribute__ ((weak))
+#define __NO_INLINE         __attribute__ ((noinline))
+#elif defined( __ICCARM__ )
 #define STRINGIFY(s) #s
 #define SECTION(_name) _Pragma( STRINGIFY(location=_name))
 #define ALIGNMTO(_bound) _Pragma( STRINGIFY(data_alignment=_bound))
@@ -221,11 +248,12 @@ typedef	    __kernel_ssize_t	SSIZE_T;
 #define _WEAK          __weak
 #define _OPTIMIZE_NONE_           _Pragma( STRINGIFY(optimize=none))
 #define UNUSED_WARN_DIS
+#define __NO_INLINE     __declspec (noinline)
 #else
 #define SECTION(_name) __attribute__ ((__section__(_name)))
 #define ALIGNMTO(_bound) __attribute__ ((aligned (_bound)))
 #define _PACKED_       __attribute__ ((packed))
-#ifdef CONFIG_TOOLCHAIN_VSDK
+#if defined (RISC_V)
 #define _LONG_CALL_
 #else
 #define _LONG_CALL_     __attribute__ ((long_call))
@@ -233,13 +261,9 @@ typedef	    __kernel_ssize_t	SSIZE_T;
 #define _WEAK           __attribute__ ((weak))
 #define _OPTIMIZE_NONE_           __attribute__ ((optimize("O0")))
 #define UNUSED_WARN_DIS	__attribute__((unused))
+#define __NO_INLINE         __attribute__ ((noinline))
 #endif
 
-
-
-//port from fw by thomas
-// TODO: Belows are Sync from SD7-Driver. It is necessary to check correctness
-
 #define SWAP32(x) ((u32)(                         \
  			(((u32)(x) & (u32)0x000000ff) << 24) |            \
  			(((u32)(x) & (u32)0x0000ff00) <<  8) |            \
@@ -293,19 +317,20 @@ typedef	    __kernel_ssize_t	SSIZE_T;
 //
 // Read LE format data from memory
 //
-#if defined (RSICV_CORE_KR4)
-#define ReadEF1Byte(_ptr)			EF1Byte(*((u8 *)(_ptr)))
-#define ReadEF2Byte(_ptr)			(ReadEF1Byte(_ptr) | (ReadEF1Byte((u32)(_ptr) + 1) << 8))
-#define ReadEF4Byte(_ptr)			(ReadEF2Byte(_ptr) | (ReadEF2Byte((u32)(_ptr) + 2) << 16))
+#if defined (RISC_V)
+#define ReadEF1Byte(_ptr)		EF1Byte(*((u8 *)(_ptr)))
+#define ReadEF2Byte(_ptr)		(ReadEF1Byte(_ptr) | (ReadEF1Byte((u32)(_ptr) + 1) << 8))
+#define ReadEF4Byte(_ptr)		(ReadEF2Byte(_ptr) | (ReadEF2Byte((u32)(_ptr) + 2) << 16))
 #else
-#define ReadEF1Byte(_ptr)			EF1Byte(*((u8 *)(_ptr)))
-#define ReadEF2Byte(_ptr)			EF2Byte(*((u16 *)(_ptr)))
-#define ReadEF4Byte(_ptr)			EF4Byte(*((u32 *)(_ptr)))
+#define ReadEF1Byte(_ptr)		EF1Byte(*((u8 *)(_ptr)))
+#define ReadEF2Byte(_ptr)		EF2Byte(*((u16 *)(_ptr)))
+#define ReadEF4Byte(_ptr)		EF4Byte(*((u32 *)(_ptr)))
 #endif
+
 //
 // Write LE data to memory
 //
-#if defined (RSICV_CORE_KR4)
+#if defined (RISC_V)
 #define WriteEF1Byte(_ptr, _val)	(*((u8 *)(_ptr)))=EF1Byte(_val)
 #define WriteEF2Byte(_ptr, _val)	do {WriteEF1Byte(_ptr, _val); WriteEF1Byte(((u32)(_ptr) + 1), ((_val) >> 8));} while(0)
 #define WriteEF4Byte(_ptr, _val)	do {WriteEF2Byte(_ptr, _val); WriteEF2Byte(((u32)(_ptr) + 2), ((_val) >> 16));} while(0)
@@ -374,7 +399,6 @@ typedef	    __kernel_ssize_t	SSIZE_T;
 			| ( (((u32)(__Value)) & BIT_LEN_MASK_32(__BitLen)) << (__BitOffset) ) ) \
 			)
 
-
 #define BIT_LEN_MASK_16(__BitLen) \
 		(0xFFFF >> (16 - (__BitLen)))
 
@@ -404,6 +428,7 @@ typedef	    __kernel_ssize_t	SSIZE_T;
 			| ( (((u16)__Value) & BIT_LEN_MASK_16(__BitLen)) << (__BitOffset) )) \
 		)
 
+
 #define BIT_LEN_MASK_8(__BitLen) \
 		(0xFF >> (8 - (__BitLen)))
 
@@ -444,11 +469,11 @@ typedef	    __kernel_ssize_t	SSIZE_T;
 //pclint
 #define SET_BITS_TO_LE_1BYTE_8BIT(__pStart, __BitOffset, __BitLen, __Value) \
 { \
-	*((pu1Byte)(__pStart)) = \
+	*((u8 *)(__pStart)) = \
 		EF1Byte( \
 			LE_BITS_CLEARED_TO_1BYTE_8BIT(__pStart, __BitOffset, __BitLen) \
 			| \
-			((u1Byte)__Value) \
+			((u8)__Value) \
 		); \
 }
 
@@ -471,7 +496,7 @@ typedef unsigned char	BOOLEAN, *PBOOLEAN;
 #if defined ( __ICCARM__ )
 #define __inline__                      inline
 #define __inline                        inline
-#define __inline_definition			//In dialect C99, inline means that a function's definition is provided
+#define __inline_definition			//In dialect C99, inline means that a function's definition is provided 
 //only for inlining, and that there is another definition
 //(without inline) somewhere else in the program.
 //That means that this program is incomplete, because if
@@ -526,46 +551,4 @@ typedef unsigned char	BOOLEAN, *PBOOLEAN;
 #define	__restrict			/* Ignore */
 #endif
 
-#if defined (__ARM_FEATURE_CMSE)
-#ifdef __ICCARM__
-#define NS_ENTRY    __attribute__((cmse_nonsecure_entry))
-#else
-#define NS_ENTRY    __attribute__((cmse_nonsecure_entry))
-#endif
-#if defined (ARM_CORE_CM4)
-#ifdef __ICCARM__
-typedef __cmse_nonsecure_call void nsfunc(void);
-#else
-typedef void __attribute__((cmse_nonsecure_call)) nsfunc(void);
-#endif
-#endif
-#endif
-
-typedef struct {
-	void (*rdp_decrypt_func)(u32 addr, u8 *key, u8  cnt, u8 *buf);
-	u32 psram_s_start_addr;
-} BOOT_EXPORT_SYMB_TABLE;
-
-typedef struct {
-	VOID (*RamStartFun)(VOID);
-	VOID (*RamWakeupFun)(VOID);
-	u32 VectorNS;
-} RAM_START_FUNCTION, *PRAM_START_FUNCTION;
-
-typedef struct _RAM_FUNCTION_START_TABLE_ {
-	VOID (*RamStartFun)(VOID);
-	VOID (*RamWakeupFun)(VOID);
-	VOID (*RamPatchFun0)(VOID);
-	VOID (*RamPatchFun1)(VOID);
-	VOID (*RamPatchFun2)(VOID);
-	VOID (*FlashStartFun)(VOID);
-	u32 Img1ValidCode;
-	BOOT_EXPORT_SYMB_TABLE *ExportTable;
-} RAM_FUNCTION_START_TABLE, *PRAM_FUNCTION_START_TABLE;
-
-typedef struct _DSLP_RETENTION_FUNC_TABLE_ {
-	VOID (*DSLPPatchFun0)(VOID);
-	u32	PatchLen;
-} DSLP_RETENTION_FUNC_TABLE, *PDSLP_RETENTION_FUNC_TABLE;
-
 #endif// __BASIC_TYPES_H__
diff --git a/os/board/rtl8720e/src/component/os/os_dep/device_lock.c b/os/board/rtl8720e/src/component/os_dep/device_lock.c
old mode 100644
new mode 100755
similarity index 100%
rename from os/board/rtl8720e/src/component/os/os_dep/device_lock.c
rename to os/board/rtl8720e/src/component/os_dep/device_lock.c
diff --git a/os/board/rtl8720e/src/component/os/os_dep/include/device_lock.h b/os/board/rtl8720e/src/component/os_dep/device_lock.h
old mode 100644
new mode 100755
similarity index 100%
rename from os/board/rtl8720e/src/component/os/os_dep/include/device_lock.h
rename to os/board/rtl8720e/src/component/os_dep/device_lock.h
diff --git a/os/board/rtl8720e/src/component/stdlib/dlist.h b/os/board/rtl8720e/src/component/os_dep/dlist.h
old mode 100644
new mode 100755
similarity index 100%
rename from os/board/rtl8720e/src/component/stdlib/dlist.h
rename to os/board/rtl8720e/src/component/os_dep/dlist.h
diff --git a/os/board/rtl8720e/src/component/stdlib/gcc_wrap.c b/os/board/rtl8720e/src/component/os_dep/gcc_wrap.c
old mode 100644
new mode 100755
similarity index 100%
rename from os/board/rtl8720e/src/component/stdlib/gcc_wrap.c
rename to os/board/rtl8720e/src/component/os_dep/gcc_wrap.c
diff --git a/os/board/rtl8720e/src/component/os/tizenrt/tizenrt_service.h b/os/board/rtl8720e/src/component/os_dep/osdep_service.h
old mode 100644
new mode 100755
similarity index 85%
rename from os/board/rtl8720e/src/component/os/tizenrt/tizenrt_service.h
rename to os/board/rtl8720e/src/component/os_dep/osdep_service.h
index de695af9a..1faa917fc
--- a/os/board/rtl8720e/src/component/os/tizenrt/tizenrt_service.h
+++ b/os/board/rtl8720e/src/component/os_dep/osdep_service.h
@@ -13,13 +13,32 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  ******************************************************************************/
-#ifndef _CUSTOMER_RTOS_SERVICE_H_
-#define _CUSTOMER_RTOS_SERVICE_H_
 
-//----- ------------------------------------------------------------------
-// Include Files
-//----- ------------------------------------------------------------------
+#ifndef __OSDEP_SERVICE_H_
+#define __OSDEP_SERVICE_H_
+
+#if defined(CONFIG_PLATFORM_8735B)
+#include <platform_conf.h>
+#include <basic_types.h>
+
+#if defined(__GNUC__)
+#include <cmsis_gcc.h>	// for __get_xPSR()
+#endif
+#else
+#include "platform_autoconf.h"
+#endif
 
+#define OSDEP_DBG(x, ...) do {} while(0)
+#if defined(PLATFORM_ALIOS)
+#include "alios_service.h"
+#elif defined(PLATFORM_ECOS)
+#include "ecos/ecos_service.h"
+#elif defined(PLATFORM_CMSIS_RTOS)
+#include "cmsis_rtos_service.h"
+#elif defined(CONFIG_PLATFOMR_CUSTOMER_RTOS)
+#include "customer_rtos_service.h"
+#endif
+/////////////////////////////////////////////////////////////TizenRT service header start
 #include "dlist.h"
 
 #include <queue.h>
@@ -321,4 +340,38 @@ extern u32 random_seed;
 
 #define configSUPPORT_STATIC_ALLOCATION					0
 
-#endif							/* _CUSTOMER_RTOS_SERVICE_H_ */
+/////////////////////////////////////////////////////////////TizenRT service header end
+
+#if defined(CONFIG_PLATFORM_TIZENRT_OS)
+#define USE_PTHREAD_MUTEX 0		//todo
+#endif
+
+// #include "dlist.h"
+// #include "FreeRTOS.h"
+// #include "task.h"
+// #include "event_groups.h"
+// #include "semphr.h"
+// #include "queue.h"
+// #include "timers.h"
+// #include "platform_stdlib.h"
+#include <stdio.h>
+#include <tinyara/sched.h>
+#include "../../../kernel/sched/sched.h"
+#include "basic_types.h"
+#include <ameba_vector.h>
+#include <ameba.h>
+
+#include "osdep_service_atomic.h"
+#include "osdep_service_critical.h"
+#include "osdep_service_list.h"
+#include "osdep_service_memory.h"
+#include "osdep_service_misc.h"
+#include "osdep_service_mutex.h"
+#include "osdep_service_queue.h"
+#include "osdep_service_sem.h"
+#include "osdep_service_task.h"
+#include "osdep_service_time.h"
+#include "osdep_service_timer.h"
+
+#endif	//#ifndef __OSDEP_SERVICE_H_
+
diff --git a/os/board/rtl8720e/src/component/os_dep/osdep_service_atomic.c b/os/board/rtl8720e/src/component/os_dep/osdep_service_atomic.c
new file mode 100755
index 000000000..9c715e973
--- /dev/null
+++ b/os/board/rtl8720e/src/component/os_dep/osdep_service_atomic.c
@@ -0,0 +1,112 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2012 Realtek Corporation. All rights reserved.
+ *
+ ******************************************************************************/
+// #include <FreeRTOS.h>
+#include <osdep_service.h>
+#include <stdio.h>
+#include <freertos_pmu.h>
+
+void ATOMIC_SET(ATOMIC_T *v, int i)
+{
+#if defined(STDATOMIC)
+	atomic_store(v, i);
+#else
+	atomic_set(v, i);
+#endif
+}
+
+int ATOMIC_READ(ATOMIC_T *v)
+{
+#if defined(STDATOMIC)
+	return atomic_load(v);
+#else
+	return atomic_read(v);
+#endif
+}
+
+void ATOMIC_ADD(ATOMIC_T *v, int i)
+{
+#if defined(STDATOMIC)
+	atomic_fetch_add(v, i);
+#else
+	unsigned int irq_flags = save_and_cli();
+	v->counter += i;
+	restore_flags(irq_flags);
+#endif
+}
+
+void ATOMIC_SUB(ATOMIC_T *v, int i)
+{
+#if defined(STDATOMIC)
+	atomic_fetch_sub(v, i);
+#else
+	unsigned int irq_flags = save_and_cli();
+	v->counter -= i;
+	restore_flags(irq_flags);
+#endif
+}
+
+void ATOMIC_INC(ATOMIC_T *v)
+{
+	ATOMIC_ADD(v, 1);
+}
+
+void ATOMIC_DEC(ATOMIC_T *v)
+{
+	ATOMIC_SUB(v, 1);
+}
+
+int ATOMIC_ADD_RETURN(ATOMIC_T *v, int i)
+{
+#if defined(STDATOMIC)
+	atomic_fetch_add(v, i);
+	return atomic_load(v);
+#else
+	int temp;
+
+	unsigned int irq_flags = save_and_cli();
+	temp = v->counter;
+	temp += i;
+	v->counter = temp;
+	restore_flags(irq_flags);
+
+	return temp;
+#endif
+}
+
+int ATOMIC_SUB_RETURN(ATOMIC_T *v, int i)
+{
+#if defined(STDATOMIC)
+	atomic_fetch_sub(v, i);
+	return atomic_load(v);
+#else
+	int temp;
+
+	unsigned int irq_flags = save_and_cli();
+	temp = v->counter;
+	temp -= i;
+	v->counter = temp;
+	restore_flags(irq_flags);
+
+	return temp;
+#endif
+}
+
+int ATOMIC_INC_RETURN(ATOMIC_T *v)
+{
+	return ATOMIC_ADD_RETURN(v, 1);
+}
+
+int ATOMIC_DEC_RETURN(ATOMIC_T *v)
+{
+	return ATOMIC_SUB_RETURN(v, 1);
+}
+
+int ATOMIC_DEC_AND_TEST(ATOMIC_T *v)
+{
+	return ATOMIC_DEC_RETURN(v) == 0;
+}
+
+
diff --git a/os/board/rtl8720e/src/component/os_dep/osdep_service_atomic.h b/os/board/rtl8720e/src/component/os_dep/osdep_service_atomic.h
new file mode 100755
index 000000000..91f1d5362
--- /dev/null
+++ b/os/board/rtl8720e/src/component/os_dep/osdep_service_atomic.h
@@ -0,0 +1,172 @@
+/******************************************************************************
+ * Copyright (c) 2013-2016 Realtek Semiconductor Corp.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ ******************************************************************************/
+
+#ifndef __OSDEP_SERVICE_ATOMIC_H_
+#define __OSDEP_SERVICE_ATOMIC_H_
+
+#if defined(CONFIG_PLATFORM_8735B)
+// experimental feature, use stdatomic to replace customized defined atomic
+#define STDATOMIC
+
+#if (CONFIG_CMSIS_FREERTOS_EN==1)
+#define PLATFORM_FREERTOS 1
+#endif
+#endif
+
+#if defined(STDATOMIC)
+//#include <stdatomic.h>
+#ifndef __cplusplus
+#include <stdatomic.h>
+#define ATOMIC_T atomic_int
+#define atomic_t atomic_int
+#else
+#include <atomic>
+#define _Atomic(X) std::atomic< X >
+#define ATOMIC_T std::atomic_int
+#define atomic_t std::atomic_int
+#endif
+
+#undef atomic_read
+#define atomic_read(v)  atomic_load(v)
+#undef atomic_set
+#define atomic_set(v,i) atomic_store(v, i)
+#else
+
+/* old implement */
+// typedef struct {
+// 	volatile int counter;
+// } atomic_t;
+
+// #define ATOMIC_T atomic_t
+
+//----- ------------------------------------------------------------------
+// Atomic Operation
+//----- ------------------------------------------------------------------
+
+/*
+ * atomic_read - read atomic variable
+ * @v: pointer of type atomic_t
+ *
+ * Atomically reads the value of @v.  Note that the guaranteed
+ * useful range of an atomic_t is only 24 bits.
+ */
+#undef atomic_read
+#define atomic_read(v)  ((v)->counter)
+
+/*
+ * atomic_set - set atomic variable
+ * @v: pointer of type atomic_t
+ * @i: required value
+ *
+ * Atomically sets the value of @v to @i.  Note that the guaranteed
+ * useful range of an atomic_t is only 24 bits.
+ */
+#undef atomic_set
+#define atomic_set(v,i) ((v)->counter = (i))
+#endif
+
+#define GFP_ATOMIC			1
+
+
+
+/*************************** ATOMIC Integer *******************************/
+
+/**
+ * @brief  This function atomically sets the value of the variable.
+ * @param[in] v: Pointer of type atomic_t that to be set value.
+ * @param[in] i: Required value.
+ * @return	  None
+ * @note    The guaranteed useful range of an atomic_t is only 24 bits.
+*/
+void 	ATOMIC_SET(ATOMIC_T *v, int i);
+
+/**
+ * @brief  This function atomically reads the value of the variable.
+ * @param[in] v: Pointer of type atomic_t that to be read.
+ * @return	  The value of the variable.
+ * @note	The guaranteed useful range of an atomic_t is only 24 bits.
+*/
+int		ATOMIC_READ(ATOMIC_T *v);
+
+/**
+ * @brief  This function adds "i" to the contained "v".
+ * @param[in] v: Pointer of type atomic_t.
+ * @param[in] i: value to add.
+ * @return	  None
+*/
+void 	ATOMIC_ADD(ATOMIC_T *v, int i);
+
+/**
+ * @brief  This function subtracts "i" from th econtained "v".
+ * @param[in] v: Pointer of type atomic_t.
+ * @param[in] i: value to subtract.
+ * @return	  None
+*/
+void 	ATOMIC_SUB(ATOMIC_T *v, int i);
+
+/**
+ * @brief  This function adds 1 to the contained "v".
+ * @param[in] v: Pointer of type atomic_t.
+ * @return	  None
+*/
+void 	ATOMIC_INC(ATOMIC_T *v);
+
+/**
+ * @brief  This function subtracts 1 from th econtained "v".
+ * @param[in] v: Pointer of type atomic_t.
+ * @return	  None
+*/
+void 	ATOMIC_DEC(ATOMIC_T *v);
+
+/**
+ * @brief  This function adds "i" to the contained "v" and returns the result.
+ * @param[in] v: Pointer of type atomic_t.
+ * @param[in] i: value to add.
+ * @return	  None
+*/
+int 	ATOMIC_ADD_RETURN(ATOMIC_T *v, int i);
+
+/**
+ * @brief  This function subtracts "i" from th econtained "v" and returns the result.
+ * @param[in] v: Pointer of type atomic_t.
+ * @param[in] i: value to subtract.
+ * @return	  None
+*/
+int 	ATOMIC_SUB_RETURN(ATOMIC_T *v, int i);
+
+/**
+ * @brief  This function adds 1 to the contained "v" and returns the result.
+ * @param[in] v: Pointer of type atomic_t.
+ * @return	  None
+*/
+int 	ATOMIC_INC_RETURN(ATOMIC_T *v);
+
+/**
+ * @brief  This function subtracts 1 from th econtained "v" and returns the result.
+ * @param[in] v: Pointer of type atomic_t.
+ * @return	  None
+*/
+int 	ATOMIC_DEC_RETURN(ATOMIC_T *v);
+
+/**
+ * @brief  This function subtracts 1 from th econtained "v" and test if the result equals 0.
+ * @param[in] v: Pointer of type atomic_t.
+ * @return	  0: The result after subtracting 1 is 0
+ * @return	 -1: The result after subtracting 1 is not 0
+*/
+int ATOMIC_DEC_AND_TEST(ATOMIC_T *v);
+/*************************** End ATOMIC *******************************/
+#endif
diff --git a/os/board/rtl8720e/src/component/os_dep/osdep_service_critical.c b/os/board/rtl8720e/src/component/os_dep/osdep_service_critical.c
new file mode 100755
index 000000000..ede8f51c7
--- /dev/null
+++ b/os/board/rtl8720e/src/component/os_dep/osdep_service_critical.c
@@ -0,0 +1,181 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2012 Realtek Corporation. All rights reserved.
+ *
+ ******************************************************************************/
+// #include <FreeRTOS.h>
+// #include <semphr.h>
+#include <osdep_service.h>
+#include <stdio.h>
+#include <freertos_pmu.h>
+
+#ifndef configNUM_CORES
+#define configNUM_CORES			1
+#define portGET_CORE_ID()			0
+#endif
+
+#if 1 //Justin: temporary solution for enter critical code for tizenRT
+static irqstate_t initial_tizen_flags, up_tizen_flag;
+static int flagcnt = 0;
+#endif
+
+#if 1 //Justin: temporary solution for enter critical code for tizenRT
+void save_and_cli_temp(void);
+void restore_flags_temp(void);
+void save_and_cli_temp()
+{
+	if(flagcnt){
+		up_tizen_flag = irqsave();
+	}else{
+		initial_tizen_flags = irqsave();
+	}
+	flagcnt++;
+}
+
+void restore_flags_temp()
+{
+	flagcnt--;
+	if(flagcnt){
+		irqrestore(up_tizen_flag);
+	}else{
+		irqrestore(initial_tizen_flags);
+	}
+}
+#endif
+
+void rtw_enter_critical(_lock *plock, _irqL *pirqL)
+{
+	/* To avoid gcc warnings */
+	(void) pirqL;
+	(void) plock;
+
+	if (rtw_in_interrupt()) {
+		DBG_INFO("\n");
+	} else {
+#if 1 //temporary solution for enter critical code for tizenRT
+		save_and_cli_temp();
+#else 
+	//printf("\n"); //suppress meaningless printout
+#endif
+	}
+}
+
+void rtw_exit_critical(_lock *plock, _irqL *pirqL)
+{
+	/* To avoid gcc warnings */
+	(void) pirqL;
+	(void) plock;
+
+	if (rtw_in_interrupt()) {
+		DBG_INFO("\n");
+	} else {
+#if 1 //temporary solution for enter critical code for tizenRT
+		restore_flags_temp();
+#else 
+	//printf("\n"); //suppress meaningless printout
+#endif
+	}
+}
+
+void rtw_enter_critical_bh(_lock *plock, _irqL *pirqL)
+{
+	/* To avoid gcc warnings */
+	(void) pirqL;
+	rtw_spin_lock(plock);
+}
+
+void rtw_exit_critical_bh(_lock *plock, _irqL *pirqL)
+{
+	/* To avoid gcc warnings */
+	(void) pirqL;
+
+	rtw_spin_unlock(plock);
+}
+
+int rtw_enter_critical_mutex(_mutex *pmutex, _irqL *pirqL)
+{
+	int temp;
+	temp = sem_wait(*pmutex);
+	if (temp != 0) {
+		DBG_ERR("Failed!\n");
+	}
+	return temp;
+}
+
+void rtw_exit_critical_mutex(_mutex *pmutex, _irqL *pirqL)
+{
+	sem_post(*pmutex);
+}
+
+void rtw_cpu_lock(void)
+{
+	printf("Not implement osdep service: rtw_cpu_lock");
+}
+
+void rtw_cpu_unlock(void)
+{
+	printf("Not implement osdep service: rtw_cpu_unlock");
+}
+
+
+void rtw_spinlock_init(_lock *plock)
+{
+	if (*plock == NULL) {
+		*plock = kmm_zalloc(sizeof(sem_t));
+		if (*plock == NULL) {
+			DBG_ERR("Failed\n");
+			return;
+		}
+#ifdef CONFIG_DEBUG_MM_HEAPINFO
+		DEBUG_SET_CALLER_ADDR(*plock);
+#endif
+	}
+	sem_init(*plock, 0, 1);
+	sem_setprotocol(*plock, SEM_PRIO_NONE);
+}
+
+
+void rtw_spinlock_free(_lock *plock)
+{
+	int i;
+	if (*plock != NULL) {
+		i = sem_destroy(*plock);
+		if (i == 0) {
+			kmm_free(*plock);
+		} else {
+			DBG_ERR("Fail!!!\n");
+		}
+	}
+	*plock = NULL;
+}
+
+
+void rtw_spin_lock(_lock *plock)
+{
+	int temp;
+	temp = sem_wait(*plock);
+	if (temp != 0) {
+		DBG_ERR("Failed!\n");
+	}
+}
+
+void rtw_spin_unlock(_lock *plock)
+{
+	sem_post(*plock);
+}
+
+unsigned int save_and_cli(void)
+{
+	return irqsave();
+}
+
+void restore_flags(unsigned int flag)
+{
+	irqrestore(flag);
+}
+
+void cli()
+{
+}
+
+
diff --git a/os/board/rtl8720e/src/component/os_dep/osdep_service_critical.h b/os/board/rtl8720e/src/component/os_dep/osdep_service_critical.h
new file mode 100755
index 000000000..3a05de486
--- /dev/null
+++ b/os/board/rtl8720e/src/component/os_dep/osdep_service_critical.h
@@ -0,0 +1,131 @@
+/******************************************************************************
+ * Copyright (c) 2013-2016 Realtek Semiconductor Corp.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ ******************************************************************************/
+
+#ifndef __OSDEP_SERVICE_CRITICAL_H_
+#define __OSDEP_SERVICE_CRITICAL_H_
+
+#include "osdep_service_mutex.h"
+
+typedef void	            *_lock;
+typedef unsigned long		_irqL;
+
+/*************************** SchedulerControl *******************************/
+/**
+ * @brief  This function marks the start of a critical code region.
+ * 		   Preemptive context switches cannot occur when in a critical region.
+ * @param[in] plock: Pointer to the spin lock semaphore.
+ * @param[in] pirqL: Pointer to the IRQ.
+ * @return	  None
+ * @note: This may alter the stack (depending on the portable implementation)
+ * so must be used with care!
+ */
+void	rtw_enter_critical(_lock *plock, _irqL *pirqL);
+
+/**
+ * @brief  This function marks end of a critical code region. Preemptive context
+ * switches cannot occur when in a critical region.
+ * @param[in] plock: Pointer to the spin lock semaphore.
+ * @param[in] pirqL: Pointer to the IRQ.
+ * @return	  None
+ * @note: This may alter the stack (depending on the portable implementation)
+ * so must be used with care!
+ */
+void	rtw_exit_critical(_lock *plock, _irqL *pirqL);
+
+/**
+ * @brief  This function obtains a spin lock semaphore.
+ * @param[in] plock: Pointer to the spin lock semaphore being taken - obtained when
+ *			  the mutex semaphore was created.
+ * @param[in] pirqL: Pointer to the IRQ.
+ * @return	  None
+ */
+void	rtw_enter_critical_bh(_lock *plock, _irqL *pirqL);
+
+/**
+ * @brief  This function releases a spin lock semaphore.
+ * @param[in] plock: Pointer to the spin lock semaphore to be released.
+ * @param[in] pirqL: Pointer to the IRQ.
+ * @return	  None
+ */
+void	rtw_exit_critical_bh(_lock *plock, _irqL *pirqL);
+
+/**
+ * @brief  This function obtains a semaphore.
+ * @param[in] pmutex: The handle to the mutex semaphore to be obtained.
+ * @param[in] pirqL: Pointer to the IRQ.
+ * @return	  None
+ */
+int		rtw_enter_critical_mutex(_mutex *pmutex, _irqL *pirqL);
+
+/**
+ * @brief  This function releases a semaphore.
+ * @param[in] pmutex: The handle to the mutex semaphore to be released.
+ * @param[in] pirqL: Pointer to the IRQ.
+ * @return	  None
+ */
+void	rtw_exit_critical_mutex(_mutex *pmutex, _irqL *pirqL);
+
+/**
+ * @brief  This function will lock cpu. Can be used when xip active and want to do some flash operation.
+ * @return	  None
+ */
+void	rtw_cpu_lock(void);
+
+/**
+* @brief  This function unlock cpu.
+* @return	  None
+*/
+void	rtw_cpu_unlock(void);
+
+/*************************** End SchedulerControl *******************************/
+
+/*************************** Semaphores *******************************/
+
+/**
+ * @brief  This function implements a spin lock semaphore by using the existing queue mechanism.
+ * @param[in] plock: Pointer to the created spin lock semaphore.
+ * @return	  None
+ */
+void	rtw_spinlock_init(_lock *plock);
+
+/**
+ * @brief  This function deletes the spin lock semaphore.
+ * @param[in] pmutex: Pointer to the spin lock semaphore to be deleted.
+ * @return	  None
+ */
+void	rtw_spinlock_free(_lock *plock);
+
+/**
+ * @brief  This function obtains a spin lock semaphore.
+ * @param[in] plock: Pointer to the spin lock semaphore being taken - obtained when
+ *			  the mutex semaphore was created.
+ * @return	  None
+ */
+void	rtw_spin_lock(_lock *plock);
+
+/**
+ * @brief  This function releases a spin lock semaphore.
+ * @param[in] plock: Pointer to the spin lock semaphore to be released.
+ * @return	  None
+ */
+void	rtw_spin_unlock(_lock *plock);
+
+/*************************** End Semaphores *******************************/
+
+// void save_and_cli(void);
+// void restore_flags(void);
+// void cli(void);
+#endif
diff --git a/os/board/rtl8720e/src/component/os_dep/osdep_service_list.c b/os/board/rtl8720e/src/component/os_dep/osdep_service_list.c
new file mode 100755
index 000000000..e6185d0a7
--- /dev/null
+++ b/os/board/rtl8720e/src/component/os_dep/osdep_service_list.c
@@ -0,0 +1,49 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2012 Realtek Corporation. All rights reserved.
+ *
+ ******************************************************************************/
+// #include <FreeRTOS.h>
+#include <osdep_service.h>
+#include <stdio.h>
+#include <freertos_pmu.h>
+
+void rtw_init_listhead(_list *list)
+{
+	INIT_LIST_HEAD(list);
+}
+
+/*
+For the following list_xxx operations,
+caller must guarantee the atomic context.
+Otherwise, there will be racing condition.
+*/
+u32 rtw_is_list_empty(_list *phead)
+{
+	if (list_empty(phead)) {
+		return _TRUE;
+	}
+
+	return _FALSE;
+}
+
+void rtw_list_insert_head(_list *plist, _list *phead)
+{
+	list_add(plist, phead);
+}
+
+void rtw_list_insert_tail(_list *plist, _list *phead)
+{
+	list_add_tail(plist, phead);
+}
+
+/*
+
+Caller must check if the list is empty before calling rtw_list_delete
+
+*/
+void rtw_list_delete(_list *plist)
+{
+	list_del_init(plist);
+}
+
diff --git a/os/board/rtl8720e/src/component/os_dep/osdep_service_list.h b/os/board/rtl8720e/src/component/os_dep/osdep_service_list.h
new file mode 100755
index 000000000..82d68a1ef
--- /dev/null
+++ b/os/board/rtl8720e/src/component/os_dep/osdep_service_list.h
@@ -0,0 +1,84 @@
+/******************************************************************************
+ * Copyright (c) 2013-2016 Realtek Semiconductor Corp.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ ******************************************************************************/
+
+#ifndef __OSDEP_SERVICE_LIST_H_
+#define __OSDEP_SERVICE_LIST_H_
+
+
+// struct	__queue	{
+// 	struct	list_head	queue;
+// 	_lock			lock;
+// };
+
+// typedef struct	__queue		_queue;
+// typedef struct	list_head	_list;
+
+/*************************** List *******************************/
+
+/**
+ * @brief  This function initializes the head of the list.
+ * @param[in] list: Pointer to the list to be initialized.
+ * @return	  None
+ */
+void	rtw_init_listhead(_list *list);
+
+/**
+ * @brief  This function tests whether a list is empty.
+ * @param[in] phead: Pointer to the list to test.
+ * @return	  _TRUE/_FALSE
+ */
+uint32_t	rtw_is_list_empty(_list *phead);
+
+/**
+ * @brief  This function adds a new entry after "phead" for the list.
+ * @param[in] plist: Pointer to the list to be added.
+ * @param[in] phead: List head to add it after.
+ * @return	  None
+ */
+void	rtw_list_insert_head(_list *plist, _list *phead);
+
+/**
+ * @brief  This function adds a new entry before "phead" for the list.
+ * @param[in] plist: Pointer to the list to be added.
+ * @param[in] phead: List head to add it before.
+ * @return	  None
+ */
+void	rtw_list_insert_tail(_list *plist, _list *phead);
+
+/**
+ * @brief  This function deletes entry from list and reinitialize it.
+ * @param[in] plist: The element to delete from the list.
+ * @return	  None
+ * @note	  Caller must check if the list is empty before calling rtw_list_delete
+ */
+void	rtw_list_delete(_list *plist);
+/*************************** End List *******************************/
+
+// static __inline _list *get_next(_list	*list)
+// {
+// 	return list->next;
+// }
+
+static __inline _list *get_prev(_list	*list)
+{
+	return list->prev;
+}
+
+// static __inline _list	*get_list_head(_queue	*queue)
+// {
+// 	return (&(queue->queue));
+// }
+#endif
diff --git a/os/board/rtl8720e/src/component/os_dep/osdep_service_memory.c b/os/board/rtl8720e/src/component/os_dep/osdep_service_memory.c
new file mode 100755
index 000000000..9e799b17d
--- /dev/null
+++ b/os/board/rtl8720e/src/component/os_dep/osdep_service_memory.c
@@ -0,0 +1,110 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2012 Realtek Corporation. All rights reserved.
+ *
+ ******************************************************************************/
+// #include <FreeRTOS.h>
+#include <osdep_service.h>
+#include <stdio.h>
+#include <freertos_pmu.h>
+
+void *rtw_vmalloc(u32 sz)
+{
+	void *pbuf = NULL;
+	pbuf = kmm_malloc(sz);
+#ifdef CONFIG_DEBUG_MM_HEAPINFO
+        if (pbuf)
+        {
+            DEBUG_SET_CALLER_ADDR(pbuf);
+        }
+#endif
+	return pbuf;
+}
+
+void *rtw_zvmalloc(u32 sz)
+{
+	void *pbuf = NULL;
+
+	pbuf = kmm_zalloc(sz);
+#ifdef CONFIG_DEBUG_MM_HEAPINFO
+        if (pbuf)
+        {
+            DEBUG_SET_CALLER_ADDR(pbuf);
+        }
+#endif
+	return pbuf;
+}
+
+void rtw_vmfree(u8 *pbuf, u32 sz)
+{
+	(void) sz;
+
+	kmm_free(pbuf);
+}
+
+void *rtw_malloc(u32 sz)
+{
+	void *pbuf = NULL;
+	pbuf = kmm_malloc(sz);
+#ifdef CONFIG_DEBUG_MM_HEAPINFO
+        if (pbuf)
+        {
+            DEBUG_SET_CALLER_ADDR(pbuf);
+        }
+#endif
+	return pbuf;
+}
+
+void *rtw_zmalloc(u32 sz)
+{
+	void *pbuf = NULL;
+
+	pbuf = kmm_zalloc(sz);
+#ifdef CONFIG_DEBUG_MM_HEAPINFO
+        if (pbuf)
+        {
+            DEBUG_SET_CALLER_ADDR(pbuf);
+        }
+#endif
+	return pbuf;
+}
+
+void *rtw_calloc(u32 nelements, u32 elementSize)
+{
+	u32 sz = nelements * elementSize;
+	void *pbuf = kmm_zalloc(sz);
+#ifdef CONFIG_DEBUG_MM_HEAPINFO
+        if (pbuf)
+        {
+            DEBUG_SET_CALLER_ADDR(pbuf);
+        }
+#endif
+	return pbuf;
+}
+
+void rtw_mfree(u8 *pbuf, u32 sz)
+{
+	(void) sz;
+
+	kmm_free(pbuf);
+}
+
+void rtw_memcpy(void *dst, void *src, u32 sz)
+{
+	memcpy(dst, src, sz);
+}
+
+int rtw_memcmp(void *dst, void *src, u32 sz)
+{
+	if (!(memcmp(dst, src, sz))) {
+		return 1;
+	}
+
+	return 0;
+}
+
+void rtw_memset(void *pbuf, int c, u32 sz)
+{
+	memset(pbuf, c, sz);
+}
+
diff --git a/os/board/rtl8720e/src/component/os_dep/osdep_service_memory.h b/os/board/rtl8720e/src/component/os_dep/osdep_service_memory.h
new file mode 100755
index 000000000..8d31b790a
--- /dev/null
+++ b/os/board/rtl8720e/src/component/os_dep/osdep_service_memory.h
@@ -0,0 +1,110 @@
+/******************************************************************************
+ * Copyright (c) 2013-2016 Realtek Semiconductor Corp.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ ******************************************************************************/
+
+#ifndef __OSDEP_SERVICE_MEMORY_H_
+#define __OSDEP_SERVICE_MEMORY_H_
+
+
+/*************************** Memory Management *******************************/
+
+/**
+ * @brief  This function allocates the virtually contiguous memory.
+ * @param[in] sz: The size of memory to be allocated.
+ * @return	  The pointer to the beginning of the memory
+ */
+void	*rtw_vmalloc(uint32_t sz);
+
+/**
+ * @brief  This function allocates the virtually contiguous memory
+ *		   and the values of the memory are setted to 0.
+ * @param[in] sz: The size of memory to be allocated.
+ * @return	  The pointer to the beginning of the memory
+ */
+void	*rtw_zvmalloc(uint32_t sz);
+
+/**
+ * @brief  This function frees the virtually contiguous memory.
+ * @param[in] pbuf: The pointer to the beginning of the memory to be free
+ * @param[in] sz: The size of memory allocated.
+ * @return	  None
+ */
+void	rtw_vmfree(uint8_t *pbuf, uint32_t sz);
+
+/**
+ * @brief  This function allocates the memory
+ *		   and the values of the memory are setted to 0.
+ * @param[in] sz: The size of memory to be allocated.
+ * @return	  The pointer to the beginning of the memory
+ */
+void	*rtw_zmalloc(uint32_t sz);
+
+/**
+ * @brief  This function allocates the memory.
+ * @param[in] sz: The size of memory to be allocated.
+ * @return	  The pointer to the beginning of the memory
+ */
+void	*rtw_malloc(uint32_t sz);
+
+/**
+ * @brief  This function allocates the memory, nlements*elementSize bytes in size.
+ * @param[in] nelements: The number of elements.
+ * @param[in] elementSize: The size of each element
+ * @return	  The pointer to the beginning of the memory
+ */
+void	*rtw_calloc(uint32_t nelements, uint32_t elmentSize);
+
+/**
+ * @brief  This function frees the virtually contiguous memory.
+ * @param[in] pbuf: The pointer to the beginning of the memory to be free
+ * @param[in] sz: The size of memory allocated.
+ * @return	  None
+ */
+void	rtw_mfree(uint8_t *pbuf, uint32_t sz);
+
+#define rtw_free(buf)		rtw_mfree((uint8_t *)buf, 0)
+
+/**
+ * @brief  This function copies the values of "sz" bytes from the location pointed to by "src"
+ *         directly to the memory block pointed to by "des".
+ * @param[in] dst: Pointer to the destination array where the content is to be copied, type-casted to a pointer of type void*.
+ * @param[in] src: Pointer to the source of data to be copied, type-casted to a pointer of type void*.
+ * @param[in] sz: Size of memory to copy.
+ * @return	  None
+ */
+void	rtw_memcpy(void *dst, void *src, uint32_t sz);
+
+/**
+ * @brief  This function compares the first "sz" bytes of the block of memory pointed by "dst"
+ *		   to the first "sz" bytes pointed by "src".
+ * @param[in] dst: Pointer to block of memory to be compared.
+ * @param[in] src: pointer to block of memory to compare.
+ * @param[in] sz: Size of memory to compare.
+ * @return	<0: The first byte that does not match in both memory blocks has a lower value in dst than in src.
+ * @return	0: The contents of both memory blocks are equal.
+ * @return	<0: The first byte that does not match in both memory blocks has a greater value in dst than in src.
+ */
+int	rtw_memcmp(void *dst, void *src, uint32_t sz);
+
+/**
+ * @brief  This function sets the first "sz" bytes of the block of memory pointed by "pbuf" to the specified "c".
+ * @param[in] pbuf: Pointer to the block of memory to fill.
+ * @param[in] c: Value to be set.
+ * @param[in] sz: Size of memory to be set to the value "c".
+ * @return	  None
+ */
+void	rtw_memset(void *pbuf, int c, uint32_t sz);
+/*************************** End Memory Management *******************************/
+#endif
diff --git a/os/board/rtl8720e/src/component/os_dep/osdep_service_misc.c b/os/board/rtl8720e/src/component/os_dep/osdep_service_misc.c
new file mode 100755
index 000000000..9f63739e9
--- /dev/null
+++ b/os/board/rtl8720e/src/component/os_dep/osdep_service_misc.c
@@ -0,0 +1,283 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2012 Realtek Corporation. All rights reserved.
+ *
+ ******************************************************************************/
+// #include <FreeRTOS.h>
+#include <osdep_service.h>
+#include <stdio.h>
+#include <freertos_pmu.h>
+
+/* Not needed on 64bit architectures */
+static unsigned int __div64_32(u64 *n, unsigned int base)
+{
+	u64 rem = *n;
+	u64 b = base;
+	u64 res, d = 1;
+	unsigned int high = rem >> 32;
+
+	/* Reduce the thing a bit first */
+	res = 0;
+	if (high >= base) {
+		high /= base;
+		res = (u64) high << 32;
+		rem -= (u64)(high * base) << 32;
+	}
+
+	while ((u64) b > 0 && b < rem) {
+		b = b + b;
+		d = d + d;
+	}
+
+	do {
+		if (rem >= b) {
+			rem -= b;
+			res += d;
+		}
+		b >>= 1;
+		d >>= 1;
+	} while (d);
+
+	*n = res;
+	return rem;
+}
+
+u64 rtw_modular64(u64 n, u64 base)
+{
+	unsigned int __base = (base);
+	unsigned int __rem;
+
+	if (((n) >> 32) == 0) {
+		__rem = (unsigned int)(n) % __base;
+		(n) = (unsigned int)(n) / __base;
+	} else {
+		__rem = __div64_32(&(n), __base);
+	}
+
+	return __rem;
+}
+
+/* Refer to ecos bsd tcpip codes */
+static int _rtw_arc4random(void)
+{
+#if defined(CONFIG_PLATFORM_AMEBALITE)
+	int value = (int)_rand();
+	return value;
+
+#else
+
+	u32 res = xTaskGetTickCount();
+	static unsigned long seed = 0xDEADB00B;
+
+#if defined(CONFIG_PLATFORM_8711B)
+	if (random_seed) {
+		seed = random_seed;
+		random_seed = 0;
+	}
+#endif
+	seed = ((seed & 0x007F00FF) << 7) ^ ((seed & 0x0F80FF00) >> 8) ^	// be sure to stir those low bits
+		   (res << 13) ^ (res >> 9);	// using the clock too!
+	return (int)seed;
+#endif
+}
+
+
+int rtw_get_random_bytes(void *buf, u32 len)
+{
+	unsigned int ranbuf;
+	unsigned int *lp;
+	int i, count;
+	count = len / sizeof(unsigned int);
+	lp = (unsigned int *)buf;
+
+	for (i = 0; i < count; i++) {
+		lp[i] = _rtw_arc4random();
+		len -= sizeof(unsigned int);
+	}
+
+	if (len > 0) {
+		ranbuf = _rtw_arc4random();
+		memcpy(&lp[i], &ranbuf, len);
+	}
+	return 0;
+}
+
+u32 rtw_getFreeHeapSize(void)
+{
+	return 0;
+}
+
+void rtw_netif_start_queue(void *pnetdev)
+{
+	/* To avoid gcc warnings */
+	(void) pnetdev;
+}
+
+int rtw_netif_queue_stopped(void *pnetdev)
+{
+	/* To avoid gcc warnings */
+	(void) pnetdev;
+
+	return 0;
+}
+
+void rtw_netif_wake_queue(void *pnetdev)
+{
+	/* To avoid gcc warnings */
+	(void) pnetdev;
+}
+
+void rtw_netif_stop_queue(void *pnetdev)
+{
+	/* To avoid gcc warnings */
+	(void) pnetdev;
+}
+
+void rtw_acquire_wakelock(void)
+{
+}
+
+void rtw_release_wakelock(void)
+{
+}
+
+void rtw_wakelock_timeout(u32 timeoutms)
+{
+}
+
+int rtw_in_interrupt(void)
+{
+#ifdef ARM_CORE_CA32
+	return (__get_mode() != CPSR_M_USR) && (__get_mode() != CPSR_M_SYS);
+#else
+#if defined(__ICCARM__)
+	return (__get_PSR() & 0x1FF) != 0;
+#elif defined(__GNUC__)
+
+#ifdef ARM_CORE_CM4
+	return (__get_xPSR() & 0x1FF) != 0;
+#elif defined(RSICV_CORE_KR4)
+	return plic_get_active_irq_id_ram() != 0;
+#else
+	return __get_IPSR() != 0;
+#endif
+
+#endif
+#endif
+}
+
+u32 rtw_atoi(u8 *s)
+{
+	int num = 0, flag = 0;
+	u32 i;
+
+	for (i = 0; i <= strlen((char *)s); i++) {
+		if (s[i] >= '0' && s[i] <= '9') {
+			num = num * 10 + s[i] - '0';
+		} else if (s[0] == '-' && i == 0) {
+			flag = 1;
+		} else {
+			break;
+		}
+	}
+
+	if (flag == 1) {
+		num = num * -1;
+	}
+
+	return (num);
+}
+
+int rtw_printf(const char *format,...)
+{
+	int ret = 0;
+#ifdef CONFIG_DEBUG_LWNL80211_VENDOR_DRV_INFO
+	va_list ap;
+	va_start(ap, format);
+#ifdef CONFIG_LOGM
+	ret = logm_internal(LOGM_NORMAL, LOGM_IDX, LOGM_INF, format, ap);
+#else
+	ret = vsyslog(LOG_INFO, format, ap);
+#endif
+	va_end(ap);
+#endif
+	return ret;
+}
+
+int rtw_printf_info(const char *format,...)
+{
+	va_list ap;
+	int ret = 0;
+	va_start(ap, format);
+#ifdef CONFIG_LOGM
+	ret = logm_internal(LOGM_NORMAL, LOGM_IDX, LOGM_INF, format, ap);
+#else
+	ret = vsyslog(LOG_INFO, format, ap);
+#endif
+	va_end(ap);
+	return ret;
+}
+
+static IRQ_FUN TizenUserIrqFunTable[MAX_PERIPHERAL_IRQ_NUM];
+static int wrapper_IrqFun(int irq, FAR void *context, FAR void *arg)
+{
+	if (irq < AMEBALITE_IRQ_FIRST) {
+		DBG_INFO("INT %d should not come here\n", irq);
+		return OK;
+	}
+	__NVIC_ClearPendingIRQ(irq - AMEBALITE_IRQ_FIRST);
+	if (TizenUserIrqFunTable[irq - AMEBALITE_IRQ_FIRST] != NULL) {
+		TizenUserIrqFunTable[irq - AMEBALITE_IRQ_FIRST]((VOID *)(arg));
+	} else {
+		DBG_INFO("INT_Entry Irq %d Fun Not Assign!!!!!\n", irq - AMEBALITE_IRQ_FIRST);
+	}
+	return OK;
+}
+
+/* AmebaLite compile cannot find this define so hardcoded here */
+#define __NVIC_PRIO_BITS 3	/**< Number of priority bits implemented in the NVIC */
+BOOL irq_register_ram(IRQ_FUN IrqFun, IRQn_Type IrqNum, u32 Data, u32 Priority)
+{
+	if (IrqNum < 0) {
+		DBG_INFO("INT %d should not come here\n", IrqNum);
+		return _TRUE;
+	}
+
+	if (IrqNum == WL_DMA_IRQ || IrqNum == WL_PROTOCOL_IRQ) {
+		Priority = 4;
+	}
+	TizenUserIrqFunTable[IrqNum] = (IRQ_FUN)((u32) IrqFun | 0x1);
+	Priority = (Priority << (8 - __NVIC_PRIO_BITS));
+	irq_attach(IrqNum + AMEBALITE_IRQ_FIRST, wrapper_IrqFun, (void *)Data);
+	up_prioritize_irq(IrqNum + AMEBALITE_IRQ_FIRST, Priority);	//Need to fix, because it can't get the same result as __NVIC_SetPriority
+	return _TRUE;
+}
+
+BOOL irq_unregister_ram(IRQn_Type IrqNum)
+{
+	if (IrqNum < 0) {
+		DBG_INFO("INT %d should not come here\n", IrqNum);
+		return _TRUE;
+	}
+	irq_detach(IrqNum);
+	TizenUserIrqFunTable[IrqNum] = NULL;
+	return _TRUE;
+}
+
+void irq_enable_ram(IRQn_Type IrqNum)
+{
+	if (IrqNum < 0) {
+		DBG_INFO("INT %d should not come here\n", IrqNum);
+		return;
+	}
+	up_enable_irq(IrqNum + AMEBALITE_IRQ_FIRST);
+}
+
+void irq_disable_ram(IRQn_Type IrqNum)
+{
+	if (IrqNum < 0) {
+		DBG_INFO("INT %d should not come here\n", IrqNum);
+		return;
+	}
+	up_disable_irq(IrqNum + AMEBALITE_IRQ_FIRST);
+}
\ No newline at end of file
diff --git a/os/board/rtl8720e/src/component/os_dep/osdep_service_misc.h b/os/board/rtl8720e/src/component/os_dep/osdep_service_misc.h
new file mode 100755
index 000000000..c46934492
--- /dev/null
+++ b/os/board/rtl8720e/src/component/os_dep/osdep_service_misc.h
@@ -0,0 +1,173 @@
+/******************************************************************************
+ * Copyright (c) 2013-2016 Realtek Semiconductor Corp.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ ******************************************************************************/
+
+#ifndef __OSDEP_SERVICE_MISC_H_
+#define __OSDEP_SERVICE_MISC_H_
+
+// #define printk				printf
+// #define DBG_ERR(fmt, args...)		printf("\n\r[%s] " fmt, __FUNCTION__, ## args)
+
+// #define HALT()				do { cli(); for(;;);} while(0)
+#undef ASSERT
+#define ASSERT(x)			do { \
+						if((x) == 0){\
+							printf("\n\rAssert(" #x ") failed on line %d in file %s\n", __LINE__, __FILE__); \
+						HALT();}\
+					} while(0)
+
+#undef DBG_ASSERT
+#define DBG_ASSERT(x, msg)		do { \
+						if((x) == 0) \
+							printf("\n\r%s, Assert(" #x ") failed on line %d in file %s", msg, __LINE__, __FILE__); \
+					} while(0)
+
+#ifndef FIELD_OFFSET
+#define FIELD_OFFSET(s,field)	((SSIZE_T)&((s*)(0))->field)
+#endif
+
+#ifdef LIST_CONTAINOR
+#undef LIST_CONTAINOR
+#endif
+#define LIST_CONTAINOR(ptr, type, member) \
+	((type *)(void*)((char *)(ptr)-(unsigned int)((char *)&((type *)(void*)ptr)->member - (char *)ptr)))
+//#define container_of(p,t,n) (t*)((p)-&(((t*)0)->n))
+#if !defined(container_of)
+#define container_of(ptr, type, member) \
+			((type *)(void*)((char *)(ptr)-(SIZE_T)(&((type *)0)->member)))
+#endif
+
+#define rtw_min(a, b) ((a > b) ? b : a)
+
+/**
+ * @brief  This function generates random bytes.
+ * @param[in] dst: The pointer to the buffer to store the random bytes.
+ * @param[in] size: The size of the random bytes.
+ * @return	  0
+*/
+int	rtw_get_random_bytes(void *dst, uint32_t size);
+
+/**
+ * @brief  This function gets the available heap size.
+ * @return	  The value of the available heap size.
+*/
+uint32_t	rtw_getFreeHeapSize(void);
+
+/**
+ * @brief  This function indicates that the WLAN needs to stay on which means cannot go into power saving mode.
+ * @return  None
+ * @note  Defining configUSE_WAKELOCK_PMU 1 in "FreeRTOSConfig.h" needs to be done before compiling,
+ *			or this API won't be effective.
+ */
+void	rtw_acquire_wakelock(void);
+
+/**
+ * @brief  This function indicates that the WLAN does not need to stay on which means can go into power saving mode.
+ * @return  None
+ * @note  Defining configUSE_WAKELOCK_PMU 1 in "FreeRTOSConfig.h" needs to be done before compiling,
+ *			or this API won't be effective.
+ */
+void	rtw_release_wakelock(void);
+void rtw_wakelock_timeout(uint32_t timeout);
+
+int rtw_in_interrupt(void);
+
+/**
+ * @brief  This function converts the initial portion of the string to integer.
+ * @param[in] s: The pointer to the string to be converted.
+ * @return	  The converted value.
+*/
+uint32_t 	rtw_atoi(uint8_t *s);
+
+__inline static uint32_t _RND4(uint32_t sz)
+{
+	uint32_t	val;
+
+	val = ((sz >> 2) + ((sz & 3) ? 1 : 0)) << 2;
+
+	return val;
+}
+
+__inline static uint32_t _RND8(uint32_t sz)
+{
+	uint32_t	val;
+
+	val = ((sz >> 3) + ((sz & 7) ? 1 : 0)) << 3;
+
+	return val;
+}
+
+__inline static uint32_t _RND128(uint32_t sz)
+{
+	uint32_t	val;
+
+	val = ((sz >> 7) + ((sz & 127) ? 1 : 0)) << 7;
+
+	return val;
+}
+
+__inline static uint32_t _RND256(uint32_t sz)
+{
+	uint32_t	val;
+
+	val = ((sz >> 8) + ((sz & 255) ? 1 : 0)) << 8;
+
+	return val;
+}
+
+__inline static uint32_t _RND512(uint32_t sz)
+{
+	uint32_t	val;
+
+	val = ((sz >> 9) + ((sz & 511) ? 1 : 0)) << 9;
+
+	return val;
+}
+
+__inline static uint32_t bitshift(uint32_t bitmask)
+{
+	uint32_t i;
+
+	for (i = 0; i <= 31; i++)
+		if (((bitmask >> i) &  0x1) == 1) {
+			break;
+		}
+
+	return i;
+}
+
+__inline static u16 _htons(u16 n)
+{
+	return ((n & 0xff) << 8) | ((n & 0xff00) >> 8);
+}
+
+__inline static u16 _ntohs(u16 n)
+{
+	return _htons(n);
+}
+
+__inline static u32 _htonl(u32 n)
+{
+	return ((n & 0xff) << 24) |
+		   ((n & 0xff00) << 8) |
+		   ((n & 0xff0000UL) >> 8) |
+		   ((n & 0xff000000UL) >> 24);
+}
+
+__inline static u32 _ntohl(u32 n)
+{
+	return _htonl(n);
+}
+#endif
diff --git a/os/board/rtl8720e/src/component/os_dep/osdep_service_mutex.c b/os/board/rtl8720e/src/component/os_dep/osdep_service_mutex.c
new file mode 100755
index 000000000..e2561f6b5
--- /dev/null
+++ b/os/board/rtl8720e/src/component/os_dep/osdep_service_mutex.c
@@ -0,0 +1,172 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2012 Realtek Corporation. All rights reserved.
+ *
+ ******************************************************************************/
+// #include <FreeRTOS.h>
+// #include <semphr.h>
+#include <osdep_service.h>
+#include <stdio.h>
+#include <freertos_pmu.h>
+
+#if( configSUPPORT_STATIC_ALLOCATION == 1 )
+
+int max_mutex_num = MAX_MUTEX_BUF_NUM;
+struct mutex_buf {
+	struct list_head list;
+	StaticSemaphore_t mutex;
+};
+
+struct mutex_buf mutex_pool[MAX_MUTEX_BUF_NUM];
+struct list_head wrapper_mutexbuf_list;
+int mutexbuf_used_num, mutex_dynamic_num;
+int max_mutexbuf_used_num;
+int mutexpool_flag = 0;
+
+void *get_mutex_from_poll(struct list_head *phead, int *count)
+{
+	StaticSemaphore_t *mutex;
+	struct list_head *plist;
+
+	if (mutexpool_flag == 0) {
+		return NULL;
+	}
+
+	save_and_cli();
+	if (list_empty(phead)) {
+		restore_flags();
+		return NULL;
+	}
+
+	plist = phead->next;
+	list_del_init(plist);
+
+	mutex = (StaticSemaphore_t *)((unsigned int)plist + sizeof(struct list_head));
+
+	*count = *count + 1;
+
+	restore_flags();
+
+	return (unsigned char *)mutex;
+}
+
+void release_mutex_to_poll(unsigned char *buf, struct list_head *phead, int *count)
+{
+	struct list_head *plist;
+	plist = (struct list_head *)(((unsigned int)buf) - sizeof(struct list_head));
+	list_add_tail(plist, phead);
+
+	*count = *count - 1;
+}
+
+u8 rtw_get_mutex_dynamic_flag(_mutex sema)
+{
+	StaticSemaphore_t *pqueue = (StaticSemaphore_t *)sema;
+	return pqueue->ucDummy6;
+}
+
+#endif
+
+void init_mutex_pool(void)
+{
+#if( configSUPPORT_STATIC_ALLOCATION == 1 )
+	int i;
+
+	memset(mutex_pool, '\0', max_mutex_num * sizeof(struct mutex_buf));
+	INIT_LIST_HEAD(&wrapper_mutexbuf_list);
+
+	for (i = 0; i < max_mutex_num; i++) {
+		INIT_LIST_HEAD(&mutex_pool[i].list);
+		list_add_tail(&mutex_pool[i].list, &wrapper_mutexbuf_list);
+	}
+
+	mutexbuf_used_num = 0;
+	max_mutexbuf_used_num = 0;
+	mutex_dynamic_num = 0;
+
+	mutexpool_flag = 1;
+#endif
+}
+
+
+void rtw_mutex_init(_mutex *pmutex)
+{
+#if( configSUPPORT_STATIC_ALLOCATION == 1 )
+	StaticSemaphore_t *mutex;
+
+	mutex = (StaticSemaphore_t *)get_mutex_from_poll(&wrapper_mutexbuf_list, &mutexbuf_used_num);
+
+	if (mutex == NULL) {
+		if (mutexpool_flag) {
+			mutex_dynamic_num++;
+			printf("static mutex is not avaliable. mutexbuf_used_num: %d\n", mutexbuf_used_num);
+		}
+		goto exit;
+	} else {
+		memset(mutex, '\0', sizeof(*mutex));
+		*pmutex = xSemaphoreCreateMutexStatic(mutex);
+	}
+
+	if (mutexbuf_used_num > max_mutexbuf_used_num) {
+		max_mutexbuf_used_num = mutexbuf_used_num;
+	}
+
+	return;
+exit:
+#endif
+
+	if (*pmutex == NULL) {
+		*pmutex = kmm_zalloc(sizeof(sem_t));
+		if (*pmutex == NULL) {
+			DBG_ERR("Failed\n");
+			return;
+		}
+#ifdef CONFIG_DEBUG_MM_HEAPINFO
+		DEBUG_SET_CALLER_ADDR(*pmutex);
+#endif
+	}
+	sem_init(*pmutex, 0, 1);
+	sem_setprotocol(*pmutex, SEM_PRIO_NONE);
+}
+
+void rtw_mutex_free(_mutex *pmutex)
+{
+	int i;
+	if (*pmutex != NULL) {
+		i = sem_destroy(*pmutex);
+		if (i == 0) {
+			kmm_free(*pmutex);
+		} else {
+			DBG_ERR("Fail!!!\n");
+		}
+	}
+	*pmutex = NULL;
+}
+
+void rtw_mutex_put(_mutex *pmutex)
+{
+	sem_post(*pmutex);
+}
+
+void rtw_mutex_get(_mutex *pmutex)
+{
+	int temp;
+	temp = sem_wait(*pmutex);
+	if (temp != 0) {
+		DBG_ERR("Failed!\n");
+	}
+}
+
+int rtw_mutex_get_timeout(_mutex *pmutex, u32 timeout_ms)
+{
+	struct timespec ts;
+	clock_gettime(CLOCK_REALTIME, &ts);
+	ts.tv_sec += timeout_ms / 1000;
+	if (sem_timedwait(*pmutex, &ts) < 0) {
+		return _FAIL;
+	} else {
+		return _SUCCESS;
+	}
+}
+
+
diff --git a/os/board/rtl8720e/src/component/os_dep/osdep_service_mutex.h b/os/board/rtl8720e/src/component/os_dep/osdep_service_mutex.h
new file mode 100755
index 000000000..cfb9f1467
--- /dev/null
+++ b/os/board/rtl8720e/src/component/os_dep/osdep_service_mutex.h
@@ -0,0 +1,84 @@
+/******************************************************************************
+ * Copyright (c) 2013-2016 Realtek Semiconductor Corp.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ ******************************************************************************/
+
+#ifndef __OSDEP_SERVICE_MUTEX_H_
+#define __OSDEP_SERVICE_MUTEX_H_
+
+typedef void	            *_mutex;
+
+#if( configSUPPORT_STATIC_ALLOCATION == 1 )
+#ifdef CONFIG_WLAN
+#define MAX_MUTEX_BUF_NUM		109
+#else
+#define MAX_MUTEX_BUF_NUM		5
+#endif
+#endif
+
+#if( configSUPPORT_STATIC_ALLOCATION == 1 )
+
+extern struct list_head wrapper_mutexbuf_list;
+extern int mutexbuf_used_num, mutex_dynamic_num;
+extern int max_mutexbuf_used_num;
+extern int mutexpool_flag;
+
+void *get_mutex_from_poll(struct list_head *phead, int *count);
+void release_mutex_to_poll(unsigned char *buf, struct list_head *phead, int *count);
+u8 rtw_get_mutex_dynamic_flag(_mutex sema);
+#endif
+
+void init_mutex_pool(void);
+
+/*************************** Mutexes *******************************/
+/**
+ * @brief  This function implements a mutex semaphore by using the existing queue mechanism.
+ * @param[in] pmutex: Pointer to the created mutex semaphore.
+ * @return	  None
+ */
+void	rtw_mutex_init(_mutex *pmutex);
+
+/**
+ * @brief  This function deletes the mutex semaphore.
+ * @param[in] pmutex: Pointer to the mutex semaphore to be deleted.
+ * @return	  None
+ */
+void	rtw_mutex_free(_mutex *pmutex);
+
+/**
+ * @brief  This function releases a mutex semaphore.
+ * @param[in] pmutex: Pointer to the mutex semaphore to be released.
+ * @return	  None
+ */
+void	rtw_mutex_put(_mutex *pmutex);
+
+/**
+ * @brief  This function obtains a mutex semaphore.
+ * @param[in] pmutex: Pointer to the mutex semaphore being taken - obtained when
+ *			  the mutex semaphore was created.
+ * @return	  None
+ */
+void	rtw_mutex_get(_mutex *pmutex);
+
+/**
+ * @brief  This function obtains a mutex semaphore with a timeout setting.
+ * @param[in] pmutex: Pointer to the mutex semaphore being taken - obtained when
+ *			  the mutex semaphore was created.
+ * @param[in] timeout: The time in ms to wait for the semaphore to become available.
+ * @return	0: The semaphore was obtained.
+ * @return	-1: Timeout without the semaphore becoming available.
+ */
+int	rtw_mutex_get_timeout(_mutex *pmutex, uint32_t timeout_ms);
+/*************************** End Mutexes *******************************/
+#endif
diff --git a/os/board/rtl8720e/src/component/os_dep/osdep_service_queue.c b/os/board/rtl8720e/src/component/os_dep/osdep_service_queue.c
new file mode 100755
index 000000000..aeb74c89a
--- /dev/null
+++ b/os/board/rtl8720e/src/component/os_dep/osdep_service_queue.c
@@ -0,0 +1,63 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2012 Realtek Corporation. All rights reserved.
+ *
+ ******************************************************************************/
+// #include <FreeRTOS.h>
+// #include <semphr.h>
+#include <osdep_service.h>
+#include <stdio.h>
+#include <freertos_pmu.h>
+
+void	rtw_init_queue(_queue	*pqueue)
+{
+	rtw_init_listhead(&(pqueue->queue));
+	rtw_spinlock_init(&(pqueue->lock));
+}
+
+u32	  rtw_queue_empty(_queue	*pqueue)
+{
+	return (rtw_is_list_empty(&(pqueue->queue)));
+}
+
+
+u32 rtw_end_of_queue_search(_list *head, _list *plist)
+{
+	if (head == plist) {
+		return _TRUE;
+	} else {
+		return _FALSE;
+	}
+}
+int rtw_init_xqueue(_xqueue *queue, const char *name, u32 message_size, u32 number_of_messages)
+{
+	/* To avoid gcc warnings */
+	DBG_INFO("\n");
+	return 0;
+}
+
+int rtw_push_to_xqueue(_xqueue *queue, void *message, u32 timeout_ms)
+{
+	DBG_INFO("\n");
+	return 0;
+}
+
+int rtw_pop_from_xqueue(_xqueue *queue, void *message, u32 timeout_ms)
+{
+	DBG_INFO("\n");
+	return 0;
+}
+
+int rtw_peek_from_xqueue(_xqueue *queue, void *message, u32 timeout_ms)
+{
+	DBG_INFO("\n");
+	return 0;
+}
+
+int rtw_deinit_xqueue(_xqueue *queue)
+{
+	DBG_INFO("\n");
+	return 0;
+}
+
+
diff --git a/os/board/rtl8720e/src/component/os_dep/osdep_service_queue.h b/os/board/rtl8720e/src/component/os_dep/osdep_service_queue.h
new file mode 100755
index 000000000..a346a5e42
--- /dev/null
+++ b/os/board/rtl8720e/src/component/os_dep/osdep_service_queue.h
@@ -0,0 +1,100 @@
+/******************************************************************************
+ * Copyright (c) 2013-2016 Realtek Semiconductor Corp.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ ******************************************************************************/
+
+#ifndef __OSDEP_SERVICE_QUEUE_H_
+#define __OSDEP_SERVICE_QUEUE_H_
+
+
+#define RTW_WAIT_FOREVER		0xFFFFFFFF
+
+typedef void	            *_queueHandle;
+typedef void	            *_xqueue;
+
+#define netif_queue_stopped(dev)	(0)
+#define netif_wake_queue(dev)		do { } while (0)
+
+/*************************** Queues *******************************/
+
+/**
+ * @brief  This function creates a new queue instance.
+ * @param[in] queue: The handle to the newly created queue.
+ * @param[in] name: The name of the queue
+ * @param[in] message_size: The number of bytes each message in the queue will require.
+ * @param[in] number_of_messages: The maximum number of messages that kthe queue can contain.
+ * @return	  0: Creating queue success
+ * @return	  -1: Creating queue fail
+ */
+int rtw_init_xqueue(_xqueue *queue, const char *name, uint32_t message_size, uint32_t number_of_messages);
+
+/**
+ * @brief  This function posts a message to the back of a queue.
+ *		   The message is queued by copy, not by reference.
+ * @param[in] queue: The handle to the queue on which the message is to be posted.
+ * @param[in] message: The pointer to the message that is to be placed on the queue.
+ * @param[in] timeout_ms: The maximum amout of time the task should block waiting for
+ 			              the space to become available on the queue, should it already be full.
+ 			              The time is defined in ms.
+ * @return	  0: The message was successfully posted.
+ * @return	  -1: The message was not posted.
+ */
+int rtw_push_to_xqueue(_xqueue *queue, void *message, uint32_t timeout_ms);
+
+/**
+ * @brief  This function receives a message from a queue.
+ *		   The message is recieved by copy so a buffer adequate size must be provided.
+ * @param[in] queue: The handle to the queue from which the message is to be received.
+ * @param[in] message: The pointer to the buffer into which the received message will be copied.
+ * @param[in] timeout_ms: The maximum amout of time the task should block waiting for a message to
+ *						  receive should the queue be empty at the time of the call.
+ 			              The time is defined in ms.
+ * @return	  0: A message was successfully received from the queue.
+ * @return	  -1: No message was received from the queue.
+ */
+int rtw_pop_from_xqueue(_xqueue *queue, void *message, uint32_t timeout_ms);
+
+int rtw_peek_from_xqueue(_xqueue *queue, void *message, uint32_t timeout_ms);
+
+/**
+ * @brief  Delete a queue - freeing all the memory allocated for storing of messages placed on the queue.
+ * @param[in] queue: The handle to the queue to be deleted.
+ * @return	  0: The queue was successfully deleted.
+ * @return	  -1: The queue was not empty so cannot be deleted.
+ */
+int rtw_deinit_xqueue(_xqueue *queue);
+
+/**
+ * @brief  This function creates a new queue instance.
+ * @param[in] pqueue: The handle to the newly created queue.
+ * @return	 None
+ */
+void	rtw_init_queue(_queue	*pqueue);
+
+/**
+ * @brief  This function tests whether the queue is empty.
+ * @param[in] pqueue: The handle to the queue to be tested.
+ * @return	 None
+ */
+uint32_t	rtw_queue_empty(_queue	*pqueue);
+
+/**
+ * @brief  This function tests whether the "pelement" is at the "queue".
+ * @param[in] queue: The pointer to the queue that to be tested.
+ * @param[in] pelement: The element that to be tested.
+ * @return	 _TRUE/_FALSE
+ */
+uint32_t	rtw_end_of_queue_search(_list *queue, _list *pelement);
+/*************************** End Queues *******************************/
+#endif
diff --git a/os/board/rtl8720e/src/component/os_dep/osdep_service_sem.c b/os/board/rtl8720e/src/component/os_dep/osdep_service_sem.c
new file mode 100755
index 000000000..80ff7439d
--- /dev/null
+++ b/os/board/rtl8720e/src/component/os_dep/osdep_service_sem.c
@@ -0,0 +1,88 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2012 Realtek Corporation. All rights reserved.
+ *
+ ******************************************************************************/
+// #include <FreeRTOS.h>
+// #include <semphr.h>
+#include <osdep_service.h>
+#include <stdio.h>
+#include <freertos_pmu.h>
+
+void rtw_init_sema(_sema *sema, int init_val)
+{
+	if (*sema == NULL) {
+		*sema = (_sema) kmm_zalloc(sizeof(sem_t));
+		if (*sema == NULL) {
+			DBG_ERR("Failed to kmm_zalloc\n");
+			return;
+		}
+#ifdef CONFIG_DEBUG_MM_HEAPINFO
+		DEBUG_SET_CALLER_ADDR(*sema);
+#endif
+	} else {
+		DBG_ERR("Already inited\n");
+		return;
+	}
+	int ret = sem_init((sem_t *)(*sema), 0, init_val);
+	if (ret != OK) {
+		DBG_ERR("Failed to sem_init\n");
+		kmm_free(*sema);
+		return;
+	}
+}
+
+void rtw_free_sema(_sema *sema)
+{
+	int i;
+	if (*sema != NULL) {
+		i = sem_destroy(*sema);
+		if (i == 0) {
+			kmm_free(*sema);
+		} else {
+			DBG_ERR("Fail!!!\n");
+		}
+	}
+	*sema = NULL;
+}
+
+void rtw_up_sema(_sema *sema)
+{
+	if (rtw_in_interrupt()) {
+		sem_post((sem_t *)(*sema));
+	} else {
+		sem_post((sem_t *)(*sema));
+	}
+}
+
+void rtw_up_sema_from_isr(_sema *sema)
+{
+	sem_post((sem_t *)(*sema));
+}
+
+u32	rtw_down_timeout_sema(_sema *sema, u32 timeout)
+{
+	struct timespec ts;
+	int ret;
+	if (timeout == RTW_MAX_DELAY) {
+		ret = sem_wait((sem_t *)(*sema));
+	} else {
+		clock_gettime(CLOCK_REALTIME, &ts);
+		ts.tv_sec += timeout / 1000;
+		ret = sem_timedwait((sem_t *)(*sema), &ts);
+	}
+	if (ret != OK) {
+		return _FAIL;
+	} else {
+		return _SUCCESS;
+	}
+}
+u32 rtw_down_sema(_sema *sema)
+{
+	while (rtw_down_timeout_sema(sema, RTW_MAX_DELAY) != _TRUE) {
+		OSDEP_DBG("%s(%p) failed, retry\n",  __FUNCTION__, sema);
+	}
+	return _TRUE;
+}
+
+
diff --git a/os/board/rtl8720e/src/component/os_dep/osdep_service_sem.h b/os/board/rtl8720e/src/component/os_dep/osdep_service_sem.h
new file mode 100755
index 000000000..2b80d9f04
--- /dev/null
+++ b/os/board/rtl8720e/src/component/os_dep/osdep_service_sem.h
@@ -0,0 +1,76 @@
+/******************************************************************************
+ * Copyright (c) 2013-2016 Realtek Semiconductor Corp.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ ******************************************************************************/
+
+#ifndef __OSDEP_SERVICE_SEM_H_
+#define __OSDEP_SERVICE_SEM_H_
+
+#define RTW_MAX_DELAY			0xFFFFFFFF
+
+typedef void	            *_sema;
+
+
+/*************************** Semaphores *******************************/
+/**
+ * @brief  This function initializes the unnamed semaphore referred to by "sema" to the value "init_val".
+ * @param[in] sema: Pointer to the semaphore handle to be initialized.
+ * @param[in] init_val: Initial value for semaphore.
+ * @return	  None
+ */
+void	rtw_init_sema(_sema *sema, int init_val);
+
+/**
+ * @brief  This function deletes the semaphore.
+ * @param[in] sema: The semaphore to be deleted.
+ * @return	  None
+ */
+void	rtw_free_sema(_sema *sema);
+
+/**
+ * @brief  This function releases the semaphore.
+ *		   This macro must not be used from an ISR.
+ * @param[in] sema: The semaphore to be released.
+ * @return	  None
+ */
+void	rtw_up_sema(_sema	*sema);
+
+/**
+ * @brief  This function releases the semaphore.
+ *		   This macro can be used from an ISR.
+ * @param[in] sema: The semaphore to be released.
+ * @return	  None
+ */
+void	rtw_up_sema_from_isr(_sema *sema);
+
+/**
+ * @brief  This function acquires the semaphore. If no more tasks are allowed to acquire the semaphore,
+ *		   calling this function will put the task to sleep until the semaphore is up.
+ * @param[in] sema: The semaphore to be acquired.
+ * @return	pdTRUE: The semaphore was obtained.
+ * @return	pdFALSE: Obtain the semaphore failed.
+ */
+uint32_t	rtw_down_sema(_sema *sema);
+
+/**
+ * @brief  This function acquires the semaphore. If no more tasks are allowed to acquire the semaphore,
+ *		   calling this function will put the task to sleep until the semaphore is up.
+ * @param[in] sema: The semaphore to be acquired.
+ * @param[in] timeout: The time in ms to wait for the semaphore to become available.
+ * @return	pdTRUE: The semaphore was obtained.
+ * @return	pdFALSE: Timeout without the semaphore becoming available.
+ */
+uint32_t	rtw_down_timeout_sema(_sema *sema, uint32_t timeout);
+/*************************** End Semaphores *******************************/
+#endif
diff --git a/os/board/rtl8720e/src/component/os_dep/osdep_service_task.c b/os/board/rtl8720e/src/component/os_dep/osdep_service_task.c
new file mode 100755
index 000000000..258d24445
--- /dev/null
+++ b/os/board/rtl8720e/src/component/os_dep/osdep_service_task.c
@@ -0,0 +1,167 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2012 Realtek Corporation. All rights reserved.
+ *
+ ******************************************************************************/
+// #include <FreeRTOS.h>
+// #include <task.h>
+#include <osdep_service.h>
+#include <stdio.h>
+#include <freertos_pmu.h>
+
+static int wrapper_thread(int argc, char *argv[])
+{
+	int func_addr, ctx_addr;
+	thread_func_t func;
+	void *thctx;
+	if (argc != 3) {
+		DBG_ERR("%s error\n", argv[0]);
+		return -1;
+	}
+	/* Arguments : [0] task name [1] func addr, [2] ctx addr */
+	func_addr = strtoul(argv[1], NULL, 16);
+	ctx_addr = strtoul(argv[2], NULL, 16);
+	func = (thread_func_t)func_addr;
+	thctx = (void *)ctx_addr;
+	func(thctx);
+	return OK;
+}
+
+int rtw_create_task(struct task_struct *ptask, const char *name,
+					u32 stack_size, u32 priority, thread_func_t func, void *thctx)
+{
+	int func_addr, ctx_addr;
+	pid_t pid;
+	char str_func_addr[9];
+	char str_ctx_addr[9];
+	char *task_info[3];
+	priority = SCHED_PRIORITY_DEFAULT + priority;
+	priority = (priority > SCHED_PRIORITY_MAX || priority < SCHED_PRIORITY_MIN)?SCHED_PRIORITY_DEFAULT:priority;
+	if(strncmp(name, "rtw_interrupt_thread", strlen("rtw_interrupt_thread") + 1) == 0) priority = 106;
+	if(strncmp(name, "rtw_recv_tasklet", strlen("rtw_recv_tasklet") + 1) == 0) priority = 105;
+	if(strncmp(name, "rtw_xmit_tasklet", strlen("rtw_xmit_tasklet") + 1) == 0) priority = 105;
+	if(strncmp(name, "cmd_thread", strlen("cmd_thread") + 1) == 0) priority = 105;
+	if(strncmp(name, "tcp_server_handler", strlen("tcp_server_handler") + 1) == 0) priority = 105;
+
+	stack_size *= sizeof(uint32_t);
+	func_addr = (int)func;
+	ctx_addr = (int)thctx;
+	task_info[0] = itoa(func_addr, str_func_addr, 16);
+	task_info[1] = itoa(ctx_addr, str_ctx_addr, 16);
+	task_info[2] = NULL;
+	pid = kernel_thread(name, priority, stack_size, wrapper_thread, (char * const *)task_info);
+	if (pid == ERROR) {
+		DBG_ERR("%s fail\n", name);
+		return _FAIL;
+	}
+	ptask->task = (pid_t)pid;
+	ptask->task_name = name;
+	return _SUCCESS;
+}
+
+void rtw_delete_task(struct task_struct *ptask)
+{
+	pid_t pid;
+	int status;
+	pid = (pid_t) ptask->task;
+	status = task_delete(pid);
+	if (status != OK) {
+		DBG_ERR("Failed, status=%d!\n", status);
+	}
+	ptask->task = -1;
+	return;
+}
+
+void rtw_set_priority_task(void *task, u32 NewPriority)
+{
+	FAR struct tcb_s *rtcb = sched_gettcb(*(pid_t *)task);
+	DBG_INFO("\n");
+
+	if (rtcb == NULL) {
+		DBG_ERR("Failed to get main task %d!\n", *(pid_t *)task);
+		return;
+	}
+
+	sched_setpriority(rtcb, NewPriority + SCHED_PRIORITY_DEFAULT);
+	return;
+}
+
+int rtw_get_priority_task(void *task)
+{
+	FAR struct tcb_s *rtcb = sched_gettcb(*(pid_t *)task);
+	DBG_INFO("\n");
+
+	if (rtcb == NULL) {
+		DBG_ERR("Failed to get main task %d!\n", *(pid_t *)task);
+		return _FAIL;
+	}
+
+	return rtcb->sched_priority - SCHED_PRIORITY_DEFAULT;
+}
+
+void rtw_suspend_task(void *task)
+{
+	FAR struct tcb_s *rtcb = sched_gettcb(*(pid_t *)task);
+	DBG_INFO("\n");
+
+	if (rtcb == NULL) {
+		DBG_ERR("Failed to get main task %d!\n", *(pid_t *)task);
+		return;
+	}
+
+	return;
+}
+
+void rtw_resume_task(void *task)
+{
+	FAR struct tcb_s *rtcb = sched_gettcb(*(pid_t *)task);
+	DBG_INFO("\n");
+
+	if (rtcb == NULL) {
+		DBG_ERR("Failed to get main task %d!\n", *(pid_t *)task);
+		return;
+	}
+
+	return;
+}
+
+void rtw_suspend_task_all(void)
+{
+	DBG_INFO("\n");
+	return;
+}
+
+void rtw_resume_task_all(void)
+{
+	DBG_INFO("\n");
+	return;
+}
+
+void rtw_thread_enter(char *name)
+{
+	/* To avoid gcc warnings */
+	DBG_INFO("RTKTHREAD %s\n", name);
+}
+
+void rtw_thread_exit()
+{
+	DBG_INFO("RTKTHREAD exit\n");
+	exit(EXIT_SUCCESS);
+}
+
+u8 rtw_get_scheduler_state()
+{
+	DBG_INFO("\n");
+	return 0;
+}
+
+void rtw_create_secure_context(u32 secure_stack_size)
+{
+	OSDEP_DBG("Not implement osdep service: rtw_create_secure_context");
+}
+
+void *rtw_get_current_TaskHandle(void)
+{
+	OSDEP_DBG("Not implement osdep service: rtw_get_current_TaskHandle");
+}
+
diff --git a/os/board/rtl8720e/src/component/os_dep/osdep_service_task.h b/os/board/rtl8720e/src/component/os_dep/osdep_service_task.h
new file mode 100755
index 000000000..16fd4bf7e
--- /dev/null
+++ b/os/board/rtl8720e/src/component/os_dep/osdep_service_task.h
@@ -0,0 +1,124 @@
+/******************************************************************************
+ * Copyright (c) 2013-2016 Realtek Semiconductor Corp.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ ******************************************************************************/
+
+#ifndef __OSDEP_SERVICE_TASK_H_
+#define __OSDEP_SERVICE_TASK_H_
+
+/**
+  * @brief  Definitions returned by xTaskGetSchedulerState().
+  */
+
+#define OS_SCHEDULER_NOT_STARTED	0
+#define OS_SCHEDULER_RUNNING		1
+#define OS_SCHEDULER_SUSPENDED		2
+
+#define TASK_PRORITY_LOW  				1
+#define TASK_PRORITY_MIDDLE   			2
+#define TASK_PRORITY_HIGH    			3
+#define TASK_PRORITY_SUPER    			4
+
+
+typedef void			    *_thread_hdl_;
+typedef void			    thread_return;
+typedef void			    *thread_context;
+
+typedef thread_return(*thread_func_t)(thread_context context);
+
+#define CONFIG_THREAD_COMM_SEMA
+struct task_struct {
+	const char *task_name;
+	_thread_hdl_ task;	/* I: workqueue thread */
+
+#ifdef CONFIG_THREAD_COMM_SIGNAL
+	const char *name;	/* I: workqueue thread name */
+	uint32_t queue_num;		/* total signal num */
+	uint32_t cur_queue_num;	/* cur signal num should < queue_num */
+#elif defined(CONFIG_THREAD_COMM_SEMA)
+	_sema wakeup_sema;    /* for internal use only */
+	_sema terminate_sema; /* for internal use only */
+#endif
+	uint32_t blocked;          /* for internal use only */
+	uint32_t callback_running; /* for internal use only */
+};
+
+
+/*********************************** Thread related *****************************************/
+
+/**
+ * @brief  This function creates a new task and adds it to the list of tasks that are ready to run.
+ * @param[in] task:  The task stucture which will store the task related infomation.
+ * @param[in] name: A descriptive name for the task.
+ * @param[in] stack_size: The size of the task stack specified as the variables the stack can hold.
+ * @param[in] priority: The priority at which the task should run.
+ * @param[in] func: The task entry function.
+ * @param[in] thctx: The pointer that will be used as the parameter for the task being created.
+ * @return  pdPASS: The task was successfully created and added to a ready list.
+ * @return  other error code defined in the file errors.h.
+ * @note  For the task name, please do not use "rtw_little_wifi_mcu_thread", "rtw_check_in_req_state_thread",
+ 		  "rtw_TDMA_change_state_thread", "xmit_thread", "recv_thread", "rtw_recv_tasklet", "rtw_xmit_tasklet",
+ 		  "rtw_interrupt_thread", "cmd_thread", "usb_init", "MSC_BULK_CMD" and "MSC_BULK_DATA".
+ */
+int	rtw_create_task(struct task_struct *task, const char *name, uint32_t  stack_size, uint32_t priority, thread_func_t func, void *thctx);
+
+/**
+ * @brief  This function deletes a task.
+ * @param[in] task:  The task stucture which will be deleted.
+ * @return  None
+ */
+void rtw_delete_task(struct task_struct *task);
+
+void rtw_set_priority_task(void *task, uint32_t NewPriority);
+
+int rtw_get_priority_task(void *task);
+
+void rtw_suspend_task(void *task);
+
+void rtw_resume_task(void *task);
+
+void rtw_suspend_task_all(void);
+
+void rtw_resume_task_all(void);
+
+/**
+ * @brief  This function prints the name of the thread in DBG_INFO.
+ * @param[in] name:  The name of the thread.
+ * @return  None
+ */
+void	rtw_thread_enter(char *name);
+
+/**
+ * @brief  This function exits the calling thread.
+ * @return  None
+ */
+void	rtw_thread_exit(void);
+
+/**
+ * @brief  This function gets the scheduler state of the calling thread.
+ * @return  OS_SCHEDULER_NOT_STARTED
+ * @return  OS_SCHEDULER_RUNNING
+ * @return  OS_SCHEDULER_SUSPENDED
+ */
+uint8_t		rtw_get_scheduler_state(void);
+
+/**
+ * @brief  This function creats secure stack for threads.
+ * @param[in] secure_stack_size:  The size of the secure stack for this thread, the unit is byte.
+ * @return  None
+ */
+void rtw_create_secure_context(uint32_t secure_stack_size);
+
+/*************************** End Threads *******************************/
+#endif
diff --git a/os/board/rtl8720e/src/component/os_dep/osdep_service_time.c b/os/board/rtl8720e/src/component/os_dep/osdep_service_time.c
new file mode 100755
index 000000000..0889bb04a
--- /dev/null
+++ b/os/board/rtl8720e/src/component/os_dep/osdep_service_time.c
@@ -0,0 +1,72 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2012 Realtek Corporation. All rights reserved.
+ *
+ ******************************************************************************/
+// #include <FreeRTOS.h>
+#include <osdep_service.h>
+#include <stdio.h>
+#include <freertos_pmu.h>
+
+uint32_t rtw_get_current_time(void)
+{
+	return (u32) clock();
+}
+
+u32 rtw_systime_to_ms(u32 systime)
+{
+	return (systime * 1000L / TICK_PER_SEC);
+}
+
+u32 rtw_systime_to_sec(u32 systime)
+{
+	return (systime / TICK_PER_SEC);
+}
+
+u32 rtw_ms_to_systime(u32 ms)
+{
+	return (ms * TICK_PER_SEC / 1000L);
+}
+
+u32 rtw_sec_to_systime(u32 sec)
+{
+	return (sec * TICK_PER_SEC);
+}
+
+// the input parameter start use the same unit as returned by rtw_get_current_time
+s32 rtw_get_passing_time_ms(u32 start)
+{
+	return rtw_systime_to_ms(rtw_get_current_time() - start);
+}
+
+s32 rtw_get_time_interval_ms(u32 start, u32 end)
+{
+	return rtw_systime_to_ms(end - start);
+}
+
+void rtw_msleep_os(int ms)
+{
+	usleep((unsigned int)ms * 1000);
+}
+
+void rtw_usleep_os(int us)
+{
+	usleep((unsigned int)us);
+}
+
+void rtw_mdelay_os(int ms)
+{
+	up_mdelay((unsigned long)ms);
+}
+
+void rtw_udelay_os(int us)
+{
+	up_udelay((unsigned long)us);
+}
+
+void rtw_yield_os(void)
+{
+	sched_yield();
+}
+
+
diff --git a/os/board/rtl8720e/src/component/os_dep/osdep_service_time.h b/os/board/rtl8720e/src/component/os_dep/osdep_service_time.h
new file mode 100755
index 000000000..d3192dadc
--- /dev/null
+++ b/os/board/rtl8720e/src/component/os_dep/osdep_service_time.h
@@ -0,0 +1,146 @@
+/******************************************************************************
+ * Copyright (c) 2013-2016 Realtek Semiconductor Corp.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ ******************************************************************************/
+
+#ifndef __OSDEP_SERVICE_TIME_H_
+#define __OSDEP_SERVICE_TIME_H_
+
+/*
+ *      These inlines deal with timer wrapping correctly. You are
+ *      strongly encouraged to use them
+ *      1. Because people otherwise forget
+ *      2. Because if the timer wrap changes in future you wont have to
+ *         alter your driver code.
+ *
+ * time_after(a,b) returns true if the time a is after time b.
+ *
+ * Do this with "<0" and ">=0" to only test the sign of the result. A
+ * good compiler would generate better code (and a really good compiler
+ * wouldn't care). Gcc is currently neither.
+ */
+#ifndef time_after
+#define time_after(a,b)	((long)(b) - (long)(a) < 0)
+#endif
+#ifndef time_before
+#define time_before(a,b)	time_after(b,a)
+#endif
+#ifndef time_after_eq
+#define time_after_eq(a,b)	((long)(a) - (long)(b) >= 0)
+#endif
+#ifndef time_before_eq
+#define time_before_eq(a,b)	time_after_eq(b,a)
+#endif
+
+#define TIMER_MAX_DELAY    				0xFFFFFFFF
+
+#ifndef mdelay
+#define mdelay(t)					((t/portTICK_RATE_MS)>0)?(vTaskDelay(t/portTICK_RATE_MS)):(vTaskDelay(1))
+#endif
+
+#ifndef udelay
+#define udelay(t)					((t/(portTICK_RATE_MS*1000))>0)?vTaskDelay(t/(portTICK_RATE_MS*1000)):(vTaskDelay(1))
+#endif
+
+#define rtw_warn_on(condition) do {} while (0)
+
+
+/*************************** Time Management *******************************/
+
+/**
+ * @brief  Get the count of ticks since the vTaskStartScheduler was called.
+ * @return	The count of ticks since the vTaskStartScheduler was called.
+ */
+uint32_t	rtw_get_current_time(void);
+
+/**
+ * @brief  Convert system time to milliseconds.
+ * @param[in] systime: The system time to be converted.
+ * @return : The milliseconds that converted by the system time.
+ */
+uint32_t	rtw_systime_to_ms(uint32_t systime);
+
+/**
+ * @brief  Convert system time to seconds.
+ * @param[in] systime: The system time to be converted.
+ * @return : The seconds that converted by the system time.
+ */
+uint32_t rtw_systime_to_sec(uint32_t systime);
+
+/**
+ * @brief  Convert milliseconds to system time.
+ * @param[in] systime: The milliseconds to be converted.
+ * @return : The system time that converted by the milliseconds.
+ */
+uint32_t	rtw_ms_to_systime(uint32_t ms);
+
+/**
+ * @brief  Convert seconds to system time.
+ * @param[in] systime: The seconds to be converted.
+ * @return : The system time that converted by the seconds.
+ */
+uint32_t	rtw_sec_to_systime(uint32_t sec);
+
+/**
+ * @brief  Get the passing time from the "start" in milliseconds.
+ * @param[in] start: The start time which is in system time format.
+ * @return : The passing time from "start" in milliseconds.
+ */
+int32_t	rtw_get_passing_time_ms(uint32_t start);
+
+/**
+ * @brief  Get the interval time from the "start" to "end" in milliseconds.
+ * @param[in] start: The start time which is in system time format.
+ * @param[in] end: The end time which is in system time format.
+ * @return : The interval time from "start" to "end" in milliseconds.
+ */
+int32_t	rtw_get_time_interval_ms(uint32_t start, uint32_t end);
+/*************************** End Time Management *******************************/
+
+/**
+ * @brief  This function suspends execution of the calling thread for "ms" milliseconds.
+ * @param[in] ms: The time that the function sleep in milliseconds
+ * @return	  None
+*/
+void	rtw_msleep_os(int ms);
+
+/**
+ * @brief  This function suspends execution of the calling thread for "us" microseconds.
+ * @param[in] ms: The time that the function sleep in microseconds
+ * @return	  None
+*/
+void	rtw_usleep_os(int us);
+
+
+/**
+ * @brief  This function delays a task for the giving time in milliseconds.
+ * @param[in] ms: The amount of time, in milliseconds, that the calling task should block.
+ * @return	  None
+*/
+void	rtw_mdelay_os(int ms);
+
+/**
+ * @brief  This function delays a task for the giving time in microseconds.
+ * @param[in] ms: The amount of time, in microseconds, that the calling task should block.
+ * @return	  None
+*/
+void	rtw_udelay_os(int us);
+
+/**
+ * @brief  This function for forcing a context switch.
+ * @return	  None
+*/
+void	rtw_yield_os(void);
+
+#endif
diff --git a/os/board/rtl8720e/src/component/os_dep/osdep_service_timer.c b/os/board/rtl8720e/src/component/os_dep/osdep_service_timer.c
new file mode 100755
index 000000000..e15d6a0dc
--- /dev/null
+++ b/os/board/rtl8720e/src/component/os_dep/osdep_service_timer.c
@@ -0,0 +1,187 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2012 Realtek Corporation. All rights reserved.
+ *
+ ******************************************************************************/
+// #include <FreeRTOS.h>
+// #include <timers.h>
+#include <osdep_service.h>
+#include <stdio.h>
+#include <freertos_pmu.h>
+
+extern void timer_wrapper(_timerHandle timer_hdl);
+struct _rtw_timer_entry {
+	struct list_head list;
+	struct timer_list_priv *timer;
+};
+static _list _rtw_timer_table;
+static _mutex _rtw_timer_mutex = NULL;
+
+_timerHandle rtw_timerCreate(const signed char *pcTimerName,
+							 u32 xTimerPeriodInTicks,
+							 u32 uxAutoReload,
+							 void *pvTimerID,
+							 TIMER_FUN pxCallbackFunction)
+{
+	struct timer_list_priv *timer = (struct timer_list_priv *)kmm_zalloc(sizeof(struct timer_list_priv));
+	if (timer == NULL) {
+		DBG_ERR("Fail to alloc priv\n");
+		return NULL;
+	}
+#ifdef CONFIG_DEBUG_MM_HEAPINFO
+	DEBUG_SET_CALLER_ADDR(timer);
+#endif
+	timer->work_hdl = (struct work_s *)kmm_zalloc(sizeof(struct work_s));
+	if (timer->work_hdl == NULL) {
+		DBG_ERR("Fail to alloc timer->work_hdl\n");
+		kmm_free(timer);
+		return NULL;
+	}
+#ifdef CONFIG_DEBUG_MM_HEAPINFO
+	DEBUG_SET_CALLER_ADDR(timer->work_hdl);
+#endif
+	timer->live = 0;
+	timer->timevalue = xTimerPeriodInTicks;
+	timer->data = pvTimerID;
+	timer->function = pxCallbackFunction;
+
+	if(_rtw_timer_mutex == NULL) {
+		unsigned int irq_flags = save_and_cli();
+		if(_rtw_timer_mutex == NULL) {
+			rtw_mutex_init(&_rtw_timer_mutex);
+			INIT_LIST_HEAD(&_rtw_timer_table);
+		}
+		restore_flags(irq_flags);
+	}
+
+	struct _rtw_timer_entry *timer_entry;
+	timer_entry = (struct _rtw_timer_entry *)kmm_zalloc(sizeof(struct _rtw_timer_entry));
+	if (timer_entry == NULL) {
+		kmm_free(timer->work_hdl);
+		kmm_free(timer);
+		return NULL;
+	}
+#ifdef CONFIG_DEBUG_MM_HEAPINFO
+	DEBUG_SET_CALLER_ADDR(timer_entry);
+#endif
+	timer_entry->timer = timer;
+
+	rtw_mutex_get(&_rtw_timer_mutex);
+	list_add(&(timer_entry->list), &_rtw_timer_table);
+	rtw_mutex_put(&_rtw_timer_mutex);
+
+	return (_timerHandle) timer;
+}
+
+u32 rtw_timerDelete(_timerHandle xTimer,
+					u32 xBlockTime)
+{
+	struct timer_list_priv *timer = (struct timer_list_priv *)xTimer;
+
+	_list *plist;
+	struct _rtw_timer_entry *timer_entry;
+
+	int ret = work_cancel(LPWORK, timer->work_hdl);
+	if (ret != OK && ret != -ENOENT) {
+		DBG_ERR(" failed! ret = %d\n", ret);
+		return _FAIL;
+	}
+
+	rtw_mutex_get(&_rtw_timer_mutex);
+	plist = get_next(&_rtw_timer_table);
+	while ((rtw_end_of_queue_search(&_rtw_timer_table, plist)) == _FALSE) {
+		timer_entry = LIST_CONTAINOR(plist, struct _rtw_timer_entry, list);
+		if (timer_entry->timer == timer) {
+			list_del_init(plist);
+			kmm_free(timer_entry);
+			break;
+		}
+		plist = get_next(plist);
+	}
+	rtw_mutex_put(&_rtw_timer_mutex);
+	if (plist == &_rtw_timer_table) {
+		return _FAIL;
+	}
+
+	timer->data = NULL;
+	timer->timer_hdl = NULL;
+	timer->timevalue = 0;
+	timer->live = 0;
+	kmm_free(timer->work_hdl);
+	kmm_free(timer);
+	return _SUCCESS;
+}
+
+u32 rtw_timerIsTimerActive(_timerHandle xTimer)
+{
+	struct timer_list_priv *timer = (struct timer_list_priv *)xTimer;
+
+	return timer->live;
+}
+
+u32  rtw_timerStop(_timerHandle xTimer,
+				   u32 xBlockTime)
+{
+	struct timer_list_priv *timer = (struct timer_list_priv *)xTimer;
+
+	int ret = work_cancel(LPWORK, timer->work_hdl);
+	if (ret != OK && ret != -ENOENT) {
+		DBG_ERR(" failed! ret = %d\n", ret);
+		return _FAIL;
+	}
+
+	timer->timevalue = 0;
+	timer->live = 0;
+	return _SUCCESS;
+}
+
+void rtw_timer_wrapper(void *timer)
+{
+	_list *plist;
+	struct _rtw_timer_entry *timer_entry = NULL;
+
+	rtw_mutex_get(&_rtw_timer_mutex);
+	plist = get_next(&_rtw_timer_table);
+	while ((rtw_end_of_queue_search(&_rtw_timer_table, plist)) == _FALSE) {
+		timer_entry = LIST_CONTAINOR(plist, struct _rtw_timer_entry, list);
+		if (timer_entry->timer == timer) {
+			break;
+		}
+		plist = get_next(plist);
+	}
+	rtw_mutex_put(&_rtw_timer_mutex);
+
+	if (plist == &_rtw_timer_table) {
+		return;
+	}
+	timer_entry->timer->live = 0;
+
+	if (timer_entry->timer->function) {
+		timer_entry->timer->function(timer);
+	}
+}
+
+u32  rtw_timerChangePeriod(_timerHandle xTimer,
+						   u32 xNewPeriod,
+						   u32 xBlockTime)
+{
+	int ret;
+	struct timer_list_priv *timer = (struct timer_list_priv *)xTimer;
+	ret = work_queue(LPWORK, timer->work_hdl, rtw_timer_wrapper, (void *)(timer), xNewPeriod);
+	if (ret == -EALREADY) {
+		if (work_cancel(LPWORK, timer->work_hdl) != OK) {
+			DBG_ERR("Failed!\n");
+			return _FAIL;
+		}
+		if (work_queue(LPWORK, timer->work_hdl, rtw_timer_wrapper, (void *)(timer), xNewPeriod)) {
+			DBG_ERR("Failed!\n");
+			return _FAIL;
+		}
+	}
+	timer->live = 1;
+
+	return _SUCCESS;
+}
+
+
+
diff --git a/os/board/rtl8720e/src/component/os_dep/osdep_service_timer.h b/os/board/rtl8720e/src/component/os_dep/osdep_service_timer.h
new file mode 100755
index 000000000..50e8ee400
--- /dev/null
+++ b/os/board/rtl8720e/src/component/os_dep/osdep_service_timer.h
@@ -0,0 +1,116 @@
+/******************************************************************************
+ * Copyright (c) 2013-2016 Realtek Semiconductor Corp.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ ******************************************************************************/
+
+#ifndef __OSDEP_SERVICE_TIMER_H_
+#define __OSDEP_SERVICE_TIMER_H_
+
+typedef void	            *_timerHandle;
+typedef void (*TIMER_FUN)(void *context);
+
+struct timer_list {
+	struct list_head list;
+	_timerHandle 	timer_hdl;
+	unsigned long	data;
+	unsigned char statically_alloc;	/*1: static allocate; 0: dynamic allocate */
+	void (*function)(void *);
+};
+
+typedef struct timer_list	_timer;
+#define rtw_timer_list timer_list
+
+/*************************** Timers *******************************/
+
+/**
+ * @brief  This function creates a new software timer instance.
+ * @param[in] pcTimerName:  A text name that is assigned to the timer.
+ * @param[in] xTimerPeriodInTicks: The timer period which is defined in tick periods.
+ * @param[in] uxAutoReload: If uxAutoReload is set to pdTRUE then the timer will
+ * expire repeatedly with a frequency set by the xTimerPeriodInTicks parameter.  If
+ * uxAutoReload is set to pdFALSE then the timer will be a one-shot timer and
+ * enter the dormant state after it expires.
+ * @param[in] pvTimerID: An identifier that is assigned to the timer being created.
+ * @param[in] pxCallbackFunction: The function to call when the timer expires.
+ * @return  If the timer is successfully create then a handle to the newly
+ * created timer is returned.  If the timer cannot be created, then 0 is returned.
+ */
+_timerHandle rtw_timerCreate(const signed char *pcTimerName,
+							 u32 xTimerPeriodInTicks,
+							 uint32_t uxAutoReload,
+							 void *pvTimerID,
+							 TIMER_FUN pxCallbackFunction);
+
+/**
+ * @brief  This function deletes a timer that was previously created using rtw_timerCreate.
+ * @param[in] xTimer:  The handle of the timer being deleted.
+ * @param[in] xBlockTime: Specifies th etime, in ticks, that the calling task should be held in the Blocked
+ *						  State to wait for the delete command to be successfully sent to the timer command queue,
+ *						  should the queue already be full when rtw_timerDelete was called.
+ * @return  pdFAIL will be returned if the delete command could not be sent to
+ * the timer command queue even after xTicksToWait ticks had passed.  pdPASS will
+ * be returned if the command was successfully sent to the timer command queue.
+ * When the command is actually processed will depend on the priority of the
+ * timer service/daemon task relative to other tasks in the system.
+ */
+uint32_t rtw_timerDelete(_timerHandle xTimer, u32 xBlockTime);
+
+/**
+ * @brief  This function queries a timer to see if it is active or dormant.
+ * @param[in] xTimer:  The timer being queried.
+ * @return  pdFALSE will be returned if the timer is dormant.  A value other than
+ * pdFALSE will be returned if the timer is active.
+ * @note  A timer will be dormant if:
+ *     1) It has been created but not started, or
+ *     2) It is an expired one-shot timer that has not been restarted.
+ */
+uint32_t rtw_timerIsTimerActive(_timerHandle xTimer);
+
+/**
+ * @brief  This function stops a timer that was previously started.
+ * @param[in] xTimer:  The handle of the timer being stopped.
+ * @param[in] xBlockTime:  Specifies the time, in ticks, that the calling task should
+ * be held in the Blocked state to wait for the stop command to be successfully
+ * sent to the timer command queue, should the queue already be full when
+ * rtw_timerStop() was called.
+ * @return  pdFAIL will be returned if the stop command could not be sent to
+ * the timer command queue even after xTicksToWait ticks had passed.  pdPASS will
+ * be returned if the command was successfully sent to the timer command queue.
+ * When the command is actually processed will depend on the priority of the
+ * timer service/daemon task relative to other tasks in the system.
+ */
+uint32_t rtw_timerStop(_timerHandle xTimer, u32 xBlockTime);
+
+/**
+ * @brief  This function changes the period of a timer that was previously created.
+ * @param[in] xTimer:  The handle of the timer that is having its period changed.
+ * @param[in] xNewPeriod:  The new period for xTimer.
+ * @param[in] xBlockTime:  Specifies the time, in ticks, that the calling task should
+ * be held in the Blocked state to wait for the change period command to be
+ * successfully sent to the timer command queue, should the queue already be
+ * full when rtw_timerChangePeriod() was called.
+ * @return  pdFAIL will be returned if the change period command could not be
+ * sent to the timer command queue even after xTicksToWait ticks had passed.
+ * pdPASS will be returned if the command was successfully sent to the timer
+ * command queue.  When the command is actually processed will depend on the
+ * priority of the timer service/daemon task relative to other tasks in the
+ * system.
+ */
+uint32_t rtw_timerChangePeriod(_timerHandle xTimer,
+							   u32 xNewPeriod,
+							   u32 xBlockTime);
+
+
+/*************************** End Timers *******************************/
+#endif
diff --git a/os/board/rtl8720e/src/component/os_dep/platform_stdlib.h b/os/board/rtl8720e/src/component/os_dep/platform_stdlib.h
new file mode 100755
index 000000000..74de71395
--- /dev/null
+++ b/os/board/rtl8720e/src/component/os_dep/platform_stdlib.h
@@ -0,0 +1,45 @@
+/******************************************************************************
+ * Copyright (c) 2013-2016 Realtek Semiconductor Corp.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ ******************************************************************************/
+#ifndef __PLATFORM_STDLIB_H__
+#define __PLATFORM_STDLIB_H__
+
+#if defined (CONFIG_PLATFORM_8721D)
+#include "platform_stdlib_rtl8721d.h"
+#elif defined(CONFIG_PLATFORM_8735B)
+#include "platform_stdlib_rtl8735b.h"
+#else
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <stdarg.h> /* va_list */
+#include "ameba.h"
+#endif
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#if defined(CONFIG_PLATFORM_AMEBA_X) && (CONFIG_PLATFORM_AMEBA_X == 0)
+#include "basic_types.h"
+#endif
+
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif //__PLATFORM_STDLIB_H__
+
diff --git a/os/board/rtl8720e/src/component/os_dep/platform_stdlib_rtl8721d.h b/os/board/rtl8720e/src/component/os_dep/platform_stdlib_rtl8721d.h
new file mode 100755
index 000000000..720b69a5d
--- /dev/null
+++ b/os/board/rtl8720e/src/component/os_dep/platform_stdlib_rtl8721d.h
@@ -0,0 +1,110 @@
+#ifndef PLATFORM_STDLIB_8721D_H
+#define PLATFORM_STDLIB_8721D_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#if defined (__IARSTDLIB__)
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <stdint.h>
+#include <stdarg.h> /* va_list */
+#include "diag.h"
+
+#define strsep(str, delim)      	_strsep(str, delim)
+#else
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <stdarg.h> /* va_list */
+#include "diag.h"
+#include "strproc.h"
+#include "memproc.h"
+#include "basic_types.h"
+#include "rtl8721d.h"
+#include "rtl8721d_ram_libc.h"
+#ifndef STD_PRINTF
+#undef printf
+#undef vsnprintf
+#undef sprintf
+#undef snprintf
+#undef sscanf
+#endif
+#undef memchr
+#undef memcmp
+#undef memcpy
+#undef memset
+#undef memmove
+#undef strcmp
+#undef strcpy
+#undef strlen
+#undef strncmp
+#undef strncpy
+#undef strsep
+#undef strtok
+#undef strcat
+#undef strchr
+#undef strncat
+#undef strstr
+#undef atol
+#undef atoi
+#undef strpbrk
+#undef strtoul
+#undef strtol
+#undef rand
+#ifndef STD_PRINTF
+#define printf						_rtl_printf
+#define sprintf						_rtl_sprintf
+#define snprintf					_rtl_snprintf			// NULL function
+#define vsnprintf					_rtl_vsnprintf
+#define sscanf						_rtl_sscanf	//if use sscanf in std libc.a, please delete _strtol_r symbol in rlx8721d_rom_symbol_acut.ld
+#endif
+#define memchr					_memchr
+#define memcmp					_memcmp
+#define memcpy					_memcpy //memcpy_gdma(dst, src, sz)
+#define memmove				_memmove
+#define memset					_memset
+
+#define strchr(s, c)				_strchr(s, c)			// for B-cut ROM
+#define strcmp(str1, str2)			_strcmp(str1, str2)
+#define strcpy					_strcpy
+#define strlen					_strlen
+#define strsep(str, delim)			_strsep(str, delim)
+#define strstr(str1, str2)			_strstr(str1, str2)	// NULL function
+#define strtok(str, delim)			_strtok(str, delim)//_strsep(str, delim)
+#define strcat					_strcat
+
+#define strncmp(str1, str2, cnt)	_strncmp(str1, str2, cnt)
+#define strncpy(dest, src, count)	_strncpy(dest, src, count)
+#define strncat					_strncat
+
+#define strtoul(str, endp, base)		_strtoul(str, endp, base)
+#define strtol(str, endp, base)		_strtol(str, endp, base)
+
+#define atol(str)					_strtol(str,NULL,10)
+#define atoi(str)					_stratoi(str)
+#define strpbrk(cs, ct)			_strpbrk(cs, ct)		// for B-cut ROM
+#define rand						Rand
+#define srand
+
+//extern int _sscanf_patch(const char *buf, const char *fmt, ...);
+//#define sscanf					_sscanf_patch
+
+
+#endif	// defined (__IARSTDLIB__)
+
+extern void *pvPortMalloc(size_t xWantedSize);
+extern void vPortFree(void *pv);
+extern void *pvPortReAlloc(void *pv,  size_t xWantedSize);
+#define malloc                  pvPortMalloc
+#define free                    vPortFree
+#define realloc			pvPortReAlloc
+#define calloc			rtw_calloc
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif // PLATFORM_STDLIB_8721D_H
diff --git a/os/board/rtl8720e/src/component/os_dep/platform_stdlib_rtl8735b.h b/os/board/rtl8720e/src/component/os_dep/platform_stdlib_rtl8735b.h
new file mode 100755
index 000000000..135ceb161
--- /dev/null
+++ b/os/board/rtl8720e/src/component/os_dep/platform_stdlib_rtl8735b.h
@@ -0,0 +1,28 @@
+#ifndef PLATFORM_STDLIB_RTL8735B_H
+#define PLATFORM_STDLIB_RTL8735B_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <stdbool.h>
+
+#ifdef __cplusplus
+}
+#include <atomic>
+#define _Atomic(X) std::atomic< X >
+#else
+#include <stdatomic.h>
+#endif
+
+#define _memcpy(dst, src, sz)	memcpy(dst, src, sz)
+#define _memset(dst, val, sz)	memset(dst, val, sz)
+#define _memcmp(dst, src, sz)	memcmp(dst, src, sz)
+#define _strlen(str)	strlen(str)
+#define _strcmp(s1, s2)	strcmp(s1, s2)
+#define _strncpy(dst, src, cnt)	strncpy(dst, src, cnt)
+#define DiagPrintf		printf
+
+#endif //PLATFORM_STDLIB_RTL8195BHP_H
diff --git a/os/board/rtl8720e/src/component/os_dep/sram0_reserve.c b/os/board/rtl8720e/src/component/os_dep/sram0_reserve.c
new file mode 100755
index 000000000..6fadc8e62
--- /dev/null
+++ b/os/board/rtl8720e/src/component/os_dep/sram0_reserve.c
@@ -0,0 +1,221 @@
+/* Important: Please link this file to SRAM memory
+ */
+
+#include <osdep_service.h>
+
+/* NOTE: struct size must be a 2's power! */
+typedef struct _MemChunk {
+	struct _MemChunk *next;
+	int size;
+} MemChunk;
+
+typedef MemChunk heap_buf_t;
+
+// A heap
+typedef struct Heap {
+	struct _MemChunk *FreeList;     ///< Head of the free list
+} Heap;
+
+/**
+ * Utility macro to allocate a heap of size \a size.
+ *
+ * \param name Variable name for the heap.
+ * \param size Heap size in bytes.
+ */
+#define HEAP_DEFINE_BUF(name, size) \
+	heap_buf_t name[((size) + sizeof(heap_buf_t) - 1) / sizeof(heap_buf_t)]
+
+#define ROUND_UP2(x, pad) (((x) + ((pad) - 1)) & ~((pad) - 1))
+
+#define RESERVED_HEAP_SIZE	(20*1024)	// Important: Must at least 20kbytes for WPS
+
+static struct Heap g_reserved_heap;
+
+static HEAP_DEFINE_BUF(reserved_heap, RESERVED_HEAP_SIZE);
+
+static int g_heap_inited = 0;
+static	_lock	heap_lock;
+
+static void reserved_heap_init(void)
+{
+	/* Initialize heap with a single big chunk */
+	g_reserved_heap.FreeList = (MemChunk *)&reserved_heap;
+	g_reserved_heap.FreeList->next = NULL;
+	g_reserved_heap.FreeList->size = sizeof(reserved_heap);
+
+	g_heap_inited = 1;
+	rtw_spinlock_init(&heap_lock);
+}
+
+static void *reserved_heap_allocmem(int size)
+{
+	MemChunk *chunk, *prev;
+	struct Heap *h = &g_reserved_heap;
+	_irqL 	irqL;
+
+	rtw_enter_critical(&heap_lock, &irqL);
+
+	if (!g_heap_inited)	{
+		reserved_heap_init();
+	}
+
+	/* Round size up to the allocation granularity */
+	size = ROUND_UP2(size, sizeof(MemChunk));
+
+	/* Handle allocations of 0 bytes */
+	if (!size) {
+		size = sizeof(MemChunk);
+	}
+
+	/* Walk on the free list looking for any chunk big enough to
+	 * fit the requested block size.
+	 */
+	for (prev = (MemChunk *)&h->FreeList, chunk = h->FreeList;
+		 chunk;
+		 prev = chunk, chunk = chunk->next) {
+		if (chunk->size >= size) {
+			if (chunk->size == size) {
+				/* Just remove this chunk from the free list */
+				prev->next = chunk->next;
+
+				rtw_exit_critical(&heap_lock, &irqL);
+
+				return (void *)chunk;
+			} else {
+				/* Allocate from the END of an existing chunk */
+				chunk->size -= size;
+
+				rtw_exit_critical(&heap_lock, &irqL);
+
+				return (void *)((uint8_t *)chunk + chunk->size);
+			}
+		}
+	}
+
+	rtw_exit_critical(&heap_lock, &irqL);
+
+	return NULL; /* fail */
+}
+
+
+static void reserved_heap_freemem(void *mem, int size)
+{
+	MemChunk *prev;
+	struct Heap *h = &g_reserved_heap;
+	_irqL 	irqL;
+
+	rtw_enter_critical(&heap_lock, &irqL);
+
+	if (!g_heap_inited)	{
+		reserved_heap_init();
+	}
+
+	/* Round size up to the allocation granularity */
+	size = ROUND_UP2(size, sizeof(MemChunk));
+
+	/* Handle allocations of 0 bytes */
+	if (!size) {
+		size = sizeof(MemChunk);
+	}
+
+	/* Special cases: first chunk in the free list or memory completely full */
+	if (((uint8_t *)mem) < ((uint8_t *)h->FreeList) || !h->FreeList) {
+		/* Insert memory block before the current free list head */
+		prev = (MemChunk *)mem;
+		prev->next = h->FreeList;
+		prev->size = size;
+		h->FreeList = prev;
+	} else { /* Normal case: not the first chunk in the free list */
+		/*
+		 * Walk on the free list. Stop at the insertion point (when mem
+		 * is between prev and prev->next)
+		 */
+		prev = h->FreeList;
+		while (prev->next < (MemChunk *)mem && prev->next) {
+			prev = prev->next;
+		}
+
+		/* Should it be merged with previous block? */
+		if (((uint8_t *)prev) + prev->size == ((uint8_t *)mem)) {
+			/* Yes */
+			prev->size += size;
+		} else { /* not merged with previous chunk */
+			MemChunk *curr = (MemChunk *)mem;
+
+			/* insert it after the previous node
+			 * and move the 'prev' pointer forward
+			 * for the following operations
+			 */
+			curr->next = prev->next;
+			curr->size = size;
+			prev->next = curr;
+
+			/* Adjust for the following test */
+			prev = curr;
+		}
+	}
+
+	/* Also merge with next chunk? */
+	if (((uint8_t *)prev) + prev->size == ((uint8_t *)prev->next)) {
+		prev->size += prev->next->size;
+		prev->next = prev->next->next;
+	}
+
+	rtw_exit_critical(&heap_lock, &irqL);
+}
+
+int sram0_reserve_free_size(void)
+{
+	int free_mem = 0;
+	struct Heap *h = &g_reserved_heap;
+	_irqL 	irqL;
+	MemChunk *chunk;
+
+	rtw_enter_critical(&heap_lock, &irqL);
+
+	if (!g_heap_inited)	{
+		reserved_heap_init();
+	}
+
+	for (chunk = h->FreeList; chunk; chunk = chunk->next) {
+		free_mem += chunk->size;
+	}
+
+	rtw_exit_critical(&heap_lock, &irqL);
+	return free_mem;
+}
+
+void *sram0_reserve_malloc(int size)
+{
+	int *mem;
+
+	size += sizeof(int);
+	if ((mem = (int *)reserved_heap_allocmem(size))) {
+		*mem++ = size;
+	}
+
+	return mem;
+}
+
+void *sram0_reserve_calloc(int num, int size)
+{
+	void *mem;
+
+	if ((mem = sram0_reserve_malloc(num * size))) {
+		memset(mem, 0, num * size);
+	}
+
+	return mem;
+}
+
+void sram0_reserve_free(void *mem)
+{
+	int *_mem = (int *)mem;
+
+	if (_mem) {
+		--_mem;
+		reserved_heap_freemem(_mem, *_mem);
+	}
+}
+
+
diff --git a/os/board/rtl8720e/src/component/stdlib/time64.h b/os/board/rtl8720e/src/component/os_dep/time64.h
old mode 100644
new mode 100755
similarity index 100%
rename from os/board/rtl8720e/src/component/stdlib/time64.h
rename to os/board/rtl8720e/src/component/os_dep/time64.h
diff --git a/os/board/rtl8720e/src/component/soc/amebalite/fwlib/include/ameba_boot.h b/os/board/rtl8720e/src/component/soc/amebalite/fwlib/include/ameba_boot.h
old mode 100644
new mode 100755
index 3e867ef7d..732e925ca
--- a/os/board/rtl8720e/src/component/soc/amebalite/fwlib/include/ameba_boot.h
+++ b/os/board/rtl8720e/src/component/soc/amebalite/fwlib/include/ameba_boot.h
@@ -221,6 +221,43 @@ typedef struct {
 	u8	PSRAMC_CKD;
 } SocClk_Info_TypeDef;
 
+
+typedef struct {
+	void (*rdp_decrypt_func)(u32 addr, u8 *key, u8  cnt, u8 *buf);
+	u32 psram_s_start_addr;
+} BOOT_EXPORT_SYMB_TABLE;
+
+typedef struct {
+	VOID (*RamStartFun)(VOID);
+	VOID (*RamWakeupFun)(VOID);
+	u32 VectorNS;
+} RAM_START_FUNCTION, *PRAM_START_FUNCTION;
+
+typedef struct _RAM_FUNCTION_START_TABLE_ {
+	VOID (*RamStartFun)(VOID);
+	VOID (*RamWakeupFun)(VOID);
+	VOID (*RamPatchFun0)(VOID);
+	VOID (*RamPatchFun1)(VOID);
+	VOID (*RamPatchFun2)(VOID);
+	VOID (*FlashStartFun)(VOID);
+	u32 Img1ValidCode;
+	BOOT_EXPORT_SYMB_TABLE *ExportTable;
+} RAM_FUNCTION_START_TABLE, *PRAM_FUNCTION_START_TABLE;
+
+typedef struct _DSLP_RETENTION_FUNC_TABLE_ {
+	VOID (*DSLPPatchFun0)(VOID);
+	u32	PatchLen;
+} DSLP_RETENTION_FUNC_TABLE, *PDSLP_RETENTION_FUNC_TABLE;
+
+#if defined (ARM_CORE_CM4)
+#define NS_ENTRY    __attribute__((cmse_nonsecure_entry))
+#ifdef __ICCARM__
+typedef __cmse_nonsecure_call void nsfunc(void);
+#else
+typedef void __attribute__((cmse_nonsecure_call)) nsfunc(void);
+#endif
+#endif
+
 typedef u8(*FuncPtr)(void);
 
 extern void SysTick_Handler(void);
diff --git a/os/board/rtl8720e/src/component/soc/amebalite/misc/ameba_wlan_init.c b/os/board/rtl8720e/src/component/soc/amebalite/misc/ameba_wlan_init.c
index 428263179..2c074d4cd 100644
--- a/os/board/rtl8720e/src/component/soc/amebalite/misc/ameba_wlan_init.c
+++ b/os/board/rtl8720e/src/component/soc/amebalite/misc/ameba_wlan_init.c
@@ -54,7 +54,6 @@ static void _wlan_network_deinit_task(void)
 void wlan_initialize(void)
 {
 	// app_mbedtls_init();
-
 	inic_ipc_init_host();
 	inic_ipc_api_init_host();
 
diff --git a/os/board/rtl8720e/src/component/stdlib/platform_stdlib.h b/os/board/rtl8720e/src/component/stdlib/platform_stdlib.h
deleted file mode 100644
index bad990759..000000000
--- a/os/board/rtl8720e/src/component/stdlib/platform_stdlib.h
+++ /dev/null
@@ -1,130 +0,0 @@
-/******************************************************************************
- * Copyright (c) 2013-2016 Realtek Semiconductor Corp.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- ******************************************************************************/
-#ifndef __PLATFORM_STDLIB_H__
-#define __PLATFORM_STDLIB_H__
-
-
-
-
-
-#if defined(CONFIG_PLATFORM_8711B)+\
-		defined(CONFIG_PLATFORM_8721D)+\
-		defined(CONFIG_PLATFORM_8195BHP)+\
-		defined(CONFIG_PLATFORM_8735B)+\
-		defined(USE_STM322xG_EVAL)+\
-		defined(USE_STM324xG_EVAL)+\
-		defined(CONFIG_PLATFOMR_CUSTOMER_RTOS)+\
-		defined(STM32F10X_XL) > 1
-#error "Cannot define two or more platform at one time"
-#endif
-
-
-#if defined (CONFIG_PLATFORM_8711B)
-#ifdef __cplusplus
-extern "C" {
-#endif
-#include "platform_stdlib_rtl8711b.h"
-#ifdef __cplusplus
-}
-#endif
-#elif defined (CONFIG_PLATFORM_8721D)
-#ifdef __cplusplus
-extern "C" {
-#endif
-#include "platform_stdlib_rtl8721d.h"
-#ifdef __cplusplus
-}
-#endif
-#elif defined (CONFIG_PLATFORM_AMEBAD2)
-#ifdef __cplusplus
-extern "C" {
-#endif
-#include "platform_stdlib_amebad2.h"
-#ifdef __cplusplus
-}
-#endif
-
-#elif defined (CONFIG_PLATFORM_AMEBALITE)
-#ifdef __cplusplus
-extern "C" {
-#endif
-#include "platform_stdlib_amebalite.h"
-#ifdef __cplusplus
-}
-#endif
-#elif defined (CONFIG_PLATFORM_AMEBADPLUS)
-#ifdef __cplusplus
-extern "C" {
-#endif
-#include "platform_stdlib_amebadplus.h"
-#ifdef __cplusplus
-}
-#endif
-#elif defined(CONFIG_PLATFORM_8195BHP)
-#ifdef __cplusplus
-extern "C" {
-#endif
-#include "platform_stdlib_rtl8195bhp.h"
-#ifdef __cplusplus
-}
-#endif
-#elif defined(CONFIG_PLATFORM_8735B)
-#include "platform_stdlib_rtl8735b.h"
-#elif defined(USE_STM322xG_EVAL) || defined(USE_STM324xG_EVAL)  || defined(STM32F10X_XL)
-#ifdef __cplusplus
-extern "C" {
-#endif
-#include "platform_stdlib_stm32.h"
-#ifdef __cplusplus
-}
-#endif
-#elif defined(CONFIG_PLATFOMR_CUSTOMER_RTOS)
-#ifdef __cplusplus
-extern "C" {
-#endif
-#include "platform_stdlib_customer.h"
-#ifdef __cplusplus
-}
-#endif
-#elif defined (CONFIG_PLATFORM_8710C)
-#ifdef __cplusplus
-extern "C" {
-#endif
-#include "platform_stdlib_rtl8710c.h"
-#ifdef __cplusplus
-}
-#endif
-#else
-#error "Undefined Platform stdlib"
-#endif
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-#if defined(CONFIG_PLATFORM_AMEBA_X) && (CONFIG_PLATFORM_AMEBA_X == 0)
-#ifndef CONFIG_PLATFOMR_CUSTOMER_RTOS
-#include "basic_types.h"
-#endif
-#endif
-
-
-#ifdef __cplusplus
-}
-#endif
-
-#endif //__PLATFORM_STDLIB_H__
-
diff --git a/os/board/rtl8720e/src/component/stdlib/platform_stdlib_amebalite.h b/os/board/rtl8720e/src/component/stdlib/platform_stdlib_amebalite.h
deleted file mode 100644
index 209be6c05..000000000
--- a/os/board/rtl8720e/src/component/stdlib/platform_stdlib_amebalite.h
+++ /dev/null
@@ -1,16 +0,0 @@
-#ifndef PLATFORM_STDLIB_AMEBALITE_H
-#define PLATFORM_STDLIB_AMEBALITE_H
-
-#define CONFIG_PLATFORM_AMEBA_X 1
-
-#include <stdio.h>
-#include <stdlib.h>
-#include <string.h>
-#include <stdarg.h> /* va_list */
-
-
-#include "ameba.h"
-#undef rand
-#define rand						_rand
-
-#endif // PLATFORM_STDLIB_AMEBALITE_H
diff --git a/os/board/rtl8720e/src/component/wifi/api/rtw_drv_api.h b/os/board/rtl8720e/src/component/wifi/api/rtw_drv_api.h
new file mode 100755
index 000000000..18bb6b5d5
--- /dev/null
+++ b/os/board/rtl8720e/src/component/wifi/api/rtw_drv_api.h
@@ -0,0 +1,113 @@
+/******************************************************************************
+ * Copyright (c) 2013-2016 Realtek Semiconductor Corp.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ ******************************************************************************/
+#ifndef __RTW_INTF_USER_H__
+#define __RTW_INTF_USER_H__
+
+#ifdef	__cplusplus
+extern "C" {
+#endif
+
+#include "wifi_conf.h"
+
+#define		_1M_RATE_		0
+#define		_2M_RATE_		1
+#define		_5M_RATE_		2
+#define		_11M_RATE_		3
+#define		_6M_RATE_		4
+#define		_9M_RATE_		5
+#define		_12M_RATE_		6
+#define		_18M_RATE_		7
+#define		_24M_RATE_		8
+#define		_36M_RATE_		9
+#define		_48M_RATE_		10
+#define		_54M_RATE_		11
+
+/**
+  * @brief  The enumeration lists the disconnect reasons.
+  */
+  //Defined in rtw_wifi_constants.h
+//typedef enum {
+//	RTW_NO_ERROR,        /**< no error */
+//	RTW_NONE_NETWORK,   /**< none network */
+//	RTW_AUTH_FAIL,            /**< auth fail */
+//	RTW_ASSOC_FAIL,          /**< assocation fail */
+//	RTW_WRONG_PASSWORD, /**< wrong password */
+//	RTW_4WAY_HANDSHAKE_TIMEOUT, /**< 4 way handshake timeout*/
+//	RTW_CONNECT_FAIL,  /**< connect fail*/
+//	RTW_DHCP_FAIL,        /**< dhcp fail*/
+//	RTW_UNKNOWN,         /**< unknown*/
+//} rtw_connect_error_flag_t;
+
+enum WIFI_INDICATE_MODE {
+	WIFI_INDICATE_DISABLE = 0,
+	WIFI_INDICATE_NORMAL = 1,
+	WIFI_INDICATE_WILD = 2,
+	WIFI_INDICATE_MAX,
+};
+
+//----- ------------------------------------------------------------------
+// Wlan Interface opened for upper layer
+//----- ------------------------------------------------------------------
+int wifi_if1_init(void);
+int wifi_if2_init(void);
+void wifi_if1_deinit(void);
+void wifi_if2_deinit(void);
+int wifi_if1_open(void);
+int wifi_if2_open(void);
+void wifi_stop_bss_network(void);
+u8 wifi_set_chplan(u8 chplan);
+int wifi_set_platform_rom_func(void *(*calloc_func)(size_t, size_t),
+							   void (*free_func)(void *),
+							   int (*rand_func)(void *, unsigned char *, size_t));
+void wifi_heap_statistics(u8 start);
+
+extern int rtw_joinbss_set_bssid(unsigned char wlan_idx, __u8 *bssid);
+extern int rtw_bss_set_auth(unsigned char wlan_idx, __u32 value);
+extern int rtw_bss_set_enc(unsigned char wlan_idx, __u16 alg, __u8 *addr, int key_idx, int set_tx, __u8 *seq, __u16 seq_len, __u8 *key, __u16 key_len);
+extern int rtw_bss_set_passphrase(unsigned char wlan_idx, __u8 *passphrase, __u16 passphrase_len);
+extern int rtw_joinbss_start_api(rtw_network_info_t *connect_param);
+extern int rtw_ap_start_api(rtw_softap_info_t *softAP_config, unsigned char value);
+extern int rtw_scan_start_api(rtw_scan_param_t *scan_param, unsigned char block);
+
+extern int wifi_set_freq(unsigned char wlan_idx, __u8 ch);
+extern int wifi_get_freq(unsigned char wlan_idx, __u8 *ch);
+
+#ifdef CONFIG_WOWLAN
+extern int rtw_wowlan_ctrl(unsigned char wlan_idx, rtw_wowlan_option_t type, void *param);
+#endif
+
+extern int wifi_hal_iwpriv_command(unsigned char wlan_idx, char *cmd, int show_msg);
+#define rtw_iwpriv_command(wlan_idx, cmd,show_msg)	wifi_hal_iwpriv_command(wlan_idx, cmd,show_msg)
+
+//promisc related
+extern int promisc_filter_retransmit_pkt(unsigned char enable, unsigned char filter_interval_ms);
+extern int _promisc_set(rtw_rcr_level_t enabled, void (*callback)(unsigned char *, unsigned int, void *), unsigned char len_used);
+extern unsigned char _is_promisc_enabled(void);
+extern int _promisc_get_fixed_channel(void *fixed_bssid, unsigned char *ssid, int *ssid_length);
+extern void _promisc_filter_by_ap_and_phone_mac(unsigned char enable, void *ap_mac, void *phone_mac);
+extern int _promisc_set_mgntframe(unsigned char enable);
+extern int _promisc_get_chnl_by_bssid(unsigned char *bssid);
+extern void _promisc_update_candi_ap_rssi_avg(signed char rssi, unsigned char cnt);
+extern void _promisc_issue_probersp(unsigned char *da);
+extern void _promisc_stop_tx_beacn(void);
+extern void _promisc_resume_tx_beacn(void);
+
+extern int wifi_get_tx_powertable(u32* powertable);
+#ifdef	__cplusplus
+}
+#endif
+
+#endif //#ifndef __RTW_INTF_USER_H__
diff --git a/os/board/rtl8720e/src/component/wifi/api/wifi_conf.c b/os/board/rtl8720e/src/component/wifi/api/wifi_conf.c
old mode 100644
new mode 100755
index 016fe9923..0a8512da9
--- a/os/board/rtl8720e/src/component/wifi/api/wifi_conf.c
+++ b/os/board/rtl8720e/src/component/wifi/api/wifi_conf.c
@@ -1,32 +1,18 @@
 //----------------------------------------------------------------------------//
-//#include <flash/stm32_flash.h>
-#if !defined(CONFIG_MBED_ENABLED) && !defined(CONFIG_PLATFOMR_CUSTOMER_RTOS)
 #include "main.h"
 #if defined(CONFIG_LWIP_LAYER) && CONFIG_LWIP_LAYER
 #include <lwip_netconf.h>
 #include <dhcp/dhcps.h>
 #endif
-#endif
-#include <platform_stdlib.h>
 #include <wifi_conf.h>
 #include <wifi_ind.h>
+#include <rtw_drv_api.h>
 #include <osdep_service.h>
-#include <device_lock.h>
-
-#if (defined(CONFIG_EXAMPLE_UART_ATCMD) && CONFIG_EXAMPLE_UART_ATCMD) || (defined(CONFIG_EXAMPLE_SPI_ATCMD) && CONFIG_EXAMPLE_SPI_ATCMD)
-#include "atcmd_wifi.h"
-#endif
-#if defined(CONFIG_PLATFORM_8721D) || defined(CONFIG_PLATFORM_AMEBAD2) || defined(CONFIG_PLATFORM_8735B) || defined(CONFIG_PLATFORM_AMEBALITE) || defined(CONFIG_PLATFORM_AMEBADPLUS)
-#include "platform_opts_bt.h"
-#endif
 
 #if defined(CONFIG_AS_INIC_NP)
 #include "inic_ipc_api.h"
 #endif
 
-void stop_bss_network(void);
-u8 rtw_set_chplan(u8 chplan);
-
 /******************************************************
  *                    Constants
  ******************************************************/
@@ -39,12 +25,9 @@ u8 rtw_set_chplan(u8 chplan);
 /******************************************************
  *               Variables Declarations
  ******************************************************/
-
-#if !defined(CONFIG_MBED_ENABLED)
 #if defined(CONFIG_LWIP_LAYER) && CONFIG_LWIP_LAYER
 extern struct netif xnetif[NET_IF_NUM];
 #endif
-#endif
 
 extern Rltk_wlan_t	rltk_wlan_info[NET_IF_NUM];
 
@@ -74,6 +57,31 @@ extern void *param_indicator;
 
 #if CONFIG_WLAN
 //----------------------------------------------------------------------------//
+static void *_my_calloc(size_t nelements, size_t elementSize)
+{
+	size_t size;
+	void *ptr = NULL;
+
+	size = nelements * elementSize;
+	ptr = rtw_zmalloc(size);
+
+	return ptr;
+}
+
+static void _my_free(void *pbuf)
+{
+	rtw_free(pbuf);
+}
+
+static int _my_random(void *p_rng, unsigned char *output, size_t output_len)
+{
+	/* To avoid gcc warnings */
+	(void) p_rng;
+
+	rtw_get_random_bytes(output, output_len);
+	return 0;
+}
+
 static void _wifi_join_status_indicate(rtw_join_status_t join_status)
 {
 	/* step 1: internal process for different status*/
@@ -137,7 +145,7 @@ int wifi_connect(rtw_network_info_t *connect_param, unsigned char block)
 		return RTW_BUSY;
 	}
 
-	if (is_promisc_enabled()) {
+	if (_is_promisc_enabled()) {
 		RTW_API_INFO("\npromisc is ongoing, can not do wifi connect now!");
 		return RTW_BUSY;
 	}
@@ -167,7 +175,7 @@ int wifi_connect(rtw_network_info_t *connect_param, unsigned char block)
 	}
 
 	/* step3: set connect cmd to driver*/
-	result = rtw_wx_connect_local(connect_param);
+	result = rtw_joinbss_start_api(connect_param);
 	if (result != RTW_SUCCESS) {
 		rtw_join_status = RTW_JOINSTATUS_FAIL;
 		goto error;
@@ -184,7 +192,7 @@ int wifi_connect(rtw_network_info_t *connect_param, unsigned char block)
 			block_param->join_timeout = RTW_JOIN_TIMEOUT;
 		}
 
-		if (rtw_down_timeout_sema(&block_param->join_sema, block_param->join_timeout) == RTW_FALSE) {
+		if (rtw_down_timeout_sema(&block_param->join_sema, block_param->join_timeout) == _FAIL) {
 			RTW_API_INFO("RTW API: Join bss timeout\r\n");
 			rtw_join_status = RTW_JOINSTATUS_FAIL;
 			result = RTW_TIMEOUT;
@@ -222,7 +230,7 @@ int wifi_disconnect(void)
 	//add extra 2 zero byte for check of #@ in wext_set_bssid()
 	const __u8 null_bssid[ETH_ALEN + 2] = {0, 0, 0, 0, 0, 1, 0, 0};
 
-	if (rtw_wx_set_wap(STA_WLAN_INDEX, (__u8 *)null_bssid) < 0) {
+	if (rtw_joinbss_set_bssid(STA_WLAN_INDEX, (__u8 *)null_bssid) < 0) {
 		RTW_API_INFO("\n\rWEXT: Failed to set bogus BSSID to disconnect");
 		ret = -1;
 	}
@@ -237,7 +245,7 @@ int wifi_is_running(unsigned char wlan_idx)
 
 //----------------------------------------------------------------------------//
 
-void wifi_set_user_config(void)
+_WEAK void wifi_set_user_config(void)
 {
 #ifndef CONFIG_AS_INIC_NP
 	// adaptivity
@@ -259,7 +267,7 @@ void wifi_set_user_config(void)
 #endif
 	wifi_user_config.wifi_wpa_mode = WPA_AUTO_MODE;
 
-	wifi_user_config.g_user_ap_sta_num = NUM_STA;//NUM_STA (2 + AP_STA_NUM)
+	wifi_user_config.g_user_ap_sta_num = AP_STA_NUM;
 
 	/* power save */
 	wifi_user_config.lps_dtim = 0;
@@ -301,6 +309,12 @@ void wifi_set_user_config(void)
 
 	wifi_user_config.auto_reconnect_count = 8;
 	wifi_user_config.auto_reconnect_interval = 5; /* in sec*/
+
+	wifi_user_config.skb_num_np = SKB_NUM_NP;
+	wifi_user_config.skb_num_ap = 0;
+#ifdef CONFIG_MCC_MODE
+	wifi_user_config.en_mcc = (u8) ENABLE;
+#endif
 #endif
 }
 
@@ -318,7 +332,6 @@ static int _wifi_on_boot(void)
 {
 	int ret = 1;
 	static int event_init = 0;
-	struct net_device *pnetdev;
 
 	if (event_init == 0) {
 		init_event_callback_list();
@@ -331,8 +344,7 @@ static int _wifi_on_boot(void)
 
 	wifi_if1_init();
 
-	pnetdev = rtw_get_netdev(STA_WLAN_INDEX);
-	ret = netdev_open(pnetdev);
+	ret = wifi_if1_open();
 	if (ret == 0) {
 		_wifi_is_on = 1;
 
@@ -348,7 +360,7 @@ static int _wifi_on_boot(void)
 	}
 
 	if (wifi_user_config.channel_plan) {
-		rtw_set_chplan(wifi_user_config.channel_plan);
+		wifi_set_chplan(wifi_user_config.channel_plan);
 	}
 
 #if defined(CONFIG_LWIP_LAYER) && CONFIG_LWIP_LAYER
@@ -361,7 +373,6 @@ static int _wifi_on_boot(void)
 static int _wifi_on_ap(void)
 {
 	int ret = 1;
-	struct net_device *pnetdev;
 
 	if (wifi_is_running(SOFTAP_WLAN_INDEX)) {
 		RTW_API_INFO("\n\rWIFI is already running\n");
@@ -374,8 +385,7 @@ static int _wifi_on_ap(void)
 		return ret;
 	}
 
-	pnetdev = rtw_get_netdev(SOFTAP_WLAN_INDEX);
-	ret = netdev_if2_open(pnetdev);
+	ret = wifi_if2_open();
 	if (ret < 0) {
 		RTW_API_INFO("\n\rERROR: Start WIFI AP Interface Failed!\n");
 		wifi_if2_deinit();
@@ -395,10 +405,14 @@ int wifi_on(rtw_mode_t mode)
 	static u32 wifi_boot = 0;
 	int ret = RTW_SUCCESS;
 
+	wifi_set_platform_rom_func(_my_calloc, _my_free, _my_random);
+
 	/* boot on STA */
 	if (wifi_boot == 0) {
 		wifi_boot = 1;
+		//wifi_heap_statistics(1);
 		ret = _wifi_on_boot();
+		//wifi_heap_statistics(0);
 		return ret;
 	}
 
@@ -465,14 +479,10 @@ int wifi_start_ap(rtw_softap_info_t *softAP_config)
 		}
 	}
 
-	if (is_promisc_enabled()) {
+	if (_is_promisc_enabled()) {
 		wifi_set_promisc(0, NULL, 0);
 	}
 
-	ret = rtw_wx_set_mode(wlan_idx, RTW_MODE_MASTER);
-	if (ret < 0) {
-		goto exit;
-	}
 	ret = wifi_set_freq(wlan_idx, softAP_config->channel);	//Set channel before starting ap
 	if (ret < 0) {
 		goto exit;
@@ -506,12 +516,12 @@ int wifi_start_ap(rtw_softap_info_t *softAP_config)
 		goto exit;
 	}
 
-	ret = rtw_wx_set_auth(wlan_idx, RTW_AUTH_ALG_OPEN_SYSTEM);
+	ret = rtw_bss_set_auth(wlan_idx, AUTH_ALG_OPEN_SYSTEM);
 	if (ret == 0) {
-		ret = rtw_wx_set_enc_ext(wlan_idx, alg, NULL, 0, key_idx, 0, 0, ext_key, ext_key_len);
+		ret = rtw_bss_set_enc(wlan_idx, alg, NULL, 0, key_idx, 0, 0, ext_key, ext_key_len);
 	}
 	if (ret == 0 && ext_key == NULL) {
-		ret = rtw_wx_set_passphrase(wlan_idx, (u8 *)softAP_config->password, softAP_config->password_len);
+		ret = rtw_bss_set_passphrase(wlan_idx, (u8 *)softAP_config->password, softAP_config->password_len);
 	}
 
 	if (ret < 0) {
@@ -519,7 +529,7 @@ int wifi_start_ap(rtw_softap_info_t *softAP_config)
 	}
 
 open:
-	ret = rtw_wx_set_ap_essid(softAP_config, 1);
+	ret = rtw_ap_start_api(softAP_config, 1);
 	if (ret < 0) {
 		goto exit;
 	}
@@ -541,7 +551,7 @@ int wifi_stop_ap(void)
 		return RTW_SUCCESS;
 	}
 
-	stop_bss_network();
+	wifi_stop_bss_network();
 
 #if defined(CONFIG_LWIP_LAYER) && CONFIG_LWIP_LAYER
 	dhcps_deinit();
@@ -579,7 +589,7 @@ int wifi_scan_networks(rtw_scan_param_t *scan_param, unsigned char block)
 	/* lock 2s to forbid suspend under scan */
 	rtw_wakelock_timeout(2 * 1000);
 
-	ret = rtw_wx_set_scan(scan_param, block);
+	ret = rtw_scan_start_api(scan_param, block);
 
 	return ret;
 }
diff --git a/os/board/rtl8720e/src/component/wifi/api/wifi_conf.h b/os/board/rtl8720e/src/component/wifi/api/wifi_conf.h
old mode 100644
new mode 100755
index 6b5920b8d..79b736da5
--- a/os/board/rtl8720e/src/component/wifi/api/wifi_conf.h
+++ b/os/board/rtl8720e/src/component/wifi/api/wifi_conf.h
@@ -32,13 +32,11 @@
  */
 
 
-#include "basic_types.h"
-#include "wifi_constants.h"
-#include "wifi_structures.h"
-#include "wlan_intf.h"
-#include "wifi_ind.h"
+#include "rtw_wifi_constants.h"
 #include <platform_stdlib.h>
-#include "bt_intf.h"
+#include "rtw_intf_bt.h"
+#include "dlist.h"
+#include <rtw_skbuff.h>
 
 #ifdef __cplusplus
 extern "C" {
@@ -62,15 +60,7 @@ extern "C" {
 * @brief Create RTW_API_INFO
 */
 #if defined RTW_ENABLE_API_INFO || defined __DOXYGEN__
-#if defined(CONFIG_MBED_ENABLED)
-extern __u32 GlobalDebugEnable;
-#define RTW_API_INFO(...)     do {\
-		if (GlobalDebugEnable) \
-			printf(__VA_ARGS__);\
-	}while(0)
-#else
 #define RTW_API_INFO printf
-#endif
 #else
 #define RTW_API_INFO(args)
 #endif
@@ -173,17 +163,6 @@ extern __u32 GlobalDebugEnable;
 /** @addtogroup Enums
    *@{
    */
-
-/**
- * @brief  The enumeration is wl band type.
- */
-typedef enum  {
-	WL_BAND_2_4G = 0,   ///<2.4g band
-	WL_BAND_5G,            ///<5g band
-	WL_BAND_2_4G_5G_BOTH, ///<2.4g&5g band
-	WL_BANDMAX  ///< max band
-} WL_BAND_TYPE;
-
 #ifndef _CUSTOM_IE_TYPE_
 /**
  * @brief  The enumeration is transmission type for wifi custom ie.
@@ -195,6 +174,14 @@ typedef enum {
 	ASSOC_REQ = BIT(3),
 } rtw_custom_ie_type_t;
 #endif /* _CUSTOM_IE_TYPE_ */
+
+typedef enum  {
+	WL_BAND_2_4G = 0,   ///<2.4g band
+	WL_BAND_5G,            ///<5g band
+	WL_BAND_2_4G_5G_BOTH, ///<2.4g&5g band
+	WL_BANDMAX  ///< max band
+} WL_BAND_TYPE;
+
 /**
   * @}
   */
@@ -212,6 +199,401 @@ typedef struct {
 	unsigned char		block;
 } internal_join_block_param_t;
 
+/**
+  * @brief  The structure is used to describe the unique 6-byte MAC address.
+  */
+typedef struct {
+	unsigned char octet[6]; /**< Unique 6-byte MAC address */
+} rtw_mac_t;
+
+/**
+  * @brief  The structure is used to describe the maclist.
+  */
+typedef struct {
+	unsigned int    count;         /**< Number of MAC addresses in the list    */
+	rtw_mac_t mac_list[1];   /**< Variable length array of MAC addresses */
+} rtw_maclist_t;
+
+/**
+  * @brief  The structure is used to describe the bss info of the network.\n
+  *			It include the version, BSSID, beacon_period, capability, SSID,
+  *			channel, atm_window, dtim_period, RSSI e.g.
+  */
+typedef struct {
+	unsigned int      version;                ///< version field
+	unsigned int      length;                 ///< byte length of data in this record
+	/* starting at version and including IEs */
+	rtw_mac_t     BSSID;
+	unsigned short      beacon_period;          ///< units are Kusec
+	unsigned short      capability;             ///< Capability information
+	unsigned char       SSID_len;
+	unsigned char       SSID[32];
+	unsigned char       channel;
+	unsigned short      atim_window;            ///< units are Kusec
+	unsigned char       dtim_period;            ///< DTIM period
+	signed short       RSSI;                   ///< receive signal strength (in dBm)
+
+	unsigned char       n_cap;                  ///< BSS is 802.11N Capable
+	unsigned int      nbss_cap;               ///< 802.11N BSS Capabilities (based on HT_CAP_*)
+	unsigned char       basic_mcs[MCSSET_LEN];  ///< 802.11N BSS required MCS set
+
+	unsigned short      ie_offset;              ///< offset at which IEs start, from beginning
+	unsigned int      ie_length;             ///< byte length of Information Elements
+} rtw_bss_info_t;
+
+/**
+  * @brief  The structure is used to describe the SSID.
+  */
+typedef struct {
+	unsigned char len;     /**< SSID length */
+	unsigned char val[33]; /**< SSID name (AP name)  */
+} rtw_ssid_t;
+
+typedef int (*wifi_do_fast_connect_ptr)(void);
+typedef int (*write_fast_connect_info_ptr)(unsigned int data1, unsigned int data2);
+typedef void (*ap_channel_switch_callback_t)(unsigned char channel, rtw_channel_switch_res_t ret);
+typedef void (*p_wlan_autoreconnect_hdl_t)(rtw_security_t, char *, int, char *, int, int);
+typedef void (*rtw_joinstatus_callback_t)(rtw_join_status_t join_status);
+
+/**
+  * @brief  The structure is used to describe the setting about SSID,
+  *			security type, password and default channel, used to start AP mode.
+  * @note  The data length of string pointed by ssid should not exceed 32,
+  *        and the data length of string pointed by password should not exceed 64.
+  */
+typedef struct {
+	rtw_ssid_t 			ssid;
+	unsigned char		hidden_ssid;
+	rtw_security_t		security_type;
+	unsigned char 		*password;
+	unsigned char 		password_len;
+	unsigned char		channel;
+} rtw_softap_info_t;
+
+/**
+  * @brief	The structure is used to describe the connection setting about SSID,
+  * 		security type and password,etc., used when connecting to an AP.
+  * @note  The data length of string pointed by ssid should not exceed 32,
+  * 	   and the data length of string pointed by password should not exceed 64.
+  * @note  If this struct is used for wifi connect, the channel is used to config
+  * 	   whether it is a full channel scan(when channel is set to 0), or it will
+  * 	   only scan one channel(do active scan on the configured channel).
+  * @note  pscan_option set to PSCAN_FAST_SURVEY means do fast survey on the specified channel
+  * 	   set to 0 means do normal scan on the specified channel or full channel.
+  */
+typedef struct {
+	rtw_ssid_t					ssid;
+	rtw_mac_t					bssid;
+	rtw_security_t				security_type;
+	unsigned char				*password;
+	int 						password_len;
+	int 						key_id;
+	unsigned char				channel;		/**< set to 0 means full channel scan, set to other value means only scan on the specified channel */
+	unsigned char				pscan_option;	/**< used when the specified channel is set, set to 0 for normal partial scan, set to PSCAN_FAST_SURVEY for fast survey*/
+	rtw_joinstatus_callback_t	joinstatus_user_callback;	/**< user callback for processing joinstatus, please set to NULL if not use it */
+} rtw_network_info_t;
+
+/**
+  * @brief  The structure is used to store the WIFI setting gotten from WIFI driver.
+  */
+typedef struct {
+	rtw_mode_t			mode;   /**< the mode of current wlan interface */
+	unsigned char 		ssid[33];   /**< the ssid of connected AP or softAP */
+	unsigned char		bssid[6];   /**< the bssid of connected AP or softAP */
+	unsigned char		channel;
+	rtw_security_t		security_type;   /**< the security type of connected AP or softAP */
+	unsigned char 		password[65];   /**< the password of connected AP or softAP */
+	unsigned char		key_idx;
+	unsigned char		iw_mode;	/**< RTK_IW_MODE */
+	unsigned char		alg;		/**< RTW_IW_ENC_ALG */
+	unsigned int		auth_type;
+} rtw_wifi_setting_t;
+
+extern rtw_wifi_setting_t wifi_setting[2];
+
+/**
+  * @brief  The structure is used to describe the wifi user configuration
+  */
+struct  wifi_user_conf {
+	unsigned char rtw_adaptivity_en;
+	unsigned char rtw_adaptivity_mode;
+	unsigned char rtw_adaptivity_th_l2h_ini;
+
+	unsigned char rtw_tx_pwr_lmt_enable;	///< 0: disable, 1: enable, 2: Depend on efuse(flash)
+	unsigned char rtw_tx_pwr_by_rate;	///< 0: disable, 1: enable, 2: Depend on efuse(flash)
+	unsigned char rtw_trp_tis_cert_en;
+
+	unsigned char rtw_cmd_tsk_spt_wap3;
+
+	rtw_wpa_mode wifi_wpa_mode;
+
+	unsigned char g_user_ap_sta_num;
+
+	/* power save */
+	unsigned char lps_dtim;
+	unsigned char lps_enter_threshold;
+	unsigned char rtw_power_mgnt;
+	unsigned char rtw_lps_level;
+	unsigned char smart_ps;
+
+	/* AP */
+	unsigned char bForwardingDisabled;
+
+	unsigned char bChDeauthDisabled;
+
+	unsigned char bAcceptAddbaReq;
+	unsigned char bIssueAddbaReq;	///< 0: disable issue addba request, 1: enable issue addba request
+
+	unsigned char ampdu_factor;	///for vht capability IE
+
+	unsigned char bCheckDestAddress; ///< 0: don't check dest mac and ip address for station, 1: check dest mac and ip address for station
+
+	/*
+	The ap_compatibilty_enabled is used to configure the wlan settings, each bit controls one aspect.
+	bit 0: (0: follow 802.11 spec, do not issue deauth, 1(default): issue deauth in 1st REAUTH_TO to be compatible with ap)
+	bit 1: (0: do not check beacon info to connect with AP with multiple SSID, 1(default): check beacon info)
+	bit 2: (0(default): do not issue deauth at start of auth, 1: issue deauth at start of auth)
+	bit 3: (0: do not switch WEP auth algo unless WLAN_STATUS_NOT_SUPPORTED_AUTH_ALG, 1(default): switch WEP auth algo from shared key to open system in 1st REAUTH_TO)
+	other bits: reserved
+	*/
+	unsigned char ap_compatibilty_enabled;
+
+	unsigned char max_roaming_times;
+
+	unsigned char ap_polling_sta;
+
+	unsigned char channel_plan;
+
+	unsigned char country_code;
+
+	/*for auto reconnect*/
+	unsigned char auto_reconnect_count;
+	unsigned char auto_reconnect_interval; // in sec
+
+	/*wifi driver's trx buffer number, each skb occupies about 1.8K bytes of heap, a little difference between different chips*/
+	int skb_num_np;/*In INIC mode for all traffics except tx data, In single core mode for all traffics*/
+	int skb_num_ap;/*In INIC mode for tx data packtes, not used in single core mode*/
+
+	/* for RTS/CTS */
+	unsigned char cts2self;
+
+	/* for MCC */
+	unsigned char en_mcc;
+} ;
+
+extern  struct wifi_user_conf wifi_user_config;
+
+/**
+  * @brief  The structure is used to describe the psk info
+  */
+struct psk_info {
+	unsigned char index;                  ///<  index
+	unsigned char psk_essid[32 + 4]; ///< refer to NDIS_802_11_LENGTH_SSID + 4
+	unsigned char psk_passphrase[64 + 1]; ///< refer to IW_PASSPHRASE_MAX_SIZE + 1
+	unsigned char wpa_global_PSK[20 * 2]; ///< refer to A_SHA_DIGEST_LEN * 2
+};
+
+/**
+  * @brief  The structure is used to describe the sw statistics
+  */
+typedef struct { /* software statistics for tx and rx*/
+	unsigned long   rx_packets;             /*!< total packets received       */
+	unsigned long   tx_packets;             /*!<total packets transmitted    */
+	unsigned long   rx_dropped;             /*!< no space in buffers    */
+	unsigned long   tx_dropped;             /*!< no space available  */
+	unsigned long   rx_bytes;               /*!< total bytes received         */
+	unsigned long   tx_bytes;               /*!< total bytes transmitted      */
+	unsigned long   rx_overflow;            /*!< rx fifo overflow count       */
+	unsigned int    max_skbbuf_used_number; /*!< max skb buffer used number       */
+	unsigned int    skbbuf_used_number;     /*!< current used skbbuf number       */
+	unsigned int    max_skbdata_used_number;/*!< max skb data used number       */
+	unsigned int    skbdata_used_number;    /*!< current used skbdata number       */
+} rtw_sw_statistics_t;
+
+/**
+  * @brief  The structure is used to describe the phy statistics
+  */
+typedef struct {
+	signed char rssi;          /*!<average rssi in 1 sec */
+	signed char snr;          /*!< average snr in 1 sec (not include cck rate)*/
+	/* todo*/
+	unsigned int false_alarm_cck;
+	unsigned int false_alarm_ofdm;
+	unsigned int cca_cck;
+	unsigned int cca_ofdm;
+	unsigned int tx_retry;
+	unsigned short tx_drop;
+	unsigned int rx_drop;
+} rtw_phy_statistics_t;
+
+/**
+* @brief channel scan time
+*/
+typedef struct {
+	unsigned short active_scan_time;      /*!< active scan time per channel, units: millisecond, default is 100ms */
+	unsigned short passive_scan_time;     /*!< passive scan time per channel, units: millisecond, default is 110ms */
+} rtw_channel_scan_time_t;
+
+/**
+  * @brief  The structure is used to describe the scan result of the AP.
+  */
+typedef struct {
+	rtw_ssid_t              SSID;             /**< Service Set Identification (i.e. Name of Access Point)                    */
+	rtw_mac_t               BSSID;            /**< Basic Service Set Identification (i.e. MAC address of Access Point)       */
+	signed short		                  signal_strength;  /**< Receive Signal Strength Indication in dBm. <-90=Very poor, >-30=Excellent */
+	rtw_bss_type_t          bss_type;         /**< Network type                                                              */
+	rtw_security_t          security;         /**< Security type                                                             */
+	rtw_wps_type_t          wps_type;         /**< WPS type                                                                  */
+	unsigned int                      channel;          /**< Radio channel that the AP beacon was received on                          */
+	rtw_802_11_band_t       band;             /**< Radio band                                                                */
+} rtw_scan_result_t;
+
+typedef struct rtw_scan_handler_result {
+    rtw_scan_result_t ap_details;
+    rtw_bool_t        scan_complete;
+    void*               user_data;
+} rtw_scan_handler_result_t;
+
+typedef rtw_result_t (*scan_user_callback_t)(unsigned int ap_num, void *user_data);
+typedef rtw_result_t (*scan_report_each_mode_user_callback_t)(rtw_scan_result_t *scanned_ap_info, void *user_data);
+
+/**
+  * @brief  The structure is used to describe the scan parameters used for scan,
+  * @note  The data length of string pointed by ssid should not exceed 32,
+  *        and the data length of string pointed by password should not exceed 64.
+  */
+typedef struct {
+	rtw_scan_option_t						options;
+	char									*ssid;
+	unsigned char							*channel_list;
+	unsigned char							channel_list_num;
+	rtw_channel_scan_time_t 				chan_scan_time;
+	unsigned short							max_ap_record_num;     /**< config the max number of recorded AP, when set to 0, use default value 64 */
+	void									*scan_user_data;
+	scan_user_callback_t					scan_user_callback;   /**< used for normal asynchronized mode */
+	scan_report_each_mode_user_callback_t	scan_report_each_mode_user_callback; /*used for RTW_SCAN_REPORT_EACH mode */
+} rtw_scan_param_t;
+
+/**
+  * @brief  The structure is used to describe the data description
+  */
+typedef struct {
+	unsigned char wlan_idx;      /**< index of wlan interface which will transmit */
+	unsigned char *buf;          /**< poninter of buf where raw data is stored*/
+	unsigned short buf_len;      /**< the length of raw data*/
+	unsigned short flags;        /**< send options*/
+	unsigned char tx_rate;       /**< specific tx rate, please refer to enum MGN_RATE in wifi_constants.h*/
+	unsigned char retry_limit;   /**< retry limit configure, when set to 0, will use default retry limit 12*/
+	/* todo*/
+	unsigned int tx_power;
+} raw_data_desc_t;
+
+/**
+  * @brief  The structure is used to set WIFI packet filter pattern.
+  */
+typedef struct {
+	unsigned short	offset;     ///< Offset in bytes to start filtering (referenced to the start of the ethernet packet)
+	unsigned short	mask_size;  ///< Size of the mask in bytes
+	unsigned char	*mask;       ///< Pattern mask bytes to be ANDed with the pattern eg. "\xff00" (must be in network byte order)
+	unsigned char	*pattern;    ///< Pattern bytes used to filter eg. "\x0800"  (must be in network byte order)
+} rtw_packet_filter_pattern_t;
+
+/**
+  * @brief  The structure is used to describe the 802.11 frame info
+  */
+typedef struct {
+	unsigned short i_fc;
+	unsigned short i_dur;
+	unsigned char i_addr1[6];
+	unsigned char i_addr2[6];
+	unsigned char i_addr3[6];
+	unsigned short i_seq;
+	unsigned char bssid[6];
+	unsigned char encrypt;
+	signed char rssi;
+#if (defined(CONFIG_UNSUPPORT_PLCPHDR_RPT) && CONFIG_UNSUPPORT_PLCPHDR_RPT) || defined __DOXYGEN__
+	rtw_rx_type_t type;
+#endif
+} ieee80211_frame_info_t;
+
+/**
+  * @brief  The structure is used to describe the packet filter info
+  */
+typedef struct {
+	char filter_id;
+	rtw_packet_filter_pattern_t patt;
+	rtw_packet_filter_rule_t rule;
+	unsigned char enable;
+} rtw_packet_filter_info_t;
+
+/**
+  * @brief  The structure is used to describe the mac filter list
+  */
+typedef struct {
+	struct list_head node;
+	unsigned char mac_addr[6];
+} rtw_mac_filter_list_t;
+
+/**
+  * @brief  The structure is used to describe the cfg parameters used for csi report,
+  * @note  The mac_addr if not specified, the default value must be 0.
+  */
+typedef struct {
+	rtw_csi_group_num group_num;
+	rtw_csi_mode mode;
+	rtw_csi_action act;
+	rtw_csi_accuracy accuracy;
+	unsigned char enable;
+	unsigned char trig_period;  /* unit:ms*/
+	unsigned char data_rate;
+	unsigned char mac_addr[6];
+	unsigned char multi_type;/* 0&1 for multi sta CSI */
+} rtw_csi_action_parm_t;
+
+#if defined CONFIG_RTL8735B || defined __DOXYGEN__
+/**
+  * @brief  The structure is used to describe the wowlan pattern
+  */
+typedef struct {
+	unsigned char eth_da[6];
+	unsigned char eth_sa[6];
+	unsigned char eth_proto_type[2];
+	unsigned char header_len[1];
+	unsigned char ip_proto[1];
+	unsigned char ip_sa[4];
+	unsigned char ip_da[4];
+	unsigned char src_port[2];
+	unsigned char dest_port[2];
+	unsigned char flag2[1];
+	unsigned char mask[6];
+	unsigned char window[2];
+	unsigned char checksum[2];
+	unsigned char urgent_pointer[2];
+	unsigned char payload[64];
+	unsigned char payload_mask[9];
+} wowlan_pattern_t;
+#else
+
+/**
+  * @brief  The structure is used to describe the wowlan pattern
+  */
+typedef struct {
+	unsigned char eth_da[6];
+	unsigned char eth_sa[6];
+	unsigned char eth_proto_type[2];
+	unsigned char header_len[1];
+	//unsigned char header_content[8];
+	unsigned char ip_proto[1];
+	//unsigned char checksum[2];
+	unsigned char ip_sa[4];
+	unsigned char ip_da[4];
+	unsigned char src_port[2];
+	unsigned char dest_port[2];
+	unsigned char mask[5];
+} wowlan_pattern_t;
+#endif
+
+//----------------------------
 /* ie format
  * +-----------+--------+-----------------------+
  * |element ID | length | content in length byte|
@@ -231,6 +613,35 @@ typedef struct _cus_ie {
 	__u8 type;
 } rtw_custom_ie_t, *p_rtw_custom_ie_t;
 #endif /* _CUS_IE_ */
+
+/**
+ * @brief  The structure is used to describe net device
+ */
+struct net_device {
+	void			*priv;		/* pointer to private data */
+	unsigned char		dev_addr[6];	/* set during bootup */
+	int	(*hard_start_xmit)(struct sk_buff *skb, struct net_device *dev);
+};
+
+/**
+ * @brief  The structure is used to describe wlan info
+ */
+typedef struct {
+	struct net_device	dev;		/* Binding wlan driver netdev */
+	void			*skb;		/* pending Rx packet */
+	unsigned int		tx_busy;
+	unsigned int		rx_busy;
+	unsigned char		enable;
+	unsigned char		mac[6];
+	_sema			netif_rx_sema;	/* prevent race condition on .skb in rltk_netif_rx() */
+} Rltk_wlan_t;
+
+extern Rltk_wlan_t rltk_wlan_info[NET_IF_NUM];
+
+#define netdev_priv(dev)		dev->priv
+#define rtw_is_netdev_enable(idx)	(rltk_wlan_info[idx].enable)
+#define rtw_get_netdev(idx)		(&(rltk_wlan_info[idx].dev))
+
 /**
   * @}
   */
@@ -289,7 +700,7 @@ int wifi_is_running(unsigned char wlan_idx);
  * 	Scan for, associate and authenticate with a Wi-Fi network.
  * @param[in]  connect_param: the pointer of a struct which store the connection
  * 	info, including ssid, bssid, password, etc, for details, please refer to struct
- * 	rtw_network_info_t in wifi_structures.h
+ * 	rtw_network_info_t in wifi_conf.h
  * @param[in]  block: if block is set to 1, it means synchronized wifi connect, and this
 * 	API will return until connect is finished; if block is set to 0, it means asynchronized
 * 	wifi connect, and this API will return immediately.
@@ -345,7 +756,7 @@ void wifi_set_join_status(rtw_join_status_t status);
   * report a NULL pointer for notification. So in this way, scan_report_each_mode_user_callback need to
   * be registered in scan_param, and RTW_SCAN_REPORT_EACH need to be set in scan_param->options.Also in
   * this mode, scan_user_callback is no need to be registered.
- * @param[in]  scan_param: refer to struct rtw_scan_param_t in wifi_structures.h.
+ * @param[in]  scan_param: refer to struct rtw_scan_param_t in wifi_conf.h.
  * @param[in]  block: If set to 1, it's synchronized scan and this API will return
  * 	after scan is done. If set to 0, it's asynchronized scan and this API will return
  * 	immediately.
@@ -357,6 +768,34 @@ void wifi_set_join_status(rtw_join_status_t status);
  */
 int wifi_scan_networks(rtw_scan_param_t *scan_param, unsigned char block);
 
+/**
+ * @brief  Get scan results
+ * @param[inout]  AP_num: input the pointer to the number of scanned ap info which
+ * 	want to get, output the number of scanned ap info whicn can actually get.
+ * @param[in]  scan_buf: pointer to the buf where scan result will be stored, the
+ * 	scanned AP info will be stored one by one in form of struct rtw_scan_result_t.
+ * @return  RTW_SUCCESS or RTW_ERROR.
+ * @note  For synchronized scan or asynchronized scan which do not config RTW_SCAN_REPORT_EACH,
+ * 	if once called wifi_scan_networks but not use this API to get scanned AP info,
+ * 	driver memory for these scanned AP will not be freed until next time
+ * 	wifi_scan_networks is called.
+ * @note  For asynchronized scan which config RTW_SCAN_REPORT_EACH, every time a
+ * 	AP is scanned, the AP info will be directly reported through scan_report_each_mode_user_callback
+ * 	and freed after user callback executed, thus there is no need to use this function to get scan result.
+ */
+int wifi_get_scan_records(unsigned int *AP_num, char *scan_buf);
+
+/**
+ * @brief  Abort onoging wifi scan
+ * @return  RTW_SUCCESS or RTW_ERROR.
+ * @note  This is an asynchronized function and will return immediately, return value
+ * 	only indicates whether the scan abort cmd is successfully notified to driver or not.
+ * 	When scan is actually aborted, the user callback registered in wifi_scan_networks
+ * 	will be executed.If there is no wifi scan in progress, this function will just return
+ * 	RTW_SUCCESS and user callback won't be executed.
+ */
+int wifi_scan_abort(void);
+
 /**
  * @brief  Enable or disable IPS. IPS is the abbreviation of Inactive Power Save mode.
  * 	Wi-Fi automatically turns RF off if it is not associated to AP.
@@ -383,7 +822,7 @@ int wifi_set_lps_enable(u8 enable);
  * @brief  Set reconnection mode with configuration.
  * @param[in]  mode: Set 1/0 to enalbe/disable the reconnection mode.
  * @return  0 if success, otherwise return -1.
- * @note  Defining CONFIG_AUTO_RECONNECT in "autoconf.h" needs to be
+ * @note  Defining CONFIG_AUTO_RECONNECT in "rtw_autoconf.h" needs to be
  * 	done before compiling, or this API won't be effective.
  */
 int wifi_config_autoreconnect(__u8 mode);
@@ -394,7 +833,7 @@ int wifi_config_autoreconnect(__u8 mode);
  * 	mode = 0 means autoreconnect is off
  *	mode = 1 means autoreconnect is on
  * @return  0 if get the status of autoreconnect success, otherwise return -1.
- * @note  Defining CONFIG_AUTO_RECONNECT in "autoconf.h" needs to be
+ * @note  Defining CONFIG_AUTO_RECONNECT in "rtw_autoconf.h" needs to be
  * 	done before compiling, or this API won't be effective.
  */
 int wifi_get_autoreconnect(__u8 *mode);
@@ -409,7 +848,7 @@ void wifi_set_no_beacon_timeout(unsigned char timeout_sec);
 /**
  * @brief  Get reason code of latest disassociation or deauthentication.
  * @param[out]  reason_code: A pointer to the variable where the
- * 	reason code will be written.
+ * 	reason code (rtw_connect_error_flag_t) will be written.
  * @return  RTW_SUCCESS or RTW ERROR.
  */
 int wifi_get_disconn_reason_code(unsigned short *reason_code);
@@ -428,7 +867,7 @@ int wifi_set_mode(rtw_mode_t mode);
 /**
  * @brief  Trigger Wi-Fi driver to start an infrastructure Wi-Fi network.
  * @param[in]  softAP_config:the pointer of a struct which store the softAP
- * 	configuration, please refer to struct rtw_softap_info_t in wifi_structures.h
+ * 	configuration, please refer to struct rtw_softap_info_t in wifi_conf.h
  * @warning  If a STA interface is active when this function is called,
  * 	the softAP will start on the same channel as the STA.
  * 	It will NOT use the channel provided!
@@ -667,8 +1106,8 @@ int wifi_promisc_ctrl_packet_rpt(u8 enable);
 /**
  * @brief  check whether current wifi driver is mp or not.
  * @param  None
- * @return  1: CONFIG_MP_INCLUDED is open
- * 	0: CONFIG_MP_INCLUDED is not open
+ * @return  1: drv_mode is RTW_DRV_MODE_MP
+ * 	0: drv_mode is not RTW_DRV_MODE_MP
  */
 u8 wifi_driver_is_mp(void);
 
@@ -904,7 +1343,7 @@ int wifi_set_eap_method(unsigned char eap_method);
  * @param[in]  flags: reserved, set to 0
  * @return  RTW_ERROR or RTW SUCCESS
  */
-int wifi_send_eapol(unsigned char wlan_idx, char *buf, __u16 buf_len, __u16 flags);
+int wifi_if_send_eapol(unsigned char wlan_idx, char *buf, __u16 buf_len, __u16 flags);
 
 /**
  * @brief  Set ble scan duty when coex.
@@ -1133,24 +1572,59 @@ int wifi_csi_config(rtw_csi_action_parm_t *act_param);
  * @param[in]  len: the size of csi raw data
  * @Example:
  *    unsigned char *csi_buf = NULL;
+ *    unsigned int len;
  *    csi_buf = rtw_zmalloc(buf_len);
  *    wifi_csi_report(buf_len,csi_buf,&len);
  * @return  RTW_SUCCESS or RTW_ERROR
  */
 int wifi_csi_report(u32 buf_len, u8 *csi_buf, u32 *len);
+
 /**
-* @}
-*/
+ * @brief  get transmit power table
+ * @param[in]  powertable: powertable
+ * @Example:
+ *    u32* powertable = NULL;
+ *    ret = wifi_get_tx_powertable(powertable);
+ * @return  RTW_SUCCESS or RTW_ERROR
+ */
+int wifi_get_tx_powertable(u32* powertable);
 
 /**
-  * @}
+ * @brief  Set PTA type when coex.
+ * @param[in]  type: the PTA type(PTA_BT/PTA_WIFI/PTA_AUTO).
+ * @return  Null.
+ */
+void wifi_btcoex_set_pta(pta_type_t type);
+
+/**
+  * @brief Write BT RFK  data to RFC
+  * @param  calibration data
+  * @retval  BT RFK result(1:success  0:failed)
   */
+int wifi_btcoex_bt_rfk(struct bt_rfk_param *rfk_param);
+
+/**
+ * @brief  Set global variable wifi_wpa_mode.
+ * @param[in]  wpa_mode:
+ 	(WPA_AUTO_MODE,WPA_ONLY_MODE, WPA2_ONLY_MODE,
+	WPA3_ONLY_MODE,WPA_WPA2_MIXED_MODE, WPA2_WPA3_MIXED_MODE).
+ * @return  0:success  -1:fail.
+ */
+int wifi_set_wpa_mode(rtw_wpa_mode wpa_mode);
+
+/**
+ * @brief  Dynamically modify the working mode of pmf.
+ * @param[in]  pmf_mode:
+ 	0: none
+ 	1: optional
+ 	2: required
+ * @return  0:success  -1:fail.
+ */
+int wifi_set_pmf_mode(u8 pmf_mode);
+
 #ifdef __cplusplus
 }
 #endif
 
-/**
-  * @}
-  */
-
 #endif // __WIFI_API_H
+
diff --git a/os/board/rtl8720e/src/component/wifi/api/wifi_conf_ext_inic_ipc.c b/os/board/rtl8720e/src/component/wifi/api/wifi_conf_ext_inic_ipc.c
old mode 100644
new mode 100755
index 70926084a..f54577880
--- a/os/board/rtl8720e/src/component/wifi/api/wifi_conf_ext_inic_ipc.c
+++ b/os/board/rtl8720e/src/component/wifi/api/wifi_conf_ext_inic_ipc.c
@@ -7,18 +7,10 @@
 //#include <dhcp/dhcps.h>
 #endif
 
-#include <platform_stdlib.h>
 #include <wifi_conf.h>
 #include <wifi_ind.h>
 #include <osdep_service.h>
-#include <device_lock.h>
 
-#if (defined(CONFIG_EXAMPLE_UART_ATCMD) && CONFIG_EXAMPLE_UART_ATCMD) || (defined(CONFIG_EXAMPLE_SPI_ATCMD) && CONFIG_EXAMPLE_SPI_ATCMD)
-#include "at_cmd/atcmd_wifi.h"
-#endif
-#if defined(CONFIG_PLATFORM_8721D) || defined(CONFIG_PLATFORM_AMEBAD2) || defined(CONFIG_PLATFORM_8735B) || defined(CONFIG_PLATFORM_AMEBALITE) || defined(CONFIG_PLATFORM_AMEBADPLUS)
-#include "platform_opts_bt.h"
-#endif
 #ifdef CONFIG_AS_INIC_AP
 #include "inic_ipc_api.h"
 #endif
@@ -384,7 +376,7 @@ int wifi_set_eap_method(unsigned char eap_method)
 #endif
 }
 
-int wifi_send_eapol(unsigned char wlan_idx, char *buf, __u16 buf_len, __u16 flags)
+int wifi_if_send_eapol(unsigned char wlan_idx, char *buf, __u16 buf_len, __u16 flags)
 {
 	int ret = 0;
 	u32 param_buf[4];
@@ -399,7 +391,7 @@ int wifi_send_eapol(unsigned char wlan_idx, char *buf, __u16 buf_len, __u16 flag
 	return ret;
 }
 
-static void _wifi_autoreconnect_thread(void *param)
+static void rtw_autoreconnect_thread(void *param)
 {
 #if CONFIG_AUTO_RECONNECT
 #if defined(configENABLE_TRUSTZONE) && (configENABLE_TRUSTZONE == 1)
@@ -452,12 +444,12 @@ static void _wifi_autoreconnect_thread(void *param)
 
 }
 
-void wifi_autoreconnect_hdl(rtw_security_t security_type,
+#if CONFIG_AUTO_RECONNECT
+void rtw_autoreconnect_hdl(rtw_security_t security_type,
 							char *ssid, int ssid_len,
 							char *password, int password_len,
 							int key_id)
 {
-#if CONFIG_AUTO_RECONNECT
 	static struct wifi_autoreconnect_param param;
 	param_indicator = &param;
 	param.security_type = security_type;
@@ -480,13 +472,13 @@ void wifi_autoreconnect_hdl(rtw_security_t security_type,
 				return;
 			}
 
-			if (wifi_autoreconnect_task.task == 0) {
+			if (wifi_autoreconnect_task.task == NULL) {
 				break;
 			}
 		}
 	}
 
-	rtw_create_task(&wifi_autoreconnect_task, (const char *)"wifi_autoreconnect", 512, 1, _wifi_autoreconnect_thread, &param);
+	rtw_create_task(&wifi_autoreconnect_task, (const char *)"wifi_autoreconnect", 512, 1, rtw_autoreconnect_thread, &param);
 #endif
 }
 
@@ -498,7 +490,7 @@ int wifi_config_autoreconnect(__u8 mode)
 	if (mode == RTW_AUTORECONNECT_DISABLE) {
 		p_wlan_autoreconnect_hdl = NULL;
 	} else {
-		p_wlan_autoreconnect_hdl = wifi_autoreconnect_hdl;
+		p_wlan_autoreconnect_hdl = rtw_autoreconnect_hdl;
 	}
 
 	param_buf[0] = mode;
@@ -856,4 +848,31 @@ int wifi_csi_report(u32 buf_len, u8 *csi_buf, u32 *len)
 }
 //----------------------------------------------------------------------------//
 
+int wifi_get_tx_powertable(u32* powertable)
+{
+	u32 param_buf[1];
+	int ret = 0;
+
+	param_buf[0] = (u32)powertable;
+	DCache_CleanInvalidate((u32)powertable, 28*4);
+	ret = inic_ipc_api_host_message_send(IPC_API_WIFI_GET_TX_POWERTABLE, param_buf, 1);
+	DCache_Invalidate((u32)powertable, 28*4);
+
+	return ret;
+}
+void wifi_print_tx_powertable(void)
+{
+	u32 powertable[28];
+	(void)wifi_get_tx_powertable(powertable);
+
+	vddbg("RTL8720E Realmap\r\n");
+	vddbg("CCK      : %g %g %g %g\r\n",((double)(powertable[3]&0x000000FF)/4),((double)((powertable[3]&0x0000FF00)>>8)/4),((double)((powertable[3]&0x00FF0000)>>16)/4),((double)((powertable[3]&0xFF000000)>>24)/4));
+	vddbg("OFDM     : %g %g %g %g %g %g %g %g\r\n",((double)(powertable[7]&0x000000FF)/4),((double)((powertable[7]&0x0000FF00)>>8)/4),((double)((powertable[7]&0x00FF0000)>>16)/4),((double)((powertable[7]&0xFF000000)>>24)/4),
+			((double)(powertable[11]&0x000000FF)/4),((double)((powertable[11]&0x0000FF00)>>8)/4),((double)((powertable[11]&0x00FF0000)>>16)/4),((double)((powertable[11]&0xFF000000)>>24)/4));
+	vddbg("11nHT20  : %g %g %g %g %g %g %g %g %g %g %g %g \r\n",((double)(powertable[15]&0x000000FF)/4),((double)((powertable[15]&0x0000FF00)>>8)/4),((double)((powertable[15]&0x00FF0000)>>16)/4),((double)((powertable[15]&0xFF000000)>>24)/4),
+			((double)(powertable[19]&0x000000FF)/4),((double)((powertable[19]&0x0000FF00)>>8)/4),((double)((powertable[19]&0x00FF0000)>>16)/4),((double)((powertable[19]&0xFF000000)>>24)/4),
+			((double)(powertable[23]&0x000000FF)/4),((double)((powertable[23]&0x0000FF00)>>8)/4),((double)((powertable[23]&0x00FF0000)>>16)/4),((double)((powertable[23]&0xFF000000)>>24)/4));
+	vddbg("HE DCM   : %g %g %g %g\r\n",((double)(powertable[27]&0x000000FF)/4),((double)((powertable[27]&0x0000FF00)>>8)/4),((double)((powertable[27]&0x00FF0000)>>16)/4),((double)((powertable[27]&0xFF000000)>>24)/4));
+}
+
 #endif	//#if CONFIG_WLAN
diff --git a/os/board/rtl8720e/src/component/wifi/api/wifi_conf_inic_ipc.c b/os/board/rtl8720e/src/component/wifi/api/wifi_conf_inic_ipc.c
old mode 100644
new mode 100755
index 186fdc30a..277f81557
--- a/os/board/rtl8720e/src/component/wifi/api/wifi_conf_inic_ipc.c
+++ b/os/board/rtl8720e/src/component/wifi/api/wifi_conf_inic_ipc.c
@@ -3,25 +3,16 @@
 #include "main.h"
 #if CONFIG_LWIP_LAYER
 #include <lwip_netconf.h>
-//#include <dhcp/dhcps.h>
+// #include <dhcp/dhcps.h>
 #endif
 
-#include <platform_stdlib.h>
 #include <wifi_conf.h>
 #include <wifi_ind.h>
 #include <osdep_service.h>
-#include <device_lock.h>
-
-#if (defined(CONFIG_EXAMPLE_UART_ATCMD) && CONFIG_EXAMPLE_UART_ATCMD) || (defined(CONFIG_EXAMPLE_SPI_ATCMD) && CONFIG_EXAMPLE_SPI_ATCMD)
-#include "at_cmd/atcmd_wifi.h"
-#endif
-#if defined(CONFIG_PLATFORM_8721D) || defined(CONFIG_PLATFORM_AMEBAD2) || defined(CONFIG_PLATFORM_8735B) || defined(CONFIG_PLATFORM_AMEBALITE) || defined(CONFIG_PLATFORM_AMEBADPLUS)
-#include "platform_opts_bt.h"
-#endif
+#include <rtw_timer.h>
 
 #if defined(CONFIG_AS_INIC_AP)
 #include "inic_ipc_api.h"
-#include "freertos/wrapper.h"
 #endif
 /******************************************************
  *                    Constants
@@ -49,6 +40,8 @@ rtw_joinstatus_callback_t p_wifi_joinstatus_internal_callback = NULL;
 
 wifi_do_fast_connect_ptr p_wifi_do_fast_connect = NULL;
 write_fast_connect_info_ptr p_store_fast_connect_info = NULL;
+
+int skb_num_ap;
 /* Give default value if not defined */
 /******************************************************
  *               Function Definitions
@@ -205,7 +198,7 @@ int wifi_connect(rtw_network_info_t *connect_param, unsigned char block)
 #endif
 			block_param->join_timeout = RTW_JOIN_TIMEOUT;
 
-		if (rtw_down_timeout_sema(&block_param->join_sema, block_param->join_timeout) == RTW_FALSE) {
+		if (rtw_down_timeout_sema(&block_param->join_sema, block_param->join_timeout) == _FAIL) {
 			RTW_API_INFO("RTW API: Join bss timeout\r\n");
 			rtw_join_status = RTW_JOINSTATUS_FAIL;
 			result = RTW_TIMEOUT;
@@ -318,7 +311,7 @@ int wifi_get_channel(int *channel)
 	return ret;
 }
 
-void wifi_set_user_config(void)
+_WEAK void wifi_set_user_config(void)
 {
 	u32 param_buf[1];
 	struct wifi_user_conf *p_wifi_user_config = (struct wifi_user_conf *)rtw_zmalloc(sizeof(struct wifi_user_conf));
@@ -342,7 +335,7 @@ void wifi_set_user_config(void)
 #endif
 	p_wifi_user_config->wifi_wpa_mode = WPA_AUTO_MODE;
 
-	p_wifi_user_config->g_user_ap_sta_num = NUM_STA;//NUM_STA (2 + AP_STA_NUM)
+	p_wifi_user_config->g_user_ap_sta_num = NUM_STA;
 
 	/* power save */
 	p_wifi_user_config->lps_dtim = 0;
@@ -385,6 +378,15 @@ void wifi_set_user_config(void)
 	p_wifi_user_config->auto_reconnect_count = 8;
 	p_wifi_user_config->auto_reconnect_interval = 5;/* in sec*/
 
+	p_wifi_user_config->skb_num_np = SKB_NUM_NP;
+	p_wifi_user_config->skb_num_ap = SKB_NUM_AP;
+
+#ifdef CONFIG_MCC_MODE
+	p_wifi_user_config->en_mcc = (u8) ENABLE;
+#endif
+
+	skb_num_ap = p_wifi_user_config->skb_num_ap;
+
 	DCache_Clean((u32)p_wifi_user_config, sizeof(struct wifi_user_conf));
 	param_buf[0] = (u32)p_wifi_user_config;
 	inic_ipc_api_host_message_send(IPC_API_WIFI_SET_USR_CFG, param_buf, 1);
@@ -463,6 +465,7 @@ int wifi_off(void)
 {
 	int ret = 0;
 
+	//inic_ipc_host_deinit_skb();/*should be called after np deinit*/
 	return ret;
 }
 
@@ -525,7 +528,7 @@ int wifi_start_ap(rtw_softap_info_t *softAP_config)
 	DCache_Clean((u32)softAP_config->password, softAP_config->password_len);
 	DCache_Clean((u32)softAP_config, sizeof(rtw_softap_info_t));
 	param_buf[0] = (u32)softAP_config;
-	
+
 #if defined(CONFIG_PLATFORM_TIZENRT_OS)
 	wifi_reg_event_handler(WIFI_EVENT_STA_ASSOC, wifi_ap_sta_assoc_hdl, NULL);
 	wifi_reg_event_handler(WIFI_EVENT_STA_DISASSOC, wifi_ap_sta_disassoc_hdl, NULL);
diff --git a/os/board/rtl8720e/src/component/wifi/api/wifi_conf_inter_inic_ipc.c b/os/board/rtl8720e/src/component/wifi/api/wifi_conf_inter_inic_ipc.c
old mode 100644
new mode 100755
index 856470273..5095d024b
--- a/os/board/rtl8720e/src/component/wifi/api/wifi_conf_inter_inic_ipc.c
+++ b/os/board/rtl8720e/src/component/wifi/api/wifi_conf_inter_inic_ipc.c
@@ -9,17 +9,9 @@
 #endif
 
 #include <platform_stdlib.h>
-#include <wifi_conf_inter.h>
+#include <wifi_conf.h>
 #include <wifi_ind.h>
-#include <osdep_service.h>
-#include <device_lock.h>
 
-#if (defined(CONFIG_EXAMPLE_UART_ATCMD) && CONFIG_EXAMPLE_UART_ATCMD) || (defined(CONFIG_EXAMPLE_SPI_ATCMD) && CONFIG_EXAMPLE_SPI_ATCMD)
-#include "at_cmd/atcmd_wifi.h"
-#endif
-#if defined(CONFIG_PLATFORM_8721D) || defined(CONFIG_PLATFORM_AMEBAD2) || defined(CONFIG_PLATFORM_8735B) || defined(CONFIG_PLATFORM_AMEBALITE) || defined(CONFIG_PLATFORM_AMEBADPLUS)
-#include "platform_opts_bt.h"
-#endif
 #ifdef CONFIG_AS_INIC_AP
 #include "inic_ipc_api.h"
 #endif
diff --git a/os/board/rtl8720e/src/component/wifi/api/wifi_conf_wowlan.c b/os/board/rtl8720e/src/component/wifi/api/wifi_conf_wowlan.c
old mode 100644
new mode 100755
index bc9f47db6..3a2d8484e
--- a/os/board/rtl8720e/src/component/wifi/api/wifi_conf_wowlan.c
+++ b/os/board/rtl8720e/src/component/wifi/api/wifi_conf_wowlan.c
@@ -1,15 +1,13 @@
 //----------------------------------------------------------------------------//
 //#include <flash/stm32_flash.h>
-#if !defined(CONFIG_MBED_ENABLED) && !defined(CONFIG_PLATFOMR_CUSTOMER_RTOS)
 #include "main.h"
 #if CONFIG_LWIP_LAYER
 #include "lwipconf.h"
 #include "lwip_netconf.h"
 #endif
-#endif
-#include <platform_stdlib.h>
 #include <wifi_conf.h>
 #include <wifi_ind.h>
+#include <rtw_drv_api.h>
 #include <osdep_service.h>
 #include <device_lock.h>
 
@@ -24,12 +22,9 @@
 /******************************************************
  *               Variables Declarations
  ******************************************************/
-
-#if !defined(CONFIG_MBED_ENABLED)
 #if CONFIG_LWIP_LAYER
 extern struct netif xnetif[NET_IF_NUM];
 #endif
-#endif
 
 /******************************************************
  *               Variables Definitions
@@ -307,7 +302,7 @@ int wifi_set_tcp_keep_alive_offload(int socket_fd, uint8_t *content, size_t len,
 	memcpy(eth_frame + sizeof(eth_header) + sizeof(ip_header) + sizeof(tcp_header), content, len);
 
 #ifdef CONFIG_ARP_KEEP_ALIVE
-	rtw_set_arp_rsp_keep_alive(RTW_TRUE, (uint8_t *)dst_ip);
+	rtw_set_arp_rsp_keep_alive(_TRUE, (uint8_t *)dst_ip);
 #endif
 	rtw_set_keepalive_offload(eth_frame, frame_len, interval_ms, resend_ms, wake_sys);
 
diff --git a/os/board/rtl8720e/src/component/wifi/api/wifi_ind.c b/os/board/rtl8720e/src/component/wifi/api/wifi_ind.c
old mode 100644
new mode 100755
index a8d7e9cd1..29618f700
--- a/os/board/rtl8720e/src/component/wifi/api/wifi_ind.c
+++ b/os/board/rtl8720e/src/component/wifi/api/wifi_ind.c
@@ -37,7 +37,7 @@ rtw_result_t rtw_indicate_event_handle(int event_cmd, char *buf, int buf_len, in
 void wifi_indication(rtw_event_indicate_t event, char *buf, int buf_len, int flags)
 {
 	//
-	// If upper layer application triggers additional operations on receiving of wireless_send_event,
+	// If upper layer application triggers additional operations on wireless event,
 	// 		please strictly check current stack size usage (by using uxTaskGetStackHighWaterMark() )
 	//		, and tries not to share the same stack with wlan driver if remaining stack space is
 	//		not available for the following operations.
diff --git a/os/board/rtl8720e/src/component/wifi/api/wifi_ind.h b/os/board/rtl8720e/src/component/wifi/api/wifi_ind.h
old mode 100644
new mode 100755
index 21436f8ff..5e9c74888
--- a/os/board/rtl8720e/src/component/wifi/api/wifi_ind.h
+++ b/os/board/rtl8720e/src/component/wifi/api/wifi_ind.h
@@ -78,7 +78,7 @@ void init_event_callback_list(void);
   * @param[in]  buf_len: The length of the buffer.
   * @param[in]  flags: Indicate some extra information, sometimes it is 0.
   * @retval None
-  * @note  If upper layer application triggers additional operations on receiving of wireless_send_event,
+  * @note  If upper layer application triggers additional operations on receiving of wireless event,
   *			please strictly check current stack size usage (by using uxTaskGetStackHighWaterMark() ),
   *			and tries not to share the same stack with wlan driver if remaining stack space is not available
   *			for the following operations.
diff --git a/os/board/rtl8720e/src/component/wifi/driver/include/HalPwrSeqCmd.h b/os/board/rtl8720e/src/component/wifi/driver/include/HalPwrSeqCmd.h
deleted file mode 100644
index 2e75a28bc..000000000
--- a/os/board/rtl8720e/src/component/wifi/driver/include/HalPwrSeqCmd.h
+++ /dev/null
@@ -1,134 +0,0 @@
-/******************************************************************************
- *
- * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of version 2 of the GNU General Public License as
- * published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
- * more details.
- *
- * You should have received a copy of the GNU General Public License along with
- * this program; if not, write to the Free Software Foundation, Inc.,
- * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
- *
- *
- ******************************************************************************/
-#ifndef __HALPWRSEQCMD_H__
-#define __HALPWRSEQCMD_H__
-
-/*---------------------------------------------*/
-//3 The value of cmd: 4 bits
-/*---------------------------------------------*/
-#define PWR_CMD_READ			0x00
-// offset: the read register offset
-// msk: the mask of the read value
-// value: N/A, left by 0
-// note: dirver shall implement this function by read & msk
-
-#define PWR_CMD_WRITE			0x01
-// offset: the read register offset
-// msk: the mask of the write bits
-// value: write value
-// note: driver shall implement this cmd by read & msk after write
-
-#define PWR_CMD_POLLING			0x02
-// offset: the read register offset
-// msk: the mask of the polled value
-// value: the value to be polled, masked by the msd field.
-// note: driver shall implement this cmd by
-// do{
-// if( (Read(offset) & msk) == (value & msk) )
-// break;
-// } while(not timeout);
-
-#define PWR_CMD_DELAY			0x03
-// offset: the value to delay
-// msk: N/A
-// value: the unit of delay, 0: us, 1: ms
-
-#define PWR_CMD_END				0x04
-// offset: N/A
-// msk: N/A
-// value: N/A
-
-/*---------------------------------------------*/
-//3 The value of base: 4 bits
-/*---------------------------------------------*/
-// define the base address of each block
-#define PWR_BASEADDR_MAC		0x00
-#define PWR_BASEADDR_USB		0x01
-#define PWR_BASEADDR_PCIE		0x02
-#define PWR_BASEADDR_SDIO		0x03
-
-/*---------------------------------------------*/
-//3 The value of interface_msk: 4 bits
-/*---------------------------------------------*/
-#define	PWR_INTF_SDIO_MSK		BIT(0)
-#define	PWR_INTF_USB_MSK		BIT(1)
-#define	PWR_INTF_PCI_MSK		BIT(2)
-#define	PWR_INTF_ALL_MSK		(BIT(0)|BIT(1)|BIT(2)|BIT(3))
-
-/*---------------------------------------------*/
-//3 The value of fab_msk: 4 bits
-/*---------------------------------------------*/
-#define	PWR_FAB_TSMC_MSK		BIT(0)
-#define	PWR_FAB_UMC_MSK			BIT(1)
-#define	PWR_FAB_ALL_MSK			(BIT(0)|BIT(1)|BIT(2)|BIT(3))
-
-/*---------------------------------------------*/
-//3 The value of cut_msk: 8 bits
-/*---------------------------------------------*/
-#define	PWR_CUT_TESTCHIP_MSK	BIT(0)
-#define	PWR_CUT_A_MSK			BIT(1)
-#define	PWR_CUT_B_MSK			BIT(2)
-#define	PWR_CUT_C_MSK			BIT(3)
-#define	PWR_CUT_D_MSK			BIT(4)
-#define	PWR_CUT_E_MSK			BIT(5)
-#define	PWR_CUT_F_MSK			BIT(6)
-#define	PWR_CUT_G_MSK			BIT(7)
-#define	PWR_CUT_ALL_MSK			0xFF
-
-
-typedef enum _PWRSEQ_CMD_DELAY_UNIT_ {
-	PWRSEQ_DELAY_US,
-	PWRSEQ_DELAY_MS,
-} PWRSEQ_DELAY_UNIT;
-
-typedef struct _WL_PWR_CFG_ {
-	u16 offset;
-	u8 cut_msk;
-	u8 fab_msk: 4;
-	u8 interface_msk: 4;
-	u8 base: 4;
-	u8 cmd: 4;
-	u8 msk;
-	u8 value;
-} WLAN_PWR_CFG, *PWLAN_PWR_CFG;
-
-
-#define GET_PWR_CFG_OFFSET(__PWR_CMD)		__PWR_CMD.offset
-#define GET_PWR_CFG_CUT_MASK(__PWR_CMD)		__PWR_CMD.cut_msk
-#define GET_PWR_CFG_FAB_MASK(__PWR_CMD)		__PWR_CMD.fab_msk
-#define GET_PWR_CFG_INTF_MASK(__PWR_CMD)	__PWR_CMD.interface_msk
-#define GET_PWR_CFG_BASE(__PWR_CMD)			__PWR_CMD.base
-#define GET_PWR_CFG_CMD(__PWR_CMD)			__PWR_CMD.cmd
-#define GET_PWR_CFG_MASK(__PWR_CMD)			__PWR_CMD.msk
-#define GET_PWR_CFG_VALUE(__PWR_CMD)		__PWR_CMD.value
-
-
-//================================================================================
-//	Prototype of protected function.
-//================================================================================
-u8 HalPwrSeqCmdParsing(
-	_adapter 		*padapter,
-	u8				CutVersion,
-	u8				FabVersion,
-	u8				InterfaceType,
-	WLAN_PWR_CFG	PwrCfgCmd[]);
-
-#endif
-
diff --git a/os/board/rtl8720e/src/component/wifi/driver/include/HalVerDef.h b/os/board/rtl8720e/src/component/wifi/driver/include/HalVerDef.h
deleted file mode 100644
index fdb4f10de..000000000
--- a/os/board/rtl8720e/src/component/wifi/driver/include/HalVerDef.h
+++ /dev/null
@@ -1,198 +0,0 @@
-/******************************************************************************
- *
- * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of version 2 of the GNU General Public License as
- * published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
- * more details.
- *
- * You should have received a copy of the GNU General Public License along with
- * this program; if not, write to the Free Software Foundation, Inc.,
- * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
- *
- *
- ******************************************************************************/
-#ifndef __HAL_VERSION_DEF_H__
-#define __HAL_VERSION_DEF_H__
-
-#ifndef TRUE
-#define TRUE 	_TRUE
-#endif
-#ifndef FALSE
-#define FALSE	_FALSE
-#endif
-
-// HAL_IC_TYPE_E
-typedef enum tag_HAL_IC_Type_Definition {
-	CHIP_8192S	=	0,
-	CHIP_8188C	=	1,
-	CHIP_8192C	=	2,
-	CHIP_8192D	=	3,
-	CHIP_8723A	=	4,
-	CHIP_8188E	=	5,
-	CHIP_8812	=	6,
-	CHIP_8821	=	7,
-	CHIP_8723B 	=	8,
-	CHIP_8192E 	=	9,
-	CHIP_8195A =	10,
-	CHIP_8710B =    11,
-	CHIP_8188F = 	12,
-	CHIP_8821C	=	13,
-	CHIP_8721D = 	14,
-	CHIP_8723D = 	15,
-	CHIP_8195B =	16,
-	CHIP_8710C =	17,
-	CHIP_8735B =	18,
-	CHIP_8730A = 	19,
-	CHIP_8720E = 	20,
-	CHIP_8730E = 	21,
-} HAL_IC_TYPE_E;
-
-//HAL_CHIP_TYPE_E
-typedef enum tag_HAL_CHIP_Type_Definition {
-	TEST_CHIP 		=	0,
-	NORMAL_CHIP 	=	1,
-	FPGA			=	2,
-} HAL_CHIP_TYPE_E;
-
-//HAL_CUT_VERSION_E
-typedef enum tag_HAL_Cut_Version_Definition {
-	A_CUT_VERSION 		=	0,
-	B_CUT_VERSION 		=	1,
-	C_CUT_VERSION 		=	2,
-	D_CUT_VERSION 		=	3,
-	E_CUT_VERSION 		=	4,
-	F_CUT_VERSION 		=	5,
-	G_CUT_VERSION 		=	6,
-	H_CUT_VERSION 		=	7,
-	I_CUT_VERSION 		=	8,
-	J_CUT_VERSION 		=	9,
-	K_CUT_VERSION 		=	10,
-} HAL_CUT_VERSION_E;
-
-//HAL_IC_VERSION_E
-typedef enum tag_HAL_IC_Version_Definition {
-	IC_VERSION0    =  0,
-	IC_VERSION1    =  1,
-	IC_VERSION2    =  2,
-	IC_VERSION3    =  3,
-	IC_VERSION4    =  4,
-} HAL_IC_VERSION_E;
-
-// HAL_Manufacturer
-typedef enum tag_HAL_Manufacturer_Version_Definition {
-	CHIP_VENDOR_TSMC 	=	0,
-	CHIP_VENDOR_UMC 	=	1,
-	CHIP_VENDOR_SMIC 	=	2,
-} HAL_VENDOR_E;
-
-typedef enum tag_HAL_RF_Type_Definition {
-	RF_TYPE_1T1R 	=	0,
-	RF_TYPE_1T2R 	=	1,
-	RF_TYPE_2T2R	=	2,
-	RF_TYPE_2T3R	=	3,
-	RF_TYPE_2T4R	=	4,
-	RF_TYPE_3T3R	=	5,
-	RF_TYPE_3T4R	=	6,
-	RF_TYPE_4T4R	=	7,
-} HAL_RF_TYPE_E;
-
-typedef	struct tag_HAL_VERSION {
-	HAL_IC_TYPE_E		ICType;
-	HAL_CHIP_TYPE_E		ChipType;
-	HAL_CUT_VERSION_E	CUTVersion;
-	HAL_IC_VERSION_E    ICVersion;
-	HAL_VENDOR_E		VendorType;
-	HAL_RF_TYPE_E		RFType;
-	u8					ROMVer;
-} HAL_VERSION, *PHAL_VERSION;
-
-//VERSION_8192C			VersionID;
-//HAL_VERSION			VersionID;
-
-// Get element
-#define GET_CVID_IC_TYPE(version)			((HAL_IC_TYPE_E)((version).ICType)	)
-#define GET_CVID_CHIP_TYPE(version)			((HAL_CHIP_TYPE_E)((version).ChipType)	)
-#define GET_CVID_RF_TYPE(version)			((HAL_RF_TYPE_E)((version).RFType))
-#define GET_CVID_MANUFACTUER(version)		((HAL_VENDOR_E)((version).VendorType))
-#define GET_CVID_CUT_VERSION(version)		((HAL_CUT_VERSION_E)((version).CUTVersion))
-#define GET_CVID_ROM_VERSION(version)		(((version).ROMVer) & ROM_VERSION_MASK)
-
-//----------------------------------------------------------------------------
-//Common Macro. --
-//----------------------------------------------------------------------------
-//HAL_VERSION VersionID
-
-// HAL_IC_TYPE_E
-#define IS_81XXC(version)				(((GET_CVID_IC_TYPE(version) == CHIP_8192C)||(GET_CVID_IC_TYPE(version) == CHIP_8188C))? TRUE : FALSE)
-#define IS_8723_SERIES(version)			((GET_CVID_IC_TYPE(version) == CHIP_8723A)? TRUE : FALSE)
-#define IS_92D(version)					((GET_CVID_IC_TYPE(version) == CHIP_8192D)? TRUE : FALSE)
-#define IS_8188E(version)					((GET_CVID_IC_TYPE(version) == CHIP_8188E)? TRUE : FALSE)
-#define IS_8192E(version)					((GET_CVID_IC_TYPE(version) == CHIP_8192E)? TRUE : FALSE)
-#define IS_8812_SERIES(version)			((GET_CVID_IC_TYPE(version) == CHIP_8812)? TRUE : FALSE)
-#define IS_8821_SERIES(version)			((GET_CVID_IC_TYPE(version) == CHIP_8821)? TRUE : FALSE)
-#define IS_8723B_SERIES(version)			((GET_CVID_IC_TYPE(version) == CHIP_8723B)? TRUE : FALSE)
-#define IS_8710B_SERIES(version)			((GET_CVID_IC_TYPE(version) == CHIP_8710B)? TRUE : FALSE)
-#define IS_8188F(version)					((GET_CVID_IC_TYPE(version) == CHIP_8188F)? TRUE : FALSE)
-#define IS_8721D_SERIES(version)			((GET_CVID_IC_TYPE(version) == CHIP_8721D)? TRUE : FALSE)
-#define IS_8735B_SERIES(version)			((GET_CVID_IC_TYPE(version) == CHIP_8735B)? TRUE : FALSE)
-#define IS_8730A_SERIES(version)			((GET_CVID_IC_TYPE(version) == CHIP_8730A)? TRUE : FALSE)
-#define IS_8720E_SERIES(version)			((GET_CVID_IC_TYPE(version) == CHIP_8720E)? TRUE : FALSE)
-
-//HAL_CHIP_TYPE_E
-#define IS_TEST_CHIP(version)			((GET_CVID_CHIP_TYPE(version)==TEST_CHIP)? TRUE: FALSE)
-#define IS_NORMAL_CHIP(version)			((GET_CVID_CHIP_TYPE(version)==NORMAL_CHIP)? TRUE: FALSE)
-
-//HAL_CUT_VERSION_E
-#define IS_A_CUT(version)				((GET_CVID_CUT_VERSION(version) == A_CUT_VERSION) ? TRUE : FALSE)
-#define IS_B_CUT(version)				((GET_CVID_CUT_VERSION(version) == B_CUT_VERSION) ? TRUE : FALSE)
-#define IS_C_CUT(version)				((GET_CVID_CUT_VERSION(version) == C_CUT_VERSION) ? TRUE : FALSE)
-#define IS_D_CUT(version)				((GET_CVID_CUT_VERSION(version) == D_CUT_VERSION) ? TRUE : FALSE)
-#define IS_E_CUT(version)				((GET_CVID_CUT_VERSION(version) == E_CUT_VERSION) ? TRUE : FALSE)
-#define IS_F_CUT(version)				((GET_CVID_CUT_VERSION(version) == F_CUT_VERSION) ? TRUE : FALSE)
-#define IS_I_CUT(version)				((GET_CVID_CUT_VERSION(version) == I_CUT_VERSION) ? TRUE : FALSE)
-#define IS_J_CUT(version)				((GET_CVID_CUT_VERSION(version) == J_CUT_VERSION) ? TRUE : FALSE)
-#define IS_K_CUT(version)				((GET_CVID_CUT_VERSION(version) == K_CUT_VERSION) ? TRUE : FALSE)
-
-//HAL_VENDOR_E
-#define IS_CHIP_VENDOR_TSMC(version)	((GET_CVID_MANUFACTUER(version) == CHIP_VENDOR_TSMC)? TRUE: FALSE)
-#define IS_CHIP_VENDOR_UMC(version)	((GET_CVID_MANUFACTUER(version) == CHIP_VENDOR_UMC)? TRUE: FALSE)
-#define IS_CHIP_VENDOR_SMIC(version)	((GET_CVID_MANUFACTUER(version) == CHIP_VENDOR_SMIC)? TRUE: FALSE)
-
-//HAL_RF_TYPE_E
-#define IS_1T1R(version)					((GET_CVID_RF_TYPE(version) == RF_TYPE_1T1R)? TRUE : FALSE )
-#define IS_1T2R(version)					((GET_CVID_RF_TYPE(version) == RF_TYPE_1T2R)? TRUE : FALSE)
-#define IS_2T2R(version)					((GET_CVID_RF_TYPE(version) == RF_TYPE_2T2R)? TRUE : FALSE)
-#define IS_3T3R(version)					((GET_CVID_RF_TYPE(version) == RF_TYPE_3T3R) ? TRUE : FALSE)
-#define IS_3T4R(version)					((GET_CVID_RF_TYPE(version) == RF_TYPE_3T4R) ? TRUE : FALSE)
-#define IS_4T4R(version)					((GET_CVID_RF_TYPE(version) == RF_TYPE_4T4R) ? TRUE : FALSE)
-
-//----------------------------------------------------------------------------
-//Chip version Macro. --
-//----------------------------------------------------------------------------
-#define IS_81XXC_TEST_CHIP(version)		((IS_81XXC(version) && (!IS_NORMAL_CHIP(version)))? TRUE: FALSE)
-
-#define IS_92C_SERIAL(version)   					((IS_81XXC(version) && IS_2T2R(version)) ? TRUE : FALSE)
-#define IS_81xxC_VENDOR_UMC_A_CUT(version)	(IS_81XXC(version)?(IS_CHIP_VENDOR_UMC(version) ? (IS_A_CUT(version) ? TRUE : FALSE) : FALSE): FALSE)
-#define IS_81xxC_VENDOR_UMC_B_CUT(version)	(IS_81XXC(version)?(IS_CHIP_VENDOR_UMC(version) ? (IS_B_CUT(version) ? TRUE : FALSE) : FALSE): FALSE)
-#define IS_81xxC_VENDOR_UMC_C_CUT(version)	(IS_81XXC(version)?(IS_CHIP_VENDOR_UMC(version) ? (IS_C_CUT(version) ? TRUE : FALSE) : FALSE): FALSE)
-
-#define IS_NORMAL_CHIP92D(version)		(( IS_92D(version))?((GET_CVID_CHIP_TYPE(version)==NORMAL_CHIP)? TRUE: FALSE):FALSE)
-
-#define IS_92D_SINGLEPHY(version)		((IS_92D(version)) ? (IS_2T2R(version) ? TRUE: FALSE) : FALSE)
-#define IS_92D_C_CUT(version)			((IS_92D(version)) ? (IS_C_CUT(version) ? TRUE : FALSE) : FALSE)
-#define IS_92D_D_CUT(version)			((IS_92D(version)) ? (IS_D_CUT(version) ? TRUE : FALSE) : FALSE)
-#define IS_92D_E_CUT(version)			((IS_92D(version)) ? (IS_E_CUT(version) ? TRUE : FALSE) : FALSE)
-
-#define IS_8723A_A_CUT(version)				((IS_8723_SERIES(version)) ? ( IS_A_CUT(version)?TRUE : FALSE) : FALSE)
-#define IS_8723A_B_CUT(version)				((IS_8723_SERIES(version)) ? ( IS_B_CUT(version)?TRUE : FALSE) : FALSE)
-
-#define IS_VENDOR_8188E_I_CUT_SERIES(_Adapter)		((IS_8188E(rtw_get_haldata(_Adapter)->VersionID)) ? ((GET_CVID_CUT_VERSION(rtw_get_haldata(_Adapter)->VersionID) >= I_CUT_VERSION) ? TRUE : FALSE) : FALSE)
-
-#endif
-
diff --git a/os/board/rtl8720e/src/component/wifi/driver/include/autoconf_8720e.h b/os/board/rtl8720e/src/component/wifi/driver/include/autoconf_8720e.h
old mode 100644
new mode 100755
index 7d80293ff..0d855b134
--- a/os/board/rtl8720e/src/component/wifi/driver/include/autoconf_8720e.h
+++ b/os/board/rtl8720e/src/component/wifi/driver/include/autoconf_8720e.h
@@ -23,6 +23,19 @@
 #undef RTL8720E_SUPPORT
 #define RTL8720E_SUPPORT 1
 
+/************************* Default Values of User Configure *****************************/
+/* Upper limit of STAs connected with SoftAP, more STAs connected will cost more heap*/
+#define AP_STA_NUM	5
+/*wifi driver's trx buffer number, each skb cost about 2240 bytes of heap*/
+#ifdef CONFIG_HIGH_TP_TEST
+#define SKB_NUM_NP	10
+#define SKB_NUM_AP	5
+#else
+#define SKB_NUM_NP	6
+#define SKB_NUM_AP	4
+#endif
+/************************* Default Values of User Configure End***************************/
+
 /* Configure for bus */
 #define CONFIG_AXI_HCI
 
@@ -50,7 +63,7 @@
 /* Configurations for power saving */
 #define CONFIG_WOWLAN
 /* enable 1X code in lib_wlan as default (increase 380 bytes) */
-#define CONFIG_EAP
+// #define CONFIG_EAP
 
 #define CONFIG_BT_COEXIST
 
@@ -79,12 +92,8 @@ so use SW AES encrypt with IPSEC.  */
 #define SW_ENCRYPT_HTC_PKT
 #endif
 
-#define RTL8720E_SPECIFIC
 //#define CONFIG_SUPPORT_DYNAMIC_TXPWR  // rtw_phydm_fill_desc_dpt -> todo
 
-/* config for AP mode */
-#define AP_STA_NUM (5)  // reduce ram size, revert this when ddr or psram read
-// Decrease STA due to memory limitation - Alex Fang
 #define NUM_STA (2 + AP_STA_NUM)  // 2 + supported clients
 
 /*halbb halrf config*/
@@ -144,6 +153,14 @@ so use SW AES encrypt with IPSEC.  */
 #define DRV_RF_DBG_TRACE_DISABLE
 #endif
 
+/*Config for SKB Size*/
+#define SKB_CACHE_SZ	32/*max(AP_Core_Cache, NP_Core_Cache)*/
+#define SKB_ALIGNMENT	__attribute__((aligned(SKB_CACHE_SZ)))
+#define TXDESC_SIZE	40
+#define RXDESC_SIZE	24
+#define RXPHYSTS_SIZE 0
+#define WLAN_HW_INFO_LEN	40/*max(TXDESC_SIZE, RXDESC_SIZE+RXPHYSTS_SIZE)*/
+#define WLAN_MAX_ETHFRM_LEN	1514/*max payload size of wifi frame*/
 
 /* debug log level */
 #define RELEASE_WIFI
@@ -152,5 +169,8 @@ so use SW AES encrypt with IPSEC.  */
 #else
 #define RTW_MSG_LEVEL    RTW_MSG_WARNING
 #endif
+
+#define CONFIG_DOSCAN_IN_BUSYTRAFFIC
+#define CONFIG_IOT_RS 1
 #endif /*#ifndef AUTOCONF_8720E_H */
 
diff --git a/os/board/rtl8720e/src/component/wifi/driver/include/autoconf_debug.h b/os/board/rtl8720e/src/component/wifi/driver/include/autoconf_debug.h
old mode 100644
new mode 100755
index b2a9f4425..a92c4f5a4
--- a/os/board/rtl8720e/src/component/wifi/driver/include/autoconf_debug.h
+++ b/os/board/rtl8720e/src/component/wifi/driver/include/autoconf_debug.h
@@ -22,12 +22,9 @@
 //#define CONFIG_DEBUG_RTL871X
 #define DBG 0 /* for phy dm debug */
 
-#if (CONFIG_PLATFORM_AMEBA_X == 1)
 #define WLAN_INTF_DBG		0
 //#define CONFIG_DEBUG_DYNAMIC
 //#define DBG_TX 1
-//#define DBG_XMIT_BUF 1
-//#define DBG_XMIT_BUF_EXT 1
 #define DBG_TX_DROP_FRAME
 #define CONFIG_DBG_DISABLE_RDU_INTERRUPT
 
@@ -40,7 +37,6 @@
 /***************************** BB debug ***************************************/
 #define DBG_RX_INFO 1
 #define DBG_DM_DIG 1			/* DebugComponents: bit0 */
-#define DBG_DM_RA_MASK 1		/* DebugComponents: bit1 */
 #define DBG_DM_ANT_DIV 1		/* DebugComponents: bit6 */
 #define DBG_TX_RATE 1			/* DebugComponents: bit9 */
 #define DBG_DM_RA 1			/* DebugComponents: bit9 */
@@ -52,9 +48,6 @@
 /************************** PHY common debug **********************************/
 #define DBG_PWR_INDEX 1			// DebugComponents: bit30 */
 #endif /* (DM_DBG == 1) */
-#else /* (CONFIG_PLATFORM_AMEBA_X != 1) */
-//#define WLAN_INTF_DBG
-#endif /* (CONFIG_PLATFORM_AMEBA_X == 1) */
 /***************************** for Debug message ******************************/
 
 
diff --git a/os/board/rtl8720e/src/component/wifi/driver/include/autoconf_eap.h b/os/board/rtl8720e/src/component/wifi/driver/include/autoconf_eap.h
old mode 100644
new mode 100755
index 77f5b9b8a..75dbe9590
--- a/os/board/rtl8720e/src/component/wifi/driver/include/autoconf_eap.h
+++ b/os/board/rtl8720e/src/component/wifi/driver/include/autoconf_eap.h
@@ -28,18 +28,6 @@
 #define CONFIG_TTLS 0
 #endif /* PRE_CONFIG_EAP*/
 
-#if CONFIG_TLS || CONFIG_PEAP || CONFIG_TTLS
-#define EAP_REMOVE_UNUSED_CODE 1
-#endif
-
-#if CONFIG_TTLS
-#define EAP_MSCHAPv2
-#define EAP_TTLS_MSCHAPv2
-//#define EAP_TTLS_EAP
-//#define EAP_TTLS_MSCHAP
-//#define EAP_TTLS_PAP
-//#define EAP_TTLS_CHAP
-#endif
 /************************ End of EAP configurations ***************************/
 
 #endif /* #ifndef AUTOCONF_EAP_H */
diff --git a/os/board/rtl8720e/src/component/wifi/driver/include/autoconf_nic.h b/os/board/rtl8720e/src/component/wifi/driver/include/autoconf_nic.h
deleted file mode 100644
index 959833415..000000000
--- a/os/board/rtl8720e/src/component/wifi/driver/include/autoconf_nic.h
+++ /dev/null
@@ -1,77 +0,0 @@
-/******************************************************************************
- * Copyright (c) 2013-2016 Realtek Semiconductor Corp.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- ******************************************************************************/
-#ifndef AUTOCONF_NIC_H
-#define AUTOCONF_NIC_H
-
-/*************************** Non Ameba Series Start ***************************/
-#if !defined(CONFIG_HARDWARE_8192E)
-#define NOT_SUPPORT_RF_MULTIPATH
-#endif
-
-/* Config for TRX thread */
-#define CONFIG_XMIT_THREAD_MODE
-/* PHY layer band config */
-//#define SUPPORT_5G_CHANNEL
-#define CONFIG_INIT_CHAN 1
-#define NOT_SUPPORT_40M
-/* 0: 20 MHz, 1: 40 MHz, 2: 80 MHz, 3: 160MHz, 4: 80+80MHz
-* 2.4G use bit 0 ~ 3, 5G use bit 4 ~ 7
-* 0x21 means enable 2.4G 40MHz & 5G 80MHz */
-#define  CONFIG_BW_MODE	0x00
-/* PHY layer band config end */
-#if defined(CONFIG_PLATFOMR_CUSTOMER_RTOS)
-#define CONFIG_LWIP_LAYER 0
-#else
-#define PLATFORM_FREERTOS 1
-#endif /* CONFIG_PLATFOMR_CUSTOMER_RTOS */
-
-#define BE_I_CUT 1
-
-/* For multicast */
-#define CONFIG_MULTICAST
-
-#define HAL_MAC_ENABLE 1
-#define HAL_BB_ENABLE 1
-#define HAL_RF_ENABLE 1
-
-#define USE_XMIT_EXTBUFF 0
-
-/* enable 1X code in lib_wlan as default (increase 380 bytes) */
-#define CONFIG_EAP
-
-/* For phydm configurations */
-#define CONFIG_FW_C2H_PKT
-#define PHYDM_VERSION	2 /*phydm trunk*/
-
-/*************************** Non Ameba Series End *****************************/
-
-#define CONFIG_REG_ENABLE_KFREE 0	// 0: Depend on efuse(flash), 1: enable, 2: disable
-
-/*************************** Config for MP_MODE *******************************/
-//#define CONFIG_MP_INCLUDED
-#ifdef CONFIG_MP_INCLUDED
-#define MP_DRIVER 1
-#undef CONFIG_ANTENNA_DIVERSITY
-#undef CONFIG_BT_COEXIST_SOC
-#undef CONFIG_REG_ENABLE_KFREE
-#define CONFIG_REG_ENABLE_KFREE 1	 // 1: enable, 2: disable
-#else /* undef CONFIG_MP_INCLUDED  */
-#define MP_DRIVER 0
-#endif /* #ifdef CONFIG_MP_INCLUDED */
-/************************* Config for MP_MODE end *****************************/
-
-#endif /* #ifndef AUTOCONF_NIC_H */
-
diff --git a/os/board/rtl8720e/src/component/wifi/driver/include/btc_api.h b/os/board/rtl8720e/src/component/wifi/driver/include/btc_api.h
deleted file mode 100644
index 49fab92da..000000000
--- a/os/board/rtl8720e/src/component/wifi/driver/include/btc_api.h
+++ /dev/null
@@ -1,60 +0,0 @@
-/******************************************************************************
- *
- * Copyright(c) 2013 Realtek Corporation. All rights reserved.
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of version 2 of the GNU General Public License as
- * published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
- * more details.
- *
- * You should have received a copy of the GNU General Public License along with
- * this program; if not, write to the Free Software Foundation, Inc.,
- * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
- *
- *
- ******************************************************************************/
-#ifndef __BTC_API_H__
-#define __BTC_API_H__
-
-#include <drv_types.h>
-#include "bt_intf.h"
-
-
-#define	PACKET_NORMAL			0
-#define	PACKET_DHCP				1
-#define	PACKET_ARP				2
-#define	PACKET_EAPOL			3
-
-void rtw_hal_btc_Initialize(PADAPTER padapter);
-void rtw_hal_btc_DeInitialize(PADAPTER);
-void rtw_hal_btc_PowerOnSetting(PADAPTER padapter);
-void rtw_hal_btc_HAL_Initialize(PADAPTER padapter, u8 bWifiOnly);
-void rtw_hal_btc_IpsNotify(PADAPTER, u8 type);
-void rtw_hal_btc_LpsNotify(PADAPTER, u8 type);
-void rtw_hal_btc_ScanNotify(PADAPTER, u8 type);
-void rtw_hal_btc_set_ant_info(PADAPTER padapter);
-void rtw_hal_btc_ConnectNotify(PADAPTER, u8 action);
-void rtw_hal_btc_MediaStatusNotify(PADAPTER, u8 mediaStatus);
-void rtw_hal_btc_SpecialPacketNotify(PADAPTER, u8 pktType);
-void rtw_hal_btc_BtInfoNotify(PADAPTER, u8 length, u8 *tmpBuf);
-void rtw_hal_btc_HaltNotify(PADAPTER);
-void rtw_hal_btc_switchband_notify(u8 under_scan, u8 band_type);
-void rtw_hal_btc_switchchnl_notify(u8 channel, u8 band_type);
-u8 rtw_hal_btc_BtRFK(PADAPTER padapter, struct bt_rfk_param *rfk_param);
-u8 rtw_hal_btc_IsBtDisabled(PADAPTER);
-void rtw_hal_btc_Handler(PADAPTER);
-u8 rtw_hal_btc_IsBtControlLps(PADAPTER);
-u8 rtw_hal_btc_IsLpsOn(PADAPTER);
-u8 rtw_hal_btc_RpwmVal(PADAPTER);
-u8 rtw_hal_btc_LpsVal(PADAPTER);
-void rtw_hal_btc_RecordPwrMode(PADAPTER, u8 *pCmdBuf, u8 cmdLen);
-void rtw_hal_btc_LPS_Enter(PADAPTER);
-void rtw_hal_btc_LPS_Leave(PADAPTER);
-u8 rtw_hal_btc_get_pg_rfe_type(PADAPTER padapter);
-u8 rtw_hal_btc_get_ant_div_cfg(PADAPTER padapter);
-
-#endif /* __BTC_API_H__ */
diff --git a/os/board/rtl8720e/src/component/wifi/driver/include/byteorder/generic.h b/os/board/rtl8720e/src/component/wifi/driver/include/byteorder/generic.h
deleted file mode 100644
index c59d706cf..000000000
--- a/os/board/rtl8720e/src/component/wifi/driver/include/byteorder/generic.h
+++ /dev/null
@@ -1,143 +0,0 @@
-/******************************************************************************
- *
- * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of version 2 of the GNU General Public License as
- * published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
- * more details.
- *
- * You should have received a copy of the GNU General Public License along with
- * this program; if not, write to the Free Software Foundation, Inc.,
- * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
- *
- *
- ******************************************************************************/
-#ifndef _LINUX_BYTEORDER_GENERIC_H
-#define _LINUX_BYTEORDER_GENERIC_H
-
-/*
- * linux/byteorder_generic.h
- * Generic Byte-reordering support
- *
- * Francois-Rene Rideau <fare@tunes.org> 19970707
- *    gathered all the good ideas from all asm-foo/byteorder.h into one file,
- *    cleaned them up.
- *    I hope it is compliant with non-GCC compilers.
- *    I decided to put __BYTEORDER_HAS_U64__ in byteorder.h,
- *    because I wasn't sure it would be ok to put it in types.h
- *    Upgraded it to 2.1.43
- * Francois-Rene Rideau <fare@tunes.org> 19971012
- *    Upgraded it to 2.1.57
- *    to please Linus T., replaced huge #ifdef's between little/big endian
- *    by nestedly #include'd files.
- * Francois-Rene Rideau <fare@tunes.org> 19971205
- *    Made it to 2.1.71; now a facelift:
- *    Put files under include/linux/byteorder/
- *    Split swab from generic support.
- *
- * TODO:
- *   = Regular kernel maintainers could also replace all these manual
- *    byteswap macros that remain, disseminated among drivers,
- *    after some grep or the sources...
- *   = Linus might want to rename all these macros and files to fit his taste,
- *    to fit his personal naming scheme.
- *   = it seems that a few drivers would also appreciate
- *    nybble swapping support...
- *   = every architecture could add their byteswap macro in asm/byteorder.h
- *    see how some architectures already do (i386, alpha, ppc, etc)
- *   = cpu_to_beXX and beXX_to_cpu might some day need to be well
- *    distinguished throughout the kernel. This is not the case currently,
- *    since little endian, big endian, and pdp endian machines needn't it.
- *    But this might be the case for, say, a port of Linux to 20/21 bit
- *    architectures (and F21 Linux addict around?).
- */
-
-/*
- * The following macros are to be defined by <asm/byteorder.h>:
- *
- * Conversion of long and short int between network and host format
- *	ntohl(__u32 x)
- *	ntohs(__u16 x)
- *	htonl(__u32 x)
- *	htons(__u16 x)
- * It seems that some programs (which? where? or perhaps a standard? POSIX?)
- * might like the above to be functions, not macros (why?).
- * if that's true, then detect them, and take measures.
- * Anyway, the measure is: define only ___ntohl as a macro instead,
- * and in a separate file, have
- * unsigned long inline ntohl(x){return ___ntohl(x);}
- *
- * The same for constant arguments
- *	__constant_ntohl(__u32 x)
- *	__constant_ntohs(__u16 x)
- *	__constant_htonl(__u32 x)
- *	__constant_htons(__u16 x)
- *
- * Conversion of XX-bit integers (16- 32- or 64-)
- * between native CPU format and little/big endian format
- * 64-bit stuff only defined for proper architectures
- *	cpu_to_[bl]eXX(__uXX x)
- *	[bl]eXX_to_cpu(__uXX x)
- *
- * The same, but takes a pointer to the value to convert
- *	cpu_to_[bl]eXXp(__uXX x)
- *	[bl]eXX_to_cpup(__uXX x)
- *
- * The same, but change in situ
- *	cpu_to_[bl]eXXs(__uXX x)
- *	[bl]eXX_to_cpus(__uXX x)
- *
- * See asm-foo/byteorder.h for examples of how to provide
- * architecture-optimized versions
- *
- */
-
-/*
- * inside the kernel, we can use nicknames;
- * outside of it, we must avoid POSIX namespace pollution...
- */
-
-#define cpu_to_le64 __cpu_to_le64
-#define le64_to_cpu __le64_to_cpu
-#define cpu_to_le32 __cpu_to_le32
-#define le32_to_cpu __le32_to_cpu
-#define cpu_to_le16 __cpu_to_le16
-#define le16_to_cpu __le16_to_cpu
-#define cpu_to_be64 __cpu_to_be64
-#define be64_to_cpu __be64_to_cpu
-#define cpu_to_be32 __cpu_to_be32
-#define be32_to_cpu __be32_to_cpu
-#define cpu_to_be16 __cpu_to_be16
-#define be16_to_cpu __be16_to_cpu
-#define cpu_to_le64p __cpu_to_le64p
-#define le64_to_cpup __le64_to_cpup
-#define cpu_to_le32p __cpu_to_le32p
-#define le32_to_cpup __le32_to_cpup
-#define cpu_to_le16p __cpu_to_le16p
-#define le16_to_cpup __le16_to_cpup
-#define cpu_to_be64p __cpu_to_be64p
-#define be64_to_cpup __be64_to_cpup
-#define cpu_to_be32p __cpu_to_be32p
-#define be32_to_cpup __be32_to_cpup
-#define cpu_to_be16p __cpu_to_be16p
-#define be16_to_cpup __be16_to_cpup
-#define cpu_to_le64s __cpu_to_le64s
-#define le64_to_cpus __le64_to_cpus
-#define cpu_to_le32s __cpu_to_le32s
-#define le32_to_cpus __le32_to_cpus
-#define cpu_to_le16s __cpu_to_le16s
-#define le16_to_cpus __le16_to_cpus
-#define cpu_to_be64s __cpu_to_be64s
-#define be64_to_cpus __be64_to_cpus
-#define cpu_to_be32s __cpu_to_be32s
-#define be32_to_cpus __be32_to_cpus
-#define cpu_to_be16s __cpu_to_be16s
-#define be16_to_cpus __be16_to_cpus
-
-#endif /* _LINUX_BYTEORDER_GENERIC_H */
-
diff --git a/os/board/rtl8720e/src/component/wifi/driver/include/byteorder/little_endian.h b/os/board/rtl8720e/src/component/wifi/driver/include/byteorder/little_endian.h
deleted file mode 100644
index d57305a1c..000000000
--- a/os/board/rtl8720e/src/component/wifi/driver/include/byteorder/little_endian.h
+++ /dev/null
@@ -1,99 +0,0 @@
-/******************************************************************************
- *
- * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of version 2 of the GNU General Public License as
- * published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
- * more details.
- *
- * You should have received a copy of the GNU General Public License along with
- * this program; if not, write to the Free Software Foundation, Inc.,
- * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
- *
- *
- ******************************************************************************/
-#ifndef _LINUX_BYTEORDER_LITTLE_ENDIAN_H
-#define _LINUX_BYTEORDER_LITTLE_ENDIAN_H
-
-#ifndef __LITTLE_ENDIAN
-#define __LITTLE_ENDIAN 1234
-#endif
-#ifndef __LITTLE_ENDIAN_BITFIELD
-#define __LITTLE_ENDIAN_BITFIELD
-#endif
-
-#include <byteorder/swab.h>
-
-#ifndef __constant_htonl
-
-//TODO
-#if 0
-
-#define __constant_htonl(x) ___constant_swab32((x))
-#define __constant_ntohl(x) ___constant_swab32((x))
-#define __constant_htons(x) ___constant_swab16((x))
-#define __constant_ntohs(x) ___constant_swab16((x))
-#define __constant_cpu_to_le64(x) ((__u64)(x))
-#define __constant_le64_to_cpu(x) ((__u64)(x))
-#define __constant_cpu_to_le32(x) ((__u32)(x))
-#define __constant_le32_to_cpu(x) ((__u32)(x))
-#define __constant_cpu_to_le16(x) ((__u16)(x))
-#define __constant_le16_to_cpu(x) ((__u16)(x))
-#define __constant_cpu_to_be64(x) ___constant_swab64((x))
-#define __constant_be64_to_cpu(x) ___constant_swab64((x))
-#define __constant_cpu_to_be32(x) ___constant_swab32((x))
-#define __constant_be32_to_cpu(x) ___constant_swab32((x))
-#define __constant_cpu_to_be16(x) ___constant_swab16((x))
-#define __constant_be16_to_cpu(x) ___constant_swab16((x))
-#define __cpu_to_le64(x) ((__u64)(x))
-#define __le64_to_cpu(x) ((__u64)(x))
-
-#endif	//#if 0
-
-#define __cpu_to_le64(x) ((__u64)(x))
-#define __le64_to_cpu(x) ((__u64)(x))
-#define __cpu_to_le32(x) ((__u32)(x))
-#define __le32_to_cpu(x) ((__u32)(x))
-#define __cpu_to_le16(x) ((__u16)(x))
-#define __le16_to_cpu(x) ((__u16)(x))
-#define __cpu_to_be64(x) __swab64((x))
-#define __be64_to_cpu(x) __swab64((x))
-#define __cpu_to_be32(x) __swab32((x))
-#define __be32_to_cpu(x) __swab32((x))
-#define __cpu_to_be16(x) __swab16((x))
-#define __be16_to_cpu(x) __swab16((x))
-#define __cpu_to_le64p(x) (*(__u64*)(x))
-#define __le64_to_cpup(x) (*(__u64*)(x))
-#define __cpu_to_le32p(x) (*(__u32*)(x))
-#define __le32_to_cpup(x) (*(__u32*)(x))
-#define __cpu_to_le16p(x) (*(__u16*)(x))
-#define __le16_to_cpup(x) (*(__u16*)(x))
-#define __cpu_to_be64p(x) __swab64p((x))
-#define __be64_to_cpup(x) __swab64p((x))
-#define __cpu_to_be32p(x) __swab32p((x))
-#define __be32_to_cpup(x) __swab32p((x))
-#define __cpu_to_be16p(x) __swab16p((x))
-#define __be16_to_cpup(x) __swab16p((x))
-#define __cpu_to_le64s(x) do {} while (0)
-#define __le64_to_cpus(x) do {} while (0)
-#define __cpu_to_le32s(x) do {} while (0)
-#define __le32_to_cpus(x) do {} while (0)
-#define __cpu_to_le16s(x) do {} while (0)
-#define __le16_to_cpus(x) do {} while (0)
-#define __cpu_to_be64s(x) __swab64s((x))
-#define __be64_to_cpus(x) __swab64s((x))
-#define __cpu_to_be32s(x) __swab32s((x))
-#define __be32_to_cpus(x) __swab32s((x))
-#define __cpu_to_be16s(x) __swab16s((x))
-#define __be16_to_cpus(x) __swab16s((x))
-#endif	// __constant_htonl
-
-#include <byteorder/generic.h>
-
-#endif /* _LINUX_BYTEORDER_LITTLE_ENDIAN_H */
-
diff --git a/os/board/rtl8720e/src/component/wifi/driver/include/byteorder/swab.h b/os/board/rtl8720e/src/component/wifi/driver/include/byteorder/swab.h
deleted file mode 100644
index 2f67a4f69..000000000
--- a/os/board/rtl8720e/src/component/wifi/driver/include/byteorder/swab.h
+++ /dev/null
@@ -1,109 +0,0 @@
-/******************************************************************************
- *
- * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of version 2 of the GNU General Public License as
- * published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
- * more details.
- *
- * You should have received a copy of the GNU General Public License along with
- * this program; if not, write to the Free Software Foundation, Inc.,
- * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
- *
- *
- ******************************************************************************/
-#ifndef _LINUX_BYTEORDER_SWAB_H
-#define _LINUX_BYTEORDER_SWAB_H
-/*
-#if !defined(CONFIG_PLATFORM_MSTAR_TITANIA12) && !defined(CONFIG_PLATFORM_8195A)
-*/
-#if !defined(CONFIG_PLATFORM_MSTAR_TITANIA12)
-
-__inline static __u16  ___swab16(__u16 x)
-{
-	__u16 __x = x;
-	return
-		((__u16)(
-			 (((__u16)(__x) & (__u16)0x00ffU) << 8) |
-			 (((__u16)(__x) & (__u16)0xff00U) >> 8)));
-
-}
-
-__inline static __u32  ___swab32(__u32 x)
-{
-	__u32 __x = (x);
-	return ((__u32)(
-				(((__u32)(__x) & (__u32)0x000000ffUL) << 24) |
-				(((__u32)(__x) & (__u32)0x0000ff00UL) <<  8) |
-				(((__u32)(__x) & (__u32)0x00ff0000UL) >>  8) |
-				(((__u32)(__x) & (__u32)0xff000000UL) >> 24)));
-}
-
-__inline static __u64  ___swab64(__u64 x)
-{
-	__u64 __x = (x);
-
-	return
-		((__u64)(\
-				 (__u64)(((__u64)(__x) & (__u64)0x00000000000000ffULL) << 56) | \
-				 (__u64)(((__u64)(__x) & (__u64)0x000000000000ff00ULL) << 40) | \
-				 (__u64)(((__u64)(__x) & (__u64)0x0000000000ff0000ULL) << 24) | \
-				 (__u64)(((__u64)(__x) & (__u64)0x00000000ff000000ULL) <<  8) | \
-				 (__u64)(((__u64)(__x) & (__u64)0x000000ff00000000ULL) >>  8) | \
-				 (__u64)(((__u64)(__x) & (__u64)0x0000ff0000000000ULL) >> 24) | \
-				 (__u64)(((__u64)(__x) & (__u64)0x00ff000000000000ULL) >> 40) | \
-				 (__u64)(((__u64)(__x) & (__u64)0xff00000000000000ULL) >> 56)));
-	\
-}
-#endif // CONFIG_PLATFORM_MSTAR_TITANIA12
-
-#ifndef __arch__swab16
-__inline static __u16 __arch__swab16(__u16 x)
-{
-	return ___swab16(x);
-}
-
-#endif
-
-#ifndef __arch__swab32
-__inline static __u32 __arch__swab32(__u32 x)
-{
-	__u32 __tmp = (x) ;
-	return ___swab32(__tmp);
-}
-#endif
-
-#ifndef __arch__swab64
-
-__inline static __u64 __arch__swab64(__u64 x)
-{
-	__u64 __tmp = (x) ;
-	return ___swab64(__tmp);
-}
-
-
-#endif
-
-#ifndef __swab16
-#define __swab16(x) __fswab16(x)
-#define __swab32(x) __fswab32(x)
-#define __swab64(x) __fswab64(x)
-#endif	// __swab16
-
-__inline static __u16 __fswab16(__u16 x)
-{
-	return __arch__swab16(x);
-}
-
-__inline static __u32 __fswab32(__u32 x)
-{
-	return __arch__swab32(x);
-}
-
-#endif /* _LINUX_BYTEORDER_SWAB_H */
-
diff --git a/os/board/rtl8720e/src/component/wifi/driver/include/cmn_info/rtw_sta_info.h b/os/board/rtl8720e/src/component/wifi/driver/include/cmn_info/rtw_sta_info.h
deleted file mode 100644
index 9b5f559a2..000000000
--- a/os/board/rtl8720e/src/component/wifi/driver/include/cmn_info/rtw_sta_info.h
+++ /dev/null
@@ -1,262 +0,0 @@
-/******************************************************************************
- *
- * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of version 2 of the GNU General Public License as
- * published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
- * more details.
- *
- * You should have received a copy of the GNU General Public License along with
- * this program; if not, write to the Free Software Foundation, Inc.,
- * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
- *
- *
- ******************************************************************************/
-
-/*This header file is for all driver teams to use the same station info.
-If you want to change this file please make sure notify all driver teams maintainers.*/
-
-/*Created by YuChen 20170301*/
-
-#ifndef __INC_RTW_STA_INFO_H
-#define __INC_RTW_STA_INFO_H
-
-/*--------------------Define ---------------------------------------*/
-
-#define STA_DM_CTRL_ACTIVE			BIT(0)
-#define STA_DM_CTRL_CFO_TRACKING	BIT(1)
-
-#ifdef CONFIG_BEAMFORMEE_VHT
-#define	BEAMFORMING_HT_BEAMFORMER_ENABLE	BIT(0)	/*Declare sta support beamformer*/
-#define	BEAMFORMING_HT_BEAMFORMEE_ENABLE	BIT(1)	/*Declare sta support beamformee*/
-#define	BEAMFORMING_HT_BEAMFORMER_TEST		BIT(2)	/*Transmiting Beamforming no matter the target supports it or not*/
-#define	BEAMFORMING_HT_BEAMFORMER_STEER_NUM		(BIT(4)|BIT(5))		/*Sta Bfer's capability*/
-#define	BEAMFORMING_HT_BEAMFORMEE_CHNL_EST_CAP	(BIT(6)|BIT(7))		/*Sta BFee's capability*/
-
-#define	BEAMFORMING_VHT_BEAMFORMER_ENABLE	BIT(0)	/*Declare sta support beamformer*/
-#define	BEAMFORMING_VHT_BEAMFORMEE_ENABLE	BIT(1)	/*Declare sta support beamformee*/
-#define	BEAMFORMING_VHT_MU_MIMO_AP_ENABLE	BIT(2)	/*Declare sta support MU beamformer*/
-#define	BEAMFORMING_VHT_MU_MIMO_STA_ENABLE	BIT(3)	/*Declare sta support MU beamformer*/
-#define	BEAMFORMING_VHT_BEAMFORMER_TEST		BIT(4)	/*Transmiting Beamforming no matter the target supports it or not*/
-#define	BEAMFORMING_VHT_BEAMFORMER_STS_CAP		(BIT(8)|BIT(9)|BIT(10))		/*Sta BFee's capability*/
-#define	BEAMFORMING_VHT_BEAMFORMEE_SOUND_DIM	(BIT(12)|BIT(13)|BIT(14))	/*Sta Bfer's capability*/
-#endif
-
-#define HT_STBC_EN	BIT(0)
-#define VHT_STBC_EN	BIT(1)
-
-#define HT_LDPC_EN	BIT(0)
-#define VHT_LDPC_EN	BIT(1)
-
-/*cmn_sta_info.ra_sta_info.txrx_state*/
-#define	TX_STATE				0
-#define	RX_STATE				1
-#define	BI_DIRECTION_STATE	2
-
-/*--------------------Define Enum-----------------------------------*/
-enum band_type {
-	BAND_ON_24G	= 0,
-	BAND_ON_5G	= 1,
-	BAND_ON_6G	= 2,
-	BAND_MAX,
-};
-
-enum channel_width {
-	CHANNEL_WIDTH_20		= 0,
-	CHANNEL_WIDTH_40		= 1,
-	CHANNEL_WIDTH_80		= 2,
-	CHANNEL_WIDTH_160		= 3,
-	CHANNEL_WIDTH_80_80	= 4,
-	CHANNEL_WIDTH_5		= 5,
-	CHANNEL_WIDTH_10	= 6,
-	CHANNEL_WIDTH_MAX	= 7,
-};
-
-enum chan_offset {
-	CHAN_OFFSET_NO_EXT = 0,	/*SCN - no secondary channel*/
-	CHAN_OFFSET_UPPER = 1,	/*SCA - secondary channel above*/
-	CHAN_OFFSET_NO_DEF = 2,	/*Reserved*/
-	CHAN_OFFSET_LOWER = 3,	/*SCB - secondary channel below*/
-	CHAN_OFFSET_40M_UPPER = 4,
-	CHAN_OFFSET_40M_LOWER = 5,
-	CHAN_OFFSET_80M_UPPER = 6,
-	CHAN_OFFSET_80M_LOWER = 7,
-};
-
-enum rf_type {
-	RF_1T1R			= 0,
-	RF_1T2R			= 1,
-	RF_2T2R			= 2,
-	RF_2T3R			= 3,
-	RF_2T4R			= 4,
-	RF_3T3R			= 5,
-	RF_3T4R			= 6,
-	RF_4T4R			= 7,
-	RF_TYPE_MAX,
-};
-
-#if (PHYDM_VERSION == 2)/*bb_path and rf_syn are in halbb files when use halbb*/
-enum bb_path {
-	BB_PATH_A = 0x00000001,
-	BB_PATH_B = 0x00000002,
-	BB_PATH_C = 0x00000004,
-	BB_PATH_D = 0x00000008,
-
-	BB_PATH_AB = (BB_PATH_A | BB_PATH_B),
-	BB_PATH_AC = (BB_PATH_A | BB_PATH_C),
-	BB_PATH_AD = (BB_PATH_A | BB_PATH_D),
-	BB_PATH_BC = (BB_PATH_B | BB_PATH_C),
-	BB_PATH_BD = (BB_PATH_B | BB_PATH_D),
-	BB_PATH_CD = (BB_PATH_C | BB_PATH_D),
-
-	BB_PATH_ABC = (BB_PATH_A | BB_PATH_B | BB_PATH_C),
-	BB_PATH_ABD = (BB_PATH_A | BB_PATH_B | BB_PATH_D),
-	BB_PATH_ACD = (BB_PATH_A | BB_PATH_C | BB_PATH_D),
-	BB_PATH_BCD = (BB_PATH_B | BB_PATH_C | BB_PATH_D),
-
-	BB_PATH_ABCD = (BB_PATH_A | BB_PATH_B | BB_PATH_C | BB_PATH_D),
-};
-
-enum rf_syn {
-	RF_SYN0 = 0,
-	RF_SYN1 = 1,
-};
-#endif
-
-enum rf_path {
-	RF_PATH_A = 0,
-	RF_PATH_B = 1,
-	RF_PATH_C = 2,
-	RF_PATH_D = 3,
-	RF_PATH_AB,
-	RF_PATH_AC,
-	RF_PATH_AD,
-	RF_PATH_BC,
-	RF_PATH_BD,
-	RF_PATH_CD,
-	RF_PATH_ABC,
-	RF_PATH_ABD,
-	RF_PATH_ACD,
-	RF_PATH_BCD,
-	RF_PATH_ABCD,
-};
-
-enum wireless_set {
-	WIRELESS_CCK	= 0x00000001,
-	WIRELESS_OFDM	= 0x00000002,
-	WIRELESS_HT	= 0x00000004,
-	WIRELESS_VHT	= 0x00000008,
-};
-
-/*--------------------Define MACRO---------------------------------*/
-
-/*--------------------Define Struct-----------------------------------*/
-
-struct rssi_info {
-	s8		rssi;
-	s8		rssi_cck;
-	s8		rssi_ofdm;
-	u8		packet_map;
-	u8		ofdm_pkt_cnt;
-	u8		cck_pkt_cnt;
-	u16		cck_sum_power;
-	u8		is_send_rssi;
-	u8		valid_bit;
-	s16		rssi_acc;	/*accumulate RSSI for per packet MA sum*/
-};
-
-struct ra_sta_info {
-	u8	rate_id;			/*[PHYDM] ratr_idx*/
-	u8	rssi_level;			/*[PHYDM]*/
-	u8	is_first_connect: 1;		/*[PHYDM] CE: ra_rpt_linked, AP: H2C_rssi_rpt*/
-	u8	is_support_sgi: 1;		/*[driver]*/
-	u8	is_vht_enable: 2;		/*[driver]*/
-	u8	disable_ra: 1;			/*[driver]*/
-	u8	disable_pt: 1;			/*[driver] remove is_disable_power_training*/
-	u8	txrx_state: 2;			/*[PHYDM] 0: Tx, 1:Rx, 2:bi-direction*/
-	u8	is_noisy: 1;			/*[PHYDM]*/
-	u8	curr_tx_rate;			/*[PHYDM] FW->Driver*/
-	enum channel_width	ra_bw_mode;	/*[Driver] max bandwidth, for RA only*/
-	enum channel_width	curr_tx_bw;	/*[PHYDM] FW->Driver*/
-	u8	curr_retry_ratio;		/*[PHYDM] FW->Driver*/
-	u64	ramask;
-};
-
-struct dtp_info {
-	u8	dyn_tx_power;	/*Dynamic Tx power offset*/
-	u8	last_tx_power;
-	u8	sta_tx_high_power_lvl: 4;
-	u8	sta_last_dtp_lvl: 4;
-};
-
-struct cmn_sta_info {
-	u16	dm_ctrl;			/*[Driver]*/
-	enum channel_width	bw_mode;	/*[Driver] max support BW*/
-	u8	mac_id;				/*[Driver]*/
-	u8	mac_addr[6];			/*[Driver]*/
-	u16	aid;				/*[Driver]*/
-	enum rf_type mimo_type;			/*[Driver] sta XTXR*/
-	struct rssi_info	rssi_stat;	/*[PHYDM]*/
-	struct ra_sta_info	ra_info;	/*[Driver&PHYDM]*/
-	u16	tx_moving_average_tp;		/*[Driver] tx average MBps*/
-	u16	rx_moving_average_tp;		/*[Driver] rx average MBps*/
-	u8	stbc_en: 2;			/*[Driver] really transmitt STBC*/
-	u8	ldpc_en: 2;			/*[Driver] really transmitt LDPC*/
-	enum wireless_set	support_wireless_set;/*[Driver]*/
-	struct dtp_info dtp_stat;		/*[PHYDM] Dynamic Tx power offset*/
-	u8	wireless_mode;	/*enum wlan_mode, [Driver], move from sta_info to cmn_sta_info for compating ax */
-	/*u8		pw2cca_over_TH_cnt;*/
-	/*u8		total_pw2cca_cnt;*/
-};
-
-struct phydm_phyinfo_struct {
-	bool	physts_rpt_valid; /* @if physts_rpt_valid is false, please ignore the parsing result in this structure*/
-	u8		rx_pwdb_all;
-	u8		signal_quality;				/* OFDM: signal_quality=rx_mimo_signal_quality[0], CCK: signal qualityin 0-100 index. */
-	u8		rx_mimo_signal_strength[4];	/* RSSI in 0~100 index */
-	s8		rx_mimo_signal_quality[4];		/* OFDM: per-path's EVM translate to 0~100% , no used for CCK*/
-	u8		rx_mimo_evm_dbm[4];			/* per-path's original EVM (dbm) */
-	s16		cfo_short[4];					/* per-path's cfo_short */
-	s16		cfo_tail[4];					/* per-path's cfo_tail */
-	s8		rx_power;					/* in dBm Translate from PWdB */
-	s8		recv_signal_power;			/* Real power in dBm for this packet, no beautification and aggregation. Keep this raw info to be used for the other procedures. */
-	u8		bt_rx_rssi_percentage;
-	u8		signal_strength;				/* in 0-100 index. */
-	s8		rx_pwr[4];					/* per-path's pwdb */
-	s8		rx_snr[4];					/* per-path's SNR	*/
-	u8		ant_idx[4];	/*per-path's antenna index*/
-	/*ODM_PHY_STATUS_NEW_TYPE_SUPPORT*/
-	u8		rx_count: 2;					/* RX path counter---*/
-	u8		band_width: 2;
-	u8		rxsc: 4;						/* sub-channel---*/
-	u8		channel;						/* channel number---*/
-	u8		is_mu_packet: 1;				/* is MU packet or not---boolean*/
-	u8		is_beamformed: 1;				/* BF packet---boolean*/
-	u8		cnt_pw2cca;
-	u8		cnt_cca2agc_rdy;
-	/*ODM_PHY_STATUS_NEW_TYPE_SUPPORT*/
-	u8		rx_cck_evm;
-};
-
-struct phydm_perpkt_info_struct {
-	u8		data_rate;
-	u8		station_id;
-	u8		is_cck_rate: 1;
-	u8		rate_ss: 3;			/*spatial stream of data rate*/
-	u8		is_packet_match_bssid: 1;	/*boolean*/
-	u8		is_packet_to_self: 1;		/*boolean*/
-	u8		is_packet_beacon: 1;		/*boolean*/
-	u8		is_to_self: 1;				/*boolean*/
-	u8		ppdu_cnt;
-};
-
-/*--------------------Export global variable----------------------------*/
-
-/*--------------------Function declaration-----------------------------*/
-
-#endif
diff --git a/os/board/rtl8720e/src/component/wifi/driver/include/drv_conf.h b/os/board/rtl8720e/src/component/wifi/driver/include/drv_conf.h
deleted file mode 100644
index 085d4fec6..000000000
--- a/os/board/rtl8720e/src/component/wifi/driver/include/drv_conf.h
+++ /dev/null
@@ -1,76 +0,0 @@
-/******************************************************************************
-  *
-  * This module is a confidential and proprietary property of RealTek and
-  * possession or use of this module requires written permission of RealTek.
-  *
-  * Copyright(c) 2016, Realtek Semiconductor Corporation. All rights reserved.
-  *
-******************************************************************************/
-
-#ifndef __DRV_CONF_H__
-#define __DRV_CONF_H__
-
-#include "autoconf.h"
-#if ((RTL8721D_SUPPORT == 1) || (RTL8720E_SUPPORT == 1) || (RTL8730E_SUPPORT == 1) || (RTL8721F_SUPPORT == 1))
-#include "platform_autoconf.h"
-#endif
-
-#if defined(CONFIG_HAS_EARLYSUSPEND) && defined (CONFIG_RESUME_IN_WORKQUEUE)
-#warning "You have CONFIG_HAS_EARLYSUSPEND enabled in your system, we disable CONFIG_RESUME_IN_WORKQUEUE automatically"
-#undef CONFIG_RESUME_IN_WORKQUEUE
-#endif
-
-#if defined(CONFIG_ANDROID_POWER) && defined (CONFIG_RESUME_IN_WORKQUEUE)
-#warning "You have CONFIG_ANDROID_POWER enabled in your system, we disable CONFIG_RESUME_IN_WORKQUEUE automatically"
-#undef CONFIG_RESUME_IN_WORKQUEUE
-#endif
-
-#ifdef CONFIG_RESUME_IN_WORKQUEUE //this can be removed, because there is no case for this...
-#if !defined( CONFIG_WAKELOCK) && !defined(CONFIG_ANDROID_POWER)
-#error "enable CONFIG_RESUME_IN_WORKQUEUE without CONFIG_WAKELOCK or CONFIG_ANDROID_POWER will suffer from the danger of wifi's unfunctionality..."
-#error "If you still want to enable CONFIG_RESUME_IN_WORKQUEUE in this case, mask this preprossor checking and GOOD LUCK..."
-#endif
-#endif
-
-//About USB VENDOR REQ
-#if defined(CONFIG_USB_VENDOR_REQ_BUFFER_PREALLOC) && !defined(CONFIG_USB_VENDOR_REQ_MUTEX)
-#warning "define CONFIG_USB_VENDOR_REQ_MUTEX for CONFIG_USB_VENDOR_REQ_BUFFER_PREALLOC automatically"
-#define CONFIG_USB_VENDOR_REQ_MUTEX
-#endif
-#if defined(CONFIG_VENDOR_REQ_RETRY) &&  !defined(CONFIG_USB_VENDOR_REQ_MUTEX)
-#warning "define CONFIG_USB_VENDOR_REQ_MUTEX for CONFIG_VENDOR_REQ_RETRY automatically"
-#define CONFIG_USB_VENDOR_REQ_MUTEX
-#endif
-
-/* adaptivity */
-#define RTW_ADAPTIVITY_EN_DISABLE			0
-#define RTW_ADAPTIVITY_EN_ENABLE			1
-#define CONFIG_RTW_ADAPTIVITY_EN			RTW_ADAPTIVITY_EN_DISABLE
-#define RTW_ADAPTIVITY_MODE_NORMAL			0
-#define RTW_ADAPTIVITY_MODE_CARRIER_SENSE	1
-#define CONFIG_RTW_ADAPTIVITY_MODE			RTW_ADAPTIVITY_MODE_CARRIER_SENSE
-#define CONFIG_RTW_ADAPTIVITY_DML			0
-
-#ifndef CONFIG_RTW_ADAPTIVITY_DC_BACKOFF
-#define CONFIG_RTW_ADAPTIVITY_DC_BACKOFF 4
-#endif
-
-#ifndef CONFIG_RTW_NHM_EN
-#define CONFIG_RTW_NHM_EN 0
-#endif
-
-#ifndef CONFIG_RTW_DFS_REGION_DOMAIN
-#define CONFIG_RTW_DFS_REGION_DOMAIN 0
-#endif
-
-#ifndef CONFIG_WIFI_CRITICAL_CODE_SECTION
-#define CONFIG_WIFI_CRITICAL_CODE_SECTION
-#endif
-
-#define RTS_THRESH 2347
-#define REG_POWER_BASE 14
-
-//#include <rtl871x_byteorder.h>
-
-#endif // __DRV_CONF_H__
-
diff --git a/os/board/rtl8720e/src/component/wifi/driver/include/drv_types.h b/os/board/rtl8720e/src/component/wifi/driver/include/drv_types.h
deleted file mode 100644
index 6695f96a1..000000000
--- a/os/board/rtl8720e/src/component/wifi/driver/include/drv_types.h
+++ /dev/null
@@ -1,645 +0,0 @@
-/******************************************************************************
- *
- * Copyright(c) 2007 - 2012 Realtek Corporation. All rights reserved.
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of version 2 of the GNU General Public License as
- * published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
- * more details.
- *
- * You should have received a copy of the GNU General Public License along with
- * this program; if not, write to the Free Software Foundation, Inc.,
- * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
- *
- *
- ******************************************************************************/
-/*-------------------------------------------------------------------------------
-
-	For type defines and data structure defines
-
---------------------------------------------------------------------------------*/
-
-
-#ifndef __DRV_TYPES_H__
-#define __DRV_TYPES_H__
-
-#include <drv_conf.h>
-
-#if defined (__ICCARM__)
-#define _PACKED         __packed
-#define _WEAK           __weak
-#else
-#define _PACKED         __attribute__ ((packed))
-#define _WEAK           __attribute__ ((weak))
-#endif
-
-// Assign memory sectinon usage
-#if defined(CONFIG_PLATFORM_8721D) || defined(CONFIG_PLATFORM_AMEBAD2) || defined(CONFIG_PLATFORM_AMEBALITE) || defined(CONFIG_PLATFORM_AMEBADPLUS)
-#include <section_config.h>
-//#include "rtl_utility_ram.h"
-#include "platform_stdlib.h"
-#else
-#define SRAM_BD_DATA_SECTION
-#define WLAN_ROM_TEXT_SECTION
-#define WLAN_ROM_DATA_SECTION
-#define _LONG_CALL_
-#endif
-
-#define CONFIG_DOSCAN_IN_BUSYTRAFFIC
-//#define CONFIG_SPCT_CH_SWITCH
-
-enum _NIC_VERSION {
-
-	RTL8711_NIC,
-	RTL8712_NIC,
-	RTL8713_NIC,
-	RTL8716_NIC
-
-};
-
-/* Add for halbb, It may be wrong if g6 driver add other type for BIT6, */
-enum rtw_hci_type {
-	RTW_HCI_PCIE = (1U << 0),
-	RTW_HCI_USB = (1U << 1),
-	RTW_HCI_SDIO = (1U << 2),
-	RTW_HCI_GSPI = (1U << 3),
-	RTW_HCI_AXI = (1U << 6),
-	RTW_HCI_MAX,
-};
-
-typedef struct _ADAPTER _adapter, ADAPTER, *PADAPTER;
-
-#include "wireless.h"
-#include <netdev.h>
-#include <osdep_service.h>
-#include <device_lock.h>
-#include <rtw_byteorder.h>
-#include <rtw_io.h>
-#include <cmn_info/rtw_sta_info.h>
-#include <wlan_bssdef.h>
-#include <wifi.h>
-//#include "p2p/p2p.h"
-#include <rtw_ht.h>
-
-#ifdef CONFIG_80211AX_HE
-#include <rtw_he.h>
-#endif
-
-#ifdef CONFIG_TWT
-#include <rtw_twt.h>
-#endif
-
-#include <wlan_basic_types.h>
-#include <rtw_intfs.h>
-//#include <hal_pg.h>
-#include <rtw_cmd.h>
-#include <rtw_xmit.h>
-#include <rtw_recv.h>
-#include <rtw_rm.h>
-#include <phl_def.h>
-#include <phl.h>
-#include <hal_com.h>
-
-#ifdef CONFIG_80211AC_VHT
-#include <rtw_vht.h>
-#endif
-
-#ifdef RTW_HALMAC
-#include <hal_com_h2c.h>
-#endif
-#include <rtw_qos.h>
-
-#include <rtw_psk.h>
-
-#ifdef CONFIG_SAE_SUPPORT
-#include "rtw_sae.h"
-#endif
-#include "rtw_pmksa_cache.h"
-#include <rtw_security.h>
-#include <rom_rtw_security.h>
-#include <rtw_pwrctrl.h>
-#include <rtw_pwrctrl_sd1.h>
-#include <sta_info.h>
-#include <rtw_mlme.h>
-#include <rtw_layer2_rm.h>
-#include <rtw_debug.h>
-#include <ieee80211.h>
-#include <rom_ieee80211.h>
-#include <rtw_ioctl_set.h>
-#include <rtw_rf.h>
-#include <rtw_event.h>
-#include <rtw_mlme_ext.h>
-#include <rtw_80211frame.h>
-#include <rtw_dfs.h>
-#include <wifi_performance_monitor.h>
-//#include <rtw_tdls.h>
-#include <rtw_ap.h>
-
-#include <osdep_intf.h>
-
-#include <hci_intfs.h>
-#ifdef CONFIG_HARDWARE_8192E
-#include <wifi_conf.h>
-#endif
-
-#ifdef CONFIG_MP_INCLUDED
-#include <rtw_mp.h>
-#endif
-
-#ifdef CONFIG_BT_COEXIST
-#include <btc_api.h>
-#endif
-
-#ifdef CONFIG_BT_COEXIST_SOC
-#include <rtw_btcoex_soc.h>
-#endif
-
-
-#ifdef CONFIG_IEEE80211R
-#include <rtw_ft.h>
-#endif
-#if defined(CONFIG_RTW_WNM) || defined(CONFIG_IEEE80211K)
-#include <rtw_wnm.h>
-#endif
-
-#define CHANNEL_MAX_NUMBER						14	// 14 is the max channel number
-#define CHANNEL_MAX_NUMBER_2G					14
-#define CHANNEL_MAX_NUMBER_5G					54	// Please refer to "phy_GetChnlGroup8812A" and "Hal_ReadTxPowerInfo8812A"
-#define CHANNEL_MAX_NUMBER_5G_80M				7
-
-// Tx Power Limit Table Size
-#define MAX_REGULATION_NUM						TXPWR_LMT_MAX_REGULATION_NUM
-#define MAX_2_4G_BANDWITH_NUM					2 // 20M, 40M
-#if defined(NOT_SUPPORT_RF_MULTIPATH) && (!defined(CONFIG_80211AC_VHT))
-#define MAX_RATE_SECTION_NUM					3 // CCk, OFDM, HT
-#define MAX_BASE_NUM_IN_PHY_REG_PG_2_4G			3 //  CCK:1,OFDM:1, HT:1(MCS0_MCS7)
-#else
-#define MAX_RATE_SECTION_NUM					10
-#define MAX_BASE_NUM_IN_PHY_REG_PG_2_4G			10 //  CCK:1,OFDM:1, HT:4, VHT:4
-#endif
-#define MAX_5G_BANDWITH_NUM						4
-#define MAX_BASE_NUM_IN_PHY_REG_PG_5G			9 // OFDM:1, HT:4, VHT:4
-
-#define SPEC_DEV_ID_NONE		BIT(0)
-#define SPEC_DEV_ID_DISABLE_HT		BIT(1)
-#define SPEC_DEV_ID_ENABLE_PS		BIT(2)
-#define SPEC_DEV_ID_RF_CONFIG_1T1R	BIT(3)
-#define SPEC_DEV_ID_RF_CONFIG_2T2R	BIT(4)
-#define SPEC_DEV_ID_ASSIGN_IFNAME	BIT(5)
-
-#define BUFLEN(a)			strnlen(a,sizeof(a))
-
-typedef unsigned char			BOOLEAN, *PBOOLEAN;
-typedef unsigned char			u1Byte, *pu1Byte;
-typedef unsigned short			u2Byte, *pu2Byte;
-typedef unsigned int			u4Byte, *pu4Byte;
-typedef unsigned long long		u8Byte, *pu8Byte;
-typedef signed char			s1Byte, *ps1Byte;
-
-struct specific_device_id {
-	u32		flags;
-	u16		idVendor;
-	u16		idProduct;
-
-};
-
-#define BSSID_OFT(field) ((u32)FIELD_OFFSET(WLAN_BSSID_EX,field))
-#define BSSID_SZ(field)   sizeof(((PWLAN_BSSID_EX) 0)->field)
-
-#define BW_MODE_2G(bw_mode) ((bw_mode) & 0x0F)
-#define BW_MODE_5G(bw_mode) ((bw_mode) >> 4)
-#define REGSTY_BW_2G(bw_mode) BW_MODE_2G(bw_mode)
-#define REGSTY_BW_5G(bw_mode) BW_MODE_5G(bw_mode)
-
-#define REGSTY_IS_BW_2G_SUPPORT(bw_mode, bw) (REGSTY_BW_2G((bw_mode)) >= (bw))
-#define REGSTY_IS_BW_5G_SUPPORT(bw_mode, bw) (REGSTY_BW_5G((bw_mode)) >= (bw))
-
-#define MAX_CONTINUAL_URB_ERR 4
-
-enum _IFACE_ID {
-	IFACE_ID0, /*PRIMARY_ADAPTER*/
-	IFACE_ID1,
-	IFACE_ID2,
-	IFACE_ID3,
-	IFACE_ID4,
-	IFACE_ID5,
-	IFACE_ID6,
-	IFACE_ID7,
-	IFACE_ID_MAX,
-};
-
-enum _IFACE_TYPE {
-	IFACE_PORT0, //mapping to port0 for C/D series chips
-	IFACE_PORT1, //mapping to port1 for C/D series chip
-	MAX_IFACE_PORT,
-};
-
-enum _hw_port {
-	HW_PORT0,
-	HW_PORT1,
-	HW_PORT2,
-	HW_PORT3,
-	HW_PORT4,
-	MAX_HW_PORT,
-};
-
-enum _ADAPTER_TYPE {
-	PRIMARY_ADAPTER,
-	SECONDARY_ADAPTER,
-	MAX_ADAPTER,
-};
-
-struct rf_ctl_t {
-	const struct country_chplan *country_ent;
-	u8 ChannelPlan;
-	u8 max_chan_nums;
-	//RT_CHANNEL_INFO channel_set[MAX_CHANNEL_NUM];
-	//struct p2p_channels channel_list;
-
-	_mutex offch_mutex;
-	u8 offch_state;
-
-	/* used for debug or by tx power limit */
-	u16 rate_bmp_cck_ofdm;		/* 20MHz */
-	u32 rate_bmp_ht_by_bw[2];	/* 20MHz, 40MHz. 4SS supported */
-	u32 rate_bmp_vht_by_bw[4];	/* 20MHz, 40MHz, 80MHz, 160MHz. up to 3SS supported */
-
-	/* used by tx power limit */
-	u8 highest_ht_rate_bw_bmp;
-	u8 highest_vht_rate_bw_bmp;
-
-#ifdef CONFIG_TXPWR_LIMIT
-	_mutex txpwr_lmt_mutex;
-	_list reg_exc_list;
-	u8 regd_exc_num;
-	_list txpwr_lmt_list;
-	u8 txpwr_regd_num;
-	const char *regd_name;
-
-	u8 txpwr_lmt_2g_cck_ofdm_state;
-#ifdef CONFIG_IEEE80211_BAND_5GHZ
-	u8 txpwr_lmt_5g_cck_ofdm_state;
-	u8 txpwr_lmt_5g_20_40_ref;
-#endif
-#endif
-
-	u8 ch_sel_same_band_prefer;
-
-#ifdef CONFIG_DFS
-	u8 csa_ch;
-#endif
-};
-
-#define RTW_CAC_STOPPED 0
-
-#define IS_CAC_STOPPED(rfctl) 1
-#define IS_CH_WAITING(rfctl) 0
-#define IS_UNDER_CAC(rfctl) 0
-#define IS_RADAR_DETECTED(rfctl) 0
-
-
-#ifdef CONFIG_DFS_SLAVE_WITH_RADAR_DETECT
-#define IS_DFS_SLAVE_WITH_RD(rfctl) ((rfctl)->dfs_slave_with_rd)
-#else
-#define IS_DFS_SLAVE_WITH_RD(rfctl) 0
-#endif
-
-#define SEC_CAP_CHK_BMC	BIT0
-
-#define RTW_DEFAULT_MGMT_MACID 1
-
-struct macid_bmp {
-	u32 m0;
-#if (MACID_NUM_SW_LIMIT > 32)
-	u32 m1;
-#endif
-#if (MACID_NUM_SW_LIMIT > 64)
-	u32 m2;
-#endif
-#if (MACID_NUM_SW_LIMIT > 96)
-	u32 m3;
-#endif
-};
-
-#define rfctl_to_share_adapter(rfctl) container_of((rfctl), struct share_adapter, rf_ctl)
-
-typedef enum _DRIVER_STATE {
-	DRIVER_NORMAL = 0,
-	DRIVER_DISAPPEAR = 1,
-	DRIVER_REPLACE_DONGLE = 2,
-} DRIVER_STATE;
-
-struct tsf_info {
-	u8 sync_port;/*tsf sync from portx*/
-	u8 offset; /*tsf timer offset*/
-};
-
-struct wps_priv {
-#ifdef CONFIG_WPS
-	u8 *wps_probe_req_ie;
-	u16 wps_probe_req_ie_len;
-	u8 *wps_assoc_req_ie;
-	u16 wps_assoc_req_ie_len;
-
-	u8 *wps_beacon_ie;
-	u8 *wps_probe_resp_ie;
-	u8 *wps_assoc_resp_ie; // for CONFIG_IOCTL_CFG80211, this IE could include p2p ie
-
-	u16 wps_beacon_ie_len;
-	u16 wps_probe_resp_ie_len;
-	u16 wps_assoc_resp_ie_len;
-#endif
-};
-
-struct halphy_data_t {
-#if (PHYDM_VERSION < 3)
-	s8			TxPwrByRateOffset[TX_PWR_BY_RATE_NUM_BAND]
-	[TX_PWR_BY_RATE_NUM_RF]
-	[TX_PWR_BY_RATE_NUM_RF]
-	[TX_PWR_BY_RATE_NUM_RATE];
-	u8			Index24G_CCK_Base[MAX_RF_PATH][CHANNEL_MAX_NUMBER];
-	u8			Index24G_BW40_Base[MAX_RF_PATH][CHANNEL_MAX_NUMBER];
-	//If only one tx, only BW20 and OFDM are used.
-	s8			OFDM_24G_Diff[MAX_RF_PATH][MAX_TX_COUNT];
-	s8			BW20_24G_Diff[MAX_RF_PATH][MAX_TX_COUNT];
-#if !defined(NOT_SUPPORT_RF_MULTIPATH)
-	s8			CCK_24G_Diff[MAX_RF_PATH][MAX_TX_COUNT];
-	s8			BW40_24G_Diff[MAX_RF_PATH][MAX_TX_COUNT];
-#endif
-	/* 5G TX power info for target TX power*/
-#if defined(SUPPORT_5G_CHANNEL)
-	u8			Index5G_BW40_Base[MAX_RF_PATH][CENTER_CH_5G_ALL_NUM];
-#if !defined(NOT_SUPPORT_80M)
-	u8			Index5G_BW80_Base[MAX_RF_PATH][CENTER_CH_5G_80M_NUM];
-#endif
-	s8			OFDM_5G_Diff[MAX_RF_PATH][MAX_TX_COUNT];
-	s8			BW20_5G_Diff[MAX_RF_PATH][MAX_TX_COUNT];
-	s8			BW40_5G_Diff[MAX_RF_PATH][MAX_TX_COUNT];
-#if !defined(NOT_SUPPORT_80M)
-	s8			BW80_5G_Diff[MAX_RF_PATH][MAX_TX_COUNT];
-#endif
-#endif
-	/* 2 Power Limit Table */
-	/* Power Limit Table for 2.4G */
-	s8			TxPwrLimit_2_4G[MAX_REGULATION_NUM]
-	[MAX_2_4G_BANDWITH_NUM]
-	[MAX_RATE_SECTION_NUM]
-	[CHANNEL_MAX_NUMBER_2G]
-	[MAX_RF_PATH];
-#if defined(SUPPORT_5G_CHANNEL)
-	/* Power Limit Table for 5G */
-	s8			TxPwrLimit_5G[MAX_REGULATION_NUM]
-	[MAX_5G_BANDWITH_NUM]
-	[MAX_RATE_SECTION_NUM]
-	[CHANNEL_MAX_NUMBER_5G]
-	[MAX_RF_PATH];
-#endif
-	/* Store the original power by rate value of the base of each rate section of rf path A & B */
-	u8			TxPwrByRateBase2_4G[TX_PWR_BY_RATE_NUM_RF]
-	[TX_PWR_BY_RATE_NUM_RF]
-	[MAX_BASE_NUM_IN_PHY_REG_PG_2_4G];
-#if defined(SUPPORT_5G_CHANNEL)
-	u8			TxPwrByRateBase5G[TX_PWR_BY_RATE_NUM_RF]
-	[TX_PWR_BY_RATE_NUM_RF]
-	[MAX_BASE_NUM_IN_PHY_REG_PG_5G];
-#endif
-#endif // (PHYDM_VERSION < 3)
-};
-
-struct share_adapter {
-	_adapter			*primary_adapter;
-	_adapter			*second_adapter;
-	u8				iface_nums;		/* total number of ifaces used runtime */
-	struct recv_priv		recvpriv;
-	struct xmit_priv		xmitpriv;
-	struct rf_ctl_t			rf_ctl;
-	struct ap_priv			appriv;
-	struct pwrctrl_priv		pwrctrlpriv;
-	struct mlme_ext_priv		mlmeextpriv;
-	struct mlme_priv		mlmepriv;
-	struct rtw_phl_com_t		phl_com;
-	struct wps_priv			wpspriv;
-	struct pwrctrl_priv_sd1		pwrctrlsd1_priv;
-	struct rm_priv			*rmpriv;
-	struct share_security_priv	share_securitypriv;
-#ifdef CONFIG_PROMISC
-	struct promisc_priv		promiscpriv;
-#endif // CONFIG_PROMISC
-#ifdef CONFIG_MP_INCLUDED
-	struct	mp_priv			mppriv;
-#endif
-	PVOID				HalData;
-	unsigned char			oper_channel;		/* saved channel info when call set_channel_bw */
-	unsigned char			oper_bwmode;
-	unsigned char			oper_ch_offset;		/* PRIME_CHNL_OFFSET */
-	systime				on_oper_ch_time;
-#ifdef RTW_HALMAC
-	void				*halmac;
-#endif
-	u8				irq_alloc;
-	u8				irq_enabled;
-	_lock				irq_th_lock;
-	struct task_struct		single_thread;
-	struct task_struct		little_stack_thread;
-#ifdef CONFIG_BT_COEXIST_SOC
-	_queue				btmailboxQueue;
-	struct coex_priv		*coexpriv;
-	struct task_struct		btmailboxThread;
-#endif
-#if defined (CONFIG_WOWLAN) && defined (CONFIG_FW_DRIVER_COEXIST) && CONFIG_FW_DRIVER_COEXIST
-	struct task_struct		driver_resumeThread;
-#endif
-};
-
-struct _ADAPTER {
-	struct share_adapter		*pshare_adapter;
-	_adapter			*pbuddy_adapter;
-
-	u32				work_mode;	//STA, AP, STA+AP, PROMISC, P2P
-	struct mlme_ext_info		mlmext_info;	//for sta/adhoc mode, including current scanning/connecting/connected related info.
-	struct cmd_priv			cmdpriv;
-	struct sta_priv			stapriv;
-	struct security_priv		securitypriv;
-	struct qos_priv			qospriv;
-	struct ht_priv			htpriv;
-#ifdef CONFIG_80211AC_VHT
-	struct vht_priv			vhtpriv;
-#endif
-#ifdef CONFIG_80211AX_HE
-	struct he_priv			hepriv;
-#endif
-	struct halphy_data_t		halphy_data;
-	struct wlan_network		cur_network;
-	s32				bDriverStopped;
-	u8				RxStop;	//Used to stop rx thread as early as possible
-	u8				hw_init_completed;
-	u8				bMpDriver;
-	_nic_hdl			pnetdev;
-	int				bup;
-	struct net_device_stats		stats;
-	u8				net_closed;
-	sint				fw_state;	//shall we protect this variable? maybe not necessarily...
-	u8				bFWReady;
-	u8				iface_type; //interface port type
-	/*extend to support multi interface*/
-	u8				iface_id;
-#if defined(CONFIG_CONCURRENT_MODE)
-	u8				isprimary; //is primary padapter or not
-	u8				adapter_type;
-#if defined(CONFIG_RTL8735B)
-	struct tsf_info			tsf;
-#endif
-#endif
-	u16				fix_rate;
-	u8				mac_addr[6];
-	u8				fix_vcs;
-	u8				driver_tx_bw_mode;
-	struct hw_xmit			pending_queue;
-};
-
-#define intf_stop hci_intf_stop
-
-/* Get elementes from padapter. */
-#ifdef CONFIG_CONCURRENT_MODE
-#define is_primary_adapter(padapter)		(padapter->adapter_type == PRIMARY_ADAPTER)
-#define get_iface_type(padapter)		(padapter->iface_type)
-#define get_hw_port(padapter)			(padapter->hw_port)
-#else
-#define is_primary_adapter(padapter)		(1)
-#define get_iface_type(padapter)		(IFACE_PORT0)
-#define get_hw_port(padapter)			(HW_PORT0)
-#endif
-#define rtw_get_stapriv(padapter)		(&(padapter->stapriv))
-#define rtw_get_securepriv(padapter)		(&(padapter->securitypriv))
-#define rtw_get_pmlmeinfo(padapter)		(&(padapter->mlmext_info))
-#define rtw_get_qospriv(padapter)		(&(padapter->qospriv))
-#define rtw_get_htpriv(padapter)		(&(padapter->htpriv))
-#define rtw_get_vhtpriv(padapter)		(&(padapter->vhtpriv))
-#define rtw_get_hepriv(padapter)		(&(padapter->hepriv))
-#define rtw_get_cur_network(padapter)		(&(padapter->cur_network))
-#define rtw_get_bssid(padapter)			(padapter->cur_network.network.MacAddress)
-#define rtw_get_stats(padapter)			(&(padapter->stats))
-#define rtw_get_pendingqueue(padapter)		(&(padapter->pending_queue))
-#define rtw_get_cmdpriv(padapter)		(&(padapter->cmdpriv))
-#define rtw_get_halphydata(padapter)		(&(padapter->halphy_data))
-#define adapter_mac_addr(padapter)		(padapter->mac_addr)
-
-/* Get elements from pshare_adapter. */
-#define rtw_get_pshare(padapter)		((padapter)->pshare_adapter)
-#define rtw_get_adapter(index, padapter)	((index == 0) ? ((_adapter *)padapter)->pshare_adapter->primary_adapter : ((_adapter *)padapter)->pshare_adapter->second_adapter)
-#define rtw_get_xmitpriv(padapter)		(&(padapter->pshare_adapter->xmitpriv))
-#define rtw_get_recvpriv(padapter)		(&(padapter->pshare_adapter->recvpriv))
-#define rtw_get_mlmepriv(padapter)		(&(padapter->pshare_adapter->mlmepriv))
-#define rtw_get_mlmeextpriv(padapter)		(&(padapter->pshare_adapter->mlmeextpriv))
-#define rtw_get_appriv(padapter)		(&(padapter->pshare_adapter->appriv))
-#define rtw_get_sharesecpriv(padapter)		(&(padapter->pshare_adapter->share_securitypriv))
-#define rtw_get_singlethread(padapter)		(&(padapter->pshare_adapter->single_thread))
-#define rtw_get_littlethread(padapter)		(&(padapter->pshare_adapter->little_stack_thread))
-#define adapter_to_pwrctl_sd1(padapter)		(&(padapter->pshare_adapter->pwrctrlsd1_priv))
-#define adapter_to_chset(padapter)		(padapter->pshare_adapter->mlmeextpriv.channel_set)
-#if defined (CONFIG_WOWLAN) && defined (CONFIG_FW_DRIVER_COEXIST) && CONFIG_FW_DRIVER_COEXIST
-#define rtw_get_driverresumethread(padapter)	(&(padapter->pshare_adapter->driver_resumeThread))
-#endif
-#ifdef CONFIG_BT_COEXIST_SOC
-#define rtw_get_btmailboxthread(padapter)	(&(padapter->pshare_adapter->btmailboxThread))
-#define rtw_get_coexpriv(padapter)		(padapter->pshare_adapter->coexpriv)
-#define rtw_get_btmailboxqueue(padapter)	(&(padapter->pshare_adapter->btmailboxQueue))
-#endif
-#define rtw_get_wpspriv(padapter)		(&(padapter->pshare_adapter->wpspriv))
-#define rtw_get_rmpriv(padapter)		(padapter->pshare_adapter->rmpriv)
-#define rtw_set_rmpriv(padapter, value)		(padapter->pshare_adapter->rmpriv = value)
-#ifdef CONFIG_PROMISC
-#define rtw_get_promisc(padapter)		(&(padapter->pshare_adapter->promiscpriv))
-#endif
-#define rtw_get_pwrctrlpriv(padapter)		(&(padapter->pshare_adapter->pwrctrlpriv))
-#define rtw_get_haldata(padapter)		((HAL_DATA_TYPE *)((padapter)->pshare_adapter->HalData))
-#define rtw_set_haldata(padapter, hal_info)	(padapter->pshare_adapter->HalData = hal_info)
-#define rtw_get_phlcom(padapter)		(&(padapter->pshare_adapter->phl_com))
-#ifdef CONFIG_MP_INCLUDED
-#define rtw_get_mppriv(padapter)		(&(padapter->pshare_adapter->mppriv))
-#endif
-#define adapter_to_rfctl(padapter)		(&(rtw_get_pshare(padapter)->rf_ctl))
-#define rtw_get_intf_type(padapter)		(rtw_get_haldata(padapter)->interface_type)
-#define adapter_to_phydm(padapter)		(&(rtw_get_haldata(padapter)->odmpriv))
-#define adapter_to_csipriv(padapter)		(&(rtw_get_haldata(padapter)->csipriv))
-
-/* Get special elements. */
-#define rtw_set_signal_stat_timer(padapter)	rtw_set_timer(&(padapter->stats.signal_stat_timer), SIG_SAMP_INTERVAL)
-#define rtw_get_pnetwork(pcur_network)		(&(((struct wlan_network *)pcur_network)->network))
-#define get_my_bssid(pnetwork)			(((WLAN_BSSID_EX *)pnetwork)->MacAddress)
-#define CHECK_STA_IS_LINKED(padapter)		((((padapter->fw_state) & (WIFI_STATION_STATE | _FW_LINKED)) == (WIFI_STATION_STATE | _FW_LINKED)) ? 1: 0)
-#define CHECK_STA_UNDER_LINKING(padapter)	((((padapter->fw_state) & (WIFI_STATION_STATE | _FW_UNDER_LINKING)) == (WIFI_STATION_STATE | _FW_UNDER_LINKING)) ? 1: 0)
-#define CHECK_AP_HAS_STA_LINKED(padapter)	(((&padapter->stapriv)->asoc_sta_count > 2) ? (((&padapter->stapriv)->asoc_sta_count) - 2) : 0)
-
-extern struct wifi_user_conf			wifi_user_config;
-
-__inline static sint check_fwstate(_adapter *padapter, sint state)
-{
-	if (padapter->fw_state & state) {
-		return _TRUE;
-	} else if ((state == WIFI_FW_NULL_STATE) &&
-			   (padapter->fw_state == WIFI_FW_NULL_STATE)) {
-		return _TRUE;
-	}
-	return _FALSE;
-}
-
-__inline static sint get_fwstate(_adapter *padapter)
-{
-	return padapter->fw_state;
-}
-
-/*
- * No Limit on the calling context,
- * therefore set it to be the critical section...
- *
- * ### NOTE:#### (!!!!)
- * MUST TAKE CARE THAT BEFORE CALLING THIS FUNC, YOU SHOULD HAVE LOCKED pmlmepriv->lock
- */
-__inline static void set_fwstate(_adapter *padapter, sint state)
-{
-	struct mlme_priv *pmlmepriv = rtw_get_mlmepriv(padapter);
-	padapter->fw_state |= state;
-	//FOR HW integration
-	if (_FW_UNDER_SURVEY == state) {
-		pmlmepriv->bScanInProcess = _TRUE;
-	}
-}
-
-__inline static void _clr_fwstate_(_adapter *padapter, sint state)
-{
-	struct mlme_priv *pmlmepriv = rtw_get_mlmepriv(padapter);
-
-	padapter->fw_state &= ~state;
-	//FOR HW integration
-	if (_FW_UNDER_SURVEY == state) {
-		pmlmepriv->bScanInProcess = _FALSE;
-	}
-}
-
-__inline static void clr_fwstate(_adapter *padapter, sint state)
-{
-	_irqL irqL;
-	struct mlme_priv *pmlmepriv = rtw_get_mlmepriv(padapter);
-
-	rtw_enter_critical_bh(&pmlmepriv->lock, &irqL);
-	if (check_fwstate(padapter, state) == _TRUE) {
-		padapter->fw_state ^= state;
-	}
-	rtw_exit_critical_bh(&pmlmepriv->lock, &irqL);
-}
-
-#if 0 //#if (CONFIG_LWIP_LAYER == 0)
-// For FPGA test program
-#define _htons(x) (x)
-#define _htons(x) (x)
-#define _htons(x) (x)
-#define _htons(x) (x)
-#endif
-
-#endif //__DRV_TYPES_H__
-
diff --git a/os/board/rtl8720e/src/component/wifi/driver/include/drv_types_sdio.h b/os/board/rtl8720e/src/component/wifi/driver/include/drv_types_sdio.h
deleted file mode 100644
index e8af03f92..000000000
--- a/os/board/rtl8720e/src/component/wifi/driver/include/drv_types_sdio.h
+++ /dev/null
@@ -1,50 +0,0 @@
-/******************************************************************************
- *
- * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of version 2 of the GNU General Public License as
- * published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
- * more details.
- *
- * You should have received a copy of the GNU General Public License along with
- * this program; if not, write to the Free Software Foundation, Inc.,
- * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
- *
- *
- ******************************************************************************/
-#ifndef __DRV_TYPES_SDIO_H__
-#define __DRV_TYPES_SDIO_H__
-
-/* SDIO Header Files */
-
-#define RTW_SDIO_CLK_33M	33000000
-#define RTW_SDIO_CLK_40M	40000000
-#define RTW_SDIO_CLK_80M	80000000
-#define RTW_SDIO_CLK_160M	160000000
-
-typedef struct sdio_data {
-	u8  func_number;
-
-	u8  tx_block_mode;
-	u8  rx_block_mode;
-	u32 block_transfer_len;
-} SDIO_DATA, *PSDIO_DATA;
-
-#define dvobj_to_sdio_func(d)	((d)->intf_data.func)
-
-#define RTW_SDIO_ADDR_CMD52_BIT		(1<<17)
-#define RTW_SDIO_ADDR_CMD52_GEN(a)	(a | RTW_SDIO_ADDR_CMD52_BIT)
-#define RTW_SDIO_ADDR_CMD52_CLR(a)	(a&~RTW_SDIO_ADDR_CMD52_BIT)
-#define RTW_SDIO_ADDR_CMD52_CHK(a)	(a&RTW_SDIO_ADDR_CMD52_BIT ? 1 : 0)
-
-#define RTW_SDIO_ADDR_F0_BIT		(1<<18)
-#define RTW_SDIO_ADDR_F0_GEN(a)		(a | RTW_SDIO_ADDR_F0_BIT)
-#define RTW_SDIO_ADDR_F0_CLR(a)		(a&~RTW_SDIO_ADDR_F0_BIT)
-#define RTW_SDIO_ADDR_F0_CHK(a)		(a&RTW_SDIO_ADDR_F0_BIT ? 1 : 0)
-
-#endif
diff --git a/os/board/rtl8720e/src/component/wifi/driver/include/ethernet.h b/os/board/rtl8720e/src/component/wifi/driver/include/ethernet.h
deleted file mode 100644
index e7e78ef8b..000000000
--- a/os/board/rtl8720e/src/component/wifi/driver/include/ethernet.h
+++ /dev/null
@@ -1,42 +0,0 @@
-/******************************************************************************
- *
- * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of version 2 of the GNU General Public License as
- * published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
- * more details.
- *
- * You should have received a copy of the GNU General Public License along with
- * this program; if not, write to the Free Software Foundation, Inc.,
- * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
- *
- *
- ******************************************************************************/
-/*! \file */
-#ifndef __INC_ETHERNET_H
-#define __INC_ETHERNET_H
-
-#define ETHERNET_ADDRESS_LENGTH				6		//!< Ethernet Address Length
-#define ETHERNET_HEADER_SIZE				14		//!< Ethernet Header Length
-#define LLC_HEADER_SIZE						6		//!< LLC Header Length
-#define TYPE_LENGTH_FIELD_SIZE				2		//!< Type/Length Size
-#define MINIMUM_ETHERNET_PACKET_SIZE		60		//!< Minimum Ethernet Packet Size
-#define MAXIMUM_ETHERNET_PACKET_SIZE		1514	//!< Maximum Ethernet Packet Size
-
-#define RT_ETH_IS_MULTICAST(_pAddr)	((((u8 *)(_pAddr))[0]&0x01)!=0)		//!< Is Multicast Address?
-#define RT_ETH_IS_BROADCAST(_pAddr)	(										\
-											((u8 *)(_pAddr))[0]==0xff	&& 		\
-											((u8 *)(_pAddr))[1]==0xff	&&		\
-											((u8 *)(_pAddr))[2]==0xff	&&		\
-											((u8 *)(_pAddr))[3]==0xff	&&		\
-											((u8 *)(_pAddr))[4]==0xff	&&		\
-											((u8 *)(_pAddr))[5]==0xff		)	//!< Is Broadcast Address?
-
-
-#endif // #ifndef __INC_ETHERNET_H
-
diff --git a/os/board/rtl8720e/src/component/wifi/driver/include/hal_btcoex_soc.h b/os/board/rtl8720e/src/component/wifi/driver/include/hal_btcoex_soc.h
deleted file mode 100644
index 50e06e6bf..000000000
--- a/os/board/rtl8720e/src/component/wifi/driver/include/hal_btcoex_soc.h
+++ /dev/null
@@ -1,30 +0,0 @@
-/******************************************************************************
- *
- * Copyright(c) 2013 Realtek Corporation. All rights reserved.
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of version 2 of the GNU General Public License as
- * published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
- * more details.
- *
- * You should have received a copy of the GNU General Public License along with
- * this program; if not, write to the Free Software Foundation, Inc.,
- * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
- *
- *
- ******************************************************************************/
-#ifndef __HAL_BTCOEX_SOC_H__
-#define __HAL_BTCOEX_SOC_H__
-#include <drv_types.h>
-
-void hal_coex_run_case(_adapter *padapter, u16 state);
-void hal_coex_init(_adapter *padapter);
-u16 hal_coex_wifi_tdma_scan_start(PADAPTER padapter, RT_SCAN_TYPE scan_type);
-u16 hal_coex_wifi_tdma_scan_handle(PADAPTER padapter);
-
-#endif //__HAL_BTCOEX_SOC_H__
-
diff --git a/os/board/rtl8720e/src/component/wifi/driver/include/hal_com.h b/os/board/rtl8720e/src/component/wifi/driver/include/hal_com.h
deleted file mode 100644
index 5204ad9a7..000000000
--- a/os/board/rtl8720e/src/component/wifi/driver/include/hal_com.h
+++ /dev/null
@@ -1,374 +0,0 @@
-/******************************************************************************
- *
- * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of version 2 of the GNU General Public License as
- * published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
- * more details.
- *
- * You should have received a copy of the GNU General Public License along with
- * this program; if not, write to the Free Software Foundation, Inc.,
- * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
- *
- *
- ******************************************************************************/
-#ifndef __HAL_COMMON_H__
-#define __HAL_COMMON_H__
-
-#include "HalVerDef.h"
-#include "hal_pg.h"
-#include "hal_def.h"
-#include "hal_intf.h"
-#include "hal_phy.h"
-#include "hal_phy_reg.h"
-#if  defined(CONFIG_RTL8730A) || defined(CONFIG_RTL8730E)
-#include "wififw_reg_rom.h"
-#elif defined(CONFIG_RTL8720E) || defined(CONFIG_RTL8721F)
-#include "wififw_reg_ram.h"
-#else
-#include "hal_com_reg.h"
-#endif
-#include "hal_com_phycfg.h"
-#ifdef RTW_HALMAC
-#include "hal_com_c2h.h"
-#endif
-#include "hal_wowlan_sd1.h"
-
-#include "hal_com_c2h.h"
-
-//----------------------------------------------------------------------------
-//       Rate Definition
-//----------------------------------------------------------------------------
-//CCK
-#define	RATR_1M					0x00000001
-#define	RATR_2M					0x00000002
-#define	RATR_55M					0x00000004
-#define	RATR_11M					0x00000008
-//OFDM
-#define	RATR_6M					0x00000010
-#define	RATR_9M					0x00000020
-#define	RATR_12M					0x00000040
-#define	RATR_18M					0x00000080
-#define	RATR_24M					0x00000100
-#define	RATR_36M					0x00000200
-#define	RATR_48M					0x00000400
-#define	RATR_54M					0x00000800
-//MCS 1 Spatial Stream
-#define	RATR_MCS0					0x00001000
-#define	RATR_MCS1					0x00002000
-#define	RATR_MCS2					0x00004000
-#define	RATR_MCS3					0x00008000
-#define	RATR_MCS4					0x00010000
-#define	RATR_MCS5					0x00020000
-#define	RATR_MCS6					0x00040000
-#define	RATR_MCS7					0x00080000
-//MCS 2 Spatial Stream
-#define	RATR_MCS8					0x00100000
-#define	RATR_MCS9					0x00200000
-#define	RATR_MCS10					0x00400000
-#define	RATR_MCS11					0x00800000
-#define	RATR_MCS12					0x01000000
-#define	RATR_MCS13					0x02000000
-#define	RATR_MCS14					0x04000000
-#define	RATR_MCS15					0x08000000
-
-//CCK
-#define RATE_1M						BIT(0)
-#define RATE_2M						BIT(1)
-#define RATE_5_5M					BIT(2)
-#define RATE_11M					BIT(3)
-//OFDM
-#define RATE_6M						BIT(4)
-#define RATE_9M						BIT(5)
-#define RATE_12M					BIT(6)
-#define RATE_18M					BIT(7)
-#define RATE_24M					BIT(8)
-#define RATE_36M					BIT(9)
-#define RATE_48M					BIT(10)
-#define RATE_54M					BIT(11)
-//MCS 1 Spatial Stream
-#define RATE_MCS0					BIT(12)
-#define RATE_MCS1					BIT(13)
-#define RATE_MCS2					BIT(14)
-#define RATE_MCS3					BIT(15)
-#define RATE_MCS4					BIT(16)
-#define RATE_MCS5					BIT(17)
-#define RATE_MCS6					BIT(18)
-#define RATE_MCS7					BIT(19)
-//MCS 2 Spatial Stream
-#define RATE_MCS8					BIT(20)
-#define RATE_MCS9					BIT(21)
-#define RATE_MCS10					BIT(22)
-#define RATE_MCS11					BIT(23)
-#define RATE_MCS12					BIT(24)
-#define RATE_MCS13					BIT(25)
-#define RATE_MCS14					BIT(26)
-#define RATE_MCS15					BIT(27)
-
-// ALL CCK Rate
-#define	RATE_ALL_CCK				RATR_1M|RATR_2M|RATR_55M|RATR_11M
-#define	RATE_ALL_OFDM_AG			RATR_6M|RATR_9M|RATR_12M|RATR_18M|RATR_24M|\
-									RATR_36M|RATR_48M|RATR_54M
-#define	RATE_ALL_OFDM_1SS			RATR_MCS0|RATR_MCS1|RATR_MCS2|RATR_MCS3 |\
-									RATR_MCS4|RATR_MCS5|RATR_MCS6	|RATR_MCS7
-#define	RATE_ALL_OFDM_2SS			RATR_MCS8|RATR_MCS9	|RATR_MCS10|RATR_MCS11|\
-									RATR_MCS12|RATR_MCS13|RATR_MCS14|RATR_MCS15
-
-/*------------------------------ Tx Desc definition Macro ------------------------*/
-//#pragma mark -- Tx Desc related definition. --
-//----------------------------------------------------------------------------
-//-----------------------------------------------------------
-//	Rate
-//-----------------------------------------------------------
-// CCK Rates, TxHT = 0
-#define DESC_RATE1M				0x00
-#define DESC_RATE2M				0x01
-#define DESC_RATE5_5M				0x02
-#define DESC_RATE11M				0x03
-
-// OFDM Rates, TxHT = 0
-#define DESC_RATE6M				0x04
-#define DESC_RATE9M				0x05
-#define DESC_RATE12M				0x06
-#define DESC_RATE18M				0x07
-#define DESC_RATE24M				0x08
-#define DESC_RATE36M				0x09
-#define DESC_RATE48M				0x0a
-#define DESC_RATE54M				0x0b
-
-// MCS Rates, TxHT = 1
-#define DESC_RATEMCS0				0x0c
-#define DESC_RATEMCS1				0x0d
-#define DESC_RATEMCS2				0x0e
-#define DESC_RATEMCS3				0x0f
-#define DESC_RATEMCS4				0x10
-#define DESC_RATEMCS5				0x11
-#define DESC_RATEMCS6				0x12
-#define DESC_RATEMCS7				0x13
-#define DESC_RATEMCS8				0x14
-#define DESC_RATEMCS9				0x15
-#define DESC_RATEMCS10				0x16
-#define DESC_RATEMCS11				0x17
-#define DESC_RATEMCS12				0x18
-#define DESC_RATEMCS13				0x19
-#define DESC_RATEMCS14				0x1a
-#define DESC_RATEMCS15				0x1b
-#define DESC_RATEMCS16				0x1C
-#define DESC_RATEMCS17				0x1D
-#define DESC_RATEMCS18				0x1E
-#define DESC_RATEMCS19				0x1F
-#define DESC_RATEMCS20				0x20
-#define DESC_RATEMCS21				0x21
-#define DESC_RATEMCS22				0x22
-#define DESC_RATEMCS23				0x23
-#define DESC_RATEMCS24				0x24
-#define DESC_RATEMCS25				0x25
-#define DESC_RATEMCS26				0x26
-#define DESC_RATEMCS27				0x27
-#define DESC_RATEMCS28				0x28
-#define DESC_RATEMCS29				0x29
-#define DESC_RATEMCS30				0x2A
-#define DESC_RATEMCS31				0x2B
-
-#define DESC_RATEVHTSS1MCS0		0x2c
-#define DESC_RATEVHTSS1MCS1		0x2d
-#define DESC_RATEVHTSS1MCS2		0x2e
-#define DESC_RATEVHTSS1MCS3		0x2f
-#define DESC_RATEVHTSS1MCS4		0x30
-#define DESC_RATEVHTSS1MCS5		0x31
-#define DESC_RATEVHTSS1MCS6		0x32
-#define DESC_RATEVHTSS1MCS7		0x33
-#define DESC_RATEVHTSS1MCS8		0x34
-#define DESC_RATEVHTSS1MCS9		0x35
-#define DESC_RATEVHTSS2MCS0		0x36
-#define DESC_RATEVHTSS2MCS1		0x37
-#define DESC_RATEVHTSS2MCS2		0x38
-#define DESC_RATEVHTSS2MCS3		0x39
-#define DESC_RATEVHTSS2MCS4		0x3a
-#define DESC_RATEVHTSS2MCS5		0x3b
-#define DESC_RATEVHTSS2MCS6		0x3c
-#define DESC_RATEVHTSS2MCS7		0x3d
-#define DESC_RATEVHTSS2MCS8		0x3e
-#define DESC_RATEVHTSS2MCS9		0x3f
-#define DESC_RATEVHTSS3MCS0		0x40
-#define DESC_RATEVHTSS3MCS1		0x41
-#define DESC_RATEVHTSS3MCS2		0x42
-#define DESC_RATEVHTSS3MCS3		0x43
-#define DESC_RATEVHTSS3MCS4		0x44
-#define DESC_RATEVHTSS3MCS5		0x45
-#define DESC_RATEVHTSS3MCS6		0x46
-#define DESC_RATEVHTSS3MCS7		0x47
-#define DESC_RATEVHTSS3MCS8		0x48
-#define DESC_RATEVHTSS3MCS9		0x49
-#define DESC_RATEVHTSS4MCS0		0x4A
-#define DESC_RATEVHTSS4MCS1		0x4B
-#define DESC_RATEVHTSS4MCS2		0x4C
-#define DESC_RATEVHTSS4MCS3		0x4D
-#define DESC_RATEVHTSS4MCS4		0x4E
-#define DESC_RATEVHTSS4MCS5		0x4F
-#define DESC_RATEVHTSS4MCS6		0x50
-#define DESC_RATEVHTSS4MCS7		0x51
-#define DESC_RATEVHTSS4MCS8		0x52
-#define DESC_RATEVHTSS4MCS9		0x53
-
-typedef enum _FIRMWARE_SOURCE {
-	FW_SOURCE_IMG_FILE = 0,
-	FW_SOURCE_HEADER_FILE = 1,		//from header file
-} FIRMWARE_SOURCE, *PFIRMWARE_SOURCE;
-
-#define QSLT_BK							0x2//0x01
-#define QSLT_BE							0x0
-#define QSLT_VI							0x5//0x4
-#define QSLT_VO							0x7//0x6
-#define QSLT_BEACON						0x10
-#define QSLT_HIGH						0x11
-#define QSLT_MGNT						0x12
-#define QSLT_CMD						0x13
-
-// BK, BE, VI, VO, HCCA, MANAGEMENT, COMMAND, HIGH, BEACON.
-//#define MAX_TX_QUEUE		9
-
-#define TX_SELE_HQ			BIT(0)		// High Queue
-#define TX_SELE_LQ			BIT(1)		// Low Queue
-#define TX_SELE_NQ			BIT(2)		// Normal Queue
-#define TX_SELE_EQ			BIT(3)		// Extern Queue
-
-#define PageNum_128(_Len)		(u32)(((_Len)>>7) + ((_Len)&0x7F ? 1:0))
-#define PageNum_256(_Len)		(u32)(((_Len)>>8) + ((_Len)&0xFF ? 1:0))
-#define PageNum_512(_Len)		(u32)(((_Len)>>9) + ((_Len)&0x1FF ? 1:0))
-#define PageNum(_Len, _Size)		(u32)(((_Len)/(_Size)) + ((_Len)&((_Size) - 1) ? 1:0))
-
-#define	DYNAMIC_FUNC_DISABLE		(0x0)
-#define DYNAMIC_ALL_FUNC_ENABLE		0xFFFFFFF
-
-#define TBTT_PROHIBIT_SETUP_TIME 0x04 /* 128us, unit is 32us */
-#define TBTT_PROHIBIT_HOLD_TIME 0x80 /* 4ms, unit is 32us*/
-#define TBTT_PROHIBIT_HOLD_TIME_STOP_BCN 0x64 /* 3.2ms unit is 32us*/
-
-#define BAND_CAP_2G			BIT0
-#define BAND_CAP_5G			BIT1
-
-void dump_chip_info(HAL_VERSION	ChipVersion);
-
-#define BAND_CAP_BIT_NUM	2
-
-#define BW_CAP_5M		BIT0
-#define BW_CAP_10M		BIT1
-#define BW_CAP_20M		BIT2
-#define BW_CAP_40M		BIT3
-#define BW_CAP_80M		BIT4
-#define BW_CAP_160M		BIT5
-#define BW_CAP_80_80M	BIT6
-#define BW_CAP_BIT_NUM	7
-
-#define PROTO_CAP_11B		BIT0
-#define PROTO_CAP_11G		BIT1
-#define PROTO_CAP_11N		BIT2
-#define PROTO_CAP_11AC		BIT3
-#define PROTO_CAP_BIT_NUM	4
-
-#define WL_FUNC_P2P			BIT0
-#define WL_FUNC_MIRACAST	BIT1
-#define WL_FUNC_TDLS		BIT2
-#define WL_FUNC_FTM			BIT3
-#define WL_FUNC_BIT_NUM		4
-
-enum STAINFO_ITEM {
-	STAINFO_MACID = 0,
-	STAINFO_MACADDR = 1,
-	STAINFO_AID = 2,
-	STAINFO_CHANDEF_BAND = 3,
-	STAINFO_CHANDEF_BW = 4,
-	STAINFO_CHANDEF_OFFSET = 5,
-	STAINFO_CHANDEF_CH = 6,
-	STAINFO_CHANDEF_CENTER_CH = 7,
-	STAINFO_TP_STATS = 8,
-	STAINFO_RAINFO_SGI = 9,
-	STAINFO_RAINFO_VHT = 10,
-	STAINFO_WIRELESS_MODE = 11,
-	STAINFO_ASSOC_RSSI = 12,
-	STAINFO_MAX,
-};
-
-
-u8	//return the final channel plan decision
-hal_com_get_channel_plan(
-	IN	PADAPTER	padapter,
-	IN	u8			hw_channel_plan,	//channel plan from HW (efuse/eeprom)
-	IN	u8			sw_channel_plan,	//channel plan from SW (registry/module param)
-	IN	u8			def_channel_plan,	//channel plan used when the former two is invalid
-	IN	BOOLEAN		AutoLoadFail
-);
-
-u8	MRateToHwRate(u8 rate);
-
-void	HalSetBrateCfg(
-	IN PADAPTER		Adapter,
-	IN u8			*mBratesOS,
-	OUT u16			*pBrateCfg);
-
-BOOLEAN
-HAL_IsLegalChannel(
-	IN	_adapter 	*Adapter,
-	IN	u32			Channel
-);
-
-void hal_init_macaddr(_adapter *adapter);
-void SetHwReg(PADAPTER padapter, u8 variable, u8 *val);
-void GetHwReg(PADAPTER padapter, u8 variable, u8 *val);
-
-void rtw_hal_sta_info_set(struct sta_info *psta, u8 type, u8 *val);
-int rtw_hal_sta_info_get(struct sta_info *psta, u8 type, u8 *val);
-
-/* ra registered after connecting success */
-void rtw_hal_ra_register(struct sta_info *psta, u8 rssi_level);
-
-/* ra  update */
-#if (PHYDM_VERSION == 2)
-void rtw_hal_update_sta_info(_adapter *padapter, struct wlan_network *pnetwork, struct sta_info *psta);
-void rtw_hal_update_sta_ra_info(_adapter *padapter, struct sta_info *psta);
-#define rtw_hal_ra_deregister(padapter, psta, is_connect)
-#define rtw_hal_ra_update(padapter, psta)
-
-#elif (PHYDM_VERSION == 3)
-void rtw_hal_update_sta_info(_adapter *padapter, struct wlan_network *pnetwork, struct sta_info *psta);
-void rtw_hal_ra_deregister(PADAPTER padapter, struct sta_info *psta, bool is_connect);
-void rtw_hal_update_sta_ra_info(_adapter *padapter, struct sta_info *psta);
-void rtw_hal_ra_update(PADAPTER padapter, struct sta_info *psta);
-#endif
-
-/* ax only, update phl_sta->asoc_cap */
-void rtw_hal_update_asoc_cap(_adapter *padapter, struct sta_info *psta);
-void rtw_hal_update_asoc_cap_apmode(_adapter *padapter, struct sta_info *psta);
-
-#if defined(CONFIG_RTL8721D) || defined(CONFIG_RTL8195B) || defined(CONFIG_RTL8710C) || defined(CONFIG_RTL8735B)
-
-typedef enum _RT_MEDIA_STATUS {
-	RT_MEDIA_DISCONNECT = 0,
-	RT_MEDIA_CONNECT       = 1
-} RT_MEDIA_STATUS;
-
-void wifi_hal_odmvar_get(
-	PADAPTER				Adapter,
-	HAL_ODM_VARIABLE		eVariable,
-	PVOID					pValue1,
-	PVOID					pValue2);
-
-void wifi_hal_odmvar_set(
-	PADAPTER				Adapter,
-	HAL_ODM_VARIABLE		eVariable,
-	PVOID					pValue1,
-	BOOLEAN					bSet);
-
-u8 SetHalDefVar(_adapter *adapter, HAL_DEF_VARIABLE variable, void *value);
-u8 GetHalDefVar(_adapter *adapter, HAL_DEF_VARIABLE variable, void *value);
-
-#endif // defined(CONFIG_RTL8721D) || defined(CONFIG_RTL8195B) || defined(CONFIG_RTL8710C) || defined(CONFIG_RTL8735B)
-
-#endif //__HAL_COMMON_H__
-
diff --git a/os/board/rtl8720e/src/component/wifi/driver/include/hal_com_h2c.h b/os/board/rtl8720e/src/component/wifi/driver/include/hal_com_h2c.h
deleted file mode 100644
index 316372962..000000000
--- a/os/board/rtl8720e/src/component/wifi/driver/include/hal_com_h2c.h
+++ /dev/null
@@ -1,411 +0,0 @@
-/******************************************************************************
- *
- * Copyright(c) 2007 - 2012 Realtek Corporation. All rights reserved.
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of version 2 of the GNU General Public License as
- * published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
- * more details.
- *
- * You should have received a copy of the GNU General Public License along with
- * this program; if not, write to the Free Software Foundation, Inc.,
- * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
- *
- *
- ******************************************************************************/
-#ifndef __COMMON_H2C_H__
-#define __COMMON_H2C_H__
-
-/* ---------------------------------------------------------------------------------------------------------
- * ----------------------------------    H2C CMD DEFINITION    ------------------------------------------------
- * ---------------------------------------------------------------------------------------------------------
- * 88e, 8723b, 8812, 8821, 92e use the same FW code base */
-enum h2c_cmd {
-	/* Common Class: 000 */
-	H2C_RSVD_PAGE = 0x00,
-	H2C_MEDIA_STATUS_RPT = 0x01,
-	H2C_SCAN_ENABLE = 0x02,
-	H2C_KEEP_ALIVE = 0x03,
-	H2C_DISCON_DECISION = 0x04,
-	H2C_PSD_OFFLOAD = 0x05,
-	H2C_TCP_KEEP_ALIVE = 0x07,
-	H2C_AP_OFFLOAD = 0x08,
-	H2C_BCN_RSVDPAGE = 0x09,
-	H2C_PROBERSP_RSVDPAGE = 0x0A,
-	H2C_FCS_RSVDPAGE = 0x10,
-	H2C_FCS_INFO = 0x11,
-	H2C_AP_WOW_GPIO_CTRL = 0x13,
-	H2C_CHNL_SWITCH_OPER_OFFLOAD = 0x1C,
-
-	/* PoweSave Class: 001 */
-	H2C_SET_PWR_MODE = 0x20,
-	H2C_PS_TUNING_PARA = 0x21,
-	H2C_PS_TUNING_PARA2 = 0x22,
-	H2C_P2P_LPS_PARAM = 0x23,
-	H2C_P2P_PS_OFFLOAD = 0x24,
-	H2C_PS_SCAN_ENABLE = 0x25,
-	H2C_SAP_PS_ = 0x26,
-	H2C_INACTIVE_PS_ = 0x27, /* Inactive_PS */
-	H2C_FWLPS_IN_IPS_ = 0x28,
-#ifdef CONFIG_LPS_PG
-	H2C_LPS_PG_INFO = 0x2B,
-#endif
-	H2C_DEFAULT_PORT_ID = 0x2C,
-	/* Dynamic Mechanism Class: 010 */
-	H2C_MACID_CFG = 0x40,
-	H2C_TXBF = 0x41,
-	H2C_RSSI_SETTING = 0x42,
-	H2C_AP_REQ_TXRPT = 0x43,
-	H2C_INIT_RATE_COLLECT = 0x44,
-	H2C_IQ_CALIBRATION	= 0x45,
-
-	H2C_RA_MASK_3SS = 0x46,/* for 8814A */
-	H2C_RA_PARA_ADJUST = 0x47,/* CONFIG_RA_DBG_CMD */
-	H2C_DYNAMIC_TX_PATH = 0x48,/* for 8814A */
-
-	H2C_FW_TRACE_EN = 0x49,
-
-	/* BT Class: 011 */
-	H2C_B_TYPE_TDMA = 0x60,
-	H2C_BT_INFO = 0x61,
-	H2C_FORCE_BT_TXPWR = 0x62,
-	H2C_BT_IGNORE_WLANACT = 0x63,
-	H2C_DAC_SWING_VALUE = 0x64,
-	H2C_ANT_SEL_RSV = 0x65,
-	H2C_WL_OPMODE = 0x66,
-	H2C_BT_MP_OPER = 0x67,
-	H2C_BT_CONTROL = 0x68,
-	H2C_BT_WIFI_CTRL = 0x69,
-	H2C_BT_FW_PATCH = 0x6A,
-
-	/* WOWLAN Class: 100 */
-	H2C_WOWLAN = 0x80,
-	H2C_REMOTE_WAKE_CTRL = 0x81,
-	H2C_AOAC_GLOBAL_INFO = 0x82,
-	H2C_AOAC_RSVD_PAGE = 0x83,
-	H2C_AOAC_RSVD_PAGE2 = 0x84,
-	H2C_D0_SCAN_OFFLOAD_CTRL = 0x85,
-	H2C_D0_SCAN_OFFLOAD_INFO = 0x86,
-	H2C_CHNL_SWITCH_OFFLOAD = 0x87,
-	H2C_AOAC_RSVDPAGE3 = 0x88,
-	H2C_P2P_OFFLOAD_RSVD_PAGE = 0x8A,
-	H2C_P2P_OFFLOAD = 0x8B,
-	H2C_BA_OFFLOAD = 0x90,
-	H2C_DHCP_RENEW = 0x91,
-	H2C_DYNAMIC_TX_PWR = 0x92,
-#ifdef CONFIG_WOWLAN_SSL_KEEP_ALIVE
-	H2C_SSL_OFFLOAD = 0x93,
-#endif
-	H2C_PNO = 0x94,
-	H2C_RESET_TSF = 0xC0,
-	H2C_BCNHWSEQ = 0xC5,
-	H2C_TSF_LATCH = 0xC9,
-#if defined(CONFIG_UNSUPPORT_PLCPHDR_RPT) && (CONFIG_UNSUPPORT_PLCPHDR_RPT)
-	H2C_UNSUPPORT_PLCPHDR_RPT = 0xCC,
-#endif
-	H2C_MAXID,
-};
-
-#define H2C_INACTIVE_PS_LEN		3
-#define H2C_RSVDPAGE_LOC_LEN		5
-#define H2C_MEDIA_STATUS_RPT_LEN		3
-
-#define H2C_KEEP_ALIVE_CTRL_LEN	6
-#define H2C_DISCON_DECISION_LEN		3
-#define H2C_PNO_LEN		        4
-#define H2C_TCP_KEEP_ALIVE_CTRL_LEN 6
-#define H2C_DHCP_RENEW_CTRL_LEN 6
-
-#define H2C_AP_OFFLOAD_LEN		3
-#define H2C_AP_WOW_GPIO_CTRL_LEN	4
-#define H2C_AP_PS_LEN			2
-#define H2C_PWRMODE_LEN			7
-#define H2C_PSTUNEPARAM_LEN			4
-#define H2C_MACID_CFG_LEN		7
-#define H2C_BTMP_OPER_LEN			5
-#define H2C_WOWLAN_LEN			5
-#define H2C_REMOTE_WAKE_CTRL_LEN	3
-#define H2C_BA_OFFLOAD_LEN          2
-#define H2C_AOAC_GLOBAL_INFO_LEN	2
-#define H2C_AOAC_RSVDPAGE_LOC_LEN	7
-#define H2C_SCAN_OFFLOAD_CTRL_LEN	4
-#define H2C_BT_FW_PATCH_LEN			6
-#define H2C_RSSI_SETTING_LEN		4
-#define H2C_AP_REQ_TXRPT_LEN		2
-#define H2C_FORCE_BT_TXPWR_LEN		3
-#define H2C_BCN_RSVDPAGE_LEN		5
-#define H2C_PROBERSP_RSVDPAGE_LEN	5
-#define H2C_P2PRSVDPAGE_LOC_LEN	5
-#define H2C_P2P_OFFLOAD_LEN	3
-#define H2C_TSF_LATCH_LEN		2
-#define H2C_DEFAULT_PORT_LEN	2
-#define H2C_B_TYPE_TDMA_LEN	5
-#define H2C_DYNAMIC_TX_PWR_LEN	5
-
-#define eq_mac_addr(a, b)						(((a)[0] == (b)[0] && (a)[1] == (b)[1] && (a)[2] == (b)[2] && (a)[3] == (b)[3] && (a)[4] == (b)[4] && (a)[5] == (b)[5]) ? 1 : 0)
-#define cp_mac_addr(des, src)					((des)[0] = (src)[0], (des)[1] = (src)[1], (des)[2] = (src)[2], (des)[3] = (src)[3], (des)[4] = (src)[4], (des)[5] = (src)[5])
-#define cpIpAddr(des, src)					((des)[0] = (src)[0], (des)[1] = (src)[1], (des)[2] = (src)[2], (des)[3] = (src)[3])
-
-/* _RSVDPAGE_LOC_CMD_0x00 */
-#define SET_H2CCMD_RSVDPAGE_LOC_PROBE_RSP(__pH2CCmd, __Value)		SET_BITS_TO_LE_1BYTE(__pH2CCmd, 0, 8, __Value)
-#define SET_H2CCMD_RSVDPAGE_LOC_PSPOLL(__pH2CCmd, __Value)			SET_BITS_TO_LE_1BYTE((__pH2CCmd)+1, 0, 8, __Value)
-#define SET_H2CCMD_RSVDPAGE_LOC_NULL_DATA(__pH2CCmd, __Value)		SET_BITS_TO_LE_1BYTE((__pH2CCmd)+2, 0, 8, __Value)
-#define SET_H2CCMD_RSVDPAGE_LOC_QOS_NULL_DATA(__pH2CCmd, __Value)	SET_BITS_TO_LE_1BYTE((__pH2CCmd)+3, 0, 8, __Value)
-#define SET_H2CCMD_RSVDPAGE_LOC_BT_QOS_NULL_DATA(__pH2CCmd, __Value)SET_BITS_TO_LE_1BYTE((__pH2CCmd)+4, 0, 8, __Value)
-
-/* _MEDIA_STATUS_RPT_PARM_CMD_0x01 */
-#define SET_H2CCMD_MSRRPT_PARM_OPMODE(__pH2CCmd, __Value)			SET_BITS_TO_LE_1BYTE(((u8 *)(__pH2CCmd)), 0, 1, (__Value))
-#define SET_H2CCMD_MSRRPT_PARM_MACID_IND(__pH2CCmd, __Value)		SET_BITS_TO_LE_1BYTE(((u8 *)(__pH2CCmd)), 1, 1, (__Value))
-#define SET_H2CCMD_MSRRPT_PARM_MIRACAST(__pH2CCmd, __Value)			SET_BITS_TO_LE_1BYTE(((u8 *)(__pH2CCmd)), 2, 1, (__Value))
-#define SET_H2CCMD_MSRRPT_PARM_MIRACAST_SINK(__pH2CCmd, __Value)	SET_BITS_TO_LE_1BYTE(((u8 *)(__pH2CCmd)), 3, 1, (__Value))
-#define SET_H2CCMD_MSRRPT_PARM_ROLE(__pH2CCmd, __Value)				SET_BITS_TO_LE_1BYTE(((u8 *)(__pH2CCmd)), 4, 4, (__Value))
-#define SET_H2CCMD_MSRRPT_PARM_MACID(__pH2CCmd, __Value)			SET_BITS_TO_LE_1BYTE(((u8 *)(__pH2CCmd)) + 1, 0, 8, (__Value))
-#define SET_H2CCMD_MSRRPT_PARM_MACID_END(__pH2CCmd, __Value)		SET_BITS_TO_LE_1BYTE(((u8 *)(__pH2CCmd)) + 2, 0, 8, (__Value))
-
-#define GET_H2CCMD_MSRRPT_PARM_OPMODE(__pH2CCmd)		LE_BITS_TO_1BYTE(((u8 *)(__pH2CCmd)), 0, 1)
-#define GET_H2CCMD_MSRRPT_PARM_MIRACAST(__pH2CCmd)		LE_BITS_TO_1BYTE(((u8 *)(__pH2CCmd)), 2, 1)
-#define GET_H2CCMD_MSRRPT_PARM_MIRACAST_SINK(__pH2CCmd)	LE_BITS_TO_1BYTE(((u8 *)(__pH2CCmd)), 3, 1)
-#define GET_H2CCMD_MSRRPT_PARM_ROLE(__pH2CCmd)			LE_BITS_TO_1BYTE(((u8 *)(__pH2CCmd)), 4, 4)
-
-#define H2C_MSR_ROLE_RSVD	0
-#define H2C_MSR_ROLE_STA	1
-#define H2C_MSR_ROLE_AP		2
-#define H2C_MSR_ROLE_GC		3
-#define H2C_MSR_ROLE_GO		4
-#define H2C_MSR_ROLE_TDLS	5
-#define H2C_MSR_ROLE_ADHOC	6
-#define H2C_MSR_ROLE_MAX	7
-
-extern const char *const _h2c_msr_role_str[];
-#define h2c_msr_role_str(role) (((role) >= H2C_MSR_ROLE_MAX) ? _h2c_msr_role_str[H2C_MSR_ROLE_MAX] : _h2c_msr_role_str[(role)])
-
-#define H2C_MSR_FMT "%s %s%s"
-#define H2C_MSR_ARG(h2c_msr) \
-	GET_H2CCMD_MSRRPT_PARM_OPMODE((h2c_msr)) ? " C" : "", \
-	h2c_msr_role_str(GET_H2CCMD_MSRRPT_PARM_ROLE((h2c_msr))), \
-	GET_H2CCMD_MSRRPT_PARM_MIRACAST((h2c_msr)) ? (GET_H2CCMD_MSRRPT_PARM_MIRACAST_SINK((h2c_msr)) ? " MSINK" : " MSRC") : ""
-
-s32 rtw_hal_set_FwMediaStatusRpt_cmd(_adapter *adapter, bool opmode, bool miracast, bool miracast_sink, u8 role, u8 macid, bool macid_ind, u8 macid_end);
-s32 rtw_hal_set_FwMediaStatusRpt_single_cmd(_adapter *adapter, bool opmode, bool miracast, bool miracast_sink, u8 role, u8 macid);
-s32 rtw_hal_set_FwMediaStatusRpt_range_cmd(_adapter *adapter, bool opmode, bool miracast, bool miracast_sink, u8 role, u8 macid, u8 macid_end);
-
-/* _KEEP_ALIVE_CMD_0x03 */
-#define SET_H2CCMD_KEEPALIVE_PARM_ENABLE(__pH2CCmd, __Value)		SET_BITS_TO_LE_1BYTE(__pH2CCmd, 0, 1, __Value)
-#define SET_H2CCMD_KEEPALIVE_PARM_ADOPT(__pH2CCmd, __Value)		SET_BITS_TO_LE_1BYTE(__pH2CCmd, 1, 1, __Value)
-#define SET_H2CCMD_KEEPALIVE_PARM_PKT_TYPE(__pH2CCmd, __Value)		SET_BITS_TO_LE_1BYTE(__pH2CCmd, 2, 1, __Value)
-#define SET_H2CCMD_KEEPALIVE_PARM_CHECK_PERIOD(__pH2CCmd, __Value)	SET_BITS_TO_LE_1BYTE(__pH2CCmd+1, 0, 8, __Value)
-#define SET_H2CCMD_KEEPALIVE_WATCHDOG_RFE_CTRL(__pH2CCmd, __Value) SET_BITS_TO_LE_1BYTE(__pH2CCmd+2, 0, 8, __Value)
-#define SET_H2CCMD_KEEPALIVE_WATCHDOG_INTERVAL(__pH2CCmd, __Value) SET_BITS_TO_LE_1BYTE(__pH2CCmd+3, 0, 8, __Value)
-
-/* _DISCONNECT_DECISION_CMD_0x04 */
-#define SET_H2CCMD_DISCONDECISION_PARM_ENABLE(__pH2CCmd, __Value)		SET_BITS_TO_LE_1BYTE(__pH2CCmd, 0, 1, __Value)
-#define SET_H2CCMD_DISCONDECISION_PARM_ADOPT(__pH2CCmd, __Value)		SET_BITS_TO_LE_1BYTE(__pH2CCmd, 1, 1, __Value)
-#define SET_H2CCMD_DISCONDECISION_PARM_TRY_OK_BCN_FAIL_COUNT_EN(__pH2CCmd, __Value)		SET_BITS_TO_LE_1BYTE(__pH2CCmd, 2, 1, __Value)
-#define SET_H2CCMD_DISCONDECISION_PARM_CHECK_PERIOD(__pH2CCmd, __Value)	SET_BITS_TO_LE_1BYTE(__pH2CCmd+1, 0, 8, __Value)
-#define SET_H2CCMD_DISCONDECISION_PARM_TRY_PKT_NUM(__pH2CCmd, __Value)	SET_BITS_TO_LE_1BYTE(__pH2CCmd+2, 0, 8, __Value)
-
-/* _PMO_CMD_0x94 */
-#define SET_H2CCMD_PNO_PARM_ENABLE(__pH2CCmd, __Value)						SET_BITS_TO_LE_1BYTE(__pH2CCmd, 0, 1, __Value)
-#define SET_H2CCMD_PNO_PARM_DTIM(__pH2CCmd, __Value)					    SET_BITS_TO_LE_1BYTE(__pH2CCmd, 1, 4, __Value)
-#define SET_H2CCMD_PNO_PARM_INTERVAL_L(__pH2CCmd, __Value)					SET_BITS_TO_LE_1BYTE(__pH2CCmd+1, 0, 8, __Value)
-#define SET_H2CCMD_PNO_PARM_INTERVAL_H(__pH2CCmd, __Value)					SET_BITS_TO_LE_1BYTE(__pH2CCmd+2, 0, 8, __Value)
-#define SET_H2CCMD_PNO_PARM_FORCE_WAKEUP(__pH2CCmd, __Value)				SET_BITS_TO_LE_1BYTE(__pH2CCmd+3, 0, 8, __Value)
-
-/* _TCP_KEEP_ALIVE_CMD_0x07 */
-#define SET_H2CCMD_TCP_KEEPALIVE_PARM_ENABLE(__pH2CCmd, __Value)			SET_BITS_TO_LE_1BYTE(__pH2CCmd, 0, 1, __Value)
-#define SET_H2CCMD_TCP_KEEPALIVE_PARM_ADOPT(__pH2CCmd, __Value)				SET_BITS_TO_LE_1BYTE(__pH2CCmd, 1, 1, __Value)
-#define SET_H2CCMD_TCP_KEEPALIVE_PARM_DTIMTO_ENABLE(__pH2CCmd, __Value)			SET_BITS_TO_LE_1BYTE(__pH2CCmd, 3, 1, __Value)
-#define SET_H2CCMD_TCP_KEEPALIVE_PARM_DTIMTO_RETRY_INC(__pH2CCmd, __Value)		SET_BITS_TO_LE_1BYTE(__pH2CCmd, 4, 1, __Value)
-#define SET_H2CCMD_TCP_KEEPALIVE_PARM_DTIMTO_SSL_EN(__pH2CCmd, __Value)		SET_BITS_TO_LE_1BYTE(__pH2CCmd, 5, 1, __Value)
-#define SET_H2CCMD_TCP_KEEPALIVE_PARM_CHECK_PERIOD(__pH2CCmd, __Value)		SET_BITS_TO_LE_1BYTE(__pH2CCmd+1, 0, 8, __Value)
-#define SET_H2CCMD_TCP_KEEPALIVE_PARM_LOC(__pH2CCmd, __Value)				SET_BITS_TO_LE_1BYTE(__pH2CCmd+2, 0, 8, __Value)
-#define SET_H2CCMD_TCP_KEEPALIVE_PARM_RESEND_INTERVAL(__pH2CCmd, __Value)	SET_BITS_TO_LE_1BYTE(__pH2CCmd+3, 0, 8, __Value)
-#define SET_H2CCMD_TCP_KEEPALIVE_PARM_FIRST_PKT_TIME(__pH2CCmd, __Value)	SET_BITS_TO_LE_1BYTE(__pH2CCmd+4, 0, 8, __Value)
-#define SET_H2CCMD_TCP_KEEPALIVE_PARM_ACK_TIMEOUT(__pH2CCmd, __Value)
-
-/* _DHCP_RENEW_CMD_0x91 */
-#define SET_H2CCMD_DHCP_RENEW_PARM_ENABLE(__pH2CCmd, __Value)			SET_BITS_TO_LE_1BYTE(__pH2CCmd, 0, 1, __Value)
-#define	SET_H2CCMD_DHCP_RENEW_PARM_LOC(__pH2CCmd, __Value)                      SET_BITS_TO_LE_1BYTE(__pH2CCmd+1, 0, 8, __Value)
-#define	SET_H2CCMD_DHCP_RENEW_PARM_T1_H(__pH2CCmd, __Value)              SET_BITS_TO_LE_1BYTE(__pH2CCmd+2, 0, 8, __Value)
-#define	SET_H2CCMD_DHCP_RENEW_PARM_T1_L(__pH2CCmd, __Value)              SET_BITS_TO_LE_1BYTE(__pH2CCmd+3, 0, 8, __Value)
-#define	SET_H2CCMD_DHCP_RENEW_PARM_LEASE_H(__pH2CCmd, __Value)        SET_BITS_TO_LE_1BYTE(__pH2CCmd+4, 0, 8, __Value)
-#define	SET_H2CCMD_DHCP_RENEW_PARM_LEASE_L(__pH2CCmd, __Value)        SET_BITS_TO_LE_1BYTE(__pH2CCmd+5, 0, 8, __Value)
-
-/* _DYNAMIC_TX_PWR_CMD_0x92 */
-#define SET_H2CCMD_DYNAMIC_TX_PWR_ENABLE(__pH2CCmd, __Value)			SET_BITS_TO_LE_1BYTE(__pH2CCmd, 0, 1, __Value)
-#define	SET_H2CCMD_DYNAMIC_TX_PWR_THS_L(__pH2CCmd, __Value)				SET_BITS_TO_LE_1BYTE(__pH2CCmd+1, 0, 8, __Value)
-#define	SET_H2CCMD_DYNAMIC_TX_PWR_THS_H(__pH2CCmd, __Value)				SET_BITS_TO_LE_1BYTE(__pH2CCmd+2, 0, 8, __Value)
-#define	SET_H2CCMD_DYNAMIC_TX_PWR_OFS_L(__pH2CCmd, __Value)				SET_BITS_TO_LE_1BYTE(__pH2CCmd+3, 0, 8, __Value)
-#define	SET_H2CCMD_DYNAMIC_TX_PWR_OFS_H(__pH2CCmd, __Value)				SET_BITS_TO_LE_1BYTE(__pH2CCmd+4, 0, 8, __Value)
-/* _AP_Offload 0x08 */
-#define SET_H2CCMD_AP_WOWLAN_EN(__pH2CCmd, __Value)			SET_BITS_TO_LE_1BYTE(__pH2CCmd, 0, 8, __Value)
-/* _BCN_RsvdPage	0x09 */
-#define SET_H2CCMD_AP_WOWLAN_RSVDPAGE_LOC_BCN(__pH2CCmd, __Value)		SET_BITS_TO_LE_1BYTE(__pH2CCmd, 0, 8, __Value)
-/* _Probersp_RsvdPage 0x0a */
-#define SET_H2CCMD_AP_WOWLAN_RSVDPAGE_LOC_ProbeRsp(__pH2CCmd, __Value)	SET_BITS_TO_LE_1BYTE(__pH2CCmd, 0, 8, __Value)
-/* _Probersp_RsvdPage 0x13 */
-#define SET_H2CCMD_AP_WOW_GPIO_CTRL_INDEX(__pH2CCmd, __Value)		SET_BITS_TO_LE_1BYTE(__pH2CCmd, 0, 4, __Value)
-#define SET_H2CCMD_AP_WOW_GPIO_CTRL_C2H_EN(__pH2CCmd, __Value)		SET_BITS_TO_LE_1BYTE(__pH2CCmd, 4, 1, __Value)
-#define SET_H2CCMD_AP_WOW_GPIO_CTRL_PLUS(__pH2CCmd, __Value)		SET_BITS_TO_LE_1BYTE(__pH2CCmd, 5, 1, __Value)
-#define SET_H2CCMD_AP_WOW_GPIO_CTRL_HIGH_ACTIVE(__pH2CCmd, __Value)	SET_BITS_TO_LE_1BYTE(__pH2CCmd, 6, 1, __Value)
-#define SET_H2CCMD_AP_WOW_GPIO_CTRL_EN(__pH2CCmd, __Value)		SET_BITS_TO_LE_1BYTE(__pH2CCmd, 7, 1, __Value)
-#define SET_H2CCMD_AP_WOW_GPIO_CTRL_DURATION(__pH2CCmd, __Value)	SET_BITS_TO_LE_1BYTE((__pH2CCmd)+1, 0, 8, __Value)
-#define SET_H2CCMD_AP_WOW_GPIO_CTRL_C2H_DURATION(__pH2CCmd, __Value)SET_BITS_TO_LE_1BYTE((__pH2CCmd)+2, 0, 8, __Value)
-/* _AP_PS 0x26 */
-#define SET_H2CCMD_AP_WOW_PS_EN(__pH2CCmd, __Value)			SET_BITS_TO_LE_1BYTE(__pH2CCmd, 0, 1, __Value)
-#define SET_H2CCMD_AP_WOW_PS_32K_EN(__pH2CCmd, __Value)		SET_BITS_TO_LE_1BYTE(__pH2CCmd, 1, 1, __Value)
-#define SET_H2CCMD_AP_WOW_PS_RF(__pH2CCmd, __Value)			SET_BITS_TO_LE_1BYTE(__pH2CCmd, 2, 1, __Value)
-#define SET_H2CCMD_AP_WOW_PS_DURATION(__pH2CCmd, __Value)	SET_BITS_TO_LE_1BYTE((__pH2CCmd)+1, 0, 8, __Value)
-
-
-/* CHNL SWITCH OPER OFFLOAD 0x1C */
-#define SET_H2CCMD_CH_SW_OPER_OFFLOAD_CH_NUM(__pH2CCmd, __Value)	SET_BITS_TO_LE_1BYTE(__pH2CCmd, 0, 8, __Value)
-#define SET_H2CCMD_CH_SW_OPER_OFFLOAD_BW_MODE(__pH2CCmd, __Value)	SET_BITS_TO_LE_1BYTE((__pH2CCmd) + 1, 0, 2, __Value)
-#define SET_H2CCMD_CH_SW_OPER_OFFLOAD_BW_40M_SC(__pH2CCmd, __Value)	SET_BITS_TO_LE_1BYTE((__pH2CCmd) + 1, 2, 3, __Value)
-#define SET_H2CCMD_CH_SW_OPER_OFFLOAD_BW_80M_SC(__pH2CCmd, __Value)	SET_BITS_TO_LE_1BYTE((__pH2CCmd) + 1, 5, 3, __Value)
-#define SET_H2CCMD_CH_SW_OPER_OFFLOAD_RFE_TYPE(__pH2CCmd, __Value)	SET_BITS_TO_LE_1BYTE((__pH2CCmd) + 2, 0, 4, __Value)
-
-/* _WoWLAN PARAM_CMD_0x80 */
-#define SET_H2CCMD_WOWLAN_FUNC_ENABLE(__pH2CCmd, __Value)			SET_BITS_TO_LE_1BYTE(__pH2CCmd, 0, 1, __Value)
-#define SET_H2CCMD_WOWLAN_PATTERN_MATCH_ENABLE(__pH2CCmd, __Value)	SET_BITS_TO_LE_1BYTE(__pH2CCmd, 1, 1, __Value)
-#define SET_H2CCMD_WOWLAN_MAGIC_PKT_ENABLE(__pH2CCmd, __Value)		SET_BITS_TO_LE_1BYTE(__pH2CCmd, 2, 1, __Value)
-#define SET_H2CCMD_WOWLAN_UNICAST_PKT_ENABLE(__pH2CCmd, __Value)	SET_BITS_TO_LE_1BYTE(__pH2CCmd, 3, 1, __Value)
-#define SET_H2CCMD_WOWLAN_ALL_PKT_DROP(__pH2CCmd, __Value)			SET_BITS_TO_LE_1BYTE(__pH2CCmd, 4, 1, __Value)
-#define SET_H2CCMD_WOWLAN_GPIO_ACTIVE(__pH2CCmd, __Value)			SET_BITS_TO_LE_1BYTE(__pH2CCmd, 5, 1, __Value)
-#define SET_H2CCMD_WOWLAN_REKEY_WAKE_UP(__pH2CCmd, __Value)			SET_BITS_TO_LE_1BYTE(__pH2CCmd, 6, 1, __Value)
-#define SET_H2CCMD_WOWLAN_DISCONNECT_WAKE_UP(__pH2CCmd, __Value)	SET_BITS_TO_LE_1BYTE(__pH2CCmd, 7, 1, __Value)
-#define SET_H2CCMD_WOWLAN_GPIONUM(__pH2CCmd, __Value)				SET_BITS_TO_LE_1BYTE((__pH2CCmd)+1, 0, 7, __Value)
-#define SET_H2CCMD_WOWLAN_DATAPIN_WAKE_UP(__pH2CCmd, __Value)		SET_BITS_TO_LE_1BYTE((__pH2CCmd)+1, 7, 1, __Value)
-#define SET_H2CCMD_WOWLAN_GPIO_DURATION(__pH2CCmd, __Value)			SET_BITS_TO_LE_1BYTE((__pH2CCmd)+2, 0, 8, __Value)
-#define SET_H2CCMD_WOWLAN_GPIO_PULSE_EN(__pH2CCmd, __Value)		SET_BITS_TO_LE_1BYTE((__pH2CCmd)+3, 0, 1, __Value)
-#define SET_H2CCMD_WOWLAN_GPIO_PULSE_COUNT(__pH2CCmd, __Value)		SET_BITS_TO_LE_1BYTE((__pH2CCmd)+3, 1, 7, __Value)
-#define SET_H2CCMD_WOWLAN_LOWPR_RX(__pH2CCmd, __Value)				SET_BITS_TO_LE_1BYTE((__pH2CCmd)+4, 0, 1, __Value)
-#define SET_H2CCMD_WOWLAN_CHANGE_UNIT(__pH2CCmd, __Value)		SET_BITS_TO_LE_1BYTE((__pH2CCmd)+4, 2, 1, __Value)
-/* _REMOTE_WAKEUP_CMD_0x81 */
-#define SET_H2CCMD_REMOTE_WAKECTRL_ENABLE(__pH2CCmd, __Value)		SET_BITS_TO_LE_1BYTE(__pH2CCmd, 0, 1, __Value)
-#define SET_H2CCMD_REMOTE_WAKE_CTRL_ARP_OFFLOAD_EN(__pH2CCmd, __Value)	SET_BITS_TO_LE_1BYTE(__pH2CCmd, 1, 1, __Value)
-#define SET_H2CCMD_REMOTE_WAKE_CTRL_NDP_OFFLOAD_EN(__pH2CCmd, __Value)	SET_BITS_TO_LE_1BYTE(__pH2CCmd, 2, 1, __Value)
-#define SET_H2CCMD_REMOTE_WAKE_CTRL_GTK_OFFLOAD_EN(__pH2CCmd, __Value)	SET_BITS_TO_LE_1BYTE(__pH2CCmd, 3, 1, __Value)
-#define SET_H2CCMD_REMOTE_WAKE_CTRL_NLO_OFFLOAD_EN(__pH2CCmd, __Value)	SET_BITS_TO_LE_1BYTE(__pH2CCmd, 4, 1, __Value)
-#define SET_H2CCMD_REMOTE_WAKE_CTRL_FW_UNICAST_EN(__pH2CCmd, __Value)	SET_BITS_TO_LE_1BYTE(__pH2CCmd, 7, 1, __Value)
-#define SET_H2CCMD_REMOTE_WAKE_CTRL_P2P_OFFLAD_EN(__pH2CCmd, __Value)	SET_BITS_TO_LE_1BYTE((__pH2CCmd)+1, 0, 1, __Value)
-#define SET_H2CCMD_REMOTE_WAKE_CTRL_NBNS_FILTER_EN(__pH2CCmd, __Value)	SET_BITS_TO_LE_1BYTE((__pH2CCmd)+1, 2, 1, __Value)
-#define SET_H2CCMD_REMOTE_WAKE_CTRL_TKIP_OFFLOAD_EN(__pH2CCmd, __Value)	SET_BITS_TO_LE_1BYTE((__pH2CCmd)+1, 3, 1, __Value)
-#define SET_H2CCMD_REMOTE_WAKE_CTRL_ARP_ACTION(__pH2CCmd, __Value)	SET_BITS_TO_LE_1BYTE((__pH2CCmd)+2, 0, 1, __Value)
-#define SET_H2CCMD_REMOTE_WAKE_CTRL_FW_PARSING_UNTIL_WAKEUP(__pH2CCmd, __Value)	SET_BITS_TO_LE_1BYTE((__pH2CCmd)+2, 4, 1, __Value)
-#define SET_H2CCMD_REMOTE_WAKE_CTRL_ARP_POWER_BIT_EN(__pH2CCmd, __Value)	SET_BITS_TO_LE_1BYTE((__pH2CCmd)+2, 7, 1, __Value)
-#define SET_H2CCMD_REMOTE_WAKE_CTRL_ARP_REQ_OFLD_EN(__pH2CCmd, __Value) SET_BITS_TO_LE_1BYTE((__pH2CCmd)+4, 3, 1, __Value)
-#define SET_H2CCMD_REMOTE_WAKE_CTRL_ARP_REQ_PWR_BIT(__pH2CCmd, __Value) SET_BITS_TO_LE_1BYTE((__pH2CCmd)+4, 4, 1, __Value)
-#define SET_H2CCMD_REMOTE_WAKE_CTRL_ARP_REQ_DTIM1TO_EN(__pH2CCmd, __Value) SET_BITS_TO_LE_1BYTE((__pH2CCmd)+4, 5, 1, __Value)
-#define SET_H2CCMD_REMOTE_WAKE_CTRL_ARP_REQ_LOC(__pH2CCmd, __Value) SET_BITS_TO_LE_1BYTE((__pH2CCmd)+5, 0, 8, __Value)
-
-/* AOAC_GLOBAL_INFO_0x82 */
-#define SET_H2CCMD_AOAC_GLOBAL_INFO_PAIRWISE_ENC_ALG(__pH2CCmd, __Value)	SET_BITS_TO_LE_1BYTE(__pH2CCmd, 0, 8, __Value)
-#define SET_H2CCMD_AOAC_GLOBAL_INFO_GROUP_ENC_ALG(__pH2CCmd, __Value)		SET_BITS_TO_LE_1BYTE((__pH2CCmd)+1, 0, 8, __Value)
-
-/* AOAC_RSVDPAGE_LOC_0x83 */
-#define SET_H2CCMD_AOAC_RSVDPAGE_LOC_REMOTE_WAKE_CTRL_INFO(__pH2CCmd, __Value)	SET_BITS_TO_LE_1BYTE((__pH2CCmd), 0, 8, __Value)
-#define SET_H2CCMD_AOAC_RSVDPAGE_LOC_ARP_RSP(__pH2CCmd, __Value)		SET_BITS_TO_LE_1BYTE((__pH2CCmd)+1, 0, 8, __Value)
-#define SET_H2CCMD_AOAC_RSVDPAGE_LOC_NEIGHBOR_ADV(__pH2CCmd, __Value)		SET_BITS_TO_LE_1BYTE((__pH2CCmd)+2, 0, 8, __Value)
-#define SET_H2CCMD_AOAC_RSVDPAGE_LOC_GTK_RSP(__pH2CCmd, __Value)		SET_BITS_TO_LE_1BYTE((__pH2CCmd)+3, 0, 8, __Value)
-#define SET_H2CCMD_AOAC_RSVDPAGE_LOC_GTK_INFO(__pH2CCmd, __Value)		SET_BITS_TO_LE_1BYTE((__pH2CCmd)+4, 0, 8, __Value)
-#ifdef CONFIG_GTK_OL
-#define SET_H2CCMD_AOAC_RSVDPAGE_LOC_GTK_EXT_MEM(__pH2CCmd, __Value)		SET_BITS_TO_LE_1BYTE((__pH2CCmd)+5, 0, 8, __Value)
-#endif /* CONFIG_GTK_OL */
-
-/* AOAC_RSVDPAGE_2_0x84 */
-
-/* AOAC_RSVDPAGE_3_0x88 */
-#ifdef CONFIG_PNO_SUPPORT
-#define SET_H2CCMD_AOAC_RSVDPAGE_LOC_NLO_INFO(__pH2CCmd, __Value)		SET_BITS_TO_LE_1BYTE((__pH2CCmd), 0, 8, __Value)
-#endif
-#define SET_H2CCMD_AOAC_RSVDPAGE_LOC_AOAC_REPORT(__pH2CCmd, __Value)		SET_BITS_TO_LE_1BYTE((__pH2CCmd) + 1, 0, 8, __Value)
-
-#ifdef CONFIG_PNO_SUPPORT
-/* D0_Scan_Offload_Info_0x86 */
-#define SET_H2CCMD_AOAC_NLO_FUN_EN(__pH2CCmd, __Value)			SET_BITS_TO_LE_1BYTE((__pH2CCmd), 3, 1, __Value)
-#define SET_H2CCMD_AOAC_NLO_IPS_EN(__pH2CCmd, __Value)			SET_BITS_TO_LE_1BYTE((__pH2CCmd), 4, 1, __Value)
-#define SET_H2CCMD_AOAC_RSVDPAGE_LOC_PROBE_PACKET(__pH2CCmd, __Value)	SET_BITS_TO_LE_1BYTE((__pH2CCmd)+1, 0, 8, __Value)
-#define SET_H2CCMD_AOAC_RSVDPAGE_LOC_SCAN_INFO(__pH2CCmd, __Value)	SET_BITS_TO_LE_1BYTE((__pH2CCmd)+2, 0, 8, __Value)
-#define SET_H2CCMD_AOAC_RSVDPAGE_LOC_SSID_INFO(__pH2CCmd, __Value)	SET_BITS_TO_LE_1BYTE((__pH2CCmd)+3, 0, 8, __Value)
-#endif /* CONFIG_PNO_SUPPORT */
-
-#ifdef CONFIG_P2P_WOWLAN
-/* P2P_RsvdPage_0x8a */
-#define SET_H2CCMD_RSVDPAGE_LOC_P2P_BCN(__pH2CCmd, __Value)			SET_BITS_TO_LE_1BYTE(__pH2CCmd, 0, 8, __Value)
-#define SET_H2CCMD_RSVDPAGE_LOC_P2P_PROBE_RSP(__pH2CCmd, __Value)				SET_BITS_TO_LE_1BYTE((__pH2CCmd)+1, 0, 8, __Value)
-#define SET_H2CCMD_RSVDPAGE_LOC_P2P_NEGO_RSP(__pH2CCmd, __Value)			SET_BITS_TO_LE_1BYTE((__pH2CCmd)+2, 0, 8, __Value)
-#define SET_H2CCMD_RSVDPAGE_LOC_P2P_INVITE_RSP(__pH2CCmd, __Value)		SET_BITS_TO_LE_1BYTE((__pH2CCmd)+3, 0, 8, __Value)
-#define SET_H2CCMD_RSVDPAGE_LOC_P2P_PD_RSP(__pH2CCmd, __Value)	SET_BITS_TO_LE_1BYTE((__pH2CCmd)+4, 0, 8, __Value)
-#endif /* CONFIG_P2P_WOWLAN */
-
-/* BA_offload 0x90 */
-#define SET_H2CCMD_BA_OFFLOAD_ENABLE(__pH2CCmd, __Value)		SET_BITS_TO_LE_1BYTE(__pH2CCmd, 0, 1, __Value)
-#define SET_H2CCMD_BA_OFFLOAD_BA_RSP_LOC(__pH2CCmd, __Value)	SET_BITS_TO_LE_1BYTE(__pH2CCmd+1, 0, 8, __Value)
-
-/* DEFAULT_PORT_CMD_0x2c */
-#define SET_H2CCMD_DEFAULT_PORTNUM(__pH2CCmd, __Value)		SET_BITS_TO_LE_1BYTE(__pH2CCmd, 4, 4, __Value)
-
-/* _TSF_LATCH_CMD_0xc6 */
-#define SET_H2CCMD_TSFLATCH_ENABLE(__pH2CCmd, __Value)		SET_BITS_TO_LE_1BYTE(__pH2CCmd, 0, 1, __Value)
-#define SET_H2CCMD_TSFLATCH_GPIO_DEFAULT_VAL(__pH2CCmd, __Value)		SET_BITS_TO_LE_1BYTE(__pH2CCmd, 1, 1, __Value)
-#define SET_H2CCMD_TSFLATCH_PORTNUM(__pH2CCmd, __Value)		SET_BITS_TO_LE_1BYTE(__pH2CCmd, 4, 4, __Value)
-#define SET_H2CCMD_TSFLATCH_GPIONUM(__pH2CCmd, __Value)	SET_BITS_TO_LE_1BYTE(__pH2CCmd+1, 0, 8, __Value)
-
-/* ---------------------------------------------------------------------------------------------------------
- * -------------------------------------------    Structure    --------------------------------------------------
- * --------------------------------------------------------------------------------------------------------- */
-typedef struct _RSVDPAGE_LOC {
-	u8 LocProbeRsp;
-	u8 LocPsPoll;
-	u8 LocNullData;
-	u8 LocQosNull;
-	u8 LocBTQosNull;
-#ifdef CONFIG_WOWLAN
-	u8 LocRemoteCtrlInfo;
-	u8 LocArpRsp;
-	u8 LocAddbaRsp;
-	u8 LocNbrAdv;
-	u8 LocGTKRsp;
-	u8 LocGTKInfo;
-#ifdef CONFIG_GTK_OL
-	u8 LocGTKEXTMEM;
-#endif /* CONFIG_GTK_OL */
-	u8 LocProbeReq;
-	u8 LocNetList;
-#ifdef CONFIG_WOW_PATTERN_HW_CAM
-	u8 LocAOACReport;
-#endif
-#ifdef CONFIG_PNO_SUPPORT
-	u8 LocPNOInfo;
-	u8 LocScanInfo;
-	u8 LocSSIDInfo;
-	u8 LocProbePacket;
-#endif /* CONFIG_PNO_SUPPORT */
-#endif /* CONFIG_WOWLAN	 */
-	u8 LocApOffloadBCN;
-#ifdef CONFIG_P2P_WOWLAN
-	u8 LocP2PBeacon;
-	u8 LocP2PProbeRsp;
-	u8 LocNegoRsp;
-	u8 LocInviteRsp;
-	u8 LocPDRsp;
-#endif /* CONFIG_P2P_WOWLAN */
-} RSVDPAGE_LOC, *PRSVDPAGE_LOC;
-
-#endif
-void dump_TX_FIFO(PADAPTER padapter, u8 page_num, u16 page_size);
-u8 rtw_hal_set_fw_media_status_cmd(_adapter *adapter, u8 mstatus, u8 macid);
-#if defined(CONFIG_WOWLAN) || defined(CONFIG_AP_WOWLAN)
-/* WOW command function */
-#ifdef CONFIG_P2P_WOWLAN
-/* H2C 0x8A */
-u8 rtw_hal_set_FwP2PRsvdPage_cmd(_adapter *adapter, PRSVDPAGE_LOC rsvdpageloc);
-/* H2C 0x8B */
-u8 rtw_hal_set_p2p_wowlan_offload_cmd(_adapter *adapter);
-#endif /* CONFIG_P2P_WOWLAN */
-#endif
diff --git a/os/board/rtl8720e/src/component/wifi/driver/include/hal_com_phycfg.h b/os/board/rtl8720e/src/component/wifi/driver/include/hal_com_phycfg.h
deleted file mode 100644
index 3bb0ec6c6..000000000
--- a/os/board/rtl8720e/src/component/wifi/driver/include/hal_com_phycfg.h
+++ /dev/null
@@ -1,293 +0,0 @@
-/******************************************************************************
- *
- * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of version 2 of the GNU General Public License as
- * published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
- * more details.
- *
- * You should have received a copy of the GNU General Public License along with
- * this program; if not, write to the Free Software Foundation, Inc.,
- * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
- *
- *
- ******************************************************************************/
-#ifndef __HAL_COM_PHYCFG_H__
-#define __HAL_COM_PHYCFG_H__
-
-#define		PathA                     			0x0	// Useless
-#define		PathB                     			0x1
-#define		PathC                     			0x2
-#define		PathD                     			0x3
-
-typedef enum _RATE_SECTION {
-	CCK = 0,
-	OFDM,
-	HT_MCS0_MCS7,
-	HT_MCS8_MCS15,
-	HT_MCS16_MCS23,
-	HT_MCS24_MCS31,
-	VHT_1SSMCS0_1SSMCS9,
-	VHT_2SSMCS0_2SSMCS9,
-	VHT_3SSMCS0_3SSMCS9,
-	VHT_4SSMCS0_4SSMCS9,
-	RATE_SECTION_NUM,
-} RATE_SECTION;
-
-typedef enum _RF_TX_NUM {
-	RF_1TX = 0,
-	RF_2TX,
-	RF_3TX,
-	RF_4TX,
-	RF_MAX_TX_NUM,
-	RF_TX_NUM_NONIMPLEMENT,
-} RF_TX_NUM;
-
-#if (RTL8721D_SUPPORT == 1) || (RTL8735B_SUPPORT == 1) || (RTL8720E_SUPPORT == 1) || (RTL8730E_SUPPORT == 1)  || (RTL8721F_SUPPORT == 1)
-#define MAX_POWER_INDEX 		0x7F //8721d TXAGC power index extends 1 bit (6 bit->7bit), 0.25dB a step
-#else
-#define MAX_POWER_INDEX 		0x3F
-#endif
-
-typedef enum _REGULATION_TXPWR_LMT {
-	TXPWR_LMT_FCC = 0,
-	TXPWR_LMT_MKK = 1,
-	TXPWR_LMT_ETSI = 2,
-	TXPWR_LMT_IC = 3,
-	TXPWR_LMT_KCC = 4,
-	TXPWR_LMT_ACMA = 5,
-	TXPWR_LMT_CHILE = 6,
-	TXPWR_LMT_MEXICO = 7,
-	TXPWR_LMT_WW = 8, // WW13, The mininum of ETSI,MKK
-	TXPWR_LMT_GL = 9, // Global, The mininum of all
-	TXPWR_LMT_UKRAINE = 10,
-	TXPWR_LMT_CN = 11,
-	TXPWR_LMT_QATAR = 12,
-	TXPWR_LMT_UK = 13,
-	TXPWR_LMT_NCC = 14,
-	TXPWR_LMT_MAX_REGULATION_NUM = 15,
-	TXPWR_LMT_NA = 16  /* Not support, choose NA */
-} REGULATION_TXPWR_LMT;
-
-/*------------------------------Define structure----------------------------*/
-typedef struct _BB_REGISTER_DEFINITION {
-	u32 rfintfs;			// set software control:
-	//		0x870~0x877[8 bytes]
-
-	u32 rfintfo; 			// output data:
-	//		0x860~0x86f [16 bytes]
-
-	u32 rfintfe; 			// output enable:
-	//		0x860~0x86f [16 bytes]
-
-	u32 rf3wireOffset;	// LSSI data:
-	//		0x840~0x84f [16 bytes]
-
-	u32 rfHSSIPara2; 	// wire parameter control2 :
-	//		0x824~0x827,0x82c~0x82f, 0x834~0x837, 0x83c~0x83f [16 bytes]
-
-	u32 rfLSSIReadBack; 	//LSSI RF readback data SI mode
-	//		0x8a0~0x8af [16 bytes]
-
-	u32 rfLSSIReadBackPi; 	//LSSI RF readback data PI mode 0x8b8-8bc for Path A and B
-
-} BB_REGISTER_DEFINITION_T, *PBB_REGISTER_DEFINITION_T;
-
-
-//----------------------------------------------------------------------
-s32
-phy_TxPwrIdxToDbm(
-	IN	PADAPTER		Adapter,
-	IN	WIRELESS_MODE	WirelessMode,
-	IN	u8				TxPwrIdx
-);
-
-u8
-PHY_GetTxPowerByRateBase(
-	IN	PADAPTER		Adapter,
-	IN	u8				Band,
-	IN	u8				RfPath,
-	IN	u8				TxNum,
-	IN	RATE_SECTION	RateSection
-);
-
-u8
-PHY_GetRateSectionIndexOfTxPowerByRate(
-	IN	PADAPTER	pAdapter,
-	IN	u32			RegAddr,
-	IN	u32			BitMask
-);
-
-VOID
-PHY_GetRateValuesOfTxPowerByRate(
-	IN	PADAPTER	pAdapter,
-	IN	u32			RegAddr,
-	IN	u32			BitMask,
-	IN	u32			Value,
-	OUT	u8			*RateIndex,
-	OUT	s8			*PwrByRateVal,
-	OUT	u8			*RateNum
-);
-
-u8
-PHY_GetRateIndexOfTxPowerByRate(
-	IN	u8	Rate
-);
-
-VOID
-PHY_SetTxPowerIndexByRateSection(
-	IN	PADAPTER		pAdapter,
-	IN	u8				RFPath,
-	IN	u8				Channel,
-	IN	u8				RateSection
-);
-
-s8
-PHY_GetTxPowerByRate(
-	IN	PADAPTER	pAdapter,
-	IN	u8			Band,
-	IN	u8			RFPath,
-	IN	u8			TxNum,
-	IN	u8			RateIndex
-);
-
-VOID
-PHY_SetTxPowerByRate(
-	IN	PADAPTER	pAdapter,
-	IN	u8			Band,
-	IN	u8			RFPath,
-	IN	u8			TxNum,
-	IN	u8			Rate,
-	IN	s8			Value
-);
-
-VOID
-PHY_SetTxPowerLevelByPath(
-	IN	PADAPTER	Adapter,
-	IN	u8			channel,
-	IN	u8			path
-);
-
-VOID
-PHY_SetTxPowerIndexByRateArray(
-	IN	PADAPTER		pAdapter,
-	IN	u8				RFPath,
-	IN	enum channel_width	BandWidth,
-	IN	u8				Channel,
-	IN	u8				*Rates,
-	IN	u8				RateArraySize
-);
-
-VOID
-PHY_InitTxPowerByRate(
-	IN	PADAPTER	pAdapter
-);
-
-VOID
-PHY_SetTxPwrTrkIndex(
-	IN	PADAPTER			pAdapter,
-	IN	u8					RFPath,
-	IN	u8 				Rates
-);
-
-VOID
-PHY_StoreTxPowerByRate(
-	IN	PADAPTER	pAdapter,
-	IN	u32			Band,
-	IN	u32			RfPath,
-	IN	u32			TxNum,
-	IN	u32			RegAddr,
-	IN	u32			BitMask,
-	IN	u32			Data
-);
-
-VOID
-PHY_TxPowerByRateConfiguration(
-	IN  PADAPTER			pAdapter
-);
-
-u8
-PHY_GetTxPowerIndexBase(
-	IN	PADAPTER		pAdapter,
-	IN	u8				RFPath,
-	IN	u8				Rate,
-	IN	enum channel_width	BandWidth,
-	IN	u8				Channel,
-	OUT PBOOLEAN		bIn24G
-);
-
-s8
-PHY_GetTxPowerLimit(
-	IN	PADAPTER		Adapter,
-	IN	enum band_type		Band,
-	IN	enum channel_width	Bandwidth,
-	IN	u8				RfPath,
-	IN	u8				DataRate,
-	IN	u8				Channel
-);
-
-VOID
-PHY_SetTxPowerLimit(
-	IN	PADAPTER			Adapter,
-	IN	u8					Regulation,
-	IN	u8					Band,
-	IN	u8					Bandwidth,
-	IN	u8					RateSection,
-	IN	u8					RfPath,
-	IN	u8					Channel,
-	IN	u8					PowerLimit
-);
-
-VOID
-PHY_ConvertTxPowerLimitToPowerIndex(
-	IN	PADAPTER			Adapter
-);
-
-VOID
-PHY_InitTxPowerLimit(
-	IN	PADAPTER			Adapter
-);
-
-s8
-PHY_GetTxPowerTrackingOffset(
-	PADAPTER	pAdapter,
-	u8			Rate,
-	u8			RFPath
-);
-
-u8
-PHY_GetTxPowerIndex(
-	IN	PADAPTER			pAdapter,
-	IN	u8					RFPath,
-	IN	u8					Rate,
-	IN	enum channel_width		BandWidth,
-	IN	u8					Channel
-);
-
-VOID
-PHY_SetTxAgcToHw(
-	IN	PADAPTER		pAdapter
-);
-
-
-VOID
-PHY_SetTxPowerIndex(
-	IN	PADAPTER		pAdapter,
-	IN	u32				PowerIndex,
-	IN	u8				RFPath,
-	IN	u8				Rate
-);
-
-VOID
-Hal_ChannelPlanToRegulation(
-	IN	PADAPTER		Adapter,
-	IN	u16				ChannelPlan
-);
-
-#endif //__HAL_COMMON_H__
-
diff --git a/os/board/rtl8720e/src/component/wifi/driver/include/hal_com_reg.h b/os/board/rtl8720e/src/component/wifi/driver/include/hal_com_reg.h
deleted file mode 100644
index d93ccf277..000000000
--- a/os/board/rtl8720e/src/component/wifi/driver/include/hal_com_reg.h
+++ /dev/null
@@ -1,2202 +0,0 @@
-/******************************************************************************
- *
- * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of version 2 of the GNU General Public License as
- * published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
- * more details.
- *
- * You should have received a copy of the GNU General Public License along with
- * this program; if not, write to the Free Software Foundation, Inc.,
- * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
- *
- *
- ******************************************************************************/
-#ifndef __HAL_COMMON_REG_H__
-#define __HAL_COMMON_REG_H__
-
-
-#define MAC_ADDR_LEN				6
-
-#define HAL_NAV_UPPER_UNIT		128		// micro-second
-
-// 8188E PKT_BUFF_ACCESS_CTRL value
-#define TXPKT_BUF_SELECT				0x69
-#define RXPKT_BUF_SELECT				0xA5
-#define DISABLE_TRXPKT_BUF_ACCESS		0x0
-
-//============================================================
-//
-//============================================================
-
-//-----------------------------------------------------
-//
-//	0x0000h ~ 0x00FFh	System Configuration
-//
-//-----------------------------------------------------
-#define REG_SYS_ISO_CTRL				0x0000
-#define REG_SYS_FUNC_EN				0x0002
-#define REG_APS_FSMCO					0x0004
-#define REG_SYS_CLKR					0x0008
-#define REG_9346CR						0x000A
-#define REG_SYS_EEPROM_CTRL			0x000A
-#define REG_EE_VPD						0x000C
-#define REG_AFE_MISC					0x0010
-#define REG_SPS0_CTRL					0x0011
-#define REG_SPS0_CTRL_6					0x0016
-#define REG_POWER_OFF_IN_PROCESS 		0x0017
-#define REG_SPS_OCP_CFG				0x0018
-#define REG_RSV_CTRL					0x001C
-#define REG_RF_CTRL						0x001F
-#define REG_LDOA15_CTRL				0x0020
-#define REG_LDOV12D_CTRL				0x0021
-#define REG_LDOHCI12_CTRL				0x0022
-#define REG_LPLDO_CTRL					0x0023
-#define REG_AFE_XTAL_CTRL				0x0024
-#define REG_AFE_LDO_CTRL				0x0027 // 1.5v for 8188EE test chip, 1.4v for MP chip
-#define REG_AFE_PLL_CTRL				0x0028
-#define REG_MAC_PHY_CTRL				0x002c //for 92d, DMDP,SMSP,DMSP contrl
-#define REG_APE_PLL_CTRL_EXT			0x002c
-#define REG_EFUSE_CTRL					0x0030
-#define REG_EFUSE_TEST					0x0034
-#define REG_PWR_DATA					0x0038
-#define REG_CAL_TIMER					0x003C
-#define REG_ACLK_MON					0x003E
-#define REG_GPIO_MUXCFG				0x0040
-#define REG_GPIO_IO_SEL					0x0042
-#define REG_MAC_PINMUX_CFG			0x0043
-#define REG_GPIO_PIN_CTRL				0x0044
-#define REG_GPIO_INTM					0x0048
-#define REG_LEDCFG0						0x004C
-#define REG_LEDCFG1						0x004D
-#define REG_LEDCFG2						0x004E
-#define REG_LEDCFG3						0x004F
-#define REG_FSIMR						0x0050
-#define REG_FSISR						0x0054
-#define REG_HSIMR						0x0058
-#define REG_HSISR						0x005c
-#define REG_GPIO_PIN_CTRL_2			0x0060 // RTL8723 WIFI/BT/GPS Multi-Function GPIO Pin Control.
-#define REG_GPIO_IO_SEL_2				0x0062 // RTL8723 WIFI/BT/GPS Multi-Function GPIO Select.
-#define REG_MULTI_FUNC_CTRL			0x0068 // RTL8723 WIFI/BT/GPS Multi-Function control source.
-#define REG_GSSR						0x006c
-#define REG_WL_BTCOEX_CTRL			0x0074
-#define REG_AFE_XTAL_CTRL_EXT			0x0078 //RTL8188E
-#define REG_XCK_OUT_CTRL				0x007c //RTL8188E
-#define REG_MCUFWDL					0x0080
-#define REG_WOL_EVENT					0x0081 //RTL8188E
-#define REG_MCUTSTCFG					0x0084
-#define REG_FDHM0						0x0088
-#define REG_HOST_SUSP_CNT				0x00BC	// RTL8192C Host suspend counter on FPGA platform
-#define REG_SYSTEM_ON_CTRL			0x00CC	// For 8723AE Reset after S3
-#define REG_EFUSE_ACCESS				0x00CF	// Efuse access protection for RTL8723
-#define REG_BIST_SCAN					0x00D0
-#define REG_BIST_RPT					0x00D4
-#define REG_BIST_ROM_RPT				0x00D8
-#define REG_USB_SIE_INTF				0x00E0
-#define REG_PCIE_MIO_INTF				0x00E4
-#define REG_PCIE_MIO_INTD				0x00E8
-#define REG_HPON_FSM					0x00EC
-#define REG_SYS_CFG						0x00F0
-#define REG_GPIO_OUTSTS				0x00F4	// For RTL8723 only.
-#define REG_TYPE_ID						0x00FC
-
-
-#define REG_WL_CLK_CTRL                 		0x0002
-#define REG_WL_FUNC_EN                  		0x0004
-#define REG_WL_PMC_CTRL                 		0x0020
-#define REG_WL_AFE_CTRL    				0x0050
-#define REG_WL_PMC_IMR                  		0x0080
-#define REG_WL_PMC_ISR                  		0x0084
-
-#define REG_AFC_CTRL_8721D                  	0x0030
-#define REG_HIMR0_8721D                  		0x00B0
-#define REG_HISR0_8721D                  		0x00B4
-
-//-----------------------------------------------------
-//
-//	0x0100h ~ 0x01FFh	MACTOP General Configuration
-//
-//-----------------------------------------------------
-#define REG_CR							0x0100
-#define REG_PBP							0x0104
-#define REG_PKT_BUFF_ACCESS_CTRL		0x0106
-#define REG_TRXDMA_CTRL				0x010C
-#define REG_TRXFF_BNDY					0x0114
-#define REG_TRXFF_STATUS				0x0118
-#define REG_RXFF_PTR					0x011C
-#define REG_HIMR						0x0120
-#define REG_HISR						0x0124
-#define REG_HIMRE						0x0128
-#define REG_HISRE						0x012C
-#define REG_CPWM						0x012F
-#define REG_FWIMR						0x0130
-#define REG_FWISR						0x0134
-#define REG_FTIMR						0x0138
-#define REG_FTISR						0x013C //RTL8192C
-#define REG_PKTBUF_DBG_CTRL			0x0140
-#define REG_RXPKTBUF_CTRL				(REG_PKTBUF_DBG_CTRL+2)
-#define REG_PKTBUF_DBG_DATA_L			0x0144
-#define REG_PKTBUF_DBG_DATA_H		0x0148
-
-#define REG_TC0_CTRL					0x0150
-#define REG_TC1_CTRL					0x0154
-#define REG_TC2_CTRL					0x0158
-#define REG_TC3_CTRL					0x015C
-#define REG_TC4_CTRL					0x0160
-#define REG_TCUNIT_BASE				0x0164
-#define REG_MBIST_START				0x0174
-#define REG_MBIST_DONE					0x0178
-#define REG_MBIST_FAIL					0x017C
-#define REG_32K_CTRL					0x0194 //RTL8188E
-#define REG_C2HEVT_MSG_NORMAL		0x01A0
-#define REG_C2HEVT_CLEAR				0x01AF
-#define REG_MCUTST_1					0x01c0
-#define REG_MCUTST_WOWLAN			0x01C7	// Defined after 8188E series.
-#define REG_FMETHR						0x01C8
-#define REG_HMETFR						0x01CC
-#define REG_HMEBOX_0					0x01D0
-#define REG_HMEBOX_1					0x01D4
-#define REG_HMEBOX_2					0x01D8
-#define REG_HMEBOX_3					0x01DC
-#define REG_LLT_INIT					0x01E0
-
-//-----------------------------------------------------
-//
-//	0x0200h ~ 0x027Fh	TXDMA Configuration
-//
-//-----------------------------------------------------
-#define REG_RQPN						0x0200
-#define REG_FIFOPAGE					0x0204
-#define REG_TDECTRL						0x0208
-#define REG_TXDMA_OFFSET_CHK			0x020C
-#define REG_TXDMA_STATUS				0x0210
-#define REG_RQPN_NPQ					0x0214
-#define REG_AUTO_LLT					0x0224
-
-
-//-----------------------------------------------------
-//
-//	0x0280h ~ 0x02FFh	RXDMA Configuration
-//
-//-----------------------------------------------------
-#define REG_RXDMA_AGG_PG_TH			0x0280
-#define REG_RXPKT_NUM					0x0284
-#define REG_RXDMA_STATUS				0x0288
-#define REG_RXDMA_MODE					0x0290
-#define REG_C2H_PKT_8723B				0x0294
-
-
-//-----------------------------------------------------
-//
-//	0x0300h ~ 0x03FFh	PCIe
-//
-//-----------------------------------------------------
-#define REG_PCIE_CTRL_REG				0x0300
-#define REG_INT_MIG						0x0304	// Interrupt Migration 
-#define REG_BCNQ_DESA					0x0308	// TX Beacon Descriptor Address
-#define REG_HQ_DESA					0x0310	// TX High Queue Descriptor Address
-#define REG_MGQ_DESA					0x0318	// TX Manage Queue Descriptor Address
-#define REG_VOQ_DESA					0x0320	// TX VO Queue Descriptor Address
-#define REG_VIQ_DESA					0x0328	// TX VI Queue Descriptor Address
-#define REG_BEQ_DESA					0x0330	// TX BE Queue Descriptor Address
-#define REG_BKQ_DESA					0x0338	// TX BK Queue Descriptor Address
-#define REG_RX_DESA						0x0340	// RX Queue	Descriptor Address
-//sherry added for DBI Read/Write  20091126
-#define REG_DBI_WDATA					0x0348	// Backdoor REG for Access Configuration
-#define REG_DBI_RDATA                         	0x034C	//Backdoor REG for Access Configuration
-#define REG_DBI_CTRL                      		0x0350	//Backdoor REG for Access Configuration
-#define REG_DBI_FLAG                      		0x0352	//Backdoor REG for Access Configuration
-#define REG_MDIO						0x0354	// MDIO for Access PCIE PHY
-#define REG_DBG_SEL						0x0360	// Debug Selection Register
-#define REG_PCIE_HRPWM					0x0361	//PCIe RPWM
-#define REG_PCIE_HCPWM					0x0363	//PCIe CPWM
-#define REG_WATCH_DOG					0x0368
-
-// For new buffer descriptor ring architecture
-
-#define REG_LX_CTRL1                			0x0300  // 4 Bytes
-
-#define REG_BCNQ_TXBD_DESA          		0x0308  // 8 Bytes
-#define REG_MGQ_TXBD_DESA           		0x0310  // 8 Bytes 
-#define REG_VOQ_TXBD_DESA          		0x0318  // 8 Bytes
-#define REG_VIQ_TXBD_DESA           		0x0320  // 8 Bytes
-#define REG_BEQ_TXBD_DESA           		0x0328  // 8 Bytes
-#define REG_BKQ_TXBD_DESA           		0x0330  // 8 Bytes
-#define REG_RXQ_RXBD_DESA           		0x0338  // 8 Bytes
-#define REG_HI0Q_TXBD_DESA          		0x0340  // 8 Bytes
-#define REG_HI1Q_TXBD_DESA          		0x0348  // 8 Bytes
-#define REG_HI2Q_TXBD_DESA          		0x0350  // 8 Bytes
-#define REG_HI3Q_TXBD_DESA          		0x0358  // 8 Bytes
-#define REG_HI4Q_TXBD_DESA          		0x0360  // 8 Bytes
-#define REG_HI5Q_TXBD_DESA          		0x0368  // 8 Bytes
-#define REG_HI6Q_TXBD_DESA         		0x0370  // 8 Bytes
-#define REG_HI7Q_TXBD_DESA          		0x0378  // 8 Bytes
-
-#define REG_MGQ_TXBD_NUM            		0x0380  // 2 Bytes
-#define REG_RX_RXBD_NUM             		0x0382  // 2 Bytes
-#define REG_VOQ_TXBD_NUM            		0x0384  // 2 Bytes
-#define REG_VIQ_TXBD_NUM            		0x0386  // 2 Bytes
-#define REG_BEQ_TXBD_NUM            		0x0388  // 2 Bytes
-#define REG_BKQ_TXBD_NUM            		0x038A  // 2 Bytes
-#define REG_HI0Q_TXBD_NUM           		0x038C  // 2 Bytes
-#define REG_HI1Q_TXBD_NUM           		0x038E  // 2 Bytes
-#define REG_HI2Q_TXBD_NUM           		0x0390  // 2 Bytes
-#define REG_HI3Q_TXBD_NUM           		0x0392  // 2 Bytes
-#define REG_HI4Q_TXBD_NUM           		0x0394  // 2 Bytes
-#define REG_HI5Q_TXBD_NUM           		0x0396  // 2 Bytes
-#define REG_HI6Q_TXBD_NUM           		0x0398  // 2 Bytes
-#define REG_HI7Q_TXBD_NUM           		0x039A  // 2 Bytes
-
-#define REG_BD_RWPTR_CLR            		0x039C  // 4 Bytes
-#define REG_VOQ_TXBD_IDX            		0x03A0  // 4 Bytes
-#define REG_VIQ_TXBD_IDX            		0x03A4  // 4 Bytes
-#define REG_BEQ_TXBD_IDX            		0x03A8  // 4 Bytes
-#define REG_BKQ_TXBD_IDX            		0x03AC  // 4 Bytes
-#define REG_MGQ_TXBD_IDX            		0x03B0  // 4 Bytes
-#define REG_RXQ_RXBD_IDX            		0x03B4  // 4 Bytes
-#define REG_HI0Q_TXBD_IDX           		0x03B8  // 4 Bytes
-#define REG_HI1Q_TXBD_IDX           		0x03BC  // 4 Bytes
-#define REG_HI2Q_TXBD_IDX           		0x03C0  // 4 Bytes
-#define REG_HI3Q_TXBD_IDX           		0x03C4  // 4 Bytes
-#define REG_HI4Q_TXBD_IDX           		0x03C8  // 4 Bytes
-#define REG_HI5Q_TXBD_IDX           		0x03CC  // 4 Bytes
-#define REG_HI6Q_TXBD_IDX           		0x03D0  // 4 Bytes
-#define REG_HI7Q_TXBD_IDX           		0x03D4  // 4 Bytes
-
-//CPWM &RPWM
-#define REG_LX_HRPWM_8711B			0x03D9  // 1 Bytes
-#define REG_LX_HCPWM_8711B			0x03DA  // 1 Bytes //from 0x14c
-
-#define REG_LX_CTRL2                			0x03DB  // 1 Bytes
-
-#define REG_LX_HRPWM2_8711B          		0x03DC  // 2 Bytes //REG_LX_HCPWM1_8711B
-#define REG_LX_HCPWM2_8711B          		0x03DE  // 2 Bytes 
-#define REG_LX_H2C_MSG_V1         		0x03E0  // 4 Bytes
-#define REG_LX_C2H_MSG_V1         		0x03E4  // 4 Bytes
-
-
-#define REG_LX_DMA_ISR              			0x03E8  // 4 Bytes
-#define REG_LX_DMA_IMR              			0x03EC  // 4 Bytes
-#define REG_LX_DMA_DBG              			0x03F0  // 4 Bytes
-
-#define REG_BUS_MIX_CFG             			0x03F8  // 4 Bytes#
-#define REG_BUS_MIX_CFG1            		0x03FC  // 4 Bytes
-
-//-----------------------------------------------------
-//
-//	0x0400h ~ 0x047Fh	Protocol Configuration
-//
-//-----------------------------------------------------
-#define REG_VOQ_INFORMATION			0x0400
-#define REG_VIQ_INFORMATION			0x0404
-#define REG_BEQ_INFORMATION			0x0408
-#define REG_BKQ_INFORMATION			0x040C
-#define REG_MGQ_INFORMATION			0x0410
-#define REG_HGQ_INFORMATION			0x0414
-#define REG_BCNQ_INFORMATION			0x0418
-#define REG_TXPKT_EMPTY				0x041A
-#define REG_CPU_MGQ_INFORMATION		0x041C
-#define REG_FWHW_TXQ_CTRL				0x0420
-#define REG_HWSEQ_CTRL					0x0423
-#define REG_BCNQ_BDNY					0x0424
-#define REG_MGQ_BDNY					0x0425
-#define REG_LIFETIME_CTRL				0x0426
-#define REG_MULTI_BCNQ_OFFSET			0x0427
-#define REG_SPEC_SIFS					0x0428
-#define REG_RL							0x042A
-#define REG_DARFRC						0x0430
-#define REG_RARFRC						0x0438
-#define REG_RRSR						0x0440
-#define REG_ARFR0						0x0444
-#define REG_ARFR1						0x0448
-#define REG_ARFR2						0x044C
-#define REG_ARFR3						0x0450
-#define REG_BCNQ1_BDNY					0x0457
-
-#define REG_AGGLEN_LMT					0x0458
-#define REG_AMPDU_MIN_SPACE			0x045C
-#define REG_TX_HANG_CTRL				0x045E
-#define REG_WMAC_LBK_BF_HD			0x045D
-#define REG_FAST_EDCA_CTRL				0x0460
-#define REG_RD_RESP_PKT_TH				0x0463
-
-#define REG_INIRTS_RATE_SEL				0x0480
-#define REG_DATA_SC						0x0483
-#define REG_MACID_SLEEP_3				0x0484
-#define REG_MACID_SLEEP_1				0x0488
-
-#define REG_POWER_STAGE1				0x04B4
-#define REG_POWER_STAGE2				0x04B8
-#define REG_PKT_VO_VI_LIFE_TIME		0x04C0
-#define REG_PKT_BE_BK_LIFE_TIME		0x04C2
-#define REG_STBC_SETTING				0x04C4
-#define REG_QUEUE_CTRL					0x04C6
-#define REG_SINGLE_AMPDU_CTRL			0x04c7
-#define REG_PROT_MODE_CTRL			0x04C8
-#define REG_MAX_AGGR_NUM				0x04CA
-#define REG_RTS_MAX_AGGR_NUM			0x04CB
-#define REG_BAR_MODE_CTRL				0x04CC
-#define REG_RA_TRY_RATE_AGG_LMT		0x04CF
-/* 88E */
-#define REG_EARLY_MODE_CONTROL		0x04D0
-/* 8723B, 92E, 8812A, 8821A */
-#define REG_MACID_SLEEP_2			0x04D0
-#define REG_MACID_SLEEP				0x04D4
-#define REG_NQOS_SEQ					0x04DC
-#define REG_QOS_SEQ					0x04DE
-#define REG_NEED_CPU_HANDLE			0x04E0
-#define REG_PKT_LOSE_RPT				0x04E1
-#define REG_PTCL_ERR_STATUS			0x04E2
-#define REG_PRETX_DROP_CTRL				0x04E4
-#define REG_TX_RPT_CTRL					0x04EC
-#define REG_TX_RPT_TIME					0x04F0	// 2 byte
-#define REG_DUMMY						0x04FC
-
-//-----------------------------------------------------
-//
-//	0x0500h ~ 0x05FFh	EDCA Configuration
-//
-//-----------------------------------------------------
-#define REG_EDCA_VO_PARAM				0x0500
-#define REG_EDCA_VI_PARAM				0x0504
-#define REG_EDCA_BE_PARAM				0x0508
-#define REG_EDCA_BK_PARAM				0x050C
-#define REG_BCNTCFG						0x0510
-#define REG_PIFS							0x0512
-#define REG_RDG_PIFS					0x0513
-#define REG_SIFS_CTX					0x0514
-#define REG_SIFS_TRX					0x0516
-#define REG_TSFTR_SYN_OFFSET			0x0518
-#define REG_AGGR_BREAK_TIME			0x051A
-#define REG_SLOT						0x051B
-#define REG_TX_PTCL_CTRL				0x0520
-#define REG_TXPAUSE						0x0522
-#define REG_DIS_TXREQ_CLR				0x0523
-#define REG_RD_CTRL						0x0524
-//
-// Format for offset 540h-542h:
-//	[3:0]:   TBTT prohibit setup in unit of 32us. The time for HW getting beacon content before TBTT.
-//	[7:4]:   Reserved.
-//	[19:8]:  TBTT prohibit hold in unit of 32us. The time for HW holding to send the beacon packet.
-//	[23:20]: Reserved
-// Description:
-//	              |
-//     |<--Setup--|--Hold------------>|
-//	--------------|----------------------
-//                |
-//               TBTT
-// Note: We cannot update beacon content to HW or send any AC packets during the time between Setup and Hold.
-// Described by Designer Tim and Bruce, 2011-01-14.
-//
-#define REG_TBTT_PROHIBIT				0x0540
-#define REG_RD_NAV_NXT					0x0544
-#define REG_NAV_PROT_LEN				0x0546
-#define REG_BCN_CTRL					0x0550
-#define REG_BCN_CTRL_1					0x0551
-#define REG_MBID_NUM					0x0552
-#define REG_DUAL_TSF_RST				0x0553
-#define REG_BCN_INTERVAL				0x0554	// The same as REG_MBSSID_BCN_SPACE
-#define REG_DRVERLYINT					0x0558
-#define REG_BCNDMATIM					0x0559
-#define REG_ATIMWND					0x055A
-#define REG_USTIME_TSF					0x055C
-#define REG_BCN_MAX_ERR				0x055D
-#define REG_RXTSF_OFFSET_CCK			0x055E
-#define REG_RXTSF_OFFSET_OFDM			0x055F
-#define REG_TSFTR						0x0560
-#define REG_TSFTR1						0x0568	// HW Port 1 TSF Register
-#define REG_ATIMWND_1					0x0570
-#define REG_P2P_CTWIN					0x0572 // 1 Byte long (in unit of TU)
-#define REG_PSTIMER						0x0580
-#define REG_TIMER0						0x0584
-#define REG_TIMER1						0x0588
-#define REG_TBTT_HOLD_PREDICT_P1		0x05B2
-#define REG_PTA_PRE_TRX_CTRL			0x5B8	//rtl8721d
-#define REG_ACMHWCTRL					0x05C0
-#define REG_NOA_DESC_SEL				0x05CF
-#define REG_NOA_DESC_DURATION		0x05E0
-#define REG_NOA_DESC_INTERVAL			0x05E4
-#define REG_NOA_DESC_START			0x05E8
-#define REG_NOA_DESC_COUNT			0x05EC
-
-#define REG_DMC							0x05F0	//Dual MAC Co-Existence Register
-#define REG_SCH_TX_CMD					0x05F8
-
-#define REG_FW_RESET_TSF_CNT_1		0x05FC
-#define REG_FW_RESET_TSF_CNT_0		0x05FD
-#define REG_FW_BCN_DIS_CNT			0x05FE
-
-//-----------------------------------------------------
-//
-//	0x0600h ~ 0x07FFh	WMAC Configuration
-//
-//-----------------------------------------------------
-#define REG_APSD_CTRL					0x0600
-#define REG_BWOPMODE					0x0603
-#define REG_TCR							0x0604
-#define REG_RCR							0x0608
-#define REG_RX_PKT_LIMIT				0x060C
-#define REG_RX_DLK_TIME				0x060D
-#define REG_RX_DRVINFO_SZ				0x060F
-
-#define REG_MACID						0x0610
-#define REG_BSSID						0x0618
-#define REG_MAR							0x0620
-#define REG_MBIDCAMCFG					0x0628
-
-#define REG_USTIME_EDCA				0x0638
-#define REG_ACKTO_CCK					0x0639
-#define REG_MAC_SPEC_SIFS				0x063A
-// 20100719 Joseph: Hardware register definition change. (HW datasheet v54)
-#define REG_RESP_SIFS_CCK				0x063C	// [15:8]SIFS_R2T_OFDM, [7:0]SIFS_R2T_CCK
-#define REG_RESP_SIFS_OFDM                    0x063E	// [15:8]SIFS_T2T_OFDM, [7:0]SIFS_T2T_CCK
-
-#define REG_ACKTO						0x0640
-#define REG_CTS2TO						0x0641
-#define REG_EIFS							0x0642
-
-
-
-//RXERR_RPT
-#define RXERR_TYPE_OFDM_PPDU			0
-#define RXERR_TYPE_OFDM_FALSE_ALARM 	1
-#define RXERR_TYPE_OFDM_MPDU_OK 		2
-#define RXERR_TYPE_OFDM_MPDU_FAIL	3
-#define RXERR_TYPE_CCK_PPDU 			4
-#define RXERR_TYPE_CCK_FALSE_ALARM	5
-#define RXERR_TYPE_CCK_MPDU_OK		6
-#define RXERR_TYPE_CCK_MPDU_FAIL		7
-#define RXERR_TYPE_HT_PPDU				8
-#define RXERR_TYPE_HT_FALSE_ALARM	9
-#define RXERR_TYPE_HT_MPDU_TOTAL		10
-#define RXERR_TYPE_HT_MPDU_OK			11
-#define RXERR_TYPE_HT_MPDU_FAIL 		12
-#define RXERR_TYPE_RX_FULL_DROP 		15
-
-#define RXERR_COUNTER_MASK			0xFFFFF
-#define RXERR_RPT_RST					BIT(27)
-#define _RXERR_RPT_SEL(type)			((type) << 28)
-
-//
-// Note:
-//	The NAV upper value is very important to WiFi 11n 5.2.3 NAV test. The default value is
-//	always too small, but the WiFi TestPlan test by 25,000 microseconds of NAV through sending
-//	CTS in the air. We must update this value greater than 25,000 microseconds to pass the item.
-//	The offset of NAV_UPPER in 8192C Spec is incorrect, and the offset should be 0x0652. Commented
-//	by SD1 Scott.
-// By Bruce, 2011-07-18.
-//
-#define REG_NAV_UPPER					0x0652	// unit of 128
-
-//WMA, BA, CCX
-#define REG_NAV_CTRL					0x0650
-#define REG_BACAMCMD					0x0654
-#define REG_BACAMCONTENT				0x0658
-#define REG_LBDLY						0x0660
-#define REG_FWDLY						0x0661
-#define REG_RXERR_RPT					0x0664
-#define REG_WMAC_TRXPTCL_CTL			0x0668
-
-// Security
-#define REG_CAMCMD						0x0670
-#define REG_CAMWRITE					0x0674
-#define REG_CAMREAD					0x0678
-#define REG_CAMDBG						0x067C
-#define REG_SECCFG						0x0680
-
-// Power
-#define REG_WOW_CTRL					0x0690
-#define REG_PS_RX_INFO					0x0692
-#define REG_UAPSD_TID					0x0693
-#define REG_WKFMCAM_CMD				0x0698
-#define REG_WKFMCAM_NUM				REG_WKFMCAM_CMD
-#define REG_WKFMCAM_RWD				0x069C
-#define REG_RXFLTMAP0					0x06A0
-#define REG_RXFLTMAP1					0x06A2
-#define REG_RXFLTMAP2					0x06A4
-#define REG_BCN_PSR_RPT				0x06A8
-#define REG_BT_COEX_TABLE				0x06C0
-#define REG_BT_COEX_TABLE2				0x06C4
-#define REG_BT_BREAK_TABLE				0x06C8
-#define REG_BT_COEX_TABLE_H				0x06CC
-
-#define REG_BBPSF_CTRL					0x06DC
-
-
-// Hardware Port 2
-#define REG_MACID1						0x0700
-#define REG_BSSID1						0x0708
-
-#define REG_BT_COEX							0x0764
-#define REG_WLAN_ACT_MASK_CTRL_1			0x076C
-/* port0 & port1 enable */
-#define REG_PORT_CTRL						0x076D
-#define REG_BT_COEX_ENHANCED_INTR_CTRL		0x076E
-#define REG_BT_STAT_CTRL					0x0778
-#define REG_BT_CMD_ID						0x077C
-#define REG_BT_INT_CTRL						0x0780
-
-#define REG_BT_TDMA_TIME					0x0790
-
-#define REG_RX_NAN_ADDR_FILTER				0x07EC
-
-//-----------------------------------------------------
-//
-//	0xFE00h ~ 0xFE55h	USB Configuration
-//
-//-----------------------------------------------------
-#define REG_USB_INFO					0xFE17
-#define REG_USB_SPECIAL_OPTION		0xFE55
-#define REG_USB_DMA_AGG_TO			0xFE5B
-#define REG_USB_AGG_TO					0xFE5C
-#define REG_USB_AGG_TH					0xFE5D
-
-#define REG_USB_HRPWM					0xFE58
-#define REG_USB_HCPWM					0xFE57
-
-// for 92DU high_Queue low_Queue Normal_Queue select
-#define REG_USB_High_NORMAL_Queue_Select_MAC0	0xFE44
-//#define REG_USB_LOW_Queue_Select_MAC0		0xFE45
-#define REG_USB_High_NORMAL_Queue_Select_MAC1	0xFE47
-//#define REG_USB_LOW_Queue_Select_MAC1		0xFE48
-
-// For test chip
-#define REG_TEST_USB_TXQS				0xFE48
-#define REG_TEST_SIE_VID				0xFE60		// 0xFE60~0xFE61
-#define REG_TEST_SIE_PID				0xFE62		// 0xFE62~0xFE63
-#define REG_TEST_SIE_OPTIONAL			0xFE64
-#define REG_TEST_SIE_CHIRP_K			0xFE65
-#define REG_TEST_SIE_PHY				0xFE66		// 0xFE66~0xFE6B
-#define REG_TEST_SIE_MAC_ADDR			0xFE70		// 0xFE70~0xFE75
-#define REG_TEST_SIE_STRING			0xFE80		// 0xFE80~0xFEB9
-
-
-// For normal chip
-#define REG_NORMAL_SIE_VID				0xFE60		// 0xFE60~0xFE61
-#define REG_NORMAL_SIE_PID				0xFE62		// 0xFE62~0xFE63
-#define REG_NORMAL_SIE_OPTIONAL		0xFE64
-#define REG_NORMAL_SIE_EP				0xFE65		// 0xFE65~0xFE67
-#define REG_NORMAL_SIE_PHY			0xFE68		// 0xFE68~0xFE6B
-#define REG_NORMAL_SIE_OPTIONAL2		0xFE6C
-#define REG_NORMAL_SIE_GPS_EP			0xFE6D		// 0xFE6D, for RTL8723 only.
-#define REG_NORMAL_SIE_MAC_ADDR		0xFE70		// 0xFE70~0xFE75
-#define REG_NORMAL_SIE_STRING			0xFE80		// 0xFE80~0xFEDF
-
-
-//-----------------------------------------------------
-//
-//	Redifine 8192C register definition for compatibility
-//
-//-----------------------------------------------------
-
-// TODO: use these definition when using REG_xxx naming rule.
-// NOTE: DO NOT Remove these definition. Use later.
-
-#define EFUSE_CTRL				REG_EFUSE_CTRL		// E-Fuse Control.
-#define EFUSE_TEST				REG_EFUSE_TEST		// E-Fuse Test.
-#define MSR						(REG_CR + 2)		// Media Status register
-//#define ISR						REG_HISR
-
-#define TSFR						REG_TSFTR			// Timing Sync Function Timer Register.
-#define TSFR1					REG_TSFTR1			// HW Port 1 TSF Register
-
-#define PBP						REG_PBP
-
-// Redifine MACID register, to compatible prior ICs.
-#define IDR0						REG_MACID			// MAC ID Register, Offset 0x0050-0x0053
-#define IDR4						(REG_MACID + 4)		// MAC ID Register, Offset 0x0054-0x0055
-
-
-//
-// 9. Security Control Registers	(Offset: )
-//
-#define RWCAM					REG_CAMCMD		//IN 8190 Data Sheet is called CAMcmd
-#define WCAMI					REG_CAMWRITE	// Software write CAM input content
-#define RCAMO					REG_CAMREAD		// Software read/write CAM config
-#define CAMDBG					REG_CAMDBG
-#define SECR						REG_SECCFG		//Security Configuration Register
-
-// Unused register
-#define UnusedRegister			0x1BF
-#define DCAM					UnusedRegister
-#define PSR						UnusedRegister
-#define BBAddr					UnusedRegister
-#define PhyDataR					UnusedRegister
-
-// Min Spacing related settings.
-#define MAX_MSS_DENSITY_2T 			0x13
-#define MAX_MSS_DENSITY_1T 			0x0A
-
-//----------------------------------------------------------------------------
-//       8192C Cmd9346CR bits					(Offset 0xA, 16bit)
-//----------------------------------------------------------------------------
-#define CmdEEPROM_En				BIT5	 // EEPROM enable when set 1
-#define CmdEERPOMSEL				BIT4 	// System EEPROM select, 0: boot from E-FUSE, 1: The EEPROM used is 9346
-#define Cmd9346CR_9356SEL			BIT4
-
-//----------------------------------------------------------------------------
-//       8721D AFE Ctrl Configuration Register (offset 0x30, 4 byte)
-//----------------------------------------------------------------------------
-#define RF_AFE_RST				BIT15
-
-//----------------------------------------------------------------------------
-//       8192C GPIO MUX Configuration Register (offset 0x40, 4 byte)
-//----------------------------------------------------------------------------
-#define GPIOSEL_GPIO				0
-#define GPIOSEL_ENBT				BIT5
-
-//----------------------------------------------------------------------------
-//       8192C GPIO PIN Control Register (offset 0x44, 4 byte)
-//----------------------------------------------------------------------------
-#define GPIO_VAL_IN				REG_GPIO_PIN_CTRL		// GPIO pins input value
-#define GPIO_VAL_OUT			(REG_GPIO_PIN_CTRL+1)	// GPIO pins output value
-#define GPIO_IO_SEL				(REG_GPIO_PIN_CTRL+2)	// GPIO pins output enable when a bit is set to "1"; otherwise, input is configured.
-#define GPIO_MOD				(REG_GPIO_PIN_CTRL+3)
-
-//----------------------------------------------------------------------------
-//       8811A GPIO PIN Control Register (offset 0x60, 4 byte)
-//----------------------------------------------------------------------------
-#define GPIO_IN_8811A			REG_GPIO_PIN_CTRL_2		// GPIO pins input value
-#define GPIO_OUT_8811A			(REG_GPIO_PIN_CTRL_2+1)	// GPIO pins output value
-#define GPIO_IO_SEL_8811A		(REG_GPIO_PIN_CTRL_2+2)	// GPIO pins output enable when a bit is set to "1"; otherwise, input is configured.
-#define GPIO_MOD_8811A			(REG_GPIO_PIN_CTRL_2+3)
-
-//----------------------------------------------------------------------------
-//       8723/8188E Host System Interrupt Mask Register (offset 0x58, 32 byte)
-//----------------------------------------------------------------------------
-#define HSIMR_GPIO12_0_INT_EN			BIT0
-#define HSIMR_SPS_OCP_INT_EN			BIT5
-#define HSIMR_RON_INT_EN				BIT6
-#define HSIMR_PDN_INT_EN				BIT7
-#define HSIMR_GPIO9_INT_EN				BIT25
-
-//----------------------------------------------------------------------------
-//       8723/8188E Host System Interrupt Status Register (offset 0x5C, 32 byte)
-//----------------------------------------------------------------------------
-#define HSISR_GPIO12_0_INT				BIT0
-#define HSISR_SPS_OCP_INT				BIT5
-#define HSISR_RON_INT					BIT6
-#define HSISR_PDNINT					BIT7
-#define HSISR_GPIO9_INT					BIT25
-
-//----------------------------------------------------------------------------
-//       8192C (MSR) Media Status Register	(Offset 0x4C, 8 bits)
-//----------------------------------------------------------------------------
-/*
-Network Type
-00: No link
-01: Link in ad hoc network
-10: Link in infrastructure network
-11: AP mode
-Default: 00b.
-*/
-#define MSR_NOLINK				0x00
-#define MSR_ADHOC				0x01
-#define MSR_INFRA				0x02
-#define MSR_AP					0x03
-
-//----------------------------------------------------------------------------
-//       USB INTR CONTENT
-//----------------------------------------------------------------------------
-#define USB_C2H_CMDID_OFFSET					0
-#define USB_C2H_SEQ_OFFSET					1
-#define USB_C2H_EVENT_OFFSET					2
-#define USB_INTR_CPWM_OFFSET					16
-#define USB_INTR_CONTENT_C2H_OFFSET			0
-#define USB_INTR_CONTENT_CPWM1_OFFSET		16
-#define USB_INTR_CONTENT_CPWM2_OFFSET		20
-#define USB_INTR_CONTENT_HISR_OFFSET			48
-#define USB_INTR_CONTENT_HISRE_OFFSET		52
-#define USB_INTR_CONTENT_LENGTH				56
-
-//----------------------------------------------------------------------------
-//       Response Rate Set Register	(offset 0x440, 24bits)
-//----------------------------------------------------------------------------
-#define RRSR_1M					BIT0
-#define RRSR_2M					BIT1
-#define RRSR_5_5M				BIT2
-#define RRSR_11M				BIT3
-#define RRSR_6M					BIT4
-#define RRSR_9M					BIT5
-#define RRSR_12M				BIT6
-#define RRSR_18M				BIT7
-#define RRSR_24M				BIT8
-#define RRSR_36M				BIT9
-#define RRSR_48M				BIT10
-#define RRSR_54M				BIT11
-#define RRSR_MCS0				BIT12
-#define RRSR_MCS1				BIT13
-#define RRSR_MCS2				BIT14
-#define RRSR_MCS3				BIT15
-#define RRSR_MCS4				BIT16
-#define RRSR_MCS5				BIT17
-#define RRSR_MCS6				BIT18
-#define RRSR_MCS7				BIT19
-
-#define RRSR_CCK_RATES (RRSR_11M|RRSR_5_5M|RRSR_2M|RRSR_1M)
-#define RRSR_OFDM_RATES (RRSR_54M|RRSR_48M|RRSR_36M|RRSR_24M|RRSR_18M|RRSR_12M|RRSR_9M|RRSR_6M)
-// WOL bit information
-#define HAL92C_WOL_PTK_UPDATE_EVENT		BIT0
-#define HAL92C_WOL_GTK_UPDATE_EVENT		BIT1
-#define HAL92C_WOL_DISASSOC_EVENT		BIT2
-#define HAL92C_WOL_DEAUTH_EVENT			BIT3
-#define HAL92C_WOL_FW_DISCONNECT_EVENT	BIT4
-
-//----------------------------------------------------------------------------
-//       Rate Definition
-//----------------------------------------------------------------------------
-//CCK
-#define	RATR_1M					0x00000001
-#define	RATR_2M					0x00000002
-#define	RATR_55M					0x00000004
-#define	RATR_11M					0x00000008
-//OFDM
-#define	RATR_6M					0x00000010
-#define	RATR_9M					0x00000020
-#define	RATR_12M					0x00000040
-#define	RATR_18M					0x00000080
-#define	RATR_24M					0x00000100
-#define	RATR_36M					0x00000200
-#define	RATR_48M					0x00000400
-#define	RATR_54M					0x00000800
-//MCS 1 Spatial Stream
-#define	RATR_MCS0					0x00001000
-#define	RATR_MCS1					0x00002000
-#define	RATR_MCS2					0x00004000
-#define	RATR_MCS3					0x00008000
-#define	RATR_MCS4					0x00010000
-#define	RATR_MCS5					0x00020000
-#define	RATR_MCS6					0x00040000
-#define	RATR_MCS7					0x00080000
-//MCS 2 Spatial Stream
-#define	RATR_MCS8					0x00100000
-#define	RATR_MCS9					0x00200000
-#define	RATR_MCS10					0x00400000
-#define	RATR_MCS11					0x00800000
-#define	RATR_MCS12					0x01000000
-#define	RATR_MCS13					0x02000000
-#define	RATR_MCS14					0x04000000
-#define	RATR_MCS15					0x08000000
-
-//CCK
-#define RATE_1M					BIT(0)
-#define RATE_2M					BIT(1)
-#define RATE_5_5M				BIT(2)
-#define RATE_11M				BIT(3)
-//OFDM
-#define RATE_6M					BIT(4)
-#define RATE_9M					BIT(5)
-#define RATE_12M				BIT(6)
-#define RATE_18M				BIT(7)
-#define RATE_24M				BIT(8)
-#define RATE_36M				BIT(9)
-#define RATE_48M				BIT(10)
-#define RATE_54M				BIT(11)
-//MCS 1 Spatial Stream
-#define RATE_MCS0				BIT(12)
-#define RATE_MCS1				BIT(13)
-#define RATE_MCS2				BIT(14)
-#define RATE_MCS3				BIT(15)
-#define RATE_MCS4				BIT(16)
-#define RATE_MCS5				BIT(17)
-#define RATE_MCS6				BIT(18)
-#define RATE_MCS7				BIT(19)
-//MCS 2 Spatial Stream
-#define RATE_MCS8				BIT(20)
-#define RATE_MCS9				BIT(21)
-#define RATE_MCS10				BIT(22)
-#define RATE_MCS11				BIT(23)
-#define RATE_MCS12				BIT(24)
-#define RATE_MCS13				BIT(25)
-#define RATE_MCS14				BIT(26)
-#define RATE_MCS15				BIT(27)
-
-
-// ALL CCK Rate
-#define	RATE_ALL_CCK				RATR_1M|RATR_2M|RATR_55M|RATR_11M
-#define	RATE_ALL_OFDM_AG			RATR_6M|RATR_9M|RATR_12M|RATR_18M|RATR_24M|\
-						RATR_36M|RATR_48M|RATR_54M
-#define	RATE_ALL_OFDM_1SS			RATR_MCS0|RATR_MCS1|RATR_MCS2|RATR_MCS3 |\
-						RATR_MCS4|RATR_MCS5|RATR_MCS6	|RATR_MCS7
-#define	RATE_ALL_OFDM_2SS			RATR_MCS8|RATR_MCS9	|RATR_MCS10|RATR_MCS11|\
-						RATR_MCS12|RATR_MCS13|RATR_MCS14|RATR_MCS15
-
-#define RATE_BITMAP_ALL			0xFFFFF
-
-// Only use CCK 1M rate for ACK
-#define RATE_RRSR_CCK_ONLY_1M		0xFFFF1
-#define RATE_RRSR_WITHOUT_CCK		0xFFFF0
-
-//----------------------------------------------------------------------------
-//       REG_DATA_SC bits				(Offset 0x483, 8bit)
-//----------------------------------------------------------------------------
-
-#define BIT_SHIFT_TXSC_20M			0
-#define BIT_MASK_TXSC_20M			0xf
-#define BIT_TXSC_20M(x)				(((x) & BIT_MASK_TXSC_20M) << BIT_SHIFT_TXSC_20M)
-
-#define BIT_SHIFT_TXSC_40M			4
-#define BIT_MASK_TXSC_40M			0xf
-#define BIT_TXSC_40M(x)				(((x) & BIT_MASK_TXSC_40M) << BIT_SHIFT_TXSC_40M)
-
-//----------------------------------------------------------------------------
-//       BW_OPMODE bits				(Offset 0x603, 8bit)
-//----------------------------------------------------------------------------
-#define BW_OPMODE_20MHZ			BIT2
-#define BW_OPMODE_5G				BIT1
-
-//----------------------------------------------------------------------------
-//       REG_WMAC_TRXPTCL_CTL bits			(Offset 0x668, 32bit)
-//----------------------------------------------------------------------------
-#define BIT_SHIFT_RFMOD				7
-#define BIT_MASK_RFMOD				0x3
-#define BIT_RFMOD(x)				(((x) & BIT_MASK_RFMOD) << BIT_SHIFT_RFMOD)
-
-
-//----------------------------------------------------------------------------
-//       CAM Config Setting (offset 0x680, 1 byte)
-//----------------------------------------------------------------------------
-#define CAM_VALID				BIT15
-#define CAM_NOTVALID			0x0000
-#define CAM_USEDK				BIT5
-
-#define CAM_CONTENT_COUNT 	8
-
-#define CAM_NONE				0x0
-#define CAM_WEP40				0x01
-#define CAM_TKIP				0x02
-#define CAM_AES					0x04
-#define CAM_WEP104				0x05
-#define CAM_SMS4				0x6
-
-#define TOTAL_CAM_ENTRY		32
-#define HALF_CAM_ENTRY			16
-
-#define CAM_CONFIG_USEDK		_TRUE
-#define CAM_CONFIG_NO_USEDK	_FALSE
-
-#define CAM_WRITE				BIT16
-#define CAM_READ				0x00000000
-#define CAM_POLLINIG			BIT31
-
-#define SCR_UseDK				0x01
-#define SCR_TxSecEnable			0x02
-#define SCR_RxSecEnable			0x04
-
-//
-// 10. Power Save Control Registers
-//
-#define	WOW_PMEN				BIT0 // Power management Enable.
-#define	WOW_WOMEN			BIT1 // WoW function on or off. 
-#define	WOW_MAGIC				BIT2 // Magic packet
-#define	WOW_UWF				BIT3 // Unicast Wakeup frame.
-
-//
-// 12. Host Interrupt Status Registers
-//
-//----------------------------------------------------------------------------
-//      8190 IMR/ISR bits
-//----------------------------------------------------------------------------
-#define IMR8190_DISABLED		0x0
-#define IMR_DISABLED			0x0
-// IMR DW0 Bit 0-31
-#define IMR_BCNDMAINT6			BIT31		// Beacon DMA Interrupt 6
-#define IMR_BCNDMAINT5			BIT30		// Beacon DMA Interrupt 5
-#define IMR_BCNDMAINT4			BIT29		// Beacon DMA Interrupt 4
-#define IMR_BCNDMAINT3			BIT28		// Beacon DMA Interrupt 3
-#define IMR_BCNDMAINT2			BIT27		// Beacon DMA Interrupt 2
-#define IMR_BCNDMAINT1			BIT26		// Beacon DMA Interrupt 1
-#define IMR_BCNDOK8				BIT25		// Beacon Queue DMA OK Interrup 8
-#define IMR_BCNDOK7				BIT24		// Beacon Queue DMA OK Interrup 7
-#define IMR_BCNDOK6				BIT23		// Beacon Queue DMA OK Interrup 6
-#define IMR_BCNDOK5				BIT22		// Beacon Queue DMA OK Interrup 5
-#define IMR_BCNDOK4				BIT21		// Beacon Queue DMA OK Interrup 4
-#define IMR_BCNDOK3				BIT20		// Beacon Queue DMA OK Interrup 3
-#define IMR_BCNDOK2				BIT19		// Beacon Queue DMA OK Interrup 2
-#define IMR_BCNDOK1				BIT18		// Beacon Queue DMA OK Interrup 1
-#define IMR_TIMEOUT2			BIT17		// Timeout interrupt 2
-#define IMR_TIMEOUT1			BIT16		// Timeout interrupt 1
-#define IMR_TXFOVW				BIT15		// Transmit FIFO Overflow
-#define IMR_PSTIMEOUT			BIT14		// Power save time out interrupt 
-#define IMR_BcnInt				BIT13		// Beacon DMA Interrupt 0
-#define IMR_RXFOVW				BIT12		// Receive FIFO Overflow
-#define IMR_RDU					BIT11		// Receive Descriptor Unavailable
-#define IMR_ATIMEND				BIT10		// For 92C,ATIM Window End Interrupt. For 8723 and later ICs, it also means P2P CTWin End interrupt.
-#define IMR_BDOK				BIT9		// Beacon Queue DMA OK Interrup
-#define IMR_HIGHDOK				BIT8		// High Queue DMA OK Interrupt
-#define IMR_TBDOK				BIT7		// Transmit Beacon OK interrup
-#define IMR_MGNTDOK			BIT6		// Management Queue DMA OK Interrupt
-#define IMR_TBDER				BIT5		// For 92C,Transmit Beacon Error Interrupt
-#define IMR_BKDOK				BIT4		// AC_BK DMA OK Interrupt
-#define IMR_BEDOK				BIT3		// AC_BE DMA OK Interrupt
-#define IMR_VIDOK				BIT2		// AC_VI DMA OK Interrupt
-#define IMR_VODOK				BIT1		// AC_VO DMA Interrupt
-#define IMR_ROK					BIT0		// Receive DMA OK Interrupt
-
-// 13. Host Interrupt Status Extension Register	 (Offset: 0x012C-012Eh)
-#define IMR_TSF_BIT32_TOGGLE	BIT15
-#define IMR_BcnInt_E				BIT12
-#define IMR_TXERR				BIT11
-#define IMR_RXERR				BIT10
-#define IMR_C2HCMD				BIT9
-#define IMR_CPWM				BIT8
-//RSVD [2-7]
-#define IMR_OCPINT				BIT1
-#define IMR_WLANOFF			BIT0
-
-//----------------------------------------------------------------------------
-// 8723E series PCIE Host IMR/ISR bit
-//----------------------------------------------------------------------------
-// IMR DW0 Bit 0-31
-#define PHIMR_TIMEOUT2				BIT31
-#define PHIMR_TIMEOUT1				BIT30
-#define PHIMR_PSTIMEOUT			BIT29
-#define PHIMR_GTINT4				BIT28
-#define PHIMR_GTINT3				BIT27
-#define PHIMR_TXBCNERR				BIT26
-#define PHIMR_TXBCNOK				BIT25
-#define PHIMR_TSF_BIT32_TOGGLE	BIT24
-#define PHIMR_BCNDMAINT3			BIT23
-#define PHIMR_BCNDMAINT2			BIT22
-#define PHIMR_BCNDMAINT1			BIT21
-#define PHIMR_BCNDMAINT0			BIT20
-#define PHIMR_BCNDOK3				BIT19
-#define PHIMR_BCNDOK2				BIT18
-#define PHIMR_BCNDOK1				BIT17
-#define PHIMR_BCNDOK0				BIT16
-#define PHIMR_HSISR_IND_ON			BIT15
-#define PHIMR_BCNDMAINT_E			BIT14
-#define PHIMR_ATIMEND_E			BIT13
-#define PHIMR_ATIM_CTW_END		BIT12
-#define PHIMR_HISRE_IND			BIT11	// RO. HISRE Indicator (HISRE & HIMRE is true, this bit is set to 1)
-#define PHIMR_C2HCMD				BIT10
-#define PHIMR_CPWM2				BIT9
-#define PHIMR_CPWM					BIT8
-#define PHIMR_HIGHDOK				BIT7		// High Queue DMA OK Interrupt
-#define PHIMR_MGNTDOK				BIT6		// Management Queue DMA OK Interrupt
-#define PHIMR_BKDOK					BIT5		// AC_BK DMA OK Interrupt
-#define PHIMR_BEDOK					BIT4		// AC_BE DMA OK Interrupt
-#define PHIMR_VIDOK					BIT3		// AC_VI DMA OK Interrupt
-#define PHIMR_VODOK				BIT2		// AC_VO DMA Interrupt
-#define PHIMR_RDU					BIT1		// Receive Descriptor Unavailable
-#define PHIMR_ROK					BIT0		// Receive DMA OK Interrupt
-
-// PCIE Host Interrupt Status Extension bit
-#define PHIMR_BCNDMAINT7			BIT23
-#define PHIMR_BCNDMAINT6			BIT22
-#define PHIMR_BCNDMAINT5			BIT21
-#define PHIMR_BCNDMAINT4			BIT20
-#define PHIMR_BCNDOK7				BIT19
-#define PHIMR_BCNDOK6				BIT18
-#define PHIMR_BCNDOK5				BIT17
-#define PHIMR_BCNDOK4				BIT16
-// bit12 15: RSVD
-#define PHIMR_TXERR					BIT11
-#define PHIMR_RXERR					BIT10
-#define PHIMR_TXFOVW				BIT9
-#define PHIMR_RXFOVW				BIT8
-// bit2-7: RSVD
-#define PHIMR_OCPINT				BIT1
-// bit0: RSVD
-
-#define UHIMR_TIMEOUT2				BIT31
-#define UHIMR_TIMEOUT1				BIT30
-#define UHIMR_PSTIMEOUT			BIT29
-#define UHIMR_GTINT4				BIT28
-#define UHIMR_GTINT3				BIT27
-#define UHIMR_TXBCNERR				BIT26
-#define UHIMR_TXBCNOK				BIT25
-#define UHIMR_TSF_BIT32_TOGGLE	BIT24
-#define UHIMR_BCNDMAINT3			BIT23
-#define UHIMR_BCNDMAINT2			BIT22
-#define UHIMR_BCNDMAINT1			BIT21
-#define UHIMR_BCNDMAINT0			BIT20
-#define UHIMR_BCNDOK3				BIT19
-#define UHIMR_BCNDOK2				BIT18
-#define UHIMR_BCNDOK1				BIT17
-#define UHIMR_BCNDOK0				BIT16
-#define UHIMR_HSISR_IND			BIT15
-#define UHIMR_BCNDMAINT_E			BIT14
-//RSVD	BIT13
-#define UHIMR_CTW_END				BIT12
-//RSVD	BIT11
-#define UHIMR_C2HCMD				BIT10
-#define UHIMR_CPWM2				BIT9
-#define UHIMR_CPWM					BIT8
-#define UHIMR_HIGHDOK				BIT7		// High Queue DMA OK Interrupt
-#define UHIMR_MGNTDOK				BIT6		// Management Queue DMA OK Interrupt
-#define UHIMR_BKDOK				BIT5		// AC_BK DMA OK Interrupt
-#define UHIMR_BEDOK				BIT4		// AC_BE DMA OK Interrupt
-#define UHIMR_VIDOK					BIT3		// AC_VI DMA OK Interrupt
-#define UHIMR_VODOK				BIT2		// AC_VO DMA Interrupt
-#define UHIMR_RDU					BIT1		// Receive Descriptor Unavailable
-#define UHIMR_ROK					BIT0		// Receive DMA OK Interrupt
-
-// USB Host Interrupt Status Extension bit
-#define UHIMR_BCNDMAINT7			BIT23
-#define UHIMR_BCNDMAINT6			BIT22
-#define UHIMR_BCNDMAINT5			BIT21
-#define UHIMR_BCNDMAINT4			BIT20
-#define UHIMR_BCNDOK7				BIT19
-#define UHIMR_BCNDOK6				BIT18
-#define UHIMR_BCNDOK5				BIT17
-#define UHIMR_BCNDOK4				BIT16
-// bit14-15: RSVD
-#define UHIMR_ATIMEND_E			BIT13
-#define UHIMR_ATIMEND				BIT12
-#define UHIMR_TXERR					BIT11
-#define UHIMR_RXERR					BIT10
-#define UHIMR_TXFOVW				BIT9
-#define UHIMR_RXFOVW				BIT8
-// bit2-7: RSVD
-#define UHIMR_OCPINT				BIT1
-// bit0: RSVD
-
-
-#define HAL_NIC_UNPLUG_ISR			0xFFFFFFFF	// The value when the NIC is unplugged for PCI.
-#define HAL_NIC_UNPLUG_PCI_ISR		0xEAEAEAEA	// The value when the NIC is unplugged for PCI in PCI interrupt (page 3).
-
-//----------------------------------------------------------------------------
-//       8188 IMR/ISR bits
-//----------------------------------------------------------------------------
-#define IMR_DISABLED_88E			0x0
-// IMR DW0(0x0060-0063) Bit 0-31
-#define IMR_TXCCK_88E				BIT30		// TXRPT interrupt when CCX bit of the packet is set	
-#define IMR_PSTIMEOUT_88E			BIT29		// Power Save Time Out Interrupt
-#define IMR_GTINT4_88E				BIT28		// When GTIMER4 expires, this bit is set to 1	
-#define IMR_GTINT3_88E				BIT27		// When GTIMER3 expires, this bit is set to 1	
-#define IMR_TBDER_88E				BIT26		// Transmit Beacon0 Error			
-#define IMR_TBDOK_88E				BIT25		// Transmit Beacon0 OK			
-#define IMR_TSF_BIT32_TOGGLE_88E	BIT24		// TSF Timer BIT32 toggle indication interrupt			
-#define IMR_BCNDMAINT0_88E		BIT20		// Beacon DMA Interrupt 0			
-#define IMR_BCNDERR0_88E			BIT16		// Beacon Queue DMA Error 0
-#define IMR_HSISR_IND_ON_INT_88E	BIT15		// HSISR Indicator (HSIMR & HSISR is true, this bit is set to 1)			
-#define IMR_BCNDMAINT_E_88E		BIT14		// Beacon DMA Interrupt Extension for Win7			
-#define IMR_ATIMEND_88E			BIT12		// CTWidnow End or ATIM Window End
-#define IMR_HISR1_IND_INT_88E		BIT11		// HISR1 Indicator (HISR1 & HIMR1 is true, this bit is set to 1)
-#define IMR_C2HCMD_88E				BIT10		// CPU to Host Command INT Status, Write 1 clear	
-#define IMR_CPWM2_88E				BIT9			// CPU power Mode exchange INT Status, Write 1 clear	
-#define IMR_CPWM_88E				BIT8			// CPU power Mode exchange INT Status, Write 1 clear	
-#define IMR_HIGHDOK_88E			BIT7			// High Queue DMA OK	
-#define IMR_MGNTDOK_88E			BIT6			// Management Queue DMA OK	
-#define IMR_BKDOK_88E				BIT5			// AC_BK DMA OK		
-#define IMR_BEDOK_88E				BIT4			// AC_BE DMA OK	
-#define IMR_VIDOK_88E				BIT3			// AC_VI DMA OK		
-#define IMR_VODOK_88E				BIT2			// AC_VO DMA OK	
-#define IMR_RDU_88E					BIT1			// Rx Descriptor Unavailable	
-#define IMR_ROK_88E					BIT0			// Receive DMA OK
-
-// IMR DW1(0x00B4-00B7) Bit 0-31
-#define IMR_BCNDMAINT7_88E		BIT27		// Beacon DMA Interrupt 7
-#define IMR_BCNDMAINT6_88E		BIT26		// Beacon DMA Interrupt 6
-#define IMR_BCNDMAINT5_88E		BIT25		// Beacon DMA Interrupt 5
-#define IMR_BCNDMAINT4_88E		BIT24		// Beacon DMA Interrupt 4
-#define IMR_BCNDMAINT3_88E		BIT23		// Beacon DMA Interrupt 3
-#define IMR_BCNDMAINT2_88E		BIT22		// Beacon DMA Interrupt 2
-#define IMR_BCNDMAINT1_88E		BIT21		// Beacon DMA Interrupt 1
-#define IMR_BCNDOK7_88E			BIT20		// Beacon Queue DMA OK Interrup 7
-#define IMR_BCNDOK6_88E			BIT19		// Beacon Queue DMA OK Interrup 6
-#define IMR_BCNDOK5_88E			BIT18		// Beacon Queue DMA OK Interrup 5
-#define IMR_BCNDOK4_88E			BIT17		// Beacon Queue DMA OK Interrup 4
-#define IMR_BCNDOK3_88E			BIT16		// Beacon Queue DMA OK Interrup 3
-#define IMR_BCNDOK2_88E			BIT15		// Beacon Queue DMA OK Interrup 2
-#define IMR_BCNDOK1_88E			BIT14		// Beacon Queue DMA OK Interrup 1
-#define IMR_ATIMEND_E_88E			BIT13		// ATIM Window End Extension for Win7
-#define IMR_TXERR_88E				BIT11		// Tx Error Flag Interrupt Status, write 1 clear.
-#define IMR_RXERR_88E				BIT10		// Rx Error Flag INT Status, Write 1 clear
-#define IMR_TXFOVW_88E				BIT9			// Transmit FIFO Overflow
-#define IMR_RXFOVW_88E				BIT8			// Receive FIFO Overflow
-
-/*===================================================================
-=====================================================================
-Here the register defines are for 92C. When the define is as same with 92C,
-we will use the 92C's define for the consistency
-So the following defines for 92C is not entire!!!!!!
-=====================================================================
-=====================================================================*/
-/*
-Based on Datasheet V33---090401
-Register Summary
-Current IOREG MAP
-0x0000h ~ 0x00FFh   System Configuration (256 Bytes)
-0x0100h ~ 0x01FFh   MACTOP General Configuration (256 Bytes)
-0x0200h ~ 0x027Fh   TXDMA Configuration (128 Bytes)
-0x0280h ~ 0x02FFh   RXDMA Configuration (128 Bytes)
-0x0300h ~ 0x03FFh   PCIE EMAC Reserved Region (256 Bytes)
-0x0400h ~ 0x04FFh   Protocol Configuration (256 Bytes)
-0x0500h ~ 0x05FFh   EDCA Configuration (256 Bytes)
-0x0600h ~ 0x07FFh   WMAC Configuration (512 Bytes)
-0x2000h ~ 0x3FFFh   8051 FW Download Region (8196 Bytes)
-*/
-//----------------------------------------------------------------------------
-//		 8192C (TXPAUSE) transmission pause 	(Offset 0x522, 8 bits)
-//----------------------------------------------------------------------------
-// Note:
-//	The the bits of stoping AC(VO/VI/BE/BK) queue in datasheet RTL8192S/RTL8192C are wrong,
-//	the correct arragement is VO - Bit0, VI - Bit1, BE - Bit2, and BK - Bit3.
-//	8723 and 88E may be not correct either in the eralier version. Confirmed with DD Tim.
-// By Bruce, 2011-09-22.
-#define StopBecon		BIT6
-#define StopHigh			BIT5
-#define StopMgt			BIT4
-#define StopBK			BIT3
-#define StopBE			BIT2
-#define StopVI			BIT1
-#define StopVO			BIT0
-
-//----------------------------------------------------------------------------
-//       8192C (RCR) Receive Configuration Register	(Offset 0x608, 32 bits)
-//----------------------------------------------------------------------------
-#define RCR_APPFCS				BIT31	// WMAC append FCS after pauload
-#define RCR_APP_MIC				BIT30	// MACRX will retain the MIC at the bottom of the packet. 
-#define RCR_APP_ICV				BIT29	// MACRX will retain the ICV at the bottom of the packet.
-#define RCR_APP_PHYST_RXFF		BIT28	// PHY Status is appended before RX packet in RXFF
-#define RCR_APP_BA_SSN			BIT27	// SSN of previous TXBA is appended as after original RXDESC as the 4-th DW of RXDESC.
-#define RCR_NONQOS_VHT			BIT26	// Reserved
-#define RCR_RSVD_BIT25			BIT25	// Reserved
-#define RCR_ENMBID				BIT24	// Enable Multiple BssId. Only response ACK to the packets whose DID(A1) matching to the addresses in the MBSSID CAM Entries.
-#define RCR_LSIGEN				BIT23	// Enable LSIG TXOP Protection function. Search KEYCAM for each rx packet to check if LSIGEN bit is set.
-#define RCR_MFBEN				BIT22	// Enable immediate MCS Feedback function. When Rx packet with MRQ = 1'b1, then search KEYCAM to find sender's MCS Feedback function and send response.
-#define RCR_RSVD_BIT21			BIT21	// Reserved
-#define RCR_RSVD_BIT20			BIT20	// Reserved
-#define RCR_RSVD_BIT19			BIT19	// Reserved
-#define RCR_TIM_PARSER_EN		BIT18	// RX Beacon TIM Parser.
-#define RCR_BM_DATA_EN			BIT17	// Broadcast data packet interrupt enable.
-#define RCR_UC_DATA_EN			BIT16	// Unicast data packet interrupt enable.
-#define RCR_RSVD_BIT15			BIT15	// Reserved
-#define RCR_HTC_LOC_CTRL		BIT14	// MFC<--HTC=1 MFC-->HTC=0
-#define RCR_AMF					BIT13	// Accept management type frame
-#define RCR_ACF					BIT12	// Accept control type frame. Control frames BA, BAR, and PS-Poll (when in AP mode) are not controlled by this bit. They are controlled by ADF.
-#define RCR_ADF					BIT11	// Accept data type frame. This bit also regulates BA, BAR, and PS-Poll (AP mode only).
-#define RCR_RSVD_BIT10			BIT10	// Reserved
-#define RCR_AICV					BIT9		// Accept ICV error packet
-#define RCR_ACRC32				BIT8		// Accept CRC32 error packet 
-#define RCR_CBSSID_BCN			BIT7		// Accept BSSID match packet (Rx beacon, probe rsp)
-#define RCR_CBSSID_DATA		BIT6		// Accept BSSID match packet (Data)
-#define RCR_CBSSID				RCR_CBSSID_DATA	// Accept BSSID match packet
-#define RCR_APWRMGT			BIT5		// Accept power management packet
-#define RCR_ADD3				BIT4		// Accept address 3 match packet
-#define RCR_AB					BIT3		// Accept broadcast packet 
-#define RCR_AM					BIT2		// Accept multicast packet 
-#define RCR_APM					BIT1		// Accept physical match packet
-#define RCR_AAP					BIT0		// Accept all unicast packet 
-
-
-//-----------------------------------------------------
-//
-//	0x0000h ~ 0x00FFh	System Configuration
-//
-//-----------------------------------------------------
-
-//2 SYS_ISO_CTRL
-#define ISO_MD2PP				BIT(0)
-#define ISO_UA2USB				BIT(1)
-#define ISO_UD2CORE				BIT(2)
-#define ISO_PA2PCIE				BIT(3)
-#define ISO_PD2CORE				BIT(4)
-#define ISO_IP2MAC				BIT(5)
-#define ISO_DIOP					BIT(6)
-#define ISO_DIOE					BIT(7)
-#define ISO_EB2CORE				BIT(8)
-#define ISO_DIOR					BIT(9)
-#define PWC_EV12V				BIT(15)
-
-
-//2 SYS_FUNC_EN
-#define FEN_BBRSTB				BIT(0)
-#define FEN_BB_GLB_RSTn		BIT(1)
-#define FEN_USBA				BIT(2)
-#define FEN_UPLL				BIT(3)
-#define FEN_USBD				BIT(4)
-#define FEN_DIO_PCIE			BIT(5)
-#define FEN_PCIEA				BIT(6)
-#define FEN_PPLL					BIT(7)
-#define FEN_PCIED				BIT(8)
-#define FEN_DIOE				BIT(9)
-#define FEN_CPUEN				BIT(10)
-#define FEN_DCORE				BIT(11)
-#define FEN_ELDR				BIT(12)
-//#define FEN_DIO_RF				BIT(13)
-#define FEN_HWPDN				BIT(14)
-#define FEN_MREGEN				BIT(15)
-
-/* REG_WL_FUNC_EN 0x0004 */
-#define BIT_SHIFT_FEN_BBRSTB_V2                      17
-#define BIT_FEN_BBRSTB_V2                            ((u32)0x00000001 << BIT_SHIFT_FEN_BBRSTB_V2)                      /*!<R/W 0  When this bit is set to , CCK and OFDM are disabled, and clock are gated. Otherwise, CCK and OFDM are enabled. */
-#define BIT_SHIFT_FEN_BB_GLB_RSTN_V2                 16
-#define BIT_FEN_BB_GLB_RSTN_V2                       ((u32)0x00000001 << BIT_SHIFT_FEN_BB_GLB_RSTN_V2)                 /*!<R/W 0  When this bit is set to , whole BB is reset. When this bit is set, BB is enabled. */
-#define BIT_SHIFT_FEN_MAC_PMC                        0
-#define BIT_FEN_MAC_PMC                              ((u32)0x00000001 << BIT_SHIFT_FEN_MAC_PMC)                        /*!<R/W 0  1: enable MAC PMC; 0: reset */
-
-/* REG_CLKDIV 0x0008 */
-#define BIT_SHIFT_MAC_CLK_SEL                        18
-#define BIT_MASK_MAC_CLK_SEL                         ((u32)0x00000003 << BIT_SHIFT_MAC_CLK_SEL)                        /*!<R/W 2'b10  11/10:20M 01:40M 00:80M */
-#define MAC_CLK_20M				(0x2 << BIT_SHIFT_MAC_CLK_SEL)
-#define MAC_CLK_40M				(0x1 << BIT_SHIFT_MAC_CLK_SEL)
-
-/* REG_WL_PMC_CTRL 0x0020 */
-#define BIT_SHIFT_WL_PMC_OFFMAC                       1
-#define BIT_WL_PMC_OFFMAC                             ((u32)0x00000001 << BIT_SHIFT_WL_PMC_OFFMAC)                       /*!<R/W 0  Inform WLAN PMC FSM to power On mode, include clock, isolation, power control for MAC only (clear when Power Ready) */
-#define BIT_SHIFT_WL_PMC_ONMAC                       0
-#define BIT_WL_PMC_ONMAC                             ((u32)0x00000001 << BIT_SHIFT_WL_PMC_ONMAC)                       /*!<R/W 0  Inform WLAN PMC FSM to power On mode, include clock, isolation, power control for MAC only (clear when Power Ready) */
-
-
-//2 APS_FSMCO
-#define PFM_LDALL				BIT(0)
-#define PFM_ALDN				BIT(1)
-#define PFM_LDKP				BIT(2)
-#define PFM_WOWL				BIT(3)
-#define EnPDN					BIT(4)
-#define PDN_PL					BIT(5)
-#define APFM_ONMAC				BIT(8)
-#define APFM_OFF				BIT(9)
-#define APFM_RSM				BIT(10)
-#define AFSM_HSUS				BIT(11)
-#define AFSM_PCIE				BIT(12)
-#define APDM_MAC				BIT(13)
-#define APDM_HOST				BIT(14)
-#define APDM_HPDN				BIT(15)
-#define RDY_MACON				BIT(16)
-#define SUS_HOST				BIT(17)
-#define ROP_ALD					BIT(20)
-#define ROP_PWR					BIT(21)
-#define ROP_SPS					BIT(22)
-#define SOP_MRST				BIT(25)
-#define SOP_FUSE				BIT(26)
-#define SOP_ABG					BIT(27)
-#define SOP_AMB					BIT(28)
-#define SOP_RCK					BIT(29)
-#define SOP_A8M					BIT(30)
-#define XOP_BTCK				BIT(31)
-
-//2 SYS_CLKR
-#define ANAD16V_EN				BIT(0)
-#define ANA8M					BIT(1)
-#define MACSLP					BIT(4)
-#define LOADER_CLK_EN			BIT(5)
-
-
-//2 9346CR /REG_SYS_EEPROM_CTRL
-#define BOOT_FROM_EEPROM		BIT(4)
-#define EEPROMSEL				BIT(4)
-#define EEPROM_EN				BIT(5)
-
-
-//2 RF_CTRL
-#define RF_EN					BIT(0)
-#define RF_RSTB					BIT(1)
-#define RF_SDMRSTB				BIT(2)
-#define RF_DAI_REG00_WREN		BIT(6)
-#define RF_DAI_RW_EN			BIT(7)
-
-
-//2 LDOV12D_CTRL
-#define LDV12_EN				BIT(0)
-#define LDV12_SDBY				BIT(1)
-#define LPLDO_HSM				BIT(2)
-#define LPLDO_LSM_DIS			BIT(3)
-#define _LDV12_VADJ(x)			(((x) & 0xF) << 4)
-
-
-
-//2 EFUSE_TEST (For RTL8723 partially)
-#define EF_TRPT					BIT(7)
-#define EF_CELL_SEL				(BIT(8)|BIT(9)) // 00: Wifi Efuse, 01: BT Efuse0, 10: BT Efuse1, 11: BT Efuse2
-#define LDOE25_EN				BIT(31)
-#define EFUSE_SEL(x)				(((x) & 0x3) << 8)
-#define EFUSE_SEL_MASK			0x300
-#define EFUSE_WIFI_SEL_0		0x0
-#define EFUSE_BT_SEL_0			0x1
-#define EFUSE_BT_SEL_1			0x2
-#define EFUSE_BT_SEL_2			0x3
-
-
-//2 8051FWDL
-//2 MCUFWDL
-#define MCUFWDL_EN				BIT(0)
-#define MCUFWDL_RDY			BIT(1)
-#define FWDL_ChkSum_rpt		BIT(2)
-#define MACINI_RDY				BIT(3)
-#define BBINI_RDY				BIT(4)
-#define RFINI_RDY				BIT(5)
-#define WINTINI_RDY				BIT(6)
-#define RAM_DL_SEL				BIT(7)
-#define ROM_DLEN				BIT(19)
-#define CPRST					BIT(23)
-
-
-//2 REG_SYS_CFG
-#define XCLK_VLD				BIT(0)
-#define ACLK_VLD				BIT(1)
-#define UCLK_VLD				BIT(2)
-#define PCLK_VLD				BIT(3)
-#define PCIRSTB					BIT(4)
-#define V15_VLD					BIT(5)
-#define SW_OFFLOAD_EN			BIT(7)
-#define SIC_IDLE					BIT(8)
-#define BD_MAC2					BIT(9)
-#define BD_MAC1					BIT(10)
-#define IC_MACPHY_MODE		BIT(11)
-#define CHIP_VER				(BIT(12)|BIT(13)|BIT(14)|BIT(15))
-#define BT_FUNC					BIT(16)
-#define VENDOR_ID				BIT(19)
-#define EXT_VENDOR_ID			(BIT(18)|BIT(19)) //Currently only for RTL8723B
-#define PAD_HWPD_IDN			BIT(22)
-#define TRP_VAUX_EN				BIT(23)	// RTL ID
-#define TRP_BT_EN				BIT(24)
-#define BD_PKG_SEL				BIT(25)
-#define BD_HCI_SEL				BIT(26)
-#define TYPE_ID					BIT(27)
-#define RF_TYPE_ID				BIT(27)
-
-#define RTL_ID					BIT(23) // TestChip ID, 1:Test(RLE); 0:MP(RL)
-#define SPS_SEL					BIT(24) // 1:LDO regulator mode; 0:Switching regulator mode
-
-
-#define CHIP_VER_RTL_MASK		0xF000	//Bit 12 ~ 15
-#define CHIP_VER_RTL_SHIFT		12
-#define EXT_VENDOR_ID_SHIFT	18
-
-//2 REG_GPIO_OUTSTS (For RTL8723 only)
-#define EFS_HCI_SEL				(BIT(0)|BIT(1))
-#define PAD_HCI_SEL				(BIT(2)|BIT(3))
-#define HCI_SEL					(BIT(4)|BIT(5))
-#define PKG_SEL_HCI				BIT(6)
-#define FEN_GPS					BIT(7)
-#define FEN_BT					BIT(8)
-#define FEN_WL					BIT(9)
-#define FEN_PCI					BIT(10)
-#define FEN_USB					BIT(11)
-#define BTRF_HWPDN_N			BIT(12)
-#define WLRF_HWPDN_N			BIT(13)
-#define PDN_BT_N				BIT(14)
-#define PDN_GPS_N				BIT(15)
-#define BT_CTL_HWPDN			BIT(16)
-#define GPS_CTL_HWPDN			BIT(17)
-#define PPHY_SUSB				BIT(20)
-#define UPHY_SUSB				BIT(21)
-#define PCI_SUSEN				BIT(22)
-#define USB_SUSEN				BIT(23)
-#define RF_RL_ID					(BIT(31)|BIT(30)|BIT(29)|BIT(28))
-
-//2 REG_WL_BTCOEX_CTRL (0x74)
-#define PTA_EN					BIT(16)
-#define BT_MODE					(BIT(17)|BIT(18))
-
-
-//-----------------------------------------------------
-//
-//	0x0100h ~ 0x01FFh	MACTOP General Configuration
-//
-//-----------------------------------------------------
-
-//2 Function Enable Registers
-//2 CR
-#define HCI_TXDMA_EN			BIT(0)
-#define HCI_RXDMA_EN			BIT(1)
-#define TXDMA_EN				BIT(2)
-#define RXDMA_EN				BIT(3)
-#define PROTOCOL_EN				BIT(4)
-#define SCHEDULE_EN				BIT(5)
-#define MACTXEN					BIT(6)
-#define MACRXEN					BIT(7)
-#define ENSWBCN					BIT(8)
-#define ENSEC					BIT(9)
-#define CALTMR_EN				BIT(10)	// 32k CAL TMR enable
-
-// Network type
-#define _NETTYPE(x)				(((x) & 0x3) << 16)
-#define MASK_NETTYPE			0x30000
-#define NT_NO_LINK				0x0
-#define NT_LINK_AD_HOC			0x1
-#define NT_LINK_AP				0x2
-#define NT_AS_AP				0x3
-
-//2 PBP - Page Size Register
-#define GET_RX_PAGE_SIZE(value)			((value) & 0xF)
-#define GET_TX_PAGE_SIZE(value)			(((value) & 0xF0) >> 4)
-#define _PSRX_MASK				0xF
-#define _PSTX_MASK				0xF0
-#define _PSRX(x)				(x)
-#define _PSTX(x)				((x) << 4)
-
-#define PBP_64					0x0
-#define PBP_128					0x1
-#define PBP_256					0x2
-#define PBP_512					0x3
-#define PBP_1024				0x4
-
-
-//2 TX/RXDMA
-#define RXDMA_ARBBW_EN		BIT(0)
-#define RXSHFT_EN				BIT(1)
-#define RXDMA_AGG_EN			BIT(2)
-#define QS_VO_QUEUE			BIT(8)
-#define QS_VI_QUEUE				BIT(9)
-#define QS_BE_QUEUE			BIT(10)
-#define QS_BK_QUEUE			BIT(11)
-#define QS_MANAGER_QUEUE		BIT(12)
-#define QS_HIGH_QUEUE			BIT(13)
-
-#define HQSEL_VOQ				BIT(0)
-#define HQSEL_VIQ				BIT(1)
-#define HQSEL_BEQ				BIT(2)
-#define HQSEL_BKQ				BIT(3)
-#define HQSEL_MGTQ				BIT(4)
-#define HQSEL_HIQ				BIT(5)
-
-// For normal driver, 0x10C
-#define _TXDMA_CMQ_MAP(x) 	 		(((x)&0x3) << 16)
-#define _TXDMA_HIQ_MAP(x) 	 		(((x)&0x3) << 14)
-#define _TXDMA_MGQ_MAP(x) 	 		(((x)&0x3) << 12)
-#define _TXDMA_BKQ_MAP(x) 	 		(((x)&0x3) << 10)
-#define _TXDMA_BEQ_MAP(x) 	 		(((x)&0x3) << 8 )
-#define _TXDMA_VIQ_MAP(x) 	 		(((x)&0x3) << 6 )
-#define _TXDMA_VOQ_MAP(x) 	 		(((x)&0x3) << 4 )
-
-#define QUEUE_EXTRA				0
-#define QUEUE_LOW				1
-#define QUEUE_NORMAL			2
-#define QUEUE_HIGH				3
-
-
-//2 TRXFF_BNDY
-
-
-//2 LLT_INIT
-#define _LLT_NO_ACTIVE				0x0
-#define _LLT_WRITE_ACCESS			0x1
-#define _LLT_READ_ACCESS			0x2
-
-#define _LLT_INIT_DATA(x)			((x) & 0xFF)
-#define _LLT_INIT_ADDR(x)			(((x) & 0xFF) << 8)
-#define _LLT_OP(x)					(((u32)(x) & 0x3) << 30)
-#define _LLT_OP_VALUE(x)			(((x) >> 30) & 0x3)
-
-
-//-----------------------------------------------------
-//
-//	0x0200h ~ 0x027Fh	TXDMA Configuration
-//
-//-----------------------------------------------------
-//2 RQPN
-#define _HPQ(x)					((x) & 0xFF)
-#define _LPQ(x)					(((x) & 0xFF) << 8)
-#define _PUBQ(x)					(((x) & 0xFF) << 16)
-#define _NPQ(x)					((x) & 0xFF)			// NOTE: in RQPN_NPQ register
-#define _EPQ(x)					(((x) & 0xFF) << 16)	// NOTE: in RQPN_EPQ register
-
-
-#define HPQ_PUBLIC_DIS			BIT(24)
-#define LPQ_PUBLIC_DIS			BIT(25)
-#define LD_RQPN					BIT(31)
-
-
-//2 TDECTL
-#define BLK_DESC_NUM_SHIFT			4
-#define BLK_DESC_NUM_MASK			0xF
-
-
-//2 TXDMA_OFFSET_CHK
-#define DROP_DATA_EN				BIT(9)
-
-//2 AUTO_LLT
-#define BIT_SHIFT_TXPKTNUM 24
-#define BIT_MASK_TXPKTNUM 0xff
-#define BIT_TXPKTNUM(x) (((x) & BIT_MASK_TXPKTNUM) << BIT_SHIFT_TXPKTNUM)
-
-#define BIT_TDE_DBG_SEL BIT(23)
-#define BIT_AUTO_INIT_LLT BIT(16)
-
-#define BIT_SHIFT_Tx_OQT_free_space 8
-#define BIT_MASK_Tx_OQT_free_space 0xff
-#define BIT_Tx_OQT_free_space(x) (((x) & BIT_MASK_Tx_OQT_free_space) << BIT_SHIFT_Tx_OQT_free_space)
-
-
-//-----------------------------------------------------
-//
-//	0x0280h ~ 0x028Bh	RX DMA Configuration
-//
-//-----------------------------------------------------
-
-//2 REG_RXDMA_CONTROL, 0x0286h
-// Write only. When this bit is set, RXDMA will decrease RX PKT counter by one. Before
-// this bit is polled, FW shall update RXFF_RD_PTR first. This register is write pulse and auto clear.
-//#define RXPKT_RELEASE_POLL			BIT(0)
-// Read only. When RXMA finishes on-going DMA operation, RXMDA will report idle state in
-// this bit. FW can start releasing packets after RXDMA entering idle mode.
-//#define RXDMA_IDLE					BIT(1)
-// When this bit is set, RXDMA will enter this mode after on-going RXDMA packet to host
-// completed, and stop DMA packet to host. RXDMA will then report Default: 0;
-//#define RW_RELEASE_EN				BIT(2)
-
-//2 REG_RXPKT_NUM, 0x0284
-#define 	RXPKT_RELEASE_POLL	BIT(16)
-#define	RXDMA_IDLE				BIT(17)
-#define	RW_RELEASE_EN			BIT(18)
-
-//-----------------------------------------------------
-//
-//	0x0400h ~ 0x047Fh	Protocol Configuration
-//
-//-----------------------------------------------------
-//2 CPU_MGT_INFORMATION
-#define CPUMGT_POLL                 BIT(5)
-
-//2 FWHW_TXQ_CTRL
-#define EN_AMPDU_RTY_NEW			BIT(7)
-
-
-//2 SPEC SIFS
-#define _SPEC_SIFS_CCK(x)			((x) & 0xFF)
-#define _SPEC_SIFS_OFDM(x)			(((x) & 0xFF) << 8)
-
-//2 RL
-#define	RETRY_LIMIT_SHORT_SHIFT			8
-#define	RETRY_LIMIT_LONG_SHIFT			0
-
-//2 QUEUE_CTRL (0x04C6)
-#define	PTA_WL_TX_EN	BIT(4)
-
-//2 TX_HANG_CTRL (0x045E)
-#define BIT_EN_GNT_BT_AWAKE BIT(3)
-
-#define BIT_SHIFT_PRETX_AGGR_TIME_MAX                8
-#define BIT_MASK_PRETX_AGGR_TIME_MAX                 ((u32)0x000007FF << BIT_SHIFT_PRETX_AGGR_TIME_MAX)                /*!<R/W 230h  If BIT_PRETX_AGGR_EN = 1, the bits will count down after PHYTXON signal asserting every transmission in pre-tx mode.(Default: 7us) */
-
-//-----------------------------------------------------
-//
-//	0x0500h ~ 0x05FFh	EDCA Configuration
-//
-//-----------------------------------------------------
-
-//2 EDCA setting
-#define AC_PARAM_TXOP_LIMIT_OFFSET		16
-#define AC_PARAM_ECW_MAX_OFFSET			12
-#define AC_PARAM_ECW_MIN_OFFSET			8
-#define AC_PARAM_AIFS_OFFSET				0
-
-
-#define _LRL(x)					((x) & 0x3F)
-#define _SRL(x)					(((x) & 0x3F) << 8)
-
-
-//2 BCN_CTRL
-#define EN_TXBCN_RPT			BIT(2)
-#define EN_BCN_FUNCTION		BIT(3)
-#define STOP_BCNQ				BIT(6)
-#define DIS_RX_BSSID_FIT		BIT(6)
-
-#define DIS_ATIM					BIT(0)
-#define DIS_BCNQ_SUB			BIT(1)
-#define DIS_TSF_UDT				BIT(4)
-
-// The same function but different bit field.
-#define DIS_TSF_UDT0_NORMAL_CHIP	BIT(4)
-#define DIS_TSF_UDT0_TEST_CHIP	BIT(5)
-
-
-//2 ACMHWCTRL
-#define AcmHw_HwEn				BIT(0)
-#define AcmHw_BeqEn			BIT(1)
-#define AcmHw_ViqEn				BIT(2)
-#define AcmHw_VoqEn			BIT(3)
-#define AcmHw_BeqStatus		BIT(4)
-#define AcmHw_ViqStatus			BIT(5)
-#define AcmHw_VoqStatus		BIT(6)
-
-//2 REG_DUAL_TSF_RST (0x553)
-#define DUAL_TSF_RST_P2P		BIT(4)
-
-//2 REG_TBTT_HOLD_PREDICT_P1 (0x5B2)
-#define BIT_DIS_BCN_1st			BIT(5)
-#define BIT_DIS_BCN_2st			BIT(6)
-
-//2 REG_NOA_DESC_SEL (0x5CF)
-#define NOA_DESC_SEL_0			0
-#define NOA_DESC_SEL_1			BIT(4)
-
-//2 REG_PTA_PRE_TRX_CTRL(0x5B8)
-#define PTA_RXBCN_DIR	BIT(29)
-//-----------------------------------------------------
-//
-//	0x0600h ~ 0x07FFh	WMAC Configuration
-//
-//-----------------------------------------------------
-
-//2 APSD_CTRL
-#define APSDOFF					BIT(6)
-
-//2 TCR
-#define TSFRST					BIT(0)
-#define DIS_GCLK					BIT(1)
-#define PAD_SEL					BIT(2)
-#define PWR_ST					BIT(6)
-#define PWRBIT_OW_EN			BIT(7)
-#define ACRC						BIT(8)
-#define CFENDFORM				BIT(9)
-#define ICV						BIT(10)
-
-
-//2 RCR
-#define AAP						BIT(0)
-#define APM						BIT(1)
-#define AM						BIT(2)
-#define AB						BIT(3)
-#define ADD3						BIT(4)
-#define APWRMGT				BIT(5)
-#define CBSSID					BIT(6)
-#define CBSSID_DATA				BIT(6)
-#define CBSSID_BCN				BIT(7)
-#define ACRC32					BIT(8)
-#define AICV						BIT(9)
-#define ADF						BIT(11)
-#define ACF						BIT(12)
-#define AMF						BIT(13)
-#define HTC_LOC_CTRL			BIT(14)
-#define UC_DATA_EN				BIT(16)
-#define BM_DATA_EN				BIT(17)
-#define MFBEN					BIT(22)
-#define LSIGEN					BIT(23)
-#define EnMBID					BIT(24)
-#define FORCEACK				BIT(26)
-#define APP_BASSN				BIT(27)
-#define APP_PHYSTS				BIT(28)
-#define APP_ICV					BIT(29)
-#define APP_MIC					BIT(30)
-#define APP_FCS					BIT(31)
-
-
-//2 SECCFG
-#define SCR_TxUseDK				BIT(0)			//Force Tx Use Default Key
-#define SCR_RxUseDK				BIT(1)			//Force Rx Use Default Key
-#define SCR_TxEncEnable			BIT(2)			//Enable Tx Encryption
-#define SCR_RxDecEnable			BIT(3)			//Enable Rx Decryption
-#define SCR_SKByA2				BIT(4)			//Search kEY BY A2
-#define SCR_NoSKMC				BIT(5)			//No Key Search Multicast
-#define SCR_TXBCUSEDK			BIT(6)			// Force Tx Broadcast packets Use Default Key
-#define SCR_RXBCUSEDK			BIT(7)			// Force Rx Broadcast packets Use Default Key
-#define BIT_DIS_GCLK_TKIP                          ((u32)0x00000001 << 13)          /*!<R/W 0  Disable gated clock control for WEP/TKIP engine. */
-
-//2 REG_BBPSF_CTRL
-#define BIT_BBPSF_MPDUCHKEN	BIT[5]	//{This bit is set to 1 to enable MAC to inform BB enter power saving mode as rx unmatch my MACID unicast or unmatch my BSSID Broadcast/Mutlicast packets, for non_ampdu case. Only valid when BIT_BBPSF_MHCHKEN is set 1.}						
-#define BIT_BBPSF_MHCHKEN		BIT[4]	//{This bit is set to 1 to enable MAC to inform BB enter power saving mode as rx unmatch my MACID unicast or unmatch my BSSID Broadcast/Mutlicast packets}						
-#define BIT_BBPSF_ERRCHKEN		BIT[3]	//{This bit is set to 1 to enable MAC to inform BB enter power saving mode as rx FCS error packets number is large than the FCS error packet threshold defined by BBPSF_ERRTHR.}						
-#define BIT_MASK_BBPSF_ERRTHR	0x07	//{FCS error packet threshold: 3'd0: 1 packets; 3'd1: 2 packets; 3'd2: 4 packets; 3'd3: 6 packets����}						
-#define BIT_SHIFT_BBPSF_ERRTHR	0
-
-//2 REG_BT_COEX (0x764)
-#define SW_CTRL_BT_BASEBAND_EN				BIT(9)
-#define SW_CTRL_BT_BASEBAND					BIT(10)
-#define SW_CTRL_BT_RF_EN					BIT(11)
-#define SW_CTRL_BT_RF						BIT(12)
-//-----------------------------------------------------
-//
-//  0x0300h ~ 0x03FFh   PCIe/LBus
-//
-//-----------------------------------------------------
-
-
-//4 REG_LX_CTRL1(0x300)
-#define BIT_WT_LIT_EDN              	BIT(25)
-#define BIT_RD_LITT_EDN             	BIT(24)
-
-#define BIT_SHIFT_MAX_RXDMA	20
-#define BIT_MASK_MAX_RXDMA     0x7
-#define BIT_MAX_RXDMA(x)            (((x) & BIT_MASK_MAX_RXDMA)<<BIT_SHIFT_MAX_RXDMA)
-
-#define BIT_SHIFT_MAX_TXDMA     16
-#define BIT_MASK_MAX_TXDMA      0x7
-#define BIT_MAX_TXDMA(x)            (((x) & BIT_MASK_MAX_TXDMA)<<BIT_SHIFT_MAX_TXDMA)
-
-#define SW_BCN_ADDR_SEL		BIT(16)
-#define BIT_STOP_BCNQ               	BIT(14)
-#define BIT_STOP_MGQ			BIT(13)
-#define BIT_STOP_VOQ                	BIT(12)
-#define BIT_STOP_VIQ                	BIT(11)
-#define BIT_STOP_BEQ                	BIT(10)
-#define BIT_STOP_BKQ                	BIT(9)
-#define BIT_STOP_RXQ                	BIT(8)
-#define BIT_STOP_HI7Q               	BIT(7)
-#define BIT_STOP_HI6Q               	BIT(6)
-#define BIT_STOP_HI5Q               	BIT(5)
-#define BIT_STOP_HI4Q               	BIT(4)
-#define BIT_STOP_HI3Q               	BIT(3)
-#define BIT_STOP_HI2Q               	BIT(2)
-#define BIT_STOP_HI1Q               	BIT(1)
-#define BIT_STOP_HI0Q               	BIT(0)
-
-
-//4 REG_INT_MIG_CFG(0x0304), 4 Bytes
-#define BIT_SHIFT_TXTTIMER_MATCH_NUM		28
-#define BIT_MASK_TXTTIMER_MATCH_NUM			0xF
-#define BIT_MAX_TXTTIMER_MATCH_NUM(x)		(((x) & BIT_MASK_TXTTIMER_MATCH_NUM)<<BIT_SHIFT_TXTTIMER_MATCH_NUM)
-
-#define BIT_SHIFT_TXPKT_NUM_MATCH			24
-#define BIT_MASK_TXPKT_NUM_MATCH                    0xF
-#define BIT_MAX_TXPKT_NUM_MATCH(x)                  (((x) & BIT_MASK_TXPKT_NUM_MATCH)<<BIT_SHIFT_TXPKT_NUM_MATCH)
-
-#define BIT_SHIFT_RXTTIMER_MATCH_NUM		20
-#define BIT_MASK_RXTTIMER_MATCH_NUM			0xF
-#define BIT_MAX_RXTTIMER_MATCH_NUM(x)		(((x) & BIT_MASK_RXTTIMER_MATCH_NUM)<<BIT_SHIFT_RXTTIMER_MATCH_NUM)
-
-#define BIT_SHIFT_RXPKT_NUM_MATCH			16
-#define BIT_MASK_RXPKT_NUM_MATCH			0xF
-#define BIT_MAX_RXPKT_NUM_MATCH(x)			(((x) & BIT_MASK_RXPKT_NUM_MATCH)<<BIT_SHIFT_RXPKT_NUM_MATCH)
-
-#define BIT_SHIFT_MIGRATE_TIMER				0
-#define BIT_MASK_MIGRATE_TIMER				0xFFFF
-#define BIT_MAX_MIGRATE_TIMER(x)				(((x) & BIT_MASK_MIGRATE_TIMER)<<BIT_SHIFT_MIGRATE_TIMER)
-
-//4 #define REG_BCNQ_TXBD_DESA          0x0308  // 8 Bytes
-//4 #define REG_MGQ_TXBD_DESA           0x0310  // 8 Bytes
-//4 #define REG_VOQ_TXBD_DESA           0x0318  // 8 Bytes
-//4 #define REG_VIQ_TXBD_DESA           0x0320  // 8 Bytes
-//4 #define REG_BEQ_TXBD_DESA           0x0328  // 8 Bytes
-//4 #define REG_BKQ_TXBD_DESA           0x0330  // 8 Bytes
-//4 #define REG_RXQ_RXBD_DESA           0x0338  // 8 Bytes
-//4 #define REG_HI0Q_TXBD_DESA          0x0340  // 8 Bytes
-//4 #define REG_HI1Q_TXBD_DESA          0x0348  // 8 Bytes
-//4 #define REG_HI2Q_TXBD_DESA          0x0350  // 8 Bytes
-//4 #define REG_HI3Q_TXBD_DESA          0x0358  // 8 Bytes
-//4 #define REG_HI4Q_TXBD_DESA          0x0360  // 8 Bytes
-//4 #define REG_HI5Q_TXBD_DESA          0x0368  // 8 Bytes
-//4 #define REG_HI6Q_TXBD_DESA          0x0370  // 8 Bytes
-//4 #define REG_HI7Q_TXBD_DESA          0x0378  // 8 Bytes
-
-
-//4 #define REG_MGQ_TXBD_NUM            0x0380  // 2 Bytes
-#define BIT_SHIFT_MGQ_DESC_MODE                      12
-#define BIT_MASK_MGQ_DESC_MODE                       0x3
-#define BIT_MAX_MGQ_DESC_MODE(x)                     (((x) & BIT_MASK_MGQ_DESC_MODE)<<BIT_SHIFT_MGQ_DESC_MODE)
-
-#define BIT_SHIFT_MGQ_DESC_NUM                      0
-#define BIT_MASK_MGQ_DESC_NUM                       0xFFF
-#define BIT_MAX_MGQ_DESC_NUM(x)                     (((x) & BIT_MASK_MGQ_DESC_NUM)<<BIT_SHIFT_MGQ_DESC_NUM)
-
-
-//4 #define REG_RX_RXBD_NUM             0x0382  // 2 Bytes
-#define BIT_SYS_32_64                               BIT(15)
-
-#define BIT_SHIFT_BCNQ_DESC_MODE                    13
-#define BIT_MASK_BCNQ_DESC_MODE                     0x3
-#define BIT_MAX_BCNQ_DESC_MODE(x)                   (((x) & BIT_MASK_BCNQ_DESC_MODE)<<BIT_SHIFT_BCNQ_DESC_MODE)
-
-#define BIT_BCNQ_FLAG                               BIT(12)
-
-#define BIT_SHIFT_RXQ_DESC_NUM                      0
-#define BIT_MASK_RXQ_DESC_NUM                       0xFFF
-#define BIT_MAX_RXQ_DESC_NUM(x)                     (((x) & BIT_MASK_RXQ_DESC_NUM)<<BIT_SHIFT_RXQ_DESC_NUM)
-
-
-//4 #define REG_VOQ_TXBD_NUM            0x0384  // 2 Bytes
-#define BIT_VOQ_FLAG                                BIT(14)
-
-#define BIT_SHIFT_VOQ_DESC_MODE                    12
-#define BIT_MASK_VOQ_DESC_MODE                     0x3
-#define BIT_MAX_VOQ_DESC_MODE(x)                   (((x) & BIT_MASK_VOQ_DESC_MODE)<<BIT_SHIFT_VOQ_DESC_MODE)
-
-#define BIT_SHIFT_VOQ_DESC_NUM                      0
-#define BIT_MASK_VOQ_DESC_NUM                       0xFFF
-#define BIT_MAX_VOQ_DESC_NUM(x)                     (((x) & BIT_MASK_VOQ_DESC_NUM)<<BIT_SHIFT_VOQ_DESC_NUM)
-
-
-//4 #define REG_VIQ_TXBD_NUM            0x0386  // 2 Bytes
-#define BIT_VIQ_FLAG                                BIT(14)
-
-#define BIT_SHIFT_VIQ_DESC_MODE                    12
-#define BIT_MASK_VIQ_DESC_MODE                     0x3
-#define BIT_MAX_VIQ_DESC_MODE(x)                   (((x) & BIT_MASK_VIQ_DESC_MODE)<<BIT_SHIFT_VIQ_DESC_MODE)
-
-#define BIT_SHIFT_VIQ_DESC_NUM                      0
-#define BIT_MASK_VIQ_DESC_NUM                       0xFFF
-#define BIT_MAX_VIQ_DESC_NUM(x)                     (((x) & BIT_MASK_VIQ_DESC_NUM)<<BIT_SHIFT_VIQ_DESC_NUM)
-
-
-//4 #define REG_BEQ_TXBD_NUM            0x0388  // 2 Bytes
-#define BIT_BEQ_FLAG                                BIT(14)
-
-#define BIT_SHIFT_BEQ_DESC_MODE                    12
-#define BIT_MASK_BEQ_DESC_MODE                     0x3
-#define BIT_MAX_BEQ_DESC_MODE(x)                   (((x) & BIT_MASK_BEQ_DESC_MODE)<<BIT_SHIFT_BEQ_DESC_MODE)
-
-#define BIT_SHIFT_BEQ_DESC_NUM                      0
-#define BIT_MASK_BEQ_DESC_NUM                       0xFFF
-#define BIT_MAX_BEQ_DESC_NUM(x)                     (((x) & BIT_MASK_BEQ_DESC_NUM)<<BIT_SHIFT_BEQ_DESC_NUM)
-
-
-
-//4 #define REG_BKQ_TXBD_NUM            0x038A  // 2 Bytes
-#define BIT_BKQ_FLAG                                BIT(14)
-
-#define BIT_SHIFT_BKQ_DESC_MODE                    12
-#define BIT_MASK_BKQ_DESC_MODE                     0x3
-#define BIT_MAX_BKQ_DESC_MODE(x)                   (((x) & BIT_MASK_BKQ_DESC_MODE)<<BIT_SHIFT_BKQ_DESC_MODE)
-
-#define BIT_SHIFT_BKQ_DESC_NUM                      0
-#define BIT_MASK_BKQ_DESC_NUM                       0xFFF
-#define BIT_MAX_BKQ_DESC_NUM(x)                     (((x) & BIT_MASK_BKQ_DESC_NUM)<<BIT_SHIFT_BKQ_DESC_NUM)
-
-
-//4 #define REG_HI0Q_TXBD_NUM            0x038C  // 2 Bytes
-#define BIT_HI0Q_FLAG                                BIT(14)
-
-#define BIT_SHIFT_HI0Q_DESC_MODE                    12
-#define BIT_MASK_HI0Q_DESC_MODE                     0x3
-#define BIT_MAX_HI0Q_DESC_MODE(x)                   (((x) & BIT_MASK_HI0Q_DESC_MODE)<<BIT_SHIFT_HI0Q_DESC_MODE)
-
-#define BIT_SHIFT_HI0Q_DESC_NUM                      0
-#define BIT_MASK_HI0Q_DESC_NUM                       0xFFF
-#define BIT_MAX_HI0Q_DESC_NUM(x)                     (((x) & BIT_MASK_HI0Q_DESC_NUM)<<BIT_SHIFT_HI0Q_DESC_NUM)
-
-
-//4 #define REG_HI1Q_TXBD_NUM            0x038E  // 2 Bytes
-#define BIT_HI1Q_FLAG                                BIT(14)
-
-#define BIT_SHIFT_HI1Q_DESC_MODE                    12
-#define BIT_MASK_HI1Q_DESC_MODE                     0x3
-#define BIT_MAX_HI1Q_DESC_MODE(x)                   (((x) & BIT_MASK_HI1Q_DESC_MODE)<<BIT_SHIFT_HI1Q_DESC_MODE)
-
-#define BIT_SHIFT_HI1Q_DESC_NUM                      0
-#define BIT_MASK_HI1Q_DESC_NUM                       0xFFF
-#define BIT_MAX_HI1Q_DESC_NUM(x)                     (((x) & BIT_MASK_HI1Q_DESC_NUM)<<BIT_SHIFT_HI1Q_DESC_NUM)
-
-
-//4 #define REG_HI2Q_TXBD_NUM            0x0390  // 2 Bytes
-#define BIT_HI2Q_FLAG                                BIT(14)
-
-#define BIT_SHIFT_HI2Q_DESC_MODE                    12
-#define BIT_MASK_HI2Q_DESC_MODE                     0x3
-#define BIT_MAX_HI2Q_DESC_MODE(x)                   (((x) & BIT_MASK_HI2Q_DESC_MODE)<<BIT_SHIFT_HI2Q_DESC_MODE)
-
-
-#define BIT_SHIFT_HI2Q_DESC_NUM                      0
-#define BIT_MASK_HI2Q_DESC_NUM                       0xFFF
-#define BIT_MAX_HI2Q_DESC_NUM(x)                     (((x) & BIT_MASK_HI2Q_DESC_NUM)<<BIT_SHIFT_HI2Q_DESC_NUM)
-
-
-//4 #define REG_HI3Q_TXBD_NUM            0x0392  // 2 Bytes
-#define BIT_HI3Q_FLAG                                BIT(14)
-
-#define BIT_SHIFT_HI3Q_DESC_MODE                    12
-#define BIT_MASK_HI3Q_DESC_MODE                     0x3
-#define BIT_MAX_HI3Q_DESC_MODE(x)                   (((x) & BIT_MASK_HI3Q_DESC_MODE)<<BIT_SHIFT_HI3Q_DESC_MODE)
-
-#define BIT_SHIFT_HI3Q_DESC_NUM                      0
-#define BIT_MASK_HI3Q_DESC_NUM                       0xFFF
-#define BIT_MAX_HI3Q_DESC_NUM(x)                     (((x) & BIT_MASK_HI3Q_DESC_NUM)<<BIT_SHIFT_HI3Q_DESC_NUM)
-
-
-//4 #define REG_HI4Q_TXBD_NUM            0x0394  // 2 Bytes
-#define BIT_HI4Q_FLAG                                BIT(14)
-
-#define BIT_SHIFT_HI4Q_DESC_MODE                    12
-#define BIT_MASK_HI4Q_DESC_MODE                     0x3
-#define BIT_MAX_HI4Q_DESC_MODE(x)                   (((x) & BIT_MASK_HI4Q_DESC_MODE)<<BIT_SHIFT_HI4Q_DESC_MODE)
-
-#define BIT_SHIFT_HI4Q_DESC_NUM                      0
-#define BIT_MASK_HI4Q_DESC_NUM                       0xFFF
-#define BIT_MAX_HI4Q_DESC_NUM(x)                     (((x) & BIT_MASK_HI4Q_DESC_NUM)<<BIT_SHIFT_HI4Q_DESC_NUM)
-
-
-//4 #define REG_HI5Q_TXBD_NUM            0x0396  // 2 Bytes
-#define BIT_HI5Q_FLAG                                BIT(14)
-
-#define BIT_SHIFT_HI5Q_DESC_MODE                    12
-#define BIT_MASK_HI5Q_DESC_MODE                     0x3
-#define BIT_MAX_HI5Q_DESC_MODE(x)                   (((x) & BIT_MASK_HI5Q_DESC_MODE)<<BIT_SHIFT_HI5Q_DESC_MODE)
-
-#define BIT_SHIFT_HI5Q_DESC_NUM                      0
-#define BIT_MASK_HI5Q_DESC_NUM                       0xFFF
-#define BIT_MAX_HI5Q_DESC_NUM(x)                     (((x) & BIT_MASK_HI5Q_DESC_NUM)<<BIT_SHIFT_HI5Q_DESC_NUM)
-
-
-//4 #define REG_HI6Q_TXBD_NUM            0x0398  // 2 Bytes
-#define BIT_HI6Q_FLAG                                BIT(14)
-
-#define BIT_SHIFT_HI6Q_DESC_MODE                    12
-#define BIT_MASK_HI6Q_DESC_MODE                     0x3
-#define BIT_MAX_HI6Q_DESC_MODE(x)                   (((x) & BIT_MASK_HI6Q_DESC_MODE)<<BIT_SHIFT_HI6Q_DESC_MODE)
-
-#define BIT_SHIFT_HI6Q_DESC_NUM                      0
-#define BIT_MASK_HI6Q_DESC_NUM                       0xFFF
-#define BIT_MAX_HI6Q_DESC_NUM(x)                     (((x) & BIT_MASK_HI6Q_DESC_NUM)<<BIT_SHIFT_HI6Q_DESC_NUM)
-
-
-//4 #define REG_HI7Q_TXBD_NUM            0x039A  // 2 Bytes
-#define BIT_HI7Q_FLAG                                BIT(14)
-
-#define BIT_SHIFT_HI7Q_DESC_MODE                    12
-#define BIT_MASK_HI7Q_DESC_MODE                     0x3
-#define BIT_MAX_HI7Q_DESC_MODE(x)                   (((x) & BIT_MASK_HI7Q_DESC_MODE)<<BIT_SHIFT_HI7Q_DESC_MODE)
-
-#define BIT_SHIFT_HI7Q_DESC_NUM                      0
-#define BIT_MASK_HI7Q_DESC_NUM                       0xFFF
-#define BIT_MAX_HI7Q_DESC_NUM(x)                     (((x) & BIT_MASK_HI7Q_DESC_NUM)<<BIT_SHIFT_HI7Q_DESC_NUM)
-
-
-//4 #define REG_TSFTIMER_HCI            0x039C  // 4 Bytes
-#define BIT_SHIFT_TSFT2_HCI                           16
-#define BIT_MASK_TSFT2_HCI                            0xFFFF
-#define BIT_MAX_TSFT2_HCI(x)                         (((x) & BIT_MASK_TSFT2_HCI)<<BIT_SHIFT_TSFT2_HCI)
-
-#define BIT_SHIFT_TSFT1_HCI                           0
-#define BIT_MASK_TSFT1_HCI                            0xFFFF
-#define BIT_MAX_TSFT1_HCI(x)                         (((x) & BIT_MASK_TSFT1_HCI)<<BIT_SHIFT_TSFT1_HCI)
-
-
-//4 #define REG_BD_RWPTR_CLR            0x039C  // 4 Bytes
-#define BIT_CLR_HI7Q_HW_IDX                             BIT(29)
-#define BIT_CLR_HI6Q_HW_IDX                             BIT(28)
-#define BIT_CLR_HI5Q_HW_IDX                             BIT(27)
-#define BIT_CLR_HI4Q_HW_IDX                             BIT(26)
-#define BIT_CLR_HI3Q_HW_IDX                             BIT(25)
-#define BIT_CLR_HI2Q_HW_IDX                             BIT(24)
-#define BIT_CLR_HI1Q_HW_IDX                             BIT(23)
-#define BIT_CLR_HI0Q_HW_IDX                             BIT(22)
-#define BIT_CLR_BKQ_HW_IDX                              BIT(21)
-#define BIT_CLR_BEQ_HW_IDX                              BIT(20)
-#define BIT_CLR_VIQ_HW_IDX                              BIT(19)
-#define BIT_CLR_VOQ_HW_IDX                              BIT(18)
-#define BIT_CLR_MGTQ_HW_IDX                             BIT(17)
-#define BIT_CLR_RXQ_HW_IDX                              BIT(16)
-
-#define BIT_SRST_TX                                     BIT(15)
-#define BIT_SRST_RX                                     BIT(14)
-
-#define BIT_CLR_HI7Q_HOST_IDX                           BIT(13)
-#define BIT_CLR_HI6Q_HOST_IDX                           BIT(12)
-#define BIT_CLR_HI5Q_HOST_IDX                           BIT(11)
-#define BIT_CLR_HI4Q_HOST_IDX                           BIT(10)
-#define BIT_CLR_HI3Q_HOST_IDX                           BIT(9)
-#define BIT_CLR_HI2Q_HOST_IDX                           BIT(8)
-#define BIT_CLR_HI1Q_HOST_IDX                           BIT(7)
-#define BIT_CLR_HI0Q_HOST_IDX                           BIT(6)
-#define BIT_CLR_BKQ_HOST_IDX                            BIT(5)
-#define BIT_CLR_BEQ_HOST_IDX                            BIT(4)
-#define BIT_CLR_VIQ_HOST_IDX                            BIT(3)
-#define BIT_CLR_VOQ_HOST_IDX                            BIT(2)
-#define BIT_CLR_MGTQ_HOST_IDX                           BIT(1)
-#define BIT_CLR_RXQ_HOST_IDX                            BIT(0)
-
-
-//4 #define REG_VOQ_TXBD_IDX            0x03A0  // 4 Bytes
-//4 #define REG_VIQ_TXBD_IDX            0x03A4  // 4 Bytes
-//4 #define REG_BEQ_TXBD_IDX            0x03A8  // 4 Bytes
-//4 #define REG_BKQ_TXBD_IDX            0x03AC  // 4 Bytes
-//4 #define REG_MGQ_TXBD_IDX            0x03B0  // 4 Bytes
-//4 #define REG_RXQ_RXBD_IDX            0x03B4  // 4 Bytes
-//4 #define REG_HI0Q_TXBD_IDX           0x03B8  // 4 Bytes
-//4 #define REG_HI1Q_TXBD_IDX           0x03BC  // 4 Bytes
-//4 #define REG_HI2Q_TXBD_IDX           0x03C0  // 4 Bytes
-//4 #define REG_HI3Q_TXBD_IDX           0x03C4  // 4 Bytes
-//4 #define REG_HI4Q_TXBD_IDX           0x03C8  // 4 Bytes
-//4 #define REG_HI5Q_TXBD_IDX           0x03CC  // 4 Bytes
-//4 #define REG_HI6Q_TXBD_IDX           0x03D0  // 4 Bytes
-//4 #define REG_HI7Q_TXBD_IDX           0x03D4  // 4 Bytes
-
-
-//4 #define REG_PCIE_HRPWM1_V1          0x03D9  // 1 Bytes
-//4 #define REG_PCIE_HCPWM1_V1          0x03DA  // 1 Bytes
-
-
-#define REG_LX_CTRL2                0x03DB  // 1 Bytes
-#define BIT_SHIFT_HPS_CLKR                          4
-#define BIT_MASK_HPS_CLKR                           0x3
-#define BIT_HPS_CLKR(x)                             (((x) & BIT_MASK_HPS_CLKR)<<BIT_SHIFT_HPS_CLKR)
-#define BIT_LX_INT                                  BIT(3)
-
-//4 #define REG_PCIE_HRPWM2_V1          0x03DC  // 2 Bytes
-//4 #define REG_PCIE_HCPWM2_V1          0x03DE  // 2 Bytes
-//4 #define REG_PCIE_H2C_MSG_V1         0x03E0  // 4 Bytes
-//4 #define REG_PCIE_C2H_MSG_V1         0x03E4  // 4 Bytes
-
-#define REG_LX_DMA_ISR              0x03E8  // 4 Bytes
-#define BIT_BCN7DOK         BIT(23)
-#define BIT_BCN6DOK         BIT(22)
-#define BIT_BCN5DOK         BIT(21)
-#define BIT_BCN4DOK         BIT(20)
-#define BIT_BCN3DOK         BIT(19)
-#define BIT_BCN2DOK         BIT(18)
-#define BIT_BCN1DOK         BIT(17)
-#define BIT_BCN0DOK         BIT(16)
-
-#define BIT_M7DOK           BIT(15)
-#define BIT_M6DOK           BIT(14)
-#define BIT_M5DOK           BIT(13)
-#define BIT_M4DOK           BIT(12)
-#define BIT_M3DOK           BIT(11)
-#define BIT_M2DOK           BIT(10)
-#define BIT_M1DOK           BIT(9)
-#define BIT_M0DOK           BIT(8)
-
-#define BIT_MGTQDOK         BIT(6)
-#define BIT_BKQDOK          BIT(5)
-#define BIT_BEQDOK          BIT(4)
-#define BIT_VIQDOK          BIT(3)
-#define BIT_VOQDOK          BIT(2)
-#define BIT_RDU             BIT(1)
-#define BIT_RXDOK           BIT(0)
-
-//4 #define REG_LX_DMA_IMR              0x03EC  // 4 Bytes
-#define BIT_BCN7DOKM        BIT(23)
-#define BIT_BCN6DOKM        BIT(22)
-#define BIT_BCN5DOKM        BIT(21)
-#define BIT_BCN4DOKM        BIT(20)
-#define BIT_BCN3DOKM        BIT(19)
-#define BIT_BCN2DOKM        BIT(18)
-#define BIT_BCN1DOKM        BIT(17)
-#define BIT_BCN0DOKM        BIT(16)
-
-#define BIT_M7DOKM          BIT(15)
-#define BIT_M6DOKM          BIT(14)
-#define BIT_M5DOKM          BIT(13)
-#define BIT_M4DOKM          BIT(12)
-#define BIT_M3DOKM          BIT(11)
-#define BIT_M2DOKM          BIT(10)
-#define BIT_M1DOKM          BIT(9)
-#define BIT_M0DOKM          BIT(8)
-
-#define BIT_MGTQDOKM        BIT(6)
-#define BIT_BKQDOKM         BIT(5)
-#define BIT_BEQDOKM         BIT(4)
-#define BIT_VIQDOKM         BIT(3)
-#define BIT_VOQDOKM         BIT(2)
-#define BIT_RDUM            BIT(1)
-#define BIT_RXDOKM          BIT(0)
-
-//4 #define REG_LX_DMA_DBG              0x03F0  // 4 Bytes
-#define BIT_RX_OVER_RD_ERR              BIT(20)
-#define BIT_RXDMA_STUCK                 BIT(19)
-
-#define BIT_SHIFT_RX_STATE              16
-#define BIT_MASK_RX_STATE               0x7
-#define BIT_RX_STATE(x)                 (((x) & BIT_MASK_RX_STATE)<<BIT_SHIFT_RX_STATE)
-
-#define BIT_TDE_NO_IDLE                 BIT(15)
-#define BIT_TXDMA_STUCK                 BIT(14)
-#define BIT_TDE_FULL_ERR                BIT(13)
-#define BIT_HD_SIZE_ERR                 BIT(12)
-
-#define BIT_SHIFT_TX_STATE              8
-#define BIT_MASK_TX_STATE               0xF
-#define BIT_TX_STATE(x)                 (((x) & BIT_MASK_TX_STATE)<<BIT_SHIFT_TX_STATE)
-
-#define BIT_MST_BUSY                    BIT(3)
-#define BIT_SLV_BUSY                    BIT(2)
-#define BIT_RXDES_UNAVAIL               BIT(1)
-#define BIT_EN_DBG_STUCK                BIT(0)
-
-
-
-//4 #define REG_PCIE_MIX_CFG            0x03F8  // 4 Bytes
-//4 #define REG_BUS_MIX_CFG             0x03F8  // 4 Bytes
-#define BIT_SHIFT_WATCH_DOG_RECORD              10
-#define BIT_MASK_WATCH_DOG_RECORD               0x3FFF
-#define BIT_WATCH_DOG_RECORD(x)                 (((x) & BIT_MASK_WATCH_DOG_RECORD)<<BIT_SHIFT_WATCH_DOG_RECORD)
-
-#define BIT_R_IO_TIMEOUT_FLAG                   BIT(9)
-#define BIT_EN_WATCH_DOG                        BIT(8)
-
-
-
-#define REG_BUS_MIX_CFG             0x03F8  // 4 Bytes
-
-//-----------------------------------------------------
-//
-//  0x0700h ~ 0x07FFh
-//
-//-----------------------------------------------------
-//2 REG_BT_STAT_CTRL (0x0778)
-#define BIT_RTK_MODE_EN			BIT(0)
-
-//2 REG_BT_COEX_ENHANCED_INTR_CTRL (0x076E)
-#define BIT_WL_ACT_MASK_EN		BIT(1)
-#define BIT_WL_ACT_PINMUX		BIT(3)
-
-
-//2 REG_BT_TDMA_TIME (0x0790)
-#define BIT_BT_REPORT_SAMPLE_RATE 		(BIT(5)|BIT(4)|BIT(3)|BIT(2)|BIT(1)|BIT(0))
-
-
-
-//-----------------------------------------------------
-//
-//	0xFE00h ~ 0xFE55h	USB Configuration
-//
-//-----------------------------------------------------
-
-//2 USB Information (0xFE17)
-#define USB_IS_HIGH_SPEED			0
-#define USB_IS_FULL_SPEED			1
-#define USB_SPEED_MASK				BIT(5)
-
-#define USB_NORMAL_SIE_EP_MASK	0xF
-#define USB_NORMAL_SIE_EP_SHIFT	4
-
-//2 Special Option
-#define USB_AGG_EN				BIT(3)
-
-// 0; Use interrupt endpoint to upload interrupt pkt
-// 1; Use bulk endpoint to upload interrupt pkt,
-#define INT_BULK_SEL			BIT(4)
-
-//2REG_C2HEVT_CLEAR
-#define C2H_EVT_HOST_CLOSE		0x00	// Set by driver and notify FW that the driver has read the C2H command message
-#define C2H_EVT_FW_CLOSE		0xFF	// Set by FW indicating that FW had set the C2H command message and it's not yet read by driver.
-
-
-//2REG_MULTI_FUNC_CTRL(For RTL8723 Only)
-#define WL_HWPDN_EN			BIT0	// Enable GPIO[9] as WiFi HW PDn source
-#define WL_HWPDN_SL			BIT1	// WiFi HW PDn polarity control
-#define WL_FUNC_EN				BIT2	// WiFi function enable
-#define WL_HWROF_EN			BIT3	// Enable GPIO[9] as WiFi RF HW PDn source
-#define BT_HWPDN_EN			BIT16	// Enable GPIO[11] as BT HW PDn source
-#define BT_HWPDN_SL			BIT17	// BT HW PDn polarity control
-#define BT_FUNC_EN				BIT18	// BT function enable
-#define BT_HWROF_EN			BIT19	// Enable GPIO[11] as BT/GPS RF HW PDn source
-#define GPS_HWPDN_EN			BIT20	// Enable GPIO[10] as GPS HW PDn source
-#define GPS_HWPDN_SL			BIT21	// GPS HW PDn polarity control
-#define GPS_FUNC_EN			BIT22	// GPS function enable
-
-//3 REG_LIFECTRL_CTRL
-#define HAL92C_EN_PKT_LIFE_TIME_BK		BIT3
-#define HAL92C_EN_PKT_LIFE_TIME_BE		BIT2
-#define HAL92C_EN_PKT_LIFE_TIME_VI		BIT1
-#define HAL92C_EN_PKT_LIFE_TIME_VO		BIT0
-
-#define HAL92C_MSDU_LIFE_TIME_UNIT		128	// in us, said by Tim.
-
-//2 8192D PartNo.
-#define PARTNO_92D_NIC							(BIT7|BIT6)
-#define PARTNO_92D_NIC_REMARK 				(BIT5|BIT4)
-#define PARTNO_SINGLE_BAND_VS  				BIT3
-#define PARTNO_SINGLE_BAND_VS_REMARK 		BIT1
-#define PARTNO_CONCURRENT_BAND_VC 			(BIT3|BIT2)
-#define PARTNO_CONCURRENT_BAND_VC_REMARK 	(BIT1|BIT0)
-
-//========================================================
-// General definitions
-//========================================================
-
-#define LAST_ENTRY_OF_TX_PKT_BUFFER_8188E		176
-#define LAST_ENTRY_OF_TX_PKT_BUFFER_8812			255
-#define LAST_ENTRY_OF_TX_PKT_BUFFER_8723B		255
-#define LAST_ENTRY_OF_TX_PKT_BUFFER_8192C		255
-#define LAST_ENTRY_OF_TX_PKT_BUFFER_DUAL_MAC	127
-#define LAST_ENTRY_OF_TX_PKT_BUFFER_8188F			255
-#define LAST_ENTRY_OF_TX_PKT_BUFFER_8723D		255
-
-#define POLLING_LLT_THRESHOLD				20
-#define POLLING_READY_TIMEOUT_COUNT		1000
-
-// GPIO BIT
-#define HAL_8192C_HW_GPIO_WPS_BIT	BIT2
-
-#endif //__HAL_COMMON_H__
-
diff --git a/os/board/rtl8720e/src/component/wifi/driver/include/hal_intf.h b/os/board/rtl8720e/src/component/wifi/driver/include/hal_intf.h
deleted file mode 100644
index bffc32c98..000000000
--- a/os/board/rtl8720e/src/component/wifi/driver/include/hal_intf.h
+++ /dev/null
@@ -1,369 +0,0 @@
-/******************************************************************************
- *
- * Copyright(c) 2007 - 2012 Realtek Corporation. All rights reserved.
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of version 2 of the GNU General Public License as
- * published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
- * more details.
- *
- * You should have received a copy of the GNU General Public License along with
- * this program; if not, write to the Free Software Foundation, Inc.,
- * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
- *
- *
- ******************************************************************************/
-#ifndef __HAL_INTF_H__
-#define __HAL_INTF_H__
-
-#ifdef CONFIG_80211AX_HE
-#include "halbb_export_fun.h"
-#include "halbb_hw_cfg_ex.h"
-#include "halbb_ex.h"
-#endif
-
-#define phy_query_mac_reg(Adapter, RegAddr, BitMask) rtw_hal_read_bbreg((Adapter), (RegAddr), (BitMask))
-#define phy_query_bb_reg(Adapter, RegAddr, BitMask) rtw_hal_read_bbreg((Adapter), (RegAddr), (BitMask))
-#define phy_set_bb_reg(Adapter, RegAddr, BitMask, Data) rtw_hal_write_bbreg((Adapter), (RegAddr), (BitMask), (Data))
-#define phy_query_rf_reg(Adapter, eRFPath, RegAddr, BitMask) rtw_hal_read_rfreg((Adapter), (eRFPath), (RegAddr), (BitMask))
-#define phy_set_rf_reg(Adapter, eRFPath, RegAddr, BitMask, Data) rtw_hal_write_rfreg((Adapter), (eRFPath), (RegAddr), (BitMask), (Data))
-
-enum RTL871X_HCI_TYPE {
-	RTW_PCIE	= BIT0,
-	RTW_USB 	= BIT1,
-	RTW_SDIO	= BIT2,
-	RTW_GSPI	= BIT3,
-	RTW_LXBUS	= BIT4,
-	RTW_AXI 	= BIT5
-};
-
-enum _CHIP_TYPE {
-
-	NULL_CHIP_TYPE,
-	RTL8721D_SOC,
-	RTL8735B_SOC,
-	RTL8720E_SOC,
-	RTL8730E_SOC,
-	RTL8721F_SOC,
-	MAX_CHIP_TYPE
-};
-
-typedef enum _HW_VARIABLES {
-	HW_VAR_SET_OPMODE,
-	HW_VAR_MAC_ADDR,
-	HW_VAR_BSSID,
-	HW_VAR_BASIC_RATE,
-	HW_VAR_TXPAUSE,
-	HW_VAR_BCN_FUNC,
-	HW_VAR_CORRECT_TSF,
-	HW_VAR_CHECK_BSSID,
-	HW_VAR_MLME_DISCONNECT,
-	HW_VAR_MLME_SITESURVEY,
-	HW_VAR_MLME_JOIN,
-	HW_VAR_BEACON_INTERVAL,
-	HW_VAR_SEC_CFG,
-	HW_VAR_BCN_VALID,
-	HW_VAR_RF_TYPE,
-	HW_VAR_CAM_EMPTY_ENTRY,
-	HW_VAR_CAM_INVALID_ALL,
-	HW_VAR_CAM_READ,
-	HW_VAR_ACM_CTRL,
-	HW_VAR_AMPDU_MIN_SPACE,
-	HW_VAR_AMPDU_FACTOR,
-	HW_VAR_RXDMA_AGG_PG_TH,
-	HW_VAR_TSF_PORT0,
-	HW_VAR_TSF_PORT1,
-	HW_VAR_SET_RPWM,
-	HW_VAR_GET_RPWM,
-	HW_VAR_CPWM,
-	HW_VAR_H2C_FW_PWRMODE,
-	HW_VAR_H2C_PS_TUNE_PARAM,
-	HW_VAR_H2C_FW_JOINBSSRPT,
-	HW_VAR_FWLPS_RF_ON,
-	HW_VAR_TDLS_WRCR,
-	HW_VAR_TDLS_RS_RCR,
-	HW_VAR_INITIAL_GAIN,
-#ifdef CONFIG_LPS_PG
-	HW_VAR_LPS_PG_HANDLE,
-#endif
-	HW_VAR_CURRENT_ANTENNA,
-	HW_VAR_ANTENNA_DIVERSITY_LINK,
-	HW_VAR_ANTENNA_DIVERSITY_SELECT,
-	HW_VAR_EFUSE_BYTES,
-	HW_VAR_FIFO_CLEARN_UP,
-	HW_VAR_CHECK_TXBUF,
-	HW_VAR_APFM_ON_MAC, //Auto FSM to Turn On, include clock, isolation, power control for MAC only
-	// The valid upper nav range for the HW updating, if the true value is larger than the upper range, the HW won't update it.
-	// Unit in microsecond. 0 means disable this function.
-#ifdef CONFIG_WOWLAN
-	HW_VAR_WOWLAN,
-	HW_VAR_WAKEUP_REASON,
-	HW_VAR_RPWM_TOG,
-#endif
-#ifdef CONFIG_GPIO_WAKEUP
-	HW_SET_GPIO_WL_CTRL,
-#endif
-	HW_VAR_NAV_UPPER,
-	HW_VAR_C2H_HANDLE,
-	HW_VAR_RPT_TIMER_SETTING,
-	HW_VAR_TX_RPT_MAX_MACID,
-	HW_VAR_H2C_MEDIA_STATUS_RPT,
-	HW_VAR_CHK_HI_QUEUE_EMPTY,
-	HW_VAR_DL_BCN_SEL,
-	HW_VAR_PORT_SWITCH,
-	HW_VAR_DO_IQK,
-	HW_VAR_SET_REQ_FW_PS,
-	HW_VAR_FW_PS_STATE,
-	HW_VAR_DL_RSVD_PAGE,
-#ifdef CONFIG_PROMISC
-	HW_VAR_PROMISC,
-#endif
-	HW_VAR_SET_ICV,
-
-	HW_VAR_SET_GNT_BT,
-	HW_VAR_SET_GNT_BT_WITH_CLK_SRC,
-	HW_VAR_SET_PTA_INIT,
-	HW_VAR_GET_SUPPORT_BT,
-	HW_VAR_GET_SUPPORT_BT_MESH,
-	HW_VAR_GET_BT_FW,
-	HW_VAR_GET_BT_FW_LEN,
-	HW_VAR_ADAPTIVITY_CAM,
-#ifdef CONFIG_BT_COEXIST_SOC
-	HW_VAR_BTCOEX_RUN_CASE,
-#endif
-	HW_VAR_DATA_RATE_FALLBACK,
-	HW_VAR_RETRY_LIMIT,
-	HW_VAR_CTRL_PKT_RPT,
-	HW_VAR_PORT1_NETTYPE,
-	HW_VAR_TX_AGG_MAX_NUM,
-	HW_VAR_CCA_EDCCA,
-	HW_VAR_TXBUF_PKT_NUM,
-	HW_VAR_SET_ANTENNA_DIVERSITY,
-	HW_VAR_GET_THERMAL,
-
-	/* add for 11ax support: start */
-	HW_VAR_BSS_COLOR,
-	/* add for 11ax support: end */
-} HW_VARIABLES;
-
-typedef enum _HAL_DEF_VARIABLE {
-	HAL_DEF_IS_SUPPORT_ANT_DIV,
-	HAL_DEF_CURRENT_ANTENNA,
-	HAL_DEF_MAX_RECVBUF_SZ,
-	HAL_DEF_RX_PACKET_OFFSET,
-	HAL_DEF_RX_DMA_SZ_WOW,
-	HAL_DEF_RX_DMA_SZ,
-	HAL_DEF_DBG_DM_FUNC,//for dbg
-	HAL_DEF_TX_LDPC,				/* LDPC support */
-	HAL_DEF_RX_LDPC,				/* LDPC support */
-	HAL_DEF_TX_STBC,				/* TX STBC support */
-	HAL_DEF_RX_STBC, 				// RX STBC support
-	HW_VAR_MAX_RX_AMPDU_FACTOR,
-	HAL_DEF_DBG_DUMP_TXPKT,
-	HAL_DEF_TX_PAGE_SIZE,
-	HAL_DEF_TX_PAGE_BOUNDARY,
-	HAL_DEF_EXPLICIT_BEAMFORMEE,
-	HAL_DEF_VHT_MU_BEAMFORMEE,
-	HAL_DEF_BEAMFORMEE_CAP,
-} HAL_DEF_VARIABLE;
-
-typedef enum _HAL_ODM_VARIABLE {
-	HAL_ODM_STA_INFO,
-//	HAL_ODM_P2P_STATE,
-//	HAL_ODM_WIFI_DISPLAY_STATE,
-	HAL_ODM_DBG_FLAG,
-//	HAL_ODM_DBG_LEVEL,
-	HAL_ODM_RX_INFO_DUMP,
-	HAL_ODM_NOISE_MONITOR,
-	HAL_ODM_REGULATION,
-} HAL_ODM_VARIABLE;
-
-
-#define C2H_TYPE_REG 0
-#define C2H_TYPE_PKT 1
-
-/*
-* C2H event format:
-* Fields    TRIGGER     PLEN      PAYLOAD    SEQ      ID
-* BITS    [127:120]  [119:112]  [111:16]   [15:8]   [7:0]
-*/
-#define C2H_ID_88XX(_c2h)		LE_BITS_TO_1BYTE(((u8*)(_c2h)), 0, 8)
-#define C2H_SEQ_88XX(_c2h)		LE_BITS_TO_1BYTE(((u8*)(_c2h)) + 1, 0, 8)
-#define C2H_PAYLOAD_88XX(_c2h)	(((u8*)(_c2h)) + 2)
-#define C2H_PLEN_88XX(_c2h)		LE_BITS_TO_1BYTE(((u8*)(_c2h)) + 14, 0, 8)
-#define C2H_TRIGGER_88XX(_c2h)	LE_BITS_TO_1BYTE(((u8*)(_c2h)) + 15, 0, 8)
-
-//TODO
-
-#ifdef CONFIG_WOWLAN
-#define Rx_Pairwisekey			0x01
-#define Rx_GTK					0x02
-#define Rx_DisAssoc				0x04
-#define Rx_DeAuth				0x08
-#define FWDecisionDisconnect	0x10
-#define Rx_MagicPkt				0x21
-#define Rx_UnicastPkt			0x22
-#define Rx_PatternPkt			0x23
-#endif
-
-#define rtw_haldata_init(padapter) wifi_hal_init_haldata(padapter)
-#define rtw_haldata_deinit(padapter) wifi_hal_free_haldata(padapter)
-#define rtw_hal_fill_h2c_cmd(padapter, id, buf_len, pbuf) wifi_hal_fill_h2c_cmd(padapter, id, buf_len, pbuf)
-#define rtw_hal_read_chip_info(padapter) wifi_hal_read_adapterinfo(padapter)
-#define rtw_hal_read_chip_version(padapter) wifi_hal_read_chipversion(padapter)
-#define rtw_hal_dm_init(padapter) wifi_hal_phy_init_dm_priv(padapter)
-#define rtw_hal_init(padapter) wifi_hal_init(padapter)
-#define rtw_hal_deinit(padapter) wifi_hal_deinit(padapter)
-#define rtw_hal_set_msr(padapter, val) ROM_WIFI_SetMSR(padapter->iface_type, val)
-#define rtw_hal_update_slottime(updateCap, preamble_mode, slotTime, cur_wireless_mode) ROM_WIFI_UPDATE_Slottime(updateCap, preamble_mode, slotTime, cur_wireless_mode)
-#define rtw_hal_set_hwreg(padapter, variable, val) wifi_hal_hwreg_set(padapter, variable, val)
-#define rtw_hal_get_hwreg(padapter, variable, val) wifi_hal_hwreg_get(padapter, variable, val)
-#define rtw_hal_set_def_var(padapter, eVariable, pValue) wifi_hal_defaultvar_set(padapter, eVariable, pValue)
-#define rtw_hal_get_def_var(padapter, eVariable, pValue) wifi_hal_defaultvar_get(padapter, eVariable, pValue)
-#define rtw_hal_enable_interrupt(padapter) wifi_hal_interrupt_enable(padapter)
-#define rtw_hal_disable_interrupt(padapter) wifi_hal_interrupt_disable(padapter)
-#define rtw_hal_descring_init(padapter) wifi_hal_desc_ring_init(padapter)
-#define rtw_hal_descring_deinit(padapter) wifi_hal_desc_ring_free(padapter)
-#define rtw_hal_descring_reset(padapter) wifi_hal_desc_ring_reset(padapter)
-#define rtw_hal_xmit(padapter, pxmitframe) wifi_hal_xmit(padapter, pxmitframe)
-#define rtw_hal_mgnt_xmit(padapter, pmgntframe) wifi_hal_mgnt_xmit(padapter, pmgntframe)
-#define rtw_hal_init_xmit_priv(padapter) wifi_hal_init_xmit_priv(padapter)
-#define rtw_hal_free_xmit_priv(padapter) wifi_hal_free_xmit_priv(padapter)
-#define rtw_hal_read_bbreg(padapter, RegAddr, BitMask) wifi_hal_read_bb_reg(padapter, RegAddr, BitMask)
-#define rtw_hal_write_bbreg(padapter, RegAddr, BitMask, Data) wifi_hal_write_bb_reg(padapter, RegAddr, BitMask, Data)
-#define rtw_hal_read_rfreg(padapter, eRFPath, RegAddr, BitMask) wifi_hal_read_rf_reg(padapter, eRFPath, RegAddr, BitMask)
-#define rtw_hal_write_rfreg(padapter, eRFPath, RegAddr, BitMask, Data) wifi_hal_write_rf_reg(padapter, eRFPath, RegAddr, BitMask, Data)
-#define rtw_hal_interrupt_handler(padapter)	wifi_hal_interrupt_handle(padapter)
-#define rtw_hal_set_chan(padapter, channel)	wifi_hal_set_channel(padapter, channel)
-#define rtw_hal_set_chnl_bw(padapter, channel, channel_offset, bwmode) wifi_hal_set_channel_bw(padapter, channel, channel_offset, bwmode)
-#define rtw_hal_dm_watchdog(padapter)	wifi_hal_phy_haldm_watchdog(padapter)
-#define rtw_hal_dbg(padapter, p)	wifi_hal_dbg(padapter, p)
-#define rtw_hal_phydm_dbg(padapter, p) wifi_hal_phydm_dbg(padapter, p)
-#define rtw_hal_antdiv_before_linked(padapter)	FALSE
-#define rtw_hal_antdiv_rssi_compared(padapter, dst, src)
-#define rtw_hal_macid_sleep(padapter, macid)
-#define rtw_hal_macid_wakeup(padapter, macid)
-#define rtw_hal_add_ra_tid(padapter, bitmap,arg, rssi_level)
-#define rtw_hal_clone_data(dst_padapter, src_padapter)
-#define	rtw_hal_update_ra_mask(padapter, mac_id, rssi_level)
-
-#ifdef CONFIG_MBSSID_AX
-#define rtw_hal_mbssid_sta_cfg(padapter, enable, bssid_idx_to_join, bssid_ref)	ROM_WIFI_MBSSID_Cfg(enable, bssid_idx_to_join, bssid_ref)
-#else
-#define rtw_hal_mbssid_sta_cfg(padapter, enable, bssid_idx_to_join, bssid_ref)
-#endif
-#ifdef CONFIG_CSI
-#define rtw_hal_csi_en(padapter, act_param)	wifi_hal_csi_en(padapter, act_param)
-#define rtw_hal_csi_cfg(padapter, act_param)	wifi_hal_csi_cfg(padapter, act_param)
-#define rtw_hal_csi_report(pcsipriv, buf_len, csi_buf, len)	wifi_hal_csi_report(pcsipriv, buf_len, csi_buf, len)
-#else
-#define rtw_hal_csi_en(padapter, act_param)	FAIL
-#define rtw_hal_csi_cfg(padapter, act_param)	FAIL
-#define rtw_hal_csi_report(padapter, buf_len, csi_buf, len)	FAIL
-#endif
-#ifdef CONFIG_TWT
-#define rtw_hal_twt_para_set(padapter, twt_para, enable)	wifi_hal_set_twt_para_cmd(padapter, twt_para, enable)
-#else
-#define rtw_hal_twt_para_set(padapter, twt_para, enable)	FAIL
-#endif
-#ifdef CONFIG_80211AX_HE
-#define rtw_hal_set_bss_color(padapter, bss_color, phy_idx) halbb_set_bss_color(rtw_get_haldata(padapter)->bb, bss_color, phy_idx)
-#else
-#define rtw_hal_set_bss_color(padapter, bss_color, phy_idx)
-#endif
-
-#if defined(CONFIG_RTL8721D)
-#define	rtw_hal_fill_fake_txdesc(padapter, pDesc, BufferLen, IsPsPoll, IsBTQosNull,bDataFrame)
-#define rtw_hal_dm_deinit(padapter)
-#define rtw_hal_dm_cancel_timer(padapter) wifi_hal_phy_dm_timer_cancel(padapter)
-#define rtw_hal_set_mu_edca_param(val, first)
-#define rtw_hal_set_spatial_reuse(padapter, val, enable, first)
-#define rtw_hal_11ax_limitation(padapter)	FALSE
-#define rtw_hal_dm_cmd(padapter, input, output, out_len)
-#define rtw_hal_dbg_no_beacon(padapter, param)
-#define rtw_hal_add_bb_sta(padapter, psta)
-#define rtw_hal_del_bb_sta(padapter, psta)
-#define rtw_hal_set_TXOP_thres(padapter, rts_th, enable)
-#define rtw_hal_set_odm_var(padapter, eVariable, pValue1, bSet) wifi_hal_odmvar_set(padapter, eVariable, pValue1, bSet)
-#define rtw_hal_get_odm_var(padapter, eVariable, pValue1, pValue2) wifi_hal_odmvar_get(padapter, eVariable, pValue1, pValue2)
-#define rtw_hal_phy_statistic_query(padapter, phy_statistic)	wifi_hal_query_phy_statistic(padapter, phy_statistic)
-#define rtw_hal_set_txpwr_done(padapter)
-#endif
-#if defined(CONFIG_RTL8721F)
-#define	rtw_hal_fill_fake_txdesc(padapter, pDesc, BufferLen, IsPsPoll, IsBTQosNull,bDataFrame)
-#define rtw_hal_dm_deinit(padapter)
-#define rtw_hal_dm_cancel_timer(padapter) wifi_hal_phy_dm_timer_cancel(padapter)
-#define rtw_hal_set_mu_edca_param(val, first)
-#define rtw_hal_set_spatial_reuse(padapter, val, enable, first)
-#define rtw_hal_11ax_limitation(padapter)	FALSE
-#define rtw_hal_dm_cmd(padapter, input, output, out_len)
-#define rtw_hal_dbg_no_beacon(padapter, param)
-#define rtw_hal_add_bb_sta(padapter, psta)
-#define rtw_hal_del_bb_sta(padapter, psta)
-#define rtw_hal_set_TXOP_thres(padapter, rts_th, enable)
-#define rtw_hal_set_odm_var(padapter, eVariable, pValue1, bSet) wifi_hal_odmvar_set(padapter, eVariable, pValue1, bSet)
-#define rtw_hal_get_odm_var(padapter, eVariable, pValue1, pValue2) wifi_hal_odmvar_get(padapter, eVariable, pValue1, pValue2)
-#define rtw_hal_phy_statistic_query(padapter, phy_statistic)
-#define rtw_hal_set_txpwr_done(padapter)
-#endif
-#if defined(CONFIG_RTL8720E)
-#define	rtw_hal_fill_fake_txdesc(padapter, pDesc, BufferLen, IsPsPoll, IsBTQosNull,bDataFrame)
-#define rtw_hal_dm_deinit(padapter) wifi_hal_phy_deinit_dm_priv(padapter)
-#define rtw_hal_dm_cancel_timer(padapter)
-#define rtw_hal_set_mu_edca_param(val, first) ROM_WIFI_Set_MUEDCA_Para(val, first)
-#define rtw_hal_set_spatial_reuse(padapter, val, enable, first) ROM_WIFI_Set_Special_Reuse(val, enable, first)
-#define rtw_hal_11ax_limitation(padapter)	wifi_hal_11ax_limitation()
-#define rtw_hal_dm_cmd(padapter, input, output, out_len)	wifi_hal_phy_dm_cmd(padapter, input, output, out_len)
-#define rtw_hal_dbg_no_beacon(padapter, param)	wifi_hal_dbg_no_beacon(param)
-#define rtw_hal_add_bb_sta(padapter, psta)	wifi_hal_bb_sta_add(padapter, psta)
-#define rtw_hal_del_bb_sta(padapter, psta)	wifi_hal_bb_sta_del(padapter, psta)
-#define rtw_hal_set_TXOP_thres(padapter, rts_th, enable)	ROM_WIFI_Set_TXOP_Thres(rts_th, enable)
-#define rtw_hal_set_odm_var(padapter, eVariable, pValue1, bSet)
-#define rtw_hal_get_odm_var(padapter, eVariable, pValue1, pValue2)
-#define rtw_hal_phy_statistic_query(padapter, phy_statistic)
-#endif
-#if defined(CONFIG_RTL8730E)
-#define	rtw_hal_fill_fake_txdesc(padapter, pDesc, BufferLen, IsPsPoll, IsBTQosNull,bDataFrame)
-#define rtw_hal_dm_deinit(padapter) wifi_hal_phy_deinit_dm_priv(padapter)
-#define rtw_hal_dm_cancel_timer(padapter)
-#define rtw_hal_set_mu_edca_param(val, first) ROM_WIFI_Set_MUEDCA_Para(val, first)
-#define rtw_hal_set_spatial_reuse(padapter, val, enable, first) ROM_WIFI_Set_Special_Reuse(val, enable, first)
-#define rtw_hal_11ax_limitation(padapter)	FALSE
-#define rtw_hal_dm_cmd(padapter, input, output, out_len)	wifi_hal_phy_dm_cmd(padapter, input, output, out_len)
-#define rtw_hal_dbg_no_beacon(padapter, param)	wifi_hal_dbg_no_beacon(param)
-#define rtw_hal_add_bb_sta(padapter, psta)	wifi_hal_bb_sta_add(padapter, psta)
-#define rtw_hal_del_bb_sta(padapter, psta)	wifi_hal_bb_sta_del(padapter, psta)
-#define rtw_hal_set_TXOP_thres(padapter, rts_th, enable)	ROM_WIFI_Set_TXOP_Thres(rts_th, enable)
-#define rtw_hal_set_odm_var(padapter, eVariable, pValue1, bSet)
-#define rtw_hal_get_odm_var(padapter, eVariable, pValue1, pValue2)
-#define rtw_hal_phy_statistic_query(padapter, phy_statistic)
-#endif
-#if defined(CONFIG_RTL8735B)
-#define	rtw_hal_fill_fake_txdesc(padapter,pDesc, BufferLen, IsPsPoll, IsBTQosNull,bDataFrame) wifi_hal_fill_fake_txdesc(padapter,pDesc, BufferLen, IsPsPoll, IsBTQosNull,bDataFrame)
-#define rtw_hal_dm_deinit(padapter)
-#define rtw_hal_dm_cancel_timer(padapter) wifi_hal_phy_dm_timer_cancel(padapter)
-#define rtw_hal_set_mu_edca_param(val, first)
-#define rtw_hal_set_spatial_reuse(padapter, val, enable, first)
-#define rtw_hal_11ax_limitation(padapter)	FALSE
-#define rtw_hal_dm_cmd(padapter, input, output, out_len)
-#define rtw_hal_dbg_no_beacon(padapter, param)
-#define rtw_hal_add_bb_sta(padapter, psta)
-#define rtw_hal_del_bb_sta(padapter, psta)
-#define rtw_hal_set_TXOP_thres(padapter, rts_th, enable)
-#define rtw_hal_set_odm_var(padapter, eVariable, pValue1, bSet) wifi_hal_odmvar_set(padapter, eVariable, pValue1, bSet)
-#define rtw_hal_get_odm_var(padapter, eVariable, pValue1, pValue2) wifi_hal_odmvar_get(padapter, eVariable, pValue1, pValue2)
-#define rtw_hal_phy_statistic_query(padapter, phy_statistic)
-#define rtw_hal_set_txpwr_done(padapter)	wifi_hal_set_txpwr_done(padapter)
-#define rtw_hal_mac_c2h_handler(padapter, buf, len)	wifi_hal_c2h_handler(padapter, buf, len)
-#undef rtw_hal_set_msr
-#define rtw_hal_set_msr(padapter, val)	wifi_hal_set_msr(padapter, val)
-#define rtw_hal_update_slottime(updateCap, preamble_mode, slotTime, cur_wireless_mode) wifi_hal_update_slottime(updateCap, preamble_mode, slotTime, cur_wireless_mode)
-
-#endif
-
-#endif //__HAL_INTF_H__
-
diff --git a/os/board/rtl8720e/src/component/wifi/driver/include/hal_pg.h b/os/board/rtl8720e/src/component/wifi/driver/include/hal_pg.h
deleted file mode 100644
index a6afcd42d..000000000
--- a/os/board/rtl8720e/src/component/wifi/driver/include/hal_pg.h
+++ /dev/null
@@ -1,124 +0,0 @@
-/******************************************************************************
- *
- * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of version 2 of the GNU General Public License as
- * published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
- * more details.
- *
- * You should have received a copy of the GNU General Public License along with
- * this program; if not, write to the Free Software Foundation, Inc.,
- * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
- *
- *
- ******************************************************************************/
-
-#ifndef __HAL_PG_H__
-#define __HAL_PG_H__
-
-#include <autoconf.h>
-
-//
-// For VHT series TX power by rate table.
-// VHT TX power by rate off setArray =
-// Band:-2G&5G = 0 / 1
-// RF: at most 4*4 = ABCD=0/1/2/3
-// CCK=0 OFDM=1/2 HT-MCS 0-15=3/4/56 VHT=7/8/9/10/11
-//
-#define PPG_BB_GAIN_2G_TX_OFFSET_MASK	0x0F
-#define PPG_BB_GAIN_2G_TXB_OFFSET_MASK	0xF0
-
-#define PPG_BB_GAIN_5G_TX_OFFSET_MASK	0x1F
-#define PPG_THERMAL_OFFSET_MASK			0x1F
-#define KFREE_BB_GAIN_2G_TX_OFFSET(_ppg_v) (((_ppg_v) == PPG_BB_GAIN_2G_TX_OFFSET_MASK) ? 0 : (((_ppg_v) & 0x01) ? ((_ppg_v) >> 1) : (-((_ppg_v) >> 1))))
-#define KFREE_THERMAL_OFFSET(_ppg_v) (((_ppg_v) == PPG_THERMAL_OFFSET_MASK) ? 0 : (((_ppg_v) & 0x01) ? ((_ppg_v) >> 1) : (-((_ppg_v) >> 1))))
-
-
-
-#if !defined(SUPPORT_5G_CHANNEL)
-#define TX_PWR_BY_RATE_NUM_BAND			1
-#else
-#define TX_PWR_BY_RATE_NUM_BAND			2
-#endif
-
-#if defined(NOT_SUPPORT_RF_MULTIPATH)
-#if !defined(CONFIG_80211AC_VHT)
-#define TX_PWR_BY_RATE_NUM_RF			1
-#define TX_PWR_BY_RATE_NUM_RATE			20 // CCK 1M~11M, OFDM 6M~54M, MCS0~7
-#else
-#define TX_PWR_BY_RATE_NUM_RF			1
-#define TX_PWR_BY_RATE_NUM_RATE			30 // CCK 1M~11M, OFDM 6M~54M, MCS0~7, VHT MCS0~MCS9
-#endif
-#else
-#define TX_PWR_BY_RATE_NUM_RF			4
-#define TX_PWR_BY_RATE_NUM_RATE			84
-#endif
-
-#if defined(NOT_SUPPORT_RF_MULTIPATH)
-#define MAX_RF_PATH					1
-#define MAX_TX_COUNT				1
-#else
-#define MAX_RF_PATH					2	// Max 4 for ss larger than 2
-#define MAX_TX_COUNT				4	//It must always set to 4, otherwise read efuse table secquence will be wrong.
-#endif
-#define	MAX_CHNL_GROUP_24G		6 		// ch1~2, ch3~5, ch6~8,ch9~11,ch12~13,CH 14 total three groups
-#define	MAX_CHNL_GROUP_5G		14
-
-typedef struct _TxPowerInfo24G {
-	u8 IndexCCK_Base[MAX_RF_PATH][MAX_CHNL_GROUP_24G];
-	u8 IndexBW40_Base[MAX_RF_PATH][MAX_CHNL_GROUP_24G];
-	//If only one tx, only BW20 and OFDM are used.
-	s8 OFDM_Diff[MAX_RF_PATH][MAX_TX_COUNT];
-	s8 BW20_Diff[MAX_RF_PATH][MAX_TX_COUNT];
-#if !defined(NOT_SUPPORT_RF_MULTIPATH)
-	s8 CCK_Diff[MAX_RF_PATH][MAX_TX_COUNT];
-	s8 BW40_Diff[MAX_RF_PATH][MAX_TX_COUNT];
-#endif
-} TxPowerInfo24G, *PTxPowerInfo24G;
-
-#ifdef SUPPORT_5G_CHANNEL
-typedef struct _TxPowerInfo5G {
-	u8 IndexBW40_Base[MAX_RF_PATH][MAX_CHNL_GROUP_5G];
-	/* If only one tx, only BW20, OFDM, BW80 and BW160 are used. */
-	s8 OFDM_Diff[MAX_RF_PATH][MAX_TX_COUNT];
-	s8 BW20_Diff[MAX_RF_PATH][MAX_TX_COUNT];
-	s8 BW40_Diff[MAX_RF_PATH][MAX_TX_COUNT];
-	s8 BW80_Diff[MAX_RF_PATH][MAX_TX_COUNT];
-	s8 BW160_Diff[MAX_RF_PATH][MAX_TX_COUNT];
-} TxPowerInfo5G, *PTxPowerInfo5G;
-#endif
-
-typedef	enum _BT_Ant_NUM {
-	Ant_x2	= 0,
-	Ant_x1	= 1
-} BT_Ant_NUM, *PBT_Ant_NUM;
-
-typedef	enum _BT_CoType {
-	BT_2WIRE		= 0,
-	BT_ISSC_3WIRE	= 1,
-	BT_ACCEL		= 2,
-	BT_CSR_BC4		= 3,
-	BT_CSR_BC8		= 4,
-	BT_RTL8756		= 5,
-	BT_RTL8723A		= 6,
-	BT_RTL8821		= 7,
-	BT_RTL8723B		= 8,
-	BT_RTL8192E		= 9,
-	BT_RTL8814A		= 10,
-	BT_RTL8812A		= 11,
-	BT_RTL8703B		= 12,
-	BT_RTL8822B		= 13,
-	BT_RTL8723D		= 14,
-	BT_RTL8821C		= 15,
-	BT_RTL8195A		= 16,
-	BT_RTL8721D     = 17
-} BT_CoType, *PBT_CoType;
-
-#endif
-
-
diff --git a/os/board/rtl8720e/src/component/wifi/driver/include/hal_phy.h b/os/board/rtl8720e/src/component/wifi/driver/include/hal_phy.h
deleted file mode 100644
index a5c002936..000000000
--- a/os/board/rtl8720e/src/component/wifi/driver/include/hal_phy.h
+++ /dev/null
@@ -1,113 +0,0 @@
-/******************************************************************************
- *
- * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of version 2 of the GNU General Public License as
- * published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
- * more details.
- *
- * You should have received a copy of the GNU General Public License along with
- * this program; if not, write to the Free Software Foundation, Inc.,
- * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
- *
- *
- ******************************************************************************/
-#ifndef __HAL_PHY_H__
-#define __HAL_PHY_H__
-
-#define	RF6052_MAX_TX_PWR			0x3F
-#define	RF6052_MAX_REG_88E			0xFF
-#define	RF6052_MAX_REG_92C			0x7F
-
-#define	RF6052_MAX_REG	\
-		(RF6052_MAX_REG_88E > RF6052_MAX_REG_92C) ? RF6052_MAX_REG_88E: RF6052_MAX_REG_92C
-
-#define GET_RF6052_REAL_MAX_REG(_Adapter)	\
-		IS_HARDWARE_TYPE_8188E(_Adapter) ? RF6052_MAX_REG_88E : RF6052_MAX_REG_92C
-
-#define	RF6052_MAX_PATH				2
-
-/*--------------------------Define Parameters-------------------------------*/
-typedef	enum _RF_TYPE {
-	RF_TYPE_MIN = 0, 	// 0
-	RF_8225 = 1,			// 1 11b/g RF for verification only
-	RF_8256 = 2,			// 2 11b/g/n
-	RF_8258 = 3,			// 3 11a/b/g/n RF
-	RF_6052 = 4,			// 4 11b/g/n RF
-	RF_PSEUDO_11N = 5,	// 5, It is a temporality RF.
-	RF_CHIP_MAX
-} RF_TYPE_E, *PRF_TYPE_E;
-
-//move to rtw_sta_info.h
-#if 0
-typedef enum _RF_PATH {
-	RF_PATH_A = 0,
-	RF_PATH_B,
-	RF_PATH_C,
-	RF_PATH_D
-} rf_path, RF_PATH, *PRF_PATH;
-#endif
-
-#define	TX_1S			0
-#define	TX_2S			1
-#define	TX_3S			2
-#define	TX_4S			3
-
-typedef enum _BaseBand_Config_Type {
-	BaseBand_Config_PHY_REG = 0,			//Radio Path A
-	BaseBand_Config_AGC_TAB = 1,			//Radio Path B
-	BaseBand_Config_AGC_TAB_2G = 2,
-	BaseBand_Config_AGC_TAB_5G = 3,
-	BaseBand_Config_PHY_REG_PG
-} BaseBand_Config_Type, *PBaseBand_Config_Type;
-
-typedef enum _WIRELESS_MODE {
-	WIRELESS_MODE_UNKNOWN = 0x00,
-	WIRELESS_MODE_A = 0x01,
-	WIRELESS_MODE_B = 0x02,
-	WIRELESS_MODE_G = 0x04,
-	WIRELESS_MODE_AUTO = 0x08,
-	WIRELESS_MODE_N_24G = 0x10,
-	WIRELESS_MODE_N_5G = 0x20,
-	WIRELESS_MODE_AC_5G = 0x40,
-	WIRELESS_MODE_AC_24G  = 0x80,
-	WIRELESS_MODE_AC_ONLY  = 0x100,
-} WIRELESS_MODE;
-
-typedef struct RF_Shadow_Compare_Map {
-	// Shadow register value
-	u32		Value;
-	// Compare or not flag
-	u8		Compare;
-	// Record If it had ever modified unpredicted
-	u8		ErrorOrNot;
-	// Recorver Flag
-	u8		Recorver;
-	//
-	u8		Driver_Write;
-} RF_SHADOW_T;
-
-typedef struct _R_ANTENNA_SELECT_OFDM {
-	u32 		r_tx_antenna: 4;
-	u32 		r_ant_l: 4;
-	u32 		r_ant_non_ht: 4;
-	u32 		r_ant_ht1: 4;
-	u32 		r_ant_ht2: 4;
-	u32 		r_ant_ht_s1: 4;
-	u32 		r_ant_non_ht_s1: 4;
-	u32 		OFDM_TXSC: 2;
-	u32 		Reserved: 2;
-} R_ANTENNA_SELECT_OFDM;
-
-typedef struct _R_ANTENNA_SELECT_CCK {
-	u8			r_cckrx_enable_2: 2;
-	u8			r_cckrx_enable: 2;
-	u8			r_ccktx_enable: 4;
-} R_ANTENNA_SELECT_CCK;
-
-#endif //__HAL_PHY_H__
diff --git a/os/board/rtl8720e/src/component/wifi/driver/include/hal_phy_reg.h b/os/board/rtl8720e/src/component/wifi/driver/include/hal_phy_reg.h
deleted file mode 100644
index 36c28a8a0..000000000
--- a/os/board/rtl8720e/src/component/wifi/driver/include/hal_phy_reg.h
+++ /dev/null
@@ -1,31 +0,0 @@
-/******************************************************************************
- *
- * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of version 2 of the GNU General Public License as
- * published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
- * more details.
- *
- * You should have received a copy of the GNU General Public License along with
- * this program; if not, write to the Free Software Foundation, Inc.,
- * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
- *
- *
- ******************************************************************************/
-#ifndef __HAL_PHY_REG_H__
-#define __HAL_PHY_REG_H__
-
-//for PutRFRegsetting & GetRFRegSetting BitMask
-//#if (RTL92SE_FPGA_VERIFY == 1)
-//#define 		bRFRegOffsetMask	0xfff
-//#else
-#define 		bRFRegOffsetMask	0xfffff
-//#endif
-
-#endif //__HAL_PHY_REG_H__
-
diff --git a/os/board/rtl8720e/src/component/wifi/driver/include/hal_wowlan_sd1.h b/os/board/rtl8720e/src/component/wifi/driver/include/hal_wowlan_sd1.h
deleted file mode 100644
index d2abbdfc5..000000000
--- a/os/board/rtl8720e/src/component/wifi/driver/include/hal_wowlan_sd1.h
+++ /dev/null
@@ -1,134 +0,0 @@
-#ifndef __HAL_WOWLAN_SD1_H__
-#define __HAL_WOWLAN_SD1_H__
-
-#include "HalVerDef.h"
-#include "hal_pg.h"
-#include "hal_intf.h"
-#include "hal_phy.h"
-#include "hal_phy_reg.h"
-#if  defined(CONFIG_RTL8730A) || defined(CONFIG_RTL8730E)
-#include "wififw_reg_rom.h"
-#elif defined(CONFIG_RTL8720E)  || defined(CONFIG_RTL8721F)
-#include "wififw_reg_ram.h"
-#else
-#include "hal_com_reg.h"
-#endif
-#include "hal_com_phycfg.h"
-#ifdef RTW_HALMAC
-#include "hal_com_c2h.h"
-#endif
-
-#include "hal_com_c2h.h"
-
-
-#ifdef CONFIG_WOWLAN_SD1
-typedef struct rtl_wow_pattern {
-	u16	crc;
-	u8	type;
-	u32	mask[4];
-} rtl_wow_pattern_t;
-
-typedef enum _wowlan_subcode {
-	WOWLAN_PATTERN_MATCH	= 1,
-	WOWLAN_MAGIC_PACKET		= 2,
-	WOWLAN_UNICAST			= 3,
-	WOWLAN_SET_PATTERN		= 4,
-	WOWLAN_DUMP_REG			= 5,
-	WOWLAN_ENABLE			= 6,
-	WOWLAN_DISABLE			= 7,
-	WOWLAN_STATUS			= 8,
-	WOWLAN_DEBUG_RELOAD_FW	= 9,
-	WOWLAN_DEBUG_1			= 10,
-	WOWLAN_DEBUG_2			= 11
-} wowlan_subcode;
-
-struct wowlan_ioctl_param {
-	unsigned int subcode;
-	unsigned int subcode_value;
-	unsigned int wakeup_reason;
-	unsigned int len;
-	wowlan_pattern_t pattern;
-};
-
-#define REMOTE_INFO_CTRL_SET_VALD_EN(target, _value) \
-	SET_BITS_TO_LE_4BYTE(target + 0, 0, 8, _value)
-#define REMOTE_INFO_CTRL_SET_PTK_EN(target, _value) \
-	SET_BITS_TO_LE_4BYTE(target + 1, 0, 1, _value)
-#define REMOTE_INFO_CTRL_SET_GTK_EN(target, _value) \
-	SET_BITS_TO_LE_4BYTE(target + 1, 1, 1, _value)
-#define REMOTE_INFO_CTRL_SET_GTK_IDX(target, _value) \
-	SET_BITS_TO_LE_4BYTE(target + 2, 0, 8, _value)
-
-int rtw_hal_wow_set_pattern(_adapter *adapter, wowlan_pattern_t pattern);
-void rtw_hal_wow_enable(_adapter *adapter);
-void rtw_hal_wow_disable(_adapter *adapter);
-
-#endif
-void rtw_hal_set_fw_rsvd_page(_adapter *adapter, bool finished);
-
-#ifdef CONFIG_LPS_PG
-
-#define H2C_LPS_PG_INFO_LEN		2
-#define H2C_LPSPG_LEN			16
-
-#define SET_H2CCMD_LPSPG_SEC_CAM_EN(__pH2CCmd, __Value)	SET_BITS_TO_LE_1BYTE(__pH2CCmd, 0, 1, __Value)/*SecurityCAM_En*/
-#define SET_H2CCMD_LPSPG_MBID_CAM_EN(__pH2CCmd, __Value)	SET_BITS_TO_LE_1BYTE(__pH2CCmd, 1, 1, __Value)/*BSSIDCAM_En*/
-#define SET_H2CCMD_LPSPG_PMC_CAM_EN(__pH2CCmd, __Value)	SET_BITS_TO_LE_1BYTE(__pH2CCmd, 2, 1, __Value)/*PatternMatchCAM_En*/
-#define SET_H2CCMD_LPSPG_MACID_SEARCH_EN(__pH2CCmd, __Value)	SET_BITS_TO_LE_1BYTE(__pH2CCmd, 3, 1, __Value)/*MACIDSearch_En*/
-#define SET_H2CCMD_LPSPG_TXSC_EN(__pH2CCmd, __Value)	SET_BITS_TO_LE_1BYTE(__pH2CCmd, 4, 1, __Value)/*TXSC_En*/
-#define SET_H2CCMD_LPSPG_MU_RATE_TB_EN(__pH2CCmd, __Value)	SET_BITS_TO_LE_1BYTE(__pH2CCmd, 5, 1, __Value)/*MURateTable_En*/
-#define SET_H2CCMD_LPSPG_LOC(__pH2CCmd, __Value)	SET_BITS_TO_LE_1BYTE(__pH2CCmd+1, 0, 8, __Value)/*Loc_LPS_PG*/
-
-#define LPSPG_RSVD_PAGE_SET_MACID(_rsvd_pag, _value)		SET_BITS_TO_LE_4BYTE(_rsvd_pag+0x00, 0, 8, _value)/*used macid*/
-#define LPSPG_RSVD_PAGE_SET_MBSSCAMID(_rsvd_pag, _value)	SET_BITS_TO_LE_4BYTE(_rsvd_pag+0x00, 8, 8, _value)/*used BSSID CAM entry*/
-#define LPSPG_RSVD_PAGE_SET_PMC_NUM(_rsvd_pag, _value)		SET_BITS_TO_LE_4BYTE(_rsvd_pag+0x00, 16, 8, _value)/*Max used Pattern Match CAM entry*/
-#define LPSPG_RSVD_PAGE_SET_MU_RAID_GID(_rsvd_pag, _value)	SET_BITS_TO_LE_4BYTE(_rsvd_pag+0x00, 24, 8, _value)/*Max MU rate table Group ID*/
-#define LPSPG_RSVD_PAGE_SET_SEC_CAM_NUM(_rsvd_pag, _value)	SET_BITS_TO_LE_4BYTE(_rsvd_pag+0x04, 0, 8, _value)/*used Security CAM entry number*/
-#define LPSPG_RSVD_PAGE_SET_DRV_RSVDPAGE_NUM(_rsvd_pag, _value)	SET_BITS_TO_LE_4BYTE(_rsvd_pag+0x04, 8, 8, _value)/*Txbuf used page number for fw offload*/
-#define LPSPG_RSVD_PAGE_SET_SEC_CAM_ID1(_rsvd_pag, _value)	SET_BITS_TO_LE_4BYTE(_rsvd_pag+0x08, 0, 8, _value)/*used Security CAM entry -1*/
-#define LPSPG_RSVD_PAGE_SET_SEC_CAM_ID2(_rsvd_pag, _value)	SET_BITS_TO_LE_4BYTE(_rsvd_pag+0x08, 8, 8, _value)/*used Security CAM entry -2*/
-#define LPSPG_RSVD_PAGE_SET_SEC_CAM_ID3(_rsvd_pag, _value)	SET_BITS_TO_LE_4BYTE(_rsvd_pag+0x08, 16, 8, _value)/*used Security CAM entry -3*/
-#define LPSPG_RSVD_PAGE_SET_SEC_CAM_ID4(_rsvd_pag, _value)	SET_BITS_TO_LE_4BYTE(_rsvd_pag+0x08, 24, 8, _value)/*used Security CAM entry -4*/
-#define LPSPG_RSVD_PAGE_SET_SEC_CAM_ID5(_rsvd_pag, _value)	SET_BITS_TO_LE_4BYTE(_rsvd_pag+0x0C, 0, 8, _value)/*used Security CAM entry -5*/
-#define LPSPG_RSVD_PAGE_SET_SEC_CAM_ID6(_rsvd_pag, _value)	SET_BITS_TO_LE_4BYTE(_rsvd_pag+0x0C, 8, 8, _value)/*used Security CAM entry -6*/
-#define LPSPG_RSVD_PAGE_SET_SEC_CAM_ID7(_rsvd_pag, _value)	SET_BITS_TO_LE_4BYTE(_rsvd_pag+0x0C, 16, 8, _value)/*used Security CAM entry -7*/
-#define LPSPG_RSVD_PAGE_SET_SEC_CAM_ID8(_rsvd_pag, _value)	SET_BITS_TO_LE_4BYTE(_rsvd_pag+0x0C, 24, 8, _value)/*used Security CAM entry -8*/
-enum lps_pg_hdl_id {
-	LPS_PG_INFO_CFG = 0,
-	LPS_PG_REDLEMEM,
-	LPS_PG_PHYDM_DIS,
-	LPS_PG_PHYDM_EN,
-};
-
-u8 rtw_hal_set_lps_pg_info(_adapter *adapter);
-
-#endif
-
-#ifdef CONFIG_WOWLAN_SSL_KEEP_ALIVE
-#define SET_H2CCMD_MQTT_SSL_EN(__pH2CCmd, __Value)	SET_BITS_TO_LE_1BYTE(__pH2CCmd, 0, 1, __Value)/*SSL EN*/
-#define SET_H2CCMD_MQTT_PATTERN_MATCH_EN(__pH2CCmd, __Value)	SET_BITS_TO_LE_1BYTE(__pH2CCmd, 1, 1, __Value)/*PATTERN_MATCH_EN EN*/
-#define SET_H2CCMD_MQTT_PUBLISH_WAKE(__pH2CCmd, __Value) SET_BITS_TO_LE_1BYTE(__pH2CCmd, 2, 1, __Value)/*PUBLISH_WAKE EN*/
-#define SET_H2CCMD_TCP_SSL_MODE(__pH2CCmd, __Value) SET_BITS_TO_LE_1BYTE(__pH2CCmd, 3, 1, __Value)/*Header ignore*/
-#define SET_H2CCMD_SSL_INFO_LOC(__pH2CCmd, __Value)	SET_BITS_TO_LE_1BYTE(__pH2CCmd+1, 0, 8, __Value)/*SSL_INFO_LOC*/
-#define SET_H2CCMD_SSL_PATTERN_LOC(__pH2CCmd, __Value)	SET_BITS_TO_LE_1BYTE(__pH2CCmd+2, 0, 8, __Value)/*SSL_PATTERN_LOC*/
-#define SET_H2CCMD_TCP_PARM_SERVERTO_EN(__pH2CCmd, __Value) SET_BITS_TO_LE_1BYTE(__pH2CCmd, 4, 1, __Value)
-#define SET_H2CCMD_TCP_PARM_SERVER_TIMEOUT_L(__pH2CCmd, __Value) SET_BITS_TO_LE_1BYTE(__pH2CCmd+3, 0, 8, __Value)
-#define SET_H2CCMD_TCP_PARM_SERVER_TIMEOUT_H(__pH2CCmd, __Value) SET_BITS_TO_LE_1BYTE(__pH2CCmd+4, 0, 8, __Value)
-#endif
-
-#if defined(CONFIG_WOWLAN) || defined(CONFIG_AP_WOWLAN)
-/* ARP element */
-#define SET_ARP_PKT_HW(__pHeader, __Value)					WriteEF2Byte(((u8 *)(__pHeader)) + 0, __Value)
-#define SET_ARP_PKT_PROTOCOL(__pHeader, __Value)			WriteEF2Byte(((u8 *)(__pHeader)) + 2, __Value)
-#define SET_ARP_PKT_HW_ADDR_LEN(__pHeader, __Value)			WriteEF1Byte(((u8 *)(__pHeader)) + 4, __Value)
-#define SET_ARP_PKT_PROTOCOL_ADDR_LEN(__pHeader, __Value)	WriteEF1Byte(((u8 *)(__pHeader)) + 5, __Value)
-#define SET_ARP_PKT_OPERATION(__pHeader, __Value)			WriteEF2Byte(((u8 *)(__pHeader)) + 6, __Value)
-#define SET_ARP_PKT_SENDER_MAC_ADDR(__pHeader, _val)	cp_mac_addr(((u8 *)(__pHeader))+8, (u8 *)(_val))
-#define SET_ARP_PKT_SENDER_IP_ADDR(__pHeader, _val)		cpIpAddr(((u8 *)(__pHeader))+14, (u8 *)(_val))
-#define SET_ARP_PKT_TARGET_MAC_ADDR(__pHeader, _val)	cp_mac_addr(((u8 *)(__pHeader))+18, (u8 *)(_val))
-#define SET_ARP_PKT_TARGET_IP_ADDR(__pHeader, _val)		cpIpAddr(((u8 *)(__pHeader))+24, (u8 *)(_val))
-
-#endif /* CONFIG_WOWLAN */
-
-
-#endif //__HAL_WOWLAN_SD1_H__
diff --git a/os/board/rtl8720e/src/component/wifi/driver/include/ieee80211.h b/os/board/rtl8720e/src/component/wifi/driver/include/ieee80211.h
deleted file mode 100644
index 9cc2c2405..000000000
--- a/os/board/rtl8720e/src/component/wifi/driver/include/ieee80211.h
+++ /dev/null
@@ -1,1238 +0,0 @@
-/******************************************************************************
- *
- * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of version 2 of the GNU General Public License as
- * published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
- * more details.
- *
- * You should have received a copy of the GNU General Public License along with
- * this program; if not, write to the Free Software Foundation, Inc.,
- * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
- *
- *
- ******************************************************************************/
-#ifndef __IEEE80211_H
-#define __IEEE80211_H
-
-#ifndef CONFIG_RTL8711FW
-#else
-
-#include <list.h>
-
-#endif
-
-#define MGMT_QUEUE_NUM 5
-
-#define ETH_ALEN	6
-#define ETH_TYPE_LEN		2
-#define PAYLOAD_TYPE_LEN	1
-
-/* STA flags */
-#define WLAN_STA_AUTH BIT(0)
-#define WLAN_STA_ASSOC BIT(1)
-#define WLAN_STA_PS BIT(2)
-#define WLAN_STA_TIM BIT(3)
-#define WLAN_STA_PERM BIT(4)
-#define WLAN_STA_AUTHORIZED BIT(5)
-#define WLAN_STA_PENDING_POLL BIT(6) /* pending activity poll not ACKed */
-#define WLAN_STA_SHORT_PREAMBLE BIT(7)
-#define WLAN_STA_PREAUTH BIT(8)
-#define WLAN_STA_WME BIT(9)
-#define WLAN_STA_MFP BIT(10)
-#define WLAN_STA_HT BIT(11)
-#define WLAN_STA_WPS BIT(12)
-#define WLAN_STA_MAYBE_WPS BIT(13)
-#define WLAN_STA_NONERP BIT(31)
-
-#define IEEE_CMD_SET_WPA_PARAM			1
-#define IEEE_CMD_SET_WPA_IE				2
-#define IEEE_CMD_SET_ENCRYPTION			3
-#define IEEE_CMD_MLME						4
-
-#define IEEE_PARAM_WPA_ENABLED				1
-#define IEEE_PARAM_TKIP_COUNTERMEASURES		2
-#define IEEE_PARAM_DROP_UNENCRYPTED			3
-#define IEEE_PARAM_PRIVACY_INVOKED			4
-#define IEEE_PARAM_AUTH_ALGS					5
-#define IEEE_PARAM_IEEE_802_1X				6
-#define IEEE_PARAM_WPAX_SELECT				7
-
-#define AUTH_ALG_OPEN_SYSTEM			0x1
-#define AUTH_ALG_SHARED_KEY			0x2
-#define AUTH_ALG_SAE					0x8
-#define AUTH_ALG_LEAP				0x00000004
-
-#define IEEE_MLME_STA_DEAUTH				1
-#define IEEE_MLME_STA_DISASSOC			2
-
-#define IEEE_CRYPT_ERR_UNKNOWN_ALG			2
-#define IEEE_CRYPT_ERR_UNKNOWN_ADDR			3
-#define IEEE_CRYPT_ERR_CRYPT_INIT_FAILED		4
-#define IEEE_CRYPT_ERR_KEY_SET_FAILED			5
-#define IEEE_CRYPT_ERR_TX_KEY_SET_FAILED		6
-#define IEEE_CRYPT_ERR_CARD_CONF_FAILED		7
-
-
-#define	IEEE_CRYPT_ALG_NAME_LEN			16
-
-#define WPA_CIPHER_NONE 			BIT(0)
-#define WPA_CIPHER_WEP40 			BIT(1)
-#define WPA_CIPHER_WEP104 		BIT(2)
-#define WPA_CIPHER_TKIP 			BIT(3)
-#define WPA_CIPHER_CCMP 			BIT(4)
-#define WPA_CIPHER_AES_128_CMAC 	BIT(5)
-#define WPA_CIPHER_GCMP 			BIT(6)
-#define WPA_CIPHER_SMS4 			BIT(7)
-#define WPA_CIPHER_GCMP_256 		BIT(8)
-#define WPA_CIPHER_CCMP_256 		BIT(9)
-#define WPA_CIPHER_BIP_GMAC_128 	BIT(11)
-#define WPA_CIPHER_BIP_GMAC_256 	BIT(12)
-#define WPA_CIPHER_BIP_CMAC_256 	BIT(13)
-#define WPA_CIPHER_GTK_NOT_USED 	BIT(14)
-
-
-#define WPA_SELECTOR_LEN 4
-//extern u16 RTW_WPA_VERSION ;
-//extern u8 WPA_AUTH_KEY_MGMT_NONE[];
-//extern u8 WPA_AUTH_KEY_MGMT_UNSPEC_802_1X[];
-//extern u8 WPA_AUTH_KEY_MGMT_PSK_OVER_802_1X[];
-//extern u8 WPA_CIPHER_SUITE_WRAP[];
-
-#define WPA_KEY_MGMT_IEEE8021X BIT(0)
-#define WPA_KEY_MGMT_PSK BIT(1)
-#define WPA_KEY_MGMT_NONE BIT(2)
-#define WPA_KEY_MGMT_IEEE8021X_NO_WPA BIT(3)
-#define WPA_KEY_MGMT_WPA_NONE BIT(4)
-#define WPA_KEY_MGMT_FT_IEEE8021X BIT(5)
-#define WPA_KEY_MGMT_FT_PSK BIT(6)
-#define WPA_KEY_MGMT_IEEE8021X_SHA256 BIT(7)
-#define WPA_KEY_MGMT_PSK_SHA256 BIT(8)
-#define WPA_KEY_MGMT_WPS BIT(9)
-#define WPA_KEY_MGMT_SAE BIT(10)
-#define WPA_KEY_MGMT_FT_SAE BIT(11)
-#define WPA_KEY_MGMT_WAPI_PSK BIT(12)
-#define WPA_KEY_MGMT_WAPI_CERT BIT(13)
-#define WPA_KEY_MGMT_CCKM BIT(14)
-#define WPA_KEY_MGMT_OSEN BIT(15)
-#define WPA_KEY_MGMT_IEEE8021X_SUITE_B BIT(16)
-#define WPA_KEY_MGMT_IEEE8021X_SUITE_B_192 BIT(17)
-#define WPA_KEY_MGMT_FILS_SHA256 BIT(18)
-#define WPA_KEY_MGMT_FILS_SHA384 BIT(19)
-#define WPA_KEY_MGMT_FT_FILS_SHA256 BIT(20)
-#define WPA_KEY_MGMT_FT_FILS_SHA384 BIT(21)
-#define WPA_KEY_MGMT_OWE BIT(22)
-#define WPA_KEY_MGMT_DPP BIT(23)
-
-#define RSN_HEADER_LEN 4
-#define RSN_SELECTOR_LEN 4
-#define RSNXE_MIN_LEN 3
-
-//tern u8 RSN_CIPHER_SUITE_WRAP[];
-
-typedef enum _RATEID_IDX_ {
-	RATEID_IDX_BGN_40M_2SS = 0,
-	RATEID_IDX_BGN_40M_1SS = 1,
-	RATEID_IDX_BGN_20M_2SS_BN = 2,
-	RATEID_IDX_BGN_20M_1SS_BN = 3,
-	RATEID_IDX_GN_N2SS = 4,
-	RATEID_IDX_GN_N1SS = 5,
-	RATEID_IDX_BG = 6,
-	RATEID_IDX_G = 7,
-	RATEID_IDX_B = 8,
-	RATEID_IDX_VHT_2SS = 9,
-	RATEID_IDX_VHT_1SS = 10,
-} RATEID_IDX, *PRATEID_IDX;
-
-#define IsSupported24G(band_type) ((band_type) & BAND_CAP_2G? _TRUE : _FALSE)
-#define IsSupported5G(band_type) ((band_type) & BAND_CAP_5G ?  _TRUE : _FALSE)
-
-#define IsLegacyOnly(NetType)  ((NetType) == ((NetType) & (WLAN_MD_11BG | WLAN_MD_11A)))
-
-#define IsSupportedTxCCK(NetType) ((NetType) & (WLAN_MD_11B) ? _TRUE : _FALSE)
-#define IsSupportedTxOFDM(NetType) ((NetType) & (WLAN_MD_11G | WLAN_MD_11A) ? _TRUE : _FALSE)
-
-#define is_supported_ht(NetType) ((NetType) & (WLAN_MD_11N) ? _TRUE : _FALSE)
-#define is_supported_vht(NetType) ((NetType) & (WLAN_MD_11AC) ? _TRUE : _FALSE)
-#define is_supported_he(NetType) ((NetType) & (WLAN_MD_11AX) ? _TRUE : _FALSE)
-
-typedef struct ieee_param {
-	u32 cmd;
-	u8 sta_addr[ETH_ALEN];
-	union {
-		struct {
-			u8 name;
-			u32 value;
-		} wpa_param;
-		struct {
-			u32 len;
-			u8 reserved[32];
-#ifdef __CC_ARM
-			u8 data[1];
-#else
-			u8 data[0];
-#endif
-		} wpa_ie;
-		struct {
-			int command;
-			int reason_code;
-		} mlme;
-		struct {
-			u8 alg[IEEE_CRYPT_ALG_NAME_LEN];
-			u8 set_tx;
-			u32 err;
-			u8 idx;
-			u8 seq[8]; /* sequence counter (set: RX, get: TX) */
-			u16 key_len;
-#ifdef __CC_ARM
-			u8 key[1];
-#else
-			u8 key[0];
-#endif
-		} crypt;
-
-		struct {
-			u16 aid;
-			u16 capability;
-			int flags;
-			u8 tx_supp_rates[16];
-			struct rtw_ieee80211_ht_cap ht_cap;
-		} add_sta;
-		struct {
-			u8	reserved[2];//for set max_num_sta
-#ifdef __CC_ARM
-			u8	buf[1];
-#else
-			u8	buf[0];
-#endif
-		} bcn_ie;
-
-	} u;
-} ieee_param;
-
-#ifdef RTW_PACK_STRUCT_USE_INCLUDES
-#  include "pack_begin.h"
-#endif
-RTW_PACK_STRUCT_BEGIN
-struct rtw_ieee80211_hdr {
-	u16 frame_ctl;
-	u16 duration_id;
-	u8 addr1[ETH_ALEN];
-	u8 addr2[ETH_ALEN];
-	u8 addr3[ETH_ALEN];
-	u16 seq_ctl;
-	u8 addr4[ETH_ALEN];
-} RTW_PACK_STRUCT_STRUCT;
-RTW_PACK_STRUCT_END
-#ifdef RTW_PACK_STRUCT_USE_INCLUDES
-#  include "pack_end.h"
-#endif
-
-#ifdef RTW_PACK_STRUCT_USE_INCLUDES
-#  include "pack_begin.h"
-#endif
-RTW_PACK_STRUCT_BEGIN
-struct rtw_ieee80211_hdr_3addr {
-	u16 frame_ctl;
-	u16 duration_id;
-	u8 addr1[ETH_ALEN];
-	u8 addr2[ETH_ALEN];
-	u8 addr3[ETH_ALEN];
-	u16 seq_ctl;
-} RTW_PACK_STRUCT_STRUCT;
-RTW_PACK_STRUCT_END
-#ifdef RTW_PACK_STRUCT_USE_INCLUDES
-#  include "pack_end.h"
-#endif
-
-#ifdef RTW_PACK_STRUCT_USE_INCLUDES
-#  include "pack_begin.h"
-#endif
-RTW_PACK_STRUCT_BEGIN
-struct rtw_ieee80211_hdr_qos {
-	u16 frame_ctl;
-	u16 duration_id;
-	u8 addr1[ETH_ALEN];
-	u8 addr2[ETH_ALEN];
-	u8 addr3[ETH_ALEN];
-	u16 seq_ctl;
-	u8 addr4[ETH_ALEN];
-	u16	qc;
-}  RTW_PACK_STRUCT_STRUCT;
-RTW_PACK_STRUCT_END
-#ifdef RTW_PACK_STRUCT_USE_INCLUDES
-#  include "pack_end.h"
-#endif
-
-#ifdef RTW_PACK_STRUCT_USE_INCLUDES
-#  include "pack_begin.h"
-#endif
-RTW_PACK_STRUCT_BEGIN
-struct rtw_ieee80211_hdr_3addr_qos {
-	u16 frame_ctl;
-	u16 duration_id;
-	u8 addr1[ETH_ALEN];
-	u8 addr2[ETH_ALEN];
-	u8 addr3[ETH_ALEN];
-	u16 seq_ctl;
-	u16     qc;
-}  RTW_PACK_STRUCT_STRUCT;
-RTW_PACK_STRUCT_END
-#ifdef RTW_PACK_STRUCT_USE_INCLUDES
-#  include "pack_end.h"
-#endif
-
-#ifdef RTW_PACK_STRUCT_USE_INCLUDES
-#  include "pack_begin.h"
-#endif
-RTW_PACK_STRUCT_BEGIN
-struct eapol {
-	u8 snap[6];
-	u16 ethertype;
-	u8 version;
-	u8 type;
-	u16 length;
-} RTW_PACK_STRUCT_STRUCT;
-RTW_PACK_STRUCT_END
-#ifdef RTW_PACK_STRUCT_USE_INCLUDES
-#  include "pack_end.h"
-#endif
-
-#define IEEE80211_3ADDR_LEN 24
-#define IEEE80211_4ADDR_LEN 30
-#define IEEE80211_FCS_LEN    4
-
-#define MIN_FRAG_THRESHOLD     256U
-#define	MAX_FRAG_THRESHOLD     2346U
-
-/* Frame control field constants */
-#define RTW_IEEE80211_FCTL_VERS		0x0002
-#define RTW_IEEE80211_FCTL_FTYPE		0x000c
-#define RTW_IEEE80211_FCTL_STYPE		0x00f0
-#define RTW_IEEE80211_FCTL_TODS		0x0100
-#define RTW_IEEE80211_FCTL_FROMDS		0x0200
-#define RTW_IEEE80211_FCTL_MOREFRAGS	0x0400
-#define RTW_IEEE80211_FCTL_RETRY		0x0800
-#define RTW_IEEE80211_FCTL_PM		0x1000
-#define RTW_IEEE80211_FCTL_MOREDATA	0x2000
-#define RTW_IEEE80211_FCTL_WEP		0x4000
-#define RTW_IEEE80211_FCTL_ORDER		0x8000
-
-#define RTW_IEEE80211_FTYPE_MGMT		0x0000
-#define RTW_IEEE80211_FTYPE_CTL		0x0004
-#define RTW_IEEE80211_FTYPE_DATA		0x0008
-
-/* management */
-#define RTW_IEEE80211_STYPE_ASSOC_REQ	0x0000
-#define RTW_IEEE80211_STYPE_ASSOC_RESP 	0x0010
-#define RTW_IEEE80211_STYPE_REASSOC_REQ	0x0020
-#define RTW_IEEE80211_STYPE_REASSOC_RESP	0x0030
-#define RTW_IEEE80211_STYPE_PROBE_REQ	0x0040
-#define RTW_IEEE80211_STYPE_PROBE_RESP	0x0050
-#define RTW_IEEE80211_STYPE_BEACON		0x0080
-#define RTW_IEEE80211_STYPE_ATIM		0x0090
-#define RTW_IEEE80211_STYPE_DISASSOC	0x00A0
-#define RTW_IEEE80211_STYPE_AUTH		0x00B0
-#define RTW_IEEE80211_STYPE_DEAUTH		0x00C0
-#define RTW_IEEE80211_STYPE_ACTION		0x00D0
-
-/* control */
-#define RTW_IEEE80211_STYPE_PSPOLL		0x00A0
-#define RTW_IEEE80211_STYPE_RTS		0x00B0
-#define RTW_IEEE80211_STYPE_CTS		0x00C0
-#define RTW_IEEE80211_STYPE_ACK		0x00D0
-#define RTW_IEEE80211_STYPE_CFEND		0x00E0
-#define RTW_IEEE80211_STYPE_CFENDACK	0x00F0
-
-/* data */
-#define RTW_IEEE80211_STYPE_DATA		0x0000
-#define RTW_IEEE80211_STYPE_DATA_CFACK	0x0010
-#define RTW_IEEE80211_STYPE_DATA_CFPOLL	0x0020
-#define RTW_IEEE80211_STYPE_DATA_CFACKPOLL	0x0030
-#define RTW_IEEE80211_STYPE_NULLFUNC	0x0040
-#define RTW_IEEE80211_STYPE_CFACK		0x0050
-#define RTW_IEEE80211_STYPE_CFPOLL		0x0060
-#define RTW_IEEE80211_STYPE_CFACKPOLL	0x0070
-#define RTW_IEEE80211_QOS_DATAGRP		0x0080
-#define RTW_IEEE80211_QoS_DATAGRP		RTW_IEEE80211_QOS_DATAGRP
-/* Mesh Control 802.11s */
-#define RTW_IEEE80211_QOS_CTL_MESH_CONTROL_PRESENT  BIT(8)
-/* Mesh flags */
-#define MESH_FLAGS_AE_A4 	0x1
-#define MESH_FLAGS_AE_A5_A6	0x2
-#define MESH_FLAGS_AE		0x3
-#define MESH_FLAGS_PS_DEEP	0x4
-
-#define RTW_IEEE80211_SCTL_FRAG		0x000F
-#define RTW_IEEE80211_SCTL_SEQ		0xFFF0
-
-
-#define RTW_ERP_INFO_NON_ERP_PRESENT BIT(0)
-#define RTW_ERP_INFO_USE_PROTECTION BIT(1)
-#define RTW_ERP_INFO_BARKER_PREAMBLE_MODE BIT(2)
-
-/* QoS,QOS */
-#define NORMAL_ACK			0
-#define NO_ACK				1
-#define NON_EXPLICIT_ACK	2
-#define BLOCK_ACK			3
-
-#ifndef ETH_P_PAE
-#define ETH_P_PAE 0x888E /* Port Access Entity (IEEE 802.1X) */
-#endif /* ETH_P_PAE */
-
-#define ETH_P_PREAUTH 0x88C7 /* IEEE 802.11i pre-authentication */
-
-#define ETH_P_ECONET	0x0018
-
-#ifndef ETH_P_80211_RAW
-#define ETH_P_80211_RAW (ETH_P_ECONET + 1)
-#endif
-
-/* IEEE 802.11 defines */
-
-#define P80211_OUI_LEN 3
-
-RTW_PACK_STRUCT_BEGIN
-struct ieee80211_snap_hdr {
-
-	u8    dsap;   /* always 0xAA */
-	u8    ssap;   /* always 0xAA */
-	u8    ctrl;   /* always 0x03 */
-	u8    oui[P80211_OUI_LEN];    /* organizational universal id */
-
-} RTW_PACK_STRUCT_STRUCT;
-RTW_PACK_STRUCT_END
-
-#define SNAP_SIZE sizeof(struct ieee80211_snap_hdr)
-
-#define WLAN_FC_GET_TYPE(fc) ((fc) & RTW_IEEE80211_FCTL_FTYPE)
-#define WLAN_FC_GET_STYPE(fc) ((fc) & RTW_IEEE80211_FCTL_STYPE)
-
-#define WLAN_QC_GET_TID(qc) ((qc) & 0x0f)
-
-#define WLAN_GET_SEQ_FRAG(seq) ((seq) & RTW_IEEE80211_SCTL_FRAG)
-#define WLAN_GET_SEQ_SEQ(seq)  ((seq) & RTW_IEEE80211_SCTL_SEQ)
-
-
-
-/* Authentication algorithms */
-#define WLAN_AUTH_OPEN 0
-#define WLAN_AUTH_SHARED_KEY 1
-
-#define WLAN_AUTH_CHALLENGE_LEN 128
-
-#define WLAN_CAPABILITY_BSS (1<<0)
-#define WLAN_CAPABILITY_IBSS (1<<1)
-#define WLAN_CAPABILITY_CF_POLLABLE (1<<2)
-#define WLAN_CAPABILITY_CF_POLL_REQUEST (1<<3)
-#define WLAN_CAPABILITY_PRIVACY (1<<4)
-#define WLAN_CAPABILITY_SHORT_PREAMBLE (1<<5)
-#define WLAN_CAPABILITY_PBCC (1<<6)
-#define WLAN_CAPABILITY_CHANNEL_AGILITY (1<<7)
-#define WLAN_CAPABILITY_SHORT_SLOT (1<<10)
-
-/* Status codes */
-#define WLAN_STATUS_SUCCESS 0
-#define WLAN_STATUS_UNSPECIFIED_FAILURE 1
-#define WLAN_STATUS_CAPS_UNSUPPORTED 10
-#define WLAN_STATUS_REASSOC_NO_ASSOC 11
-#define WLAN_STATUS_ASSOC_DENIED_UNSPEC 12
-#define WLAN_STATUS_NOT_SUPPORTED_AUTH_ALG 13
-#define WLAN_STATUS_UNKNOWN_AUTH_TRANSACTION 14
-#define WLAN_STATUS_CHALLENGE_FAIL 15
-#define WLAN_STATUS_AUTH_TIMEOUT 16
-#define WLAN_STATUS_AP_UNABLE_TO_HANDLE_NEW_STA 17
-#define WLAN_STATUS_ASSOC_DENIED_RATES 18
-/* 802.11b */
-#define WLAN_STATUS_ASSOC_DENIED_NOSHORT 19
-#define WLAN_STATUS_ASSOC_DENIED_NOPBCC 20
-#define WLAN_STATUS_ASSOC_DENIED_NOAGILITY 21
-
-/* WPA3-SAE*/
-#define WLAN_STATUS_ANTI_CLOGGING_TOKEN_REQ 		76
-#define WLAN_STATUS_UNSUPPORTED_FCC_GROUP   		77
-#define WLAN_STATUS_UNKNOWN_PASSWORD_IDENTIFIER		123
-
-/* Reason codes */
-#define WLAN_REASON_UNSPECIFIED 1
-#define WLAN_REASON_PREV_AUTH_NOT_VALID 2
-#define WLAN_REASON_DEAUTH_LEAVING 3
-#define WLAN_REASON_DISASSOC_DUE_TO_INACTIVITY 4
-#define WLAN_REASON_DISASSOC_AP_BUSY 5
-#define WLAN_REASON_CLASS2_FRAME_FROM_NONAUTH_STA 6
-#define WLAN_REASON_CLASS3_FRAME_FROM_NONASSOC_STA 7
-#define WLAN_REASON_DISASSOC_STA_HAS_LEFT 8
-#define WLAN_REASON_STA_REQ_ASSOC_WITHOUT_AUTH 9
-#define	WLAN_REASON_MIC_FAILURE 14
-#define WLAN_REASON_4WAY_HANDSHAKE_TIMEOUT 15
-#define WLAN_REASON_ACTIVE_ROAM 65533
-#define WLAN_REASON_JOIN_WRONG_CHANNEL       65534
-#define WLAN_REASON_EXPIRATION_CHK 65535
-
-/* 802.11s */
-#define WLAN_REASON_MESH_PEER_CANCELED 52
-#define WLAN_REASON_MESH_MAX_PEERS 53
-#define WLAN_REASON_MESH_CONFIG 54
-#define WLAN_REASON_MESH_CLOSE 55
-#define WLAN_REASON_MESH_MAX_RETRIES 56
-#define WLAN_REASON_MESH_CONFIRM_TIMEOUT 57
-#define WLAN_REASON_MESH_INVALID_GTK 58
-#define WLAN_REASON_MESH_INCONSISTENT_PARAM 59
-#define WLAN_REASON_MESH_INVALID_SECURITY 60
-#define WLAN_REASON_MESH_PATH_ERROR 61
-#define WLAN_REASON_MESH_PATH_NOFORWARD  62
-#define WLAN_REASON_MESH_PATH_DEST_UNREACHABLE 63
-#define WLAN_REASON_MAC_EXISTS_IN_MBSS 64
-#define WLAN_REASON_MESH_CHAN_REGULATORY 65
-#define WLAN_REASON_MESH_CHAN 66
-
-/* Information Element IDs */
-#define WLAN_EID_SSID 0
-#define WLAN_EID_SUPP_RATES 1
-#define WLAN_EID_FH_PARAMS 2
-#define WLAN_EID_DS_PARAMS 3
-#define WLAN_EID_CF_PARAMS 4
-#define WLAN_EID_TIM 5
-#define WLAN_EID_IBSS_PARAMS 6
-#define WLAN_EID_CHALLENGE 16
-/* EIDs defined by IEEE 802.11h - START */
-#define WLAN_EID_PWR_CONSTRAINT 32
-#define WLAN_EID_PWR_CAPABILITY 33
-#define WLAN_EID_TPC_REQUEST 34
-#define WLAN_EID_TPC_REPORT 35
-#define WLAN_EID_SUPPORTED_CHANNELS 36
-#define WLAN_EID_CHANNEL_SWITCH 37
-#define WLAN_EID_MEASURE_REQUEST 38
-#define WLAN_EID_MEASURE_REPORT 39
-#define WLAN_EID_QUITE 40
-#define WLAN_EID_IBSS_DFS 41
-/* EIDs defined by IEEE 802.11h - END */
-#define WLAN_EID_ERP_INFO 42
-#define WLAN_EID_HT_CAP 45
-#define WLAN_EID_RSN 48
-#define WLAN_EID_EXT_SUPP_RATES 50
-#define WLAN_EID_MOBILITY_DOMAIN 54
-#define WLAN_EID_FAST_BSS_TRANSITION 55
-#define WLAN_EID_TIMEOUT_INTERVAL 56
-#define WLAN_EID_RIC_DATA 57
-#define WLAN_EID_HT_OPERATION 61
-#define WLAN_EID_SECONDARY_CHANNEL_OFFSET 62
-#define WLAN_EID_MULTIPLE_BSSID 71
-#define WLAN_EID_20_40_BSS_COEXISTENCE 72
-#define WLAN_EID_20_40_BSS_INTOLERANT 73
-#define WLAN_EID_OVERLAPPING_BSS_SCAN_PARAMS 74
-#define WLAN_EID_MMIE 76
-#define WLAN_EID_NONTRANSMITTED_BSSID_CAPABILITY 83
-#define WLAN_EID_MULTIPLE_BSSID_INDEX 85
-#define WLAN_EID_VHT_CAPABILITY 191
-#define WLAN_EID_VHT_OPERATION 192
-#define WLAN_EID_VHT_OPERATING_MODE_NOTIFICATION 199
-#define WLAN_EID_MESH_CONFIG 113
-#define WLAN_EID_MESH_ID 114
-#define WLAN_EID_MESH_PEERING_MANAGEMENT 117
-#define WLAN_EID_GANN 125
-#define WLAN_EID_RANN 126
-#define WLAN_EID_EXT_CAP 127
-#define WLAN_EID_PREQ 130
-#define WLAN_EID_PREP 131
-#define WLAN_EID_PERR 132
-#define WLAN_EID_MIC 140
-#define WLAN_EID_TWT 216
-#define WLAN_EID_VENDOR_SPECIFIC 221
-#define WLAN_EID_GENERIC (WLAN_EID_VENDOR_SPECIFIC)
-
-/* EID Extension */
-#define WLAN_EID_EXTENSION 255
-#define WLAN_EID_EXT_OWE_DH_PARAM 32	//WPA3
-#define WLAN_EID_EXT_HE_CAPABILITY 35
-#define WLAN_EID_EXT_HE_OPERATION 36
-#define WLAN_EID_EXT_HE_MU_EDCA 38
-#define WLAN_EID_EXT_SPATIAL_REUSE_PARA 39
-#define WLAN_EID_EXT_BSS_COLOR_CHANGE 42
-#define WLAN_EID_EXT_MULTIPLE_BSSID_CONFIGURATION 55	//MBSSID
-#define WLAN_EID_EXT_NON_INGERITANCE_ELEMENT 56		//MBSSID
-
-#define WLAN_EID_EXT_CAP_MAX_LEN 10
-
-#define IEEE80211_MGMT_HDR_LEN 24
-#define IEEE80211_DATA_HDR3_LEN 24
-#define IEEE80211_DATA_HDR4_LEN 30
-
-
-#define IEEE80211_STATMASK_SIGNAL (1<<0)
-#define IEEE80211_STATMASK_RSSI (1<<1)
-#define IEEE80211_STATMASK_NOISE (1<<2)
-#define IEEE80211_STATMASK_RATE (1<<3)
-#define IEEE80211_STATMASK_WEMASK 0x7
-
-
-#define IEEE80211_CCK_MODULATION    (1<<0)
-#define IEEE80211_OFDM_MODULATION   (1<<1)
-
-#define IEEE80211_24GHZ_BAND     (1<<0)
-#define IEEE80211_52GHZ_BAND     (1<<1)
-
-#define IEEE80211_CCK_RATE_LEN  		4
-#define IEEE80211_NUM_OFDM_RATESLEN	8
-
-
-#define IEEE80211_CCK_RATE_1MB		        0x02
-#define IEEE80211_CCK_RATE_2MB		        0x04
-#define IEEE80211_CCK_RATE_5MB		        0x0B
-#define IEEE80211_CCK_RATE_11MB		        0x16
-#define IEEE80211_OFDM_RATE_LEN 		8
-#define IEEE80211_OFDM_RATE_6MB		        0x0C
-#define IEEE80211_OFDM_RATE_9MB		        0x12
-#define IEEE80211_OFDM_RATE_12MB		0x18
-#define IEEE80211_OFDM_RATE_18MB		0x24
-#define IEEE80211_OFDM_RATE_24MB		0x30
-#define IEEE80211_OFDM_RATE_36MB		0x48
-#define IEEE80211_OFDM_RATE_48MB		0x60
-#define IEEE80211_OFDM_RATE_54MB		0x6C
-#define IEEE80211_BASIC_RATE_MASK		0x80
-
-#define IEEE80211_CCK_RATE_1MB_MASK		(1<<0)
-#define IEEE80211_CCK_RATE_2MB_MASK		(1<<1)
-#define IEEE80211_CCK_RATE_5MB_MASK		(1<<2)
-#define IEEE80211_CCK_RATE_11MB_MASK		(1<<3)
-#define IEEE80211_OFDM_RATE_6MB_MASK		(1<<4)
-#define IEEE80211_OFDM_RATE_9MB_MASK		(1<<5)
-#define IEEE80211_OFDM_RATE_12MB_MASK		(1<<6)
-#define IEEE80211_OFDM_RATE_18MB_MASK		(1<<7)
-#define IEEE80211_OFDM_RATE_24MB_MASK		(1<<8)
-#define IEEE80211_OFDM_RATE_36MB_MASK		(1<<9)
-#define IEEE80211_OFDM_RATE_48MB_MASK		(1<<10)
-#define IEEE80211_OFDM_RATE_54MB_MASK		(1<<11)
-
-
-#define IEEE80211_CCK_RATES_MASK	        0x0000000F
-#define IEEE80211_CCK_BASIC_RATES_MASK	(IEEE80211_CCK_RATE_1MB_MASK | \
-	IEEE80211_CCK_RATE_2MB_MASK)
-#define IEEE80211_CCK_DEFAULT_RATES_MASK	(IEEE80211_CCK_BASIC_RATES_MASK | \
-        IEEE80211_CCK_RATE_5MB_MASK | \
-        IEEE80211_CCK_RATE_11MB_MASK)
-
-#define IEEE80211_OFDM_RATES_MASK		0x00000FF0
-#define IEEE80211_OFDM_BASIC_RATES_MASK	(IEEE80211_OFDM_RATE_6MB_MASK | \
-	IEEE80211_OFDM_RATE_12MB_MASK | \
-	IEEE80211_OFDM_RATE_24MB_MASK)
-#define IEEE80211_OFDM_DEFAULT_RATES_MASK	(IEEE80211_OFDM_BASIC_RATES_MASK | \
-	IEEE80211_OFDM_RATE_9MB_MASK  | \
-	IEEE80211_OFDM_RATE_18MB_MASK | \
-	IEEE80211_OFDM_RATE_36MB_MASK | \
-	IEEE80211_OFDM_RATE_48MB_MASK | \
-	IEEE80211_OFDM_RATE_54MB_MASK)
-#define IEEE80211_DEFAULT_RATES_MASK (IEEE80211_OFDM_DEFAULT_RATES_MASK | \
-                                IEEE80211_CCK_DEFAULT_RATES_MASK)
-
-#define IEEE80211_NUM_OFDM_RATES	    8
-#define IEEE80211_NUM_CCK_RATES	            4
-#define IEEE80211_OFDM_SHIFT_MASK_A         4
-
-typedef enum _RATR_TABLE_MODE {
-	RATR_INX_WIRELESS_NGB = 0,	/* BGN 40 Mhz 2SS 1SS */
-	RATR_INX_WIRELESS_NG = 1,		/* GN or N */
-	RATR_INX_WIRELESS_NB = 2,		/* BGN 20 Mhz 2SS 1SS  or BN */
-	RATR_INX_WIRELESS_N = 3,
-	RATR_INX_WIRELESS_GB = 4,
-	RATR_INX_WIRELESS_G = 5,
-	RATR_INX_WIRELESS_B = 6,
-	RATR_INX_WIRELESS_MC = 7,
-	RATR_INX_WIRELESS_AC_N = 8,
-} RATR_TABLE_MODE, *PRATR_TABLE_MODE;
-
-#define	MGN_MCS0_SG			0xc0
-#define	MGN_MCS1_SG			0xc1
-#define	MGN_MCS2_SG			0xc2
-#define	MGN_MCS3_SG			0xc3
-#define	MGN_MCS4_SG			0xc4
-#define	MGN_MCS5_SG			0xc5
-#define	MGN_MCS6_SG			0xc6
-#define	MGN_MCS7_SG			0xc7
-#define	MGN_MCS8_SG			0xc8
-#define	MGN_MCS9_SG			0xc9
-#define	MGN_MCS10_SG		0xca
-#define	MGN_MCS11_SG		0xcb
-#define	MGN_MCS12_SG		0xcc
-#define	MGN_MCS13_SG		0xcd
-#define	MGN_MCS14_SG		0xce
-#define	MGN_MCS15_SG		0xcf
-
-#define IS_HT_RATE(_rate)				(((_rate) & 0x80) ? _TRUE : _FALSE)
-#define IS_CCK_RATE(_rate) 				(MGN_1M == _rate || _rate == MGN_2M || _rate == MGN_5_5M || _rate == MGN_11M )
-#define IS_OFDM_RATE(_rate)				(MGN_6M <= _rate && _rate <= MGN_54M )
-
-/* NOTE: This data is for statistical purposes; not all hardware provides this
- *       information for frames received.  Not setting these will not cause
- *       any adverse affects. */
-struct ieee80211_rx_stats {
-	//u32 mac_time[2];
-	s8 rssi;
-	u8 signal;
-	u8 noise;
-	u8 received_channel;
-	u16 rate; /* in 100 kbps */
-	//u8 control;
-	u8 mask;
-	u8 freq;
-	u16 len;
-};
-
-/* IEEE 802.11 requires that STA supports concurrent reception of at least
- * three fragmented frames. This define can be increased to support more
- * concurrent frames, but it should be noted that each entry can consume about
- * 2 kB of RAM and increasing cache size will slow down frame reassembly. */
-#define IEEE80211_FRAG_CACHE_LEN 4
-
-struct ieee80211_frag_entry {
-	u32 first_frag_time;
-	uint seq;
-	uint last_frag;
-	uint qos;   //jackson
-	uint tid;	//jackson
-	struct sk_buff *skb;
-	u8 src_addr[ETH_ALEN];
-	u8 dst_addr[ETH_ALEN];
-};
-
-struct ieee80211_stats {
-	uint tx_unicast_frames;
-	uint tx_multicast_frames;
-	uint tx_fragments;
-	uint tx_unicast_octets;
-	uint tx_multicast_octets;
-	uint tx_deferred_transmissions;
-	uint tx_single_retry_frames;
-	uint tx_multiple_retry_frames;
-	uint tx_retry_limit_exceeded;
-	uint tx_discards;
-	uint rx_unicast_frames;
-	uint rx_multicast_frames;
-	uint rx_fragments;
-	uint rx_unicast_octets;
-	uint rx_multicast_octets;
-	uint rx_fcs_errors;
-	uint rx_discards_no_buffer;
-	uint tx_discards_wrong_sa;
-	uint rx_discards_undecryptable;
-	uint rx_message_in_msg_fragments;
-	uint rx_message_in_bad_msg_fragments;
-};
-
-struct ieee80211_softmac_stats {
-	uint rx_ass_ok;
-	uint rx_ass_err;
-	uint rx_probe_rq;
-	uint tx_probe_rs;
-	uint tx_beacons;
-	uint rx_auth_rq;
-	uint rx_auth_rs_ok;
-	uint rx_auth_rs_err;
-	uint tx_auth_rq;
-	uint no_auth_rs;
-	uint no_ass_rs;
-	uint tx_ass_rq;
-	uint rx_ass_rq;
-	uint tx_probe_rq;
-	uint reassoc;
-	uint swtxstop;
-	uint swtxawake;
-};
-
-#define SEC_KEY_1         (1<<0)
-#define SEC_KEY_2         (1<<1)
-#define SEC_KEY_3         (1<<2)
-#define SEC_KEY_4         (1<<3)
-#define SEC_ACTIVE_KEY    (1<<4)
-#define SEC_AUTH_MODE     (1<<5)
-#define SEC_UNICAST_GROUP (1<<6)
-#define SEC_LEVEL         (1<<7)
-#define SEC_ENABLED       (1<<8)
-
-#define SEC_LEVEL_0      0 /* None */
-#define SEC_LEVEL_1      1 /* WEP 40 and 104 bit */
-#define SEC_LEVEL_2      2 /* Level 1 + TKIP */
-#define SEC_LEVEL_2_CKIP 3 /* Level 1 + CKIP */
-#define SEC_LEVEL_3      4 /* Level 2 + CCMP */
-
-#define WEP_KEYS 4
-#define WEP_KEY_LEN 13
-
-#ifdef CONFIG_IEEE80211W
-#define BIP_MAX_KEYID 5
-#define BIP_AAD_SIZE  20
-#endif /* CONFIG_IEEE80211W */
-
-
-#if defined(CONFIG_RTL8711FW)
-
-struct ieee80211_security {
-	u16 active_key: 2,
-		enabled: 1,
-		auth_mode: 2,
-		auth_algo: 4,
-		unicast_uses_group: 1;
-	u8 key_sizes[WEP_KEYS];
-	u8 keys[WEP_KEYS][WEP_KEY_LEN];
-	u8 level;
-	u16 flags;
-} __attribute__((packed));
-
-#endif
-
-/*
-
- 802.11 data frame from AP
-
-      ,-------------------------------------------------------------------.
-Bytes |  2   |  2   |    6    |    6    |    6    |  2   | 0..2312 |   4  |
-      |------|------|---------|---------|---------|------|---------|------|
-Desc. | ctrl | dura |  DA/RA  |   TA    |    SA   | Sequ |  frame  |  fcs |
-      |      | tion | (BSSID) |         |         | ence |  data   |      |
-      `-------------------------------------------------------------------'
-
-Total: 28-2340 bytes
-
-*/
-
-struct ieee80211_header_data {
-	u16 frame_ctl;
-	u16 duration_id;
-	u8 addr1[6];
-	u8 addr2[6];
-	u8 addr3[6];
-	u16 seq_ctrl;
-};
-
-#define BEACON_PROBE_SSID_ID_POSITION 12
-
-/* Management Frame Information Element Types */
-#define MFIE_TYPE_SSID       0
-#define MFIE_TYPE_RATES      1
-#define MFIE_TYPE_FH_SET     2
-#define MFIE_TYPE_DS_SET     3
-#define MFIE_TYPE_CF_SET     4
-#define MFIE_TYPE_TIM        5
-#define MFIE_TYPE_IBSS_SET   6
-#define MFIE_TYPE_CHALLENGE  16
-#define MFIE_TYPE_ERP        42
-#define MFIE_TYPE_RSN	     48
-#define MFIE_TYPE_RATES_EX   50
-#define MFIE_TYPE_GENERIC    221
-
-#if defined(CONFIG_RTL8711FW)
-
-struct ieee80211_info_element_hdr {
-	u8 id;
-	u8 len;
-} __attribute__((packed));
-
-struct ieee80211_info_element {
-	u8 id;
-	u8 len;
-	u8 data[0];
-} __attribute__((packed));
-#endif
-
-/*
- * These are the data types that can make up management packets
- *
-	u16 auth_algorithm;
-	u16 auth_sequence;
-	u16 beacon_interval;
-	u16 capability;
-	u8 current_ap[ETH_ALEN];
-	u16 listen_interval;
-	struct {
-		u16 association_id:14, reserved:2;
-	} __attribute__ ((packed));
-	u32 time_stamp[2];
-	u16 reason;
-	u16 status;
-*/
-
-#define IEEE80211_DEFAULT_TX_ESSID "Penguin"
-#define IEEE80211_DEFAULT_BASIC_RATE 10
-
-
-#if defined(CONFIG_RTL8711FW)
-
-
-struct ieee80211_authentication {
-	struct ieee80211_header_data header;
-	u16 algorithm;
-	u16 transaction;
-	u16 status;
-	//struct ieee80211_info_element_hdr info_element;
-} __attribute__((packed));
-
-
-struct ieee80211_probe_response {
-	struct ieee80211_header_data header;
-	u32 time_stamp[2];
-	u16 beacon_interval;
-	u16 capability;
-	struct ieee80211_info_element info_element;
-} __attribute__((packed));
-
-struct ieee80211_probe_request {
-	struct ieee80211_header_data header;
-	/*struct ieee80211_info_element info_element;*/
-} __attribute__((packed));
-
-struct ieee80211_assoc_request_frame {
-	struct rtw_ieee80211_hdr_3addr header;
-	u16 capability;
-	u16 listen_interval;
-	//u8 current_ap[ETH_ALEN];
-	struct ieee80211_info_element_hdr info_element;
-} __attribute__((packed));
-
-struct ieee80211_assoc_response_frame {
-	struct rtw_ieee80211_hdr_3addr header;
-	u16 capability;
-	u16 status;
-	u16 aid;
-//	struct ieee80211_info_element info_element; /* supported rates */
-} __attribute__((packed));
-#endif
-
-/* SWEEP TABLE ENTRIES NUMBER*/
-#define MAX_SWEEP_TAB_ENTRIES		  42
-#define MAX_SWEEP_TAB_ENTRIES_PER_PACKET  7
-/* MAX_RATES_LENGTH needs to be 12.  The spec says 8, and many APs
- * only use 8, and then use extended rates for the remaining supported
- * rates.  Other APs, however, stick all of their supported rates on the
- * main rates information element... */
-#define MAX_RATES_LENGTH                  ((u8)12)
-#define MAX_RATES_EX_LENGTH               ((u8)16)
-#define MAX_NETWORK_COUNT                  128
-#define MAX_CHANNEL_NUMBER                 161
-#define IEEE80211_SOFTMAC_SCAN_TIME	  400
-//(HZ / 2)
-#define IEEE80211_SOFTMAC_ASSOC_RETRY_TIME (HZ * 2)
-
-#define CRC_LENGTH                 4U
-
-#define MAX_WPA_IE_LEN (256)
-#define MAX_WPS_IE_LEN (512)
-#define MAX_P2P_IE_LEN (256)
-#define MAX_WFD_IE_LEN (128)
-
-#define NETWORK_EMPTY_ESSID (1<<0)
-#define NETWORK_HAS_OFDM    (1<<1)
-#define NETWORK_HAS_CCK     (1<<2)
-
-#define IEEE80211_DTIM_MBCAST 4
-#define IEEE80211_DTIM_UCAST 2
-#define IEEE80211_DTIM_VALID 1
-#define IEEE80211_DTIM_INVALID 0
-
-#define IEEE80211_PS_DISABLED 0
-#define IEEE80211_PS_UNICAST IEEE80211_DTIM_UCAST
-#define IEEE80211_PS_MBCAST IEEE80211_DTIM_MBCAST
-#define IW_ESSID_MAX_SIZE 32
-#define IW_PASSPHRASE_MAX_SIZE 64
-#if 0
-struct ieee80211_network {
-	/* These entries are used to identify a unique network */
-	u8 bssid[ETH_ALEN];
-	u8 channel;
-	/* Ensure null-terminated for any debug msgs */
-	u8 ssid[IW_ESSID_MAX_SIZE + 1];
-	u8 ssid_len;
-	u8	rssi;	//relative signal strength
-	u8	sq;		//signal quality
-
-	/* These are network statistics */
-	//struct ieee80211_rx_stats stats;
-	u16 capability;
-	u16	aid;
-	u8 rates[MAX_RATES_LENGTH];
-	u8 rates_len;
-	u8 rates_ex[MAX_RATES_EX_LENGTH];
-	u8 rates_ex_len;
-
-	u8 edca_parmsets[18];
-
-	u8 mode;
-	u8 flags;
-	u8 time_stamp[8];
-	u16 beacon_interval;
-	u16 listen_interval;
-	u16 atim_window;
-	u8 wpa_ie[MAX_WPA_IE_LEN];
-	size_t wpa_ie_len;
-	u8 rsn_ie[MAX_WPA_IE_LEN];
-	size_t rsn_ie_len;
-	u8 country[6];
-	u8 dtim_period;
-	u8 dtim_data;
-	u8 power_constraint;
-	u8 qosinfo;
-	u8 qbssload[5];
-	u8 network_type;
-	int join_res;
-	unsigned long	last_scanned;
-};
-#endif
-/*
-join_res:
--1: authentication fail
--2: association fail
-> 0: TID
-*/
-
-enum ieee80211_state {
-
-	/* the card is not linked at all */
-	IEEE80211_NOLINK = 0,
-
-	/* IEEE80211_ASSOCIATING* are for BSS client mode
-	 * the driver shall not perform RX filtering unless
-	 * the state is LINKED.
-	 * The driver shall just check for the state LINKED and
-	 * defaults to NOLINK for ALL the other states (including
-	 * LINKED_SCANNING)
-	 */
-
-	/* the association procedure will start (wq scheduling)*/
-	IEEE80211_ASSOCIATING,
-	IEEE80211_ASSOCIATING_RETRY,
-
-	/* the association procedure is sending AUTH request*/
-	IEEE80211_ASSOCIATING_AUTHENTICATING,
-
-	/* the association procedure has successfully authentcated
-	 * and is sending association request
-	 */
-	IEEE80211_ASSOCIATING_AUTHENTICATED,
-
-	/* the link is ok. the card associated to a BSS or linked
-	 * to a ibss cell or acting as an AP and creating the bss
-	 */
-	IEEE80211_LINKED,
-
-	/* same as LINKED, but the driver shall apply RX filter
-	 * rules as we are in NO_LINK mode. As the card is still
-	 * logically linked, but it is doing a syncro site survey
-	 * then it will be back to LINKED state.
-	 */
-	IEEE80211_LINKED_SCANNING,
-
-};
-
-#define DEFAULT_MAX_SCAN_AGE (15 * HZ)
-#define DEFAULT_FTS 2346
-#define MAC_FMT "%02x:%02x:%02x:%02x:%02x:%02x"
-
-#if defined(PLATFORM_FREERTOS) //Baron change func to macro
-#define is_multicast_mac_addr(Addr) ((((Addr[0]) & 0x01) == 0x01) && ((Addr[0]) != 0xff))
-#define is_broadcast_mac_addr(Addr) ((((Addr[0]) & 0xff) == 0xff) && (((Addr[1]) & 0xff) == 0xff) && \
-(((Addr[2]) & 0xff) == 0xff) && (((Addr[3]) & 0xff) == 0xff) && (((Addr[4]) & 0xff) == 0xff) && \
-(((Addr[5]) & 0xff) == 0xff))
-#define is_zero_mac_addr(Addr)	((Addr[0] == 0x00) && (Addr[1] == 0x00) && (Addr[2] == 0x00) &&   \
-                    (Addr[3] == 0x00) && (Addr[4] == 0x00) && (Addr[5] == 0x00))
-#endif // PLATFORM_FREERTOS
-
-#define CFG_IEEE80211_RESERVE_FCS (1<<0)
-#define CFG_IEEE80211_COMPUTE_FCS (1<<1)
-
-#define MAXTID	16
-
-#define IEEE_A            (1<<0)
-#define IEEE_B            (1<<1)
-#define IEEE_G            (1<<2)
-#define IEEE_MODE_MASK    (IEEE_A|IEEE_B|IEEE_G)
-
-//Baron move to ieee80211.c
-int ieee80211_is_empty_essid(const char *essid, int essid_len);
-int ieee80211_get_hdrlen(u16 fc);
-
-/* Action category code */
-enum rtw_ieee80211_category {
-	RTW_WLAN_CATEGORY_SPECTRUM_MGMT = 0,
-	RTW_WLAN_CATEGORY_QOS = 1,
-	RTW_WLAN_CATEGORY_DLS = 2,
-	RTW_WLAN_CATEGORY_BACK = 3,
-	RTW_WLAN_CATEGORY_PUBLIC = 4, //IEEE 802.11 public action frames
-	RTW_WLAN_CATEGORY_RADIO_MEASUREMENT  = 5,
-	RTW_WLAN_CATEGORY_FT = 6,
-	RTW_WLAN_CATEGORY_HT = 7,
-	RTW_WLAN_CATEGORY_SA_QUERY = 8,
-	RTW_WLAN_CATEGORY_WNM = 10,
-	RTW_WLAN_CATEGORY_UNPROTECTED_WNM = 11, /* add for CONFIG_IEEE80211W, none 11w also can use */
-	RTW_WLAN_CATEGORY_TDLS = 12,
-	RTW_WLAN_CATEGORY_MESH_ACTION = 13,
-	RTW_WLAN_CATEGORY_MULTIHOP_ACTION = 14,
-	RTW_WLAN_CATEGORY_SELF_PROTECTED = 15, /* add for CONFIG_IEEE80211W, none 11w also can use */
-	RTW_WLAN_CATEGORY_WMM = 17,
-	RTW_WLAN_CATEGORY_VHT = 21,
-	RTW_WLAN_CATEGORY_TWT = 22,
-	RTW_WLAN_CATEGORY_P2P = 0x7f,//P2P action frames
-};
-
-/* SPECTRUM_MGMT action code */
-enum rtw_ieee80211_spectrum_mgmt_actioncode {
-	RTW_WLAN_ACTION_SPCT_MSR_REQ = 0,
-	RTW_WLAN_ACTION_SPCT_MSR_RPRT = 1,
-	RTW_WLAN_ACTION_SPCT_TPC_REQ = 2,
-	RTW_WLAN_ACTION_SPCT_TPC_RPRT = 3,
-	RTW_WLAN_ACTION_SPCT_CHL_SWITCH = 4,
-	RTW_WLAN_ACTION_SPCT_EXT_CHL_SWITCH = 5,
-};
-
-enum _PUBLIC_ACTION {
-	ACT_PUBLIC_BSSCOEXIST = 0, // 20/40 BSS Coexistence
-	ACT_PUBLIC_DSE_ENABLE = 1,
-	ACT_PUBLIC_DSE_DEENABLE = 2,
-	ACT_PUBLIC_DSE_REG_LOCATION = 3,
-	ACT_PUBLIC_EXT_CHL_SWITCH = 4,
-	ACT_PUBLIC_DSE_MSR_REQ = 5,
-	ACT_PUBLIC_DSE_MSR_RPRT = 6,
-	ACT_PUBLIC_MP = 7, // Measurement Pilot
-	ACT_PUBLIC_DSE_PWR_CONSTRAINT = 8,
-	ACT_PUBLIC_VENDOR = 9, // for WIFI_DIRECT
-	ACT_PUBLIC_GAS_INITIAL_REQ = 10,
-	ACT_PUBLIC_GAS_INITIAL_RSP = 11,
-	ACT_PUBLIC_GAS_COMEBACK_REQ = 12,
-	ACT_PUBLIC_GAS_COMEBACK_RSP = 13,
-	ACT_PUBLIC_TDLS_DISCOVERY_RSP = 14,
-	ACT_PUBLIC_LOCATION_TRACK = 15,
-	ACT_PUBLIC_MAX
-};
-
-/* BACK action code */
-enum rtw_ieee80211_back_actioncode {
-	RTW_WLAN_ACTION_ADDBA_REQ = 0,
-	RTW_WLAN_ACTION_ADDBA_RESP = 1,
-	RTW_WLAN_ACTION_DELBA = 2,
-};
-
-enum rtw_ieee80211_spec_mgnt_actioncode {
-	RTW_WLAN_ACTION_CSA = 4,
-	RTW_WLAN_ACTION_EXTENDED_CSA = 5,
-};
-
-/* HT features action code */
-enum rtw_ieee80211_ht_actioncode {
-	RTW_WLAN_ACTION_NOTIFY_CH_WIDTH = 0,
-	RTW_WLAN_ACTION_SM_PS = 1,
-	RTW_WLAN_ACTION_PSPM = 2,
-	RTW_WLAN_ACTION_PCO_PHASE = 3,
-	RTW_WLAN_ACTION_MIMO_CSI_MX = 4,
-	RTW_WLAN_ACTION_MIMO_NONCP_BF = 5,
-	RTW_WLAN_ACTION_MIMP_CP_BF = 6,
-	RTW_WLAN_ACTION_ASEL_INDICATES_FB = 7,
-	RTW_WLAN_ACTION_HI_INFO_EXCHG = 8,
-};
-
-/* VHT features action code */
-enum rtw_ieee80211_vht_actioncode {
-	RTW_WLAN_ACTION_VHT_COMPRESSED_BEAMFORMING = 0,
-	RTW_WLAN_ACTION_VHT_GROUPID_MANAGEMENT = 1,
-	RTW_WLAN_ACTION_VHT_OPMODE_NOTIFICATION = 2,
-};
-
-/* BACK (block-ack) parties */
-enum rtw_ieee80211_back_parties {
-	RTW_WLAN_BACK_RECIPIENT = 0,
-	RTW_WLAN_BACK_INITIATOR = 1,
-	RTW_WLAN_BACK_TIMER = 2,
-};
-
-enum secondary_ch_offset {
-	RTW_WLAN_SCN = 0, /* no secondary channel */
-	RTW_WLAN_SCA = 1, /* secondary channel above */
-	RTW_WLAN_SCB = 3,  /* secondary channel below */
-};
-
-/* Self Protected Action codes */
-enum rtw_ieee80211_self_protected_actioncode {
-	RTW_WLAN_SP_RESERVED = 0,
-	RTW_WLAN_SP_MESH_PEERING_OPEN = 1,
-	RTW_WLAN_SP_MESH_PEERING_CONFIRM = 2,
-	RTW_WLAN_SP_MESH_PEERING_CLOSE = 3,
-	RTW_WLAN_SP_MGK_INFORM = 4,
-	RTW_WLAN_SP_MGK_ACK = 5,
-};
-
-/* Mesh action codes */
-enum rtw_ieee80211_mesh_actioncode {
-	RTW_WLAN_MESH_ACTION_LINK_METRIC_REPORT,
-	RTW_WLAN_MESH_ACTION_HWMP_PATH_SELECTION,
-	RTW_WLAN_MESH_ACTION_GATE_ANNOUNCEMENT,
-	RTW_WLAN_MESH_ACTION_CONGESTION_CONTROL_NOTIFICATION,
-	RTW_WLAN_MESH_ACTION_MCCA_SETUP_REQUEST,
-	RTW_WLAN_MESH_ACTION_MCCA_SETUP_REPLY,
-	RTW_WLAN_MESH_ACTION_MCCA_ADVERTISEMENT_REQUEST,
-	RTW_WLAN_MESH_ACTION_MCCA_ADVERTISEMENT,
-	RTW_WLAN_MESH_ACTION_MCCA_TEARDOWN,
-	RTW_WLAN_MESH_ACTION_TBTT_ADJUSTMENT_REQUEST,
-	RTW_WLAN_MESH_ACTION_TBTT_ADJUSTMENT_RESPONSE,
-};
-
-#if defined(CONFIG_IEEE80211K) || defined(CONFIG_RTW_WNM)
-/* Represent channel details, subset of ieee80211_channel */
-struct rtw_ieee80211_channel {
-	/* enum ieee80211_band band; */
-	/* u16 center_freq; */
-	u16 hw_value;
-	u32 flags;
-	/* int max_antenna_gain; */
-	/* int max_power; */
-	/* int max_reg_power; */
-	/* bool beacon_found; */
-	/* u32 orig_flags; */
-	/* int orig_mag; */
-	/* int orig_mpwr; */
-};
-#endif
-
-#define OUI_MICROSOFT 0x0050f2 /* Microsoft (also used in Wi-Fi specs)
-				* 00:50:F2 */
-#define WME_OUI_TYPE 2
-#define WME_OUI_SUBTYPE_INFORMATION_ELEMENT 0
-#define WME_OUI_SUBTYPE_PARAMETER_ELEMENT 1
-#define WME_OUI_SUBTYPE_TSPEC_ELEMENT 2
-#define WME_VERSION 1
-
-#define WME_ACTION_CODE_SETUP_REQUEST 0
-#define WME_ACTION_CODE_SETUP_RESPONSE 1
-#define WME_ACTION_CODE_TEARDOWN 2
-
-#define WME_SETUP_RESPONSE_STATUS_ADMISSION_ACCEPTED 0
-#define WME_SETUP_RESPONSE_STATUS_INVALID_PARAMETERS 1
-#define WME_SETUP_RESPONSE_STATUS_REFUSED 3
-
-#define WME_TSPEC_DIRECTION_UPLINK 0
-#define WME_TSPEC_DIRECTION_DOWNLINK 1
-#define WME_TSPEC_DIRECTION_BI_DIRECTIONAL 3
-
-
-#define OUI_BROADCOM 0x00904c /* Broadcom (Epigram) */
-
-#define VENDOR_HT_CAPAB_OUI_TYPE 0x33 /* 00-90-4c:0x33 */
-
-u8 *wifi_rom_get_ie_ex(u8 *in_ie, uint in_len, u8 eid, u8 *oui, u8 oui_len, u8 *ie, uint *ielen);
-int rtw_ies_remove_ie(u8 *ies, uint *ies_len, uint offset, u8 eid, u8 *oui, u8 oui_len);
-
-int rtw_get_wapi_ie(u8 *in_ie, uint in_len, u8 *wapi_ie, u16 *wapi_len);
-
-u8 rtw_is_wps_ie(u8 *ie_ptr, uint *wps_ielen);
-
-void dump_ies(u8 *buf, u32 buf_len);
-void dump_wps_ie(u8 *ie, u32 ie_len);
-
-int wifi_rom_parse_sec_ie_akm_mgc(u8 *ie, int ie_len, int *auth_key_mgmt, int *mgmt_group_cipher);
-u16 rtw_mcs_rate(u8 rf_type, u8 bw_40MHz, u8 short_GI_20, u8 short_GI_40, unsigned char *MCS_rate);
-
-
-#endif /* __IEEE80211_H */
-
diff --git a/os/board/rtl8720e/src/component/wifi/driver/include/ip.h b/os/board/rtl8720e/src/component/wifi/driver/include/ip.h
deleted file mode 100644
index eb57236c3..000000000
--- a/os/board/rtl8720e/src/component/wifi/driver/include/ip.h
+++ /dev/null
@@ -1,136 +0,0 @@
-/******************************************************************************
- *
- * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of version 2 of the GNU General Public License as
- * published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
- * more details.
- *
- * You should have received a copy of the GNU General Public License along with
- * this program; if not, write to the Free Software Foundation, Inc.,
- * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
- *
- *
- ******************************************************************************/
-#ifndef _LINUX_IP_H
-#define _LINUX_IP_H
-#include <rtw_byteorder.h>
-
-/* SOL_IP socket options */
-#ifndef IPTOS_TOS_MASK
-#define IPTOS_TOS_MASK		0x1E
-#define IPTOS_TOS(tos)		((tos)&IPTOS_TOS_MASK)
-#define	IPTOS_LOWDELAY		0x10
-#define	IPTOS_THROUGHPUT	0x08
-#define	IPTOS_RELIABILITY	0x04
-#define	IPTOS_MINCOST		0x02
-
-#define IPTOS_PREC_MASK		0xE0
-#define IPTOS_PREC(tos)		((tos)&IPTOS_PREC_MASK)
-#define IPTOS_PREC_NETCONTROL           0xe0
-#define IPTOS_PREC_INTERNETCONTROL      0xc0
-#define IPTOS_PREC_CRITIC_ECP           0xa0
-#define IPTOS_PREC_FLASHOVERRIDE        0x80
-#define IPTOS_PREC_FLASH                0x60
-#define IPTOS_PREC_IMMEDIATE            0x40
-#define IPTOS_PREC_PRIORITY             0x20
-#define IPTOS_PREC_ROUTINE              0x00
-#endif
-
-/* IP options */
-#define IPOPT_COPY		0x80
-#define IPOPT_CLASS_MASK	0x60
-#define IPOPT_NUMBER_MASK	0x1f
-
-#define	IPOPT_COPIED(o)		((o)&IPOPT_COPY)
-#define	IPOPT_CLASS(o)		((o)&IPOPT_CLASS_MASK)
-#define	IPOPT_NUMBER(o)		((o)&IPOPT_NUMBER_MASK)
-
-#define	IPOPT_CONTROL		0x00
-#define	IPOPT_RESERVED1		0x20
-#define	IPOPT_MEASUREMENT	0x40
-#define	IPOPT_RESERVED2		0x60
-
-#define IPOPT_END	(0 |IPOPT_CONTROL)
-#define IPOPT_NOOP	(1 |IPOPT_CONTROL)
-#define IPOPT_SEC	(2 |IPOPT_CONTROL|IPOPT_COPY)
-#define IPOPT_LSRR	(3 |IPOPT_CONTROL|IPOPT_COPY)
-#define IPOPT_TIMESTAMP	(4 |IPOPT_MEASUREMENT)
-#define IPOPT_RR	(7 |IPOPT_CONTROL)
-#define IPOPT_SID	(8 |IPOPT_CONTROL|IPOPT_COPY)
-#define IPOPT_SSRR	(9 |IPOPT_CONTROL|IPOPT_COPY)
-#define IPOPT_RA	(20|IPOPT_CONTROL|IPOPT_COPY)
-
-#define IPVERSION	4
-#define MAXTTL		255
-#define IPDEFTTL	64
-
-/* struct timestamp, struct route and MAX_ROUTES are removed.
-
-   REASONS: it is clear that nobody used them because:
-   - MAX_ROUTES value was wrong.
-   - "struct route" was wrong.
-   - "struct timestamp" had fatally misaligned bitfields and was completely unusable.
- */
-
-#define IPOPT_OPTVAL 0
-#define IPOPT_OLEN   1
-#define IPOPT_OFFSET 2
-#define IPOPT_MINOFF 4
-#define MAX_IPOPTLEN 40
-#define IPOPT_NOP IPOPT_NOOP
-#define IPOPT_EOL IPOPT_END
-#define IPOPT_TS  IPOPT_TIMESTAMP
-
-#define	IPOPT_TS_TSONLY		0		/* timestamps only */
-#define	IPOPT_TS_TSANDADDR	1		/* timestamps and addresses */
-#define	IPOPT_TS_PRESPEC	3		/* specified modules only */
-
-struct iphdr {
-#if defined(__LITTLE_ENDIAN_BITFIELD)
-	__u8	ihl: 4,
-			version: 4;
-#elif defined (__BIG_ENDIAN_BITFIELD)
-	__u8	version: 4,
-			ihl: 4;
-#else
-#error	"Please fix <asm/byteorder.h>"
-#endif
-	__u8	tos;
-	__u16	tot_len;
-	__u16	id;
-	__u16	frag_off;
-	__u8	ttl;
-	__u8	protocol;
-	__u16	check;
-	__u32	saddr;
-	__u32	daddr;
-	/*The options start here. */
-};
-
-/**
- *format of ipv6 header
- * |<---4 --->|<---8----->|<------20------->|
- * |--version--|-traffic class-|-----flow label-----|
- * |<--16--->|<----8----->|<--- ----8------>|
- * |--length --|--next header-|------hop limit----|
- * |<----------------128-------------------->|
- * |-----------------source addr---------------|
- * |<-----------------128------------------->|
- * |-----------------dest addr-----------------|
- */
-struct ipv6_hdr {
-	__u32 	v_tc_fl;
-	__u16	payload_len;
-	__u8	next_header;
-	__u8	hop_limit;
-	__u32	saddr[4];
-	__u32	daddr[4];
-};
-#endif	/* _LINUX_IP_H */
-
diff --git a/os/board/rtl8720e/src/component/wifi/driver/include/lxbus_hal.h b/os/board/rtl8720e/src/component/wifi/driver/include/lxbus_hal.h
deleted file mode 100644
index 90dc7e1ce..000000000
--- a/os/board/rtl8720e/src/component/wifi/driver/include/lxbus_hal.h
+++ /dev/null
@@ -1,24 +0,0 @@
-/******************************************************************************
- *
- * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of version 2 of the GNU General Public License as
- * published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
- * more details.
- *
- * You should have received a copy of the GNU General Public License along with
- * this program; if not, write to the Free Software Foundation, Inc.,
- * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
- *
- *
- ******************************************************************************/
-#ifndef __LXBUS_HAL_H__
-#define __LXBUS_HAL_H__
-
-#endif //__LXBUS_HAL_H__
-
diff --git a/os/board/rtl8720e/src/component/wifi/driver/include/lxbus_ops.h b/os/board/rtl8720e/src/component/wifi/driver/include/lxbus_ops.h
deleted file mode 100644
index 66a8071aa..000000000
--- a/os/board/rtl8720e/src/component/wifi/driver/include/lxbus_ops.h
+++ /dev/null
@@ -1,44 +0,0 @@
-/******************************************************************************
- *
- * Copyright(c) 2007 - 2012 Realtek Corporation. All rights reserved.
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of version 2 of the GNU General Public License as
- * published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
- * more details.
- *
- * You should have received a copy of the GNU General Public License along with
- * this program; if not, write to the Free Software Foundation, Inc.,
- * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
- *
- *
- ******************************************************************************/
-#ifndef __LXBUS_OPS_H__
-#define __LXBUS_OPS_H__
-
-extern const u32 tx_buf_addr_table[16];
-
-extern void wifi_hal_desc_ring_init(_adapter *padapter);
-extern u32 wifi_hal_desc_ring_free(_adapter *padapter);
-extern void wifi_hal_desc_ring_reset(_adapter *padapter);
-extern void wifi_xmit_tasklet(void *priv);
-extern void wifi_recv_tasklet(void *priv);
-extern void wifi_hal_tx_int_handler(_adapter *padapter);
-extern void wifi_hal_interrupt_enable(PADAPTER padapter);
-extern void wifi_hal_interrupt_disable(PADAPTER padapter);
-extern s32 wifi_hal_interrupt_handle(PADAPTER Adapter);
-extern void wifi_hal_interrupt_init(PADAPTER padapter);
-
-#if defined(CONFIG_RTL8721D)
-extern VOID UpdateInterruptMask8721d(PADAPTER Adapter, u32 *pAddMSRB, u32 *pRemoveMSR);
-#ifdef CONFIG_WOWLAN
-extern void DisableInterruptButCpwm28721d(PADAPTER padapter);
-#endif
-#endif
-
-#endif // !__LXBUS_OPS_H__
-
diff --git a/os/board/rtl8720e/src/component/wifi/driver/include/lxbus_osintf.h b/os/board/rtl8720e/src/component/wifi/driver/include/lxbus_osintf.h
deleted file mode 100644
index 1116e5561..000000000
--- a/os/board/rtl8720e/src/component/wifi/driver/include/lxbus_osintf.h
+++ /dev/null
@@ -1,29 +0,0 @@
-/******************************************************************************
- *
- * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of version 2 of the GNU General Public License as
- * published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
- * more details.
- *
- * You should have received a copy of the GNU General Public License along with
- * this program; if not, write to the Free Software Foundation, Inc.,
- * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
- *
- *
- ******************************************************************************/
-#ifndef __LXBUS_OSINTF_H
-#define __LXBUS_OSINTF_H
-
-
-//void	rtw_pci_disable_aspm(_adapter *padapter);
-//void	rtw_pci_enable_aspm(_adapter *padapter);
-//void	PlatformClearPciPMEStatus(PADAPTER Adapter);
-
-#endif //__LXBUS_OSINTF_H
-
diff --git a/os/board/rtl8720e/src/component/wifi/driver/include/pack_begin.h b/os/board/rtl8720e/src/component/wifi/driver/include/pack_begin.h
deleted file mode 100644
index 50838e0f5..000000000
--- a/os/board/rtl8720e/src/component/wifi/driver/include/pack_begin.h
+++ /dev/null
@@ -1,14 +0,0 @@
-
-/*
-  *    Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
-  *
-  * 	Define the start point of packed structure
-  *
-  */
-
-
-#if defined(__IAR_SYSTEMS_ICC__) || defined (__GNUC__) || defined(__CC_ARM) || (defined(__ARMCC_VERSION) && (__ARMCC_VERSION >= 6010050))
-#pragma pack(1)
-#endif
-
-
diff --git a/os/board/rtl8720e/src/component/wifi/driver/include/pack_end.h b/os/board/rtl8720e/src/component/wifi/driver/include/pack_end.h
deleted file mode 100644
index 3c168ea58..000000000
--- a/os/board/rtl8720e/src/component/wifi/driver/include/pack_end.h
+++ /dev/null
@@ -1,13 +0,0 @@
-/*
-  *    Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
-  *
-  * 	Define the end point of packed structure
-  *
-  */
-
-#if defined(__IAR_SYSTEMS_ICC__) || defined (__GNUC__) || defined(__CC_ARM) || (defined(__ARMCC_VERSION) && (__ARMCC_VERSION >= 6010050))
-#pragma pack()
-#endif
-
-
-
diff --git a/os/board/rtl8720e/src/component/wifi/driver/include/rom_aes.h b/os/board/rtl8720e/src/component/wifi/driver/include/rom_aes.h
old mode 100644
new mode 100755
index a1e5d278b..468dd4102
--- a/os/board/rtl8720e/src/component/wifi/driver/include/rom_aes.h
+++ b/os/board/rtl8720e/src/component/wifi/driver/include/rom_aes.h
@@ -33,4 +33,8 @@ void AES_UnWRAP(unsigned char *cipher, int cipher_len,
 				unsigned char *kek,	int kek_len,
 				unsigned char *plain);
 
+int wifi_rom_omac1_aes_128_vector(u8 *key, size_t num_elem,
+								  u8 *addr[], u32 *len, u8 *mac);
+
+
 #endif
diff --git a/os/board/rtl8720e/src/component/wifi/driver/include/rom_arc4.h b/os/board/rtl8720e/src/component/wifi/driver/include/rom_arc4.h
deleted file mode 100644
index 8c1b56b6c..000000000
--- a/os/board/rtl8720e/src/component/wifi/driver/include/rom_arc4.h
+++ /dev/null
@@ -1,23 +0,0 @@
-/******************************************************************************
- *
- * Copyright(c) 2007 - 2014 Realtek Corporation. All rights reserved.
- *
- * This is ROM code section.
- *
- *
- ******************************************************************************/
-#ifndef ROM_ARC4_H
-#define ROM_ARC4_H
-
-struct arc4context {
-	u32 x;
-	u32 y;
-	u8 state[256];
-};
-
-u32 crc32_get(u8 *buf, sint len);
-void rt_arc4_init(struct arc4context 	*parc4ctx, u8 *key, u32	key_len);
-void rt_arc4_crypt(struct arc4context	*parc4ctx, u8 *dest, u8 *src, u32 len);
-
-
-#endif //ROM_ARC4_H
diff --git a/os/board/rtl8720e/src/component/wifi/driver/include/rom_ieee80211.h b/os/board/rtl8720e/src/component/wifi/driver/include/rom_ieee80211.h
deleted file mode 100644
index 5fa0729f8..000000000
--- a/os/board/rtl8720e/src/component/wifi/driver/include/rom_ieee80211.h
+++ /dev/null
@@ -1,127 +0,0 @@
-/******************************************************************************
- *
- * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of version 2 of the GNU General Public License as
- * published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
- * more details.
- *
- * You should have received a copy of the GNU General Public License along with
- * this program; if not, write to the Free Software Foundation, Inc.,
- * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
- *
- *
- ******************************************************************************/
-#ifndef __ROM_IEEE80211_H
-#define __ROM_IEEE80211_H
-
-extern const u8 RTW_WPA_OUI_TYPE[] ;
-extern const u8 WPA_CIPHER_SUITE_NONE[];
-extern const u8 WPA_CIPHER_SUITE_WEP40[];
-extern const u8 WPA_CIPHER_SUITE_TKIP[];
-extern const u8 WPA_CIPHER_SUITE_CCMP[];
-extern const u8 WPA_CIPHER_SUITE_WEP104[];
-extern const u16 RSN_VERSION_BSD;
-extern const u8 RSN_AUTH_KEY_MGMT_UNSPEC_802_1X[];
-extern const u8 RSN_AUTH_KEY_MGMT_PSK_OVER_802_1X[];
-extern const u8 RSN_CIPHER_SUITE_NONE[];
-extern const u8 RSN_CIPHER_SUITE_WEP40[];
-extern const u8 RSN_CIPHER_SUITE_TKIP[];
-extern const u8 RSN_CIPHER_SUITE_CCMP[];
-extern const u8 RSN_CIPHER_SUITE_WEP104[];
-
-/* Parsed Information Elements */
-struct rtw_ieee802_11_elems {
-	u8 *ssid;
-	u8 ssid_len;
-	u8 *supp_rates;
-	u8 supp_rates_len;
-	u8 *fh_params;
-	u8 fh_params_len;
-	u8 *ds_params;
-	u8 ds_params_len;
-	u8 *cf_params;
-	u8 cf_params_len;
-	u8 *tim;
-	u8 tim_len;
-	u8 *ibss_params;
-	u8 ibss_params_len;
-	u8 *challenge;
-	u8 challenge_len;
-	u8 *erp_info;
-	u8 erp_info_len;
-	u8 *ext_supp_rates;
-	u8 ext_supp_rates_len;
-	u8 *wpa_ie;
-	u8 wpa_ie_len;
-	u8 *rsn_ie;
-	u8 rsn_ie_len;
-	u8 *wme;
-	u8 wme_len;
-	u8 *wme_tspec;
-	u8 wme_tspec_len;
-	u8 *wps_ie;
-	u8 wps_ie_len;
-	u8 *power_cap;
-	u8 power_cap_len;
-	u8 *supp_channels;
-	u8 supp_channels_len;
-	u8 *mdie;
-	u8 mdie_len;
-	u8 *ftie;
-	u8 ftie_len;
-	u8 *timeout_int;
-	u8 timeout_int_len;
-	u8 *ht_capabilities;
-	u8 ht_capabilities_len;
-	u8 *ht_operation;
-	u8 ht_operation_len;
-	u8 *vendor_ht_cap;
-	u8 vendor_ht_cap_len;
-};
-
-typedef enum { ParseOK = 0, ParseUnknown = 1, ParseFailed = -1 } ParseRes;
-
-ParseRes rtw_ieee802_11_parse_elems(u8 *start, uint len,
-									struct rtw_ieee802_11_elems *elems,
-									int show_errors);
-
-u8 *rtw_set_fixed_ie(unsigned char *pbuf, unsigned int len, unsigned char *source, unsigned int *frlen);
-u8 *rtw_set_ie(u8 *pbuf, sint index, uint len, u8 *source, uint *frlen);
-u8 *rtw_get_ie(u8 *pbuf, sint index, u32 *len, sint limit);
-
-void rtw_set_supported_rate(u8 *SupportedRates, uint mode, uint channel);
-
-unsigned char *rtw_get_wpa_ie(unsigned char *pie, u32 *wpa_ie_len, int limit);
-unsigned char *rtw_get_wpa2_ie(unsigned char *pie, u32 *rsn_ie_len, int limit);
-int rtw_get_wpa_cipher_suite(u8 *s);
-int rtw_get_wpa2_cipher_suite(u8 *s);
-
-int rtw_parse_wpa_ie(u8 *wpa_ie, int wpa_ie_len, int *group_cipher, int *pairwise_cipher, int *is_8021x);
-int rtw_parse_wpa2_ie(u8 *wpa_ie, int wpa_ie_len, int *group_cipher, int *pairwise_cipher, int *is_8021x);
-
-int rtw_get_sec_ie(u8 *in_ie, uint in_len, u8 *rsn_ie, u16 *rsn_len, u8 *wpa_ie, u16 *wpa_len);
-
-u8 *rtw_get_wps_ie(u8 *in_ie, uint in_len, u8 *wps_ie, uint *wps_ielen);
-u8 *rtw_get_wps_attr(u8 *wps_ie, uint wps_ielen, u16 target_attr_id, u8 *buf_attr, u32 *len_attr);
-u8 *rtw_get_wps_attr_content(u8 *wps_ie, uint wps_ielen, u16 target_attr_id, u8 *buf_content, uint *len_content);
-
-uint rtw_get_rateset_len(u8	*rateset);
-
-int rtw_get_bit_value_from_ieee_value(u8 val);
-
-uint rtw_is_cckrates_included(u8 *rate);
-
-uint rtw_is_cckratesonly_included(u8 *rate);
-
-int rtw_check_network_type(unsigned char *rate, int ratelen, int channel);
-
-u8 key_2char2num(u8 hch, u8 lch);
-
-#endif /* __ROM_IEEE80211_H */
-
diff --git a/os/board/rtl8720e/src/component/wifi/driver/include/rom_md5.h b/os/board/rtl8720e/src/component/wifi/driver/include/rom_md5.h
deleted file mode 100644
index ec8585bd4..000000000
--- a/os/board/rtl8720e/src/component/wifi/driver/include/rom_md5.h
+++ /dev/null
@@ -1,32 +0,0 @@
-/******************************************************************************
- *
- * Copyright(c) 2007 - 2014 Realtek Corporation. All rights reserved.
- *
- * This is ROM code section.
- *
- *
- ******************************************************************************/
-
-#ifndef ROM_MD5_H
-#define ROM_MD5_H
-
-
-#ifdef CONFIG_USE_MBEDTLS_ROM_ALG
-#include "mbedtls/md5.h"
-#define md5_ctx mbedtls_md5_context
-#else
-/* MD5 context. */
-typedef struct {
-	u32 state[4];                                   /* state (ABCD) */
-	u32 count[2];        /* number of bits, modulo 2^64 (lsb first) */
-	u8 buffer[64];                         /* input buffer */
-} md5_ctx;
-#endif
-
-void rt_md5_init(md5_ctx *context);
-void rt_md5_append(md5_ctx *context, u8 *input, u32 inputLen);
-void rt_md5_final(u8 digest[16], md5_ctx *context);
-void rt_md5_hmac(unsigned char *text, int text_len, unsigned char *key,
-				 int key_len, void *digest);
-
-#endif
diff --git a/os/board/rtl8720e/src/component/wifi/driver/include/rom_rc4.h b/os/board/rtl8720e/src/component/wifi/driver/include/rom_rc4.h
deleted file mode 100644
index 6492df76e..000000000
--- a/os/board/rtl8720e/src/component/wifi/driver/include/rom_rc4.h
+++ /dev/null
@@ -1,88 +0,0 @@
-/* crypto/rc4/rc4.h */
-/* Copyright (C) 1995-1997 Eric Young (eay@cryptsoft.com)
- * All rights reserved.
- *
- * This package is an SSL implementation written
- * by Eric Young (eay@cryptsoft.com).
- * The implementation was written so as to conform with Netscapes SSL.
- *
- * This library is free for commercial and non-commercial use as long as
- * the following conditions are aheared to.  The following conditions
- * apply to all code found in this distribution, be it the RC4, RSA,
- * lhash, DES, etc., code; not just the SSL code.  The SSL documentation
- * included with this distribution is covered by the same copyright terms
- * except that the holder is Tim Hudson (tjh@cryptsoft.com).
- *
- * Copyright remains Eric Young's, and as such any Copyright notices in
- * the code are not to be removed.
- * If this package is used in a product, Eric Young should be given attribution
- * as the author of the parts of the library used.
- * This can be in the form of a textual message at program startup or
- * in documentation (online or textual) provided with the package.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- * 3. All advertising materials mentioning features or use of this software
- *    must display the following acknowledgement:
- *    "This product includes cryptographic software written by
- *     Eric Young (eay@cryptsoft.com)"
- *    The word 'cryptographic' can be left out if the rouines from the library
- *    being used are not cryptographic related :-).
- * 4. If you include any Windows specific code (or a derivative thereof) from
- *    the apps directory (application code) you must include an acknowledgement:
- *    "This product includes software written by Tim Hudson (tjh@cryptsoft.com)"
- *
- * THIS SOFTWARE IS PROVIDED BY ERIC YOUNG ``AS IS'' AND
- * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
- * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
- * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
- * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
- * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
- * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
- * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
- * SUCH DAMAGE.
- *
- * The licence and distribution terms for any publically available version or
- * derivative of this code cannot be changed.  i.e. this code cannot simply be
- * copied and put under another distribution licence
- * [including the GNU Public Licence.]
- */
-
-#ifndef HEADER_RC4_H
-#define HEADER_RC4_H
-
-#ifdef OPENSSL_NO_RC4
-#error RC4 is disabled.
-#endif
-
-//#include <openssl/opensslconf.h> /* RC4_INT */
-#define RC4_INT unsigned int
-
-#ifdef  __cplusplus
-extern "C" {
-#endif
-
-typedef struct rc4_key_st {
-	RC4_INT x, y;
-	RC4_INT data[256];
-} RC4_KEY;
-
-
-//const char *RC4_options(void);
-void RC4_set_key(RC4_KEY *key, int len, const unsigned char *data);
-void RC4(RC4_KEY *key, unsigned long len, const unsigned char *indata,
-		 unsigned char *outdata);
-
-#ifdef  __cplusplus
-}
-#endif
-
-#endif
diff --git a/os/board/rtl8720e/src/component/wifi/driver/include/rom_rtw_defs.h b/os/board/rtl8720e/src/component/wifi/driver/include/rom_rtw_defs.h
new file mode 100755
index 000000000..9d2b99531
--- /dev/null
+++ b/os/board/rtl8720e/src/component/wifi/driver/include/rom_rtw_defs.h
@@ -0,0 +1,555 @@
+#ifndef __ROM_RTW_DEFS_H_
+#define __ROM_RTW_DEFS_H_
+
+enum wlan_mode {
+	WLAN_MD_INVALID = 0,
+	WLAN_MD_11B	= BIT0,
+	WLAN_MD_11A	= BIT1,
+	WLAN_MD_11G	= BIT2,
+	WLAN_MD_11N	= BIT3,
+	WLAN_MD_11AC	= BIT4,
+	WLAN_MD_11AX	= BIT5,
+
+	/* Type for current wireless mode */
+	WLAN_MD_11BG	= (WLAN_MD_11B | WLAN_MD_11G),
+	WLAN_MD_11GN	= (WLAN_MD_11G | WLAN_MD_11N),
+	WLAN_MD_11AN	= (WLAN_MD_11A | WLAN_MD_11N),
+	WLAN_MD_11BN	= (WLAN_MD_11B | WLAN_MD_11N),
+	WLAN_MD_11BGN	= (WLAN_MD_11B | WLAN_MD_11G | WLAN_MD_11N),
+	WLAN_MD_11BGAC = (WLAN_MD_11B | WLAN_MD_11G | WLAN_MD_11AC),
+	WLAN_MD_11BGAX = (WLAN_MD_11B | WLAN_MD_11G | WLAN_MD_11AX),
+	WLAN_MD_11GAC  = (WLAN_MD_11G | WLAN_MD_11AC),
+	WLAN_MD_11GAX  = (WLAN_MD_11G | WLAN_MD_11AX),
+	WLAN_MD_11A_AC = (WLAN_MD_11A | WLAN_MD_11AC),
+	WLAN_MD_11A_AX = (WLAN_MD_11A | WLAN_MD_11AX),
+
+	/* Capability -Type for registry default wireless mode */
+	WLAN_MD_11AGN	= (WLAN_MD_11A | WLAN_MD_11G | WLAN_MD_11N),
+	WLAN_MD_11ABGN	= (WLAN_MD_11A | WLAN_MD_11B | WLAN_MD_11G | WLAN_MD_11N),
+	WLAN_MD_11ANAC	= (WLAN_MD_11A | WLAN_MD_11N | WLAN_MD_11AC),
+	WLAN_MD_11BGNAC = (WLAN_MD_11B | WLAN_MD_11G | WLAN_MD_11N | WLAN_MD_11AC),
+	WLAN_MD_11GNAC  = (WLAN_MD_11G | WLAN_MD_11N | WLAN_MD_11AC),
+	WLAN_MD_24G_MIX = (WLAN_MD_11B | WLAN_MD_11G | WLAN_MD_11N  | WLAN_MD_11AX),
+	WLAN_MD_5G_MIX	= (WLAN_MD_11A | WLAN_MD_11N | WLAN_MD_11AC | WLAN_MD_11AX),
+	WLAN_MD_6G_MIX 	= (WLAN_MD_11A | WLAN_MD_11AX),
+	WLAN_MD_MAX	= (WLAN_MD_24G_MIX | WLAN_MD_5G_MIX),
+};
+
+typedef enum _RT_CHANNEL_DOMAIN_2G {
+	RTW_RD_2G_NULL = 0,	/* Do not support 2G*/
+	RTW_RD_2G_01 = 1,	/* Worldwide 13, Canada */
+	RTW_RD_2G_02 = 2,	/* Europe, Japan */
+	RTW_RD_2G_03 = 3,		/* Worldwide 11, US, Canada, Korea */
+	RTW_RD_2G_04 = 4,		/* Japan */
+	RTW_RD_2G_05 = 5,	/* France */
+	RTW_RD_2G_06 = 6,	/* 2G Global, include channel 14 */
+	//===== Add new channel plan above this line===============//
+	RT_CHANNEL_DOMAIN_2G_MAX,
+} RT_CHANNEL_DOMAIN_2G, *PRT_CHANNEL_DOMAIN_2G;
+
+typedef enum _RT_CHANNEL_DOMAIN_5G {
+	RTW_RD_5G_NULL = 0,		/*Do not support 5G*/
+	RTW_RD_5G_01 = 1,		/*US, Canada, Australia, New Zealand, Mexico (w/o Weather radar), (w/o Ch120~Ch128)*/
+	RTW_RD_5G_02 = 2,		/*Europe, Japan (W52, W53, W56)*/
+	RTW_RD_5G_03 = 3,		/*Australia, New Zealand, US, Korea*/
+	RTW_RD_5G_04 = 4,		/*Russia (w/o Ch136, Ch140)*/
+	RTW_RD_5G_05 = 5,		/*Korea*/
+	RTW_RD_5G_06 = 6,		/*FCC w/o DFS Channels, Jordan*/
+	RTW_RD_5G_07 = 7,		/*Bolivia, Chile, El Salvador, Venezuela, China */
+	RTW_RD_5G_08 = 8,		/*Venezuela, Indonesia (w/o Ch165)*/
+	RTW_RD_5G_09 = 9,		/*China, Taiwan w/o DFS, Qatar*/
+	RTW_RD_5G_10 = 10,		/*Japan (W52, W53), Israel, Bahrain, Egypt, India, China, Malaysia*/
+	RTW_RD_5G_11 = 11,		/*Japan (W56)*/
+	RTW_RD_5G_12 = 12,		/*Taiwan, (w/o Weather radar)(w/o Ch52, Ch120~Ch128)*/
+	RTW_RD_5G_13 = 13,		/*Taiwan, Band2, Band4*/
+	RTW_RD_5G_14 = 14,		/*Europe, Japan (W52), w/o DFS, Band1 only*/
+	RTW_RD_5G_15 = 15,		/*Latin America, Indonesia*/
+	RTW_RD_5G_16 = 16,		/*Lebanon*/
+	RTW_RD_5G_17 = 17,		/*Russia*/
+	RTW_RD_5G_18 = 18,		/*Taiwan (w/o Weather radar)(w/o Ch120~Ch128)*/
+	RTW_RD_5G_19 = 19,		/*ETSI, FCC (w/o Weather radar)(w/o Ch120~Ch128)*/
+	RTW_RD_5G_20 = 20,		/*Argentina(w/o Weather radar)(w/o Ch120~Ch128, Ch165)*/
+	RTW_RD_5G_21 = 21,		/*Russia*/
+	RTW_RD_5G_22 = 22,		/*US (include Ch144), Chile, Korea (2018 Dec 05 New standard, include ch144)*/
+	RTW_RD_5G_23 = 23,		/*Malaysia*/
+	RTW_RD_5G_24 = 24,		/*Japan, Europe*/
+	RTW_RD_5G_25 = 25,		/*Europe, FCC*/
+	RTW_RD_5G_26 = 26,		/*FCC*/
+	RTW_RD_5G_27 = 27,		/*FCC w/o Weather radar(w/o Ch120~Ch128)*/
+	RTW_RD_5G_28 = 28,		/*FCC w/o Band3 China*/
+	RTW_RD_5G_29 = 29,		/*FCC w/o Band3*/
+	RTW_RD_5G_30 = 30,		/*ETSI w/o DFS Band2&3*/
+	RTW_RD_5G_31 = 31,		/*Europe*/
+	RTW_RD_5G_32 = 32,		/*Europe*/
+	RTW_RD_5G_33 = 33,		/*Canada (w/o Weather radar)(w/o Ch120~Ch128, include Ch144)*/
+	RTW_RD_5G_34 = 34,		/*Australia, New Zealand (w/o Weather radar)(w/o Ch120~Ch128)*/
+	RTW_RD_5G_35 = 35,		/**/
+	RTW_RD_5G_36 = 36,		/*5G Worldwide (include Ch144) Band2&3 w/i DFS for AP mode.*/
+	RTW_RD_5G_37 = 37,		/*5G Worldwide Band1&2*/
+	RTW_RD_5G_38 = 38,		/*Chile (Band2,Band3)*/
+	RTW_RD_5G_39 = 39,		/*Japan*/
+	RTW_RD_5G_40 = 40,		/*Japan*/
+	RTW_RD_5G_41 = 41,		/*Japan*/
+	RTW_RD_5G_42 = 42,		/*Europe*/
+	RTW_RD_5G_43 = 43,		/*Japan, FCC*/
+	RTW_RD_5G_44 = 44,		/*FCC*/
+	RTW_RD_5G_45 = 45,		/*FCC w/o Band3*/
+	RTW_RD_5G_46 = 46,		/*Indonesia*/
+	RTW_RD_5G_47 = 47,		/*Japan, Singapore*/
+	RTW_RD_5G_48 = 48,		/*Japan*/
+	RTW_RD_5G_49 = 49,		/**/
+	RTW_RD_5G_50 = 50,		/*Russia*/
+	RTW_RD_5G_51 = 51,		/*Tunisia*/
+	RTW_RD_5G_52 = 52,		/*US (include Ch144)(2018 Dec 05 New standard, include ch144)Add FCC 5.9G Channel*/
+	RTW_RD_5G_53 = 53,		/*Korea*/
+	RTW_RD_5G_54 = 54,
+	//===== Add new channel plan above this line===============//
+	RT_CHANNEL_DOMAIN_5G_MAX
+} RT_CHANNEL_DOMAIN_5G, *PRT_CHANNEL_DOMAIN_5G;
+
+// Tx Power Limit Table Size
+typedef enum _REGULATION_TXPWR_LMT {
+	TXPWR_LMT_FCC = 0,
+	TXPWR_LMT_MKK = 1,
+	TXPWR_LMT_ETSI = 2,
+	TXPWR_LMT_IC = 3,
+	TXPWR_LMT_KCC = 4,
+	TXPWR_LMT_ACMA = 5,
+	TXPWR_LMT_CHILE = 6,
+	TXPWR_LMT_MEXICO = 7,
+	TXPWR_LMT_WW = 8, // WW13, The mininum of ETSI,MKK
+	TXPWR_LMT_GL = 9, // Global, The mininum of all
+	TXPWR_LMT_UKRAINE = 10,
+	TXPWR_LMT_CN = 11,
+	TXPWR_LMT_QATAR = 12,
+	TXPWR_LMT_UK = 13,
+	TXPWR_LMT_NCC = 14,
+	TXPWR_LMT_MAX_REGULATION_NUM = 15,
+	TXPWR_LMT_NA = 16  /* Not support, choose NA */
+} REGULATION_TXPWR_LMT;
+
+//
+// Channel Plan Type.
+// Note:
+//	We just add new channel plan when the new channel plan is different from any of the following
+//	channel plan.
+//	If you just wnat to customize the acitions(scan period or join actions) about one of the channel plan,
+//	customize them in RT_CHANNEL_INFO in the RT_CHANNEL_LIST.
+//
+typedef enum _RT_CHANNEL_DOMAIN {
+	//===== new channel plan mapping, (2GDOMAIN_5GDOMAIN) =====//
+	RT_CHANNEL_DOMAIN_WORLD_NULL = 0x20,
+	RT_CHANNEL_DOMAIN_ETSI1_NULL = 0x21,
+	RT_CHANNEL_DOMAIN_FCC1_NULL = 0x22,
+	RT_CHANNEL_DOMAIN_MKK1_NULL = 0x23,
+	RT_CHANNEL_DOMAIN_ETSI2_NULL = 0x24,
+	RT_CHANNEL_DOMAIN_FCC1_FCC1 = 0x25,
+	RT_CHANNEL_DOMAIN_WORLD_ETSI1 = 0x26,
+	RT_CHANNEL_DOMAIN_MKK1_MKK1 = 0x27,
+	RT_CHANNEL_DOMAIN_WORLD_KCC1 = 0x28,
+	RT_CHANNEL_DOMAIN_WORLD_FCC2 = 0x29,
+	RT_CHANNEL_DOMAIN_FCC2_NULL = 0x2A,
+	RT_CHANNEL_DOMAIN_IC1_IC2 = 0x2B,
+	RT_CHANNEL_DOMAIN_MKK2_NULL = 0x2C,
+	RT_CHANNEL_DOMAIN_WORLD_CHILE1 = 0x2D,
+	RT_CHANNEL_DOMAIN_WORLD1_WORLD1 = 0x2E,
+	RT_CHANNEL_DOMAIN_WORLD_CHILE2 = 0x2F,
+	RT_CHANNEL_DOMAIN_WORLD_FCC3 = 0x30,
+	RT_CHANNEL_DOMAIN_WORLD_FCC4 = 0x31,
+	RT_CHANNEL_DOMAIN_WORLD_FCC5 = 0x32,
+	RT_CHANNEL_DOMAIN_WORLD_FCC6 = 0x33,
+	RT_CHANNEL_DOMAIN_FCC1_FCC7 = 0x34,
+	RT_CHANNEL_DOMAIN_WORLD_ETSI2 = 0x35,
+	RT_CHANNEL_DOMAIN_WORLD_ETSI3 = 0x36,
+	RT_CHANNEL_DOMAIN_MKK1_MKK2 = 0x37,
+	RT_CHANNEL_DOMAIN_MKK1_MKK3 = 0x38,
+	RT_CHANNEL_DOMAIN_FCC1_NCC1 = 0x39,
+	RT_CHANNEL_DOMAIN_ETSI1_ETSI1 = 0x3A,
+	RT_CHANNEL_DOMAIN_ETSI1_ACMA1 = 0x3B,
+	RT_CHANNEL_DOMAIN_ETSI1_ETSI6 = 0x3C,
+	RT_CHANNEL_DOMAIN_ETSI1_ETSI12 = 0x3D,
+	RT_CHANNEL_DOMAIN_KCC1_KCC2 = 0x3E,
+	RT_CHANNEL_DOMAIN_FCC1_FCC11 = 0x3F,
+	RT_CHANNEL_DOMAIN_FCC1_NCC2 = 0x40,
+	RT_CHANNEL_DOMAIN_GLOBAL_NULL = 0x41,
+	RT_CHANNEL_DOMAIN_ETSI1_ETSI4 = 0x42,
+	RT_CHANNEL_DOMAIN_FCC1_FCC2 = 0x43,
+	RT_CHANNEL_DOMAIN_FCC1_NCC3 = 0x44,
+	RT_CHANNEL_DOMAIN_WORLD_ACMA1 = 0x45,
+	RT_CHANNEL_DOMAIN_FCC1_FCC8 = 0x46,
+	RT_CHANNEL_DOMAIN_WORLD_ETSI6 = 0x47,
+	RT_CHANNEL_DOMAIN_WORLD_ETSI7 = 0x48,
+	RT_CHANNEL_DOMAIN_WORLD_ETSI8 = 0x49,
+	RT_CHANNEL_DOMAIN_IC2_IC2 = 0x4A,
+	RT_CHANNEL_DOMAIN_KCC1_KCC3 = 0x4B,
+	RT_CHANNEL_DOMAIN_FCC1_FCC15 = 0x4C,
+	RT_CHANNEL_DOMAIN_FCC2_MEX1 = 0x4D,
+	RT_CHANNEL_DOMAIN_ETSI1_ETSI22 = 0x4E,
+	RT_CHANNEL_DOMAIN_NULL_MKK9 = 0x4F,
+	RT_CHANNEL_DOMAIN_WORLD_ETSI9 = 0x50,
+	RT_CHANNEL_DOMAIN_WORLD_ETSI10 = 0x51,
+	RT_CHANNEL_DOMAIN_WORLD_ETSI11 = 0x52,
+	RT_CHANNEL_DOMAIN_FCC1_NCC4 = 0x53,
+	RT_CHANNEL_DOMAIN_WORLD_ETSI12 = 0x54,
+	RT_CHANNEL_DOMAIN_FCC1_FCC9 = 0x55,
+	RT_CHANNEL_DOMAIN_WORLD_ETSI13 = 0x56,
+	RT_CHANNEL_DOMAIN_FCC1_FCC10 = 0x57,
+	RT_CHANNEL_DOMAIN_MKK2_MKK4 = 0x58,
+	RT_CHANNEL_DOMAIN_WORLD_ETSI14 = 0x59,
+	RT_CHANNEL_DOMAIN_NULL_FCC19 = 0x5A,
+	RT_CHANNEL_DOMAIN_NULL_FCC20 = 0x5B,
+	RT_CHANNEL_DOMAIN_NULL_FCC21 = 0x5C,
+	RT_CHANNEL_DOMAIN_ETSI1_ETSI23	= 0x5D,
+	RT_CHANNEL_DOMAIN_ETSI1_ETSI2 = 0x5E,
+	RT_CHANNEL_DOMAIN_MKK2_MKK10 = 0x5F,
+	RT_CHANNEL_DOMAIN_FCC1_FCC5 = 0x60,
+	RT_CHANNEL_DOMAIN_FCC2_FCC7 = 0x61,
+	RT_CHANNEL_DOMAIN_FCC2_FCC1 = 0x62,
+	RT_CHANNEL_DOMAIN_WORLD_ETSI15 = 0x63,
+	RT_CHANNEL_DOMAIN_MKK2_MKK5 = 0x64,
+	RT_CHANNEL_DOMAIN_ETSI1_ETSI16 = 0x65,
+	RT_CHANNEL_DOMAIN_FCC1_FCC14 = 0x66,
+	RT_CHANNEL_DOMAIN_FCC1_FCC12 = 0x67,
+	RT_CHANNEL_DOMAIN_FCC2_FCC14 = 0x68,
+	RT_CHANNEL_DOMAIN_FCC2_FCC12 = 0x69,
+	RT_CHANNEL_DOMAIN_ETSI1_ETSI17 = 0x6A,
+	RT_CHANNEL_DOMAIN_WORLD_FCC16 = 0x6B,
+	RT_CHANNEL_DOMAIN_WORLD_FCC13 = 0x6C,
+	RT_CHANNEL_DOMAIN_FCC2_FCC15 = 0x6D,
+	RT_CHANNEL_DOMAIN_WORLD_FCC12 = 0x6E,
+	RT_CHANNEL_DOMAIN_NULL_ETSI8 = 0x6F,
+	RT_CHANNEL_DOMAIN_NULL_ETSI18 = 0x70,
+	RT_CHANNEL_DOMAIN_NULL_ETSI17 = 0x71,
+	RT_CHANNEL_DOMAIN_NULL_ETSI19 = 0x72,
+	RT_CHANNEL_DOMAIN_WORLD_FCC7 = 0x73,
+	RT_CHANNEL_DOMAIN_FCC2_FCC17 = 0x74,
+	RT_CHANNEL_DOMAIN_WORLD_ETSI20 = 0x75,
+	RT_CHANNEL_DOMAIN_FCC2_FCC11 = 0x76,
+	RT_CHANNEL_DOMAIN_WORLD_ETSI21 = 0x77,
+	RT_CHANNEL_DOMAIN_FCC1_FCC18 = 0x78,
+	RT_CHANNEL_DOMAIN_MKK2_MKK1 = 0x79,
+	RT_CHANNEL_DOMAIN_ETSI1_ETSI25 = 0x7A,
+	RT_CHANNEL_DOMAIN_ETSI1_ETSI24 = 0x7B,
+	RT_CHANNEL_DOMAIN_ETSI1_ETSI26 = 0x7C,
+	RT_CHANNEL_DOMAIN_MKK1_MKK11 = 0x7D,
+	RT_CHANNEL_DOMAIN_MKK2_MKK11 = 0x7E,
+	RT_CHANNEL_DOMAIN_WORLDWIDE = 0x7F,
+
+	/* ===== Add new channel plan above this line. ===== */
+	RT_CHANNEL_DOMAIN_MAX
+} RT_CHANNEL_DOMAIN, *PRT_CHANNEL_DOMAIN;
+
+#define BAND_CAP_2G			BIT0
+#define BAND_CAP_5G			BIT1
+
+// Scan type including active and passive scan.
+typedef enum _RT_SCAN_TYPE {
+	SCAN_PASSIVE = 1,
+	SCAN_ACTIVE,
+} RT_SCAN_TYPE, *PRT_SCAN_TYPE;
+
+enum channel_width {
+	CHANNEL_WIDTH_20		= 0,
+	CHANNEL_WIDTH_40		= 1,
+	CHANNEL_WIDTH_80		= 2,
+	CHANNEL_WIDTH_160		= 3,
+	CHANNEL_WIDTH_80_80	= 4,
+	CHANNEL_WIDTH_5		= 5,
+	CHANNEL_WIDTH_10	= 6,
+	CHANNEL_WIDTH_MAX	= 7,
+};
+
+#define WLANHDR_OFFSET	64
+#define TXDESC_OFFSET TXDESC_SIZE
+
+#define WPA_KEY_MGMT_IEEE8021X BIT(0)
+#define WPA_KEY_MGMT_PSK BIT(1)
+#define WPA_KEY_MGMT_NONE BIT(2)
+#define WPA_KEY_MGMT_IEEE8021X_NO_WPA BIT(3)
+#define WPA_KEY_MGMT_WPA_NONE BIT(4)
+#define WPA_KEY_MGMT_FT_IEEE8021X BIT(5)
+#define WPA_KEY_MGMT_FT_PSK BIT(6)
+#define WPA_KEY_MGMT_IEEE8021X_SHA256 BIT(7)
+#define WPA_KEY_MGMT_PSK_SHA256 BIT(8)
+#define WPA_KEY_MGMT_WPS BIT(9)
+#define WPA_KEY_MGMT_SAE BIT(10)
+#define WPA_KEY_MGMT_FT_SAE BIT(11)
+#define WPA_KEY_MGMT_WAPI_PSK BIT(12)
+#define WPA_KEY_MGMT_WAPI_CERT BIT(13)
+#define WPA_KEY_MGMT_CCKM BIT(14)
+#define WPA_KEY_MGMT_OSEN BIT(15)
+#define WPA_KEY_MGMT_IEEE8021X_SUITE_B BIT(16)
+#define WPA_KEY_MGMT_IEEE8021X_SUITE_B_192 BIT(17)
+#define WPA_KEY_MGMT_FILS_SHA256 BIT(18)
+#define WPA_KEY_MGMT_FILS_SHA384 BIT(19)
+#define WPA_KEY_MGMT_FT_FILS_SHA256 BIT(20)
+#define WPA_KEY_MGMT_FT_FILS_SHA384 BIT(21)
+#define WPA_KEY_MGMT_OWE BIT(22)
+#define WPA_KEY_MGMT_DPP BIT(23)
+
+typedef enum _NDIS_802_11_AUTHENTICATION_MODE {
+	Ndis802_11AuthModeOpen,
+	Ndis802_11AuthModeShared,
+	Ndis802_11AuthModeAutoSwitch,
+	Ndis802_11AuthModeWPA,
+	Ndis802_11AuthModeWPAPSK,
+	Ndis802_11AuthModeWPANone,
+	Ndis802_11AuthModeWAPI,
+	Ndis802_11AuthModeWPA2,
+	Ndis802_11AuthModeWPA2PSK,
+	Ndis802_11AuthModeWPA3,
+	Ndis802_11AuthModeWPA3PSK,
+	Ndis802_11AuthModeMax               // Not a real mode, defined as upper bound
+} NDIS_802_11_AUTHENTICATION_MODE, *PNDIS_802_11_AUTHENTICATION_MODE;
+
+#define MAX_IE_SZ	768 //384//
+
+enum {
+	RTW_ROAM_ON_EXPIRED = BIT(0),
+	RTW_ROAM_ON_RESUME = BIT(1),
+	RTW_ROAM_ACTIVE = BIT(2),
+	RTW_ROAM_ON_BTM = BIT(3),
+};
+
+/* Extended Capabilities: n bytes */
+#define GET_EXT_CAP_MBSSID(_pEleStart)					LE_BITS_TO_1BYTE(((u8 *)(_pEleStart) + 2), 6, 1)
+#define SET_EXT_CAP_MBSSID(_pEleStart, _val)				SET_BITS_TO_LE_1BYTE(((u8 *)(_pEleStart) + 2), 6, 1, _val)
+
+enum VCS_TYPE {
+	NONE_VCS,
+	RTS_CTS,
+	CTS_TO_SELF
+};
+
+#define WAIT_FOR_BCN_TO_MIN		(6000)
+#define WAIT_FOR_BCN_TO_MAX		(20000)
+
+#define PMK_EXPANSION_CONST				"Pairwise key expansion"
+#define PMK_EXPANSION_CONST_SIZE		22
+#define GMK_EXPANSION_CONST				"Group key expansion"
+#define GMK_EXPANSION_CONST_SIZE		19
+#define IGTK_EXPANSION_CONST				"IGTK key expansion"
+#define RANDOM_EXPANSION_CONST			"Init Counter"
+#define RANDOM_EXPANSION_CONST_SIZE		12
+
+#define A_SHA_DIGEST_LEN		20
+#define INFO_ELEMENT_SIZE       128
+
+typedef enum {
+	DOT11_PortStatus_Unauthorized,
+	DOT11_PortStatus_Authorized,
+	DOT11_PortStatus_Guest
+} DOT11_PORT_STATUS;
+
+#define _NO_PRIVACY_		0x0
+#define _WEP40_				0x1
+#define _TKIP_				0x2
+#define _TKIP_WTMIC_		0x3
+#define _AES_				0x4
+#define _WEP104_			0x5
+#define _WEP_WPA_MIXED_		0x07  // WEP + WPA
+#define _SMS4_				0x06
+#define _BIP_				0x8
+#define _GCMP_ 0x07
+#define _GCMP_256_ (_GCMP_ | BIT(3))
+#define _CCMP_256_ (_AES_ | BIT(3))
+
+#define BW_CAP_5M		BIT0
+#define BW_CAP_10M		BIT1
+#define BW_CAP_20M		BIT2
+#define BW_CAP_40M		BIT3
+#define BW_CAP_80M		BIT4
+#define BW_CAP_160M		BIT5
+#define BW_CAP_80_80M	BIT6
+
+enum chan_offset {
+	CHAN_OFFSET_NO_EXT = 0,	/*SCN - no secondary channel*/
+	CHAN_OFFSET_UPPER = 1,	/*SCA - secondary channel above*/
+	CHAN_OFFSET_NO_DEF = 2,	/*Reserved*/
+	CHAN_OFFSET_LOWER = 3,	/*SCB - secondary channel below*/
+	CHAN_OFFSET_40M_UPPER = 4,
+	CHAN_OFFSET_40M_LOWER = 5,
+	CHAN_OFFSET_80M_UPPER = 6,
+	CHAN_OFFSET_80M_LOWER = 7,
+};
+
+typedef enum {
+	ENCRYP_PROTOCOL_OPENSYS,   //open system
+	ENCRYP_PROTOCOL_WEP,       //WEP
+	ENCRYP_PROTOCOL_WPA,       //WPA
+	ENCRYP_PROTOCOL_WPA2,      //WPA2
+	ENCRYP_PROTOCOL_WPA_WPA2,  //WPA & WPA2
+	ENCRYP_PROTOCOL_WAPI,      //WAPI: Not support in this version
+	ENCRYP_PROTOCOL_MAX
+} ENCRYP_PROTOCOL_E;
+
+/**
+ * enum mfp_options - Management frame protection (IEEE 802.11w) options
+ */
+enum mfp_options {
+	NO_MGMT_FRAME_PROTECTION = 0,
+	MGMT_FRAME_PROTECTION_OPTIONAL = 1,
+	MGMT_FRAME_PROTECTION_REQUIRED = 2,
+};
+#define MGMT_FRAME_PROTECTION_DEFAULT 3
+
+#define WPA_CAPABILITY_MFPR BIT(6)
+#define WPA_CAPABILITY_MFPC BIT(7)
+
+enum dot11AuthAlgrthmNum {
+	dot11AuthAlgrthm_Open = 0,
+	dot11AuthAlgrthm_Shared,
+	dot11AuthAlgrthm_8021X,
+	dot11AuthAlgrthm_SAE,
+	dot11AuthAlgrthm_Auto,
+	dot11AuthAlgrthm_WAPI,
+	dot11AuthAlgrthm_FT_PSK,
+	dot11AuthAlgrthm_MaxNum
+};
+
+#define _AUTH_ALGM_NUM_			2
+#define _AUTH_SEQ_NUM_			2
+#define _BEACON_ITERVAL_		2
+#define _CAPABILITY_			2
+#define _RSON_CODE_				2
+#define _ASOC_ID_				2
+#define _STATUS_CODE_			2
+#define _TIMESTAMP_				8
+
+/* Values in HE spec */
+#define TXOP_DUR_RTS_TH_DISABLED	1023
+
+#define SN_LESS(a, b)		(((a-b)&0x800)!=0)
+#define SN_EQUAL(a, b)	(a == b)
+
+#define SHA256_MAC_LEN 32
+
+#define CCK_ONLY_RATE_NUM		4
+#define OFDM_ONLY_RATE_NUM		8
+#define NumRates			12
+#define OFDM_ONLY_BASIC_RATE_NUM	3
+
+/* STA flags */
+#define WLAN_STA_AUTH BIT(0)
+#define WLAN_STA_ASSOC BIT(1)
+#define WLAN_STA_PS BIT(2)
+#define WLAN_STA_TIM BIT(3)
+#define WLAN_STA_PERM BIT(4)
+#define WLAN_STA_AUTHORIZED BIT(5)
+#define WLAN_STA_PENDING_POLL BIT(6) /* pending activity poll not ACKed */
+#define WLAN_STA_SHORT_PREAMBLE BIT(7)
+#define WLAN_STA_PREAUTH BIT(8)
+#define WLAN_STA_WME BIT(9)
+#define WLAN_STA_MFP BIT(10)
+#define WLAN_STA_HT BIT(11)
+#define WLAN_STA_WPS BIT(12)
+#define WLAN_STA_MAYBE_WPS BIT(13)
+#define WLAN_STA_NONERP BIT(31)
+
+#define RTW_RX_HANDLED			2
+#define RTW_RFRAME_UNAVAIL		3
+#define RTW_RFRAME_PKT_UNAVAIL	4
+#define RTW_RBUF_UNAVAIL		5
+#define RTW_RBUF_PKT_UNAVAIL	6
+#define RTW_SDIO_READ_PORT_FAIL	7
+
+typedef enum _RATEID_IDX_ {
+	RATEID_IDX_BGN_40M_2SS = 0,
+	RATEID_IDX_BGN_40M_1SS = 1,
+	RATEID_IDX_BGN_20M_2SS_BN = 2,
+	RATEID_IDX_BGN_20M_1SS_BN = 3,
+	RATEID_IDX_GN_N2SS = 4,
+	RATEID_IDX_GN_N1SS = 5,
+	RATEID_IDX_BG = 6,
+	RATEID_IDX_G = 7,
+	RATEID_IDX_B = 8,
+	RATEID_IDX_VHT_2SS = 9,
+	RATEID_IDX_VHT_1SS = 10,
+} RATEID_IDX, *PRATEID_IDX;
+
+enum rf_type {
+	RF_1T1R			= 0,
+	RF_1T2R			= 1,
+	RF_2T2R			= 2,
+	RF_2T3R			= 3,
+	RF_2T4R			= 4,
+	RF_3T3R			= 5,
+	RF_3T4R			= 6,
+	RF_4T4R			= 7,
+	RF_TYPE_MAX,
+};
+
+enum _IFACE_TYPE {
+	IFACE_PORT0, //mapping to port0 for C/D series chips
+	IFACE_PORT1, //mapping to port1 for C/D series chip
+	MAX_IFACE_PORT,
+};
+
+typedef enum _WIRELESS_MODE {
+	WIRELESS_MODE_UNKNOWN = 0x00,
+	WIRELESS_MODE_A = 0x01,
+	WIRELESS_MODE_B = 0x02,
+	WIRELESS_MODE_G = 0x04,
+	WIRELESS_MODE_AUTO = 0x08,
+	WIRELESS_MODE_N_24G = 0x10,
+	WIRELESS_MODE_N_5G = 0x20,
+	WIRELESS_MODE_AC_5G = 0x40,
+	WIRELESS_MODE_AC_24G  = 0x80,
+	WIRELESS_MODE_AC_ONLY  = 0x100,
+} WIRELESS_MODE;
+
+#define _HW_MSR_STATE_NOLINK_		0x00
+#define _HW_MSR_STATE_STATION_ 		0x02
+#define _HW_MSR_STATE_AP_		0x03
+#define _HW_MSR_STATE_MONITOR_		0x04
+
+enum _hw_port {
+	HW_PORT0,
+	HW_PORT1,
+};
+
+#define CHANNEL_MAX_NUMBER						14	// 14 is the max channel number
+#define CHANNEL_MAX_NUMBER_2G					14
+#define CHANNEL_MAX_NUMBER_5G					54	// Please refer to "phy_GetChnlGroup8812A" and "Hal_ReadTxPowerInfo8812A"
+#define CHANNEL_MAX_NUMBER_5G_80M				7
+
+#define MAX_REGULATION_NUM	TXPWR_LMT_MAX_REGULATION_NUM
+
+#define MAX_2_4G_BANDWITH_NUM					2 // 20M, 40M
+#if defined(NOT_SUPPORT_RF_MULTIPATH) && (!defined(CONFIG_80211AC_VHT))
+#define MAX_RATE_SECTION_NUM					3 // CCk, OFDM, HT
+#define MAX_BASE_NUM_IN_PHY_REG_PG_2_4G			3 //  CCK:1,OFDM:1, HT:1(MCS0_MCS7)
+#else
+#define MAX_RATE_SECTION_NUM					10
+#define MAX_BASE_NUM_IN_PHY_REG_PG_2_4G			10 //  CCK:1,OFDM:1, HT:4, VHT:4
+#endif
+#define MAX_5G_BANDWITH_NUM						4
+#define MAX_BASE_NUM_IN_PHY_REG_PG_5G			9 // OFDM:1, HT:4, VHT:4
+
+enum hal_rate_mode {
+	HAL_LEGACY_MODE	= 0,
+	HAL_HT_MODE	= 1,
+	HAL_VHT_MODE	= 2,
+	HAL_HE_MODE	= 3
+};
+
+#if !defined(SUPPORT_5G_CHANNEL)
+#define TX_PWR_BY_RATE_NUM_BAND			1
+#else
+#define TX_PWR_BY_RATE_NUM_BAND			2
+#endif
+
+#if defined(NOT_SUPPORT_RF_MULTIPATH)
+#if !defined(CONFIG_80211AC_VHT)
+#define RTW_TX_PWR_BY_RATE_NUM_RF			1
+#define TX_PWR_BY_RATE_NUM_RATE			20 // CCK 1M~11M, OFDM 6M~54M, MCS0~7
+#else
+#define RTW_TX_PWR_BY_RATE_NUM_RF			1
+#define TX_PWR_BY_RATE_NUM_RATE			30 // CCK 1M~11M, OFDM 6M~54M, MCS0~7, VHT MCS0~MCS9
+#endif
+#else
+#define RTW_TX_PWR_BY_RATE_NUM_RF			4
+#define TX_PWR_BY_RATE_NUM_RATE			84
+#endif
+
+#endif //__ROM_RTW_DEFS_H_
diff --git a/os/board/rtl8720e/src/component/wifi/driver/include/rom_rtw_message.h b/os/board/rtl8720e/src/component/wifi/driver/include/rom_rtw_message.h
deleted file mode 100644
index 514bbf21c..000000000
--- a/os/board/rtl8720e/src/component/wifi/driver/include/rom_rtw_message.h
+++ /dev/null
@@ -1,95 +0,0 @@
-#ifndef _ROM_RTW_MESSAGE_
-#define _ROM_RTW_MESSAGE_
-
-#include <autoconf.h>
-#if (CONFIG_PLATFORM_AMEBA_X == 1)
-#include <platform_stdlib.h>
-#endif //CONFIG_PLATFORM_AMEBA_X
-
-extern u32 GlobalDebugEnable;
-
-// e-version
-typedef enum {
-#define ROM_E_RTW_MSGPOOL(name,str)  ROM_E_RTW_MSGP_##name,
-#include "rom_rtw_message_e.h"
-	ROM_E_RTW_MSGP_MAX
-} rom_e_rtw_msgp_t;
-
-// f-version
-typedef enum {
-#define ROM_F_RTW_MSGPOOL(name,str)  ROM_F_RTW_MSGP_##name,
-#include "rom_rtw_message_f.h"
-	ROM_F_RTW_MSGP_MAX
-} rom_f_rtw_msgp_t;
-
-#if defined(CONFIG_PLATFORM_8735B)
-char **get_rom_e_rtw_msgp_str(void);
-#define rom_e_rtw_msg_printf(name, fmt, args...) \
-	do {\
-		if(GlobalDebugEnable){\
-			char **rom_e_rtw_msgp_str_ = get_rom_e_rtw_msgp_str();\
-			printf((char*)rom_e_rtw_msgp_str_[ROM_E_RTW_MSGP_##name], ## args);\
-		}\
-	}while(0)
-#define rom_e_rtw_msg_871X_LEVEL(name, level, fmt, args...) \
-	do {\
-		if(GlobalDebugEnable){\
-			char **rom_e_rtw_msgp_str_ = get_rom_e_rtw_msgp_str();\
-			printf("\n\r");\
-			printf((char*)rom_e_rtw_msgp_str_[ROM_E_RTW_MSGP_##name], ## args);\
-		}\
-	}while(0)
-#else
-extern const char *const rom_e_rtw_msgp_str_[ROM_E_RTW_MSGP_MAX];
-#define rom_e_rtw_msg_printf(name, fmt, args...) \
-	do {\
-		if(GlobalDebugEnable){\
-			printf((char*)rom_e_rtw_msgp_str_[ROM_E_RTW_MSGP_##name], ## args);\
-		}\
-	}while(0)
-
-#define rom_e_rtw_msg_871X_LEVEL(name, level, fmt, args...) \
-	do {\
-		if(GlobalDebugEnable){\
-			printf("\n\r");\
-			printf((char*)rom_e_rtw_msgp_str_[ROM_E_RTW_MSGP_##name], ## args);\
-		}\
-	}while(0)
-#endif
-
-#if defined(CONFIG_PLATFORM_8735B)
-char **get_rom_f_rtw_msgp_str(void);
-#define rom_f_rtw_msg_printf(name, fmt, args...) \
-	do {\
-		if(GlobalDebugEnable){\
-			char **rom_f_rtw_msgp_str_ = get_rom_f_rtw_msgp_str();\
-			printf((char*)rom_f_rtw_msgp_str_[ROM_F_RTW_MSGP_##name], ## args);\
-		}\
-	}while(0)
-#define rom_f_rtw_msg_871X_LEVEL(name, level, fmt, args...) \
-	do {\
-		if(GlobalDebugEnable){\
-			char **rom_f_rtw_msgp_str_ = get_rom_f_rtw_msgp_str();\
-			printf("\n\r");\
-			printf((char*)rom_f_rtw_msgp_str_[ROM_F_RTW_MSGP_##name], ## args);\
-		}\
-	}while(0)
-#else
-extern const char *const rom_f_rtw_msgp_str_[ROM_F_RTW_MSGP_MAX];
-#define rom_f_rtw_msg_printf(name, fmt, args...) \
-	do {\
-		if(GlobalDebugEnable){\
-			printf((char*)rom_f_rtw_msgp_str_[ROM_F_RTW_MSGP_##name], ## args);\
-		}\
-	}while(0)
-
-#define rom_f_rtw_msg_871X_LEVEL(name, level, fmt, args...) \
-	do {\
-		if(GlobalDebugEnable){\
-			printf("\n\r");\
-			printf((char*)rom_f_rtw_msgp_str_[ROM_F_RTW_MSGP_##name], ## args);\
-		}\
-	}while(0)
-#endif
-
-#endif //_ROM_RTW_MESSAGE_
diff --git a/os/board/rtl8720e/src/component/wifi/driver/include/rom_rtw_message_e.h b/os/board/rtl8720e/src/component/wifi/driver/include/rom_rtw_message_e.h
deleted file mode 100644
index 122f80deb..000000000
--- a/os/board/rtl8720e/src/component/wifi/driver/include/rom_rtw_message_e.h
+++ /dev/null
@@ -1,155 +0,0 @@
-// Debug message
-// DBG_PWR_INDEX
-ROM_E_RTW_MSGPOOL(PWR_INDEX_1,	"BandWidth = %d, Rate = %d, Channel = %d\n\r")
-ROM_E_RTW_MSGPOOL(PWR_INDEX_2,	"Base = %d, DiffByRate = %d, limit = %d, DiffByTrack = %d, Tx Power = %d\n\n\r")
-// DBG_RX_INFO
-ROM_E_RTW_MSGPOOL(RX_INFO_1,	"============ Rx Info dump ===================\n")
-ROM_E_RTW_MSGPOOL(RX_INFO_2,	"bLinked = %d, RSSI_Min = %d(%%), CurrentIGI = 0x%x\n")
-ROM_E_RTW_MSGPOOL(RX_INFO_3,	"Cnt_Cck_fail = %d, Cnt_Ofdm_fail = %d, Total False Alarm = %d\n")
-ROM_E_RTW_MSGPOOL(RX_INFO_4,	"RxRate = 0x%x, RSSI_A = %d(%%), RSSI_B = %d(%%)\n")
-// DBG_TX_RATE
-ROM_E_RTW_MSGPOOL(TX_RATE_1,	"Init Rate: 0x%x\n\r")
-ROM_E_RTW_MSGPOOL(TX_RATE_2,	"%s(): mac_id=%d raid=0x%x bw=%d mask=0x%x init_rate=0x%x\n")
-// DBG_DM_RA
-ROM_E_RTW_MSGPOOL(DM_RA_1,	"==> ReadRateMask = 0x%x RAMASK[%d] = 0x%x\n")
-ROM_E_RTW_MSGPOOL(DM_RA_2,	"==> TMP_rate = %x highest_rate = 0x%02X, lowest_rate = 0x%02X\n")
-ROM_E_RTW_MSGPOOL(DM_RA_3,	"==> MacID = %d rateid = 0x%x sgi = %d bw_idx = %d\n\r")
-ROM_E_RTW_MSGPOOL(DM_RA_4,	"%s(): mac_id=%d raid=0x%x bw=%d mask=0x%x\r\n")
-// DBG_DM_DIG
-ROM_E_RTW_MSGPOOL(DM_DIG_1,	"CurrentIGI(0x%02x)\n\n")
-// DBG_PWR_TRACKING
-ROM_E_RTW_MSGPOOL(PWR_TRACKING_1,	"Thermal = 0x%02X\r\n")
-ROM_E_RTW_MSGPOOL(PWR_TRACKING_2,	"delta = %d, AVG Thermal = 0x%02X, EFUSE = 0x%02X\r\n")
-ROM_E_RTW_MSGPOOL(PWR_TRACKING_3,	"Channel = %d, CCK PwrBase = 0x%02X, HT40M PwrBase = 0x%02X, OFDMdiff = %d, 20Mdiff = %d \n\r")
-ROM_E_RTW_MSGPOOL(PWR_TRACKING_4,	"Remnant_CCKSwingIdx  = %d\n\r")
-ROM_E_RTW_MSGPOOL(PWR_TRACKING_5,	"Remnant_OFDMSwingIdx = %d\n\r")
-ROM_E_RTW_MSGPOOL(PWR_TRACKING_6,	"CCK2~11: 0x86c = 0x%08X\r\n")
-ROM_E_RTW_MSGPOOL(PWR_TRACKING_7,	"MCS7~4 : 0xe14 = 0x%08X\r\n")
-// DBG_RF_IQK
-ROM_E_RTW_MSGPOOL(RF_IQK_1,	"Path A Tx IQK Success!\n")
-ROM_E_RTW_MSGPOOL(RF_IQK_2,	"Path A Rx IQK Success!\n")
-ROM_E_RTW_MSGPOOL(RF_IQK_3,	"Path A IQK failed!\n")
-ROM_E_RTW_MSGPOOL(RF_IQK_4,	"IQK finished\n")
-ROM_E_RTW_MSGPOOL(RF_IQK_5,	"LCK finished\n")
-// DBG_DM_ADAPTIVITY
-ROM_E_RTW_MSGPOOL(DM_ADAPTIVITY_1, "IGI_Base=0x%x, TH_L2H_ini = %d, TH_EDCCA_HL_diff = %d\n")
-ROM_E_RTW_MSGPOOL(DM_ADAPTIVITY_2, "DynamicLinkAdaptivity = %d, Adaptivity_enable = %d\n")
-ROM_E_RTW_MSGPOOL(DM_ADAPTIVITY_3, "IGI=0x%x, TH_L2H_dmc = 0x%x, TH_H2L_dmc = 0x%x\n\n")
-
-// freertos_ioctl.c
-// mac_reg_dump, bb_reg_dump, rf_reg_dump
-ROM_E_RTW_MSGPOOL(MAC_REG_DUMP_1,	"\n======= MAC REG =======\n")
-ROM_E_RTW_MSGPOOL(BB_REG_DUMP_1,	"\n======= BB REG =======\n")
-ROM_E_RTW_MSGPOOL(RF_REG_DUMP_1,	"\n======= RF REG =======\n")
-ROM_E_RTW_MSGPOOL(RF_REG_DUMP_2,	"\nRF_Path(%x)\n")
-ROM_E_RTW_MSGPOOL(REG_DUMP_1,	"0x%02x ")
-ROM_E_RTW_MSGPOOL(REG_DUMP_2,	" 0x%08x ")
-ROM_E_RTW_MSGPOOL(REG_DUMP_3,	"\n")
-// 0x70 read reg
-ROM_E_RTW_MSGPOOL(READ_REG_1,	"rtw_read8(0x%x)=0x%02x\n")
-ROM_E_RTW_MSGPOOL(READ_REG_2,	"rtw_read16(0x%x)=0x%04x\n")
-ROM_E_RTW_MSGPOOL(READ_REG_3,	"rtw_read32(0x%x)=0x%08x\n")
-// 0x71 write reg
-ROM_E_RTW_MSGPOOL(WRITE_REG_1,	"rtw_write8(0x%x)=0x%02x\n")
-ROM_E_RTW_MSGPOOL(WRITE_REG_2,	"rtw_write16(0x%x)=0x%04x\n")
-ROM_E_RTW_MSGPOOL(WRITE_REG_3,	"rtw_write32(0x%x)=0x%08x\n")
-// 0x72 read bb
-ROM_E_RTW_MSGPOOL(READ_BB_1,	"read_bbreg(0x%x)=0x%x\n")
-// 0x73 write bb
-ROM_E_RTW_MSGPOOL(WRITE_BB_1,	"write_bbreg(0x%x)=0x%x\n")
-// 0x74 read rf
-ROM_E_RTW_MSGPOOL(READ_RF_1,	"read RF_reg path(0x%02x),offset(0x%x),value(0x%08x)\n")
-// 0x75 write rf
-ROM_E_RTW_MSGPOOL(WRITE_RF_1,	"write RF_reg path(0x%02x),offset(0x%x),value(0x%08x)\n")
-// 0x17 fix channel
-ROM_E_RTW_MSGPOOL(FIX_CHANNEL_1,	"=>Fixed channel to %d\n")
-ROM_E_RTW_MSGPOOL(FIX_CHANNEL_2,	"Invalid channel number(%d)\n")
-// 0x22 enable / disable power saving mode
-ROM_E_RTW_MSGPOOL(PWR_SAVE_MODE_1,	"wlan power saving mode = %s\n")
-// 0xaa fix rate
-ROM_E_RTW_MSGPOOL(FIX_RATE_1,	"chang data rate to :0x%02x\n")
-// 0xc0 get odm dbg flag
-ROM_E_RTW_MSGPOOL(GET_ODM_DBG_FLAG_1,	"get odm dbg flag : 0x%08x\n")
-// 0xc1 set odm dbg flag
-ROM_E_RTW_MSGPOOL(SET_ODM_DBG_FLAG_1,	"set odm dbg flag : 0x%08x\n")
-// 0xcc open power index debug message (power by rate, power limit, power tracking)
-ROM_E_RTW_MSGPOOL(DUMP_PWR_IDX_1,	"Fixed rate = %d\n")
-// 0xdd dump info
-ROM_E_RTW_MSGPOOL(DUMP_INFO_1,	"Tx power:\n")
-ROM_E_RTW_MSGPOOL(DUMP_INFO_2,	"CCK 1(0xe08)= 0x%x\n")
-ROM_E_RTW_MSGPOOL(DUMP_INFO_3,	"CCK 11~2(0x86c)= 0x%x\n")
-ROM_E_RTW_MSGPOOL(DUMP_INFO_4,	"OFDM 18~6(0xe00)= 0x%x\n")
-ROM_E_RTW_MSGPOOL(DUMP_INFO_5,	"OFDM 54~24(0xe04)= 0x%x\n")
-ROM_E_RTW_MSGPOOL(DUMP_INFO_6,	"MCS 3~0(0xe10)= 0x%x\n")
-ROM_E_RTW_MSGPOOL(DUMP_INFO_7,	"MCS 7~4(0xe14)= 0x%x\n")
-ROM_E_RTW_MSGPOOL(DUMP_INFO_8,	"Country code: 0x%x\n")
-// 0xee turn on/off dynamic funcs
-ROM_E_RTW_MSGPOOL(DM_FUNC_FLAG_1,	" === DMFlag(0x%08x) === \n")
-ROM_E_RTW_MSGPOOL(DM_FUNC_FLAG_2,	"extra_arg = 0 - disable all dynamic func\n")
-ROM_E_RTW_MSGPOOL(DM_FUNC_FLAG_3,	"extra_arg = 1 - enable all dynamic func\n")
-ROM_E_RTW_MSGPOOL(DM_FUNC_FLAG_4,	"extra_arg = 2 - disable DIG\n")
-ROM_E_RTW_MSGPOOL(DM_FUNC_FLAG_5,	"extra_arg = 3 - enable DIG\n")
-ROM_E_RTW_MSGPOOL(DM_FUNC_FLAG_6,	"extra_arg = 4 - disable tx power tracking\n")
-ROM_E_RTW_MSGPOOL(DM_FUNC_FLAG_7,	"extra_arg = 5 - enable tx power tracking\n")
-ROM_E_RTW_MSGPOOL(DM_FUNC_FLAG_8,	"extra_arg = 6 - disable adaptivity\n")
-ROM_E_RTW_MSGPOOL(DM_FUNC_FLAG_9,	"extra_arg = 7 - enable adaptivity\n")
-
-// lxbus_ops.c
-ROM_E_RTW_MSGPOOL(RX_MPDU_1,	"Drop packet! crc_err = %d, icv_err = %d, rx_pkt_len = %d, skb_pkt_len = %d\n")
-
-// wlan driver DBG_871X_LEVEL
-#define ROM_E_RTW_MSGPOOL_871X(name,str) ROM_E_RTW_MSGPOOL(name,DRIVER_PREFIX str)
-// rtw_ap.c
-ROM_E_RTW_MSGPOOL_871X(AP_TIMEOUT_CHK_1,	"Asoc expire "MAC_FMT"\n")
-// rtw_intfs.c
-ROM_E_RTW_MSGPOOL_871X(INIT_DRV_SW_1,	"The driver is for MP\n")
-// rtw_ioctl_set.c
-ROM_E_RTW_MSGPOOL_871X(SET_BSSID_1,	"set BSSID: %02x:%02x:%02x:%02x:%02x:%02x\n")
-ROM_E_RTW_MSGPOOL_871X(SET_SSID_1,	"set ssid [%s] \n")
-// rtw_mlme_ext.c
-ROM_E_RTW_MSGPOOL_871X(ON_BEACON_1,	"ap has changed, disconnect now\n ")
-ROM_E_RTW_MSGPOOL_871X(ON_AUTH_1,	"+OnAuth: "MAC_FMT"\n")
-ROM_E_RTW_MSGPOOL_871X(ON_AUTH_2,	" Exceed the upper limit(%d) of supported clients...\n")
-ROM_E_RTW_MSGPOOL_871X(ON_AUTH_CLIENT_1,	"auth success, start assoc\n")
-ROM_E_RTW_MSGPOOL_871X(ON_ASSOC_REQ_1,	"+OnAssocReq\n")
-ROM_E_RTW_MSGPOOL_871X(ON_ASSOC_RSP_1,	"association success(res=%d)\n")
-ROM_E_RTW_MSGPOOL_871X(ON_DE_AUTH_1,	"ap recv deauth reason code(%d) sta:"MAC_FMT"\n")
-ROM_E_RTW_MSGPOOL_871X(ON_DE_AUTH_2,	"sta recv deauth reason code(%d) sta:"MAC_FMT"\n")
-ROM_E_RTW_MSGPOOL_871X(ON_DISASSOC_1,	"ap recv disassoc reason code(%d) sta:"MAC_FMT"\n")
-ROM_E_RTW_MSGPOOL_871X(ON_DISASSOC_2,	"sta recv disassoc reason code(%d) sta:"MAC_FMT"\n")
-ROM_E_RTW_MSGPOOL_871X(ISSUE_BEACON_1,	"beacon frame too large\n")
-ROM_E_RTW_MSGPOOL_871X(ISSUE_PROBERSP_1,	"probersp frame too large\n")
-ROM_E_RTW_MSGPOOL_871X(ISSUE_PROBEREQ_1,	"probereq frame too large\n")
-ROM_E_RTW_MSGPOOL_871X(ISSUE_AUTH_1,	"auth frame too large\n")
-ROM_E_RTW_MSGPOOL_871X(ISSUE_ASSOCRSP_1,	"assocrsp frame too large\n")
-ROM_E_RTW_MSGPOOL_871X(ISSUE_ASSOCREQ_1,	"assocreq frame too large\n")
-ROM_E_RTW_MSGPOOL_871X(ISSUE_NULLDATA_1,	"nulldata frame too large\n")
-ROM_E_RTW_MSGPOOL_871X(ISSUE_QOS_NULLDATA_1,	"qos nulldata frame too large\n")
-ROM_E_RTW_MSGPOOL_871X(ISSUE_DEAUTH_1,	"deauth frame too large\n")
-ROM_E_RTW_MSGPOOL_871X(ISSUE_ACTION_BA_1,	"action BA frame too large\n")
-ROM_E_RTW_MSGPOOL_871X(ISSUE_BSS_COEXIST_1,	"action BSSCoexist frame too large\n")
-ROM_E_RTW_MSGPOOL_871X(START_CLNT_AUTH_1,	"start auth to %02x:%02x:%02x:%02x:%02x:%02x\n")
-ROM_E_RTW_MSGPOOL_871X(LINKED_STATUS_CHK_1,	"no beacon for a long time, disconnect or roaming\n")
-ROM_E_RTW_MSGPOOL_871X(SETKEY_HDL_1,	"set group key to hw: alg:%d(WEP40-1 WEP104-5 TKIP-2 AES-4) keyid:%d\n")
-ROM_E_RTW_MSGPOOL_871X(SET_STAKEY_HDL_1,	"set pairwise key to hw: alg:%d(WEP40-1 WEP104-5 TKIP-2 AES-4)\n")
-ROM_E_RTW_MSGPOOL_871X(SET_STAKEY_HDL_2,	"set pairwise key to hw: alg:%d(WEP40-1 WEP104-5 TKIP-2 AES-4) for %x:%x:%x:%x:%x:%x\n")
-// rtw_p2p.c
-ROM_E_RTW_MSGPOOL_871X(P2P_BUILD_MGNT_FRAME_1,	"p2p mgnt frame too large\n")
-// rtw_psk.c
-ROM_E_RTW_MSGPOOL_871X(SEND_EAPOL_1,	"ap mode 4-1\n")
-ROM_E_RTW_MSGPOOL_871X(SEND_EAPOL_2,	"ap mode 4-3\n")
-ROM_E_RTW_MSGPOOL_871X(SEND_EAPOL_3,	"ap mode 2-1 to WPA_STA(%d)\n")
-ROM_E_RTW_MSGPOOL_871X(EAPOL_KEY_RECVD_1,	"ap mode 4-2\n")
-ROM_E_RTW_MSGPOOL_871X(EAPOL_KEY_RECVD_2,	"ap mode 4-4\n")
-ROM_E_RTW_MSGPOOL_871X(EAPOL_KEY_RECVD_3,	"ap mode 2-2 from WPA_STA(%d)\n")
-// rtw_recv.c
-ROM_E_RTW_MSGPOOL_871X(FREE_RECVFRAME_1,	"%s free_recvframe_cnt:%d > %d refree happen !!!!\n")
-// hal_com.c
-ROM_E_RTW_MSGPOOL_871X(VAR_PORT_SWITCH_1,	"port switch - port0("ADPT_FMT"), port1("ADPT_FMT")\n")
-ROM_E_RTW_MSGPOOL_871X(VAR_PORT_SWITCH_2,	"port switch - port0("ADPT_FMT"), port1("ADPT_FMT")\n")
-// osdep_service.c
-ROM_E_RTW_MSGPOOL_871X(DOWN_SEMA_1,	"%s(%p) failed, retry\n")
-
-
-#undef ROM_E_RTW_MSGPOOL
-#undef ROM_E_RTW_MSGPOOL_871X
diff --git a/os/board/rtl8720e/src/component/wifi/driver/include/rom_rtw_message_f.h b/os/board/rtl8720e/src/component/wifi/driver/include/rom_rtw_message_f.h
deleted file mode 100644
index 188175700..000000000
--- a/os/board/rtl8720e/src/component/wifi/driver/include/rom_rtw_message_f.h
+++ /dev/null
@@ -1,21 +0,0 @@
-// Debug message
-// DBG_DM_ANT_DIV
-ROM_F_RTW_MSGPOOL(DM_ANT_DIV_1, "\n*** Main_Cnt= (( %u )), Main_Cnt_CCK= (( %u )), Main_RSSI= (( %u )) \n")
-ROM_F_RTW_MSGPOOL(DM_ANT_DIV_2, "*** Aux_Cnt = (( %u )), Aux_Cnt_CCK = (( %u )), Aux_RSSI = (( %u )) \n")
-ROM_F_RTW_MSGPOOL(DM_ANT_DIV_3, "*** MAC ID:[ %u ] , TargetAnt = (( %s )), decision_type = (( %u ))\n")
-ROM_F_RTW_MSGPOOL(DM_ANT_DIV_4, "*** Phy_AntSel_A=[ %d, %d, %d] \n")
-ROM_F_RTW_MSGPOOL(DM_ANT_DIV_5, "[ Update Rx-Idle-Ant ] RxIdleAnt =%s\n")
-
-// freertos_ioctl.c
-// 0x76 read sys
-ROM_F_RTW_MSGPOOL(READ_SYS_1,	"read sys_reg(0x%x)=0x%x\n")
-// 0x77 write sys
-ROM_F_RTW_MSGPOOL(WRITE_SYS_1,	"write sys_reg(0x%x)=0x%x\n")
-// 0xdd dump info
-ROM_F_RTW_MSGPOOL(DUMP_INFO_9,	"ID: 0x%02x\n")
-
-// wlan driver DBG_871X_LEVEL
-#define ROM_F_RTW_MSGPOOL_871X(name,str) ROM_F_RTW_MSGPOOL(name,DRIVER_PREFIX str)
-
-#undef ROM_F_RTW_MSGPOOL
-#undef ROM_F_RTW_MSGPOOL_871X
diff --git a/os/board/rtl8720e/src/component/wifi/driver/include/rom_rtw_psk.h b/os/board/rtl8720e/src/component/wifi/driver/include/rom_rtw_psk.h
deleted file mode 100644
index 52cc900c3..000000000
--- a/os/board/rtl8720e/src/component/wifi/driver/include/rom_rtw_psk.h
+++ /dev/null
@@ -1,31 +0,0 @@
-/******************************************************************************
- *
- * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
- *
- * This is ROM code section.
- *
- *
- ******************************************************************************/
-#ifndef __ROM_RTW_PSK_H_
-#define __ROM_RTW_PSK_H_
-
-int rom_psk_PasswordHash(
-	unsigned char *password,
-	int passwordlength,
-	unsigned char *ssid,
-	int ssidlength,
-	unsigned char *output);
-
-void rom_psk_CalcPTK(unsigned int AuthKeyMgmt,
-					 unsigned char *addr1, unsigned char *addr2,
-					 unsigned char *nonce1, unsigned char *nonce2,
-					 unsigned char *keyin, int keyinlen,
-					 unsigned char *keyout, int keyoutlen);
-
-void rom_psk_CalcGTK(unsigned int AuthKeyMgmt,
-					 unsigned char *addr, unsigned char *nonce,
-					 unsigned char *keyin, int keyinlen,
-					 unsigned char *keyout, int keyoutlen);
-
-#endif	//__ROM_RTW_PSK_H_
-
diff --git a/os/board/rtl8720e/src/component/wifi/driver/include/rtw_rf.h b/os/board/rtl8720e/src/component/wifi/driver/include/rom_rtw_rf.h
old mode 100644
new mode 100755
similarity index 65%
rename from os/board/rtl8720e/src/component/wifi/driver/include/rtw_rf.h
rename to os/board/rtl8720e/src/component/wifi/driver/include/rom_rtw_rf.h
index ea09fdc66..87f2e6ce0
--- a/os/board/rtl8720e/src/component/wifi/driver/include/rtw_rf.h
+++ b/os/board/rtl8720e/src/component/wifi/driver/include/rom_rtw_rf.h
@@ -20,20 +20,14 @@
 #ifndef	__RTW_RF_H_
 #define __RTW_RF_H_
 
-#include <hal_pg.h>
-
 #define OFDM_PHY		1
 #define MIXED_PHY		2
 #define CCK_PHY		3
 
-#define NumRates	(13)
-
 // slot time for 11g
 #define SHORT_SLOT_TIME					9
 #define NON_SHORT_SLOT_TIME				20
 
-#define RTL8711_RF_MAX_SENS 6
-#define RTL8711_RF_DEF_SENS 4
 
 #define CENTER_CH_2G_40M_NUM	9
 #define CENTER_CH_2G_NUM		14
@@ -57,14 +51,16 @@
 #define	MAX_CHANNEL_NUM					(MAX_CHANNEL_NUM_2G + MAX_CHANNEL_NUM_5G) //14+28
 #endif
 
-#ifdef SUPPORT_5G_CHANNEL
-#ifndef NOT_SUPPORT_80M
-extern u8 center_ch_5g_80m[CENTER_CH_5G_80M_NUM];
-#endif
-extern u8 center_ch_5g_all[CENTER_CH_5G_ALL_NUM];
+#if defined(NOT_SUPPORT_RF_MULTIPATH)
+#define RTW_MAX_RF_PATH					1
+#define MAX_TX_COUNT				1
+#else
+#define RTW_MAX_RF_PATH					2	// Max 4 for ss larger than 2
+#define MAX_TX_COUNT				4	//It must always set to 4, otherwise read efuse table secquence will be wrong.
 #endif
+#define	MAX_CHNL_GROUP_24G		6 		// ch1~2, ch3~5, ch6~8,ch9~11,ch12~13,CH 14 total three groups
+#define	MAX_CHNL_GROUP_5G		14
 
-//#define NUM_REGULATORYS	21
 #define NUM_REGULATORYS	1
 
 //Country codes
@@ -72,15 +68,6 @@ extern u8 center_ch_5g_all[CENTER_CH_5G_ALL_NUM];
 #define EUROPE						0x1 //temp, should be provided later	
 #define JAPAN						0x2 //temp, should be provided later	
 
-struct	regulatory_class {
-	u32	starting_freq;					//MHz,
-	u8	channel_set[MAX_CHANNEL_NUM];
-	u8	channel_cck_power[MAX_CHANNEL_NUM];//dbm
-	u8	channel_ofdm_power[MAX_CHANNEL_NUM];//dbm
-	u8	txpower_limit;  				//dbm
-	u8	channel_spacing;				//MHz
-	u8	modem;
-};
 
 typedef enum _CAPABILITY {
 	cESS			= 0x0001,
@@ -108,41 +95,22 @@ enum	_REG_PREAMBLE_MODE {
 };
 
 
-enum _RTL8712_RF_MIMO_CONFIG_ {
-	RTL8712_RFCONFIG_1T = 0x10,
-	RTL8712_RFCONFIG_2T = 0x20,
-	RTL8712_RFCONFIG_1R = 0x01,
-	RTL8712_RFCONFIG_2R = 0x02,
-	RTL8712_RFCONFIG_1T1R = 0x11,
-	RTL8712_RFCONFIG_1T2R = 0x12,
-	RTL8712_RFCONFIG_TURBO = 0x92,
-	RTL8712_RFCONFIG_2T2R = 0x22
-};
 
+struct center_chs_ent_t {
+	u8 ch_num;
+	const u8 *chs;
+};
 
-typedef enum _RF90_RADIO_PATH {
-	RF90_PATH_A = 0,			//Radio Path A
-	RF90_PATH_B = 1,			//Radio Path B
-	RF90_PATH_C = 2,			//Radio Path C
-	RF90_PATH_D = 3 		//Radio Path D
-				  //RF90_PATH_MAX 			//Max RF number 90 support
-} RF90_RADIO_PATH_E, *PRF90_RADIO_PATH_E;
-
-typedef enum _VHT_DATA_SC {
-	VHT_DATA_SC_DONOT_CARE = 0,
-	VHT_DATA_SC_20_UPPER_OF_80MHZ = 1,
-	VHT_DATA_SC_20_LOWER_OF_80MHZ = 2,
-	VHT_DATA_SC_20_UPPERST_OF_80MHZ = 3,
-	VHT_DATA_SC_20_LOWEST_OF_80MHZ = 4,
-	VHT_DATA_SC_20_RECV1 = 5,
-	VHT_DATA_SC_20_RECV2 = 6,
-	VHT_DATA_SC_20_RECV3 = 7,
-	VHT_DATA_SC_20_RECV4 = 8,
-	VHT_DATA_SC_40_UPPER_OF_80MHZ = 9,
-	VHT_DATA_SC_40_LOWER_OF_80MHZ = 10,
-} VHT_DATA_SC, *PVHT_DATA_SC_E;
+struct op_chs_ent_t {
+	u8 ch_num;
+	const u8 *chs;
+};
 
+#ifndef _RTW_RF_C_
 extern const u8 _ch_width_to_bw_cap[];
+extern u8 center_ch_5g_80m[CENTER_CH_5G_80M_NUM];
+extern u8 center_ch_5g_all[CENTER_CH_5G_ALL_NUM];
+#endif
 #define ch_width_to_bw_cap(bw) (((bw) < CHANNEL_WIDTH_MAX) ? _ch_width_to_bw_cap[(bw)] : 0)
 
 #define RF_TYPE_VALID(rf_type) (rf_type < RF_TYPE_MAX)
@@ -154,34 +122,21 @@ extern const u8 _rf_type_to_rf_rx_cnt[];
 #define rf_type_to_rf_rx_cnt(rf_type) (RF_TYPE_VALID(rf_type) ? _rf_type_to_rf_rx_cnt[rf_type] : 0)
 
 #define BB_GAIN_2G 0
-#ifdef SUPPORT_5G_CHANNEL
 #define BB_GAIN_5GLB1 1
 #define BB_GAIN_5GLB2 2
 #define BB_GAIN_5GMB1 3
 #define BB_GAIN_5GMB2 4
 #define BB_GAIN_5GHB 5
-#endif
 
-#ifdef SUPPORT_5G_CHANNEL
-#define BB_GAIN_NUM 6
-#else
-#define BB_GAIN_NUM 1
-#endif
-
-u32 rtw_ch2freq(u32 ch);
-u32 rtw_freq2ch(u32 freq);
+u32 wifi_rom_ch2freq(u32 ch);
+u32 wifi_rom_freq2ch(u32 freq);
 
 /* only check channel ranges */
 #define rtw_is_2g_ch(ch) (ch >= 1 && ch <= 14)
 #define rtw_is_5g_ch(ch) ((ch) >= 36 && (ch) <= 177)
-#define rtw_is_same_band(a, b) \
-	((rtw_is_2g_ch(a) && rtw_is_2g_ch(b)) \
-	|| (rtw_is_5g_ch(a) && rtw_is_5g_ch(b)))
 
-#define rtw_is_5g_band1(ch) ((ch) >= 36 && (ch) <= 48)
-#define rtw_is_5g_band2(ch) ((ch) >= 52 && (ch) <= 64)
-#define rtw_is_5g_band3(ch) ((ch) >= 100 && (ch) <= 144)
-#define rtw_is_5g_band4(ch) ((ch) >= 149 && (ch) <= 177)
 
-#endif //_RTL8711_RF_H_
+u8 wifi_rom_get_op_chs_by_cch_bw(u8 cch, u8 bw, u8 **op_chs, u8 *op_ch_num);
+
+#endif
 
diff --git a/os/board/rtl8720e/src/component/wifi/driver/include/rom_rtw_security.h b/os/board/rtl8720e/src/component/wifi/driver/include/rom_rtw_security.h
deleted file mode 100644
index 97e944988..000000000
--- a/os/board/rtl8720e/src/component/wifi/driver/include/rom_rtw_security.h
+++ /dev/null
@@ -1,97 +0,0 @@
-/******************************************************************************
- *
- * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
- *
- * This is ROM code section.
- *
- *
- ******************************************************************************/
-#ifndef __ROM_RTW_SECURITY_H_
-#define __ROM_RTW_SECURITY_H_
-
-struct mic_data {
-	u32  K0, K1;         // Key
-	u32  L, R;           // Current state
-	u32  M;              // Message accumulator (single word)
-	u32     nBytesInM;      // # bytes in M
-};
-
-union  u_crc {
-	unsigned char	ch[4];
-	int i;
-};
-
-//===============================
-// WEP related
-//===============================
-void wep_80211_encrypt(
-	u8 *pframe, u32 wlan_hdr_len, \
-	u32 iv_len, u32 payload_len, \
-	u8 *key, u32 key_len);
-
-u8 wep_80211_decrypt(
-	u8 *pframe, u32 wlan_hdr_len,
-	u32 iv_len, u32 payload_len,
-	u8 *key, u32 key_len,
-	union u_crc *pcrc\
-);
-
-//===============================
-// TKIP related
-//===============================
-void tkip_80211_encrypt(
-	u8 *pframe, u32 wlan_hdr_len, \
-	u32 iv_len, u32 payload_len, \
-	u8 *key, u32 key_len, \
-	u8 *ta);
-
-u8 tkip_80211_decrypt(
-	u8 *pframe, u32 wlan_hdr_len, \
-	u32 iv_len, u32 payload_len, \
-	u8 *key, u32 key_len, \
-	u8 *ta, union u_crc *pcrc);
-
-void tkip_micappendbyte(struct mic_data *pmicdata, u8 b);
-void rtw_secmicsetkey(struct mic_data *pmicdata, u8 *key);
-void rtw_secmicappend(struct mic_data *pmicdata, u8 *src, u32 nbytes);
-void rtw_secgetmic(struct mic_data *pmicdata, u8 *dst);
-void rtw_seccalctkipmic(u8 *key, u8 *header, u8 *data, u32 data_len, u8 *mic_code, u8 pri);
-void tkip_phase1(u16 *p1k, const u8 *tk, const u8 *ta, u32 iv32);
-void tkip_phase2(u8 *rc4key, const u8 *tk, const u16 *p1k, u16 iv16);
-
-
-//===============================
-// AES related
-//===============================
-void aes1_encrypt(u8 *key, u8 *data, u8 *ciphertext);
-#ifdef CONFIG_IEEE80211W
-void aesccmp_construct_mic_iv_ram(
-	u8 *mic_iv, sint qc_exists, sint a4_exists,
-	u8 *mpdu, uint payload_length, u8 *pn_vector, uint frtype);
-void aesccmp_construct_mic_header1_ram(u8 *mic_header1, sint header_length, u8 *mpdu, uint frtype);
-void aesccmp_construct_ctr_preload_ram(
-	u8 *ctr_preload, sint a4_exists, sint qc_exists,
-	u8 *mpdu, u8 *pn_vector, sint c, uint frtype);
-#else
-void aesccmp_construct_mic_iv(
-	u8 *mic_iv, sint qc_exists, sint a4_exists,
-	u8 *mpdu, uint payload_length, u8 *pn_vector);
-void aesccmp_construct_mic_header1(u8 *mic_header1, sint header_length, u8 *mpdu);
-void aesccmp_construct_ctr_preload(
-	u8 *ctr_preload, sint a4_exists, sint qc_exists,
-	u8 *mpdu, u8 *pn_vector, sint c);
-#endif
-void aesccmp_construct_mic_header2(
-	u8 *mic_header2, u8 *mpdu, sint a4_exists, sint qc_exists);
-
-u32 aes_80211_encrypt(
-	u8 *pframe, u32 wlan_hdr_len, \
-	u32 payload_len, u8 *key, \
-	u32 frame_type);
-
-u32 aes_80211_decrypt(
-	u8 *pframe, u32 wlan_hdr_len, \
-	u32 payload_len, u8 *key, \
-	u32 frame_type);
-#endif	//__ROM_RTW_SECURITY_H_
-
diff --git a/os/board/rtl8720e/src/component/wifi/driver/include/rom_rtw_structs.h b/os/board/rtl8720e/src/component/wifi/driver/include/rom_rtw_structs.h
new file mode 100755
index 000000000..8f180e1de
--- /dev/null
+++ b/os/board/rtl8720e/src/component/wifi/driver/include/rom_rtw_structs.h
@@ -0,0 +1,300 @@
+#ifndef __ROM_RTW_STRUCTS_H_
+#define __ROM_RTW_STRUCTS_H_
+
+/* Fasten in ROM CODE, revise cautiously. */
+typedef struct _RT_CHANNEL_PLAN_MAP {
+	unsigned char	ChannelPlan;
+	unsigned char	Index2G;
+	unsigned char	Index5G;
+	unsigned char	PwrLmt2G;
+	unsigned char	PwrLmt5G;
+} RT_CHANNEL_PLAN_MAP;
+
+typedef struct _RT_CHANNEL_PLAN_2G {
+	unsigned char	Channel[MAX_CHANNEL_NUM_2G];
+	unsigned char	Len;
+} RT_CHANNEL_PLAN_2G;
+
+typedef struct _RT_CHANNEL_PLAN_5G {
+	unsigned char	Channel[MAX_CHANNEL_NUM_5G];
+	unsigned char	Len;
+} RT_CHANNEL_PLAN_5G;
+
+typedef struct _RT_CHANNEL_INFO {
+	uint8_t		ChannelNum;		// The channel number.
+	uint8_t		ScanType;		// Scan type such as passive or active scan. _RT_SCAN_TYPE
+	uint32_t		rx_count;
+	uint8_t		hidden_bss_cnt; /* per scan count */
+	uint8_t		pscan_config;
+} RT_CHANNEL_INFO;
+
+typedef struct _TxPowerInfo24G {
+	u8 IndexCCK_Base[RTW_MAX_RF_PATH][MAX_CHNL_GROUP_24G];
+	u8 IndexBW40_Base[RTW_MAX_RF_PATH][MAX_CHNL_GROUP_24G];
+	//If only one tx, only BW20 and OFDM are used.
+	s8 OFDM_Diff[RTW_MAX_RF_PATH][MAX_TX_COUNT];
+	s8 BW20_Diff[RTW_MAX_RF_PATH][MAX_TX_COUNT];
+#if !defined(NOT_SUPPORT_RF_MULTIPATH)
+	s8 CCK_Diff[RTW_MAX_RF_PATH][MAX_TX_COUNT];
+	s8 BW40_Diff[RTW_MAX_RF_PATH][MAX_TX_COUNT];
+#endif
+} TxPowerInfo24G, *PTxPowerInfo24G;
+
+#ifdef SUPPORT_5G_CHANNEL
+typedef struct _TxPowerInfo5G {
+	u8 IndexBW40_Base[RTW_MAX_RF_PATH][MAX_CHNL_GROUP_5G];
+	/* If only one tx, only BW20, OFDM, BW80 and BW160 are used. */
+	s8 OFDM_Diff[RTW_MAX_RF_PATH][MAX_TX_COUNT];
+	s8 BW20_Diff[RTW_MAX_RF_PATH][MAX_TX_COUNT];
+	s8 BW40_Diff[RTW_MAX_RF_PATH][MAX_TX_COUNT];
+	s8 BW80_Diff[RTW_MAX_RF_PATH][MAX_TX_COUNT];
+	s8 BW160_Diff[RTW_MAX_RF_PATH][MAX_TX_COUNT];
+} TxPowerInfo5G, *PTxPowerInfo5G;
+#endif
+
+struct halphy_data_t {
+#if (PHYDM_VERSION < 3)
+	s8	TxPwrByRateOffset[TX_PWR_BY_RATE_NUM_BAND][RTW_TX_PWR_BY_RATE_NUM_RF][RTW_TX_PWR_BY_RATE_NUM_RF][TX_PWR_BY_RATE_NUM_RATE];
+	u8	Index24G_CCK_Base[RTW_MAX_RF_PATH][CHANNEL_MAX_NUMBER];
+	u8	Index24G_BW40_Base[RTW_MAX_RF_PATH][CHANNEL_MAX_NUMBER];
+	//If only one tx, only BW20 and OFDM are used.
+	s8	OFDM_24G_Diff[RTW_MAX_RF_PATH][MAX_TX_COUNT];
+	s8	BW20_24G_Diff[RTW_MAX_RF_PATH][MAX_TX_COUNT];
+#if !defined(NOT_SUPPORT_RF_MULTIPATH)
+	s8	CCK_24G_Diff[RTW_MAX_RF_PATH][MAX_TX_COUNT];
+	s8	BW40_24G_Diff[RTW_MAX_RF_PATH][MAX_TX_COUNT];
+#endif
+	/* 5G TX power info for target TX power*/
+#if defined(SUPPORT_5G_CHANNEL)
+	u8	Index5G_BW40_Base[RTW_MAX_RF_PATH][CENTER_CH_5G_ALL_NUM];
+#if !defined(NOT_SUPPORT_80M)
+	u8	Index5G_BW80_Base[RTW_MAX_RF_PATH][CENTER_CH_5G_80M_NUM];
+#endif
+	s8	OFDM_5G_Diff[RTW_MAX_RF_PATH][MAX_TX_COUNT];
+	s8	BW20_5G_Diff[RTW_MAX_RF_PATH][MAX_TX_COUNT];
+	s8	BW40_5G_Diff[RTW_MAX_RF_PATH][MAX_TX_COUNT];
+#if !defined(NOT_SUPPORT_80M)
+	s8	BW80_5G_Diff[RTW_MAX_RF_PATH][MAX_TX_COUNT];
+#endif
+#endif
+	/* 2 Power Limit Table */
+	/* Power Limit Table for 2.4G */
+	s8	TxPwrLimit_2_4G[MAX_REGULATION_NUM][MAX_2_4G_BANDWITH_NUM][MAX_RATE_SECTION_NUM][CHANNEL_MAX_NUMBER_2G][RTW_MAX_RF_PATH];
+#if defined(SUPPORT_5G_CHANNEL)
+	/* Power Limit Table for 5G */
+	s8	TxPwrLimit_5G[MAX_REGULATION_NUM][MAX_5G_BANDWITH_NUM][MAX_RATE_SECTION_NUM][CHANNEL_MAX_NUMBER_5G][RTW_MAX_RF_PATH];
+#endif
+	/* Store the original power by rate value of the base of each rate section of rf path A & B */
+	u8	TxPwrByRateBase2_4G[RTW_TX_PWR_BY_RATE_NUM_RF][RTW_TX_PWR_BY_RATE_NUM_RF][MAX_BASE_NUM_IN_PHY_REG_PG_2_4G];
+#if defined(SUPPORT_5G_CHANNEL)
+	u8	TxPwrByRateBase5G[RTW_TX_PWR_BY_RATE_NUM_RF][RTW_TX_PWR_BY_RATE_NUM_RF][MAX_BASE_NUM_IN_PHY_REG_PG_5G];
+#endif
+#endif // (PHYDM_VERSION < 3)
+};
+
+struct wps_priv {
+	uint8_t *wps_probe_req_ie;
+	uint16_t wps_probe_req_ie_len;
+	uint8_t *wps_assoc_req_ie;
+	uint16_t wps_assoc_req_ie_len;
+
+	uint8_t *wps_beacon_ie;
+	uint8_t *wps_probe_resp_ie;
+	uint8_t *wps_assoc_resp_ie; // for CONFIG_IOCTL_CFG80211, this IE could include p2p ie
+
+	uint16_t wps_beacon_ie_len;
+	uint16_t wps_probe_resp_ie_len;
+	uint16_t wps_assoc_resp_ie_len;
+};
+
+struct init_chset_parms {
+	u8	band_type_support;
+	u8	*pRegulation2_4G;
+	u8	*pRegulation5G;
+	u8	ChannelPlan;
+	u8	country_code;
+};
+
+struct update_mode_parms {
+	u8	*SupportedRates;
+	u8	HT_info_enable;
+	u8	HT_caps_enable;
+	u8	cur_channel;
+	u8	he_option;
+	u8	*pHT_enable;
+	u8	*pcur_wireless_mode;
+	u8	wireless_mode_support;
+	u8	*puser_tx_rate;
+	u8 ht_enable;
+	u8	*cur_ch_offset;
+	u8 ht_option;
+	u8 qos_option;
+};
+
+struct security_ie_set {
+	u8 *supplicant_ie;
+	u8 *rsnxe_ie;
+	u8 *pmkid;
+	u8 h2e;
+	u32 ndisauthmode;
+};
+
+struct singal_stat_param {
+	u8 avg_signal_snr;
+	u8 avg_signal_strength;
+	u8 avg_signal_qual;
+	int RxSNRdB;
+	u8 signal_strength;
+	u8 signal_qual;
+	u8 tmp_snr;
+	u32 tmp_s;
+	u32 tmp_q;
+};
+
+struct fill_wlan_hdr_parms {
+	u8	*pstart;
+	u8	*paddr1;
+	u8	*paddr2;
+	u8	*paddr3;
+	u16	frame_ctl;
+	u16	*pseq;
+	u16	frame_subtype;
+	u16	*phdrlen;
+	u32	*ppktlen;
+};
+
+struct bcn_info_param {
+	/* these infor get from rtw_get_encrypt_info when
+	 * 	 * translate scan to UI */
+	u8	encryp_protocol;	//ENCRYP_PROTOCOL_E: OPEN/WEP/WPA/WPA2/WAPI
+	int	group_cipher;		//WPA/WPA2 group cipher
+	int	pairwise_cipher;	//WPA/WPA2/WEP pairwise cipher
+	int	is_8021x;
+	u8 is_1M_beacon;		// check if the beacon uses 1M data rate
+
+	/* bwmode 20/40 and ch_offset UP/LOW */
+	unsigned short 	ht_cap_info;
+	unsigned char	ht_info_infos_0;
+};
+
+struct network_param {
+	u32	*BeaconPeriod;
+	u8 *Ssid;
+	u32  *SsidLength;
+	u32           *DSConfig;
+	unsigned char *SupportedRates;
+	u32 *Privacy;
+	u8 *IEs;
+	u32 IELength;
+};
+
+struct securitypriv_parms {
+	u32 *dot11PrivacyAlgrthm;
+	u32 *ndisauthtype;
+	u32 *dot118021XGrpPrivacy;
+	u32 *AuthKeyMgmt;
+	u8 *ieee80211w;
+	u32 *wep_enable;
+	u32 *dot11AuthAlgrthm;
+
+	unsigned int *wpa_psk;//0:disable, bit(0): WPA, bit(1):WPA2
+	unsigned int *wpa_group_cipher;
+	unsigned int *wpa2_group_cipher;
+	unsigned int *wpa_pairwise_cipher;
+	unsigned int *wpa2_pairwise_cipher;
+
+	u8 *supplicant_ie;
+
+	unsigned char rtw_cmd_tsk_spt_wap3;
+};
+
+struct stainfo_parms {
+	uint *qos_option;
+	u16 *capability;
+	u32 *flags;
+
+	int *dot8021xalg;//0:disable, 1:psk, 2:802.1x
+	int *wpa_psk;//0:disable, bit(0): WPA, bit(1):WPA2
+	int *wpa_group_cipher;
+	int *wpa2_group_cipher;
+	int *wpa_pairwise_cipher;
+	int *wpa2_pairwise_cipher;
+
+	u8 *wpa_ie;
+	u8 wpa_ie_len;
+
+	u8 *qos_info;
+
+	u8 *max_sp_len;
+	u8 *uapsd_bk;//BIT(0): Delivery enabled, BIT(1): Trigger enabled
+	u8 *uapsd_be;
+	u8 *uapsd_vi;
+	u8 *uapsd_vo;
+	u8 *has_legacy_ac;
+
+	u8 *bssrateset;
+	u32	*bssratelen;
+
+	u8 *ht_cap;
+	u8 ht_cap_len;
+};
+
+struct issue_assoc_req_param {
+	struct network_param net_param;
+
+	u8 *supported_rateset;
+	u8 rateset_len;
+	RT_CHANNEL_INFO *channel_set;
+
+	u8 cur_channel;
+};
+
+struct issue_assoc_req_param_2 {
+	struct network_param net_param;
+	u8 wps_phase;
+	u8 ht_option;
+	u8 vht_option;
+	u8 he_option;
+};
+
+
+struct on_assoc_req_param {
+	struct securitypriv_parms secure_params;
+	struct network_param net_param;
+	struct stainfo_parms sta_param;
+	struct update_mode_parms mode_param;
+	struct wps_priv *wpspriv;
+};
+
+struct issue_assoc_rsp_param {
+	u8 *IEs;
+	u32 IELength;
+	u8 *bssrateset;
+	u32 bssratelen;
+	u32 sta_flags;
+	u8 ht_option;
+	u8 qos_option;
+
+	struct wps_priv *wpspriv;
+};
+
+struct dot11w_action_params {
+	unsigned char *ra;
+	unsigned char *bssid;
+	unsigned char *sa;
+	u16 *mgnt_seq;
+	u32 *pktlen;
+	unsigned char action;
+	unsigned short tid;
+	u16	*sa_query_seq;
+};
+
+struct signal_stat {
+	u8	update_req;		//used to indicate
+	u8	avg_val;		//avg of valid elements
+	u8	latest_val;		//latest valid elements
+	u32	total_num;		//num of valid elements
+	u32	total_val;		//sum of valid elements
+};
+
+#endif //__ROM_RTW_STRUCTS_H_
diff --git a/os/board/rtl8720e/src/component/wifi/driver/include/rom_sha1.h b/os/board/rtl8720e/src/component/wifi/driver/include/rom_sha1.h
deleted file mode 100644
index fd78d15ae..000000000
--- a/os/board/rtl8720e/src/component/wifi/driver/include/rom_sha1.h
+++ /dev/null
@@ -1,50 +0,0 @@
-#ifndef _ROM_SHA1_
-#define _ROM_SHA1_
-
-
-#ifndef _SHA_enum_
-#define _SHA_enum_
-enum {
-	shaSuccess = 0,
-	shaNull,            /* Null pointer parameter */
-	shaInputTooLong,    /* input data too long */
-	shaStateError       /* called Input after Result */
-};
-#endif
-
-
-#define SHA1HashSize 20
-
-/*
- *  This structure will hold context information for the SHA-1
- *  hashing operation
- */
-typedef struct SHA1Context {
-	u32 Intermediate_Hash[SHA1HashSize / 4]; /* Message Digest  */
-
-	u32 Length_Low;            /* Message length in bits      */
-	u32 Length_High;           /* Message length in bits      */
-
-	/* Index into message block array   */
-	u16 Message_Block_Index;
-	u8 Message_Block[64];      /* 512-bit message blocks      */
-
-	int Computed;               /* Is the digest computed?         */
-	int Corrupted;             /* Is the message digest corrupted? */
-} SHA1Context;
-
-
-/*
- *  Function Prototypes
- */
-
-
-int rt_sha1_init(SHA1Context *);
-int rt_sha1_update(SHA1Context *, const u8 *, unsigned int);
-int rt_sha1_finish(SHA1Context *, u8 Message_Digest[SHA1HashSize]);
-
-void rt_hmac_sha1(unsigned char *text, int text_len, unsigned char *key,
-				  int key_len, unsigned char *digest);
-
-
-#endif //_ROM_SHA1_
diff --git a/os/board/rtl8720e/src/component/wifi/driver/include/rtl8195a_hal.h b/os/board/rtl8720e/src/component/wifi/driver/include/rtl8195a_hal.h
deleted file mode 100644
index d3afe0681..000000000
--- a/os/board/rtl8720e/src/component/wifi/driver/include/rtl8195a_hal.h
+++ /dev/null
@@ -1,518 +0,0 @@
-/******************************************************************************
- *
- * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of version 2 of the GNU General Public License as
- * published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
- * more details.
- *
- * You should have received a copy of the GNU General Public License along with
- * this program; if not, write to the Free Software Foundation, Inc.,
- * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
- *
- *
- ******************************************************************************/
-
-#ifndef __RTL8195A_HAL_H__
-#define __RTL8195A_HAL_H__
-
-#include "drv_types.h"
-#include "rtl8195a/rtl8195a_pmu_task.h"
-#include "hal_data.h"
-
-#include "rtl8195a/rtl8195a_spec.h"
-#include "rtl8195a/rtl8195a_rf.h"
-#include "rtl8195a/rtl8195a_dm.h"
-#include "rtl8195a/rtl8195a_recv.h"
-#include "rtl8195a/rtl8195a_xmit.h"
-#include "rtl8195a/rtl8195a_cmd.h"
-#include "rtl8195a/rtl8195a_pmu_cmd.h"
-#include "rtl8195a/rtl8195a_led.h"
-#include "rtl8195a/Hal8195APwrSeq.h"
-#include "rtl8195a/Hal8195APhyReg.h"
-#include "rtl8195a/Hal8195APhyCfg.h"
-#include "rtl8195a/rom_Hal8195APhyCfg.h"
-
-#include "../src/hal/OUTSRC/phydm_precomp.h"
-
-#define FW_8723B_SIZE			0x8000
-#define FW_8723B_START_ADDRESS	0x1000
-#define FW_8723B_END_ADDRESS		0x1FFF //0x5FFF
-
-#define IS_FW_HEADER_EXIST_8723B(_pFwHdr)	((le16_to_cpu(_pFwHdr->Signature)&0xFFF0) == 0x5300)
-
-typedef struct _RT_FIRMWARE {
-	FIRMWARE_SOURCE	eFWSource;
-	u8			*szFwBuffer;
-	u32			ulFwLength;
-
-	u8			*szBTFwBuffer;
-	u32			ulBTFwLength;
-
-#ifdef CONFIG_WOWLAN
-	u8			*szWoWLANFwBuffer;
-	u32			ulWoWLANFwLength;
-#endif //CONFIG_WOWLAN
-} RT_FIRMWARE_8723B, *PRT_FIRMWARE_8723B;
-
-//
-// This structure must be cared byte-ordering
-//
-// Added by tynli. 2009.12.04.
-typedef struct _RT_8723B_FIRMWARE_HDR {
-	// 8-byte alinment required
-
-	//--- LONG WORD 0 ----
-	u16		Signature;	// 92C0: test chip; 92C, 88C0: test chip; 88C1: MP A-cut; 92C1: MP A-cut
-	u8		Category;	// AP/NIC and USB/PCI
-	u8		Function;	// Reserved for different FW function indcation, for further use when driver needs to download different FW in different conditions
-	u16		Version;		// FW Version
-	u8		Subversion;	// FW Subversion, default 0x00
-	u16		Rsvd1;
-
-
-	//--- LONG WORD 1 ----
-	u8		Month;	// Release time Month field
-	u8		Date;	// Release time Date field
-	u8		Hour;	// Release time Hour field
-	u8		Minute;	// Release time Minute field
-	u16		RamCodeSize;	// The size of RAM code
-	u16		Rsvd2;
-
-	//--- LONG WORD 2 ----
-	u32		SvnIdx;	// The SVN entry index
-	u32		Rsvd3;
-
-	//--- LONG WORD 3 ----
-	u32		Rsvd4;
-	u32		Rsvd5;
-} RT_8723B_FIRMWARE_HDR, *PRT_8723B_FIRMWARE_HDR;
-
-#define DRIVER_EARLY_INT_TIME_8195A         0x05 // 5ms
-#define BCN_DMA_ATIME_INT_TIME_8195A        0x02 // 2ms
-
-// for 8195A
-// TX 32K, RX 16K, Page size 128B for TX, 8B for RX
-#define PAGE_SIZE_TX_8195A                  128
-#define PAGE_SIZE_RX_8195A                  8
-
-#define RX_DMA_SIZE_8195A                   0x4000	// 16K
-#define RX_DMA_RESERVED_SIZE_8195A          0x80	// 128B, reserved for tx report
-#define RX_DMA_BOUNDARY_8195A               (RX_DMA_SIZE_8195A - RX_DMA_RESERVED_SIZE_8195A - 1)
-
-
-// Note: We will divide number of page equally for each queue other than public queue!
-
-//For General Reserved Page Number(Beacon Queue is reserved page)
-//Beacon:2, PS-Poll:1, Null Data:1,Qos Null Data:1,BT Qos Null Data:1
-#ifdef CONFIG_WLAN_HAL_TEST
-#define BCNQ_PAGE_NUM_8195A             0x00
-#else
-#define BCNQ_PAGE_NUM_8195A             0x08
-#endif
-
-#ifdef CONFIG_CONCURRENT_MODE
-#define BCNQ1_PAGE_NUM_8195A            0x04
-#else
-#define BCNQ1_PAGE_NUM_8195A            0x00
-#endif
-
-//For WoWLan , more reserved page
-//ARP Rsp:1, RWC:1, GTK Info:1,GTK RSP:2,GTK EXT MEM:2
-#ifdef CONFIG_WOWLAN
-#define WOWLAN_PAGE_NUM_8195A           0x07
-#else
-#define WOWLAN_PAGE_NUM_8195A           0x00
-#endif
-
-#ifdef CONFIG_WLAN_HAL_TEST
-#define TX_TOTAL_PAGE_NUMBER_8195A      0x40
-#define TX_PAGE_BOUNDARY_8195A          (TX_TOTAL_PAGE_NUMBER_8195A + 1)
-#else
-#define TX_TOTAL_PAGE_NUMBER_8195A      (0xFF - BCNQ_PAGE_NUM_8195A - BCNQ1_PAGE_NUM_8195A - WOWLAN_PAGE_NUM_8195A)
-#define TX_PAGE_BOUNDARY_8195A          (TX_TOTAL_PAGE_NUMBER_8195A + 1)
-#endif
-
-#define WMM_NORMAL_TX_TOTAL_PAGE_NUMBER TX_TOTAL_PAGE_NUMBER_8195A
-#define WMM_NORMAL_TX_PAGE_BOUNDARY		(WMM_NORMAL_TX_TOTAL_PAGE_NUMBER + 1)
-
-// For Normal Chip Setting
-// (HPQ + LPQ + NPQ + PUBQ) shall be TX_TOTAL_PAGE_NUMBER_8195A
-#ifdef CONFIG_WLAN_HAL_TEST
-#define NORMAL_PAGE_NUM_HPQ_8195A		0x10
-#define NORMAL_PAGE_NUM_LPQ_8195A		0x10
-#define NORMAL_PAGE_NUM_NPQ_8195A		0x10
-#else
-#define NORMAL_PAGE_NUM_HPQ_8195A		0x0C
-#define NORMAL_PAGE_NUM_LPQ_8195A		0x02
-#define NORMAL_PAGE_NUM_NPQ_8195A		0x02
-#endif
-
-// Note: For Normal Chip Setting, modify later
-#define WMM_NORMAL_PAGE_NUM_HPQ_8195A   0x30
-#define WMM_NORMAL_PAGE_NUM_LPQ_8195A   0x20
-#define WMM_NORMAL_PAGE_NUM_NPQ_8195A   0x20
-
-#include "HalVerDef.h"
-#include "hal_com.h"
-
-#define EFUSE_OOB_PROTECT_BYTES 		(52+28+16+32) // Security + RF + MAC + OTP = 128
-
-#define HWSET_MAX_SIZE_8195A            512
-#define EFUSE_REAL_CONTENT_LEN_8195A    256
-#define EFUSE_MAP_LEN_8195A             512
-#define EFUSE_MAX_SECTION_8195A			64
-
-#define EFUSE_IC_ID_OFFSET			506	//For some inferiority IC purpose. added by Roger, 2009.09.02.
-#define AVAILABLE_EFUSE_ADDR(addr) 	(addr < EFUSE_REAL_CONTENT_LEN_8195A)
-
-#define EFUSE_ACCESS_ON			0x69	// For RTL8723 only.
-#define EFUSE_ACCESS_OFF			0x00	// For RTL8723 only.
-
-#define LX_DMA_IMR_DISABLED 0
-#define FW_IMR_DISABLED     0
-#define WL_PMC_IMR_DISABLED 0
-
-
-//========================================================
-//			EFUSE for BT definition
-//========================================================
-#define EFUSE_BT_REAL_BANK_CONTENT_LEN	512
-#define EFUSE_BT_REAL_CONTENT_LEN		1536	// 512*3
-#define EFUSE_BT_MAP_LEN				1024	// 1k bytes
-#define EFUSE_BT_MAX_SECTION			128		// 1024/8
-
-#define EFUSE_PROTECT_BYTES_BANK		16
-
-#define GET_RF_TYPE(priv)			(rtw_get_haldata(priv)->rf_type)
-
-// Description: Determine the types of C2H events that are the same in driver and Fw.
-// Fisrt constructed by tynli. 2009.10.09.
-typedef enum _C2H_EVT {
-	C2H_DBG = 0,
-	C2H_TSF = 1,
-	C2H_AP_RPT_RSP = 2,
-	C2H_CCX_TX_RPT = 3,	// The FW notify the report of the specific tx packet.
-	C2H_BT_RSSI = 4,
-	C2H_BT_OP_MODE = 5,
-	C2H_EXT_RA_RPT = 6,
-	C2H_8723B_BT_INFO = 9,
-	C2H_HW_INFO_EXCH = 10,
-	C2H_8723B_BT_MP_INFO = 11,
-	MAX_C2HEVENT
-} C2H_EVT;
-
-typedef _PACKED struct _C2H_EVT_HDR {
-	u8	CmdID;
-	u8	CmdLen;
-	u8	CmdSeq;
-} C2H_EVT_HDR, *PC2H_EVT_HDR;
-
-typedef enum tag_Package_Definition {
-	PACKAGE_DEFAULT,
-	PACKAGE_QFN56,
-	PACKAGE_QFN48,
-	PACKAGE_BGA96,
-	PACKAGE_COMBO
-} PACKAGE_TYPE_E;
-
-typedef enum tag_ChipID_Definition {
-	CHIPID_8711AM		= 0xFF,
-	CHIPID_8195AM		= 0xFE,
-	CHIPID_8711AF		= 0xFD,
-	CHIPID_8710AF		= 0xFC,
-	CHIPID_8711AN		= 0xFB,
-	CHIPID_8710AM		= 0xFA,
-	CHIPID_SIP			= 0xF9,	// Midea
-	CHIPID_COMBO_SIP	= 0xF8,	// MICO200
-	CHIPID_SIP2			= 0xF7,
-	CHIPID_MICO100		= 0xF1	// wifi SIP
-} CHIP_TD_E;
-
-
-#define INCLUDE_MULTI_FUNC_BT(_Adapter)		(rtw_get_haldata(_Adapter)->MultiFunc & RT_MULTI_FUNC_BT)
-#define INCLUDE_MULTI_FUNC_GPS(_Adapter)	(rtw_get_haldata(_Adapter)->MultiFunc & RT_MULTI_FUNC_GPS)
-
-//========================================================
-//			TXBD and RXBD definition
-//========================================================
-#ifdef CONFIG_MP_INCLUDED	// For MP Tx no idle
-#define TX_VIQ_DESC_NUM         4
-#define TX_VOQ_DESC_NUM         4
-#define TX_BKQ_DESC_NUM         4
-#define TX_BEQ_DESC_NUM         32
-#else
-#define TX_VIQ_DESC_NUM         4
-#define TX_VOQ_DESC_NUM         4
-#define TX_BKQ_DESC_NUM         4
-#define TX_BEQ_DESC_NUM         4
-#endif
-#define TX_BCNQ_DESC_NUM        2
-#define TX_MGQ_DESC_NUM         4
-#define TX_H0Q_DESC_NUM         2
-#define TX_H1Q_DESC_NUM         2
-#define TX_H2Q_DESC_NUM         2
-#define TX_H3Q_DESC_NUM         2
-#define TX_H4Q_DESC_NUM         2
-#define TX_H5Q_DESC_NUM         2
-#define TX_H6Q_DESC_NUM         2
-#define TX_H7Q_DESC_NUM         2
-#define RX_Q_DESC_NUM           4  //16 Reduce rx desc number due to memory limitation
-
-#define SET_VIQ_DES_NUM     (TX_VIQ_DESC_NUM<<16)
-#define SET_VOQ_DES_NUM     (TX_VOQ_DESC_NUM)
-#define SET_RXQ_DES_NUM     (RX_Q_DESC_NUM<<16)
-#define SET_MGQ_DES_NUM     (TX_MGQ_DESC_NUM)
-#define SET_BKQ_DES_NUM     (TX_BKQ_DESC_NUM<<16)
-#define SET_BEQ_DES_NUM     (TX_BEQ_DESC_NUM)
-#define SET_H1Q_DES_NUM     (TX_H1Q_DESC_NUM<<16)
-#define SET_H0Q_DES_NUM     (TX_H0Q_DESC_NUM)
-#define SET_H3Q_DES_NUM     (TX_H3Q_DESC_NUM<<16)
-#define SET_H2Q_DES_NUM     (TX_H2Q_DESC_NUM)
-#define SET_H5Q_DES_NUM     (TX_H5Q_DESC_NUM<<16)
-#define SET_H4Q_DES_NUM     (TX_H4Q_DESC_NUM)
-#define SET_H7Q_DES_NUM     (TX_H7Q_DESC_NUM<<16)
-#define SET_H6Q_DES_NUM     (TX_H6Q_DESC_NUM)
-
-#define TX_DESC_MODE        1
-
-//0: 2 segment
-//1: 4 segment
-//2: 8 segment
-//#define TX_DESC_MODE            2
-
-#define MAX_TXBD_SEQMENT_NUM    ((TX_DESC_MODE)? (4*TX_DESC_MODE): 2)
-#define TXBD_SEGMENT_SIZE		8
-
-
-
-typedef struct _RXBD_ELEMENT_ {
-	u32         Dword0;
-	u32         PhyAddr;
-} RXBD_ELEMENT, *PRXBD_ELEMENT;
-
-
-typedef struct _TXBD_ELEMENT_ {
-	u32         Dword0;
-	u32         AddrLow;
-} TXBD_ELEMENT, *PTXBD_ELEMENT;
-
-typedef struct _LX_DMA_ELEMENT_ {
-	u32         QueueTRxBdBase;
-	u32         HwIndex;
-	u32         HostIndex;
-	u32         AvaliableCnt;
-} LX_DMA_ELEMENT, *PLX_DMA_ELEMENT;
-#if 1
-
-typedef enum _LX_DMA_QUEUE_TYPE_ {
-	VO_QUEUE = 0,
-	VI_QUEUE = 1,
-	BE_QUEUE = 2,
-	BK_QUEUE = 3,
-	MG_QUEUE = 4,
-	RX_QUEUE = 5,
-	H0_QUEUE = 6,
-	H1_QUEUE = 7,
-	H2_QUEUE = 8,
-	H3_QUEUE = 9,
-	H4_QUEUE = 10,
-	H5_QUEUE = 11,
-	H6_QUEUE = 12,
-	H7_QUEUE = 13,
-	BCN_QUEUE = 14,
-	MAX_TX_QUEUE = 15,
-	ERROR_QUEUE = 16,
-} LX_DMA_QUEUE_TYPE, *PLX_DMA_QUEUE_TYPE;
-
-typedef struct _TX_FREE_QUEUE_ {
-	_queue               FreeQueue;
-	u32                  Qlen;
-} TX_FREE_QUEUE, *PTX_FREE_QUEUE;
-
-typedef struct _LX_DMA_MANAGER_ {
-	LX_DMA_ELEMENT       QueueTRxBd[MAX_TX_QUEUE];
-	u32                  QueueMaxValue[MAX_TX_QUEUE];
-	u32                  RxBdSkb[RX_Q_DESC_NUM];
-	u32                  RxLen;
-	u32                  RemainLen;
-	u16                  RxAggregateNum;
-	u16                  RxExpectTag;
-	u16                  RxSegFlow;
-	u16                  Flagls;
-	TX_FREE_QUEUE        TxFreeQueue[MAX_TX_QUEUE];
-
-} LX_DMA_MANAGER, *PLX_DMA_MANAGER;
-
-#else
-
-typedef struct _LX_DMA_MANAGER_ {
-	u32                 *pVoqTXBD;
-	u32                 *pViqTXBD;
-	u32                 *pBeqTXBD;
-	u32                 *pBkqTXBD;
-	u32                 *pBcnqTXBD;
-	u32                 *pMgqTXBD;
-	u32                 *pH0qTXBD;
-	u32                 *pH1qTXBD;
-	u32                 *pH2qTXBD;
-	u32                 *pH3qTXBD;
-	u32                 *pH4qTXBD;
-	u32                 *pH5qTXBD;
-	u32                 *pH6qTXBD;
-	u32                 *pH7qTXBD;
-	u32                 *pExViqTXBD;
-	u32                 *pExVoqTXBD;
-	u32                 *pExBeqTXBD;
-	u32                 *pExBkqTXBD;
-	u32                 *pExMgqTXBD;
-	u32                 *pRXBD;
-//    u4Byte                  RxAggBufEntry[RX_Q_DESC_NUM];
-//    u4Byte                  RxAggLenEntry[RX_Q_DESC_NUM];
-	u32                  RxLen;
-	u32                  RemainLen;
-	u16                  ViqTxWritePoint;
-	u16                  ViqTxReadPoint;
-	u16                  VoqTxWritePoint;
-	u16                  VoqTxReadPoint;
-	u16                  BeqTxWritePoint;
-	u16                  BeqTxReadPoint;
-	u16                  BkqTxWritePoint;
-	u16                  BkqTxReadPoint;
-	u16                  RxWritePoint;
-	u16                  RxReadPoint;
-	u16                  RxAggregateNum;
-	u16                  RxExpectTag;
-	u16                  RxSegFlow;
-	u16                  Flagls;
-} LX_DMA_MANAGER, *PLX_DMA_MANAGER;
-#endif
-
-// rtl8723a_hal_init.c
-s32 rtl8195a_FirmwareDownload(PADAPTER padapter, BOOLEAN  bUsedWoWLANFw);
-void rtl8195a_FirmwareSelfReset(PADAPTER padapter);
-void rtl8195a_InitializeFirmwareVars(PADAPTER padapter);
-
-void rtl8195a_InitAntenna_Selection(PADAPTER padapter);
-void rtl8195a_DeinitAntenna_Selection(PADAPTER padapter);
-void rtl8195a_CheckAntenna_Selection(PADAPTER padapter);
-void rtl8195a_init_default_value(PADAPTER padapter);
-
-s32 rtl8195a_InitLLTTable(PADAPTER padapter);
-
-s32 CardDisableHWSM(PADAPTER padapter, u8 resetMCU);
-s32 CardDisableWithoutHWSM(PADAPTER padapter);
-
-// EFuse
-//u8 GetEEPROMSize8195a(PADAPTER padapter);
-void Hal_InitPGData(PADAPTER padapter, u8 *PROMContent);
-void Hal_EfuseParseIDCode(PADAPTER padapter, u8 *hwinfo);
-void Hal_EfuseParseTxPowerInfo_8195A(PADAPTER padapter, u8 *PROMContent, BOOLEAN AutoLoadFail);
-void Hal_EfuseParseBTCoexistInfo_8195A(PADAPTER padapter, u8 *hwinfo, BOOLEAN AutoLoadFail);
-void Hal_EfuseParseEEPROMVer_8195A(PADAPTER padapter, u8 *hwinfo, BOOLEAN AutoLoadFail);
-void Hal_EfuseParseChnlPlan_8195A(PADAPTER padapter, u8 *hwinfo, BOOLEAN AutoLoadFail);
-void Hal_EfuseParseCustomerID_8195A(PADAPTER padapter, u8 *hwinfo, BOOLEAN AutoLoadFail);
-void Hal_EfuseParseAntennaDiversity_8195A(PADAPTER padapter, u8 *hwinfo, BOOLEAN AutoLoadFail);
-void Hal_EfuseParseXtal_8195A(PADAPTER pAdapter, u8 *hwinfo, u8 AutoLoadFail);
-void Hal_EfuseParseThermalMeter_8195A(PADAPTER padapter, u8 *hwinfo, u8 AutoLoadFail);
-
-u8 rtw_flash_read(PADAPTER padapter, u16 addr, u16 cnts, u8 *data);
-u8 rtw_flash_write(PADAPTER padapter, u16 addr, u16 cnts, u8 *data);
-u8 rtw_config_map_read(PADAPTER padapter, u16 addr, u16 cnts, u8 *data, u8 efuse);
-u8 rtw_config_map_write(PADAPTER padapter, u16 addr, u16 cnts, u8 *data, u8 efuse);
-
-void lxbus_set_intf_ops(struct _io_ops	*pops);
-void SetHwReg8195A(PADAPTER padapter, u8 variable, u8 *val);
-void GetHwReg8195A(PADAPTER padapter, u8 variable, u8 *val);
-u8 SetHalDefVar8195A(PADAPTER padapter, HAL_DEF_VARIABLE variable, void *pval);
-u8 GetHalDefVar8195A(PADAPTER padapter, HAL_DEF_VARIABLE variable, void *pval);
-void SetHalODMVar8195A(PADAPTER Adapter, HAL_ODM_VARIABLE eVariable, PVOID pValue1, BOOLEAN bSet);
-void GetHalODMVar8195A(PADAPTER Adapter, HAL_ODM_VARIABLE eVariable, PVOID pValue1, PVOID pValue2);
-
-// register
-void rtl8195a_InitBeaconParameters(PADAPTER padapter);
-void rtl8195a_InitBeaconMaxError(PADAPTER padapter, u8 InfraMode);
-void	_InitBurstPktLen_8195AB(PADAPTER Adapter);
-#ifdef CONFIG_WOWLAN
-void _8051Reset8195a(PADAPTER padapter);
-#endif //CONFIG_WOWLAN
-
-void rtl8195a_start_thread(_adapter *padapter);
-void rtl8195a_stop_thread(_adapter *padapter);
-
-#if defined(CONFIG_CHECK_BT_HANG) && defined(CONFIG_BT_COEXIST)
-void rtl8195ab_init_checkbthang_workqueue(_adapter *adapter);
-void rtl8195ab_free_checkbthang_workqueue(_adapter *adapter);
-void rtl8195ab_cancle_checkbthang_workqueue(_adapter *adapter);
-void rtl8195ab_hal_check_bt_hang(_adapter *adapter);
-#endif
-
-#ifdef CONFIG_GPIO_WAKEUP
-void HalSetOutPutGPIO(PADAPTER padapter, u8 index, u8 OutPutValue);
-#endif
-
-//1TODO: Chris
-#if 1
-
-//=============
-// [1] Rx Buffer Descriptor (for PCIE) buffer descriptor architecture
-//DWORD 0
-#define SET_RX_BUFFER_DESC_DATA_LENGTH_92E(__pRxStatusDesc, __Value)		SET_BITS_TO_LE_4BYTE( __pRxStatusDesc, 0, 14, __Value)
-#define SET_RX_BUFFER_DESC_LS_92E(__pRxStatusDesc,__Value)	SET_BITS_TO_LE_4BYTE( __pRxStatusDesc, 14, 1, __Value)
-#define SET_RX_BUFFER_DESC_FS_92E(__pRxStatusDesc, __Value)		SET_BITS_TO_LE_4BYTE( __pRxStatusDesc, 15, 1, __Value)
-#define SET_RX_BUFFER_DESC_RX_TAG_92E(__pRxStatusDesc, __Value)		SET_BITS_TO_LE_4BYTE( __pRxStatusDesc, 16, 13, __Value)
-
-#define GET_RX_BUFFER_DESC_OWN_92E(__pRxStatusDesc)		LE_BITS_TO_4BYTE( __pRxStatusDesc, 31, 1)
-#define GET_RX_BUFFER_DESC_LS_92E(__pRxStatusDesc)		LE_BITS_TO_4BYTE( __pRxStatusDesc, 14, 1)
-#define GET_RX_BUFFER_DESC_FS_92E(__pRxStatusDesc)		LE_BITS_TO_4BYTE( __pRxStatusDesc, 15, 1)
-#define GET_RX_BUFFER_DESC_RX_TAG_92E(__pRxStatusDesc)		LE_BITS_TO_4BYTE( __pRxStatusDesc, 16, 13)
-#define GET_RX_BUFFER_DESC_TOTAL_LENGTH_92E(__pRxStatusDesc)LE_BITS_TO_4BYTE( __pRxStatusDesc, 0, 14)
-
-
-//DWORD 1
-#define SET_RX_BUFFER_PHYSICAL_LOW_92E(__pRxStatusDesc, __Value)		SET_BITS_TO_LE_4BYTE( __pRxStatusDesc+4, 0, 32, __Value)
-#define GET_RX_BUFFER_PHYSICAL_LOW_92E(__pRxStatusDesc)		LE_BITS_TO_4BYTE( __pRxStatusDesc+4, 0, 32)
-
-//DWORD 2
-#define SET_RX_BUFFER_PHYSICAL_HIGH_92E(__pRxStatusDesc, __Value)		SET_BITS_TO_LE_4BYTE( __pRxStatusDesc+8, 0, 32, __Value)
-
-
-//=====Tx Desc Buffer content
-
-// config element for each tx buffer
-/*
-#define SET_TXBUFFER_DESC_LEN_WITH_OFFSET(__pTxDesc, __Offset, __Valeu) SET_BITS_TO_LE_4BYTE(__pTxDesc+(__Offset*16), 0, 16, __Valeu)
-#define SET_TXBUFFER_DESC_AMSDU_WITH_OFFSET(__pTxDesc, __Offset, __Valeu) SET_BITS_TO_LE_4BYTE(__pTxDesc+(__Offset*16), 31, 1, __Valeu)
-#define SET_TXBUFFER_DESC_ADD_LOW_WITH_OFFSET(__pTxDesc, __Offset, __Valeu) SET_BITS_TO_LE_4BYTE(__pTxDesc+(__Offset*16)+4, 0, 32, __Valeu)
-#define SET_TXBUFFER_DESC_ADD_HIGT_WITH_OFFSET(__pTxDesc, __Offset, __Valeu) SET_BITS_TO_LE_4BYTE(__pTxDesc+(__Offset*16)+8, 0, 32, __Valeu)
-*/
-#define SET_TXBUFFER_DESC_LEN_WITH_OFFSET(__pTxDesc, __Offset, __Valeu) SET_BITS_TO_LE_4BYTE(__pTxDesc+(__Offset*8), 0, 16, __Valeu)
-#define SET_TXBUFFER_DESC_AMSDU_WITH_OFFSET(__pTxDesc, __Offset, __Valeu) SET_BITS_TO_LE_4BYTE(__pTxDesc+(__Offset*8), 31, 1, __Valeu)
-#define SET_TXBUFFER_DESC_ADD_LOW_WITH_OFFSET(__pTxDesc, __Offset, __Valeu) SET_BITS_TO_LE_4BYTE(__pTxDesc+(__Offset*8)+4, 0, 32, __Valeu)
-#define SET_TXBUFFER_DESC_ADD_HIGT_WITH_OFFSET(__pTxDesc, __Offset, __Valeu) SET_BITS_TO_LE_4BYTE(__pTxDesc+(__Offset*16)+8, 0, 32, __Valeu)
-
-// Dword 0
-#define SET_TX_BUFF_DESC_LEN_0_92E(__pTxDesc, __Valeu) SET_BITS_TO_LE_4BYTE(__pTxDesc, 0, 16, __Valeu)
-#define SET_TX_BUFF_DESC_PSB_92E(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc, 16, 8, __Value)
-#define SET_TX_BUFF_DESC_OWN_92E(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc, 31, 1, __Value)
-// Dword 1
-#define SET_TX_BUFF_DESC_ADDR_LOW_0_92E(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+4, 0, 32, __Value)
-#define GET_TX_DESC_TX_BUFFER_ADDRESS_92E(__pTxDesc) LE_BITS_TO_4BYTE(__pTxDesc+4, 0,32)
-
-
-// Dword 2
-#define SET_TX_BUFF_DESC_ADDR_HIGH_0_92E(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+8, 0, 32, __Value)
-// Dword 3, RESERVED
-
-
-#define SET_TX_DESC_OWN_92E(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc, 31, 1, __Value)
-
-#endif
-
-#endif
-
diff --git a/os/board/rtl8720e/src/component/wifi/driver/include/rtl8711b_hal.h b/os/board/rtl8720e/src/component/wifi/driver/include/rtl8711b_hal.h
deleted file mode 100644
index 13223bcbe..000000000
--- a/os/board/rtl8720e/src/component/wifi/driver/include/rtl8711b_hal.h
+++ /dev/null
@@ -1,584 +0,0 @@
-/******************************************************************************
- *
- * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of version 2 of the GNU General Public License as
- * published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
- * more details.
- *
- * You should have received a copy of the GNU General Public License along with
- * this program; if not, write to the Free Software Foundation, Inc.,
- * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
- *
- *
- ******************************************************************************/
-
-#ifndef __RTL8711B_HAL_H__
-#define __RTL8711B_HAL_H__
-
-#include "drv_types.h"
-//#include "rtl8711b/rtl8711b_pmu_task.h"
-#include "hal_data.h"
-
-#include "rtl8711b/rtl8711b_spec.h"
-#include "rtl8711b/rtl8711b_rf.h"
-#include "rtl8711b/rtl8711b_dm.h"
-#include "rtl8711b/rtl8711b_recv.h"
-#include "rtl8711b/rtl8711b_xmit.h"
-#include "rtl8711b/rtl8711b_cmd.h"
-//#include "rtl8711b/rtl8711b_pmu_cmd.h"
-#include "rtl8711b/rtl8711b_led.h"
-#include "rtl8711b/Hal8711BPwrSeq.h"
-#include "rtl8711b/Hal8711BPhyReg.h"
-#include "rtl8711b/Hal8711BPhyCfg.h"
-#include "rtl8711b/rom_Hal8711BPhyCfg.h"
-
-#include "../src/hal/OUTSRC/phydm_precomp.h"
-
-#if (RTL8711B_SUPPORT==1)
-//2TODO: We should define 8192S firmware related macro settings here!!
-#define RTL819X_DEFAULT_RF_TYPE			RF_1T2R
-#define RTL819X_TOTAL_RF_PATH				2
-
-//---------------------------------------------------------------------
-//		RTL8723BS From file
-//---------------------------------------------------------------------
-#define RTL8723B_FW_IMG					"rtl8723B\\rtl8723bfw.bin"
-#define RTL8711B_PHY_REG					"rtl8711B\\PHY_REG_1T.txt"
-#define RTL8711B_PHY_RADIO_A			"rtl8711B\\radio_a_1T.txt"
-#define RTL8711B_PHY_RADIO_B			"rtl8711B\\radio_b_1T.txt"
-#define RTL8711B_TXPWR_TRACK			"rtl8711B\\TxPowerTrack.txt"
-#define RTL8711B_AGC_TAB					"rtl8711B\\AGC_TAB_1T.txt"
-#define RTL8711B_PHY_MACREG				"rtl87195A\\MAC_REG.txt"
-#define RTL8711B_PHY_REG_PG				"rtl8711B\\PHY_REG_PG.txt"
-#define RTL8711B_PHY_REG_MP				"rtl8711B\\PHY_REG_MP.txt"
-#define RTL8711B_TXPWR_LMT 				"rtl8711B\\TXPWR_LMT.txt"
-
-//---------------------------------------------------------------------
-//		RTL8723BS From header
-//---------------------------------------------------------------------
-
-//#define Rtl8723B_FwImageArray				Array_MP_8723B_FW_NIC
-//#define Rtl8723B_FwImgArrayLength			ArrayLength_MP_8723B_FW_NIC
-//#define Rtl8723B_FwWoWImageArray			Array_MP_8723B_FW_WoWLAN
-//#define Rtl8723B_FwWoWImgArrayLength		ArrayLength_MP_8723B_FW_WoWLAN
-
-#define Rtl8711B_PHY_REG_Array_PG 			Rtl8723SPHY_REG_Array_PG
-#define Rtl8711B_PHY_REG_Array_PGLength	Rtl8723SPHY_REG_Array_PGLength
-
-#if MP_DRIVER == 1
-#define Rtl8711B_FwBTImgArray				Rtl8723BFwBTImgArray
-#define Rtl8711B_FwBTImgArrayLength		Rtl8723BFwBTImgArrayLength
-
-#define Rtl8711B_FwMPImageArray			Rtl8723BFwMPImgArray
-#define Rtl8711B_FwMPImgArrayLength		Rtl8723BMPImgArrayLength
-
-#define Rtl8711B_PHY_REG_Array_MP			Rtl8723B_PHYREG_Array_MP
-#define Rtl8711B_PHY_REG_Array_MPLength	Rtl8723B_PHYREG_Array_MPLength
-#endif
-
-#endif // RTL8711B_SUPPORT
-
-#define FW_8711B_SIZE			0x8000
-#define FW_8711B_START_ADDRESS	0x1000
-#define FW_8711B_END_ADDRESS		0x1FFF //0x5FFF
-
-#define IS_FW_HEADER_EXIST_8711B(_pFwHdr)	((GET_FIRMWARE_HDR_SIGNATURE(_pFwHdr)&0xFFF0) == 0x10B0)
-
-typedef struct _RT_FIRMWARE {
-	FIRMWARE_SOURCE	eFWSource;
-	u8			*szFwBuffer;
-	u32			ulFwLength;
-
-	u8			*szBTFwBuffer;
-	u32			ulBTFwLength;
-
-#ifdef CONFIG_WOWLAN
-	u8			*szWoWLANFwBuffer;
-	u32			ulWoWLANFwLength;
-#endif //CONFIG_WOWLAN
-} RT_FIRMWARE_8711B, *PRT_FIRMWARE_8711B;
-
-//
-// This structure must be cared byte-ordering
-//
-// Added by tynli. 2009.12.04.
-typedef struct _RT_8723B_FIRMWARE_HDR {
-	// 8-byte alinment required
-
-	//--- LONG WORD 0 ----
-	u16		Signature;	// 92C0: test chip; 92C, 88C0: test chip; 88C1: MP A-cut; 92C1: MP A-cut
-	u8		Category;	// AP/NIC and USB/PCI
-	u8		Function;	// Reserved for different FW function indcation, for further use when driver needs to download different FW in different conditions
-	u16		Version;		// FW Version
-	u8		Subversion;	// FW Subversion, default 0x00
-	u16		Rsvd1;
-
-
-	//--- LONG WORD 1 ----
-	u8		Month;	// Release time Month field
-	u8		Date;	// Release time Date field
-	u8		Hour;	// Release time Hour field
-	u8		Minute;	// Release time Minute field
-	u16		RamCodeSize;	// The size of RAM code
-	u16		Rsvd2;
-
-	//--- LONG WORD 2 ----
-	u32		SvnIdx;	// The SVN entry index
-	u32		Rsvd3;
-
-	//--- LONG WORD 3 ----
-	u32		Rsvd4;
-	u32		Rsvd5;
-} RT_8723B_FIRMWARE_HDR, *PRT_8723B_FIRMWARE_HDR;
-
-#define DRIVER_EARLY_INT_TIME_8711B         0x05 // 5ms
-#define BCN_DMA_ATIME_INT_TIME_8711B        0x02 // 2ms
-
-// for 8711B
-// TX 32K, RX 16K, Page size 128B for TX, 8B for RX
-#define PAGE_SIZE_TX_8711B                  128
-#define PAGE_SIZE_RX_8711B                  8
-
-#define RX_DMA_SIZE_8711B                   0x4000	// 16K
-#define RX_DMA_RESERVED_SIZE_8711B          0x80	// 128B, reserved for tx report
-#define RX_DMA_BOUNDARY_8711B               (RX_DMA_SIZE_8711B - RX_DMA_RESERVED_SIZE_8711B - 1)
-
-// Note: We will divide number of page equally for each queue other than public queue!
-
-//For General Reserved Page Number(Beacon Queue is reserved page)
-//Beacon:2, PS-Poll:1, Null Data:1,Qos Null Data:1,BT Qos Null Data:1
-#ifdef CONFIG_WLAN_HAL_TEST
-#define BCNQ_PAGE_NUM_8711B             0x00
-#else
-#define BCNQ_PAGE_NUM_8711B             0x08
-#endif
-
-#ifdef CONFIG_CONCURRENT_MODE
-#define BCNQ1_PAGE_NUM_8711B            0x04
-#else
-#define BCNQ1_PAGE_NUM_8711B            0x00
-#endif
-
-//For WoWLan , more reserved page
-//ARP Rsp:1, RWC:1, GTK Info:1,GTK RSP:2,GTK EXT MEM:2
-#ifdef CONFIG_WOWLAN
-#define WOWLAN_PAGE_NUM_8711B           0x07
-#else
-#define WOWLAN_PAGE_NUM_8711B           0x00
-#endif
-
-#ifdef CONFIG_WLAN_HAL_TEST
-#define TX_TOTAL_PAGE_NUMBER_8711B      (0xF8 - BCNQ_PAGE_NUM_8711B - BCNQ1_PAGE_NUM_8711B - WOWLAN_PAGE_NUM_8711B)
-//#define TX_TOTAL_PAGE_NUMBER_8711B      0x40
-#define TX_PAGE_BOUNDARY_8711B          (TX_TOTAL_PAGE_NUMBER_8711B + 1)
-#else
-#define TX_TOTAL_PAGE_NUMBER_8711B      (0xFF - BCNQ_PAGE_NUM_8711B - BCNQ1_PAGE_NUM_8711B - WOWLAN_PAGE_NUM_8711B)
-#define TX_PAGE_BOUNDARY_8711B          (TX_TOTAL_PAGE_NUMBER_8711B + 1)
-#endif
-
-#define WMM_NORMAL_TX_TOTAL_PAGE_NUMBER TX_TOTAL_PAGE_NUMBER_8711B
-#define WMM_NORMAL_TX_PAGE_BOUNDARY		(WMM_NORMAL_TX_TOTAL_PAGE_NUMBER + 1)
-
-// For Normal Chip Setting
-// (HPQ + LPQ + NPQ + PUBQ) shall be TX_TOTAL_PAGE_NUMBER_8711B
-#ifdef CONFIG_WLAN_HAL_TEST
-#define NORMAL_PAGE_NUM_HPQ_8711B		0x10
-#define NORMAL_PAGE_NUM_LPQ_8711B		0x10
-#define NORMAL_PAGE_NUM_NPQ_8711B		0x10
-#else
-#define NORMAL_PAGE_NUM_HPQ_8711B		0x0C
-#define NORMAL_PAGE_NUM_LPQ_8711B		0x02
-#define NORMAL_PAGE_NUM_NPQ_8711B		0x02
-#endif
-
-#ifdef CONFIG_WLAN_HAL_TEST
-#define WMM_NORMAL_PAGE_NUM_HPQ_8711B   0x10
-#define WMM_NORMAL_PAGE_NUM_LPQ_8711B   0x10
-#define WMM_NORMAL_PAGE_NUM_NPQ_8711B   0x10
-#else
-// Note: For Normal Chip Setting, modify later
-#define WMM_NORMAL_PAGE_NUM_HPQ_8711B   0x30
-#define WMM_NORMAL_PAGE_NUM_LPQ_8711B   0x20
-#define WMM_NORMAL_PAGE_NUM_NPQ_8711B   0x20
-#endif
-
-#include "HalVerDef.h"
-#include "hal_com.h"
-
-#define LX_DMA_IMR_DISABLED 0
-#define FW_IMR_DISABLED     0
-#define WL_PMC_IMR_DISABLED 0
-
-
-//========================================================
-//			EFUSE for BT definition
-//========================================================
-#define EFUSE_BT_REAL_BANK_CONTENT_LEN	512
-#define EFUSE_BT_REAL_CONTENT_LEN		1536	// 512*3
-#define EFUSE_BT_MAP_LEN				1024	// 1k bytes
-#define EFUSE_BT_MAX_SECTION			128		// 1024/8
-
-#define EFUSE_PROTECT_BYTES_BANK		16
-
-#define GET_RF_TYPE(priv)			(rtw_get_haldata(priv)->rf_type)
-
-// Description: Determine the types of C2H events that are the same in driver and Fw.
-// Fisrt constructed by tynli. 2009.10.09.
-typedef enum _C2H_EVT {
-	C2H_DBG = 0x00,
-	C2H_LB = 0x01,
-	C2H_TXBF = 0x02,
-	C2H_CCX_TX_RPT = 0x03,
-	C2H_FW_SCAN_COMPLETE = 0x7,
-	C2H_BT_INFO = 0x09,
-	C2H_BT_MP_INFO = 0x0B,
-	C2H_RA_RPT = 0x0C,
-	C2H_RA_PARA_RPT = 0x0E,
-	C2H_FW_CHNL_SWITCH_COMPLETE = 0x10,
-	C2H_IQK_FINISH = 0x11,
-	C2H_MAILBOX_STATUS = 0x15,
-	C2H_P2P_RPORT = 0x16,
-	C2H_MCC = 0x17,
-	C2H_MAC_HIDDEN_RPT = 0x19,
-	C2H_MAC_HIDDEN_RPT_2 = 0x1A,
-	C2H_BCN_EARLY_RPT = 0x1E,
-	C2H_DEFEATURE_DBG = 0x22,
-	C2H_PLCPHDR_RPT = 0x2B,
-	C2H_DEFEATURE_RSVD = 0xFD,
-	C2H_EXTEND = 0xff,
-} C2H_EVT;
-
-typedef _PACKED struct _C2H_EVT_HDR {
-	u8	CmdID;
-	u8	CmdLen;
-	u8	CmdSeq;
-} C2H_EVT_HDR, *PC2H_EVT_HDR;
-
-typedef enum tag_Package_Definition {
-	PACKAGE_SMIC_QFN32,
-	PACKAGE_SMIC_QFN48_MCM,
-	PACKAGE_SMIC_QFN48,
-	PACKAGE_SMIC_QFN68,
-	PACKAGE_UMC_QFN32,
-	PACKAGE_UMC_QFN48_MCM,
-	PACKAGE_UMC_QFN48,
-	PACKAGE_UMC_QFN68,
-} PACKAGE_TYPE_E;
-
-typedef enum tag_ChipID_Definition {
-	CHIPID_8710BN = 0xFF, /* PACKAGE_QFN32 */
-	CHIPID_8710BU = 0xFE, /* PACKAGE_QFN48_MCM */
-	CHIPID_8711BN = 0xFD, /* PACKAGE_QFN48 */
-	CHIPID_8711BU = 0xFC, /* PACKAGE_QFN68 */
-	CHIPID_8710BN_L0 = 0xFB, /* PACKAGE_QFN32, cpu clk: 62.5M, sram: 200K, flash io: 2-bit mode */
-	CHIPID_8710BN_VV2 = 0xFA, /* PACKAGE_QFN32, sram: 200k, special for Haier */
-	CHIPID_8710BN_A0_VV2 = 0xF8, /* PACKAGE_QFN32, the same as CHIPID_8710BN */
-} CHIP_TD_E;
-
-#define INCLUDE_MULTI_FUNC_BT(_Adapter)		(rtw_get_haldata(_Adapter)->MultiFunc & RT_MULTI_FUNC_BT)
-#define INCLUDE_MULTI_FUNC_GPS(_Adapter)	(rtw_get_haldata(_Adapter)->MultiFunc & RT_MULTI_FUNC_GPS)
-
-//========================================================
-//			TXBD and RXBD definition
-//========================================================
-#ifdef CONFIG_MP_INCLUDED	// For MP Tx no idle
-#define TX_VIQ_DESC_NUM         4
-#define TX_VOQ_DESC_NUM         4
-#define TX_BKQ_DESC_NUM         4
-#define TX_BEQ_DESC_NUM         32
-#else
-#define TX_VIQ_DESC_NUM         4
-#define TX_VOQ_DESC_NUM         4
-#define TX_BKQ_DESC_NUM         4
-#define TX_BEQ_DESC_NUM         4
-#endif
-#ifdef CONFIG_CONCURRENT_MODE
-#define TX_BCNQ_DESC_NUM        4
-#else
-#define TX_BCNQ_DESC_NUM        2
-#endif
-#define TX_MGQ_DESC_NUM         4
-#define TX_H0Q_DESC_NUM         4  // Increase Tx Hi Queue for BMcast Packets in SoftAP mode
-#define TX_H1Q_DESC_NUM         2
-#define TX_H2Q_DESC_NUM         2
-#define TX_H3Q_DESC_NUM         2
-#define TX_H4Q_DESC_NUM         2
-#define TX_H5Q_DESC_NUM         2
-#define TX_H6Q_DESC_NUM         2
-#define TX_H7Q_DESC_NUM         2
-#define RX_Q_DESC_NUM           4  //16 Reduce rx desc number due to memory limitation
-
-#define SET_VIQ_DES_NUM     (TX_VIQ_DESC_NUM<<16)
-#define SET_VOQ_DES_NUM     (TX_VOQ_DESC_NUM)
-#define SET_RXQ_DES_NUM     (RX_Q_DESC_NUM<<16)
-#define SET_MGQ_DES_NUM     (TX_MGQ_DESC_NUM)
-#define SET_BKQ_DES_NUM     (TX_BKQ_DESC_NUM<<16)
-#define SET_BEQ_DES_NUM     (TX_BEQ_DESC_NUM)
-#define SET_H1Q_DES_NUM     (TX_H1Q_DESC_NUM<<16)
-#define SET_H0Q_DES_NUM     (TX_H0Q_DESC_NUM)
-#define SET_H3Q_DES_NUM     (TX_H3Q_DESC_NUM<<16)
-#define SET_H2Q_DES_NUM     (TX_H2Q_DESC_NUM)
-#define SET_H5Q_DES_NUM     (TX_H5Q_DESC_NUM<<16)
-#define SET_H4Q_DES_NUM     (TX_H4Q_DESC_NUM)
-#define SET_H7Q_DES_NUM     (TX_H7Q_DESC_NUM<<16)
-#define SET_H6Q_DES_NUM     (TX_H6Q_DESC_NUM)
-
-#define TX_DESC_MODE        1
-
-//0: 2 segment
-//1: 4 segment
-//2: 8 segment
-//#define TX_DESC_MODE            2
-
-#define MAX_TXBD_SEQMENT_NUM    ((TX_DESC_MODE)? (4*TX_DESC_MODE): 2)
-#define TXBD_SEGMENT_SIZE		8
-
-
-
-typedef struct _RXBD_ELEMENT_ {
-	u32         Dword0;
-	u32         PhyAddr;
-} RXBD_ELEMENT, *PRXBD_ELEMENT;
-
-
-typedef struct _TXBD_ELEMENT_ {
-	u32         Dword0;
-	u32         AddrLow;
-} TXBD_ELEMENT, *PTXBD_ELEMENT;
-
-typedef struct _LX_DMA_ELEMENT_ {
-	u32         QueueTRxBdBase;
-	u32         HwIndex;
-	u32         HostIndex;
-	u32         AvaliableCnt;
-} LX_DMA_ELEMENT, *PLX_DMA_ELEMENT;
-#if 1
-
-typedef enum _LX_DMA_QUEUE_TYPE_ {
-	VO_QUEUE = 0,
-	VI_QUEUE = 1,
-	BE_QUEUE = 2,
-	BK_QUEUE = 3,
-	MG_QUEUE = 4,
-	RX_QUEUE = 5,
-	H0_QUEUE = 6,
-	H1_QUEUE = 7,
-	H2_QUEUE = 8,
-	H3_QUEUE = 9,
-	H4_QUEUE = 10,
-	H5_QUEUE = 11,
-	H6_QUEUE = 12,
-	H7_QUEUE = 13,
-	BCN_QUEUE = 14,
-	MAX_TX_QUEUE = 15,
-	ERROR_QUEUE = 16,
-} LX_DMA_QUEUE_TYPE, *PLX_DMA_QUEUE_TYPE;
-
-typedef struct _TX_FREE_QUEUE_ {
-	_queue               FreeQueue;
-	u32                  Qlen;
-} TX_FREE_QUEUE, *PTX_FREE_QUEUE;
-
-typedef struct _LX_DMA_MANAGER_ {
-	LX_DMA_ELEMENT       QueueTRxBd[MAX_TX_QUEUE];
-	u32                  QueueMaxValue[MAX_TX_QUEUE];
-	u32                  RxBdSkb[RX_Q_DESC_NUM];
-	u32                  RxLen;
-	u32                  RemainLen;
-	u16                  RxAggregateNum;
-	u16                  RxExpectTag;
-	u16                  RxSegFlow;
-	u16                  Flagls;
-	TX_FREE_QUEUE        TxFreeQueue[MAX_TX_QUEUE];
-
-} LX_DMA_MANAGER, *PLX_DMA_MANAGER;
-
-#else
-
-typedef struct _LX_DMA_MANAGER_ {
-	u32                 *pVoqTXBD;
-	u32                 *pViqTXBD;
-	u32                 *pBeqTXBD;
-	u32                 *pBkqTXBD;
-	u32                 *pBcnqTXBD;
-	u32                 *pMgqTXBD;
-	u32                 *pH0qTXBD;
-	u32                 *pH1qTXBD;
-	u32                 *pH2qTXBD;
-	u32                 *pH3qTXBD;
-	u32                 *pH4qTXBD;
-	u32                 *pH5qTXBD;
-	u32                 *pH6qTXBD;
-	u32                 *pH7qTXBD;
-	u32                 *pExViqTXBD;
-	u32                 *pExVoqTXBD;
-	u32                 *pExBeqTXBD;
-	u32                 *pExBkqTXBD;
-	u32                 *pExMgqTXBD;
-	u32                 *pRXBD;
-//    u4Byte                  RxAggBufEntry[RX_Q_DESC_NUM];
-//    u4Byte                  RxAggLenEntry[RX_Q_DESC_NUM];
-	u32                  RxLen;
-	u32                  RemainLen;
-	u16                  ViqTxWritePoint;
-	u16                  ViqTxReadPoint;
-	u16                  VoqTxWritePoint;
-	u16                  VoqTxReadPoint;
-	u16                  BeqTxWritePoint;
-	u16                  BeqTxReadPoint;
-	u16                  BkqTxWritePoint;
-	u16                  BkqTxReadPoint;
-	u16                  RxWritePoint;
-	u16                  RxReadPoint;
-	u16                  RxAggregateNum;
-	u16                  RxExpectTag;
-	u16                  RxSegFlow;
-	u16                  Flagls;
-} LX_DMA_MANAGER, *PLX_DMA_MANAGER;
-#endif
-
-// rtl8723a_hal_init.c
-s32 rtl8711b_FirmwareDownload(PADAPTER padapter, BOOLEAN  bUsedWoWLANFw);
-void rtl8711b_FirmwareSelfReset(PADAPTER padapter);
-void rtl8711b_InitializeFirmwareVars(PADAPTER padapter);
-
-void rtl8711b_InitAntenna_Selection(PADAPTER padapter);
-void rtl8711b_DeinitAntenna_Selection(PADAPTER padapter);
-void rtl8711b_CheckAntenna_Selection(PADAPTER padapter);
-void rtl8711b_init_default_value(PADAPTER padapter);
-
-s32 rtl8711b_InitLLTTable(PADAPTER padapter);
-
-s32 CardDisableHWSM(PADAPTER padapter, u8 resetMCU);
-s32 CardDisableWithoutHWSM(PADAPTER padapter);
-
-// EFuse
-//u8 GetEEPROMSize8711b(PADAPTER padapter);
-void Hal_InitPGData(PADAPTER padapter, u8 *PROMContent);
-void Hal_EfuseParseIDCode(PADAPTER padapter, u8 *hwinfo);
-void Hal_EfuseParseTxPowerInfo_8711B(PADAPTER padapter, u8 *PROMContent, BOOLEAN AutoLoadFail);
-void Hal_EfuseParseBTCoexistInfo_8711B(PADAPTER padapter, u8 *hwinfo, BOOLEAN AutoLoadFail);
-void Hal_EfuseParseEEPROMVer_8711B(PADAPTER padapter, u8 *hwinfo, BOOLEAN AutoLoadFail);
-void Hal_EfuseParseChnlPlan_8711B(PADAPTER padapter, u8 *hwinfo, BOOLEAN AutoLoadFail);
-void Hal_EfuseParseCustomerID_8711B(PADAPTER padapter, u8 *hwinfo, BOOLEAN AutoLoadFail);
-void Hal_EfuseParseAntennaDiversity_8711B(PADAPTER padapter, u8 *hwinfo, BOOLEAN AutoLoadFail);
-void Hal_EfuseParseXtal_8711B(PADAPTER pAdapter, u8 *hwinfo, u8 AutoLoadFail);
-void Hal_EfuseParseThermalMeter_8711B(PADAPTER padapter, u8 *hwinfo, u8 AutoLoadFail);
-
-#ifdef CONFIG_C2H_PACKET_EN
-void C2HPacketHandler_8711B(PADAPTER padapter, u8 *pbuffer, u16 length);
-#endif
-
-u8 rtw_flash_read(PADAPTER padapter, u16 addr, u16 cnts, u8 *data);
-u8 rtw_flash_write(PADAPTER padapter, u16 addr, u16 cnts, u8 *data);
-u8 rtw_config_map_read(PADAPTER padapter, u16 addr, u16 cnts, u8 *data, u8 efuse);
-u8 rtw_config_map_write(PADAPTER padapter, u16 addr, u16 cnts, u8 *data, u8 efuse);
-
-void lxbus_set_intf_ops(struct _io_ops	*pops);
-void SetHwReg8711B(PADAPTER padapter, u8 variable, u8 *val);
-void GetHwReg8711B(PADAPTER padapter, u8 variable, u8 *val);
-u8 SetHalDefVar8711B(PADAPTER padapter, HAL_DEF_VARIABLE variable, void *pval);
-u8 GetHalDefVar8711B(PADAPTER padapter, HAL_DEF_VARIABLE variable, void *pval);
-void SetHalODMVar8711B(PADAPTER Adapter, HAL_ODM_VARIABLE eVariable, PVOID pValue1, BOOLEAN bSet);
-void GetHalODMVar8711B(PADAPTER Adapter, HAL_ODM_VARIABLE eVariable, PVOID pValue1, PVOID pValue2);
-void rtl8711b_Set_AC_Param(u32 ACParam[], u32 *pBE_param);
-
-// register
-void rtl8711b_InitBeaconParameters(PADAPTER padapter);
-void rtl8711b_InitBeaconMaxError(PADAPTER padapter, u8 InfraMode);
-void	_InitBurstPktLen_8711BB(PADAPTER Adapter);
-#ifdef CONFIG_WOWLAN
-void _8051Reset8711b(PADAPTER padapter);
-#endif //CONFIG_WOWLAN
-
-void rtl8711b_start_thread(_adapter *padapter);
-void rtl8711b_stop_thread(_adapter *padapter);
-
-#if defined(CONFIG_CHECK_BT_HANG) && defined(CONFIG_BT_COEXIST)
-void rtl8711bb_init_checkbthang_workqueue(_adapter *adapter);
-void rtl8711bb_free_checkbthang_workqueue(_adapter *adapter);
-void rtl8711bb_cancle_checkbthang_workqueue(_adapter *adapter);
-void rtl8711bb_hal_check_bt_hang(_adapter *adapter);
-#endif
-
-u32 rtl8710b_wlan_suspend(u32 expected_idle_time, void *param);
-u32 rtl8710b_wlan_late_resume(u32 expected_idle_time, void *param);
-u32 rtl8710b_wlan_resume(u32 expected_idle_time, void *param);
-void rtl8711b_tcp_suspend_indicate(struct xmit_frame *pxmitframe);
-
-#ifdef CONFIG_GPIO_WAKEUP
-void HalSetOutPutGPIO(PADAPTER padapter, u8 index, u8 OutPutValue);
-#endif
-
-void CCX_FwC2HTxRpt_8711B(PADAPTER padapter, u8 *pdata, u8 len);
-s32 c2h_id_filter_ccx_8711B(u8 *buf);
-s32 c2h_handler_8711B(PADAPTER padapter, u8 *pC2hEvent);
-u8 MRateToHwRate8723B(u8  rate);
-u8 HwRateToMRate8723B(u8	 rate);
-
-//1TODO: Chris
-#if 1
-
-//=============
-// [1] Rx Buffer Descriptor (for PCIE) buffer descriptor architecture
-//DWORD 0
-#define SET_RX_BUFFER_DESC_DATA_LENGTH_92E(__pRxStatusDesc, __Value)		SET_BITS_TO_LE_4BYTE( __pRxStatusDesc, 0, 14, __Value)
-#define SET_RX_BUFFER_DESC_LS_92E(__pRxStatusDesc,__Value)	SET_BITS_TO_LE_4BYTE( __pRxStatusDesc, 14, 1, __Value)
-#define SET_RX_BUFFER_DESC_FS_92E(__pRxStatusDesc, __Value)		SET_BITS_TO_LE_4BYTE( __pRxStatusDesc, 15, 1, __Value)
-#define SET_RX_BUFFER_DESC_RX_TAG_92E(__pRxStatusDesc, __Value)		SET_BITS_TO_LE_4BYTE( __pRxStatusDesc, 16, 13, __Value)
-
-#define GET_RX_BUFFER_DESC_OWN_92E(__pRxStatusDesc)		LE_BITS_TO_4BYTE( __pRxStatusDesc, 31, 1)
-#define GET_RX_BUFFER_DESC_LS_92E(__pRxStatusDesc)		LE_BITS_TO_4BYTE( __pRxStatusDesc, 14, 1)
-#define GET_RX_BUFFER_DESC_FS_92E(__pRxStatusDesc)		LE_BITS_TO_4BYTE( __pRxStatusDesc, 15, 1)
-#define GET_RX_BUFFER_DESC_RX_TAG_92E(__pRxStatusDesc)		LE_BITS_TO_4BYTE( __pRxStatusDesc, 16, 13)
-#define GET_RX_BUFFER_DESC_TOTAL_LENGTH_92E(__pRxStatusDesc)LE_BITS_TO_4BYTE( __pRxStatusDesc, 0, 14)
-
-
-//DWORD 1
-#define SET_RX_BUFFER_PHYSICAL_LOW_92E(__pRxStatusDesc, __Value)		SET_BITS_TO_LE_4BYTE( __pRxStatusDesc+4, 0, 32, __Value)
-#define GET_RX_BUFFER_PHYSICAL_LOW_92E(__pRxStatusDesc)		LE_BITS_TO_4BYTE( __pRxStatusDesc+4, 0, 32)
-
-//DWORD 2
-#define SET_RX_BUFFER_PHYSICAL_HIGH_92E(__pRxStatusDesc, __Value)		SET_BITS_TO_LE_4BYTE( __pRxStatusDesc+8, 0, 32, __Value)
-
-
-//=====Tx Desc Buffer content
-
-// config element for each tx buffer
-/*
-#define SET_TXBUFFER_DESC_LEN_WITH_OFFSET(__pTxDesc, __Offset, __Valeu) SET_BITS_TO_LE_4BYTE(__pTxDesc+(__Offset*16), 0, 16, __Valeu)
-#define SET_TXBUFFER_DESC_AMSDU_WITH_OFFSET(__pTxDesc, __Offset, __Valeu) SET_BITS_TO_LE_4BYTE(__pTxDesc+(__Offset*16), 31, 1, __Valeu)
-#define SET_TXBUFFER_DESC_ADD_LOW_WITH_OFFSET(__pTxDesc, __Offset, __Valeu) SET_BITS_TO_LE_4BYTE(__pTxDesc+(__Offset*16)+4, 0, 32, __Valeu)
-#define SET_TXBUFFER_DESC_ADD_HIGT_WITH_OFFSET(__pTxDesc, __Offset, __Valeu) SET_BITS_TO_LE_4BYTE(__pTxDesc+(__Offset*16)+8, 0, 32, __Valeu)
-*/
-#define SET_TXBUFFER_DESC_LEN_WITH_OFFSET(__pTxDesc, __Offset, __Valeu) SET_BITS_TO_LE_4BYTE(__pTxDesc+(__Offset*8), 0, 16, __Valeu)
-#define SET_TXBUFFER_DESC_AMSDU_WITH_OFFSET(__pTxDesc, __Offset, __Valeu) SET_BITS_TO_LE_4BYTE(__pTxDesc+(__Offset*8), 31, 1, __Valeu)
-#define SET_TXBUFFER_DESC_ADD_LOW_WITH_OFFSET(__pTxDesc, __Offset, __Valeu) SET_BITS_TO_LE_4BYTE(__pTxDesc+(__Offset*8)+4, 0, 32, __Valeu)
-#define SET_TXBUFFER_DESC_ADD_HIGT_WITH_OFFSET(__pTxDesc, __Offset, __Valeu) SET_BITS_TO_LE_4BYTE(__pTxDesc+(__Offset*16)+8, 0, 32, __Valeu)
-
-// Dword 0
-#define SET_TX_BUFF_DESC_LEN_0_92E(__pTxDesc, __Valeu) SET_BITS_TO_LE_4BYTE(__pTxDesc, 0, 16, __Valeu)
-#define SET_TX_BUFF_DESC_PSB_92E(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc, 16, 8, __Value)
-#define SET_TX_BUFF_DESC_OWN_92E(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc, 31, 1, __Value)
-// Dword 1
-#define SET_TX_BUFF_DESC_ADDR_LOW_0_92E(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+4, 0, 32, __Value)
-#define GET_TX_DESC_TX_BUFFER_ADDRESS_92E(__pTxDesc) LE_BITS_TO_4BYTE(__pTxDesc+4, 0,32)
-
-
-// Dword 2
-#define SET_TX_BUFF_DESC_ADDR_HIGH_0_92E(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+8, 0, 32, __Value)
-// Dword 3, RESERVED
-
-
-#define SET_TX_DESC_OWN_92E(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc, 31, 1, __Value)
-
-#endif
-
-#endif
-
diff --git a/os/board/rtl8720e/src/component/wifi/driver/include/rtl8721d_hal.h b/os/board/rtl8720e/src/component/wifi/driver/include/rtl8721d_hal.h
deleted file mode 100644
index 49845c280..000000000
--- a/os/board/rtl8720e/src/component/wifi/driver/include/rtl8721d_hal.h
+++ /dev/null
@@ -1,583 +0,0 @@
-/******************************************************************************
- *
- * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of version 2 of the GNU General Public License as
- * published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
- * more details.
- *
- * You should have received a copy of the GNU General Public License along with
- * this program; if not, write to the Free Software Foundation, Inc.,
- * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
- *
- *
- ******************************************************************************/
-
-#ifndef __RTL8721D_HAL_H__
-#define __RTL8721D_HAL_H__
-
-#include "drv_types.h"
-//#include "rtl8721d/rtl8721d_pmu_task.h"
-#include "ameba_soc.h"
-#include "hal_data.h"
-
-#include "rtl8721d/rtl8721d_spec.h"
-#include "rtl8721d/rtl8721d_rf.h"
-#include "rtl8721d/rtl8721d_dm.h"
-#include "rtl8721d/rtl8721d_recv.h"
-#include "rtl8721d/rtl8721d_xmit.h"
-#include "rtl8721d/rtl8721d_cmd.h"
-//#include "rtl8721d/rtl8721d_pmu_cmd.h"
-#include "rtl8721d/Hal8721DPwrSeq.h"
-#include "rtl8721d/Hal8721DPhyReg.h"
-#include "rtl8721d/Hal8721DPhyCfg.h"
-#include "rtl8721d/rom_Hal8721DPhyCfg.h"
-#include "../src/hal/phydm/phydm_precomp.h"
-
-#if (RTL8721D_SUPPORT==1)
-//2TODO: We should define 8192S firmware related macro settings here!!
-#define RTL819X_DEFAULT_RF_TYPE			RF_1T2R
-#define RTL819X_TOTAL_RF_PATH				2
-
-//---------------------------------------------------------------------
-//		RTL8723BS From file
-//---------------------------------------------------------------------
-#define RTL8723B_FW_IMG					"rtl8723B\\rtl8723bfw.bin"
-#define RTL8721D_PHY_REG					"rtl8721D\\PHY_REG_1T.txt"
-#define RTL8721D_PHY_RADIO_A			"rtl8721D\\radio_a_1T.txt"
-#define RTL8721D_PHY_RADIO_B			"rtl8721D\\radio_b_1T.txt"
-#define RTL8721D_TXPWR_TRACK			"rtl8721D\\TxPowerTrack.txt"
-#define RTL8721D_AGC_TAB					"rtl8721D\\AGC_TAB_1T.txt"
-#define RTL8721D_PHY_MACREG				"rtl87195A\\MAC_REG.txt"
-#define RTL8721D_PHY_REG_PG				"rtl8721D\\PHY_REG_PG.txt"
-#define RTL8721D_PHY_REG_MP				"rtl8721D\\PHY_REG_MP.txt"
-#define RTL8721D_TXPWR_LMT 				"rtl8721D\\TXPWR_LMT.txt"
-
-//---------------------------------------------------------------------
-//		RTL8723BS From header
-//---------------------------------------------------------------------
-
-//#define Rtl8723B_FwImageArray				Array_MP_8723B_FW_NIC
-//#define Rtl8723B_FwImgArrayLength			ArrayLength_MP_8723B_FW_NIC
-//#define Rtl8723B_FwWoWImageArray			Array_MP_8723B_FW_WoWLAN
-//#define Rtl8723B_FwWoWImgArrayLength		ArrayLength_MP_8723B_FW_WoWLAN
-
-#define Rtl8721D_PHY_REG_Array_PG 			Rtl8723SPHY_REG_Array_PG
-#define Rtl8721D_PHY_REG_Array_PGLength	Rtl8723SPHY_REG_Array_PGLength
-
-#if MP_DRIVER == 1
-#define Rtl8721D_FwBTImgArray				Rtl8723BFwBTImgArray
-#define Rtl8721D_FwBTImgArrayLength		Rtl8723BFwBTImgArrayLength
-
-#define Rtl8721D_FwMPImageArray			Rtl8723BFwMPImgArray
-#define Rtl8721D_FwMPImgArrayLength		Rtl8723BMPImgArrayLength
-
-#define Rtl8721D_PHY_REG_Array_MP			Rtl8723B_PHYREG_Array_MP
-#define Rtl8721D_PHY_REG_Array_MPLength	Rtl8723B_PHYREG_Array_MPLength
-#endif
-
-#endif // RTL8721D_SUPPORT
-
-#define FW_8721D_SIZE			0x8000
-#define FW_8721D_START_ADDRESS	0x1000
-#define FW_8721D_END_ADDRESS		0x1FFF //0x5FFF
-
-#define IS_FW_HEADER_EXIST_8721D(_pFwHdr)	((GET_FIRMWARE_HDR_SIGNATURE(_pFwHdr)&0xFFF0) == 0x10B0)
-
-typedef struct _RT_FIRMWARE {
-	FIRMWARE_SOURCE	eFWSource;
-	u8			*szFwBuffer;
-	u32			ulFwLength;
-
-	u8			*szBTFwBuffer;
-	u32			ulBTFwLength;
-
-#ifdef CONFIG_WOWLAN
-	u8			*szWoWLANFwBuffer;
-	u32			ulWoWLANFwLength;
-#endif //CONFIG_WOWLAN
-} RT_FIRMWARE_8721D, *PRT_FIRMWARE_8721D;
-
-//
-// This structure must be cared byte-ordering
-//
-// Added by tynli. 2009.12.04.
-typedef struct _RT_8723B_FIRMWARE_HDR {
-	// 8-byte alinment required
-
-	//--- LONG WORD 0 ----
-	u16		Signature;	// 92C0: test chip; 92C, 88C0: test chip; 88C1: MP A-cut; 92C1: MP A-cut
-	u8		Category;	// AP/NIC and USB/PCI
-	u8		Function;	// Reserved for different FW function indcation, for further use when driver needs to download different FW in different conditions
-	u16		Version;		// FW Version
-	u8		Subversion;	// FW Subversion, default 0x00
-	u16		Rsvd1;
-
-
-	//--- LONG WORD 1 ----
-	u8		Month;	// Release time Month field
-	u8		Date;	// Release time Date field
-	u8		Hour;	// Release time Hour field
-	u8		Minute;	// Release time Minute field
-	u16		RamCodeSize;	// The size of RAM code
-	u16		Rsvd2;
-
-	//--- LONG WORD 2 ----
-	u32		SvnIdx;	// The SVN entry index
-	u32		Rsvd3;
-
-	//--- LONG WORD 3 ----
-	u32		Rsvd4;
-	u32		Rsvd5;
-} RT_8723B_FIRMWARE_HDR, *PRT_8723B_FIRMWARE_HDR;
-
-#define DRIVER_EARLY_INT_TIME_8721D         0x05 // 5ms
-#define BCN_DMA_ATIME_INT_TIME_8721D        0x02 // 2ms
-
-// for 8721D
-// TX 32K, RX 16K, Page size 128B for TX, 8B for RX
-#define PAGE_SIZE_TX_8721D                  128
-#define PAGE_SIZE_RX_8721D                  8
-
-#define RX_DMA_SIZE_8721D                   0x4000	// 16K
-#define RX_DMA_RESERVED_SIZE_8721D          0x80	// 128B, reserved for tx report
-#define RX_DMA_BOUNDARY_8721D               (RX_DMA_SIZE_8721D - RX_DMA_RESERVED_SIZE_8721D - 1)
-
-// Note: We will divide number of page equally for each queue other than public queue!
-
-//For General Reserved Page Number(Beacon Queue is reserved page)
-//Beacon:2, PS-Poll:1, Null Data:1,Qos Null Data:1,BT Qos Null Data:1
-#ifdef CONFIG_WLAN_HAL_TEST
-#define BCNQ_PAGE_NUM_8721D             0x00
-#else
-#define BCNQ_PAGE_NUM_8721D             0x08
-#endif
-
-#ifdef CONFIG_CONCURRENT_MODE
-#define BCNQ1_PAGE_NUM_8721D            0x04
-#else
-#define BCNQ1_PAGE_NUM_8721D            0x00
-#endif
-
-//For WoWLan , more reserved page
-//ARP Rsp:1, RWC:1, GTK Info:1,GTK RSP:2,GTK EXT MEM:2
-#ifdef CONFIG_WOWLAN
-#define WOWLAN_PAGE_NUM_8721D           0x07
-#else
-#define WOWLAN_PAGE_NUM_8721D           0x00
-#endif
-
-#ifdef CONFIG_WLAN_HAL_TEST
-#define TX_TOTAL_PAGE_NUMBER_8721D      (0xF8 - BCNQ_PAGE_NUM_8721D - BCNQ1_PAGE_NUM_8721D - WOWLAN_PAGE_NUM_8721D)
-//#define TX_TOTAL_PAGE_NUMBER_8721D      0x40
-#define TX_PAGE_BOUNDARY_8721D          (TX_TOTAL_PAGE_NUMBER_8721D + 1)
-#else
-#define TX_TOTAL_PAGE_NUMBER_8721D      (0xFF - BCNQ_PAGE_NUM_8721D - BCNQ1_PAGE_NUM_8721D - WOWLAN_PAGE_NUM_8721D)
-#define TX_PAGE_BOUNDARY_8721D          (TX_TOTAL_PAGE_NUMBER_8721D + 1)
-#endif
-
-#define WMM_NORMAL_TX_TOTAL_PAGE_NUMBER TX_TOTAL_PAGE_NUMBER_8721D
-#define WMM_NORMAL_TX_PAGE_BOUNDARY		(WMM_NORMAL_TX_TOTAL_PAGE_NUMBER + 1)
-
-// For Normal Chip Setting
-// (HPQ + LPQ + NPQ + PUBQ) shall be TX_TOTAL_PAGE_NUMBER_8721D
-#ifdef CONFIG_WLAN_HAL_TEST
-#define NORMAL_PAGE_NUM_HPQ_8721D		0x10
-#define NORMAL_PAGE_NUM_LPQ_8721D		0x10
-#define NORMAL_PAGE_NUM_NPQ_8721D		0x10
-#else
-#define NORMAL_PAGE_NUM_HPQ_8721D		0x0C
-#define NORMAL_PAGE_NUM_LPQ_8721D		0x02
-#define NORMAL_PAGE_NUM_NPQ_8721D		0x02
-#endif
-
-#ifdef CONFIG_WLAN_HAL_TEST
-#define WMM_NORMAL_PAGE_NUM_HPQ_8721D   0x10
-#define WMM_NORMAL_PAGE_NUM_LPQ_8721D   0x10
-#define WMM_NORMAL_PAGE_NUM_NPQ_8721D   0x10
-#else
-// Note: For Normal Chip Setting, modify later
-#define WMM_NORMAL_PAGE_NUM_HPQ_8721D   0x30
-#define WMM_NORMAL_PAGE_NUM_LPQ_8721D   0x20
-#define WMM_NORMAL_PAGE_NUM_NPQ_8721D   0x20
-#endif
-
-#include "HalVerDef.h"
-#include "hal_com.h"
-
-#define LX_DMA_IMR_DISABLED 0
-#define FW_IMR_DISABLED     0
-#define WL_PMC_IMR_DISABLED 0
-
-
-//========================================================
-//			EFUSE for BT definition
-//========================================================
-#define EFUSE_BT_REAL_BANK_CONTENT_LEN	512
-#define EFUSE_BT_REAL_CONTENT_LEN		1536	// 512*3
-#define EFUSE_BT_MAP_LEN				1024	// 1k bytes
-#define EFUSE_BT_MAX_SECTION			128		// 1024/8
-
-#define EFUSE_PROTECT_BYTES_BANK		16
-
-#define GET_RF_TYPE(priv)			(rtw_get_haldata(priv)->rf_type)
-
-// Description: Determine the types of C2H events that are the same in driver and Fw.
-// Fisrt constructed by tynli. 2009.10.09.
-typedef enum tag_Package_Definition {
-	PACKAGE_QFN48,
-	PACKAGE_QFN56,
-	PACKAGE_QFN68_RCU,
-	PACKAGE_QFN68,
-	PACKAGE_QFN88,
-	PACKAGE_QFN88_STR,
-} PACKAGE_TYPE_E;
-
-typedef enum tag_ChipID_Definition {
-	CHIPID_8710BN = 0xFF, /* PACKAGE_QFN32 */
-	CHIPID_8710BU = 0xFE, /* PACKAGE_QFN48_MCM */
-	CHIPID_8711BN = 0xFD, /* PACKAGE_QFN48 */
-	CHIPID_8711BU = 0xFC, /* PACKAGE_QFN68 */
-	CHIPID_8710BN_L0 = 0xFB, /* PACKAGE_QFN32, cpu clk: 62.5M, sram: 200K, flash io: 2-bit mode */
-	CHIPID_8710BN_VV2 = 0xFA, /* PACKAGE_QFN32, sram: 200k, special for Haier */
-	CHIPID_8710BN_A0_VV2 = 0xF8, /* PACKAGE_QFN32, the same as CHIPID_8710BN */
-} CHIP_TD_E;
-
-#define INCLUDE_MULTI_FUNC_BT(_Adapter)		(rtw_get_haldata(_Adapter)->MultiFunc & RT_MULTI_FUNC_BT)
-#define INCLUDE_MULTI_FUNC_GPS(_Adapter)	(rtw_get_haldata(_Adapter)->MultiFunc & RT_MULTI_FUNC_GPS)
-
-//========================================================
-//			TXBD and RXBD definition
-//========================================================
-#ifdef CONFIG_MP_INCLUDED	// For MP Tx no idle
-#define TX_VIQ_DESC_NUM         4
-#define TX_VOQ_DESC_NUM         4
-#define TX_BKQ_DESC_NUM         4
-#define TX_BEQ_DESC_NUM         32
-#else
-#define TX_VIQ_DESC_NUM         4
-#define TX_VOQ_DESC_NUM         4
-#define TX_BKQ_DESC_NUM         4
-#define TX_BEQ_DESC_NUM         4
-#endif
-#ifdef CONFIG_CONCURRENT_MODE
-#define TX_BCNQ_DESC_NUM        4
-#else
-#define TX_BCNQ_DESC_NUM        2
-#endif
-#define TX_MGQ_DESC_NUM         4
-#define TX_H0Q_DESC_NUM         4  // Increase Tx Hi Queue for BMcast Packets in SoftAP mode
-#define TX_H1Q_DESC_NUM         2
-#define TX_H2Q_DESC_NUM         2
-#define TX_H3Q_DESC_NUM         2
-#define TX_H4Q_DESC_NUM         2
-#define TX_H5Q_DESC_NUM         2
-#define TX_H6Q_DESC_NUM         2
-#define TX_H7Q_DESC_NUM         2
-#define RX_Q_DESC_NUM           4  //16 Reduce rx desc number due to memory limitation
-
-#define SET_VIQ_DES_NUM     (TX_VIQ_DESC_NUM<<16)
-#define SET_VOQ_DES_NUM     (TX_VOQ_DESC_NUM)
-#define SET_RXQ_DES_NUM     (RX_Q_DESC_NUM<<16)
-#define SET_MGQ_DES_NUM     (TX_MGQ_DESC_NUM)
-#define SET_BKQ_DES_NUM     (TX_BKQ_DESC_NUM<<16)
-#define SET_BEQ_DES_NUM     (TX_BEQ_DESC_NUM)
-#define SET_H1Q_DES_NUM     (TX_H1Q_DESC_NUM<<16)
-#define SET_H0Q_DES_NUM     (TX_H0Q_DESC_NUM)
-#define SET_H3Q_DES_NUM     (TX_H3Q_DESC_NUM<<16)
-#define SET_H2Q_DES_NUM     (TX_H2Q_DESC_NUM)
-#define SET_H5Q_DES_NUM     (TX_H5Q_DESC_NUM<<16)
-#define SET_H4Q_DES_NUM     (TX_H4Q_DESC_NUM)
-#define SET_H7Q_DES_NUM     (TX_H7Q_DESC_NUM<<16)
-#define SET_H6Q_DES_NUM     (TX_H6Q_DESC_NUM)
-
-#define TX_DESC_MODE        1
-
-//0: 2 segment
-//1: 4 segment
-//2: 8 segment
-//#define TX_DESC_MODE            2
-
-#define MAX_TXBD_SEQMENT_NUM    ((TX_DESC_MODE)? (4*TX_DESC_MODE): 2)
-#define TXBD_SEGMENT_SIZE		8
-
-
-
-typedef struct _RXBD_ELEMENT_ {
-	u32         Dword0;
-	u32         PhyAddr;
-} RXBD_ELEMENT, *PRXBD_ELEMENT;
-
-
-typedef struct _TXBD_ELEMENT_ {
-	u32         Dword0;
-	u32         AddrLow;
-} TXBD_ELEMENT, *PTXBD_ELEMENT;
-
-typedef struct _LX_DMA_ELEMENT_ {
-	u32         QueueTRxBdBase;
-	u32         HwIndex;
-	u32         HostIndex;
-	u32         AvaliableCnt;
-} LX_DMA_ELEMENT, *PLX_DMA_ELEMENT;
-#if 1
-
-typedef enum _LX_DMA_QUEUE_TYPE_ {
-	VO_QUEUE = 0,
-	VI_QUEUE = 1,
-	BE_QUEUE = 2,
-	BK_QUEUE = 3,
-	MG_QUEUE = 4,
-	RX_QUEUE = 5,
-	H0_QUEUE = 6,
-	H1_QUEUE = 7,
-	H2_QUEUE = 8,
-	H3_QUEUE = 9,
-	H4_QUEUE = 10,
-	H5_QUEUE = 11,
-	H6_QUEUE = 12,
-	H7_QUEUE = 13,
-	BCN_QUEUE = 14,
-	MAX_TX_QUEUE = 15,
-	ERROR_QUEUE = 16,
-} LX_DMA_QUEUE_TYPE, *PLX_DMA_QUEUE_TYPE;
-
-typedef struct _TX_FREE_QUEUE_ {
-	_queue               FreeQueue;
-	u32                  Qlen;
-} TX_FREE_QUEUE, *PTX_FREE_QUEUE;
-
-typedef struct _LX_DMA_MANAGER_ {
-	LX_DMA_ELEMENT       QueueTRxBd[MAX_TX_QUEUE];
-	u32                  QueueMaxValue[MAX_TX_QUEUE];
-	u32                  RxBdSkb[RX_Q_DESC_NUM];
-	u32                  RxLen;
-	u32                  RemainLen;
-	u16                  RxAggregateNum;
-	u16                  RxExpectTag;
-	u16                  RxSegFlow;
-	u16                  Flagls;
-	TX_FREE_QUEUE        TxFreeQueue[MAX_TX_QUEUE];
-
-} LX_DMA_MANAGER, *PLX_DMA_MANAGER;
-
-#else
-
-typedef struct _LX_DMA_MANAGER_ {
-	u32                 *pVoqTXBD;
-	u32                 *pViqTXBD;
-	u32                 *pBeqTXBD;
-	u32                 *pBkqTXBD;
-	u32                 *pBcnqTXBD;
-	u32                 *pMgqTXBD;
-	u32                 *pH0qTXBD;
-	u32                 *pH1qTXBD;
-	u32                 *pH2qTXBD;
-	u32                 *pH3qTXBD;
-	u32                 *pH4qTXBD;
-	u32                 *pH5qTXBD;
-	u32                 *pH6qTXBD;
-	u32                 *pH7qTXBD;
-	u32                 *pExViqTXBD;
-	u32                 *pExVoqTXBD;
-	u32                 *pExBeqTXBD;
-	u32                 *pExBkqTXBD;
-	u32                 *pExMgqTXBD;
-	u32                 *pRXBD;
-//    u4Byte                  RxAggBufEntry[RX_Q_DESC_NUM];
-//    u4Byte                  RxAggLenEntry[RX_Q_DESC_NUM];
-	u32                  RxLen;
-	u32                  RemainLen;
-	u16                  ViqTxWritePoint;
-	u16                  ViqTxReadPoint;
-	u16                  VoqTxWritePoint;
-	u16                  VoqTxReadPoint;
-	u16                  BeqTxWritePoint;
-	u16                  BeqTxReadPoint;
-	u16                  BkqTxWritePoint;
-	u16                  BkqTxReadPoint;
-	u16                  RxWritePoint;
-	u16                  RxReadPoint;
-	u16                  RxAggregateNum;
-	u16                  RxExpectTag;
-	u16                  RxSegFlow;
-	u16                  Flagls;
-} LX_DMA_MANAGER, *PLX_DMA_MANAGER;
-#endif
-
-// rtl8723a_hal_init.c
-s32 rtl8721d_FirmwareDownload(PADAPTER padapter, BOOLEAN  bUsedWoWLANFw);
-s32 rtl8721d_FirmwareDisable(PADAPTER padapter);
-void rtl8721d_InitializeFirmwareVars(PADAPTER padapter);
-
-void wifi_hal_read_adapterinfo(PADAPTER padapter);
-void wifi_hal_read_chipversion(PADAPTER padapter);
-void wifi_hal_init_haldata(PADAPTER padapter);
-void wifi_hal_free_haldata(PADAPTER padapter);
-u32 wifi_hal_init(PADAPTER padapter);
-u32 wifi_hal_deinit(PADAPTER padapter);
-
-void rtl8721d_InitAntenna_Selection(PADAPTER padapter);
-void rtl8721d_DeinitAntenna_Selection(PADAPTER padapter);
-void rtl8721d_CheckAntenna_Selection(PADAPTER padapter);
-
-s32 rtl8721d_InitLLTTable(PADAPTER padapter);
-
-s32 CardDisableHWSM(PADAPTER padapter, u8 resetMCU);
-s32 CardDisableWithoutHWSM(PADAPTER padapter);
-
-// EFuse
-//u8 GetEEPROMSize8721d(PADAPTER padapter);
-void Hal_InitPGData(PADAPTER padapter, u8 *PROMContent);
-void Hal_EfuseParseIDCode(PADAPTER padapter, u8 *hwinfo, u8 *autoload_fail_flag);
-void Hal_EfuseParseTxPowerInfo_8721D(PADAPTER padapter, u8 *PROMContent, BOOLEAN AutoLoadFail);
-void Hal_EfuseParseBTCoexistInfo_8721D(PADAPTER padapter, u8 *hwinfo, BOOLEAN AutoLoadFail);
-void Hal_EfuseParseEEPROMVer_8721D(PADAPTER padapter, u8 *hwinfo, BOOLEAN AutoLoadFail);
-void Hal_EfuseParseChnlPlan_8721D(PADAPTER padapter, u8 *hwinfo, BOOLEAN AutoLoadFail);
-void Hal_EfuseParseCustomerID_8721D(PADAPTER padapter, u8 *hwinfo, BOOLEAN AutoLoadFail);
-void Hal_EfuseParseAntennaDiversity_8721D(PADAPTER padapter, u8 *hwinfo, BOOLEAN AutoLoadFail);
-void Hal_EfuseParseXtal_8721D(PADAPTER pAdapter, u8 *hwinfo, u8 AutoLoadFail);
-void Hal_EfuseParseThermalMeter_8721D(PADAPTER padapter, u8 *hwinfo, u8 AutoLoadFail);
-void wifi_hal_get_efusedefinition(PADAPTER	padapter, u8 efuseType, u8 type, void *pOut, u8 bPseudoTest);
-
-//bt enable in efuse
-bool Hal_BT_Is_Supported(PADAPTER padapter);
-bool Hal_BT_Mesh_Is_Supported(PADAPTER padapter);
-//DPK date in flash
-u8 rtw_dpk_map_read(PADAPTER padapter);
-u8 rtw_dpk_map_write(PADAPTER padapter);
-
-#ifdef CONFIG_C2H_PACKET_EN
-void C2HPacketHandler_8721D(PADAPTER padapter, u8 *pbuffer, u16 length);
-#endif
-
-u8 rtw_flash_read(PADAPTER padapter, u16 addr, u16 cnts, u8 *data);
-u8 rtw_flash_write(PADAPTER padapter, u16 addr, u16 cnts, u8 *data);
-u8 rtw_config_map_read(PADAPTER padapter, u16 addr, u16 cnts, u8 *data, u8 is_phycial);
-u8 rtw_config_map_write(PADAPTER padapter, u16 addr, u16 cnts, u8 *data, u8 is_phycial);
-
-void rtl8721d_ResumeTxBeacon(PADAPTER padapter);
-void rtl8721d_StopTxBeacon(PADAPTER padapter);
-void ROM_WIFI_TxBeacon_Ctrl(u8 enable);
-
-void wifi_hal_hwreg_set(PADAPTER padapter, u8 variable, u8 *val);
-void wifi_hal_hwreg_get(PADAPTER padapter, u8 variable, u8 *val);
-u8 wifi_hal_defaultvar_set(PADAPTER padapter, HAL_DEF_VARIABLE variable, void *pval);
-u8 wifi_hal_defaultvar_get(PADAPTER padapter, HAL_DEF_VARIABLE variable, void *pval);
-void wifi_hal_odmvar_set(PADAPTER Adapter, HAL_ODM_VARIABLE eVariable, PVOID pValue1, BOOLEAN bSet);
-void wifi_hal_odmvar_get(PADAPTER Adapter, HAL_ODM_VARIABLE eVariable, PVOID pValue1, PVOID pValue2);
-void ROM_WIFI_Set_AC_Param(u32 ACParam[], u32 *pBE_param);
-#define wifi_hal_set_ac_param ROM_WIFI_Set_AC_Param
-void ROM_WIFI_WRITE_CAM(u8 entry, u16 ctrl, u8 *mac, u8 *key);
-void ROM_WIFI_READ_CAM(u8 id, u8 *ctrl, u8 *mac, u8 *key);
-#define wifi_rom_write_cam(entry, ctrl, mac, key)	ROM_WIFI_WRITE_CAM(entry, ctrl, mac, key)
-#define wifi_rom_read_cam(id, ctrl, mac, key)	ROM_WIFI_READ_CAM(id, ctrl, mac, key)
-#define write_cam_spp_amsdu_valid(entry, value) ROM_WIFI_WriteCamSppAmsduValid(entry, value)
-#define clear_cam_entry(entry) ROM_WIFI_ClearCamEntry(entry)
-
-// register
-void rtl8721d_InitBeaconParameters(PADAPTER padapter);
-void rtl8721d_InitBeaconMaxError(PADAPTER padapter, u8 InfraMode);
-void	_InitBurstPktLen_8721DB(PADAPTER Adapter);
-#ifdef CONFIG_WOWLAN
-void _8051Reset8721d(PADAPTER padapter);
-#endif //CONFIG_WOWLAN
-
-#if defined(CONFIG_CHECK_BT_HANG) && defined(CONFIG_BT_COEXIST)
-void rtl8721dd_init_checkbthang_workqueue(_adapter *adapter);
-void rtl8721dd_free_checkbthang_workqueue(_adapter *adapter);
-void rtl8721dd_cancle_checkbthang_workqueue(_adapter *adapter);
-void rtl8721dd_hal_check_bt_hang(_adapter *adapter);
-#endif
-
-#ifdef CONFIG_WOWLAN
-void rtw_get_current_ip_address(PADAPTER padapter, u8 *pcurrentip);
-void rtw_get_current_gw_address(PADAPTER padapter, u8 *pcurrentgw);
-void rtw_get_current_mask_address(PADAPTER padapter, u8 *pgwmask);
-void rtw_get_sec_iv(PADAPTER padapter, u8 *pcur_dot11txpn, u8 *StaAddr);
-#endif
-
-u32 rtl8721d_wlan_suspend(u32 expected_idle_time, void *param);
-u32 rtl8721d_wlan_late_resume(u32 expected_idle_time, void *param);
-u32 rtl8721d_wlan_resume(u32 expected_idle_time, void *param);
-void rtl8721d_tcp_suspend_indicate(struct xmit_frame *pxmitframe);
-
-#ifdef CONFIG_GPIO_WAKEUP
-void HalSetOutPutGPIO(PADAPTER padapter, u8 index, u8 OutPutValue);
-#endif
-
-void CCX_FwC2HTxRpt_8721D(PADAPTER padapter, u8 *pdata, u8 len);
-s32 c2h_id_filter_ccx_8721D(u8 *buf);
-//s32 c2h_handler_8721D(PADAPTER padapter, u8 *pC2hEvent);
-u8 MRateToHwRate8723B(u8  rate);
-u8 HwRateToMRate8723B(u8	 rate);
-
-void wifi_hal_dbg(_adapter *padapter, struct rtw_point *p);
-int wifi_hal_phydm_dbg(_adapter *padapter, union rtwreq_data *wrqu);
-int wifi_hal_iwpriv_command(unsigned char wlan_idx, char *cmd, int show_msg);
-
-//1TODO: Chris
-#if 1
-
-//=============
-// [1] Rx Buffer Descriptor (for PCIE) buffer descriptor architecture
-//DWORD 0
-#define SET_RX_BUFFER_DESC_DATA_LENGTH_92E(__pRxStatusDesc, __Value)		SET_BITS_TO_LE_4BYTE( __pRxStatusDesc, 0, 14, __Value)
-#define SET_RX_BUFFER_DESC_LS_92E(__pRxStatusDesc,__Value)	SET_BITS_TO_LE_4BYTE( __pRxStatusDesc, 14, 1, __Value)
-#define SET_RX_BUFFER_DESC_FS_92E(__pRxStatusDesc, __Value)		SET_BITS_TO_LE_4BYTE( __pRxStatusDesc, 15, 1, __Value)
-#define SET_RX_BUFFER_DESC_RX_TAG_92E(__pRxStatusDesc, __Value)		SET_BITS_TO_LE_4BYTE( __pRxStatusDesc, 16, 13, __Value)
-
-#define GET_RX_BUFFER_DESC_OWN_92E(__pRxStatusDesc)		LE_BITS_TO_4BYTE( __pRxStatusDesc, 31, 1)
-#define GET_RX_BUFFER_DESC_LS_92E(__pRxStatusDesc)		LE_BITS_TO_4BYTE( __pRxStatusDesc, 14, 1)
-#define GET_RX_BUFFER_DESC_FS_92E(__pRxStatusDesc)		LE_BITS_TO_4BYTE( __pRxStatusDesc, 15, 1)
-#define GET_RX_BUFFER_DESC_RX_TAG_92E(__pRxStatusDesc)		LE_BITS_TO_4BYTE( __pRxStatusDesc, 16, 13)
-#define GET_RX_BUFFER_DESC_TOTAL_LENGTH_92E(__pRxStatusDesc)LE_BITS_TO_4BYTE( __pRxStatusDesc, 0, 14)
-
-
-//DWORD 1
-#define SET_RX_BUFFER_PHYSICAL_LOW_92E(__pRxStatusDesc, __Value)		SET_BITS_TO_LE_4BYTE( __pRxStatusDesc+4, 0, 32, __Value)
-#define GET_RX_BUFFER_PHYSICAL_LOW_92E(__pRxStatusDesc)		LE_BITS_TO_4BYTE( __pRxStatusDesc+4, 0, 32)
-
-//DWORD 2
-#define SET_RX_BUFFER_PHYSICAL_HIGH_92E(__pRxStatusDesc, __Value)		SET_BITS_TO_LE_4BYTE( __pRxStatusDesc+8, 0, 32, __Value)
-
-
-//=====Tx Desc Buffer content
-
-// config element for each tx buffer
-/*
-#define SET_TXBUFFER_DESC_LEN_WITH_OFFSET(__pTxDesc, __Offset, __Valeu) SET_BITS_TO_LE_4BYTE(__pTxDesc+(__Offset*16), 0, 16, __Valeu)
-#define SET_TXBUFFER_DESC_AMSDU_WITH_OFFSET(__pTxDesc, __Offset, __Valeu) SET_BITS_TO_LE_4BYTE(__pTxDesc+(__Offset*16), 31, 1, __Valeu)
-#define SET_TXBUFFER_DESC_ADD_LOW_WITH_OFFSET(__pTxDesc, __Offset, __Valeu) SET_BITS_TO_LE_4BYTE(__pTxDesc+(__Offset*16)+4, 0, 32, __Valeu)
-#define SET_TXBUFFER_DESC_ADD_HIGT_WITH_OFFSET(__pTxDesc, __Offset, __Valeu) SET_BITS_TO_LE_4BYTE(__pTxDesc+(__Offset*16)+8, 0, 32, __Valeu)
-*/
-#define SET_TXBUFFER_DESC_LEN_WITH_OFFSET(__pTxDesc, __Offset, __Valeu) SET_BITS_TO_LE_4BYTE(__pTxDesc+(__Offset*8), 0, 16, __Valeu)
-#define SET_TXBUFFER_DESC_AMSDU_WITH_OFFSET(__pTxDesc, __Offset, __Valeu) SET_BITS_TO_LE_4BYTE(__pTxDesc+(__Offset*8), 31, 1, __Valeu)
-#define SET_TXBUFFER_DESC_ADD_LOW_WITH_OFFSET(__pTxDesc, __Offset, __Valeu) SET_BITS_TO_LE_4BYTE(__pTxDesc+(__Offset*8)+4, 0, 32, __Valeu)
-#define SET_TXBUFFER_DESC_ADD_HIGT_WITH_OFFSET(__pTxDesc, __Offset, __Valeu) SET_BITS_TO_LE_4BYTE(__pTxDesc+(__Offset*16)+8, 0, 32, __Valeu)
-
-// Dword 0
-#define SET_TX_BUFF_DESC_LEN_0_92E(__pTxDesc, __Valeu) SET_BITS_TO_LE_4BYTE(__pTxDesc, 0, 16, __Valeu)
-#define SET_TX_BUFF_DESC_PSB_92E(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc, 16, 8, __Value)
-#define SET_TX_BUFF_DESC_OWN_92E(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc, 31, 1, __Value)
-// Dword 1
-#define SET_TX_BUFF_DESC_ADDR_LOW_0_92E(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+4, 0, 32, __Value)
-#define GET_TX_DESC_TX_BUFFER_ADDRESS_92E(__pTxDesc) LE_BITS_TO_4BYTE(__pTxDesc+4, 0,32)
-
-
-// Dword 2
-#define SET_TX_BUFF_DESC_ADDR_HIGH_0_92E(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc+8, 0, 32, __Value)
-// Dword 3, RESERVED
-
-
-#define SET_TX_DESC_OWN_92E(__pTxDesc, __Value) SET_BITS_TO_LE_4BYTE(__pTxDesc, 31, 1, __Value)
-
-#endif
-
-#endif
-
diff --git a/os/board/rtl8720e/src/component/wifi/driver/include/rtw_80211frame.h b/os/board/rtl8720e/src/component/wifi/driver/include/rtw_80211frame.h
deleted file mode 100644
index c2f32b5b8..000000000
--- a/os/board/rtl8720e/src/component/wifi/driver/include/rtw_80211frame.h
+++ /dev/null
@@ -1,113 +0,0 @@
-/******************************************************************************
- *
- * Copyright(c) 2007 - 2012 Realtek Corporation. All rights reserved.
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of version 2 of the GNU General Public License as
- * published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
- * more details.
- *
- * You should have received a copy of the GNU General Public License along with
- * this program; if not, write to the Free Software Foundation, Inc.,
- * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
- *
- *
- ******************************************************************************/
-#ifndef __RTW_80211FRAME_H_
-#define __RTW_80211FRAME_H_
-
-extern const u8 WMM_OUI[];
-extern const u8 WPS_OUI[];
-extern const u8 WFD_OUI[];
-extern const u8 P2P_OUI[];
-
-//extern const unsigned char WMM_INFO_OUI[];
-extern const u8	WMM_PARA_OUI[];
-
-struct mlme_handler {
-	unsigned int   num;
-	unsigned int (*func)(_adapter *padapter, union recv_frame *precv_frame);
-};
-
-struct action_handler {
-	unsigned int   num;
-	unsigned int (*func)(_adapter *padapter, union recv_frame *precv_frame);
-};
-
-
-/* WFA Transition Disable KDE (using OUI_WFA) */
-/* Transition Disable Bitmap bits */
-#define TRANSITION_DISABLE_WPA3_PERSONAL BIT(0)
-#define TRANSITION_DISABLE_SAE_PK BIT(1)
-#define TRANSITION_DISABLE_WPA3_ENTERPRISE BIT(2)
-#define TRANSITION_DISABLE_ENHANCED_OPEN BIT(3)
-
-void update_mgntframe_attrib(_adapter *padapter, struct pkt_attrib *pattrib);
-int dump_mgntframe(_adapter *padapter, struct xmit_frame *pmgntframe);
-
-void issue_beacon(_adapter *padapter);
-void issue_probersp(_adapter *padapter, unsigned char *da, u8 is_valid_p2p_probereq);
-void issue_assocreq(_adapter *padapter, u8 is_reassoc);
-void issue_asocrsp(_adapter *padapter, unsigned short status, struct sta_info *pstat, int pkt_type);
-void issue_auth(_adapter *padapter, struct sta_info *psta, unsigned short status);
-//	Added by Albert 2010/07/26
-//	blnbc: 1 -> broadcast probe request
-//	blnbc: 0 -> unicast probe request. The address 1 will be the BSSID.
-void issue_probereq(_adapter *padapter, NDIS_802_11_SSID *pssid, u8 blnbc);
-void issue_nulldata(_adapter *padapter, unsigned int power_mode);
-void issue_qos_nulldata(_adapter *padapter, unsigned char *da, u16 tid);
-void issue_deauth(_adapter *padapter, unsigned char *da, u32 reason);
-
-void issue_action_BA(_adapter *padapter, unsigned char *raddr, unsigned char action, unsigned short status);
-#ifdef CONFIG_IEEE80211W
-void issue_action_SA_Query(_adapter *padapter, unsigned char *raddr, unsigned char action, unsigned short tid, u8 key_type);
-#endif
-
-unsigned int send_delba(_adapter *padapter, u8 initiator, u8 *addr);
-
-unsigned int OnAssocReq(_adapter *padapter, union recv_frame *precv_frame);
-void OnAssocRsp_HT(_adapter *padapter);
-void OnAssocRsp_WMM(_adapter *padapter);
-unsigned int OnAssocRsp(_adapter *padapter, union recv_frame *precv_frame);
-unsigned int OnProbeReq(_adapter *padapter, union recv_frame *precv_frame);
-unsigned int OnProbeRsp(_adapter *padapter, union recv_frame *precv_frame);
-unsigned int DoReserved(_adapter *padapter, union recv_frame *precv_frame);
-#ifdef CONFIG_DFS
-void OnBeacon_csa(_adapter *padapter, u8 *pframe, uint len);
-#endif //CONFIG_DFS
-unsigned int OnBeacon(_adapter *padapter, union recv_frame *precv_frame);
-unsigned int OnAtim(_adapter *padapter, union recv_frame *precv_frame);
-unsigned int OnDisassoc(_adapter *padapter, union recv_frame *precv_frame);
-unsigned int OnAuth(_adapter *padapter, union recv_frame *precv_frame);
-unsigned int OnAuthClient(_adapter *padapter, union recv_frame *precv_frame);
-unsigned int OnDeAuth(_adapter *padapter, union recv_frame *precv_frame);
-unsigned int OnAction(_adapter *padapter, union recv_frame *precv_frame);
-
-unsigned int OnAction_qos(_adapter *padapter, union recv_frame *precv_frame);
-unsigned int OnAction_dls(_adapter *padapter, union recv_frame *precv_frame);
-unsigned int OnAction_back(_adapter *padapter, union recv_frame *precv_frame);
-unsigned int OnAction_public(_adapter *padapter, union recv_frame *precv_frame);
-unsigned int OnAction_ht(_adapter *padapter, union recv_frame *precv_frame);
-#ifdef CONFIG_IEEE80211W
-unsigned int OnAction_sa_query(_adapter *padapter, union recv_frame *precv_frame);
-#endif
-#ifdef CONFIG_RTW_WNM
-unsigned int OnAction_wnm(_adapter *adapter, union recv_frame *precv_frame);
-#endif
-unsigned int OnAction_wmm(_adapter *padapter, union recv_frame *precv_frame);
-unsigned int OnAction_csa(_adapter *padapter, union recv_frame *precv_frame);
-#ifdef CONFIG_TWT
-void issue_action_twt(_adapter *padapter, u8 setup, struct twt_ie_t *twt_ie);
-unsigned int OnAction_twt(_adapter *padapter, union recv_frame *precv_frame);
-#endif
-#ifdef CONFIG_80211AC_VHT
-unsigned int OnAction_vht(_adapter *padapter, union recv_frame *precv_frame);
-#endif
-
-
-#endif
-
diff --git a/os/board/rtl8720e/src/component/wifi/driver/include/rtw_80211spec_enum.h b/os/board/rtl8720e/src/component/wifi/driver/include/rtw_80211spec_enum.h
new file mode 100755
index 000000000..828fc37e0
--- /dev/null
+++ b/os/board/rtl8720e/src/component/wifi/driver/include/rtw_80211spec_enum.h
@@ -0,0 +1,292 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+#ifndef	__RTW_80211SPEC_ENUM_H_
+#define __RTW_80211SPEC_ENUM_H_
+
+enum WIFI_FRAME_TYPE {
+	WIFI_MGT_TYPE  =	(0),
+	WIFI_CTRL_TYPE =	(BIT(2)),
+	WIFI_DATA_TYPE =	(BIT(3)),
+	WIFI_QOS_DATA_TYPE	= (BIT(7) | BIT(3)),	//!< QoS Data
+};
+
+enum WIFI_FRAME_SUBTYPE {
+	// below is for mgt frame
+	WIFI_ASSOCREQ       = (0 | WIFI_MGT_TYPE),
+	WIFI_ASSOCRSP       = (BIT(4) | WIFI_MGT_TYPE),
+	WIFI_REASSOCREQ     = (BIT(5) | WIFI_MGT_TYPE),
+	WIFI_REASSOCRSP     = (BIT(5) | BIT(4) | WIFI_MGT_TYPE),
+	WIFI_PROBEREQ       = (BIT(6) | WIFI_MGT_TYPE),
+	WIFI_PROBERSP       = (BIT(6) | BIT(4) | WIFI_MGT_TYPE),
+	WIFI_BEACON         = (BIT(7) | WIFI_MGT_TYPE),
+	WIFI_ATIM           = (BIT(7) | BIT(4) | WIFI_MGT_TYPE),
+	WIFI_DISASSOC       = (BIT(7) | BIT(5) | WIFI_MGT_TYPE),
+	WIFI_AUTH           = (BIT(7) | BIT(5) | BIT(4) | WIFI_MGT_TYPE),
+	WIFI_DEAUTH         = (BIT(7) | BIT(6) | WIFI_MGT_TYPE),
+	WIFI_ACTION         = (BIT(7) | BIT(6) | BIT(4) | WIFI_MGT_TYPE),
+
+	// below is for control frame
+	WIFI_PSPOLL         = (BIT(7) | BIT(5) | WIFI_CTRL_TYPE),
+	WIFI_RTS            = (BIT(7) | BIT(5) | BIT(4) | WIFI_CTRL_TYPE),
+	WIFI_CTS            = (BIT(7) | BIT(6) | WIFI_CTRL_TYPE),
+	WIFI_ACK            = (BIT(7) | BIT(6) | BIT(4) | WIFI_CTRL_TYPE),
+	WIFI_CFEND          = (BIT(7) | BIT(6) | BIT(5) | WIFI_CTRL_TYPE),
+	WIFI_CFEND_CFACK    = (BIT(7) | BIT(6) | BIT(5) | BIT(4) | WIFI_CTRL_TYPE),
+	WIFI_TRIGGER        = (BIT(5) | WIFI_CTRL_TYPE),
+
+	// below is for data frame
+	WIFI_DATA           = (0 | WIFI_DATA_TYPE),
+	WIFI_DATA_CFACK     = (BIT(4) | WIFI_DATA_TYPE),
+	WIFI_DATA_CFPOLL    = (BIT(5) | WIFI_DATA_TYPE),
+	WIFI_DATA_CFACKPOLL = (BIT(5) | BIT(4) | WIFI_DATA_TYPE),
+	WIFI_DATA_NULL      = (BIT(6) | WIFI_DATA_TYPE),
+	WIFI_CF_ACK         = (BIT(6) | BIT(4) | WIFI_DATA_TYPE),
+	WIFI_CF_POLL        = (BIT(6) | BIT(5) | WIFI_DATA_TYPE),
+	WIFI_CF_ACKPOLL     = (BIT(6) | BIT(5) | BIT(4) | WIFI_DATA_TYPE),
+	WIFI_QOS_DATA_NULL	= (BIT(6) | WIFI_QOS_DATA_TYPE),
+};
+
+
+typedef	enum _ELEMENT_ID {
+	EID_SsId					= 0, /* service set identifier (0:32) */
+	EID_SupRates				= 1, /* supported rates (1:8) */
+	EID_FHParms				= 2, /* FH parameter set (5) */
+	EID_DSParms				= 3, /* DS parameter set (1) */
+	EID_CFParms				= 4, /* CF parameter set (6) */
+	EID_Tim						= 5, /* Traffic Information Map (4:254) */
+	EID_IbssParms				= 6, /* IBSS parameter set (2) */
+	EID_Country					= 7, /* */
+
+	/* Form 7.3.2: Information elements in 802.11E/D13.0, page 46. */
+	EID_QBSSLoad				= 11,
+	EID_EDCAParms				= 12,
+	EID_TSpec					= 13,
+	EID_TClass					= 14,
+	EID_Schedule				= 15,
+	/*  */
+
+	EID_Ctext					= 16, /* challenge text*/
+	EID_POWER_CONSTRAINT		= 32, /* Power Constraint*/
+
+	/* vivi for WIFITest, 802.11h AP, 20100427 */
+	/* 2010/12/26 MH The definition we can declare always!! */
+	EID_PowerCap				= 33,
+	EID_TPC				= 35,
+	EID_SupportedChannels		= 36,
+	EID_ChlSwitchAnnounce		= 37,
+
+	EID_MeasureRequest			= 38, /* Measurement Request */
+	EID_MeasureReport			= 39, /* Measurement Report */
+
+	EID_ERPInfo				= 42,
+
+	/* Form 7.3.2: Information elements in 802.11E/D13.0, page 46. */
+	EID_TSDelay				= 43,
+	EID_TCLASProc				= 44,
+	EID_HTCapability			= 45,
+	EID_QoSCap					= 46,
+	/*  */
+
+	EID_WPA2					= 48,
+	EID_ExtSupRates			= 50,
+
+	EID_FTIE					= 55, /* Defined in 802.11r */
+	EID_Timeout				= 56, /* Defined in 802.11r */
+
+	EID_SupRegulatory			= 59, /* Supported Requlatory Classes 802.11y */
+	EID_HTInfo					= 61,
+	EID_SecondaryChnlOffset		= 62,
+
+	EID_BSSCoexistence			= 72, /* 20/40 BSS Coexistence */
+	EID_BSSIntolerantChlReport	= 73,
+	EID_OBSS					= 74, /* Overlapping BSS Scan Parameters */
+
+	EID_LinkIdentifier			= 101, /* Defined in 802.11z */
+	EID_WakeupSchedule		= 102, /* Defined in 802.11z */
+	EID_ChnlSwitchTimeing		= 104, /* Defined in 802.11z */
+	EID_PTIControl				= 105, /* Defined in 802.11z */
+	EID_PUBufferStatus			= 106, /* Defined in 802.11z */
+
+	EID_EXTCapability			= 127, /* Extended Capabilities */
+	/* From S19:Aironet IE and S21:AP IP address IE in CCX v1.13, p16 and p18. */
+	EID_Aironet					= 133, /* 0x85: Aironet Element for Cisco CCX */
+	EID_CiscoIP					= 149, /* 0x95: IP Address IE for Cisco CCX */
+
+	EID_CellPwr					= 150, /* 0x96: Cell Power Limit IE. Ref. 0x96. */
+
+	EID_CCKM					= 156,
+
+	EID_Vendor					= 221, /* 0xDD: Vendor Specific */
+
+	EID_WAPI					= 68,
+	EID_VHTCapability 			= 191, /* Based on 802.11ac D2.0 */
+	EID_VHTOperation 			= 192, /* Based on 802.11ac D2.0 */
+	EID_AID						= 197, /* Based on 802.11ac D4.0 */
+	EID_OpModeNotification		= 199, /* Based on 802.11ac D3.0 */
+} ELEMENT_ID, *PELEMENT_ID;
+
+typedef enum _HT_CAP_AMPDU_FACTOR {
+	MAX_AMPDU_FACTOR_8K		= 0,
+	MAX_AMPDU_FACTOR_16K	= 1,
+	MAX_AMPDU_FACTOR_32K	= 2,
+	MAX_AMPDU_FACTOR_64K	= 3,
+} HT_CAP_AMPDU_FACTOR;
+
+enum WIFI_REASON_CODE	{
+	_RSON_RESERVED_					= 0,
+	_RSON_UNSPECIFIED_				= 1,
+	_RSON_AUTH_NO_LONGER_VALID_		= 2,
+	_RSON_DEAUTH_STA_LEAVING_		= 3,
+	_RSON_INACTIVITY_				= 4,
+	_RSON_UNABLE_HANDLE_			= 5,
+	_RSON_CLS2_						= 6,
+	_RSON_CLS3_						= 7,
+	_RSON_DISAOC_STA_LEAVING_		= 8,
+	_RSON_ASOC_NOT_AUTH_			= 9,
+
+	// WPA reason
+	_RSON_INVALID_IE_				= 13,
+	_RSON_MIC_FAILURE_				= 14,
+	_RSON_4WAY_HNDSHK_TIMEOUT_		= 15,
+	_RSON_GROUP_KEY_UPDATE_TIMEOUT_	= 16,
+	_RSON_DIFF_IE_					= 17,
+	_RSON_MLTCST_CIPHER_NOT_VALID_	= 18,
+	_RSON_UNICST_CIPHER_NOT_VALID_	= 19,
+	_RSON_AKMP_NOT_VALID_			= 20,
+	_RSON_UNSUPPORT_RSNE_VER_		= 21,
+	_RSON_INVALID_RSNE_CAP_			= 22,
+	_RSON_IEEE_802DOT1X_AUTH_FAIL_	= 23,
+
+	//belowing are Realtek definition
+	_RSON_PMK_NOT_AVAILABLE_		= 24,
+	_RSON_TDLS_TEAR_TOOFAR_			= 25,
+	_RSON_TDLS_TEAR_UN_RSN_			= 26,
+};
+
+/* SPECTRUM_MGMT action code */
+enum rtw_ieee80211_spectrum_mgmt_actioncode {
+	RTW_WLAN_ACTION_SPCT_MSR_REQ = 0,
+	RTW_WLAN_ACTION_SPCT_MSR_RPRT = 1,
+	RTW_WLAN_ACTION_SPCT_TPC_REQ = 2,
+	RTW_WLAN_ACTION_SPCT_TPC_RPRT = 3,
+	RTW_WLAN_ACTION_SPCT_CHL_SWITCH = 4,
+	RTW_WLAN_ACTION_SPCT_EXT_CHL_SWITCH = 5,
+};
+
+enum _PUBLIC_ACTION {
+	ACT_PUBLIC_BSSCOEXIST = 0, // 20/40 BSS Coexistence
+	ACT_PUBLIC_DSE_ENABLE = 1,
+	ACT_PUBLIC_DSE_DEENABLE = 2,
+	ACT_PUBLIC_DSE_REG_LOCATION = 3,
+	ACT_PUBLIC_EXT_CHL_SWITCH = 4,
+	ACT_PUBLIC_DSE_MSR_REQ = 5,
+	ACT_PUBLIC_DSE_MSR_RPRT = 6,
+	ACT_PUBLIC_MP = 7, // Measurement Pilot
+	ACT_PUBLIC_DSE_PWR_CONSTRAINT = 8,
+	ACT_PUBLIC_VENDOR = 9, // for WIFI_DIRECT
+	ACT_PUBLIC_GAS_INITIAL_REQ = 10,
+	ACT_PUBLIC_GAS_INITIAL_RSP = 11,
+	ACT_PUBLIC_GAS_COMEBACK_REQ = 12,
+	ACT_PUBLIC_GAS_COMEBACK_RSP = 13,
+	ACT_PUBLIC_TDLS_DISCOVERY_RSP = 14,
+	ACT_PUBLIC_LOCATION_TRACK = 15,
+	ACT_PUBLIC_MAX
+};
+
+/* HT features action code */
+enum rtw_ieee80211_ht_actioncode {
+	RTW_WLAN_ACTION_NOTIFY_CH_WIDTH = 0,
+	RTW_WLAN_ACTION_SM_PS = 1,
+	RTW_WLAN_ACTION_PSPM = 2,
+	RTW_WLAN_ACTION_PCO_PHASE = 3,
+	RTW_WLAN_ACTION_MIMO_CSI_MX = 4,
+	RTW_WLAN_ACTION_MIMO_NONCP_BF = 5,
+	RTW_WLAN_ACTION_MIMP_CP_BF = 6,
+	RTW_WLAN_ACTION_ASEL_INDICATES_FB = 7,
+	RTW_WLAN_ACTION_HI_INFO_EXCHG = 8,
+};
+
+/* VHT features action code */
+enum rtw_ieee80211_vht_actioncode {
+	RTW_WLAN_ACTION_VHT_COMPRESSED_BEAMFORMING = 0,
+	RTW_WLAN_ACTION_VHT_GROUPID_MANAGEMENT = 1,
+	RTW_WLAN_ACTION_VHT_OPMODE_NOTIFICATION = 2,
+};
+
+/* BACK (block-ack) parties */
+enum rtw_ieee80211_back_parties {
+	RTW_WLAN_BACK_RECIPIENT = 0,
+	RTW_WLAN_BACK_INITIATOR = 1,
+	RTW_WLAN_BACK_TIMER = 2,
+};
+
+enum secondary_ch_offset {
+	RTW_WLAN_SCN = 0, /* no secondary channel */
+	RTW_WLAN_SCA = 1, /* secondary channel above */
+	RTW_WLAN_SCB = 3,  /* secondary channel below */
+};
+
+/* Self Protected Action codes */
+enum rtw_ieee80211_self_protected_actioncode {
+	RTW_WLAN_SP_RESERVED = 0,
+	RTW_WLAN_SP_MESH_PEERING_OPEN = 1,
+	RTW_WLAN_SP_MESH_PEERING_CONFIRM = 2,
+	RTW_WLAN_SP_MESH_PEERING_CLOSE = 3,
+	RTW_WLAN_SP_MGK_INFORM = 4,
+	RTW_WLAN_SP_MGK_ACK = 5,
+};
+
+/* Action category code */
+enum rtw_ieee80211_category {
+	RTW_WLAN_CATEGORY_SPECTRUM_MGMT = 0,
+	RTW_WLAN_CATEGORY_QOS = 1,
+	RTW_WLAN_CATEGORY_DLS = 2,
+	RTW_WLAN_CATEGORY_BACK = 3,
+	RTW_WLAN_CATEGORY_PUBLIC = 4, //IEEE 802.11 public action frames
+	RTW_WLAN_CATEGORY_RADIO_MEASUREMENT  = 5,
+	RTW_WLAN_CATEGORY_FT = 6,
+	RTW_WLAN_CATEGORY_HT = 7,
+	RTW_WLAN_CATEGORY_SA_QUERY = 8,
+	RTW_WLAN_CATEGORY_WNM = 10,
+	RTW_WLAN_CATEGORY_UNPROTECTED_WNM = 11, /* add for CONFIG_IEEE80211W, none 11w also can use */
+	RTW_WLAN_CATEGORY_TDLS = 12,
+	RTW_WLAN_CATEGORY_MESH_ACTION = 13,
+	RTW_WLAN_CATEGORY_MULTIHOP_ACTION = 14,
+	RTW_WLAN_CATEGORY_SELF_PROTECTED = 15, /* add for CONFIG_IEEE80211W, none 11w also can use */
+	RTW_WLAN_CATEGORY_WMM = 17,
+	RTW_WLAN_CATEGORY_VHT = 21,
+	RTW_WLAN_CATEGORY_TWT = 22,
+	RTW_WLAN_CATEGORY_P2P = 0x7f,//P2P action frames
+};
+
+/* BACK action code */
+enum rtw_ieee80211_back_actioncode {
+	RTW_WLAN_ACTION_ADDBA_REQ = 0,
+	RTW_WLAN_ACTION_ADDBA_RESP = 1,
+	RTW_WLAN_ACTION_DELBA = 2,
+};
+
+enum rtw_ieee80211_spec_mgnt_actioncode {
+	RTW_WLAN_ACTION_CSA = 4,
+	RTW_WLAN_ACTION_EXTENDED_CSA = 5,
+};
+
+#endif
+
diff --git a/os/board/rtl8720e/src/component/wifi/driver/include/rtw_80211spec_ft.h b/os/board/rtl8720e/src/component/wifi/driver/include/rtw_80211spec_ft.h
new file mode 100755
index 000000000..bf32b5d74
--- /dev/null
+++ b/os/board/rtl8720e/src/component/wifi/driver/include/rtw_80211spec_ft.h
@@ -0,0 +1,97 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+#ifndef	__RTW_80211SPEC_FT_H_
+#define __RTW_80211SPEC_FT_H_
+
+enum rtw_ieee80211_ft_actioncode {
+	RTW_WLAN_ACTION_FT_RESV,
+	RTW_WLAN_ACTION_FT_REQ,
+	RTW_WLAN_ACTION_FT_RSP,
+	RTW_WLAN_ACTION_FT_CONF,
+	RTW_WLAN_ACTION_FT_ACK,
+	RTW_WLAN_ACTION_FT_MAX,
+};
+
+enum _rtw_ft_sta_status {
+	RTW_FT_UNASSOCIATED_STA = 0,
+	RTW_FT_AUTHENTICATING_STA,
+	RTW_FT_AUTHENTICATED_STA,
+	RTW_FT_ASSOCIATING_STA,
+	RTW_FT_ASSOCIATED_STA,
+	RTW_FT_REQUESTING_STA,
+	RTW_FT_REQUESTED_STA,
+};
+
+enum rtw_ft_capability {
+	RTW_FT_EN = BIT(0),
+	RTW_FT_OTD_EN = BIT(1),
+	RTW_FT_PEER_EN = BIT(2),
+	RTW_FT_PEER_OTD_EN = BIT(3),
+};
+
+#define FTIE_SUBELEM_R1KH_ID 1
+#define FTIE_SUBELEM_GTK 2
+#define FTIE_SUBELEM_R0KH_ID 3
+
+#define RTW_FT_ACTION_REQ_LMT	4
+#define RTW_FT_MAX_IE_SZ	256
+
+#define PMK_LEN_MAX 64
+#define MOBILITY_DOMAIN_ID_LEN 2
+#define FT_R0KH_ID_MAX_LEN 48
+#define FT_R1KH_ID_LEN 6
+#define WPA_PMK_NAME_LEN 16
+#define KEY_NONCE_LEN		32
+
+struct wpa_ie_data {
+	int proto;
+	int pairwise_cipher;
+	int has_pairwise;
+	int group_cipher;
+	int has_group;
+	int key_mgmt;
+	int capabilities;
+	u32 num_pmkid;
+	u8 *pmkid;
+	int mgmt_group_cipher;
+};
+
+struct ft_ftie {
+	u8 mic_control[2];
+	u8 mic[16];
+	u8 anonce[KEY_NONCE_LEN];
+	u8 snonce[KEY_NONCE_LEN];
+	/* followed by optional parameters */
+};
+
+struct ft_mdie {
+	u8 mobility_domain[MOBILITY_DOMAIN_ID_LEN];
+	u8 ft_capab;
+};
+
+
+struct rsn_ie_hdr {
+	u8 elem_id; /* WLAN_EID_RSN */
+	u8 len;
+	u8 version[2]; /* little endian */
+};
+
+#endif
+
diff --git a/os/board/rtl8720e/src/component/wifi/driver/include/rtw_he.h b/os/board/rtl8720e/src/component/wifi/driver/include/rtw_80211spec_he.h
old mode 100644
new mode 100755
similarity index 97%
rename from os/board/rtl8720e/src/component/wifi/driver/include/rtw_he.h
rename to os/board/rtl8720e/src/component/wifi/driver/include/rtw_80211spec_he.h
index 0f5273c14..ae7f4c498
--- a/os/board/rtl8720e/src/component/wifi/driver/include/rtw_he.h
+++ b/os/board/rtl8720e/src/component/wifi/driver/include/rtw_80211spec_he.h
@@ -1,6 +1,6 @@
 /******************************************************************************
  *
- * Copyright(c) 2007 - 2017 Realtek Corporation.
+ * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or modify it
  * under the terms of version 2 of the GNU General Public License as
@@ -11,9 +11,14 @@
  * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
  * more details.
  *
- *****************************************************************************/
-#ifndef _RTW_HE_H_
-#define _RTW_HE_H_
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+#ifndef	__RTW_80211SPEC_HE_H_
+#define __RTW_80211SPEC_HE_H_
 
 /* set HE capabilities element HE MAC capability information field: 6octets */
 #define SET_HE_MAC_CAP_HTC_HE_SUPPORT(_pEleStart, _val) \
@@ -684,9 +689,6 @@
 #define GET_HE_CAP_TX_MCS_80_80MHZ_8SS(_pEleStart) \
 	GET_HE_CAP_MCS_8SS(_pEleStart + 10)
 
-/* Values in HE spec */
-#define TXOP_DUR_RTS_TH_DISABLED	1023
-
 /* get HE capabilities element PPE Threshlod field: MAX 25octets */
 #define GET_HE_CAP_PPE_NSTS(_pEleStart) \
 	LE_BITS_TO_1BYTE(_pEleStart, 0, 3)
@@ -737,15 +739,6 @@
 #define GET_HE_OP_BASIC_MCS_8SS(_pEleStart) \
 	LE_BITS_TO_1BYTE((_pEleStart) + 1, 6, 2)
 
-/* get HE operation element VHT operation information field: 3octets (option)
-	* channel_width; channel center frequency segment0; channel center frequency segment1
-	* refer to rtw_vht.h
-*/
-
-/* get HE operation element max co-hosted BSSID indicator field: 1octets (option) */
-#define GET_HE_OP_MAX_CO_HOSTED_BSSID_INDCATOR(_pEleStart) \
-	LE_BITS_TO_1BYTE(_pEleStart, 0, 8)
-
 /* Get MU EDCA Parameter Set element */
 #define GET_HE_MU_EDCA_QOS_INFO(_pEleStart) \
 	LE_BITS_TO_1BYTE(_pEleStart, 0, 8)
@@ -784,6 +777,16 @@
 #define GET_HE_MU_EDCA_VO_TIMER(_pEleStart) \
 	LE_BITS_TO_1BYTE((_pEleStart) + 12, 0, 8)
 
+
+/* get HE operation element VHT operation information field: 3octets (option)
+	* channel_width; channel center frequency segment0; channel center frequency segment1
+	* refer to rtw_vht.h
+*/
+
+/* get HE operation element max co-hosted BSSID indicator field: 1octets (option) */
+#define GET_HE_OP_MAX_CO_HOSTED_BSSID_INDCATOR(_pEleStart) \
+	LE_BITS_TO_1BYTE(_pEleStart, 0, 8)
+
 /* HE variant HT Control */
 #define HE_VAR_HTC	3
 
@@ -869,12 +872,6 @@
 		+ HE_OP_BASIC_MCS_LEN + HE_OP_VHT_OPER_INFO_LEN \
 		+ HE_OP_MAX_COHOST_BSSID_LEN + HE_OP_6G_OPER_INFO_LEN)
 
-struct he_priv {
-	u8 he_option;
-	u8 pre_he_muedca_cnt;
-	u8 he_muedca_enabled;
-};
-
 struct HE_caps_element {
 	unsigned char HE_MAC_caps[HE_CAP_ELE_MAC_CAP_LEN];
 	unsigned char HE_PHY_caps[HE_CAP_ELE_PHY_CAP_LEN];
@@ -882,13 +879,5 @@ struct HE_caps_element {
 	unsigned char ppe_thres[HE_CAP_ELE_PPE_THRE_MAX_LEN];	/* option */
 };
 
-void HE_caps_handler(_adapter *padapter, PNDIS_802_11_VARIABLE_IEs pIE);
-void HE_operation_handler(_adapter *padapter, PNDIS_802_11_VARIABLE_IEs pIE, u8 update);
-void HE_mu_edca_handler(_adapter *padapter, PNDIS_802_11_VARIABLE_IEs pIE, u8 first);
-void rtw_he_nss_to_mcsmap(u8 nss, u8 *target_mcs_map, u8 *cur_mcs_map);
-u64 rtw_he_mcs_map_to_bitmap(u8 *mcs_map, u8 nss);
-u8 rtw_he_get_highest_rate(u8 *he_mcs_map);
-u32 rtw_restructure_he_ie(_adapter *padapter, u8 *in_ie, u8 *out_ie, uint in_len, uint *pout_len);
-void rtw_he_fill_htc(_adapter *padapter, u8 *phtc_buf);
+#endif
 
-#endif //_RTW_HE_H_
diff --git a/os/board/rtl8720e/src/component/wifi/driver/include/rtw_ht.h b/os/board/rtl8720e/src/component/wifi/driver/include/rtw_80211spec_ht.h
old mode 100644
new mode 100755
similarity index 83%
rename from os/board/rtl8720e/src/component/wifi/driver/include/rtw_ht.h
rename to os/board/rtl8720e/src/component/wifi/driver/include/rtw_80211spec_ht.h
index 26a094629..ca206e247
--- a/os/board/rtl8720e/src/component/wifi/driver/include/rtw_ht.h
+++ b/os/board/rtl8720e/src/component/wifi/driver/include/rtw_80211spec_ht.h
@@ -1,6 +1,6 @@
 /******************************************************************************
  *
- * Copyright(c) 2007 - 2012 Realtek Corporation. All rights reserved.
+ * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or modify it
  * under the terms of version 2 of the GNU General Public License as
@@ -17,52 +17,48 @@
  *
  *
  ******************************************************************************/
-#ifndef _RTW_HT_H_
-#define _RTW_HT_H_
-
-#include "wifi.h"
+#ifndef	__RTW_80211SPEC_HT_H_
+#define __RTW_80211SPEC_HT_H_
+
+/* 802.11n HT capabilities masks */
+#define IEEE80211_HT_CAP_SUP_WIDTH		0x0002
+#define IEEE80211_HT_CAP_GRN_FLD		0x0010
+#define IEEE80211_HT_CAP_SGI_20			0x0020
+#define IEEE80211_HT_CAP_SGI_40			0x0040
+#define IEEE80211_HT_CAP_TX_STBC			0x0080
+#define IEEE80211_HT_CAP_RX_STBC		0x0300
+#define IEEE80211_HT_CAP_DELAY_BA		0x0400
+#define IEEE80211_HT_CAP_MAX_AMSDU		0x0800
+#define IEEE80211_HT_CAP_DSSSCCK40		0x1000
+/* 802.11n HT capability AMPDU settings */
+#define IEEE80211_HT_CAP_AMPDU_FACTOR		0x03
+#define IEEE80211_HT_CAP_AMPDU_DENSITY		0x1C
+/* 802.11n HT capability MSC set */
+#define IEEE80211_SUPP_MCS_SET_UEQM		4
+#define IEEE80211_HT_CAP_MAX_STREAMS		4
+#define IEEE80211_SUPP_MCS_SET_LEN		10
+/* maximum streams the spec allows */
+#define IEEE80211_HT_CAP_MCS_TX_DEFINED		0x01
+#define IEEE80211_HT_CAP_MCS_TX_RX_DIFF		0x02
+#define IEEE80211_HT_CAP_MCS_TX_STREAMS		0x0C
+#define IEEE80211_HT_CAP_MCS_TX_UEQM		0x10
+/* 802.11n HT IE masks */
+#define IEEE80211_HT_IE_CHA_SEC_OFFSET		0x03
+#define IEEE80211_HT_IE_CHA_SEC_NONE	 	0x00
+#define IEEE80211_HT_IE_CHA_SEC_ABOVE 		0x01
+#define IEEE80211_HT_IE_CHA_SEC_BELOW 		0x03
+#define IEEE80211_HT_IE_CHA_WIDTH		0x04
+#define IEEE80211_HT_IE_HT_PROTECTION		0x0003
+#define IEEE80211_HT_IE_NON_GF_STA_PRSNT	0x0004
+#define IEEE80211_HT_IE_NON_HT_STA_PRSNT	0x0010
 
 #define HT_OP_IE_LEN 22
 
-struct ht_priv {
-	u8	ht_enable;
-	u8	ht_option;
-	u8	ampdu_enable;//for enable Tx A-MPDU
-	//u8	baddbareq_issued[16];
-	//u32	tx_amsdu_enable;//for enable Tx A-MSDU
-	//u32	tx_amdsu_maxlen; // 1: 8k, 0:4k ; default:8k, for tx
-	//u32	rx_ampdu_maxlen; //for rx reordering ctrl win_sz, updated when join_callback.
-
-	u8	bwmode;//
-	u8	ch_offset;//PRIME_CHNL_OFFSET
-	u8	sgi_20m;//short GI
-	u8	sgi_40m;
-
-	//for processing Tx A-MPDU
-	u8	agg_enable_bitmap;
-	//u8	ADDBA_retry_count;
-	u8	candidate_tid_bitmap;
-
-	struct rtw_ieee80211_ht_cap ht_cap;
-
-};
-
 #define	STBC_HT_ENABLE_RX			BIT0
 #define	STBC_HT_ENABLE_TX			BIT1
 #define	STBC_HT_TEST_TX_ENABLE		BIT2
 #define	STBC_HT_CAP_TX				BIT3
 
-typedef enum AGGRE_SIZE {
-	HT_AGG_SIZE_8K = 0,
-	HT_AGG_SIZE_16K = 1,
-	HT_AGG_SIZE_32K = 2,
-	HT_AGG_SIZE_64K = 3,
-	VHT_AGG_SIZE_128K = 4,
-	VHT_AGG_SIZE_256K = 5,
-	VHT_AGG_SIZE_512K = 6,
-	VHT_AGG_SIZE_1024K = 7,
-} AGGRE_SIZE_E, *PAGGRE_SIZE_E;
-
 /* HT Operation element */
 #define GET_HT_OP_ELE_PRI_CHL(_pEleStart)					LE_BITS_TO_1BYTE(((u8 *)(_pEleStart)), 0, 8)
 #define SET_HT_OP_ELE_PRI_CHL(_pEleStart, _val)				SET_BITS_TO_LE_1BYTE(((u8 *)(_pEleStart)), 0, 8, _val)
@@ -137,8 +133,5 @@ typedef enum AGGRE_SIZE {
 #define SET_HT_OP_ELE_PCO_ACTIVE(_pEleStart, _val)			SET_BITS_TO_LE_1BYTE(((u8 *)(_pEleStart)) + 5, 2, 1, _val)
 #define SET_HT_OP_ELE_PCO_PHASE(_pEleStart, _val)			SET_BITS_TO_LE_1BYTE(((u8 *)(_pEleStart)) + 5, 3, 1, _val)
 
-/* Extended Capabilities: n bytes */
-#define GET_EXT_CAP_MBSSID(_pEleStart)					LE_BITS_TO_1BYTE(((u8 *)(_pEleStart) + 2), 6, 1)
-#define SET_EXT_CAP_MBSSID(_pEleStart, _val)				SET_BITS_TO_LE_1BYTE(((u8 *)(_pEleStart) + 2), 6, 1, _val)
-#endif	//_RTL871X_HT_H_
+#endif
 
diff --git a/os/board/rtl8720e/src/component/wifi/driver/include/rtw_80211spec_macro.h b/os/board/rtl8720e/src/component/wifi/driver/include/rtw_80211spec_macro.h
new file mode 100755
index 000000000..f68fcc7a2
--- /dev/null
+++ b/os/board/rtl8720e/src/component/wifi/driver/include/rtw_80211spec_macro.h
@@ -0,0 +1,910 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+#ifndef	__RTW_80211SPEC_MACRO_H_
+#define __RTW_80211SPEC_MACRO_H_
+
+/* Frame control field constants */
+#define RTW_IEEE80211_FCTL_VERS		0x0002
+#define RTW_IEEE80211_FCTL_FTYPE		0x000c
+#define RTW_IEEE80211_FCTL_STYPE		0x00f0
+#define RTW_IEEE80211_FCTL_TODS		0x0100
+#define RTW_IEEE80211_FCTL_FROMDS		0x0200
+#define RTW_IEEE80211_FCTL_MOREFRAGS	0x0400
+#define RTW_IEEE80211_FCTL_RETRY		0x0800
+#define RTW_IEEE80211_FCTL_PM		0x1000
+#define RTW_IEEE80211_FCTL_MOREDATA	0x2000
+#define RTW_IEEE80211_FCTL_WEP		0x4000
+#define RTW_IEEE80211_FCTL_ORDER		0x8000
+
+#define RTW_IEEE80211_FTYPE_MGMT		0x0000
+#define RTW_IEEE80211_FTYPE_CTL		0x0004
+#define RTW_IEEE80211_FTYPE_DATA		0x0008
+
+/* management */
+#define RTW_IEEE80211_STYPE_ASSOC_REQ	0x0000
+#define RTW_IEEE80211_STYPE_ASSOC_RESP 	0x0010
+#define RTW_IEEE80211_STYPE_REASSOC_REQ	0x0020
+#define RTW_IEEE80211_STYPE_REASSOC_RESP	0x0030
+#define RTW_IEEE80211_STYPE_PROBE_REQ	0x0040
+#define RTW_IEEE80211_STYPE_PROBE_RESP	0x0050
+#define RTW_IEEE80211_STYPE_BEACON		0x0080
+#define RTW_IEEE80211_STYPE_ATIM		0x0090
+#define RTW_IEEE80211_STYPE_DISASSOC	0x00A0
+#define RTW_IEEE80211_STYPE_AUTH		0x00B0
+#define RTW_IEEE80211_STYPE_DEAUTH		0x00C0
+#define RTW_IEEE80211_STYPE_ACTION		0x00D0
+
+/* control */
+#define RTW_IEEE80211_STYPE_PSPOLL		0x00A0
+#define RTW_IEEE80211_STYPE_RTS		0x00B0
+#define RTW_IEEE80211_STYPE_CTS		0x00C0
+#define RTW_IEEE80211_STYPE_ACK		0x00D0
+#define RTW_IEEE80211_STYPE_CFEND		0x00E0
+#define RTW_IEEE80211_STYPE_CFENDACK	0x00F0
+
+/* data */
+#define RTW_IEEE80211_STYPE_DATA		0x0000
+#define RTW_IEEE80211_STYPE_DATA_CFACK	0x0010
+#define RTW_IEEE80211_STYPE_DATA_CFPOLL	0x0020
+#define RTW_IEEE80211_STYPE_DATA_CFACKPOLL	0x0030
+#define RTW_IEEE80211_STYPE_NULLFUNC	0x0040
+#define RTW_IEEE80211_STYPE_CFACK		0x0050
+#define RTW_IEEE80211_STYPE_CFPOLL		0x0060
+#define RTW_IEEE80211_STYPE_CFACKPOLL	0x0070
+#define RTW_IEEE80211_QOS_DATAGRP		0x0080
+#define RTW_IEEE80211_QoS_DATAGRP		RTW_IEEE80211_QOS_DATAGRP
+/* Mesh Control 802.11s */
+#define RTW_IEEE80211_QOS_CTL_MESH_CONTROL_PRESENT  BIT(8)
+
+/* Authentication algorithms */
+#define WLAN_AUTH_OPEN 0
+#define WLAN_AUTH_SHARED_KEY 1
+#define WLAN_AUTH_CHALLENGE_LEN 128
+
+/* 802.11b */
+#define WLAN_STATUS_ASSOC_DENIED_NOSHORT 19
+#define WLAN_STATUS_ASSOC_DENIED_NOPBCC 20
+#define WLAN_STATUS_ASSOC_DENIED_NOAGILITY 21
+
+/* Reason codes */
+#define WLAN_REASON_UNSPECIFIED 1
+#define WLAN_REASON_PREV_AUTH_NOT_VALID 2
+#define WLAN_REASON_DEAUTH_LEAVING 3
+#define WLAN_REASON_DISASSOC_DUE_TO_INACTIVITY 4
+#define WLAN_REASON_DISASSOC_AP_BUSY 5
+#define WLAN_REASON_CLASS2_FRAME_FROM_NONAUTH_STA 6
+#define WLAN_REASON_CLASS3_FRAME_FROM_NONASSOC_STA 7
+#define WLAN_REASON_DISASSOC_STA_HAS_LEFT 8
+#define WLAN_REASON_STA_REQ_ASSOC_WITHOUT_AUTH 9
+#define WLAN_REASON_MIC_FAILURE 14
+#define WLAN_REASON_4WAY_HANDSHAKE_TIMEOUT 15
+#define WLAN_REASON_ACTIVE_ROAM 65533
+#define WLAN_REASON_JOIN_WRONG_CHANNEL       65534
+#define WLAN_REASON_EXPIRATION_CHK 65535
+
+/* 802.11s */
+#define WLAN_REASON_MESH_PEER_CANCELED 52
+#define WLAN_REASON_MESH_MAX_PEERS 53
+#define WLAN_REASON_MESH_CONFIG 54
+#define WLAN_REASON_MESH_CLOSE 55
+#define WLAN_REASON_MESH_MAX_RETRIES 56
+#define WLAN_REASON_MESH_CONFIRM_TIMEOUT 57
+#define WLAN_REASON_MESH_INVALID_GTK 58
+#define WLAN_REASON_MESH_INCONSISTENT_PARAM 59
+#define WLAN_REASON_MESH_INVALID_SECURITY 60
+#define WLAN_REASON_MESH_PATH_ERROR 61
+#define WLAN_REASON_MESH_PATH_NOFORWARD  62
+#define WLAN_REASON_MESH_PATH_DEST_UNREACHABLE 63
+#define WLAN_REASON_MAC_EXISTS_IN_MBSS 64
+#define WLAN_REASON_MESH_CHAN_REGULATORY 65
+#define WLAN_REASON_MESH_CHAN 66
+
+#define IEEE80211_CCK_RATE_1MB		        0x02
+#define IEEE80211_CCK_RATE_2MB		        0x04
+#define IEEE80211_CCK_RATE_5MB		        0x0B
+#define IEEE80211_CCK_RATE_11MB		        0x16
+#define IEEE80211_OFDM_RATE_LEN 		8
+#define IEEE80211_OFDM_RATE_6MB		        0x0C
+#define IEEE80211_OFDM_RATE_9MB		        0x12
+#define IEEE80211_OFDM_RATE_12MB		0x18
+#define IEEE80211_OFDM_RATE_18MB		0x24
+#define IEEE80211_OFDM_RATE_24MB		0x30
+#define IEEE80211_OFDM_RATE_36MB		0x48
+#define IEEE80211_OFDM_RATE_48MB		0x60
+#define IEEE80211_OFDM_RATE_54MB		0x6C
+#define IEEE80211_BASIC_RATE_MASK		0x80
+
+#define IEEE80211_CCK_RATE_1MB_MASK		(1<<0)
+#define IEEE80211_CCK_RATE_2MB_MASK		(1<<1)
+#define IEEE80211_CCK_RATE_5MB_MASK		(1<<2)
+#define IEEE80211_CCK_RATE_11MB_MASK		(1<<3)
+#define IEEE80211_OFDM_RATE_6MB_MASK		(1<<4)
+#define IEEE80211_OFDM_RATE_9MB_MASK		(1<<5)
+#define IEEE80211_OFDM_RATE_12MB_MASK		(1<<6)
+#define IEEE80211_OFDM_RATE_18MB_MASK		(1<<7)
+#define IEEE80211_OFDM_RATE_24MB_MASK		(1<<8)
+#define IEEE80211_OFDM_RATE_36MB_MASK		(1<<9)
+#define IEEE80211_OFDM_RATE_48MB_MASK		(1<<10)
+#define IEEE80211_OFDM_RATE_54MB_MASK		(1<<11)
+
+#define IEEE80211_CCK_RATE_LEN  		4
+#define IEEE80211_NUM_OFDM_RATESLEN	8
+
+#define IEEE80211_CCK_RATES_MASK	        0x0000000F
+#define IEEE80211_CCK_BASIC_RATES_MASK	(IEEE80211_CCK_RATE_1MB_MASK | \
+	IEEE80211_CCK_RATE_2MB_MASK)
+#define IEEE80211_CCK_DEFAULT_RATES_MASK	(IEEE80211_CCK_BASIC_RATES_MASK | \
+        IEEE80211_CCK_RATE_5MB_MASK | \
+        IEEE80211_CCK_RATE_11MB_MASK)
+
+#define IEEE80211_OFDM_RATES_MASK		0x00000FF0
+#define IEEE80211_OFDM_BASIC_RATES_MASK	(IEEE80211_OFDM_RATE_6MB_MASK | \
+	IEEE80211_OFDM_RATE_12MB_MASK | \
+	IEEE80211_OFDM_RATE_24MB_MASK)
+#define IEEE80211_OFDM_DEFAULT_RATES_MASK	(IEEE80211_OFDM_BASIC_RATES_MASK | \
+	IEEE80211_OFDM_RATE_9MB_MASK  | \
+	IEEE80211_OFDM_RATE_18MB_MASK | \
+	IEEE80211_OFDM_RATE_36MB_MASK | \
+	IEEE80211_OFDM_RATE_48MB_MASK | \
+	IEEE80211_OFDM_RATE_54MB_MASK)
+#define IEEE80211_DEFAULT_RATES_MASK (IEEE80211_OFDM_DEFAULT_RATES_MASK | \
+                                IEEE80211_CCK_DEFAULT_RATES_MASK)
+
+#define IEEE80211_NUM_OFDM_RATES	    8
+#define IEEE80211_NUM_CCK_RATES	            4
+#define IEEE80211_OFDM_SHIFT_MASK_A         4
+
+/* IEEE 802.11 requires that STA supports concurrent reception of at least
+ * three fragmented frames. This define can be increased to support more
+ * concurrent frames, but it should be noted that each entry can consume about
+ * 2 kB of RAM and increasing cache size will slow down frame reassembly. */
+#define IEEE80211_FRAG_CACHE_LEN 4
+
+/* MAX_RATES_LENGTH needs to be 12.  The spec says 8, and many APs
+ * only use 8, and then use extended rates for the remaining supported
+ * rates.  Other APs, however, stick all of their supported rates on the
+ * main rates information element... */
+#define MAX_RATES_LENGTH                  ((u8)12)
+#define MAX_RATES_EX_LENGTH               ((u8)16)
+#define MAX_NETWORK_COUNT                  128
+#define MAX_CHANNEL_NUMBER                 161
+
+#define CRC_LENGTH		4U
+#define P80211_OUI_LEN 3
+#define LIB1X_EAPOL_HDRLEN	4
+
+#define WEP_KEYS 4
+#define WEP_KEY_LEN 13
+
+#define WPA_SELECTOR_LEN 4
+#define RSN_HEADER_LEN 4
+#define RSN_SELECTOR_LEN 4
+#define RSNXE_MIN_LEN 3
+
+#define MAXTID	16
+#define WIRELESS_EXT		22
+
+/* Information Element IDs */
+#define WLAN_EID_SSID 0
+#define WLAN_EID_SUPP_RATES 1
+#define WLAN_EID_FH_PARAMS 2
+#define WLAN_EID_DS_PARAMS 3
+#define WLAN_EID_CF_PARAMS 4
+#define WLAN_EID_TIM 5
+#define WLAN_EID_IBSS_PARAMS 6
+#define WLAN_EID_CHALLENGE 16
+/* EIDs defined by IEEE 802.11h - START */
+#define WLAN_EID_PWR_CONSTRAINT 32
+#define WLAN_EID_PWR_CAPABILITY 33
+#define WLAN_EID_TPC_REQUEST 34
+#define WLAN_EID_TPC_REPORT 35
+#define WLAN_EID_SUPPORTED_CHANNELS 36
+#define WLAN_EID_CHANNEL_SWITCH 37
+#define WLAN_EID_MEASURE_REQUEST 38
+#define WLAN_EID_MEASURE_REPORT 39
+#define WLAN_EID_QUITE 40
+#define WLAN_EID_IBSS_DFS 41
+/* EIDs defined by IEEE 802.11h - END */
+#define WLAN_EID_ERP_INFO 42
+#define WLAN_EID_HT_CAP 45
+#define WLAN_EID_RSN 48
+#define WLAN_EID_EXT_SUPP_RATES 50
+#define WLAN_EID_MOBILITY_DOMAIN 54
+#define WLAN_EID_FAST_BSS_TRANSITION 55
+#define WLAN_EID_TIMEOUT_INTERVAL 56
+#define WLAN_EID_RIC_DATA 57
+#define WLAN_EID_HT_OPERATION 61
+#define WLAN_EID_SECONDARY_CHANNEL_OFFSET 62
+#define WLAN_EID_RRM_EN_CAP			70
+#define WLAN_EID_MULTIPLE_BSSID 71
+#define WLAN_EID_20_40_BSS_COEXISTENCE 72
+#define WLAN_EID_20_40_BSS_INTOLERANT 73
+#define WLAN_EID_OVERLAPPING_BSS_SCAN_PARAMS 74
+#define WLAN_EID_MMIE 76
+#define WLAN_EID_NONTRANSMITTED_BSSID_CAPABILITY 83
+#define WLAN_EID_MULTIPLE_BSSID_INDEX 85
+#define WLAN_EID_VHT_CAPABILITY 191
+#define WLAN_EID_VHT_OPERATION 192
+#define WLAN_EID_VHT_OPERATING_MODE_NOTIFICATION 199
+#define WLAN_EID_MESH_CONFIG 113
+#define WLAN_EID_MESH_ID 114
+#define WLAN_EID_MESH_PEERING_MANAGEMENT 117
+#define WLAN_EID_GANN 125
+#define WLAN_EID_RANN 126
+#define WLAN_EID_EXT_CAP 127
+#define WLAN_EID_PREQ 130
+#define WLAN_EID_PREP 131
+#define WLAN_EID_PERR 132
+#define WLAN_EID_MIC 140
+#define WLAN_EID_TWT 216
+#define WLAN_EID_VENDOR_SPECIFIC 221
+#define WLAN_EID_GENERIC (WLAN_EID_VENDOR_SPECIFIC)
+#define WLAN_EID_RSNXE					244
+
+#define WLAN_EID_WPA	0xdd
+#define WLAN_EID_WPA2	0x30
+
+/* EID Extension */
+#define WLAN_EID_EXTENSION 255
+#define WLAN_EID_EXT_OWE_DH_PARAM 32	//WPA3
+#define WLAN_EID_EXT_HE_CAPABILITY 35
+#define WLAN_EID_EXT_HE_OPERATION 36
+#define WLAN_EID_EXT_HE_MU_EDCA 38
+#define WLAN_EID_EXT_SPATIAL_REUSE_PARA 39
+#define WLAN_EID_EXT_BSS_COLOR_CHANGE 42
+#define WLAN_EID_EXT_MULTIPLE_BSSID_CONFIGURATION 55	//MBSSID
+#define WLAN_EID_EXT_NON_INGERITANCE_ELEMENT 56		//MBSSID
+
+#define WLAN_EID_EXT_CAP_MAX_LEN 10
+
+#define MAX_WPA_IE_LEN (256)
+#define MAX_WPS_IE_LEN (512)
+#define MAX_P2P_IE_LEN (256)
+#define MAX_WFD_IE_LEN (128)
+
+#define _WMM_IE_Length_				7  // for WMM STA
+#define _WMM_Para_Element_Length_		24
+
+#define _ASOCREQ_IE_OFFSET_		4	// excluding wlan_hdr
+#define	_ASOCRSP_IE_OFFSET_		6
+#define _REASOCREQ_IE_OFFSET_	10
+#define _REASOCRSP_IE_OFFSET_	6
+#define _PROBEREQ_IE_OFFSET_	0
+#define	_PROBERSP_IE_OFFSET_	12
+#define _AUTH_IE_OFFSET_		6
+#define _DEAUTH_IE_OFFSET_		0
+#define _BEACON_IE_OFFSET_		12
+#define _PUBLIC_ACTION_IE_OFFSET_	8
+
+#define _FIXED_IE_LENGTH_			_BEACON_IE_OFFSET_
+
+#define WLAN_IEEE_OUI_LEN	3
+#define WLAN_ADDR_LEN		6
+#define WLAN_CRC_LEN		4
+#define WLAN_BSSID_LEN		6
+#define WLAN_BSS_TS_LEN		8
+#define WLAN_HDR_A3_LEN		24
+#define WLAN_HDR_A4_LEN		30
+#define WLAN_HDR_A3_QOS_LEN	26
+#define WLAN_HDR_A4_QOS_LEN	32
+#define WLAN_HDR_A3_QOS_HTC_LEN	30
+#define WLAN_DATA_MAXLEN	2312
+#define WLAN_RATES_MAXLEN        12
+#define WLAN_RATES_EX_MAXLEN     16
+
+/* Maximum size of the ESSID and NICKN strings */
+#define RTW_ESSID_MAX_SIZE	32
+#define RTW_PASSPHRASE_MAX_SIZE 64
+
+#define BIP_MAX_KEYID 5
+#define BIP_AAD_SIZE  20
+
+/*wlan over head : [WLAN_HDR_A4_QOS_HTC][IV][SNAP][][MIC][ICV]*/
+#define WLAN_HDR_A4_QOS_HTC_LEN	36
+#define WLAN_MAX_IV_LEN	8
+#define WLAN_SNAP_HEADER	8
+#define WLAN_MAX_MIC_LEN	8
+#define WLAN_MAX_ICV_LEN	8
+#define WLAN_MAX_PROTOCOL_OVERHEAD (WLAN_HDR_A4_QOS_HTC_LEN+WLAN_MAX_IV_LEN+\
+							WLAN_SNAP_HEADER+WLAN_MAX_MIC_LEN+WLAN_MAX_ICV_LEN)/*=68*/
+
+#define _TO_DS_		BIT(8)
+#define _FROM_DS_	BIT(9)
+#define _MORE_FRAG_	BIT(10)
+#define _RETRY_		BIT(11)
+#define _PWRMGT_	BIT(12)
+#define _MORE_DATA_	BIT(13)
+#define _PRIVACY_	BIT(14)
+#define _ORDER_			BIT(15)
+
+#define SetToDs(pbuf)	\
+	do	{	\
+		*(unsigned short *)(void*)(pbuf) |= cpu_to_le16(_TO_DS_); \
+	} while(0)
+
+#define GetToDs(pbuf)	(((*(unsigned short *)(void*)(pbuf)) & le16_to_cpu(_TO_DS_)) != 0)
+
+#define ClearToDs(pbuf)	\
+	do	{	\
+		*(unsigned short *)(void*)(pbuf) &= (~cpu_to_le16(_TO_DS_)); \
+	} while(0)
+
+#define SetFrDs(pbuf)	\
+	do	{	\
+		*(unsigned short *)(void*)(pbuf) |= cpu_to_le16(_FROM_DS_); \
+	} while(0)
+
+#define GetFrDs(pbuf)	(((*(unsigned short *)(void*)(pbuf)) & le16_to_cpu(_FROM_DS_)) != 0)
+
+#define ClearFrDs(pbuf)	\
+	do	{	\
+		*(unsigned short *)(void*)(pbuf) &= (~cpu_to_le16(_FROM_DS_)); \
+	} while(0)
+
+#define get_tofr_ds(pframe)	((GetToDs(pframe) << 1) | GetFrDs(pframe))
+
+
+#define SetMFrag(pbuf)	\
+	do	{	\
+		*(unsigned short *)(void*)(pbuf) |= cpu_to_le16(_MORE_FRAG_); \
+	} while(0)
+
+#define GetMFrag(pbuf)	(((*(unsigned short *)(void*)(pbuf)) & le16_to_cpu(_MORE_FRAG_)) != 0)
+
+#define ClearMFrag(pbuf)	\
+	do	{	\
+		*(unsigned short *)(void*)(pbuf) &= (~cpu_to_le16(_MORE_FRAG_)); \
+	} while(0)
+
+#define SetRetry(pbuf)	\
+	do	{	\
+		*(unsigned short *)(void*)(pbuf) |= cpu_to_le16(_RETRY_); \
+	} while(0)
+
+#define GetRetry(pbuf)	(((*(unsigned short *)(void*)(pbuf)) & le16_to_cpu(_RETRY_)) != 0)
+
+#define ClearRetry(pbuf)	\
+	do	{	\
+		*(unsigned short *)(void*)(pbuf) &= (~cpu_to_le16(_RETRY_)); \
+	} while(0)
+
+#define SetPwrMgt(pbuf)	\
+	do	{	\
+		*(unsigned short *)(void*)(pbuf) |= cpu_to_le16(_PWRMGT_); \
+	} while(0)
+
+#define GetPwrMgt(pbuf)	(((*(unsigned short *)(void*)(pbuf)) & le16_to_cpu(_PWRMGT_)) != 0)
+
+#define ClearPwrMgt(pbuf)	\
+	do	{	\
+		*(unsigned short *)(void*)(pbuf) &= (~cpu_to_le16(_PWRMGT_)); \
+	} while(0)
+
+#define SetMData(pbuf)	\
+	do	{	\
+		*(unsigned short *)(void*)(pbuf) |= cpu_to_le16(_MORE_DATA_); \
+	} while(0)
+
+#define GetMData(pbuf)	(((*(unsigned short *)(void*)(pbuf)) & le16_to_cpu(_MORE_DATA_)) != 0)
+
+#define ClearMData(pbuf)	\
+	do	{	\
+		*(unsigned short *)(void*)(pbuf) &= (~cpu_to_le16(_MORE_DATA_)); \
+	} while(0)
+
+#define SetPrivacy(pbuf)	\
+	do	{	\
+		*(unsigned short *)(void*)(pbuf) |= cpu_to_le16(_PRIVACY_); \
+	} while(0)
+
+#define GetPrivacy(pbuf)	(((*(unsigned short *)(void*)(pbuf)) & le16_to_cpu(_PRIVACY_)) != 0)
+
+#define ClearPrivacy(pbuf)	\
+	do	{	\
+		*(unsigned short *)(void*)(pbuf) &= (~cpu_to_le16(_PRIVACY_)); \
+	} while(0)
+
+#define SetOrder(pbuf)	\
+	do	{	\
+		*(unsigned short *)(void*)(pbuf) |= cpu_to_le16(_ORDER_); \
+	} while (0)
+
+#define ClearOrder(pbuf)	\
+	do	{	\
+		*(unsigned short *)(void*)(pbuf) &= (~cpu_to_le16(_ORDER_)); \
+	} while(0)
+
+#define GetOrder(pbuf)	(((*(unsigned short *)(void*)(pbuf)) & le16_to_cpu(_ORDER_)) != 0)
+
+#define GetFrameType(pbuf)	(le16_to_cpu(*(unsigned short *)(void*)(pbuf)) & (BIT(3) | BIT(2)))
+
+#define get_frame_sub_type(pbuf)	(cpu_to_le16(*(unsigned short *)(void*)(pbuf)) & (BIT(7) | BIT(6) | BIT(5) | BIT(4) | BIT(3) | BIT(2)))
+
+
+#define set_frame_sub_type(pbuf, type) \
+	do {    \
+		*(unsigned short *)(void*)(pbuf) &= cpu_to_le16(~(BIT(7) | BIT(6) | BIT(5) | BIT(4) | BIT(3) | BIT(2))); \
+		*(unsigned short *)(void*)(pbuf) |= cpu_to_le16(type); \
+	} while (0)
+
+#define SetFrameType(pbuf,type)	\
+	do { 	\
+		*(unsigned short *)(void*)(pbuf) &= cpu_to_le16(~(BIT(3) | BIT(2))); \
+		*(unsigned short *)(void*)(pbuf) |= cpu_to_le16(type); \
+	} while(0)
+
+#define GetFrameSubType(pbuf)	(cpu_to_le16(*(unsigned short *)(void*)(pbuf)) & (BIT(7) | BIT(6) | BIT(5) | BIT(4) | BIT(3) | BIT(2)))
+
+#define SetFrameSubType(pbuf,type) \
+	do {    \
+		*(unsigned short *)(void*)(pbuf) &= cpu_to_le16(~(BIT(7) | BIT(6) | BIT(5) | BIT(4) | BIT(3) | BIT(2))); \
+		*(unsigned short *)(void*)(pbuf) |= cpu_to_le16(type); \
+	} while(0)
+
+#define GetSequence(pbuf)	(cpu_to_le16(*(unsigned short *)(void*)((SIZE_PTR)(pbuf) + 22)) >> 4)
+
+#define GetFragNum(pbuf)	(cpu_to_le16(*(unsigned short *)(void*)((SIZE_PTR)(pbuf) + 22)) & 0x0f)
+
+#define GetTupleCache(pbuf)	(cpu_to_le16(*(unsigned short *)(void*)((SIZE_PTR)(pbuf) + 22)))
+
+#define SetFragNum(pbuf, num) \
+	do {    \
+		*(unsigned short *)(void*)((SIZE_PTR)(pbuf) + 22) = \
+			((*(unsigned short *)(void*)((SIZE_PTR)(pbuf) + 22)) & le16_to_cpu(~(0x000f))) | \
+			cpu_to_le16(0x0f & (num));     \
+	} while(0)
+
+#define SetSeqNum(pbuf, num) \
+	do {    \
+		*(unsigned short *)(void*)((SIZE_PTR)(pbuf) + 22) = \
+			((*(unsigned short *)(void*)((SIZE_PTR)(pbuf) + 22)) & le16_to_cpu((unsigned short)~0xfff0)) | \
+			le16_to_cpu((unsigned short)(0xfff0 & (num << 4))); \
+	} while(0)
+#define GetFrameControl(pbuf)(cpu_to_le16(*(unsigned short*)(void*)((SIZE_PTR)(pbuf))))
+#define SetFrameControl(pbuf, val)		\
+   do {    \
+	   *(unsigned short *)(void*)((SIZE_PTR)(pbuf)) = cpu_to_le16(0xffff & (val)); \
+   } while(0)
+
+#define GetDuration(pbuf) (cpu_to_le16(*(unsigned short*)(void*)((SIZE_PTR)(pbuf) + 2)))
+#define SetDuration(pbuf, dur) \
+	do {    \
+		*(unsigned short *)(void*)((SIZE_PTR)(pbuf) + 2) = cpu_to_le16(0xffff & (dur)); \
+	} while(0)
+
+
+#define SetPriority(pbuf, tid)	\
+	do	{	\
+		*(unsigned short *)(void*)(pbuf) |= cpu_to_le16(tid & 0xf); \
+	} while(0)
+
+#define GetPriority(pbuf)	((le16_to_cpu(*(unsigned short *)(void*)(pbuf))) & 0xf)
+
+#define SetEOSP(pbuf, eosp)	\
+	do	{	\
+		*(unsigned short *)(void*)(pbuf) |= cpu_to_le16( (eosp & 1) << 4); \
+	} while(0)
+
+#define SetAckpolicy(pbuf, ack)	\
+	do	{	\
+		*(unsigned short *)(void*)(pbuf) |= cpu_to_le16( (ack & 3) << 5); \
+	} while(0)
+
+#define GetAckpolicy(pbuf) (((le16_to_cpu(*(unsigned short *)(void*)pbuf)) >> 5) & 0x3)
+
+#define GetAMsdu(pbuf) (((le16_to_cpu(*(unsigned short *)(void*)pbuf)) >> 7) & 0x1)
+
+#define SetAMsdu(pbuf, amsdu)	\
+	do	{	\
+		*(unsigned short *)(void*)(pbuf) |= cpu_to_le16( (amsdu & 1) << 7); \
+	} while(0)
+
+#define GetAid(pbuf)	(cpu_to_le16(*(unsigned short *)(void*)((SIZE_PTR)(pbuf) + 2)) & 0x3fff)
+
+#define GetTid(pbuf)	(cpu_to_le16(*(unsigned short *)(void*)((SIZE_PTR)(pbuf) + (((GetToDs(pbuf)<<1)|GetFrDs(pbuf))==3?30:24))) & 0x000f)
+
+#define GetAddr1Ptr(pbuf)	((unsigned char *)((SIZE_PTR)(pbuf) + 4))
+
+#define GetAddr2Ptr(pbuf)	((unsigned char *)((SIZE_PTR)(pbuf) + 10))
+
+#define GetAddr3Ptr(pbuf)	((unsigned char *)((SIZE_PTR)(pbuf) + 16))
+
+#define GetAddr4Ptr(pbuf)	((unsigned char *)((SIZE_PTR)(pbuf) + 24))
+
+//WIFI_WMM
+#define GetQosControl(pbuf) (unsigned char *)((SIZE_PTR)(pbuf) + (((GetToDs(pbuf)<<1)|GetFrDs(pbuf))==3?30:24))
+
+#define MacAddr_isBcst(addr) \
+( \
+	( (addr[0] == 0xff) && (addr[1] == 0xff) && \
+		(addr[2] == 0xff) && (addr[3] == 0xff) && \
+		(addr[4] == 0xff) && (addr[5] == 0xff) )  ? _TRUE : _FALSE \
+)
+
+#define RTW_ERP_INFO_NON_ERP_PRESENT BIT(0)
+#define RTW_ERP_INFO_USE_PROTECTION BIT(1)
+#define RTW_ERP_INFO_BARKER_PREAMBLE_MODE BIT(2)
+
+/* block-ack parameters */
+#define IEEE80211_ADDBA_PARAM_POLICY_MASK 0x0002
+#define IEEE80211_ADDBA_PARAM_TID_MASK 0x003C
+#define IEEE80211_ADDBA_PARAM_BUF_SIZE_MASK 0xFFC0
+#define IEEE80211_DELBA_PARAM_TID_MASK 0xF000
+#define IEEE80211_DELBA_PARAM_INITIATOR_MASK 0x0800
+
+#define WLAN_CAPABILITY_BSS BIT(0)
+#define WLAN_CAPABILITY_IBSS BIT(1)
+#define WLAN_CAPABILITY_CF_POLLABLE BIT(2)
+#define WLAN_CAPABILITY_CF_POLL_REQUEST BIT(3)
+#define WLAN_CAPABILITY_PRIVACY BIT(4)
+#define WLAN_CAPABILITY_SHORT_PREAMBLE BIT(5)
+#define WLAN_CAPABILITY_PBCC BIT(6)
+#define WLAN_CAPABILITY_CHANNEL_AGILITY BIT(7)
+#define WLAN_CAPABILITY_SHORT_SLOT BIT(10)
+
+/* Status codes (IEEE 802.11-2007, 7.3.1.9, Table 7-23) */
+#define WLAN_STATUS_SUCCESS 0
+#define WLAN_STATUS_UNSPECIFIED_FAILURE 1
+#define WLAN_STATUS_CAPS_UNSUPPORTED 10
+#define WLAN_STATUS_REASSOC_NO_ASSOC 11
+#define WLAN_STATUS_ASSOC_DENIED_UNSPEC 12
+#define WLAN_STATUS_NOT_SUPPORTED_AUTH_ALG 13
+#define WLAN_STATUS_UNKNOWN_AUTH_TRANSACTION 14
+#define WLAN_STATUS_CHALLENGE_FAIL 15
+#define WLAN_STATUS_AUTH_TIMEOUT 16
+#define WLAN_STATUS_AP_UNABLE_TO_HANDLE_NEW_STA 17
+#define WLAN_STATUS_ASSOC_DENIED_RATES 18
+/* WPA3-SAE*/
+#define WLAN_STATUS_ANTI_CLOGGING_TOKEN_REQ 		76
+#define WLAN_STATUS_UNSUPPORTED_FCC_GROUP   		77
+#define WLAN_STATUS_UNKNOWN_PASSWORD_IDENTIFIER		123
+//entended
+/* IEEE 802.11b */
+#define WLAN_STATUS_ASSOC_DENIED_NOSHORT 19
+#define WLAN_STATUS_ASSOC_DENIED_NOPBCC 20
+#define WLAN_STATUS_ASSOC_DENIED_NOAGILITY 21
+/* IEEE 802.11h */
+#define WLAN_STATUS_SPEC_MGMT_REQUIRED 22
+#define WLAN_STATUS_PWR_CAPABILITY_NOT_VALID 23
+#define WLAN_STATUS_SUPPORTED_CHANNEL_NOT_VALID 24
+/* IEEE 802.11g */
+#define WLAN_STATUS_ASSOC_DENIED_NO_SHORT_SLOT_TIME 25
+#define WLAN_STATUS_ASSOC_DENIED_NO_ER_PBCC 26
+#define WLAN_STATUS_ASSOC_DENIED_NO_DSSS_OFDM 27
+/* IEEE 802.11w */
+#define WLAN_STATUS_ASSOC_REJECTED_TEMPORARILY 30
+#define WLAN_STATUS_ROBUST_MGMT_FRAME_POLICY_VIOLATION 31
+/* IEEE 802.11i */
+#define WLAN_STATUS_INVALID_IE 40
+#define WLAN_STATUS_GROUP_CIPHER_NOT_VALID 41
+#define WLAN_STATUS_PAIRWISE_CIPHER_NOT_VALID 42
+#define WLAN_STATUS_AKMP_NOT_VALID 43
+#define WLAN_STATUS_UNSUPPORTED_RSN_IE_VERSION 44
+#define WLAN_STATUS_INVALID_RSN_IE_CAPAB 45
+#define WLAN_STATUS_CIPHER_REJECTED_PER_POLICY 46
+#define WLAN_STATUS_TS_NOT_CREATED 47
+#define WLAN_STATUS_DIRECT_LINK_NOT_ALLOWED 48
+#define WLAN_STATUS_DEST_STA_NOT_PRESENT 49
+#define WLAN_STATUS_DEST_STA_NOT_QOS_STA 50
+#define WLAN_STATUS_ASSOC_DENIED_LISTEN_INT_TOO_LARGE 51
+/* IEEE 802.11r */
+#define WLAN_STATUS_INVALID_FT_ACTION_FRAME_COUNT 52
+#define WLAN_STATUS_INVALID_PMKID 53
+#define WLAN_STATUS_INVALID_MDIE 54
+#define WLAN_STATUS_INVALID_FTIE 55
+
+#define WLAN_STATUS_SAE_HASH_TO_ELEMENT 126
+
+//	===============WPS Section===============
+//	For WPSv1.0
+#define WPSOUI							0x0050f204
+//	WPS attribute ID
+#define WPS_ATTR_VER1					0x104A
+#define WPS_ATTR_SIMPLE_CONF_STATE	0x1044
+#define WPS_ATTR_RESP_TYPE			0x103B
+#define WPS_ATTR_UUID_E				0x1047
+#define WPS_ATTR_MANUFACTURER		0x1021
+#define WPS_ATTR_MODEL_NAME			0x1023
+#define WPS_ATTR_MODEL_NUMBER		0x1024
+#define WPS_ATTR_SERIAL_NUMBER		0x1042
+#define WPS_ATTR_PRIMARY_DEV_TYPE	0x1054
+#define WPS_ATTR_SEC_DEV_TYPE_LIST	0x1055
+#define WPS_ATTR_DEVICE_NAME			0x1011
+#define WPS_ATTR_CONF_METHOD			0x1008
+#define WPS_ATTR_RF_BANDS				0x103C
+#define WPS_ATTR_DEVICE_PWID			0x1012
+#define WPS_ATTR_REQUEST_TYPE			0x103A
+#define WPS_ATTR_ASSOCIATION_STATE	0x1002
+#define WPS_ATTR_CONFIG_ERROR			0x1009
+#define WPS_ATTR_VENDOR_EXT			0x1049
+#define WPS_ATTR_SELECTED_REGISTRAR	0x1041
+
+//	Value of WPS attribute "WPS_ATTR_DEVICE_NAME
+#define WPS_MAX_DEVICE_NAME_LEN		32
+
+//	Value of WPS Request Type Attribute
+#define WPS_REQ_TYPE_ENROLLEE_INFO_ONLY			0x00
+#define WPS_REQ_TYPE_ENROLLEE_OPEN_8021X		0x01
+#define WPS_REQ_TYPE_REGISTRAR					0x02
+#define WPS_REQ_TYPE_WLAN_MANAGER_REGISTRAR	0x03
+
+//	Value of WPS Response Type Attribute
+#define WPS_RESPONSE_TYPE_INFO_ONLY	0x00
+#define WPS_RESPONSE_TYPE_8021X		0x01
+#define WPS_RESPONSE_TYPE_REGISTRAR	0x02
+#define WPS_RESPONSE_TYPE_AP			0x03
+
+//	Value of WPS WiFi Simple Configuration State Attribute
+#define WPS_WSC_STATE_NOT_CONFIG	0x01
+#define WPS_WSC_STATE_CONFIG			0x02
+
+//	Value of WPS Version Attribute
+#define WPS_VERSION_1					0x10
+
+//	Value of WPS Configuration Method Attribute
+#define WPS_CONFIG_METHOD_FLASH		0x0001
+#define WPS_CONFIG_METHOD_ETHERNET	0x0002
+#define WPS_CONFIG_METHOD_LABEL		0x0004
+#define WPS_CONFIG_METHOD_DISPLAY	0x0008
+#define WPS_CONFIG_METHOD_E_NFC		0x0010
+#define WPS_CONFIG_METHOD_I_NFC		0x0020
+#define WPS_CONFIG_METHOD_NFC		0x0040
+#define WPS_CONFIG_METHOD_PBC		0x0080
+#define WPS_CONFIG_METHOD_KEYPAD	0x0100
+#define WPS_CONFIG_METHOD_VPBC		0x0280
+#define WPS_CONFIG_METHOD_PPBC		0x0480
+#define WPS_CONFIG_METHOD_VDISPLAY	0x2008
+#define WPS_CONFIG_METHOD_PDISPLAY	0x4008
+
+//	Value of Category ID of WPS Primary Device Type Attribute
+#define WPS_PDT_CID_DISPLAYS			0x0007
+#define WPS_PDT_CID_MULIT_MEDIA		0x0008
+#define WPS_PDT_CID_RTK_WIDI			WPS_PDT_CID_MULIT_MEDIA
+
+//	Value of Sub Category ID of WPS Primary Device Type Attribute
+#define WPS_PDT_SCID_MEDIA_SERVER	0x0005
+#define WPS_PDT_SCID_RTK_DMP			WPS_PDT_SCID_MEDIA_SERVER
+
+//	Value of Device Password ID
+#define WPS_DPID_PIN					0x0000
+#define WPS_DPID_USER_SPEC			0x0001
+#define WPS_DPID_MACHINE_SPEC			0x0002
+#define WPS_DPID_REKEY					0x0003
+#define WPS_DPID_PBC					0x0004
+#define WPS_DPID_REGISTRAR_SPEC		0x0005
+
+//	Value of WPS RF Bands Attribute
+#define WPS_RF_BANDS_2_4_GHZ		0x01
+#define WPS_RF_BANDS_5_GHZ		0x02
+
+//	Value of WPS Association State Attribute
+#define WPS_ASSOC_STATE_NOT_ASSOCIATED			0x00
+#define WPS_ASSOC_STATE_CONNECTION_SUCCESS		0x01
+#define WPS_ASSOC_STATE_CONFIGURATION_FAILURE	0x02
+#define WPS_ASSOC_STATE_ASSOCIATION_FAILURE		0x03
+#define WPS_ASSOC_STATE_IP_FAILURE				0x04
+
+
+// This value is tested by WiFi 11n Test Plan 5.2.3.
+// This test verifies the WLAN NIC can update the NAV through sending the CTS with large duration.
+#define	WiFiNavUpperUs				30000	// 30 ms
+
+/* Reason codes (IEEE 802.11-2007, 7.3.1.7, Table 7-22) */
+#define WLAN_REASON_UNSPECIFIED 1
+#define WLAN_REASON_PREV_AUTH_NOT_VALID 2
+#define WLAN_REASON_DEAUTH_LEAVING 3
+#define WLAN_REASON_DISASSOC_DUE_TO_INACTIVITY 4
+#define WLAN_REASON_DISASSOC_AP_BUSY 5
+#define WLAN_REASON_CLASS2_FRAME_FROM_NONAUTH_STA 6
+#define WLAN_REASON_CLASS3_FRAME_FROM_NONASSOC_STA 7
+#define WLAN_REASON_DISASSOC_STA_HAS_LEFT 8
+#define WLAN_REASON_STA_REQ_ASSOC_WITHOUT_AUTH 9
+/* IEEE 802.11h */
+#define WLAN_REASON_PWR_CAPABILITY_NOT_VALID 10
+#define WLAN_REASON_SUPPORTED_CHANNEL_NOT_VALID 11
+/* IEEE 802.11i */
+#define WLAN_REASON_INVALID_IE 13
+#define WLAN_REASON_MICHAEL_MIC_FAILURE 14
+#define WLAN_REASON_4WAY_HANDSHAKE_TIMEOUT 15
+#define WLAN_REASON_GROUP_KEY_UPDATE_TIMEOUT 16
+#define WLAN_REASON_IE_IN_4WAY_DIFFERS 17
+#define WLAN_REASON_GROUP_CIPHER_NOT_VALID 18
+#define WLAN_REASON_PAIRWISE_CIPHER_NOT_VALID 19
+#define WLAN_REASON_AKMP_NOT_VALID 20
+#define WLAN_REASON_UNSUPPORTED_RSN_IE_VERSION 21
+#define WLAN_REASON_INVALID_RSN_IE_CAPAB 22
+#define WLAN_REASON_IEEE_802_1X_AUTH_FAILED 23
+#define WLAN_REASON_CIPHER_SUITE_REJECTED 24
+
+#ifdef CONFIG_IEEE80211W
+#define _MME_IE_LENGTH_  18
+#endif /* CONFIG_IEEE80211W */
+
+#define OP_MODE_PURE                    0
+#define OP_MODE_MAY_BE_LEGACY_STAS      1
+#define OP_MODE_20MHZ_HT_STA_ASSOCED    2
+#define OP_MODE_MIXED                   3
+
+#define HT_INFO_HT_PARAM_SECONDARY_CHNL_OFF_MASK	((u8) BIT(0) | BIT(1))
+#define HT_INFO_HT_PARAM_SECONDARY_CHNL_ABOVE		((u8) BIT(0))
+#define HT_INFO_HT_PARAM_SECONDARY_CHNL_BELOW		((u8) BIT(0) | BIT(1))
+#define HT_INFO_HT_PARAM_REC_TRANS_CHNL_WIDTH		((u8) BIT(2))
+#define HT_INFO_HT_PARAM_RIFS_MODE			((u8) BIT(3))
+#define HT_INFO_HT_PARAM_CTRL_ACCESS_ONLY		((u8) BIT(4))
+#define HT_INFO_HT_PARAM_SRV_INTERVAL_GRANULARITY	((u8) BIT(5))
+
+#define HT_INFO_OPERATION_MODE_OP_MODE_MASK	\
+		((u8) (0x0003))
+#define HT_INFO_OPERATION_MODE_OP_MODE_OFFSET		0
+#define HT_INFO_OPERATION_MODE_NON_GF_DEVS_PRESENT	((u8) BIT(2))
+#define HT_INFO_OPERATION_MODE_TRANSMIT_BURST_LIMIT	((u8) BIT(3))
+#define HT_INFO_OPERATION_MODE_NON_HT_STA_PRESENT	((u8) BIT(4))
+
+#define HT_INFO_STBC_PARAM_DUAL_BEACON			((u16) BIT(6))
+#define HT_INFO_STBC_PARAM_DUAL_STBC_PROTECT		((u16) BIT(7))
+#define HT_INFO_STBC_PARAM_SECONDARY_BCN		((u16) BIT(8))
+#define HT_INFO_STBC_PARAM_LSIG_TXOP_PROTECT_ALLOWED	((u16) BIT(9))
+#define HT_INFO_STBC_PARAM_PCO_ACTIVE			((u16) BIT(10))
+#define HT_INFO_STBC_PARAM_PCO_PHASE			((u16) BIT(11))
+
+/*
+ * A-PMDU buffer sizes
+ * According to IEEE802.11n spec size varies from 8K to 64K (in powers of 2)
+ */
+#define IEEE80211_MIN_AMPDU_BUF 0x8
+#define IEEE80211_MAX_AMPDU_BUF 0x40
+
+//	P2P Public Action Frame Type
+#define	P2P_GO_NEGO_REQ						0
+#define	P2P_GO_NEGO_RESP						1
+#define	P2P_GO_NEGO_CONF						2
+#define	P2P_INVIT_REQ							3
+#define	P2P_INVIT_RESP							4
+#define	P2P_DEVDISC_REQ						5
+#define	P2P_DEVDISC_RESP						6
+#define	P2P_PROVISION_DISC_REQ				7
+#define	P2P_PROVISION_DISC_RESP				8
+
+#define OUI_MICROSOFT 0x0050f2 /* Microsoft (also used in Wi-Fi specs) 	* 00:50:F2 */
+#define OUI_BROADCOM 0x00904c /* Broadcom (Epigram) */
+
+#define WME_OUI_TYPE 2
+#define WME_OUI_SUBTYPE_INFORMATION_ELEMENT 0
+#define WME_OUI_SUBTYPE_PARAMETER_ELEMENT 1
+#define WME_OUI_SUBTYPE_TSPEC_ELEMENT 2
+
+#define VENDOR_HT_CAPAB_OUI_TYPE 0x33 /* 00-90-4c:0x33 */
+
+typedef unsigned char   NDIS_802_11_RATES[WLAN_RATES_MAXLEN];        // Set of 8 data rates
+typedef unsigned char   NDIS_802_11_RATES_EX[WLAN_RATES_EX_MAXLEN];  // Set of 16 data rates
+
+static inline u8 *rtw_get_capability_from_ie(u8 *ie)
+{
+	return (ie + 8 + 2);
+}
+
+static inline u8 *rtw_get_beacon_interval_from_ie(u8 *ie)
+{
+	return (ie + 8);
+}
+
+//temporarily put inline here
+__inline static int IS_MCAST(unsigned char *da)
+{
+	if ((*da) & 0x01) {
+		return _TRUE;
+	} else {
+		return _FALSE;
+	}
+}
+
+__inline static int IsFrameTypeCtrl(unsigned char *pframe)
+{
+	if (BIT(2) == GetFrameType(pframe)) {
+		return _TRUE;
+	} else {
+		return _FALSE;
+	}
+}
+
+__inline static unsigned char *get_ta(unsigned char *pframe)
+{
+	unsigned char 	*ta;
+	ta = GetAddr2Ptr(pframe);
+	return ta;
+}
+
+__inline static unsigned char *get_da(unsigned char *pframe)
+{
+	unsigned char 	*da;
+	unsigned int	to_fr_ds	= (GetToDs(pframe) << 1) | GetFrDs(pframe);
+
+	switch (to_fr_ds) {
+	case 0x00:	// ToDs=0, FromDs=0
+		da = GetAddr1Ptr(pframe);
+		break;
+	case 0x01:	// ToDs=0, FromDs=1
+		da = GetAddr1Ptr(pframe);
+		break;
+	case 0x02:	// ToDs=1, FromDs=0
+		da = GetAddr3Ptr(pframe);
+		break;
+	default:	// ToDs=1, FromDs=1
+		da = GetAddr3Ptr(pframe);
+		break;
+	}
+
+	return da;
+}
+
+
+__inline static unsigned char *get_sa(unsigned char *pframe)
+{
+	unsigned char 	*sa;
+	unsigned int	to_fr_ds	= (GetToDs(pframe) << 1) | GetFrDs(pframe);
+
+	switch (to_fr_ds) {
+	case 0x00:	// ToDs=0, FromDs=0
+		sa = GetAddr2Ptr(pframe);
+		break;
+	case 0x01:	// ToDs=0, FromDs=1
+		sa = GetAddr3Ptr(pframe);
+		break;
+	case 0x02:	// ToDs=1, FromDs=0
+		sa = GetAddr2Ptr(pframe);
+		break;
+	default:	// ToDs=1, FromDs=1
+		sa = GetAddr4Ptr(pframe);
+		break;
+	}
+
+	return sa;
+}
+
+__inline static unsigned char *get_hdr_bssid(unsigned char *pframe)
+{
+	unsigned char 	*sa;
+	unsigned int	to_fr_ds	= (GetToDs(pframe) << 1) | GetFrDs(pframe);
+
+	switch (to_fr_ds) {
+	case 0x00:	// ToDs=0, FromDs=0
+		sa = GetAddr3Ptr(pframe);
+		break;
+	case 0x01:	// ToDs=0, FromDs=1
+		sa = GetAddr2Ptr(pframe);
+		break;
+	case 0x02:	// ToDs=1, FromDs=0
+		sa = GetAddr1Ptr(pframe);
+		break;
+	case 0x03:	// ToDs=1, FromDs=1
+		sa = GetAddr1Ptr(pframe);
+		break;
+	default:
+		sa = NULL; //???????
+		break;
+	}
+
+	return sa;
+}
+
+
+
+#endif
+
diff --git a/os/board/rtl8720e/src/component/wifi/driver/include/rtw_80211spec_struct.h b/os/board/rtl8720e/src/component/wifi/driver/include/rtw_80211spec_struct.h
new file mode 100755
index 000000000..ebd519318
--- /dev/null
+++ b/os/board/rtl8720e/src/component/wifi/driver/include/rtw_80211spec_struct.h
@@ -0,0 +1,187 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+#ifndef	__RTW_80211SPEC_STRUCT_H_
+#define __RTW_80211SPEC_STRUCT_H_
+
+struct wlan_ethhdr_t {
+	unsigned char		daddr[ETH_ALEN];
+	unsigned char		saddr[ETH_ALEN];
+	unsigned short		type;
+};
+
+/* Fasten in ROM, cautious to revise. */
+struct rtw_ieee80211_hdr {
+	u16 frame_ctl;
+	u16 duration_id;
+	u8 addr1[ETH_ALEN];
+	u8 addr2[ETH_ALEN];
+	u8 addr3[ETH_ALEN];
+	u16 seq_ctl;
+	u8 addr4[ETH_ALEN];
+} _PACKED_;
+
+struct rtw_ieee80211_hdr_3addr {
+	u16 frame_ctl;
+	u16 duration_id;
+	u8 addr1[ETH_ALEN];
+	u8 addr2[ETH_ALEN];
+	u8 addr3[ETH_ALEN];
+	u16 seq_ctl;
+} _PACKED_;
+
+
+struct rtw_ieee80211_hdr_3addr_qos {
+	u16 frame_ctl;
+	u16 duration_id;
+	u8 addr1[ETH_ALEN];
+	u8 addr2[ETH_ALEN];
+	u8 addr3[ETH_ALEN];
+	u16 seq_ctl;
+	u16     qc;
+}  _PACKED_;
+
+struct eapol {
+	u8 snap[6];
+	u16 ethertype;
+	u8 version;
+	u8 type;
+	u16 length;
+} _PACKED_;
+
+struct HT_caps_element {
+	union {
+		struct {
+			unsigned short	HT_caps_info;
+			unsigned char	AMPDU_para;
+			unsigned char	MCS_rate[16];
+			unsigned short	HT_ext_caps;
+			unsigned int	Beamforming_caps;
+			unsigned char	ASEL_caps;
+		} _PACKED_
+		HT_cap_element;
+		unsigned char HT_cap[26];
+	} _PACKED_
+	u;
+} _PACKED_;
+
+struct AC_param {
+	unsigned char		ACI_AIFSN;
+	unsigned char		CW;
+	unsigned short	TXOP_limit;
+} _PACKED_;
+
+//move to rom, image cannot use this struct
+struct WMM_para_element_rom {
+	unsigned char		QoS_info;
+	unsigned char		reserved;
+	struct AC_param	ac_param[4];
+} _PACKED_;
+
+/**
+* struct rtw_ieee80211_ht_cap - HT capabilities
+*
+* This structure refers to "HT capabilities element" as
+* described in 802.11n draft section 7.3.2.52
+*/
+
+struct rtw_ieee80211_ht_cap {
+	unsigned short 	cap_info;
+	unsigned char 	ampdu_params_info;
+	unsigned char 	supp_mcs_set[16];
+	unsigned short 	extended_ht_cap_info;
+	unsigned int		tx_BF_cap_info;
+	unsigned char	       antenna_selection_info;
+} _PACKED_;
+
+/**
+ * struct rtw_ieee80211_ht_cap - HT additional information
+ *
+ * This structure refers to "HT information element" as
+ * described in 802.11n draft section 7.3.2.53
+ */
+struct ieee80211_ht_addt_info {
+	unsigned char 	control_chan;
+	unsigned char		ht_param;
+	unsigned short	operation_mode;
+	unsigned short	stbc_param;
+	unsigned char		basic_set[16];
+} _PACKED_;
+
+struct HT_info_element {
+	unsigned char	primary_channel;
+	unsigned char	infos[5];
+	unsigned char	MCS_rate[16];
+} _PACKED_;
+
+struct ADDBA_request {
+	unsigned char		dialog_token;
+	unsigned short	BA_para_set;
+	unsigned short	BA_timeout_value;
+	unsigned short	BA_starting_seqctrl;
+} _PACKED_;
+
+struct ieee80211_snap_hdr {
+
+	u8    dsap;   /* always 0xAA */
+	u8    ssap;   /* always 0xAA */
+	u8    ctrl;   /* always 0x03 */
+	u8    oui[P80211_OUI_LEN];    /* organizational universal id */
+
+} _PACKED_;
+
+#define SNAP_SIZE sizeof(struct ieee80211_snap_hdr)
+
+#if defined(CONFIG_IEEE80211K) || defined(CONFIG_RTW_WNM)
+/* Represent channel details, subset of ieee80211_channel */
+struct rtw_ieee80211_channel {
+	/* enum ieee80211_band band; */
+	/* u16 center_freq; */
+	u16 hw_value;
+	u32 flags;
+	/* int max_antenna_gain; */
+	/* int max_power; */
+	/* int max_reg_power; */
+	/* bool beacon_found; */
+	/* u32 orig_flags; */
+	/* int orig_mag; */
+	/* int orig_mpwr; */
+};
+#endif
+
+typedef struct _NDIS_802_11_VARIABLE_IEs {
+	uint8_t  ElementID;
+	uint8_t  Length;
+	uint8_t  data[1];
+} NDIS_802_11_VARIABLE_IEs, *PNDIS_802_11_VARIABLE_IEs;
+
+typedef struct _NDIS_802_11_SSID {
+	u32  SsidLength;
+	u8  Ssid[RTW_ESSID_MAX_SIZE + 4];
+} NDIS_802_11_SSID;
+
+typedef struct _NDIS_802_11_FIXED_IEs {
+	u8  Timestamp[8];
+	u16  BeaconInterval;
+	u16  Capabilities;
+} NDIS_802_11_FIXED_IEs;
+
+
+#endif
+
diff --git a/os/board/rtl8720e/src/component/wifi/driver/include/rtw_twt.h b/os/board/rtl8720e/src/component/wifi/driver/include/rtw_80211spec_twt.h
old mode 100644
new mode 100755
similarity index 90%
rename from os/board/rtl8720e/src/component/wifi/driver/include/rtw_twt.h
rename to os/board/rtl8720e/src/component/wifi/driver/include/rtw_80211spec_twt.h
index f15428f43..08ad5f510
--- a/os/board/rtl8720e/src/component/wifi/driver/include/rtw_twt.h
+++ b/os/board/rtl8720e/src/component/wifi/driver/include/rtw_80211spec_twt.h
@@ -1,6 +1,6 @@
 /******************************************************************************
  *
- * Copyright(c) 2007 - 2017 Realtek Corporation.
+ * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or modify it
  * under the terms of version 2 of the GNU General Public License as
@@ -11,9 +11,14 @@
  * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
  * more details.
  *
- *****************************************************************************/
-#ifndef _RTW_TWT_H_
-#define _RTW_TWT_H_
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+#ifndef	__RTW_80211SPEC_TWT_H_
+#define __RTW_80211SPEC_TWT_H_
 
 #define TWT_IE_LEN	15
 
@@ -105,15 +110,6 @@
 #define GET_TWT_PARA_CHANNEL(_pEleStart) \
 	LE_BITS_TO_1BYTE(_pEleStart +13, 0, 8)
 
-typedef struct {
-	unsigned char id;
-	unsigned char announced;
-	unsigned char trigger;
-	u64 target_time;//unit: us
-	u32 interval;//unit: us
-	u16 duration;//unit: us
-} twt_para_t;
-
 struct twt_control_t {
 	unsigned char rsvd: 2;
 	unsigned char wake_duration_unit: 1;	/* 0: the unit is 256 us, 1: the unit is a TU. A non-HE STA sets to 0 */
@@ -158,17 +154,5 @@ struct twt_ie_t {
 	struct twt_ie_other_t twt_ie_o;
 };
 
-enum twt_class {
-	TWTCLIENTA               = 0x0,
-	TWTCLIENTB               = 0x1,
-	TWTCLIENTC               = 0x2,
-	TWTCLIENTD               = 0x3,
-	TWTCLIENTE               = 0x4,
-};
-
-void rtw_twt_timer_enable(u8 idx, u8 port);
-void rtw_twt_timer_disable(u8 idx);
-void rtw_twt_set_early_time(u8 idx, u8 early_time);
-void rtw_twt_set_target_wake_time(u8 idx, u64 twt);
 #endif
 
diff --git a/os/board/rtl8720e/src/component/wifi/driver/include/rtw_vht.h b/os/board/rtl8720e/src/component/wifi/driver/include/rtw_80211spec_vht.h
old mode 100644
new mode 100755
similarity index 75%
rename from os/board/rtl8720e/src/component/wifi/driver/include/rtw_vht.h
rename to os/board/rtl8720e/src/component/wifi/driver/include/rtw_80211spec_vht.h
index 5b87af64d..1db0ce3ca
--- a/os/board/rtl8720e/src/component/wifi/driver/include/rtw_vht.h
+++ b/os/board/rtl8720e/src/component/wifi/driver/include/rtw_80211spec_vht.h
@@ -1,6 +1,6 @@
 /******************************************************************************
  *
- * Copyright(c) 2007 - 2017 Realtek Corporation.
+ * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or modify it
  * under the terms of version 2 of the GNU General Public License as
@@ -11,9 +11,14 @@
  * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
  * more details.
  *
- *****************************************************************************/
-#ifndef _RTW_VHT_H_
-#define _RTW_VHT_H_
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+#ifndef	__RTW_80211SPEC_VHT_H_
+#define __RTW_80211SPEC_VHT_H_
 
 #define VHT_CAP_IE_LEN 12
 #define VHT_OP_IE_LEN 5
@@ -92,44 +97,5 @@
 #define SET_EXT_CAPABILITY_ELE_OP_MODE_NOTIF(_pEleStart, _val)			SET_BITS_TO_LE_1BYTE((_pEleStart)+7, 6, 1, _val)
 #define GET_EXT_CAPABILITY_ELE_OP_MODE_NOTIF(_pEleStart)				LE_BITS_TO_1BYTE((_pEleStart)+7, 6, 1)
 
-#define VHT_MAX_MPDU_LEN_MAX 3
-extern const u16 _vht_max_mpdu_len[];
-#define vht_max_mpdu_len(val) (((val) >= VHT_MAX_MPDU_LEN_MAX) ? _vht_max_mpdu_len[VHT_MAX_MPDU_LEN_MAX] : _vht_max_mpdu_len[(val)])
-
-#define VHT_SUP_CH_WIDTH_SET_MAX 3
-extern const u8 _vht_sup_ch_width_set_to_bw_cap[];
-#define vht_sup_ch_width_set_to_bw_cap(set) (((set) >= VHT_SUP_CH_WIDTH_SET_MAX) ? _vht_sup_ch_width_set_to_bw_cap[VHT_SUP_CH_WIDTH_SET_MAX] : _vht_sup_ch_width_set_to_bw_cap[(set)])
-extern const char *const _vht_sup_ch_width_set_str[];
-#define vht_sup_ch_width_set_str(set) (((set) >= VHT_SUP_CH_WIDTH_SET_MAX) ? _vht_sup_ch_width_set_str[VHT_SUP_CH_WIDTH_SET_MAX] : _vht_sup_ch_width_set_str[(set)])
-
-#define VHT_MAX_AMPDU_LEN(f) ((1 << (13 + f)) - 1)
-void dump_vht_cap_ie(void *sel, const u8 *ie, u32 ie_len);
-
-#define VHT_OP_CH_WIDTH_MAX 4
-extern const char *const _vht_op_ch_width_str[];
-#define vht_op_ch_width_str(ch_width) (((ch_width) >= VHT_OP_CH_WIDTH_MAX) ? _vht_op_ch_width_str[VHT_OP_CH_WIDTH_MAX] : _vht_op_ch_width_str[(ch_width)])
-
-void dump_vht_op_ie(void *sel, const u8 *ie, u32 ie_len);
-
-struct vht_priv {
-	u8	vht_option;
-
-	u8	ldpc_cap;
-	u8	stbc_cap;
-	u16	beamform_cap;
-	u8	vht_mcs_map[2];
-};
-
-u8 rtw_get_vht_highest_rate(u8 *pvht_mcs_map);
-u64 rtw_vht_mcs_map_to_bitmap(u8 *mcs_map, u8 nss);
-void rtw_vht_use_default_setting(_adapter *padapter);
-u32 rtw_build_vht_operation_ie(_adapter *padapter, u8 *pbuf, u8 channel);
-u32 rtw_build_vht_op_mode_notify_ie(_adapter *padapter, u8 *pbuf, u8 bw);
-u32 rtw_build_vht_cap_ie(_adapter *padapter, u8 *pbuf);
-void rtw_process_vht_op_mode_notify(_adapter *padapter, u8 *pframe, PVOID sta);
-u32 rtw_restructure_vht_ie(_adapter *padapter, u8 *in_ie, u8 *out_ie, uint in_len, uint *pout_len);
-u8 rtw_vht_mcsmap_to_nss(u8 *pvht_mcs_map);
-void rtw_vht_nss_to_mcsmap(u8 nss, u8 *target_mcs_map, u8 *cur_mcs_map);
-void rtw_bf_get_vht_gid_mgnt_packet(_adapter *padapter, union recv_frame *rframe);
+#endif
 
-#endif /* _RTW_VHT_H_ */
diff --git a/os/board/rtl8720e/src/component/wifi/driver/include/rtw_80211spec_wnm.h b/os/board/rtl8720e/src/component/wifi/driver/include/rtw_80211spec_wnm.h
new file mode 100755
index 000000000..3bc3ec441
--- /dev/null
+++ b/os/board/rtl8720e/src/component/wifi/driver/include/rtw_80211spec_wnm.h
@@ -0,0 +1,96 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+#ifndef	__RTW_80211SPEC_WNM_H_
+#define __RTW_80211SPEC_WNM_H_
+
+#define RTW_RRM_NB_RPT_EN		BIT(1)
+#define RTW_MAX_NB_RPT_NUM	16
+
+#define rtw_wnm_set_ext_cap_btm(_pEleStart, _val) \
+	SET_BITS_TO_LE_1BYTE(((u8 *)(_pEleStart))+2, 3, 1, _val)
+
+#define wnm_btm_bss_term_inc(p) (*((u8 *)((p)+3)) & BSS_TERMINATION_INCLUDED)
+
+#define wnm_btm_ess_disassoc_im(p) (*((u8 *)((p)+3)) & ESS_DISASSOC_IMMINENT)
+
+#define wnm_btm_dialog_token(p) (*((u8 *)((p)+2)))
+
+#define wnm_btm_req_mode(p) (*((u8 *)((p)+3)))
+
+#define wnm_btm_disassoc_timer(p) (*((u16 *)((p)+4)))
+
+#define wnm_btm_valid_interval(p) (*((u8 *)((p)+6)))
+
+#define wnm_btm_term_duration_offset(p) ((p)+7)
+
+#define RTW_WLAN_ACTION_WNM_NB_RPT_ELEM	0x34
+
+enum rtw_ieee80211_wnm_actioncode {
+	RTW_WLAN_ACTION_WNM_BTM_QUERY = 6,
+	RTW_WLAN_ACTION_WNM_BTM_REQ = 7,
+	RTW_WLAN_ACTION_WNM_BTM_RSP = 8,
+	RTW_WLAN_ACTION_WNM_NOTIF_REQ = 26,
+	RTW_WLAN_ACTION_WNM_NOTIF_RSP = 27,
+};
+
+/*IEEE Std 80211k Figure 7-95b Neighbor Report element format*/
+struct nb_rpt_hdr {
+	u8 id; /*0x34: Neighbor Report Element ID*/
+	u8 len;
+	u8 bssid[ETH_ALEN];
+	u32 bss_info;
+	u8 reg_class;
+	u8 ch_num;
+	u8 phy_type;
+};
+
+/*IEEE Std 80211v, Figure 7-9 BSS Termination Duration subelement field format */
+struct btm_term_duration {
+	u8 id;
+	u8 len;
+	u64 tsf;		/* value of the TSF counter when BSS termination will occur in the future */
+	u16 duration;		/* number of minutes for which the BSS is not present*/
+};
+
+/*IEEE Std 80211v, Figure 7-10 BSS Transition Management Request frame body format */
+struct btm_req_hdr {
+	u8 dialog_token;
+	u8 req_mode;
+	/* number of TBTTs until the AP sends a Disassociation frame to this STA */
+	u16 disassoc_timer;
+	/* number of TBTTs until the BSS transition candidate list is no longer valid */
+	u8 validity_interval;
+	struct btm_term_duration term_duration;
+};
+
+/*IEEE Std 80211v,  Table 7-43b Optional Subelement IDs for Neighbor Report*/
+/* BSS Transition Candidate Preference */
+#define WNM_BTM_CAND_PREF_SUBEID 0x03
+
+/* BSS Termination Duration */
+#define WNM_BTM_TERM_DUR_SUBEID		0x04
+
+struct wnm_btm_cant {
+	struct nb_rpt_hdr nb_rpt;
+	u8 preference;	/* BSS Transition Candidate Preference */
+};
+
+#endif
+
diff --git a/os/board/rtl8720e/src/component/wifi/driver/include/rtw_ap.h b/os/board/rtl8720e/src/component/wifi/driver/include/rtw_ap.h
deleted file mode 100644
index b559d598c..000000000
--- a/os/board/rtl8720e/src/component/wifi/driver/include/rtw_ap.h
+++ /dev/null
@@ -1,108 +0,0 @@
-/******************************************************************************
- *
- * Copyright(c) 2007 - 2012 Realtek Corporation. All rights reserved.
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of version 2 of the GNU General Public License as
- * published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
- * more details.
- *
- * You should have received a copy of the GNU General Public License along with
- * this program; if not, write to the Free Software Foundation, Inc.,
- * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
- *
- *
- ******************************************************************************/
-#ifndef __RTW_AP_H_
-#define __RTW_AP_H_
-
-#define AUTH_TIMEOUT				3
-#define ASSOC_TIMEOUT				3
-#define EXPIRE_TIMEOUT				60	// 60*2 = 120 sec = 2 min, expire after no any traffic.
-
-struct ap_priv {
-	/* Number of non-HT AP/stations */
-	u8 num_sta_no_ht; //int num_sta_no_ht;
-	/* Number of associated Non-ERP stations (i.e., stations using 802.11b
-	 * in 802.11g BSS) */
-	u8 num_sta_non_erp;
-	/* Number of associated stations that do not support Short Slot Time */
-	u8 num_sta_no_short_slot_time;
-	/* Number of associated stations that do not support Short Preamble */
-	u8 num_sta_no_short_preamble;
-	/* Number of HT associated stations that do not support greenfield */
-	u8 num_sta_ht_no_gf;
-	/* Number of HT associated stations 20 MHz */
-	u8 num_sta_ht_20mhz;
-	u8 num_sta_no_wmm;
-
-	/* Overlapping BSS information */
-	u8 olbc_ht;
-
-	u8 ht_op_mode;
-
-	_lock	bcn_update_lock;
-	u8		update_bcn;
-
-	/*ap csa related*/
-	u8 ap_csa_start;
-	u8 csa_new_chl;
-	u8 *csa_ie;
-	ap_channel_switch_callback_t ap_channel_switch_callback;
-	_timer ap_csa_update_timer;
-
-	_list asoc_list;
-	_list auth_list;
-	_lock asoc_list_lock;
-	_lock auth_list_lock;
-	_lock expire_lock;
-
-	/* pointers to STA info; based on allocated AID or NULL if AID free
-	 * AID is in the range 1-2007, so sta_aid[0] corresponders to AID 1
-	 * and so on
-	 */
-	struct sta_info *sta_aid[NUM_STA];
-
-	u16 sta_dz_bitmap;//only support 15 stations, staion aid bitmap for sleeping sta.
-	u16 tim_bitmap;//only support 15 stations, aid=0~15 mapping bit0~bit15
-
-	u16 max_num_sta;
-
-};
-
-//external function
-extern void rtw_indicate_sta_assoc_event(_adapter *padapter, struct sta_info *psta);
-extern void rtw_indicate_sta_disassoc_event(_adapter *padapter, struct sta_info *psta);
-
-
-void init_mlme_ap_info(_adapter *padapter);
-void free_mlme_ap_info(_adapter *padapter);
-//void update_BCNTIM(_adapter *padapter);
-void rtw_add_bcn_ie(_adapter *padapter, WLAN_BSSID_EX *pnetwork, u8 index, u8 *data, u8 len);
-void rtw_remove_bcn_ie(_adapter *padapter, WLAN_BSSID_EX *pnetwork, u8 index);
-void update_beacon(_adapter *padapter, u8 ie_id, u8 *oui, u8 tx);
-void add_RATid(_adapter *padapter, struct sta_info *psta, u8 rssi_level);
-void expire_timeout_chk(_adapter *padapter);
-void update_sta_info_apmode(_adapter *padapter, struct sta_info *psta);
-void rtw_set_macaddr_acl(_adapter *padapter, int mode);
-int rtw_acl_add_sta(_adapter *padapter, u8 *addr);
-int rtw_acl_remove_sta(_adapter *padapter, u8 *addr);
-int rtw_generate_bcn_ie(_adapter *adapter, u8 *ssid, u16 ssid_len, u8 *ie, u32 max_ie_sz);
-//void start_bss_network(_adapter *padapter, struct createbss_parm *parm);
-void start_bss_network(_adapter *padapter, u8 *parm);
-
-void associated_clients_update(_adapter *padapter, u8 updated);
-void bss_cap_update_on_sta_join(_adapter *padapter, struct sta_info *psta);
-u8 bss_cap_update_on_sta_leave(_adapter *padapter, struct sta_info *psta);
-void sta_info_update(_adapter *padapter, struct sta_info *psta);
-void ap_sta_info_defer_update(_adapter *padapter, struct sta_info *psta);
-u8 ap_free_sta(_adapter *padapter, struct sta_info *psta, u16 reason);
-int rtw_sta_flush(_adapter *padapter);
-void ap_csa_update_timer_hdl(void *FunctionContext);
-
-#endif
-
diff --git a/os/board/rtl8720e/src/component/wifi/driver/include/autoconf.h b/os/board/rtl8720e/src/component/wifi/driver/include/rtw_autoconf.h
old mode 100644
new mode 100755
similarity index 78%
rename from os/board/rtl8720e/src/component/wifi/driver/include/autoconf.h
rename to os/board/rtl8720e/src/component/wifi/driver/include/rtw_autoconf.h
index c76110af3..36c7d07c0
--- a/os/board/rtl8720e/src/component/wifi/driver/include/autoconf.h
+++ b/os/board/rtl8720e/src/component/wifi/driver/include/rtw_autoconf.h
@@ -24,13 +24,9 @@
 
 #define CONFIG_LITTLE_ENDIAN
 
-#if defined(CONFIG_PLATFORM_8721D) || defined(CONFIG_PLATFORM_AMEBAD2) || defined(CONFIG_PLATFORM_8735B) || defined(CONFIG_PLATFORM_AMEBALITE) || defined(CONFIG_PLATFORM_AMEBADPLUS)
 #ifndef CONFIG_PLATFORM_AMEBA_X
 #define CONFIG_PLATFORM_AMEBA_X 1
 #endif
-#else
-#define CONFIG_PLATFORM_AMEBA_X 0
-#endif
 
 //#define CONFIG_HIGH_TP
 
@@ -46,29 +42,21 @@
 #define CONFIG_SAE_SUPPORT
 #ifdef CONFIG_SAE_SUPPORT
 #define CONFIG_SAE_DH_SUPPORT 1
-#define ALL_DH_GROUPS
 #endif
 
 
 /* For promiscuous mode */
-#define CONFIG_PROMISC
+//#define CONFIG_PROMISC
 
 /* For STA+AP Concurrent MODE */
-#define CONFIG_CONCURRENT_MODE
 /****************** configurations for concurrent mode ************************/
-#ifdef CONFIG_CONCURRENT_MODE
+//#define CONFIG_MCC_MODE
 //#define CONFIG_STA_MODE_SCAN_UNDER_AP_MODE
 #define NET_IF_NUM	3
-/* Temp macro for new concurrent test. */
-#define CONFIG_CONCURRENT_NEW
-#endif
 /**************** configurations for concurrent mode end **********************/
 
 /* For WPS and P2P */
 #define CONFIG_WPS
-#if 0
-#define CONFIG_WPS_AP
-#endif
 
 /***************************** for Debug message ******************************/
 #include "autoconf_debug.h"
@@ -79,7 +67,6 @@
 #define RTL8192E_SUPPORT 0
 #define RTL8188E_SUPPORT 0
 #define RTL8188F_SUPPORT 0
-#define RTL8711B_SUPPORT 0
 #define RTL8720E_SUPPORT 0
 #define RTL8721D_SUPPORT 0
 #define RTL8723D_SUPPORT 0
@@ -94,10 +81,7 @@
 /******************** Configurations for each platform ************************/
 #if (CONFIG_PLATFORM_AMEBA_X == 1)
 /******************* Ameba Series Common Configurations ***********************/
-//#define CONFIG_WLAN_HAL_RX_TASK
-
 #define NOT_SUPPORT_RF_MULTIPATH
-#define USE_XMIT_EXTBUFF 1
 
 /*PHYDM version*/
 #define OUTSRC	1
@@ -121,28 +105,19 @@
 #include "autoconf_8720e.h"
 #endif
 /****************************** Ameba Series End ******************************/
-#else /* (CONFIG_PLATFORM_AMEBA_X != 1) */
-/*************************** Non Ameba Series Start ***************************/
-#include "autoconf_nic.h"
-/*************************** Non Ameba Series End *****************************/
 #endif /* (CONFIG_PLATFORM_AMEBA_X == 1) */
 /****************** Configurations for each platform end **********************/
 
-/********************** For AP mode configurations ****************************/
-/* to save memory, set AP_STA_NUM to 3. */
-#ifndef AP_STA_NUM
-#define AP_STA_NUM (3)
-//Decrease STA due to memory limitation - Alex Fang
-#define NUM_STA (2 + AP_STA_NUM)	//2 + supported clients
-#endif /* not defined(AP_STA_NUM) */
-
-//#define CONFIG_GK_REKEY
-/******************** For AP mode configurations end **************************/
 
 /************************ For EAP auth configurations *************************/
 #include "autoconf_eap.h"
 /************************ For EAP auth configurations *************************/
 
+#if WIFI_LOGO_CERTIFICATION
+#undef WLAN_MAX_ETHFRM_LEN
+#define WLAN_MAX_ETHFRM_LEN	4000
+#endif
+
 /* 80211 - K V R */
 //#define CONFIG_IEEE80211K
 //#define CONFIG_LAYER2_ROAMING
diff --git a/os/board/rtl8720e/src/component/wifi/driver/include/rtw_btcoex_soc.h b/os/board/rtl8720e/src/component/wifi/driver/include/rtw_btcoex_soc.h
deleted file mode 100644
index e2e1c3a1e..000000000
--- a/os/board/rtl8720e/src/component/wifi/driver/include/rtw_btcoex_soc.h
+++ /dev/null
@@ -1,151 +0,0 @@
-/******************************************************************************
- *
- * Copyright(c) 2013 Realtek Corporation. All rights reserved.
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of version 2 of the GNU General Public License as
- * published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
- * more details.
- *
- * You should have received a copy of the GNU General Public License along with
- * this program; if not, write to the Free Software Foundation, Inc.,
- * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
- *
- *
- ******************************************************************************/
-#ifndef __RTW_BTCOEX_SOC_H__
-#define __RTW_BTCOEX_SOC_H__
-
-#include <drv_types.h>
-
-//bt state
-enum {
-	COEX_STATE_BT_OFF = 0,
-	COEX_STATE_BT_ON = 0x01,
-	COEX_STATE_BLE_SCAN = 0x02,
-	COEX_STATE_BLE_INIT = 0x04,
-	COEX_STATE_MESH_PB_ADV = 0x08,
-	COEX_STATE_BT_MAX
-};
-
-//wifi state
-enum {
-	COEX_STATE_WIFI_OFF = 0,
-	COEX_STATE_WIFI_STA_UNCONNECTED = 0x01,
-	COEX_STATE_WIFI_STA_SCAN = 0x02,
-	COEX_STATE_WIFI_STA_CONNECTING = 0x03,
-	COEX_STATE_WIFI_STA_FOUR_WAY_DOING = 0x04,
-	COEX_STATE_WIFI_STA_CONNECTED = 0x05,
-	COEX_STATE_WIFI_AP_IDLE = 0x06,
-	COEX_STATE_WIFI_CONCURRENT = 0x07,
-	COEX_STATE_WIFI_OTHER_MODE = 0x08,
-	COEX_STATE_WIFI_MAX
-};
-
-//wifi event
-enum {
-	COEX_EVENT_WIFI_OFF = 0,
-	COEX_EVENT_WIFI_ON = 1,
-	COEX_EVENT_WIFI_SCAN_START = 2,
-	COEX_EVENT_WIFI_SCAN_DONE = 3,
-	COEX_EVENT_WIFI_JOIN_START = 4,
-	COEX_EVENT_WIFI_JOIN_SUCCESS = 5,
-	COEX_EVENT_WIFI_JOIN_FAIL = 6,
-	COEX_EVENT_WIFI_DISCONNECT = 7,
-	COEX_EVENT_WIFI_CHANGE_MODE = 8,
-	COEX_EVENT_WIFI_FOURWAY_DONE = 9,
-	COEX_EVENT_WIFI_MAX
-};
-/**
-  * @brief  The enumeration is coex state indicated from wlan driver.
-  */
-
-struct mailbox_info {
-	u8	id;
-	u8	*data;
-	u8	len;
-	_list	list;
-};
-
-struct coex_hal_fun_t {
-	void (*run_case)(_adapter *padapter, u16 state);
-	void (*hal_coex_init)(_adapter *padapter);
-	u16(*wifi_tdma_scan_start)(PADAPTER padapter, RT_SCAN_TYPE scan_type);
-	u16(*wifi_tdma_scan_handle)(PADAPTER padapter);
-};
-
-struct wifi_tdma_scan_t {
-	u8 scaning;
-	u8 slot_num;
-	u8 cur_slot;
-};
-
-/*may be used before both devices on*/
-struct coex_t {
-	u8 coex_en;
-	u8 wifi_state;
-	u8 wifi_last_state;
-	u8 bt_state;
-	u16 state;
-	_mutex coex_run_lock;
-	struct wifi_tdma_scan_t wifi_tdma_scan;
-	struct coex_hal_fun_t *hal_fun;
-
-};
-
-/*only be used after both devices on, so it can be free when only one device is on */
-struct coex_priv {
-	int table_idx;
-	u8 ble_scan_duty;
-	u8 random_wlan_slot;
-	u8 wlan_connecting_adjust;
-	u8 wlan_4way_adjust;
-	u8 wlan_connected_adjust;
-};
-
-typedef struct _coex_bt_info {
-	//low byte 1
-	u8 length: 8;
-
-	//low byte 2
-	u8 Connection: 1;
-	u8 rsvd1: 7;
-
-	//low byte 3
-	u8 rsvd2: 8;
-
-	//hign byte 0
-	u8 rsvd3: 8;
-
-	//hign byte 1
-	u8 rsvd5: 5;
-	u8 Ble_scan_en: 1;
-	u8 Ble_init_scan: 1;
-	u8 rsvd4: 1;
-
-	//hign byte 2
-	u8 rsvd6: 8;
-
-	//hign byte 3
-	u8 rsvd7: 8;
-} coex_bt_info;
-
-#define COEX_MBOX_STACKSIZE                    256
-
-int rtw_coex_mailbox_to_wifi(_adapter *padapter, u8 *data, u8 len);
-int rtw_coex_wifi_info_update(_adapter *padapter, u8 wifi_event);
-int rtw_coex_ble_scan_duty_update(_adapter *padapter, u8 duty);
-int rtw_coex_wlan_slot_random_set(_adapter *padapter, bool temp);
-int rtw_coex_wlan_slot_preempting_set(_adapter *padapter, u8 bitmask);
-void rtw_btcoex_init(PADAPTER padapter);
-void rtw_btcoex_deinit(PADAPTER padapter);
-int rtw_coex_bt_enable(_adapter *padapter, u8 enable);
-void rtw_coex_wifi_enable(PADAPTER padapter, u8 enable);
-u16 rtw_coex_wifi_tdma_scan_start(PADAPTER padapter, RT_SCAN_TYPE scan_type);
-u16 rtw_coex_wifi_tdma_scan_handle(PADAPTER padapter);
-u8 rtw_coex_is_bt_disabled(PADAPTER padapter);
-#endif /* __RTW_BTCOEX_SOC_H__ */
diff --git a/os/board/rtl8720e/src/component/wifi/driver/include/rtw_byteorder.h b/os/board/rtl8720e/src/component/wifi/driver/include/rtw_byteorder.h
old mode 100644
new mode 100755
index bcde84b9e..be91cfcc2
--- a/os/board/rtl8720e/src/component/wifi/driver/include/rtw_byteorder.h
+++ b/os/board/rtl8720e/src/component/wifi/driver/include/rtw_byteorder.h
@@ -20,16 +20,192 @@
 #ifndef _RTL871X_BYTEORDER_H_
 #define _RTL871X_BYTEORDER_H_
 
-#include <drv_conf.h>
+#include "basic_types.h"
 
+#if !defined(CONFIG_PLATFORM_MSTAR_TITANIA12)
 
-#  include <byteorder/little_endian.h>
+#define RTW_GET_BE16(a) ((uint16_t) (((a)[0] << 8) | (a)[1]))
 
+#define RTW_GET_LE16(a) ((uint16_t) (((a)[1] << 8) | (a)[0]))
+#define RTW_PUT_LE16(a, val)			\
+	do {					\
+		(a)[1] = ((uint16_t) (val)) >> 8;	\
+		(a)[0] = ((uint16_t) (val)) & 0xff;	\
+	} while (0)
 
-u16 _htons(u16 x);
-u16 _ntohs(u16 x);
-u32 _htonl(u32 x);
-u32 _ntohl(u32 x);
+#define RTW_GET_BE24(a) ((((uint32_t) (a)[0]) << 16) | (((uint32_t) (a)[1]) << 8) | \
+			 ((uint32_t) (a)[2]))
+
+__inline static __u16  ___swab16(__u16 x)
+{
+	__u16 __x = x;
+	return
+		((__u16)(
+			 (((__u16)(__x) & (__u16)0x00ffU) << 8) |
+			 (((__u16)(__x) & (__u16)0xff00U) >> 8)));
+
+}
+
+__inline static __u32  ___swab32(__u32 x)
+{
+	__u32 __x = (x);
+	return ((__u32)(
+				(((__u32)(__x) & (__u32)0x000000ffUL) << 24) |
+				(((__u32)(__x) & (__u32)0x0000ff00UL) <<  8) |
+				(((__u32)(__x) & (__u32)0x00ff0000UL) >>  8) |
+				(((__u32)(__x) & (__u32)0xff000000UL) >> 24)));
+}
+
+__inline static __u64  ___swab64(__u64 x)
+{
+	__u64 __x = (x);
+
+	return
+		((__u64)(\
+				 (__u64)(((__u64)(__x) & (__u64)0x00000000000000ffULL) << 56) | \
+				 (__u64)(((__u64)(__x) & (__u64)0x000000000000ff00ULL) << 40) | \
+				 (__u64)(((__u64)(__x) & (__u64)0x0000000000ff0000ULL) << 24) | \
+				 (__u64)(((__u64)(__x) & (__u64)0x00000000ff000000ULL) <<  8) | \
+				 (__u64)(((__u64)(__x) & (__u64)0x000000ff00000000ULL) >>  8) | \
+				 (__u64)(((__u64)(__x) & (__u64)0x0000ff0000000000ULL) >> 24) | \
+				 (__u64)(((__u64)(__x) & (__u64)0x00ff000000000000ULL) >> 40) | \
+				 (__u64)(((__u64)(__x) & (__u64)0xff00000000000000ULL) >> 56)));
+	\
+}
+#endif // CONFIG_PLATFORM_MSTAR_TITANIA12
+
+#ifndef __arch__swab16
+__inline static __u16 __arch__swab16(__u16 x)
+{
+	return ___swab16(x);
+}
+
+#endif
+
+#ifndef __arch__swab32
+__inline static __u32 __arch__swab32(__u32 x)
+{
+	__u32 __tmp = (x) ;
+	return ___swab32(__tmp);
+}
+#endif
+
+#ifndef __arch__swab64
+
+__inline static __u64 __arch__swab64(__u64 x)
+{
+	__u64 __tmp = (x) ;
+	return ___swab64(__tmp);
+}
+
+
+#endif
+
+#ifndef __swab16
+#define __swab16(x) __fswab16(x)
+#define __swab32(x) __fswab32(x)
+#define __swab64(x) __fswab64(x)
+#endif	// __swab16
+
+__inline static __u16 __fswab16(__u16 x)
+{
+	return __arch__swab16(x);
+}
+
+__inline static __u32 __fswab32(__u32 x)
+{
+	return __arch__swab32(x);
+}
+
+
+/*
+ * inside the kernel, we can use nicknames;
+ * outside of it, we must avoid POSIX namespace pollution...
+ */
+
+#define cpu_to_le64 __cpu_to_le64
+#define le64_to_cpu __le64_to_cpu
+#define cpu_to_le32 __cpu_to_le32
+#define le32_to_cpu __le32_to_cpu
+#define cpu_to_le16 __cpu_to_le16
+#define le16_to_cpu __le16_to_cpu
+#define cpu_to_be64 __cpu_to_be64
+#define be64_to_cpu __be64_to_cpu
+#define cpu_to_be32 __cpu_to_be32
+#define be32_to_cpu __be32_to_cpu
+#define cpu_to_be16 __cpu_to_be16
+#define be16_to_cpu __be16_to_cpu
+#define cpu_to_le64p __cpu_to_le64p
+#define le64_to_cpup __le64_to_cpup
+#define cpu_to_le32p __cpu_to_le32p
+#define le32_to_cpup __le32_to_cpup
+#define cpu_to_le16p __cpu_to_le16p
+#define le16_to_cpup __le16_to_cpup
+#define cpu_to_be64p __cpu_to_be64p
+#define be64_to_cpup __be64_to_cpup
+#define cpu_to_be32p __cpu_to_be32p
+#define be32_to_cpup __be32_to_cpup
+#define cpu_to_be16p __cpu_to_be16p
+#define be16_to_cpup __be16_to_cpup
+#define cpu_to_le64s __cpu_to_le64s
+#define le64_to_cpus __le64_to_cpus
+#define cpu_to_le32s __cpu_to_le32s
+#define le32_to_cpus __le32_to_cpus
+#define cpu_to_le16s __cpu_to_le16s
+#define le16_to_cpus __le16_to_cpus
+#define cpu_to_be64s __cpu_to_be64s
+#define be64_to_cpus __be64_to_cpus
+#define cpu_to_be32s __cpu_to_be32s
+#define be32_to_cpus __be32_to_cpus
+#define cpu_to_be16s __cpu_to_be16s
+#define be16_to_cpus __be16_to_cpus
+
+#ifndef __LITTLE_ENDIAN
+#define __LITTLE_ENDIAN 1234
+#endif
+#ifndef __LITTLE_ENDIAN_BITFIELD
+#define __LITTLE_ENDIAN_BITFIELD
+#endif
+
+#ifndef __constant_htonl
+
+#define __cpu_to_le64(x) ((__u64)(x))
+#define __le64_to_cpu(x) ((__u64)(x))
+#define __cpu_to_le32(x) ((__u32)(x))
+#define __le32_to_cpu(x) ((__u32)(x))
+#define __cpu_to_le16(x) ((__u16)(x))
+#define __le16_to_cpu(x) ((__u16)(x))
+#define __cpu_to_be64(x) __swab64((x))
+#define __be64_to_cpu(x) __swab64((x))
+#define __cpu_to_be32(x) __swab32((x))
+#define __be32_to_cpu(x) __swab32((x))
+#define __cpu_to_be16(x) __swab16((x))
+#define __be16_to_cpu(x) __swab16((x))
+#define __cpu_to_le64p(x) (*(__u64*)(x))
+#define __le64_to_cpup(x) (*(__u64*)(x))
+#define __cpu_to_le32p(x) (*(__u32*)(x))
+#define __le32_to_cpup(x) (*(__u32*)(x))
+#define __cpu_to_le16p(x) (*(__u16*)(x))
+#define __le16_to_cpup(x) (*(__u16*)(x))
+#define __cpu_to_be64p(x) __swab64p((x))
+#define __be64_to_cpup(x) __swab64p((x))
+#define __cpu_to_be32p(x) __swab32p((x))
+#define __be32_to_cpup(x) __swab32p((x))
+#define __cpu_to_be16p(x) __swab16p((x))
+#define __be16_to_cpup(x) __swab16p((x))
+#define __cpu_to_le64s(x) do {} while (0)
+#define __le64_to_cpus(x) do {} while (0)
+#define __cpu_to_le32s(x) do {} while (0)
+#define __le32_to_cpus(x) do {} while (0)
+#define __cpu_to_le16s(x) do {} while (0)
+#define __le16_to_cpus(x) do {} while (0)
+#define __cpu_to_be64s(x) __swab64s((x))
+#define __be64_to_cpus(x) __swab64s((x))
+#define __cpu_to_be32s(x) __swab32s((x))
+#define __be32_to_cpus(x) __swab32s((x))
+#define __cpu_to_be16s(x) __swab16s((x))
+#define __be16_to_cpus(x) __swab16s((x))
+#endif	// __constant_htonl
 
 #endif /* _RTL871X_BYTEORDER_H_ */
 
diff --git a/os/board/rtl8720e/src/component/wifi/driver/include/rtw_cmd.h b/os/board/rtl8720e/src/component/wifi/driver/include/rtw_cmd.h
deleted file mode 100644
index e55471c99..000000000
--- a/os/board/rtl8720e/src/component/wifi/driver/include/rtw_cmd.h
+++ /dev/null
@@ -1,900 +0,0 @@
-/******************************************************************************
- *
- * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of version 2 of the GNU General Public License as
- * published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
- * more details.
- *
- * You should have received a copy of the GNU General Public License along with
- * this program; if not, write to the Free Software Foundation, Inc.,
- * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
- *
- *
- ******************************************************************************/
-#ifndef __RTW_CMD_H_
-#define __RTW_CMD_H_
-
-#include <rtw_rf.h>
-
-#define C2H_MEM_SZ (16*1024)
-//#define CMD_DBG 0
-
-#ifndef CONFIG_RTL8711FW
-
-#include <ieee80211.h> // <ieee80211/ieee80211.h>
-#include <rom_ieee80211.h> // <ieee80211/ieee80211.h>
-
-#define FREE_CMDOBJ_SZ	128
-
-#define MAX_CMDSZ	1024
-#define MAX_RSPSZ	512
-#define MAX_EVTSZ	1024
-
-#define CMDBUFF_ALIGN_SZ 4
-
-struct cmd_obj {
-	_adapter *padapter;
-	u16	cmdcode;
-	u8	res;
-	u8	*parmbuf;
-	u32	cmdsz;
-	u32	parm_nobuf;
-	u8	*rsp;
-	u32	rspsz;
-	struct submit_ctx *sctx;
-	//_sema 	cmd_sem;
-	_list	list;
-};
-
-struct cmd_hdl_callback {
-	u32	cmd_code;
-	u8(*h2cfuns)(_adapter *padapter, struct cmd_obj *pcmd);
-	void (*callback)(_adapter  *padapter, struct cmd_obj *cmd);
-
-};
-
-
-/* cmd flags */
-enum {
-	RTW_CMDF_DIRECTLY = BIT0,
-	RTW_CMDF_WAIT_ACK = BIT1,
-};
-
-struct cmd_priv {
-	_queue	cmd_queue;
-	u8 	cmdthd_running;
-	_adapter *padapter;
-};
-
-#define init_h2fwcmd_w_parm_no_rsp(pcmd, pparm, code) \
-do {\
-	rtw_init_listhead(&pcmd->list);\
-	pcmd->cmdcode = code;\
-	pcmd->parmbuf = (u8 *)(pparm);\
-	pcmd->cmdsz = sizeof (*pparm);\
-	pcmd->parm_nobuf = 0;\
-	pcmd->rsp = NULL;\
-	pcmd->rspsz = 0;\
-} while(0)
-
-extern u32 rtw_enqueue_cmd(struct cmd_priv *pcmdpriv, struct cmd_obj *obj);
-extern struct cmd_obj *rtw_dequeue_cmd(struct cmd_priv *pcmdpriv);
-extern void rtw_free_cmd_obj(struct cmd_obj *pcmd);
-
-void rtw_cmd_resource_free(_adapter *padapter);
-u8 rtw_cmd_process(_adapter *padapter, void *task);
-
-extern void rtw_cmd_clr_isr(struct cmd_priv *pcmdpriv);
-
-#else	/* CONFIG_RTL8711FW */
-#include <ieee80211.h>
-#endif	/* CONFIG_RTL8711FW */
-
-enum LPS_CTRL_TYPE {
-	LPS_CTRL_SCAN = 0,
-	LPS_CTRL_JOINBSS = 1,
-	LPS_CTRL_CONNECT = 2,
-	LPS_CTRL_DISCONNECT = 3,
-	LPS_CTRL_SPECIAL_PACKET = 4,
-	LPS_CTRL_LEAVE = 5,
-	LPS_CTRL_DENY = 6,
-	LPS_CTRL_TRAFFIC_BUSY = 7,
-	LPS_CTRL_TX_TRAFFIC_LEAVE = 8,
-	LPS_CTRL_RX_TRAFFIC_LEAVE = 9,
-};
-
-enum RFINTFS {
-	SWSI,
-	HWSI,
-	HWPI,
-};
-
-/*
-Caller Mode: Infra, Ad-HoC(C)
-
-Notes: To enter USB suspend mode
-
-Command Mode
-
-*/
-struct usb_suspend_parm {
-	u32 action;// 1: sleep, 0:resume
-};
-
-/*
-Caller Mode: Infra, Ad-HoC
-
-Notes: To join a known BSS.
-
-Command-Event Mode
-
-*/
-
-/*
-Caller Mode: Infra, Ad-Hoc
-
-Notes: To join the specified bss
-
-Command Event Mode
-
-*/
-struct joinbss_parm {
-	WLAN_BSSID_EX network;
-};
-
-/*
-Caller Mode: Infra, Ad-HoC(C)
-
-Notes: To disconnect the current associated BSS
-
-Command Mode
-
-*/
-struct disconnect_parm {
-	u32 rsvd;
-};
-
-/*
-Caller Mode: AP, Ad-HoC(M)
-
-Notes: To create a BSS
-
-Command Mode
-*/
-struct createbss_parm {
-	WLAN_BSSID_EX network;
-
-	/* used by AP/Mesh mode now */
-	u8 ifbmp;
-	u8 excl_ifbmp;
-	s16 req_ch;
-	s8 req_bw;
-	s8 req_offset;
-};
-
-/*
-Caller Mode: AP, Ad-HoC, Infra
-
-Notes: To set the NIC mode of RTL8711
-
-Command Mode
-
-The definition of mode:
-
-#define IW_MODE_AUTO	0	// Let the driver decides which AP to join
-#define IW_MODE_ADHOC	1	// Single cell network (Ad-Hoc Clients)
-#define IW_MODE_INFRA	2	// Multi cell network, roaming, ..
-#define IW_MODE_MASTER	3	// Synchronisation master or Access Point
-#define IW_MODE_REPEAT	4	// Wireless Repeater (forwarder)
-#define IW_MODE_SECOND	5	// Secondary master/repeater (backup)
-#define IW_MODE_MONITOR	6	// Passive monitor (listen only)
-
-*/
-struct	setopmode_parm {
-	u8	mode;
-	u8	rsvd[3];
-};
-
-/*
-Caller Mode: AP, Ad-HoC, Infra
-
-Notes: To ask RTL8711 performing site-survey
-
-Command-Event Mode
-
-*/
-
-#define RTW_SSID_SCAN_AMOUNT 1 //Reduce ssid scan amount due to memory limitation - Alex Fang
-#define RTW_CHANNEL_SCAN_AMOUNT (14+37)
-
-struct sitesurvey_parm {
-	sint scan_mode;	//active: 1, passive: 0
-	//sint bsslimit;	// 1 ~ 48
-	// for up to 9 probreq with specific ssid
-	NDIS_802_11_SSID ssid[RTW_SSID_SCAN_AMOUNT];
-	u8 ssid_num;
-#if  defined(CONFIG_IEEE80211K) || defined(CONFIG_RTW_WNM)
-	struct rtw_ieee80211_channel ch[RTW_CHANNEL_SCAN_AMOUNT];
-	u8 ch_num;
-	u32 token; 	/* 80211k use it to identify caller */
-	u16 duration;	/* 0: use default, otherwise: channel scan time */
-#endif
-};
-
-/*
-Caller Mode: Any
-
-Notes: To set the auth type of RTL8711. open/shared/802.1x
-
-Command Mode
-
-*/
-struct setauth_parm {
-	u8 mode;  //0: legacy open, 1: legacy shared 2: 802.1x
-	u8 _1x;   //0: PSK, 1: TLS
-	u8 rsvd[2];
-};
-
-/*
-Caller Mode: Infra
-
-a. algorithm: wep40, wep104, tkip & aes
-b. keytype: grp key/unicast key
-c. key contents
-
-when shared key ==> keyid is the camid
-when 802.1x ==> keyid [0:1] ==> grp key
-when 802.1x ==> keyid > 2 ==> unicast key
-
-*/
-struct setkey_parm {
-	u8	algorithm;	// encryption algorithm, could be none, wep40, TKIP, CCMP, wep104
-	u8	keyid;
-	u8 	grpkey;		// 1: this is the grpkey for 802.1x. 0: this is the unicast key for 802.1x
-	u8 	set_tx;		// 1: main tx key for wep. 0: other key.
-	u8	key[16];	// this could be 40 or 104
-};
-
-/*
-When in AP or Ad-Hoc mode, this is used to
-allocate an sw/hw entry for a newly associated sta.
-
-Command
-
-when shared key ==> algorithm/keyid
-
-*/
-struct set_stakey_parm {
-	u8	addr[ETH_ALEN];
-	u8	algorithm;
-	u8 	id;// currently for erasing cam entry if algorithm == _NO_PRIVACY_
-	u8	key[16];
-};
-
-struct set_stakey_rsp {
-	u8	addr[ETH_ALEN];
-	u8	keyid;
-	u8	rsvd;
-};
-
-/*
-Caller Ad-Hoc/AP
-
-Command -Rsp(AID == CAMID) mode
-
-This is to force fw to add an sta_data entry per driver's request.
-
-FW will write an cam entry associated with it.
-
-*/
-struct set_assocsta_parm {
-	u8	addr[ETH_ALEN];
-};
-
-struct set_assocsta_rsp {
-	u8	cam_id;
-	u8	rsvd[3];
-};
-
-/*
-	Caller Ad-Hoc/AP
-
-	Command mode
-
-	This is to force fw to del an sta_data entry per driver's request
-
-	FW will invalidate the cam entry associated with it.
-
-*/
-struct del_assocsta_parm {
-	u8  	addr[ETH_ALEN];
-};
-
-/*
-Caller Mode: AP/Ad-HoC(M)
-
-Notes: To notify fw that given staid has changed its power state
-
-Command Mode
-
-*/
-struct setstapwrstate_parm {
-	u8	staid;
-	u8	status;
-	u8	hwaddr[6];
-};
-
-/*
-Caller Mode: Any
-
-Notes: To setup the basic rate of RTL8711
-
-Command Mode
-
-*/
-struct	setbasicrate_parm {
-	u8	basicrates[NumRates];
-};
-
-/*
-Caller Mode: Any
-
-Notes: To read the current basic rate
-
-Command-Rsp Mode
-
-*/
-struct getbasicrate_parm {
-	u32 rsvd;
-};
-
-struct getbasicrate_rsp {
-	u8 basicrates[NumRates];
-};
-
-/*
-Caller Mode: Any
-
-Notes: To setup the data rate of RTL8711
-
-Command Mode
-
-*/
-struct setdatarate_parm {
-#ifdef MP_FIRMWARE_OFFLOAD
-	u32	curr_rateidx;
-#else
-	u8	mac_id;
-	u8	datarates[NumRates];
-#endif
-};
-
-/*
-Caller Mode: Any
-
-Notes: To read the current data rate
-
-Command-Rsp Mode
-
-*/
-struct getdatarate_parm {
-	u32 rsvd;
-
-};
-struct getdatarate_rsp {
-	u8 datarates[NumRates];
-};
-
-
-/*
-Caller Mode: Any
-AP: AP can use the info for the contents of beacon frame
-Infra: STA can use the info when sitesurveying
-Ad-HoC(M): Like AP
-Ad-HoC(C): Like STA
-
-
-Notes: To set the phy capability of the NIC
-
-Command Mode
-
-*/
-
-struct	setphyinfo_parm {
-	struct regulatory_class class_sets[NUM_REGULATORYS];
-	u8	status;
-};
-
-struct	getphyinfo_parm {
-	u32 rsvd;
-};
-
-struct	getphyinfo_rsp {
-	struct regulatory_class class_sets[NUM_REGULATORYS];
-	u8	status;
-};
-
-/*
-Caller Mode: Any
-
-Notes: To set the channel/modem/band
-This command will be used when channel/modem/band is changed.
-
-Command Mode
-
-*/
-struct	setphy_parm {
-	u8	rfchannel;
-	u8	modem;
-};
-
-/*
-Caller Mode: Any
-
-Notes: To get the current setting of channel/modem/band
-
-Command-Rsp Mode
-
-*/
-struct	getphy_parm {
-	u32 rsvd;
-
-};
-struct	getphy_rsp {
-	u8	rfchannel;
-	u8	modem;
-};
-
-struct readBB_parm {
-	u8	offset;
-};
-struct readBB_rsp {
-	u8	value;
-};
-
-struct readTSSI_parm {
-	u8	offset;
-};
-struct readTSSI_rsp {
-	u8	value;
-};
-
-struct writeBB_parm {
-	u8	offset;
-	u8	value;
-};
-
-struct readRF_parm {
-	u8	offset;
-};
-struct readRF_rsp {
-	u32	value;
-};
-
-struct writeRF_parm {
-	u32	offset;
-	u32	value;
-};
-
-struct getrfintfs_parm {
-	u8	rfintfs;
-};
-
-
-struct Tx_Beacon_param {
-	WLAN_BSSID_EX network;
-};
-
-/*
-	Notes: This command is used for H2C/C2H loopback testing
-
-	mac[0] == 0
-	==> CMD mode, return H2C_SUCCESS.
-	The following condition must be ture under CMD mode
-		mac[1] == mac[4], mac[2] == mac[3], mac[0]=mac[5]= 0;
-		s0 == 0x1234, s1 == 0xabcd, w0 == 0x78563412, w1 == 0x5aa5def7;
-		s2 == (b1 << 8 | b0);
-
-	mac[0] == 1
-	==> CMD_RSP mode, return H2C_SUCCESS_RSP
-
-	The rsp layout shall be:
-	rsp: 			parm:
-		mac[0]  =   mac[5];
-		mac[1]  =   mac[4];
-		mac[2]  =   mac[3];
-		mac[3]  =   mac[2];
-		mac[4]  =   mac[1];
-		mac[5]  =   mac[0];
-		s0		=   s1;
-		s1		=   swap16(s0);
-		w0		=  	swap32(w1);
-		b0		= 	b1
-		s2		= 	s0 + s1
-		b1		= 	b0
-		w1		=	w0
-
-	mac[0] == 	2
-	==> CMD_EVENT mode, return 	H2C_SUCCESS
-	The event layout shall be:
-	event:			parm:
-		mac[0]  =   mac[5];
-		mac[1]  =   mac[4];
-		mac[2]  =   event's sequence number, starting from 1 to parm's marc[3]
-		mac[3]  =   mac[2];
-		mac[4]  =   mac[1];
-		mac[5]  =   mac[0];
-		s0		=   swap16(s0) - event.mac[2];
-		s1		=   s1 + event.mac[2];
-		w0		=  	swap32(w0);
-		b0		= 	b1
-		s2		= 	s0 + event.mac[2]
-		b1		= 	b0
-		w1		=	swap32(w1) - event.mac[2];
-
-		parm->mac[3] is the total event counts that host requested.
-
-
-	event will be the same with the cmd's param.
-
-*/
-
-// CMD param Formart for driver extra cmd handler
-struct drvextra_cmd_parm {
-	int ec_id; //extra cmd id
-	int type; /* Can use this field as the type id or command size */
-	int size; /* buffer size */
-	unsigned char *pbuf;
-};
-
-/*------------------- Below are used for RF/BB tunning ---------------------*/
-
-struct	setantenna_parm {
-	u8	tx_antset;
-	u8	rx_antset;
-	u8	tx_antenna;
-	u8	rx_antenna;
-};
-
-struct	enrateadaptive_parm {
-	u32	en;
-};
-
-struct settxagctbl_parm {
-	u32	txagc[MAX_RATES_LENGTH];
-};
-
-struct gettxagctbl_parm {
-	u32 rsvd;
-};
-struct gettxagctbl_rsp {
-	u32	txagc[MAX_RATES_LENGTH];
-};
-
-struct setagcctrl_parm {
-	u32	agcctrl;		// 0: pure hw, 1: fw
-};
-
-
-struct setssup_parm	{
-	u32	ss_ForceUp[MAX_RATES_LENGTH];
-};
-
-struct getssup_parm	{
-	u32 rsvd;
-};
-struct getssup_rsp	{
-	u8	ss_ForceUp[MAX_RATES_LENGTH];
-};
-
-
-struct setssdlevel_parm	{
-	u8	ss_DLevel[MAX_RATES_LENGTH];
-};
-
-struct getssdlevel_parm	{
-	u32 rsvd;
-};
-struct getssdlevel_rsp	{
-	u8	ss_DLevel[MAX_RATES_LENGTH];
-};
-
-struct setssulevel_parm	{
-	u8	ss_ULevel[MAX_RATES_LENGTH];
-};
-
-struct getssulevel_parm	{
-	u32 rsvd;
-};
-struct getssulevel_rsp	{
-	u8	ss_ULevel[MAX_RATES_LENGTH];
-};
-
-
-struct	setcountjudge_parm {
-	u8	count_judge[MAX_RATES_LENGTH];
-};
-
-struct	getcountjudge_parm {
-	u32 rsvd;
-};
-struct	getcountjudge_rsp {
-	u8	count_judge[MAX_RATES_LENGTH];
-};
-
-
-struct setratable_parm {
-	u8 ss_ForceUp[NumRates];
-	u8 ss_ULevel[NumRates];
-	u8 ss_DLevel[NumRates];
-	u8 count_judge[NumRates];
-};
-
-struct getratable_parm {
-	uint rsvd;
-};
-struct getratable_rsp {
-	u8 ss_ForceUp[NumRates];
-	u8 ss_ULevel[NumRates];
-	u8 ss_DLevel[NumRates];
-	u8 count_judge[NumRates];
-};
-
-
-//to get TX,RX retry count
-struct gettxretrycnt_parm {
-	unsigned int rsvd;
-};
-struct gettxretrycnt_rsp {
-	unsigned long tx_retrycnt;
-};
-
-struct getrxretrycnt_parm {
-	unsigned int rsvd;
-};
-struct getrxretrycnt_rsp {
-	unsigned long rx_retrycnt;
-};
-
-//to get BCNOK,BCNERR count
-struct getbcnokcnt_parm {
-	unsigned int rsvd;
-};
-struct getbcnokcnt_rsp {
-	unsigned long  bcnokcnt;
-};
-
-struct getbcnerrcnt_parm {
-	unsigned int rsvd;
-};
-struct getbcnerrcnt_rsp {
-	unsigned long bcnerrcnt;
-};
-
-// to get current TX power level
-struct getcurtxpwrlevel_parm {
-	unsigned int rsvd;
-};
-struct getcurtxpwrlevel_rsp {
-	unsigned short tx_power;
-};
-
-struct addBaReq_parm {
-	unsigned int tid;
-	u8	addr[ETH_ALEN];
-};
-
-/*H2C Handler index: 46 */
-struct SetChannel_parm {
-	u32 curr_ch;
-};
-
-#ifdef MP_FIRMWARE_OFFLOAD
-/*H2C Handler index: 47 */
-struct SetTxPower_parm {
-	u8 TxPower;
-};
-
-/*H2C Handler index: 48 */
-struct SwitchAntenna_parm {
-	u16 antenna_tx;
-	u16 antenna_rx;
-//	R_ANTENNA_SELECT_CCK cck_txrx;
-	u8 cck_txrx;
-};
-
-/*H2C Handler index: 49 */
-struct SetCrystalCap_parm {
-	u32 curr_crystalcap;
-};
-
-/*H2C Handler index: 50 */
-struct SetSingleCarrierTx_parm {
-	u8 bStart;
-};
-
-/*H2C Handler index: 51 */
-struct SetSingleToneTx_parm {
-	u8 bStart;
-	u8 curr_rfpath;
-};
-
-/*H2C Handler index: 52 */
-struct SetCarrierSuppressionTx_parm {
-	u8 bStart;
-	u32 curr_rateidx;
-};
-
-/*H2C Handler index: 53 */
-struct SetContinuousTx_parm {
-	u8 bStart;
-	u8 CCK_flag; /*1:CCK 2:OFDM*/
-	u32 curr_rateidx;
-};
-
-/*H2C Handler index: 54 */
-struct SwitchBandwidth_parm {
-	u8 curr_bandwidth;
-};
-
-#endif	/* MP_FIRMWARE_OFFLOAD */
-
-/*H2C Handler index: 62 */
-struct TDLSoption_param {
-	u8 addr[ETH_ALEN];
-	u8 option;
-};
-
-
-/*
-Result:
-0x00: success
-0x01: sucess, and check Response.
-0x02: cmd ignored due to duplicated sequcne number
-0x03: cmd dropped due to invalid cmd code
-0x04: reserved.
-
-*/
-
-#define H2C_RSP_OFFSET			512
-
-#define H2C_SUCCESS			0x00
-#define H2C_SUCCESS_RSP			0x01
-#define H2C_DUPLICATED			0x02
-#define H2C_DROPPED			0x03
-#define H2C_PARAMETERS_ERROR		0x04
-#define H2C_REJECTED			0x05
-#define H2C_CMD_OVERFLOW		0x06
-#define H2C_RESERVED			0x07
-
-#define REQ_CH_NONE		-1
-#define REQ_BW_NONE		-1
-#define REQ_BW_ORI		-2
-#define REQ_OFFSET_NONE	-1
-
-extern u8 rtw_setassocsta_cmd(_adapter  *padapter, u8 *mac_addr);
-extern u8 rtw_setstandby_cmd(_adapter *padapter, uint action);
-extern u8 rtw_scan_start_cmd(_adapter  *padapter, struct sitesurvey_parm *pparm);
-extern u8 rtw_createbss_cmd(_adapter  *padapter);
-extern u8 rtw_createbss_cmd_ex(_adapter  *padapter, unsigned char *pbss, unsigned int sz);
-extern u8 rtw_setphy_cmd(_adapter  *padapter, u8 modem, u8 ch);
-extern u8 rtw_setstakey_cmd(_adapter  *padapter, u8 *psta, u8 unicast_key);
-extern u8 rtw_clearstakey_cmd(_adapter *padapter, u8 *psta, u8 entry);
-extern u8 rtw_joinbss_cmd(_adapter  *padapter, struct wlan_network *pnetwork);
-extern u8 rtw_disassoc_cmd(_adapter  *padapter);
-extern u8 rtw_setdatarate_cmd(_adapter  *padapter, u8 *rateset);
-extern u8 rtw_setbasicrate_cmd(_adapter  *padapter, u8 *rateset);
-extern u8 rtw_setbbreg_cmd(_adapter *padapter, u8 offset, u8 val);
-extern u8 rtw_setrfreg_cmd(_adapter *padapter, u8 offset, u32 val);
-extern u8 rtw_getbbreg_cmd(_adapter *padapter, u8 offset, u8 *pval);
-extern u8 rtw_getrfreg_cmd(_adapter *padapter, u8 offset, u8 *pval);
-extern u8 rtw_setrfintfs_cmd(_adapter  *padapter, u8 mode);
-extern u8 rtw_setrttbl_cmd(_adapter  *padapter, struct setratable_parm *prate_table);
-extern u8 rtw_getrttbl_cmd(_adapter  *padapter, struct getratable_rsp *pval);
-
-extern u8 rtw_gettssi_cmd(_adapter  *padapter, u8 offset, u8 *pval);
-extern u8 rtw_setfwdig_cmd(_adapter *padapter, u8 type);
-extern u8 rtw_setfwra_cmd(_adapter *padapter, u8 type);
-
-extern u8 rtw_addbareq_cmd(_adapter *padapter, u8 tid, u8 *addr);
-
-extern u8 rtw_dynamic_chk_wk_hdl(_adapter *padapter,  struct cmd_obj *cmd_obj);
-extern u8 rtw_dynamic_chk_wk_cmd(_adapter *adapter);
-
-extern u8 rtw_lps_ctrl_wk_hdl(_adapter *padapter, struct cmd_obj *cmd_obj);
-u8 rtw_lps_ctrl_wk_cmd(_adapter *padapter, u8 lps_ctrl_type, u8 enqueue);
-
-#ifdef CONFIG_ANTENNA_DIVERSITY
-extern  u8 rtw_antenna_select_cmd(_adapter *padapter, u8 antenna);
-#endif
-
-extern u8 rtw_ps_wk_hdl(_adapter *padapter, struct cmd_obj *cmd_obj);
-extern u8 rtw_ps_cmd(_adapter *padapter);
-
-extern u8 rtw_set_chplan(u8 chplan);
-u8 rtw_rm_post_event_hdl(_adapter *padapter, struct cmd_obj *cmd_obj);
-
-u8 createbss_hdl(_adapter *padapter, u8 *pbuf);
-u8 join_cmd_hdl(_adapter *padapter, struct cmd_obj *cmd_obj);
-u8 disconnect_hdl(_adapter *padapter, struct cmd_obj *cmd_obj);
-u8 rtw_scan_cmd_hdl(_adapter *padapter,  struct cmd_obj *cmd_obj);
-u8 setkey_hdl(_adapter *padapter,  struct cmd_obj *cmd_obj);
-u8 set_stakey_hdl(_adapter *padapter,  struct cmd_obj *cmd_obj);
-u8 add_ba_hdl(_adapter *padapter, struct cmd_obj *cmd_obj);
-u8 tx_beacon_hdl(_adapter *padapter,  struct cmd_obj *cmd_obj);
-u8 rtw_joinbss_event_callback(_adapter *adapter, struct cmd_obj *cmd_obj);
-u8 rtw_stassoc_event_callback(_adapter *adapter, struct cmd_obj *cmd_obj);
-u8 rtw_stadel_event_callback(_adapter *adapter, struct cmd_obj *cmd_obj);
-#if defined(CONFIG_IEEE80211W)
-u8 rtw_sta_timeout_event_callback(_adapter *adapter, struct cmd_obj *cmd_obj);
-#endif /* CONFIG_IEEE80211W */
-u8 rtw_free_stainfo_hdl(_adapter *padapter, struct cmd_obj *cmd_obj);
-u8  rtw_hal_c2h_handler(_adapter *padapter, u8 id, u8 seq, u8 plen, u8 *payload);
-
-extern void rtw_scan_cmd_callback(_adapter  *padapter, struct cmd_obj *pcmd);
-extern void rtw_disassoc_cmd_callback(_adapter  *padapter, struct cmd_obj *pcmd);
-extern void rtw_joinbss_cmd_callback(_adapter  *padapter, struct cmd_obj *pcmd);
-extern void rtw_createbss_cmd_callback(_adapter  *padapter, struct cmd_obj *pcmd);
-extern void rtw_getbbrfreg_cmdrsp_callback(_adapter  *padapter, struct cmd_obj *pcmd);
-extern void rtw_readtssi_cmdrsp_callback(_adapter	*padapter,  struct cmd_obj *pcmd);
-
-extern void rtw_setstaKey_cmdrsp_callback(_adapter  *padapter,  struct cmd_obj *pcmd);
-extern void rtw_setassocsta_cmdrsp_callback(_adapter  *padapter,  struct cmd_obj *pcmd);
-extern void rtw_getrttbl_cmdrsp_callback(_adapter  *padapter,  struct cmd_obj *pcmd);
-extern void rtw_set_channel_plan_cmd_callback(_adapter	*padapter,  struct cmd_obj *pcmd);
-
-enum rtw_h2c_cmd {
-	_JoinBss_CMD_,   /*0*/
-	_DisConnect_CMD_,
-	_SiteSurvey_CMD_,
-	_SetKey_CMD_,	/*5*/
-	_SetStaKey_CMD_,
-	_AddBAReq_CMD_,
-	_TX_Beacon_CMD_,
-	_RM_POST_EVENT_CMD_,
-	_FREE_STA_INFO_CMD_,
-	_JoinBSSRes_CMD_, /*16*/
-	_AddSTA_CMD_,
-	_DelSTA_CMD_,
-#ifdef CONFIG_IEEE80211W
-	_TimeoutSTA_CMD_,
-#endif
-	_Dynamic_Chk_CMD_,
-	_PowerSaveCtrl_CMD_,/*IPS,AUTOSuspend*/
-	_LPSCtrl_CMD_,
-	MAX_H2CCMD
-};
-
-
-#ifdef _RTW_CMD_C_
-const struct cmd_hdl_callback wlancmds[] = {
-	{_JoinBss_CMD_, join_cmd_hdl, &rtw_joinbss_cmd_callback}, /*0*/
-	{_DisConnect_CMD_, disconnect_hdl, &rtw_disassoc_cmd_callback},
-	{_SiteSurvey_CMD_, rtw_scan_cmd_hdl, &rtw_scan_cmd_callback},
-	{_SetKey_CMD_, setkey_hdl, NULL},  /*5*/
-	{_SetStaKey_CMD_, set_stakey_hdl, &rtw_setstaKey_cmdrsp_callback},
-	{_AddBAReq_CMD_, add_ba_hdl, NULL},
-	{_TX_Beacon_CMD_, tx_beacon_hdl, NULL},
-	{_RM_POST_EVENT_CMD_, rtw_rm_post_event_hdl, NULL},
-	{_FREE_STA_INFO_CMD_, rtw_free_stainfo_hdl, NULL},
-	{_JoinBSSRes_CMD_, rtw_joinbss_event_callback, NULL}, /*16*/
-	{_AddSTA_CMD_, rtw_stassoc_event_callback, NULL},
-	{_DelSTA_CMD_, rtw_stadel_event_callback, NULL},
-#if defined(CONFIG_IEEE80211W)
-	{_TimeoutSTA_CMD_, rtw_sta_timeout_event_callback, NULL},
-#endif /* CONFIG_IEEE80211W */
-	{_Dynamic_Chk_CMD_, rtw_dynamic_chk_wk_hdl, NULL},
-	{_PowerSaveCtrl_CMD_, rtw_ps_wk_hdl, NULL},
-	{_LPSCtrl_CMD_, rtw_lps_ctrl_wk_hdl, NULL},
-};
-
-#endif
-
-#endif // _CMD_H_
-
diff --git a/os/board/rtl8720e/src/component/wifi/driver/include/rtw_core_function.h b/os/board/rtl8720e/src/component/wifi/driver/include/rtw_core_function.h
new file mode 100755
index 000000000..95cea11b7
--- /dev/null
+++ b/os/board/rtl8720e/src/component/wifi/driver/include/rtw_core_function.h
@@ -0,0 +1,808 @@
+#ifndef _RTW_CORE_FUNCTION_H_
+#define _RTW_CORE_FUNCTION_H_
+#ifdef _RTW_ADAPTER_DEFINED_H_
+
+/*-------------------------------------------------------------------------------
+	rtw_recv.c.
+--------------------------------------------------------------------------------*/
+sint rtw_recv_init_priv(struct recv_priv *precvpriv, _adapter *padapter);
+void rtw_recv_free_priv(struct recv_priv *precvpriv);
+union recv_frame *rtw_recv_alloc_frame(_queue *pfree_recv_queue);
+int rtw_recv_free_frame(union recv_frame *precvframe, _queue *pfree_recv_queue);
+void rtw_recv_free_frame_queue(_queue *pframequeue,  _queue *pfree_recv_queue);
+u32 rtw_recv_free_uc_swdec_pending_queue(_adapter *padapter);
+void rtw_recv_free_defrag_queue(PADAPTER padapter, struct sta_info *psta);
+int rtw_recv_tkip_countermeasure(_adapter *padapter);
+sint rtw_recv_frame_chkmic(_adapter *padapter,  union recv_frame *precvframe);
+sint rtw_recv_frame_chkpn(_adapter *padapter,  union recv_frame *precvframe);
+sint rtw_recv_frame_chk_frag_pn(_adapter *padapter,  union recv_frame *precvframe, u8 fragnum);
+union recv_frame *rtw_recv_frame_chk_plaintext(_adapter *padapter, union recv_frame *precv_frame);
+union recv_frame *rtw_recv_frame_defrag(_adapter *padapter, _queue *defrag_q);
+union recv_frame *rtw_recv_frame_chk_defrag(PADAPTER padapter, union recv_frame *precv_frame);
+union recv_frame *rtw_recv_decryptor(_adapter *padapter, union recv_frame *precv_frame);
+void rtw_recv_count_rx_stats(_adapter *padapter, union recv_frame *prframe, struct sta_info *sta);
+sint rtw_recv_sta2sta_data_frame(_adapter *padapter, union recv_frame *precv_frame, struct sta_info **psta);
+sint rtw_recv_ap2sta_data_frame(_adapter *padapter, union recv_frame *precv_frame, struct sta_info **psta);
+sint rtw_recv_sta2ap_data_frame(_adapter *padapter, union recv_frame *precv_frame, struct sta_info **psta);
+void rtw_recv_validate_ctrl_frame(_adapter *padapter, union recv_frame *precv_frame);
+void rtw_recv_validate_mgnt_frame(PADAPTER padapter, union recv_frame **pprecv_frame);
+sint rtw_recv_validate_data_frame(_adapter *padapter, union recv_frame *precv_frame);
+sint rtw_recv_validate_frame(_adapter *padapter, union recv_frame **pprecv_frame);
+sint rtw_recv_wlanhdr_to_ethhdr(union recv_frame *precvframe);
+int rtw_recv_amsdu_to_msdu(_adapter *padapter, union recv_frame *prframe);
+int rtw_recv_enqueue_reorder_recvframe(struct recv_reorder_ctrl *preorder_ctrl, union recv_frame *prframe);
+int rtw_recv_indicatepkt(_adapter *padapter, union recv_frame *precv_frame);
+int rtw_recv_indicatepkt_in_order(_adapter *padapter, struct recv_reorder_ctrl *preorder_ctrl, int bforced);
+int rtw_recv_indicatepkt_reorder(_adapter *padapter, union recv_frame *prframe);
+int rtw_recv_process_indicatepkts(_adapter *padapter, union recv_frame *prframe);
+int rtw_recv_func_prehandle(_adapter *padapter, union recv_frame *rframe);
+int rtw_recv_func_posthandle(_adapter *padapter, union recv_frame *prframe);
+s32 rtw_recv_entry(union recv_frame *precvframe);
+void rtw_recv_reordering_ctrl_timer_hdl(void *FunctionContext);
+void rtw_recv_signal_stat_timer_hdl(void *FunctionContext);
+u8 *rtw_recv_get_recvframe_data(union recv_frame *precvframe);
+u8 *rtw_recv_recvframe_pull(union recv_frame *precvframe, sint sz);
+u8 *rtw_recv_recvframe_put(union recv_frame *precvframe, sint sz);
+u8 *rtw_recv_recvframe_pull_tail(union recv_frame *precvframe, sint sz);
+
+/*-------------------------------------------------------------------------------
+	rtw_xmit.c.
+--------------------------------------------------------------------------------*/
+s32	rtw_xmit_priv_init(struct xmit_priv *pxmitpriv, _adapter *padapter);
+void rtw_xmit_priv_free(struct xmit_priv *pxmitpriv);
+void rtw_xmit_open_pktfile(struct sk_buff *pktptr, struct pkt_file *pfile);
+uint rtw_xmit_read_pktfile(struct pkt_file *pfile, u8 *rmem, uint rlen);
+s32 rtw_xmit_enc_tkip_addmic(_adapter *padapter, struct xmit_frame *pxmitframe);
+#ifdef SW_ENCRYPT_HTC_PKT
+u32 rtw_xmit_enc_aes_use_ipsec(u8 *pframe, u32 wlan_hdr_len, u32 payload_len, u8 *key, u32 frame_type);
+#endif
+s32 rtw_xmit_enc_software(_adapter *padapter, struct xmit_frame *pxmitframe);
+s32 rtw_xmit_make_wlanhdr(_adapter *padapter, u8 *hdr, struct pkt_attrib *pattrib);
+int rtw_xmit_raw_frame(_adapter *padapter, raw_data_desc_t *raw_data_desc);
+s32 rtw_xmit_pending_queue_check(_adapter *padapter, int prio);
+void rtw_xmit_update_attrib_vcs_info(_adapter *padapter, struct xmit_frame *pxmitframe);
+s32 rtw_xmit_put_snap(u8 *data, u16 h_proto);
+void rtw_xmit_count_stats(PADAPTER padapter, struct xmit_frame *pxmitframe, int sz);
+s32 rtw_xmit_classifier(_adapter *padapter, struct xmit_frame *pxmitframe);
+int rtw_xmit_mgntframe(_adapter *padapter, struct xmit_frame *pmgntframe);
+int rtw_xmit_entry(struct sk_buff *pkt, struct net_device *pnetdev);
+u8	rtw_xmit_query_short_GI(struct sta_info *psta, u8 bw);
+void rtw_xmit_nulldata(_adapter *padapter, unsigned int power_mode);
+void rtw_xmit_qos_nulldata(_adapter *padapter, unsigned char *da, u16 tid);
+s32 rtw_txframes_pending(_adapter *padapter);
+
+
+/*-------------------------------------------------------------------------------
+	rtw_xmitbuff.c.
+--------------------------------------------------------------------------------*/
+struct xmit_frame *rtw_xmitframe_alloc(_adapter *padapter);
+s32 rtw_xmitframe_free(struct xmit_priv *pxmitpriv, struct xmit_frame *pxmitframe);
+void rtw_xmitframe_queue_free(struct xmit_priv *pxmitpriv, _queue *pframequeue);
+s32 rtw_xmitframe_enqueue_one(_adapter *padapter, struct xmit_frame *pxmitframe);
+struct xmit_frame *rtw_xmitframe_dequeue_one(struct xmit_priv *pxmitpriv, int *qcnt, _queue *pframe_queue);
+struct xmit_buf *rtw_xmitbuf_alloc(struct xmit_priv *pxmitpriv);
+s32 rtw_xmitbuf_free(struct xmit_priv *pxmitpriv, struct xmit_buf *pxmitbuf);
+struct xmit_buf *rtw_xmitbuf_ext_alloc(struct xmit_priv *pxmitpriv, u32 size);
+s32 rtw_xmitbuf_ext_free(struct xmit_priv *pxmitpriv, struct xmit_buf *pxmitbuf);
+BOOLEAN rtw_xmitbuf_enqueue(IN  struct rtw_tx_ring	*ring, IN  struct xmit_buf *pxmitbuf);
+struct xmit_buf *rtw_xmitbuf_dequeue(IN  struct rtw_tx_ring	*ring);
+
+/*-------------------------------------------------------------------------------
+	rtw_shortcut.c.
+--------------------------------------------------------------------------------*/
+#ifdef RX_SHORTCUT
+int rtw_recv_get_rx_sc_index(ADAPTER *padapter, unsigned char *hdr);
+int rtw_recv_get_rx_sc_free_entry(ADAPTER *padapter, unsigned char *hdr);
+int rtw_recv_indicatepkt_sc(_adapter *padapter, union recv_frame *precv_frame, int idx);
+int rtw_recv_check_rx_shortcut_path(_adapter *padapter, union recv_frame *precv_frame);
+#endif // RX_SHORTCUT
+#ifdef TX_SHORTCUT
+int rtw_get_tx_sc_index(struct sta_info *pstat, unsigned char *hdr);
+int rtw_get_tx_sc_free_entry(struct sta_info *pstat, unsigned char *hdr);
+s32 rtw_xmit_entry_sc(_adapter *padapter, struct sk_buff *pkt);
+#endif
+
+/*-------------------------------------------------------------------------------
+	rtw_sta_mgt.c.
+--------------------------------------------------------------------------------*/
+void _rtw_init_stainfo(struct sta_info *psta);
+void _rtw_defrag_timer_handler(void *FunctionContext);
+void init_defrag_queue_timer(_adapter *padapter, struct sta_info *psta);
+struct	sta_info *rtw_alloc_stainfo(struct sta_priv *pstapriv, u8 *hwaddr);
+u32 rtw_free_stainfo(_adapter *padapter, struct sta_info *psta);
+u8 rtw_free_stainfo_hdl(_adapter *padapter, struct cmd_obj *cmd_obj);
+u32 rtw_free_stainfo_enqueue_cmd(_adapter *padapter, struct sta_info *psta);
+struct sta_info *rtw_get_stainfo(struct sta_priv *pstapriv, u8 *hwaddr);
+struct sta_info *rtw_get_bcmc_stainfo(_adapter *padapter);
+void rtw_free_all_stainfo(_adapter *padapter);
+void rtw_update_sta_info(_adapter *padapter, struct sta_info *psta);
+u32 rtw_init_bcmc_stainfo(_adapter *padapter);
+struct recv_reorder_ctrl *rtw_alloc_reorder_ctrl(_adapter *padapter);
+void rtw_free_reorder_ctrl(_adapter *padapter, struct sta_info *psta, u8 tid);
+void _rtw_sta_del_event_callback(_adapter *padapter);
+u8 rtw_sta_del_event_callback(_adapter *padapter, struct cmd_obj *cmd_obj);
+void rtw_sta_del_event(_adapter *padapter, unsigned char *MacAddr, unsigned short reason);
+
+/*-------------------------------------------------------------------------------
+	rtw_task.c.
+--------------------------------------------------------------------------------*/
+int rtw_if_wifi_create_task(struct task_struct *ptask, const char *name, u32  stack_size, u32 priority, thread_func_t func, void *thctx);
+void rtw_if_wifi_delete_task(struct task_struct *ptask);
+void rtw_if_wifi_wakeup_task(struct task_struct *ptask);
+
+/*-------------------------------------------------------------------------------
+	rtw_sitesurvey.c.
+--------------------------------------------------------------------------------*/
+void rtw_scan_report_free_remaining_node(struct mlme_priv *pmlmepriv);
+int rtw_scan_start_api(rtw_scan_param_t *scan_param, unsigned char block);
+u8 rtw_scan_start_cmd(_adapter  *padapter, struct sitesurvey_parm *pparm);
+u8 rtw_scan_cmd_hdl(_adapter *padapter, struct cmd_obj *cmd_obj);
+void rtw_scan_cmd_callback(_adapter	*padapter,  struct cmd_obj *pcmd);
+void rtw_scan_one_channel(_adapter *padapter);
+int rtw_scan_report_node_process(_adapter *padapter, rtw_scan_report_node_t *new_node);
+int rtw_scan_report_node_sort_and_insert(_adapter *padapter, rtw_scan_report_node_t *new_node);
+int rtw_scan_report_one_node(_adapter *padapter, WLAN_BSSID_EX *bssid);
+#ifdef CONFIG_MBSSID_AX
+u8 rtw_scan_mbssid_bssid_convert(u8 trans_bssid_b5, u8 idx, u8 n);
+void rtw_scan_mbssid_parse(WLAN_BSSID_EX *bssid);
+#endif
+u8 rtw_scan_collect_bss_info(_adapter *padapter, union recv_frame *precv_frame, WLAN_BSSID_EX *bssid);
+void rtw_scan_one_beacon_report(_adapter *padapter, union recv_frame *precv_frame);
+void rtw_scan_done_user_callback(_adapter	*padapter);
+void rtw_scan_one_channel_done(_adapter *padapter);
+void rtw_scan_timeout_handler(void *FunctionContext);
+void rtw_scan_timer_hdl(void *FunctionContext);
+
+/*-------------------------------------------------------------------------------
+	rtw_join.c.
+--------------------------------------------------------------------------------*/
+void rtw_joinbss_timer_hdl(void *FunctionContext);
+sint rtw_joinbss_linked_check(_adapter *padapter);
+void rtw_joinbss_chk_done_concurrent(_adapter *padapter, int join_res);
+void rtw_leavebss_indicate(_adapter *padapter);
+void rtw_joinbss_assoc_timer_hdl(void *FunctionContext);
+void rtw_joinbss_done_indicate(_adapter *padapter);
+void rtw_joinbss_result_callback(_adapter *padapter, int join_res);
+void rtw_joinbss_result(_adapter *padapter, int res);
+void rtw_joinbss_cmd_callback(_adapter	*padapter,  struct cmd_obj *pcmd);
+u8 rtw_joinbss_cmd_hdl(_adapter *padapter, struct cmd_obj *cmd_obj);
+u8 rtw_joinbss_cmd(_adapter  *padapter, struct wlan_network *ptgt_network);
+int rtw_joinbss_from_scanned_queue(struct mlme_priv *pmlmepriv);
+u8 rtw_joinbss_start(_adapter *padapter);
+u8 _rtw_joinbss_set_bssid(_adapter *padapter, u8 *bssid);
+int rtw_joinbss_set_bssid(unsigned char wlan_idx, __u8 *bssid);
+u8 _rtw_joinbss_set_ssid(_adapter *padapter, NDIS_802_11_SSID *ssid);
+int rtw_joinbss_set_ssid(__u8 *ssid, __u16 ssid_len);
+int rtw_bss_set_auth(unsigned char wlan_idx, __u32 value);
+int rtw_bss_set_enc(unsigned char wlan_idx, __u16 alg, __u8 *addr, int key_idx, int set_tx, __u8 *seq, __u16 seq_len, __u8 *key, __u16 key_len);
+int rtw_bss_set_passphrase(unsigned char wlan_idx, __u8 *passphrase, __u16 passphrase_len);
+int rtw_joinbss_start_api(rtw_network_info_t *connect_param);
+void rtw_leavebss_status_update(_adapter *padapter);
+u8 rtw_leavebss_cmd_hdl(_adapter *padapter, struct cmd_obj *cmd_obj);
+unsigned int rtw_leavebss_start(_adapter *padapter, unsigned char *MacAddr, unsigned short reason);
+void rtw_leavebss_event_indicate(_adapter *padapter);
+
+/*-------------------------------------------------------------------------------
+	rtw_probe.c.
+--------------------------------------------------------------------------------*/
+void rtw_issue_probersp(_adapter *padapter, unsigned char *da, u8 is_valid_p2p_probereq);
+void rtw_issue_probereq(_adapter *padapter, NDIS_802_11_SSID *pssid, u8 blnbc);
+unsigned int rtw_on_probereq(_adapter *padapter, union recv_frame *precv_frame);
+unsigned int rtw_on_probersp(_adapter *padapter, union recv_frame *precv_frame);
+
+/*-------------------------------------------------------------------------------
+	rtw_auth.c.
+--------------------------------------------------------------------------------*/
+void rtw_start_clnt_join(_adapter *padapter);
+void rtw_start_clnt_auth(_adapter *padapter);
+void rtw_issue_auth(_adapter *padapter, struct sta_info *psta, unsigned short status);
+void rtw_issue_deauth(_adapter *padapter, unsigned char *da, u32 reason);
+unsigned int rtw_on_auth(_adapter *padapter, union recv_frame *precv_frame);
+unsigned int rtw_on_auth_client(_adapter *padapter, union recv_frame *precv_frame);
+unsigned int rtw_on_deauth(_adapter *padapter, union recv_frame *precv_frame);
+
+/*-------------------------------------------------------------------------------
+	rtw_assoc.c.
+--------------------------------------------------------------------------------*/
+void rtw_start_clnt_assoc(_adapter *padapter);
+void rtw_issue_assocreq(_adapter *padapter, u8 is_reassoc);
+void rtw_issue_assocrsp(_adapter *padapter, unsigned short status, struct sta_info *pstat, int pkt_type);
+unsigned int rtw_on_assocreq(_adapter *padapter, union recv_frame *precv_frame);
+void rtw_on_assocrsp_wmm(_adapter *padapter);
+unsigned int rtw_on_assocrsp(_adapter *padapter, union recv_frame *precv_frame);
+unsigned int rtw_on_disassoc(_adapter *padapter, union recv_frame *precv_frame);
+int rtw_assoc_set_wpa_ie(_adapter *padapter, char *pie, unsigned short ielen);
+u8 rtw_disassoc_cmd(_adapter *padapter);
+void rtw_assoc_resources_free(_adapter *padapter, int lock_scanned_queue);
+
+/*-------------------------------------------------------------------------------
+	rtw_setkey.c.
+--------------------------------------------------------------------------------*/
+sint rtw_setkey_to_cam(_adapter *padapter, struct security_priv *psecuritypriv, sint keyid, u8 set_tx);
+void rtw_setkey_cmd_callback(_adapter *padapter,  struct cmd_obj *pcmd);
+u8 rtw_setkey_clear_stakey(_adapter *padapter, u8 *psta, u8 entry);
+u8 rtw_setkey_set_stakey(_adapter *padapter, u8 *psta, u8 unicast_key);
+u8 rtw_setkey_cmd_hdl(_adapter *padapter, struct cmd_obj *cmd_obj);
+void rtw_setkey_remove_ptk(_adapter *padapter, struct sta_info *psta);
+void rtw_setkey_set_ptk(_adapter *padapter, struct sta_info *psta);
+void rtw_setkey_set_gtk(_adapter *padapter);
+void rtw_setkey_set_igtk(_adapter *padapter);
+
+/*-------------------------------------------------------------------------------
+	rtw_psk.c.
+--------------------------------------------------------------------------------*/
+void rtw_psk_sta_wait_4way_msg(_adapter *padapter, struct sta_info *psta);
+void rtw_psk_sta_send_eapol(_adapter *padapter, struct sta_info *psta, int resend);
+void rtw_psk_sta_eapolkey_recvd(_adapter *padapter, struct sta_info *psta);
+void rtw_psk_ap_send_eapol(_adapter *padapter, struct sta_info *psta, int resend);
+void rtw_psk_ap_eapolkey_recvd(_adapter *padapter, struct sta_info *psta);
+void rtw_psk_init(_adapter *padapter, unsigned char *pie, unsigned short ielen);
+void rtw_psk_init_wpa_sta_info(_adapter *padapter, struct sta_info *psta);
+int rtw_psk_tkip_send_mic_failure_report(_adapter *padapter, struct	sta_info *psta);
+
+/*-------------------------------------------------------------------------------
+	rtw_sae.c.
+--------------------------------------------------------------------------------*/
+#ifdef CONFIG_SAE_SUPPORT
+int rtw_sae_generate_commit_msg(struct sae_data *sae, u8 *own_addr, u8 *peer_addr, enum sae_group_config group_config);
+int rtw_sae_handle_auth(_adapter *padapter, struct sta_info *psta, struct sae_data *sae, u8 *own_addr, u8 *peer_addr,
+						u8 *sae_msg, u32 sae_msg_len, u16 seq_num, u16 status);
+struct sae_data *rtw_sae_allocate_instance(_adapter *padapter);
+void rtw_sae_free_instance(_adapter *padapter, const char *reason);
+#endif
+
+/*-------------------------------------------------------------------------------
+	rtw_wnm.c.
+--------------------------------------------------------------------------------*/
+#ifdef CONFIG_RTW_WNM
+u8 rtw_wmn_btm_rsp_reason_decision(_adapter *padapter, u8 *req_mode);
+u8 rtw_wnm_btm_reassoc_req(_adapter *padapter);
+void rtw_wnm_roam_scan_hdl(void *ctx);
+void rtw_wnm_disassoc_chk_hdl(void *ctx);
+u8 rtw_wnm_try_btm_roam_imnt(_adapter *padapter);
+void rtw_wnm_process_btm_req(_adapter *padapter, u8 *pframe, u32 frame_len);
+void rtw_wnm_reset_btm_candidate(struct roam_nb_info *pnb);
+void rtw_wnm_reset_btm_cache(_adapter *padapter);
+void rtw_wnm_reset_btm_state(_adapter *padapter);
+void rtw_wnm_issue_action(_adapter *padapter, u8 action, u8 reason, u8 dialog);
+#endif /* CONFIG_RTW_WNM */
+void wnm_dbg_cmd(_adapter *padapter, char *s);
+#if defined(CONFIG_RTW_WNM) || defined(CONFIG_IEEE80211K)
+void rtw_roam_nb_info_init(_adapter *padapter);
+void rtw_roam_nb_info_deinit(_adapter *padapter);
+void rtw_roam_nb_enable(_adapter *padapter);
+void rtw_roam_nb_disable(_adapter *padapter);
+void rtw_check_peer_btm_cap(_adapter *padapter, struct wlan_network *pcur_network);
+u8 rtw_roam_nb_scan_list_set(_adapter *padapter, struct sitesurvey_parm *pparm);
+u32 rtw_wnm_btm_candidates_survey(_adapter *padapter, u8 *pframe, u32 elem_len, u8 from_btm);
+void sitesurvey_res_reset(_adapter *padapter, struct sitesurvey_parm *pparm);
+#endif /*defined(CONFIG_RTW_WNM) || defined(CONFIG_IEEE80211K) */
+
+/*-------------------------------------------------------------------------------
+	rtw_autoreconnect.c.
+--------------------------------------------------------------------------------*/
+#if CONFIG_AUTO_RECONNECT
+void rtw_autoreconnect_psk_timeout(void *task_psta);
+void rtw_autoreconnect_thread(void *param);
+void rtw_autoreconnect_hdl(rtw_security_t security_type, char *ssid, int ssid_len, char *password, int password_len, int key_id);
+void rtw_autoreconnect_timer_hdl(void *FunctionContext);
+u8 rtw_autoreconnect_start(_adapter *padapter, bool continue_by, bool fixed_timeout);
+#endif
+
+/*-------------------------------------------------------------------------------
+	rtw_network.c.
+--------------------------------------------------------------------------------*/
+struct wlan_network *rtw_network_alloc(struct	mlme_priv *pmlmepriv);
+void rtw_network_queue_free(_adapter *dev);
+struct wlan_network *rtw_network_find(_queue *scanned_queue, u8 *addr);
+void rtw_network_update_for_scan(WLAN_BSSID_EX *dst, WLAN_BSSID_EX *src, _adapter *padapter, bool update_ie);
+void rtw_network_update_vcs(_adapter *padapter, u8 *ie, uint ie_len);
+void rtw_network_add_for_scan(_adapter *padapter, WLAN_BSSID_EX *target);
+int rtw_network_check_same(WLAN_BSSID_EX *src, WLAN_BSSID_EX *dst);
+
+/*-------------------------------------------------------------------------------
+	rtw_rm_fsm.c.
+--------------------------------------------------------------------------------*/
+#ifdef CONFIG_IEEE80211K
+static void rm_state_initial(struct rm_obj *prm);
+static void rm_state_goto(struct rm_obj *prm, enum RM_STATE rm_state);
+static void rm_state_run(struct rm_obj *prm, enum RM_EV_ID evid);
+static struct rm_event *rm_dequeue_ev(_queue *queue);
+static struct rm_obj *rm_dequeue_rm(_queue *queue);
+void rm_timer_callback(void *data);
+void rm_free_rmobj(struct rm_obj *prm);
+struct rm_obj *rm_alloc_rmobj(_adapter *padapter);
+int rm_enqueue_rmobj(_adapter *padapter, struct rm_obj *prm, bool to_head);
+struct sta_info *rm_get_psta(_adapter *padapter, u32 rmid);
+struct rm_obj *rm_get_rmobj(_adapter *padapter, u32 rmid);
+u8 rtw_rm_post_envent_cmd(_adapter *padapter, u32 rmid, u8 evid);
+u8 rtw_rm_post_event_hdl(_adapter *padapter, struct cmd_obj *cmd_obj);
+int rm_post_event(_adapter *padapter, u32 rmid, enum RM_EV_ID evid);
+int _rm_post_event(_adapter *padapter, u32 rmid, enum RM_EV_ID evid);
+void rm_handler(_adapter *padapter, struct rm_event *pe);
+char *rm_event_name(enum RM_EV_ID evid);
+void rtw_deinit_rm(_adapter *padapter);
+void rtw_rm_enable(_adapter *padapter);
+void rtw_rm_disable(_adapter *padapter);
+void rtw_check_peer_rm_cap(_adapter *padapter, struct wlan_network *pcur_network);
+#endif /* CONFIG_IEEE80211K */
+
+/*-------------------------------------------------------------------------------
+	rtw_rm_util.c.
+--------------------------------------------------------------------------------*/
+#ifdef CONFIG_IEEE80211K
+void rm_init_rtw_op_class(_adapter *padapter);
+u8 rm_set_rtw_op_class(u32 country_code);
+u8 rm_get_ch_set(struct rtw_ieee80211_channel *pch_set, u8 op_class, u8 ch_num);
+u8 rm_get_oper_class_via_ch(u8 ch);
+int is_wildcard_bssid(u8 *bssid);
+u8 translate_dbm_to_rcpi(s8 SignalPower);
+u8 translate_percentage_to_rcpi(u32 SignalStrengthIndex);
+u8 rm_get_bcn_rcpi(struct rm_obj *prm, struct wlan_network *pcur_network);
+u8 rm_get_frame_rsni(struct rm_obj *prm, union recv_frame *pframe);
+u8 rm_get_bcn_rsni(struct rm_obj *prm, struct wlan_network *pcur_network);
+int rm_get_tx_power(PADAPTER padapter, enum rf_path path, u8 rate, s8 *pwr);
+int rm_get_rx_sensitivity(PADAPTER padapter, enum channel_width bw, u8 rate, s8 *pwr);
+int rm_get_path_a_max_tx_power(_adapter *padapter, s8 *path_a);
+#endif /* CONFIG_IEEE80211K */
+
+/*-------------------------------------------------------------------------------
+	rtw_rm.c.
+--------------------------------------------------------------------------------*/
+#ifdef CONFIG_IEEE80211K
+char *rm_type_rep_name(u8 meas_type);
+int rm_en_cap_chk_and_set(struct rm_obj *prm, enum rm_cap_en en);
+/* for caller outside rm */
+u8 rm_add_nb_req(_adapter *padapter, struct sta_info *psta);
+void rm_set_rep_mode(struct rm_obj *prm, u8 mode);
+int issue_null_reply(struct rm_obj *prm);
+int ready_for_scan(struct rm_obj *prm);
+int rm_sitesurvey(struct rm_obj *prm);
+int rm_recv_radio_mens_req(_adapter *padapter, union recv_frame *precv_frame, struct sta_info *psta);
+int rm_recv_radio_mens_rep(_adapter *padapter, union recv_frame *precv_frame, struct sta_info *psta);
+int rm_recv_link_mens_req(_adapter *padapter, union recv_frame *precv_frame, struct sta_info *psta);
+int rm_recv_link_mens_rep(_adapter *padapter, union recv_frame *precv_frame, struct sta_info *psta);
+int rm_radio_mens_nb_rep(_adapter *padapter, union recv_frame *precv_frame, struct sta_info *psta);
+unsigned int onAction_rm(_adapter *padapter, union recv_frame *precv_frame);
+u8 rm_bcn_req_cond_mach(struct rm_obj *prm, struct wlan_network *pcur_network);
+int issue_beacon_rep(struct rm_obj *prm);
+/* neighbor request */
+int issue_nb_req(struct rm_obj *prm);
+/* issue link measurement request */
+int issue_link_meas_req(struct rm_obj *prm);
+/* issue link measurement report */
+int issue_link_meas_rep(struct rm_obj *prm);
+int issue_radio_meas_req(struct rm_obj *prm);
+int rm_radio_meas_report_cond(struct rm_obj *prm);
+int retrieve_radio_meas_result(struct rm_obj *prm);
+int issue_radio_meas_rep(struct rm_obj *prm);
+void RM_IE_handler(_adapter *padapter, PNDIS_802_11_VARIABLE_IEs pIE);
+#if defined(CONFIG_LAYER2_ROAMING)
+void rtw_roam_nb_discover(_adapter *padapter, u8 bfroce);
+#endif
+#if (RM_SUPPORT_IWPRIV_DBG)
+void rm_dbg_list_sta(_adapter *padapter, char *s);
+void rm_dbg_help(_adapter *padapter, char *s);
+struct sta_info *rm_get_sta(_adapter *padapter, u16 aid, u8 *pbssid);
+#endif /* RM_SUPPORT_IWPRIV_DBG */
+void rm_dbg_cmd(_adapter *padapter, char *s);
+#endif /* CONFIG_IEEE80211K */
+
+/*-------------------------------------------------------------------------------
+	rtw_dynamic.c.
+--------------------------------------------------------------------------------*/
+u8 rtw_dynamic_check_work_hdl(_adapter *padapter, struct cmd_obj *cmd_obj);
+u8 rtw_dynamic_check_work_cmd(_adapter *padapter);
+u8 rtw_dynamic_check_timer_hdl(_adapter *padapter);
+void rtw_dynamic_timer_hdl(void *FunctionContext);
+void rtw_dynamic_check_link_status(_adapter *padapter);
+
+/*-------------------------------------------------------------------------------
+	wifi_performance_monitor.c.
+--------------------------------------------------------------------------------*/
+#ifdef WIFI_PERFORMANCE_MONITOR
+u32 WIFI_PMTimer_GetCount(void);
+u32 WIFI_PMTimer_GetPassTime(u32 start);
+void wifi_performance_print();
+#endif //WIFI_PERFORMANCE_MONITOR
+#ifndef CONFIG_AS_INIC_AP
+u32 wifi_heap_size_printt(void);
+#endif
+
+/*-------------------------------------------------------------------------------
+	rtw_mgnt.c.
+--------------------------------------------------------------------------------*/
+void rtw_mgntframe_dispatcher(_adapter *padapter, union recv_frame *precv_frame);
+unsigned int rtw_mgntframe_do_reserved(_adapter *padapter, union recv_frame *precv_frame);
+struct xmit_frame *rtw_mgntframe_alloc(_adapter *padapter);
+void rtw_mgntframe_attrib_update(_adapter *padapter, struct pkt_attrib *pattrib);
+void rtw_mgntframe_indicate(_adapter *padapter, u8 *data, u16 len, u8 channel);
+s32 rtw_mgmt_xmitframe_coalesce(_adapter *padapter, struct sk_buff *pkt, struct xmit_frame *pxmitframe);
+
+/*-------------------------------------------------------------------------------
+	rtw_pmksa_cache.c.
+--------------------------------------------------------------------------------*/
+void rtw_pmksa_cache_entry_free(struct pmksa_cache_entry *pentry);
+int rtw_pmksa_cache_entry_add(struct pmksa_cache *ppmksa, u8 *pmk, u8 *pmkid, u8 *addr1, u32 akmp, u8 *encrypted_addr);
+struct pmksa_cache_entry *rtw_pmksa_cache_entry_remove(struct pmksa_cache *ppmksa, struct pmksa_cache_entry *pdelete);
+struct pmksa_cache_entry *rtw_pmksa_cache_entry_search(struct pmksa_cache *ppmksa, u8 *addr1, u32 akmp);
+void rtw_pmksa_cache_set_current_entry(struct pmksa_cache *ppmksa, struct pmksa_cache_entry *pentry);
+struct pmksa_cache_entry *rtw_pmksa_cache_get_current_entry(struct pmksa_cache *ppmksa);
+int rtw_pmksa_cache_init(_adapter *padapter);
+int rtw_pmksa_cache_deinit(_adapter *padapter);
+
+/*-------------------------------------------------------------------------------
+	rtw_ft.c.
+--------------------------------------------------------------------------------*/
+#ifdef CONFIG_IEEE80211R
+void rtw_ft_info_init(_adapter *padapter);
+void rtw_ft_info_deinit(_adapter *padapter);
+void rtw_ft_enable(_adapter *padapter);
+void rtw_ft_disable(_adapter *padapter);
+int rtw_ft_derive_ptk(_adapter *padapter);
+int rtw_ft_set_key(_adapter *padapter, struct sta_info *psta);
+int rtw_ft_validate_ie_eapol_3(_adapter *padapter, u8 *buf, u32 len);
+int rtw_ft_process_assoc_resp(_adapter *padapter, u8 *pframe, u32 frame_len);
+int rtw_ft_process_auth_resp(_adapter *padapter, u8 *pframe, u32 frame_len);
+int rtw_ft_chk_roaming_candidate(_adapter *padapter, struct wlan_network *competitor);
+void rtw_ft_validate_akm_type(_adapter  *padapter, struct wlan_network *pcur_network);
+void rtw_ft_build_eapol_2_ies(_adapter *padapter, OCTET_STRING *EapolKeyMsgSend);
+void rtw_ft_build_auth_req_ies(_adapter *padapter, struct pkt_attrib *pattrib, u8 **pframe);
+u8 rtw_ft_build_assoc_req_ies(_adapter *padapter, u8 is_reassoc, struct pkt_attrib *pattrib, u8 **pframe);
+void rtw_ft_issue_action_req(_adapter *padapter, u8 *pTargetAddr);
+void rtw_ft_start_roam(_adapter *padapter, u8 *pTargetAddr);
+void rtw_ft_link_timer_hdl(void *FunctionContext);
+void rtw_ft_roam_timer_hdl(void *FunctionContext);
+void rtw_ft_roam_status_reset(_adapter *padapter);
+void rtw_ft_start_clnt_join(_adapter *padapter);
+unsigned int OnAction_ft(_adapter *padapter, union recv_frame *precv_frame);
+void rtw_ft_dbg_cmd(_adapter *padapter, char *s);
+int rtw_ft_process_igtk_subelem(_adapter *padapter, const u8 *igtk_elem, u32 igtk_elem_len);
+#endif /* CONFIG_IEEE80211R */
+
+/*-------------------------------------------------------------------------------
+	rtw_he.c.
+--------------------------------------------------------------------------------*/
+#ifdef CONFIG_80211AX_HE
+void HE_caps_handler(_adapter *padapter, PNDIS_802_11_VARIABLE_IEs pIE);
+void HE_operation_update_asoc_cap(_adapter *padapter, PNDIS_802_11_VARIABLE_IEs pIE);
+void HE_operation_handler(_adapter *padapter, PNDIS_802_11_VARIABLE_IEs pIE, u8 update);
+void HE_mu_edca_handler(_adapter *padapter, PNDIS_802_11_VARIABLE_IEs pIE, u8 first);
+void HE_spatial_reuse_handler(_adapter *padapter, PNDIS_802_11_VARIABLE_IEs pIE, u8 first);
+void HE_phy_caps_update_asoc_cap(_adapter *padapter, struct rtw_phl_stainfo_t *phl_sta, u8 *ele_start);
+void HE_caps_update_asoc_cap(_adapter *padapter, u8 *pIE);
+u32 rtw_restructure_he_ie(_adapter *padapter, u8 *in_ie, u8 *out_ie, uint in_len, uint *pout_len);
+void rtw_he_fill_htc(u8 *phtc_buf);
+#endif
+
+/*-------------------------------------------------------------------------------
+	rtw_ht.c.
+--------------------------------------------------------------------------------*/
+void rtw_ht_caps_handler(_adapter *padapter, PNDIS_802_11_VARIABLE_IEs pIE);
+void rtw_ht_info_handler(_adapter *padapter, PNDIS_802_11_VARIABLE_IEs pIE);
+unsigned int rtw_restructure_ht_ie(_adapter *padapter, u8 *in_ie, u8 *out_ie, uint in_len, uint *pout_len);
+void rtw_update_ht_cap(_adapter *padapter, u8 *pie, uint ie_len);
+int rtw_ht_operation_update(_adapter *padapter);
+
+/*-------------------------------------------------------------------------------
+	rtw_vht.c.
+--------------------------------------------------------------------------------*/
+#ifdef CONFIG_80211AC_VHT
+void rtw_vht_use_default_setting(_adapter *padapter);
+void rtw_process_vht_op_mode_notify(_adapter *padapter, u8 *pframe, PVOID sta);
+u32	rtw_build_vht_op_mode_notify_ie(_adapter *padapter, u8 *pbuf, u8 bw);
+u32	rtw_build_vht_cap_ie(_adapter *padapter, u8 *pbuf);
+u32 rtw_restructure_vht_ie(_adapter *padapter, u8 *in_ie, u8 *out_ie, uint in_len, uint *pout_len);
+unsigned int rtw_on_action_vht(_adapter *padapter, union recv_frame *precv_frame);
+#endif /* CONFIG_80211AC_VHT */
+
+/*-------------------------------------------------------------------------------
+	rtw_ips.c.
+--------------------------------------------------------------------------------*/
+void ips_enter(_adapter *padapter);
+int ips_leave(_adapter *padapter);
+bool rtw_pwr_unassociated_idle(_adapter *padapter);
+void rtw_ps_processor(_adapter *padapter);
+u8 rtw_ps_wk_hdl(_adapter *padapter, struct cmd_obj *cmd_obj);
+u8 rtw_ps_cmd(_adapter *padapter);
+int rtw_pwr_wakeup(_adapter *padapter, u32 ips_deffer_ms);
+int rtw_pm_set_ips_enable(_adapter *padapter, u8 enable);
+
+/*-------------------------------------------------------------------------------
+	rtw_lps.c.
+--------------------------------------------------------------------------------*/
+void pwr_state_check_handler(void *FunctionContext);
+u8 PS_RDY_CHECK(_adapter *padapter);
+void rtw_set_ps_mode(PADAPTER padapter, u8 ps_mode, u8 smart_ps, u8 bcn_ant_mode);
+s32 LPS_RF_ON_check(PADAPTER padapter, u32 delay_ms);
+void LPS_Enter(PADAPTER padapter);
+void LPS_Leave(PADAPTER padapter);
+void LeaveAllPowerSaveMode(IN PADAPTER Adapter);
+void rtw_init_pwrctrl_priv(PADAPTER padapter);
+void rtw_free_pwrctrl_priv(PADAPTER padapter);
+int rtw_pm_set_lps_enable(_adapter *padapter, u8 enable);
+int rtw_pm_set_lps_level(_adapter *padapter, u8 level);
+u8 _lps_chk_by_tp(_adapter *padapter);
+u8 traffic_status_watchdog(_adapter *padapter);
+void _rtw_lps_ctrl_wk_hdl(_adapter *padapter, u8 lps_ctrl_type);
+u8 rtw_lps_ctrl_wk_cmd(_adapter *padapter, u8 lps_ctrl_type, u8 enqueue);
+u8 rtw_lps_ctrl_wk_hdl(_adapter *padapter, struct cmd_obj *cmd_obj);
+
+/*-------------------------------------------------------------------------------
+	rtw_twt.c.
+--------------------------------------------------------------------------------*/
+#ifdef CONFIG_TWT
+void rtw_twt_timer_enable(u8 idx, u8 port);
+void rtw_twt_set_early_time(u8 idx, u8 early_time);
+void rtw_twt_set_target_wake_time(u8 idx, u64 twt);
+void rtw_twt_get_tsf(u8 port, u64 *cur);
+unsigned int rtw_on_action_twt(_adapter *padapter, union recv_frame *precv_frame);
+void rtw_issue_action_twt(_adapter *padapter, u8 setup, struct twt_ie_t *twt_ie);
+#endif
+
+/*-------------------------------------------------------------------------------
+	rtw_layer2_rm.c.
+--------------------------------------------------------------------------------*/
+#ifdef CONFIG_LAYER2_ROAMING
+int is_same_ess(WLAN_BSSID_EX *a, WLAN_BSSID_EX *b);
+void rtw_set_to_roam(_adapter *padapter, u8 to_roam);
+u8 rtw_dec_to_roam(_adapter *padapter);
+u8 rtw_to_roam(_adapter *padapter);
+void rtw_roaming(_adapter *padapter, struct wlan_network *tgt_network);
+void _rtw_roaming(_adapter *padapter, struct wlan_network *tgt_network);
+void rtw_roaming_sitesurvey_again(_adapter *padapter);
+void rtw_start_roam(_adapter *padapter);
+void rtw_drv_scan_by_self(_adapter *padapter, u8 reason);
+int rtw_is_desired_network(_adapter *padapter, struct wlan_network *pcur_network_new);
+void rtw_roamimg_info_init(_adapter *padapter);
+int rtw_select_roaming_candidate(struct mlme_priv *mlme);
+#endif /* CONFIG_LAYER2_ROAMING */
+
+/*-------------------------------------------------------------------------------
+	rtw_ap.c.
+--------------------------------------------------------------------------------*/
+void init_mlme_ap_info(_adapter *padapter);
+void free_mlme_ap_info(_adapter *padapter);
+void ap_polling_sta_hdl(void *padapter);
+void expire_timeout_chk(_adapter *padapter);
+u8 rtw_createbss_hdl(_adapter *padapter, u8 *pbuf);
+void start_bss_network(_adapter *padapter, u8 *pbuf);
+u8 rtw_ap_add_sta_callback(_adapter *padapter, struct cmd_obj *cmd_obj);
+void rtw_ap_add_sta_event(_adapter *padapter, unsigned char *MacAddr, int cam_idx);
+void associated_clients_update(_adapter *padapter, u8 updated);
+void bss_cap_update_on_sta_join(_adapter *padapter, struct sta_info *psta);
+u8 bss_cap_update_on_sta_leave(_adapter *padapter, struct sta_info *psta);
+u8 ap_free_sta(_adapter *padapter, struct sta_info *psta, unsigned short reason);
+int rtw_sta_flush(_adapter *padapter);
+void sta_info_update(_adapter *padapter, struct sta_info *psta);
+int rtw_ap_start_api(rtw_softap_info_t *softAP_config, unsigned char value);
+
+/*-------------------------------------------------------------------------------
+	rtw_ap_xmit.c.
+--------------------------------------------------------------------------------*/
+sint rtw_ap_xmitframe_enqueue_for_sleeping_sta(_adapter *padapter, struct xmit_frame *pxmitframe);
+void rtw_ap_stop_sta_xmit(_adapter *padapter, struct sta_info *psta);
+void rtw_ap_wakeup_sta_to_xmit(_adapter *padapter, struct sta_info *psta);
+void rtw_ap_xmit_delivery_enabled_frames(_adapter *padapter, struct sta_info *psta);
+
+/*-------------------------------------------------------------------------------
+	rtw_beacon.c.
+--------------------------------------------------------------------------------*/
+void rtw_on_beacon_rate_check(_adapter *padapter, struct sta_info *psta, u8 *rate, u8 rate_len, u8 *MCS_rate);
+void rtw_on_beacon_info_update(_adapter *padapter, u8 *pframe, uint pkt_len, struct sta_info *psta);
+int rtw_on_beacon_info_check(ADAPTER *Adapter, u8 *pframe, u32 packet_len);
+unsigned int rtw_on_beacon(_adapter *padapter, union recv_frame *precv_frame);
+void rtw_get_bcn_info(struct wlan_network *pcur_network);
+void rtw_ap_issue_beacon(_adapter *padapter);
+int rtw_ap_set_beacon(_adapter *padapter, u8 *pbuf,  int len);
+int rtw_ap_generate_bcn_ie(_adapter *padapter, u8 *ssid, u16 ssid_len, u8 *ie, u32 max_ie_sz);
+void rtw_ap_update_beacon(_adapter *padapter, u8 ie_id, u8 *oui, u8 tx);
+u8 rtw_ap_tx_beacon_hdl(_adapter *padapter, struct cmd_obj *cmd_obj);
+u8 rtw_ap_set_tx_beacon_cmd(_adapter *padapter);
+
+/*-------------------------------------------------------------------------------
+	rtw_action.c.
+--------------------------------------------------------------------------------*/
+unsigned int rtw_on_action(_adapter *padapter, union recv_frame *precv_frame);
+unsigned int rtw_on_action_back(_adapter *padapter, union recv_frame *precv_frame);
+#ifdef CONFIG_RTW_WNM
+unsigned int rtw_on_action_wnm(_adapter *padapter, union recv_frame *precv_frame);
+#endif /* CONFIG_RTW_WNM */
+
+/*-------------------------------------------------------------------------------
+	rtw_addba.c.
+--------------------------------------------------------------------------------*/
+void rtw_on_addba_req(_adapter *padapter, u8 *paddba_req, u8 *addr);
+void rtw_issue_action_ba(_adapter *padapter, unsigned char *raddr, unsigned char action, unsigned short status);
+unsigned int rtw_send_delba(_adapter *padapter, u8 initiator, u8 *addr);
+u8 rtw_add_ba_hdl(_adapter *padapter, struct cmd_obj *cmd_obj);
+u8 rtw_addbareq_cmd(_adapter *padapter, u8 tid, u8 *addr);
+void rtw_issue_addbareq_cmd(_adapter *padapter, struct xmit_frame *pxmitframe);
+void rtw_addba_timer_hdl(void *FunctionContext);
+void rtw_init_addba_retry_timer(_adapter *padapter, struct sta_info *psta);
+
+/*-------------------------------------------------------------------------------
+	rtw_80211w.c.
+--------------------------------------------------------------------------------*/
+#ifdef CONFIG_IEEE80211W
+void rtw_dot11w_issue_action_sa_query(_adapter *padapter, unsigned char *raddr, unsigned char action, unsigned short tid, u8 key_type);
+unsigned int rtw_dot11w_on_action_sa_query(_adapter *padapter, union recv_frame *precv_frame);
+u8 rtw_dot11w_sta_timeout_event_callback(_adapter *padapter, struct cmd_obj *cmd_obj);
+void rtw_dot11w_sa_query_timer_hdl(void *FunctionContext);
+void rtw_dot11w_init_expire_timer(_adapter *padapter, struct sta_info *psta);
+u32	rtw_dot11w_BIP_verify(_adapter *padapter, u8 *precvframe);
+sint rtw_dot11w_validate_mgmt(_adapter *padapter, union recv_frame **pprecv_frame);
+#endif
+
+/*-------------------------------------------------------------------------------
+	rtw_cmd.c.
+--------------------------------------------------------------------------------*/
+int rtw_cmd_filter(struct cmd_priv *pcmdpriv, struct cmd_obj *cmd_obj);
+u32 rtw_enqueue_cmd(struct cmd_priv *pcmdpriv, struct cmd_obj *cmd_obj);
+struct	cmd_obj	*rtw_dequeue_cmd(struct cmd_priv *pcmdpriv);
+void rtw_free_cmd_obj(struct cmd_obj *pcmd);
+u8 rtw_cmd_process(_adapter *padapter, void *task);
+void rtw_cmd_resource_free(_adapter *padapter);
+
+/*-------------------------------------------------------------------------------
+	rtw_btcoex_soc.c.
+--------------------------------------------------------------------------------*/
+#ifdef CONFIG_BT_COEXIST_SOC
+void rtw_coex_run(_adapter *padapter);
+int rtw_coex_ble_scan_duty_update(_adapter *padapter, u8 duty);
+int rtw_coex_wifi_info_update(_adapter *padapter, u8 wifi_event);
+void rtw_coex_bt_info_update(_adapter *padapter, u8 *mailbox_data);
+sint rtw_enqueue_btmailbox(_queue *queue, struct mailbox_info *obj);
+struct mailbox_info *rtw_dequeue_btmailbox(_queue *queue);
+int rtw_coex_mailbox_to_wifi(_adapter *padapter, u8 *data, u8 len);
+thread_return rtw_coex_mailbox_thread(thread_context context);
+void rtw_coex_run_enable(_adapter *padapter, u8 enable);
+char rtw_coex_pcoex_init(void);
+void rtw_coex_pcoex_deinit(void);
+void rtw_coex_mailbox_check(_adapter *padapter, u8 enable);
+int rtw_coex_bt_enable(_adapter *padapter, u8 enable);
+void rtw_coex_wifi_enable(PADAPTER padapter, u8 enable);
+u16 rtw_coex_wifi_tdma_scan_start(PADAPTER padapter, RT_SCAN_TYPE scan_type);
+u16 rtw_coex_wifi_tdma_scan_handle(PADAPTER padapter);
+u8 rtw_coex_is_bt_disabled(PADAPTER padapter);
+#endif
+
+/*-------------------------------------------------------------------------------
+	rtw_dfs.c.
+--------------------------------------------------------------------------------*/
+void rtw_rfctl_init(_adapter *padapter);
+void rtw_rfctl_deinit(_adapter *padapter);
+u8 rtw_change_bss_chbw_cmd(_adapter *padapter, int flags, u8 ifbmp, u8 excl_ifbmp, s16 req_ch, s8 req_bw, s8 req_offset);
+void rtw_on_beacon_csa(_adapter *padapter, u8 *pframe, uint pkt_len);
+unsigned int rtw_on_action_csa(_adapter *padapter, union recv_frame *precv_frame);
+void rtw_csa_timer_hdl(void *FunctionContext);
+void rtw_csa_process(_adapter *padapter, u8 new_ch_no, u8 new_ch_count);
+void rtw_issue_action_csa(_adapter *padapter, unsigned char *da, unsigned char new_channel, unsigned char switch_mode, unsigned char switch_cnt);
+void rtw_ap_csa_update_timer_hdl(void *FunctionContext);
+
+/*-------------------------------------------------------------------------------
+	rtw_mp.c.
+--------------------------------------------------------------------------------*/
+#ifdef CONFIG_MP_INCLUDED
+u32 read_bbreg(_adapter *padapter, u32 addr, u32 bitmask);
+void write_bbreg(_adapter *padapter, u32 addr, u32 bitmask, u32 val);
+u32 _read_rfreg(PADAPTER padapter, u8 rfpath, u32 addr, u32 bitmask);
+void _write_rfreg(PADAPTER padapter, u8 rfpath, u32 addr, u32 bitmask, u32 val);
+u32 read_rfreg(PADAPTER padapter, u8 rfpath, u32 addr);
+void write_rfreg(PADAPTER padapter, u8 rfpath, u32 addr, u32 val);
+s32 init_mp_priv(PADAPTER padapter);
+VOID MPT_DeInitAdapter(IN PADAPTER	padapter);
+void MPT_PwrCtlDM(PADAPTER padapter, u32 bstart);
+s32 mp_start_test(PADAPTER padapter);
+void mp_stop_test(PADAPTER padapter);
+void SetBandwidth(PADAPTER padapter);
+void MP_PHY_SetRFPathSwitch(PADAPTER padapter, BOOLEAN bMain);
+void fill_txdesc_for_mp(PADAPTER padapter, struct tx_desc *ptxdesc);
+void SetPacketTx(PADAPTER padapter);
+void SetPacketRx(PADAPTER padapter, u8 bStartRx);
+#if (PHYDM_VERSION == 3)
+void mp_init_psd(PADAPTER padapter, struct rtw_point *wrqu);
+void mp_get_point_data_psd(PADAPTER padapter, struct rtw_point *wrqu);
+void mp_restore_psd(PADAPTER padapter, struct rtw_point *wrqu);
+#endif
+u8 MptToMgntRate(IN	u32 MptRateIdx);
+u8 MgntRateToMPTRate(u8 rate);
+u32 mpt_ProQueryCalTxPower(PADAPTER padapter, u8 RfPath);
+int rtfloor(float x);
+void ByteToBit(u8 *out, bool *in, u8	in_size);
+void CRC16_generator(bool *out, bool *in, u8 in_size);
+void CCK_generator(PRT_PMAC_TX_INFO pPMacTxInfo, PRT_PMAC_PKT_INFO pPMacPktInfo);
+u32 LDPC_parameter_generator(u32 N_pld_int, u32 N_CBPSS, u32 N_SS, u32 R, u32 m_STBC, u32 N_TCB_int);
+void PMAC_Nsym_generator(PRT_PMAC_TX_INFO pPMacTxInfo, PRT_PMAC_PKT_INFO pPMacPktInfo);
+void L_SIG_generator(u32 N_SYM, PRT_PMAC_TX_INFO pPMacTxInfo, PRT_PMAC_PKT_INFO pPMacPktInfo);
+void CRC8_generator(bool *out, bool *in, u8 in_size);
+void HT_SIG_generator(PRT_PMAC_TX_INFO pPMacTxInfo, PRT_PMAC_PKT_INFO pPMacPktInfo);
+void VHT_SIG_A_generator(PRT_PMAC_TX_INFO pPMacTxInfo, PRT_PMAC_PKT_INFO pPMacPktInfo);
+void VHT_SIG_B_generator(PRT_PMAC_TX_INFO pPMacTxInfo);
+void VHT_Delimiter_generator(PRT_PMAC_TX_INFO pPMacTxInfo);
+void mp_FA_statistics(PADAPTER	padapter);
+#endif // #ifdef CONFIG_MP_INCLUDED
+
+/*-------------------------------------------------------------------------------
+	rtw_promisc.c.
+--------------------------------------------------------------------------------*/
+#ifdef CONFIG_PROMISC
+void promisc_deinit(_adapter *padapter);
+int promisc_recv_func(_adapter *padapter, union recv_frame *rframe);
+int promisc_recv_lens_func(void *padapter, u8 *payload, u8 plen);
+int promisc_ctrl_packet_rpt(u8 enable);
+void promisc_filter_by_ap_and_phone_mac(u8 enable, void *ap_mac, void *phone_mac);
+#endif
+int promisc_set(rtw_rcr_level_t enabled, void (*callback)(unsigned char *, unsigned int, void *), unsigned char len_used);
+unsigned char is_promisc_enabled(void);
+int promisc_get_fixed_channel(void *fixed_bssid, u8 *ssid, int *ssid_length);
+void promisc_issue_probersp(unsigned char *da);
+void promisc_stop_tx_beacn(void);
+void promisc_resume_tx_beacn(void);
+void _promisc_deinit(_adapter *padapter);
+int _promisc_recv_func(_adapter *padapter, union recv_frame *rframe);
+#if defined(CONFIG_UNSUPPORT_PLCPHDR_RPT) && CONFIG_UNSUPPORT_PLCPHDR_RPT
+int _promisc_recv_lens_func(_adapter *padapter, u8 *payload, u8 plen);
+#endif
+
+/*-------------------------------------------------------------------------------
+	rtw_state.c.
+--------------------------------------------------------------------------------*/
+int rtw_check_sta_mode(_adapter *padapter);
+int rtw_check_ap_mode(_adapter *padapter);
+int rtw_check_sta_associated_to_ap(_adapter *padapter);
+int rtw_check_sta_linking(_adapter *padapter);
+void rtw_state_set_sitesurvey_doing(_adapter *padapter, u8 state);
+int rtw_check_under_sitesurvey(_adapter *padapter);
+void rtw_state_set_join_doing(_adapter *padapter);
+void rtw_state_set_auth_doing(_adapter *padapter);
+void rtw_state_set_assoc_doing(_adapter *padapter);
+void rtw_state_set_assoc_success(_adapter *padapter);
+int rtw_state_check_sta_no_link(_adapter *padapter);
+int rtw_state_check_sta_prepare_join(_adapter *padapter);
+int rtw_state_check_sta_auth_doing(_adapter *padapter);
+int rtw_state_check_sta_assoc_doing(_adapter *padapter);
+void rtw_state_reset(_adapter *padapter);
+void rtw_state_set_ap_beacon_on(_adapter *padapter, u8 state);
+int rtw_state_check_ap_on(_adapter *padapter);
+int rtw_check_ap_linked(_adapter *padapter);
+void rtw_state_set_ap_client_auth_ongoing(struct sta_info *psta);
+void rtw_state_set_ap_client_auth_success(struct sta_info *psta);
+void rtw_state_set_ap_client_assoc_success(struct sta_info *psta);
+void rtw_state_reset_ap_client_state(struct sta_info *psta);
+int rtw_state_check_ap_client_auth_ongoing(struct sta_info *psta);
+int rtw_state_check_ap_client_auth_success(struct sta_info *psta);
+int rtw_state_check_ap_client_assoc_success(struct sta_info *psta);
+
+/*-------------------------------------------------------------------------------
+	rtw_drv_init.c: for core, rtw_intf_inter.
+--------------------------------------------------------------------------------*/
+void rtw_cancel_all_timer(_adapter *padapter);
+u8 rtw_free_drv_sw(_adapter *padapter);
+u8 rtw_reset_drv_sw(_adapter *padapter);
+void rtw_init_drv_sw(_adapter *padapter);
+void rtw_reset_securitypriv(_adapter *padapter);
+u32 rtw_start_drv_threads(_adapter *padapter);
+void rtw_stop_drv_threads(_adapter *padapter);
+
+#endif // _RTW_ADAPTER_DEFINED_H_
+#endif // _RTW_CORE_FUNCTION_H_
+
+/*-------------------------------------------------------------------------------
+	rtw_skbuff.c: for core, inic and api. Place outside _RTW_CORE_FUNCTION_H_.
+--------------------------------------------------------------------------------*/
+void skb_reserve(struct sk_buff *skb, unsigned int len);
+void skb_assign_buf(struct sk_buff *skb, unsigned char *buf, unsigned int len);
+unsigned char *skb_tail_pointer(const struct sk_buff *skb);
+void skb_set_tail_pointer(struct sk_buff *skb, const int offset);
+unsigned char *skb_end_pointer(const struct sk_buff *skb);
+struct sk_buff *dev_alloc_skb(unsigned int length, unsigned int reserve_len);
+void kfree_skb(struct sk_buff *skb);
+struct sk_buff *skb_clone(struct sk_buff *skb, int gfp_mask);
+struct sk_buff *skb_copy(const struct sk_buff *skb, int gfp_mask, unsigned int reserve_len);
+void kfree_skb_chk_key(struct sk_buff *skb, struct net_device *root_dev);
+void init_skb_pool(void);
+void deinit_skb_pool(void);
+int skb_fail_get_and_rst(void);
+void skb_fail_inc(void);
+
diff --git a/os/board/rtl8720e/src/component/wifi/driver/include/rtw_debug.h b/os/board/rtl8720e/src/component/wifi/driver/include/rtw_debug.h
old mode 100644
new mode 100755
index 3a6cc63e1..f063faa58
--- a/os/board/rtl8720e/src/component/wifi/driver/include/rtw_debug.h
+++ b/os/board/rtl8720e/src/component/wifi/driver/include/rtw_debug.h
@@ -18,12 +18,9 @@
 
 
 /* add new definition of debug log level */
-#define RTW_MSG_OFF             1
 #define RTW_MSG_RESIDENT   2
 #define RTW_MSG_ERROR         3
 #define RTW_MSG_WARNING    4
-#define RTW_MSG_INFO            5
-#define RTW_MSG_DBG             6
 
 /* reserve definition for macro rom_e_rtw_msg_871X_LEVEL*/
 #define _drv_always_		1
diff --git a/os/board/rtl8720e/src/component/wifi/driver/include/rtw_dfs.h b/os/board/rtl8720e/src/component/wifi/driver/include/rtw_dfs.h
deleted file mode 100644
index 8fa5d8519..000000000
--- a/os/board/rtl8720e/src/component/wifi/driver/include/rtw_dfs.h
+++ /dev/null
@@ -1,42 +0,0 @@
-/******************************************************************************
- *
- * Copyright(c) 2007 - 2012 Realtek Corporation. All rights reserved.
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of version 2 of the GNU General Public License as
- * published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
- * more details.
- *
- * You should have received a copy of the GNU General Public License along with
- * this program; if not, write to the Free Software Foundation, Inc.,
- * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
- *
- *
- ******************************************************************************/
-#ifndef __RTW_DFS_H_
-#define __RTW_DFS_H_
-
-#define CAC_TIME_MS (60*1000)
-#define CAC_TIME_CE_MS (10*60*1000)
-#define NON_OCP_TIME_MS (30*60*1000)
-
-void rtw_rfctl_init(_adapter *adapter);
-void rtw_rfctl_deinit(_adapter *adapter);
-
-#define CH_IS_NON_OCP(rt_ch_info) 0
-#define rtw_chset_is_chbw_non_ocp(ch_set, ch, bw, offset) _FALSE
-#define rtw_chset_is_ch_non_ocp(ch_set, ch) _FALSE
-#define rtw_rfctl_is_tx_blocked_by_ch_waiting(rfctl) _FALSE
-
-#if (PHYDM_VERSION == 2)
-u8 rtw_odm_get_dfs_domain(_adapter *adapter);
-u8 rtw_odm_dfs_domain_unknown(_adapter *adapter);
-#endif
-bool rtw_adjust_chbw(_adapter *adapter, u8 req_ch, u8 *req_bw, u8 *req_offset);
-
-#endif
-
diff --git a/os/board/rtl8720e/src/component/wifi/driver/include/if_ether.h b/os/board/rtl8720e/src/component/wifi/driver/include/rtw_ethernet.h
old mode 100644
new mode 100755
similarity index 56%
rename from os/board/rtl8720e/src/component/wifi/driver/include/if_ether.h
rename to os/board/rtl8720e/src/component/wifi/driver/include/rtw_ethernet.h
index 8c4a73dab..20839f145
--- a/os/board/rtl8720e/src/component/wifi/driver/include/if_ether.h
+++ b/os/board/rtl8720e/src/component/wifi/driver/include/rtw_ethernet.h
@@ -17,9 +17,22 @@
  *
  *
  ******************************************************************************/
+/*! \file */
+#ifndef __RTW_ETHERNET_H
+#define __RTW_ETHERNET_H
 
-#ifndef _LINUX_IF_ETHER_H
-#define _LINUX_IF_ETHER_H
+#define LLC_HEADER_SIZE						6		//!< LLC Header Length
+#define MINIMUM_ETHERNET_PACKET_SIZE		60		//!< Minimum Ethernet Packet Size
+#define MAXIMUM_ETHERNET_PACKET_SIZE		1514	//!< Maximum Ethernet Packet Size
+
+#define RT_ETH_IS_MULTICAST(_pAddr)	((((u8 *)(_pAddr))[0]&0x01)!=0)		//!< Is Multicast Address?
+#define RT_ETH_IS_BROADCAST(_pAddr)	(										\
+											((u8 *)(_pAddr))[0]==0xff	&& 		\
+											((u8 *)(_pAddr))[1]==0xff	&&		\
+											((u8 *)(_pAddr))[2]==0xff	&&		\
+											((u8 *)(_pAddr))[3]==0xff	&&		\
+											((u8 *)(_pAddr))[4]==0xff	&&		\
+											((u8 *)(_pAddr))[5]==0xff		)	//!< Is Broadcast Address?
 
 /*
  *	IEEE 802.3 Ethernet magic constants.  The frame sizes omit the preamble
@@ -31,6 +44,8 @@
 #define ETH_ZLEN	60		/* Min. octets in frame sans FCS */
 #define ETH_DATA_LEN	1500		/* Max. octets in payload	 */
 #define ETH_FRAME_LEN	1514		/* Max. octets in frame sans FCS */
+#define ETH_TYPE_LEN		2
+#define ETH_ARPHRD		1	/* ethernet hardware format */
 
 /*
  *	These are the defined Ethernet Protocol ID's.
@@ -42,7 +57,7 @@
 #define ETH_P_IP	0x0800		/* Internet Protocol packet	*/
 #define ETH_P_X25	0x0805		/* CCITT X.25			*/
 #define ETH_P_ARP	0x0806		/* Address Resolution packet	*/
-#define	ETH_P_BPQ	0x08FF		/* G8BPQ AX.25 Ethernet Packet	[ NOT AN OFFICIALLY REGISTERED ID ] */
+#define ETH_P_BPQ	0x08FF		/* G8BPQ AX.25 Ethernet Packet	[ NOT AN OFFICIALLY REGISTERED ID ] */
 #define ETH_P_IEEEPUP	0x0a00		/* Xerox IEEE802.3 PUP packet */
 #define ETH_P_IEEEPUPAT	0x0a01		/* Xerox IEEE802.3 PUP Addr Trans packet */
 #define ETH_P_DEC       0x6000          /* DEC Assigned proto           */
@@ -89,25 +104,114 @@
 /*
  *	This is an Ethernet frame header.
  */
-RTW_PACK_STRUCT_BEGIN
 struct ethhdr {
 	unsigned char	h_dest[ETH_ALEN];	/* destination eth addr	*/
 	unsigned char	h_source[ETH_ALEN];	/* source ether addr	*/
 	unsigned short	h_proto;		/* packet type ID field	*/
-} RTW_PACK_STRUCT_STRUCT;
-RTW_PACK_STRUCT_END
+} _PACKED_;
 
 struct _vlan {
 	unsigned short       h_vlan_TCI;                // Encapsulates priority and VLAN ID
 	unsigned short       h_vlan_encapsulated_proto;
 };
 
+struct sockaddr_t {
+	__u8		sa_len;
+	__u8		sa_family;
+	char		sa_data[14];
+};
+
+/* IP options */
+#define IPOPT_COPY		0x80
+#define IPOPT_CLASS_MASK	0x60
+#define IPOPT_NUMBER_MASK	0x1f
+
+#define	IPOPT_COPIED(o)		((o)&IPOPT_COPY)
+#define	IPOPT_CLASS(o)		((o)&IPOPT_CLASS_MASK)
+#define	IPOPT_NUMBER(o)		((o)&IPOPT_NUMBER_MASK)
 
+#define	IPOPT_CONTROL		0x00
+#define	IPOPT_RESERVED1		0x20
+#define	IPOPT_MEASUREMENT	0x40
+#define	IPOPT_RESERVED2		0x60
 
-#define get_vlan_id(pvlan) ((_htons((unsigned short )pvlan->h_vlan_TCI)) & 0xfff)
-#define get_vlan_priority(pvlan) ((_htons((unsigned short )pvlan->h_vlan_TCI))>>13)
-#define get_vlan_encap_proto(pvlan) (_htons((unsigned short )pvlan->h_vlan_encapsulated_proto))
+#define IPOPT_END	(0 |IPOPT_CONTROL)
+#define IPOPT_NOOP	(1 |IPOPT_CONTROL)
+#define IPOPT_SEC	(2 |IPOPT_CONTROL|IPOPT_COPY)
+#define IPOPT_LSRR	(3 |IPOPT_CONTROL|IPOPT_COPY)
+#define IPOPT_TIMESTAMP	(4 |IPOPT_MEASUREMENT)
+#define IPOPT_RR	(7 |IPOPT_CONTROL)
+#define IPOPT_SID	(8 |IPOPT_CONTROL|IPOPT_COPY)
+#define IPOPT_SSRR	(9 |IPOPT_CONTROL|IPOPT_COPY)
+#define IPOPT_RA	(20|IPOPT_CONTROL|IPOPT_COPY)
+
+#define IPVERSION	4
+#define MAXTTL		255
+#define IPDEFTTL	64
+
+/* struct timestamp, struct route and MAX_ROUTES are removed.
+
+   REASONS: it is clear that nobody used them because:
+   - MAX_ROUTES value was wrong.
+   - "struct route" was wrong.
+   - "struct timestamp" had fatally misaligned bitfields and was completely unusable.
+ */
+
+#define IPOPT_OPTVAL 0
+#define IPOPT_OLEN   1
+#define IPOPT_OFFSET 2
+#define IPOPT_MINOFF 4
+#define MAX_IPOPTLEN 40
+#define IPOPT_NOP IPOPT_NOOP
+#define IPOPT_EOL IPOPT_END
+#define IPOPT_TS  IPOPT_TIMESTAMP
+
+#define	IPOPT_TS_TSONLY		0		/* timestamps only */
+#define	IPOPT_TS_TSANDADDR	1		/* timestamps and addresses */
+#define	IPOPT_TS_PRESPEC	3		/* specified modules only */
+
+struct iphdr {
+#if defined(__LITTLE_ENDIAN_BITFIELD)
+	__u8	ihl: 4,
+			version: 4;
+#elif defined (__BIG_ENDIAN_BITFIELD)
+	__u8	version: 4,
+			ihl: 4;
+#else
+#error	"Please fix <asm/byteorder.h>"
+#endif
+	__u8	tos;
+	__u16	tot_len;
+	__u16	id;
+	__u16	frag_off;
+	__u8	ttl;
+	__u8	protocol;
+	__u16	check;
+	__u32	saddr;
+	__u32	daddr;
+	/*The options start here. */
+};
+
+/**
+ *format of ipv6 header
+ * |<---4 --->|<---8----->|<------20------->|
+ * |--version--|-traffic class-|-----flow label-----|
+ * |<--16--->|<----8----->|<--- ----8------>|
+ * |--length --|--next header-|------hop limit----|
+ * |<----------------128-------------------->|
+ * |-----------------source addr---------------|
+ * |<-----------------128------------------->|
+ * |-----------------dest addr-----------------|
+ */
+struct ipv6_hdr {
+	__u32 	v_tc_fl;
+	__u16	payload_len;
+	__u8	next_header;
+	__u8	hop_limit;
+	__u32	saddr[4];
+	__u32	daddr[4];
+};
 
 
-#endif	/* _LINUX_IF_ETHER_H */
+#endif // #ifndef __RTW_ETHERNET_H
 
diff --git a/os/board/rtl8720e/src/component/wifi/driver/include/rtw_event.h b/os/board/rtl8720e/src/component/wifi/driver/include/rtw_event.h
deleted file mode 100644
index ceea62ccf..000000000
--- a/os/board/rtl8720e/src/component/wifi/driver/include/rtw_event.h
+++ /dev/null
@@ -1,62 +0,0 @@
-/******************************************************************************
- *
- * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of version 2 of the GNU General Public License as
- * published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
- * more details.
- *
- * You should have received a copy of the GNU General Public License along with
- * this program; if not, write to the Free Software Foundation, Inc.,
- * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
- *
- *
- ******************************************************************************/
-#ifndef _RTW_EVENT_H_
-#define _RTW_EVENT_H_
-
-/*
-Used to report the link result of joinning the given bss
-
-
-join_res:
--1: authentication fail
--2: association fail
-> 0: TID
-
-*/
-struct joinbss_event {
-	//struct	wlan_network	network;
-	int join_res;
-};
-
-/*
-Used to report a given STA has joinned the created BSS.
-It is used in AP/Ad-HoC(M) mode.
-
-
-*/
-struct stassoc_event {
-	unsigned char macaddr[6];
-	unsigned char rsvd[2];
-	int    cam_id;
-
-};
-
-struct stadel_event {
-	unsigned char macaddr[6];
-	unsigned char rsvd[2]; //for reason
-	int mac_id;
-};
-
-struct addba_event {
-	unsigned int tid;
-};
-
-#endif // _WLANEVENT_H_
-
diff --git a/os/board/rtl8720e/src/component/wifi/driver/include/rtw_ft.h b/os/board/rtl8720e/src/component/wifi/driver/include/rtw_ft.h
deleted file mode 100644
index 3e1c136b9..000000000
--- a/os/board/rtl8720e/src/component/wifi/driver/include/rtw_ft.h
+++ /dev/null
@@ -1,233 +0,0 @@
-#ifndef __RTW_FT_H_
-#define __RTW_FT_H_
-//#include <rtw_psk.h>
-//#include <rtw_mlme.h>
-
-enum rtw_ieee80211_ft_actioncode {
-	RTW_WLAN_ACTION_FT_RESV,
-	RTW_WLAN_ACTION_FT_REQ,
-	RTW_WLAN_ACTION_FT_RSP,
-	RTW_WLAN_ACTION_FT_CONF,
-	RTW_WLAN_ACTION_FT_ACK,
-	RTW_WLAN_ACTION_FT_MAX,
-};
-
-enum _rtw_ft_sta_status {
-	RTW_FT_UNASSOCIATED_STA = 0,
-	RTW_FT_AUTHENTICATING_STA,
-	RTW_FT_AUTHENTICATED_STA,
-	RTW_FT_ASSOCIATING_STA,
-	RTW_FT_ASSOCIATED_STA,
-	RTW_FT_REQUESTING_STA,
-	RTW_FT_REQUESTED_STA,
-	RTW_FT_CONFIRMED_STA,
-	RTW_FT_UNSPECIFIED_STA
-};
-
-enum rtw_ft_capability {
-	RTW_FT_EN = BIT(0),
-	RTW_FT_OTD_EN = BIT(1),
-	RTW_FT_PEER_EN = BIT(2),
-	RTW_FT_PEER_OTD_EN = BIT(3),
-};
-
-#define rtw_ft_chk_status(padapter, s) \
-	((padapter->pshare_adapter)->rmpriv->ft_info->ft_status == (s))
-
-#define rtw_ft_roam_status(a, s)	\
-	((rtw_to_roam(a) > 0) && rtw_ft_chk_status(a, s))
-
-#define rtw_ft_authed_sta(a)	\
-	((rtw_ft_chk_status(a, RTW_FT_AUTHENTICATED_STA)) ||	\
-	(rtw_ft_chk_status(a, RTW_FT_ASSOCIATING_STA)) ||	\
-	(rtw_ft_chk_status(a, RTW_FT_ASSOCIATED_STA)))
-
-#define rtw_ft_set_status(padapter, s) \
-	do { \
-		((padapter->pshare_adapter)->rmpriv->ft_info->ft_status = (s)); \
-	} while (0)
-
-#define rtw_ft_lock_set_status(padapter, s, irq) \
-	do { \
-		rtw_enter_critical_bh(&rtw_get_mlmepriv(a)->lock, ((_irqL *)(irq)));	\
-		((padapter->pshare_adapter)->rmpriv->ft_info->ft_status = (s));	\
-		rtw_exit_critical_bh(&rtw_get_mlmepriv(a)->lock, ((_irqL *)(irq)));	\
-	} while (0)
-
-#define rtw_ft_reset_status(padapter) \
-	do { \
-		((padapter->pshare_adapter)->rmpriv->ft_info->ft_status = RTW_FT_UNASSOCIATED_STA); \
-	} while (0)
-
-
-#define rtw_ft_chk_flags(padapter, f) \
-	((padapter->pshare_adapter)->rmpriv->ft_flags & (f))
-
-#define rtw_ft_set_flags(padapter, f) \
-	do { \
-		((padapter->pshare_adapter)->rmpriv->ft_flags |= (f)); \
-	} while (0)
-
-#define rtw_ft_clr_flags(padapter, f) \
-	do { \
-		((padapter->pshare_adapter)->rmpriv->ft_flags &= ~(f)); \
-	} while (0)
-
-#define rtw_ft_roam(a)	\
-	((rtw_to_roam(a) > 0) && rtw_ft_chk_flags(a, RTW_FT_PEER_EN))
-
-#define rtw_ft_valid_akm(a, t)	\
-	((rtw_ft_chk_flags(a, RTW_FT_EN)) && \
-	(((t) == WPA_KEY_MGMT_FT_IEEE8021X) || ((t) == WPA_KEY_MGMT_FT_PSK)))
-
-#define rtw_ft_otd_roam_en(padapter)	\
-	((rtw_ft_chk_flags(a, RTW_FT_OTD_EN))	\
-	&& ((padapter->pshare_adapter)->rmpriv->ft_info->ft_cap & 0x01))
-
-#define rtw_ft_otd_roam(a) \
-	(rtw_ft_chk_flags(a, RTW_FT_OTD_EN) && rtw_ft_chk_flags(a, RTW_FT_PEER_OTD_EN))
-
-#define rtw_ft_valid_otd_candidate(a, p)	\
-	((rtw_ft_chk_flags(a, RTW_FT_OTD_EN)) 	\
-	&& ((rtw_ft_chk_flags(a, RTW_FT_PEER_OTD_EN)	\
-	&& ((*((p)+4) & 0x01) == 0))	\
-	|| ((rtw_ft_chk_flags(a, RTW_FT_PEER_OTD_EN) == 0)	\
-	&& (*((p)+4) & 0x01))))
-
-#define FTIE_SUBELEM_R1KH_ID 1
-#define FTIE_SUBELEM_GTK 2
-#define FTIE_SUBELEM_R0KH_ID 3
-
-#define RTW_FT_ACTION_REQ_LMT	4
-#define RTW_FT_MAX_IE_SZ	256
-
-#define PMK_LEN_MAX 64
-#define MOBILITY_DOMAIN_ID_LEN 2
-#define FT_R0KH_ID_MAX_LEN 48
-#define FT_R1KH_ID_LEN 6
-#define WPA_PMK_NAME_LEN 16
-#define ASSOC_RESP_IE_MAX_LEN 256
-
-struct wpa_ie_data {
-	int proto;
-	int pairwise_cipher;
-	int has_pairwise;
-	int group_cipher;
-	int has_group;
-	int key_mgmt;
-	int capabilities;
-	u32 num_pmkid;
-	u8 *pmkid;
-	int mgmt_group_cipher;
-};
-
-struct ft_ie_parse {
-	u8 *mdie;
-	u32 mdie_len;
-	u8 *ftie;
-	u32 ftie_len;
-	u8 *r1kh_id;
-	u8 *gtk;
-	u32 gtk_len;
-	u8 *r0kh_id;
-	u32 r0kh_id_len;
-	u8 *rsn;
-	u32 rsn_len;
-	u8 *rsn_pmkid;
-	u8 *tie;
-	u32 tie_len;
-	u8 *igtk;
-	u32 igtk_len;
-	u8 *ric;
-	u32 ric_len;
-	int key_mgmt;
-	int pairwise_cipher;
-};
-
-struct ft_roam_info {
-	u16 mdid;
-	u8 ft_cap;
-	u8	assoc_resp_ies[RTW_FT_MAX_IE_SZ];/* MDIE FTIE from Association Response */
-	u32	assoc_resp_ies_len;
-	u32 ft_status;
-	u32 ft_req_retry_cnt;
-	u32 reassoc_deadline;
-	u32 key_lifetime;
-	u8 snonce[KEY_NONCE_LEN]; //snonce in ft auth/reassoc
-	u8 anonce[KEY_NONCE_LEN]; //anonce in ft auth/reassoc
-	u8 pmk_r0[PMK_LEN_MAX];
-	u32 pmk_r0_len;
-	u8 pmk_r0_name[WPA_PMK_NAME_LEN];
-	u8 pmk_r1[PMK_LEN_MAX];
-	u32 pmk_r1_len;
-	u8 pmk_r1_name[WPA_PMK_NAME_LEN];
-	u8	ptk[PTK_LEN_TKIP];
-	u8	gtk[GTK_LEN];
-	u8	gtk_keyid;
-	u8 r0kh_id[FT_R0KH_ID_MAX_LEN];
-	u32 r0kh_id_len;
-	u8 r1kh_id[FT_R1KH_ID_LEN];
-#ifdef CONFIG_IEEE80211W
-	u8	igtk[WPA_IGTK_MAX_LEN];
-	u32	igtk_len;
-	u32 igtk_keyid;
-#endif
-};
-
-struct ft_ftie {
-	u8 mic_control[2];
-	u8 mic[16];
-	u8 anonce[KEY_NONCE_LEN];
-	u8 snonce[KEY_NONCE_LEN];
-	/* followed by optional parameters */
-};
-
-struct ft_mdie {
-	u8 mobility_domain[MOBILITY_DOMAIN_ID_LEN];
-	u8 ft_capab;
-};
-
-struct ft_rdie {
-	u8 id;
-	u8 descr_count;
-	u16 status_code;
-};
-
-struct rsn_ie_hdr {
-	u8 elem_id; /* WLAN_EID_RSN */
-	u8 len;
-	u8 version[2]; /* little endian */
-};
-
-void rtw_ft_info_init(_adapter *padapter);
-
-void rtw_ft_info_deinit(_adapter *padapter);
-
-void rtw_ft_enable(_adapter *padapter);
-
-void rtw_ft_disable(_adapter *padapter);
-
-int rtw_ft_set_key(_adapter *padapter, struct sta_info *psta);
-
-int rtw_ft_chk_roaming_candidate(_adapter *padapter, struct wlan_network *competitor);
-
-void rtw_ft_validate_akm_type(_adapter  *padapter, struct wlan_network *pnetwork);
-
-void rtw_ft_start_clnt_join(_adapter *padapter);
-
-void rtw_ft_build_eapol_2_ies(_adapter *padapter, OCTET_STRING *EapolKeyMsgSend);
-
-void rtw_ft_build_auth_req_ies(_adapter *padapter, struct pkt_attrib *pattrib, u8 **pframe);
-
-u8 rtw_ft_build_assoc_req_ies(_adapter *padapter, u8 is_reassoc, struct pkt_attrib *pattrib, u8 **pframe);
-
-void rtw_ft_start_roam(_adapter *padapter, u8 *pTargetAddr);
-
-void rtw_ft_link_timer_hdl(void *FunctionContext);
-
-void rtw_ft_roam_timer_hdl(void *FunctionContext);
-
-void rtw_ft_roam_status_reset(_adapter *padapter);
-
-unsigned int OnAction_ft(_adapter *padapter, union recv_frame *precv_frame);
-#endif /* __RTW_FT_H_ */
diff --git a/os/board/rtl8720e/src/component/wifi/driver/include/rtw_intfs.h b/os/board/rtl8720e/src/component/wifi/driver/include/rtw_intfs.h
deleted file mode 100644
index 1b4847f43..000000000
--- a/os/board/rtl8720e/src/component/wifi/driver/include/rtw_intfs.h
+++ /dev/null
@@ -1,17 +0,0 @@
-#ifndef _RTW_INTFS_H_
-#define _RTW_INTFS_H_
-
-extern void rtw_init_default_value(_adapter *padapter);
-extern void rtw_cancel_all_timer(_adapter *padapter);
-
-extern void rtw_init_drv_sw(_adapter *padapter);
-extern u8 rtw_free_drv_sw(_adapter *padapter);
-extern u8 rtw_reset_drv_sw(_adapter *padapter);
-
-extern int rtw_drv_init(ADAPTER *padapter);
-extern void rtw_drv_deinit(ADAPTER *Adapter);
-
-extern u32 rtw_start_drv_threads(_adapter *padapter);
-extern void rtw_stop_drv_threads(_adapter *padapter);
-
-#endif //_RTW_INTFS_H_
diff --git a/os/board/rtl8720e/src/component/wifi/driver/include/rtw_io.h b/os/board/rtl8720e/src/component/wifi/driver/include/rtw_io.h
deleted file mode 100644
index 603f207cf..000000000
--- a/os/board/rtl8720e/src/component/wifi/driver/include/rtw_io.h
+++ /dev/null
@@ -1,32 +0,0 @@
-/******************************************************************************
- *
- * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of version 2 of the GNU General Public License as
- * published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
- * more details.
- *
- * You should have received a copy of the GNU General Public License along with
- * this program; if not, write to the Free Software Foundation, Inc.,
- * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
- *
- *
- ******************************************************************************/
-
-#ifndef _RTW_IO_H_
-#define _RTW_IO_H_
-
-extern u8 rtw_read8(ADAPTER *adapter, u32 addr);
-extern u16 rtw_read16(ADAPTER *adapter, u32 addr);
-extern u32 rtw_read32(ADAPTER *adapter, u32 addr);
-extern s32 rtw_write8(ADAPTER *adapter, u32 addr, u8 val);
-extern s32 rtw_write16(ADAPTER *adapter, u32 addr, u16 val);
-extern s32 rtw_write32(ADAPTER *adapter, u32 addr, u32 val);
-
-#endif	//_RTW_IO_H_
-
diff --git a/os/board/rtl8720e/src/component/wifi/driver/include/rtw_ioctl_set.h b/os/board/rtl8720e/src/component/wifi/driver/include/rtw_ioctl_set.h
deleted file mode 100644
index 002aba470..000000000
--- a/os/board/rtl8720e/src/component/wifi/driver/include/rtw_ioctl_set.h
+++ /dev/null
@@ -1,42 +0,0 @@
-/******************************************************************************
- *
- * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of version 2 of the GNU General Public License as
- * published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
- * more details.
- *
- * You should have received a copy of the GNU General Public License along with
- * this program; if not, write to the Free Software Foundation, Inc.,
- * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
- *
- *
- ******************************************************************************/
-#ifndef __RTW_IOCTL_SET_H_
-#define __RTW_IOCTL_SET_H_
-
-
-u8 rtw_set_802_11_add_key(_adapter *padapter, NDIS_802_11_KEY *key);
-u8 rtw_set_802_11_bssid(_adapter *padapter, u8 *bssid);
-u8 rtw_set_802_11_disassociate(_adapter *padapter);
-u8 rtw_set_802_11_bssid_list_scan(_adapter *padapter, struct sitesurvey_parm *pparm);
-u8 rtw_set_802_11_remove_wep(_adapter *padapter, u32 keyindex);
-u8 rtw_set_802_11_ssid(_adapter *padapter, NDIS_802_11_SSID *ssid);
-u8 rtw_set_802_11_connect(_adapter *padapter, u8 *bssid, NDIS_802_11_SSID *ssid);
-u8 rtw_set_802_11_remove_key(_adapter *padapter, NDIS_802_11_REMOVE_KEY *key);
-
-u8 rtw_validate_bssid(u8 *bssid);
-u8 rtw_validate_ssid(NDIS_802_11_SSID *ssid);
-
-u16 rtw_get_cur_max_rate(_adapter *adapter);
-//int rtw_set_scan_mode(_adapter *adapter, RT_SCAN_TYPE scan_mode);
-int rtw_set_channel_plan(_adapter *adapter, u8 channel_plan);
-//int rtw_set_band(_adapter *adapter, enum _BAND band);
-
-#endif
-
diff --git a/os/board/rtl8720e/src/component/wifi/driver/include/rtw_layer2_rm.h b/os/board/rtl8720e/src/component/wifi/driver/include/rtw_layer2_rm.h
deleted file mode 100644
index b0a6a4461..000000000
--- a/os/board/rtl8720e/src/component/wifi/driver/include/rtw_layer2_rm.h
+++ /dev/null
@@ -1,59 +0,0 @@
-/******************************************************************************
- *
- * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of version 2 of the GNU General Public License as
- * published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
- * more details.
- *
- * You should have received a copy of the GNU General Public License along with
- * this program; if not, write to the Free Software Foundation, Inc.,
- * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
- *
- *
- ******************************************************************************/
-#ifndef __RTW_LAYER2_RM_H_
-#define __RTW_LAYER2_RM_H_
-
-#ifdef CONFIG_LAYER2_ROAMING
-#define rtw_roam_flags(adapter)		(rtw_get_rmpriv(adapter)->roam_flags)
-#define rtw_chk_roam_flags(adapter, flags) (rtw_roam_flags(adapter) & flags)
-#define rtw_clr_roam_flags(adapter, flags) \
-	do { \
-		struct rm_priv *prmpriv = rtw_get_rmpriv(adapter); \
-		(prmpriv->roam_flags &= ~flags); \
-	} while (0)
-
-#define rtw_set_roam_flags(adapter, flags) \
-	do { \
-		struct rm_priv *prmpriv = rtw_get_rmpriv(adapter); \
-		(prmpriv->roam_flags |= flags); \
-	} while (0)
-
-#define rtw_assign_roam_flags(adapter, flags) \
-	do { \
-		struct rm_priv *prmpriv = rtw_get_rmpriv(adapter); \
-		(prmpriv->roam_flags = flags); \
-	} while (0)
-
-int is_same_ess(WLAN_BSSID_EX *a, WLAN_BSSID_EX *b);
-void _rtw_roaming(_adapter *adapter, struct wlan_network *tgt_network);
-void rtw_roaming(_adapter *adapter, struct wlan_network *tgt_network);
-void rtw_set_to_roam(_adapter *adapter, u8 to_roam);
-u8 rtw_dec_to_roam(_adapter *adapter);
-u8 rtw_to_roam(_adapter *adapter);
-void rtw_roaming_sitesurvey_again(_adapter *padapter);
-void rtw_start_roam(_adapter *padapter);
-void rtw_drv_scan_by_self(_adapter *padapter, u8 reason);
-void rtw_roamimg_info_init(_adapter *padapter);
-int rtw_select_roaming_candidate(struct mlme_priv *pmlmepriv);
-#endif /* CONFIG_LAYER2_ROAMING */
-
-
-#endif //__RTW_LAYER2_RM_H_
-
diff --git a/os/board/rtl8720e/src/component/wifi/driver/include/rtw_mlme.h b/os/board/rtl8720e/src/component/wifi/driver/include/rtw_mlme.h
deleted file mode 100644
index 5180cc100..000000000
--- a/os/board/rtl8720e/src/component/wifi/driver/include/rtw_mlme.h
+++ /dev/null
@@ -1,366 +0,0 @@
-/******************************************************************************
- *
- * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of version 2 of the GNU General Public License as
- * published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
- * more details.
- *
- * You should have received a copy of the GNU General Public License along with
- * this program; if not, write to the Free Software Foundation, Inc.,
- * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
- *
- *
- ******************************************************************************/
-#ifndef __RTW_MLME_H_
-#define __RTW_MLME_H_
-
-//#define   MAX_JOIN_TIMEOUT	2000
-//#define   MAX_JOIN_TIMEOUT	2500
-#define   MAX_JOIN_TIMEOUT	6500
-
-#ifdef CONFIG_MULTICAST
-#define MULTICAST_LIST_SIZE		4
-#endif //CONFIG_MULTICAST
-
-//	Commented by Albert 20101105
-//	Increase the scanning timeout because of increasing the SURVEY_TO value.
-
-#if defined(CONFIG_BT_COEXIST_SOC) || defined(CONFIG_BT_COEXIST)
-#define 	SCANNING_TIMEOUT 	12000
-#else
-#define 	SCANNING_TIMEOUT 	8000
-#endif //CONFIG_BT_COEXIST_SOC
-
-#define	SCAN_INTERVAL	(30) // unit:2sec, 30*2=60sec
-
-#define MLME_IS_PD(adapter) 0
-#define MLME_IS_GC(adapter) 0
-#define MLME_IS_GO(adapter) 0
-
-#define 	WIFI_NULL_STATE		0x00000000
-#define	WIFI_ASOC_STATE		0x00000001		// Under Linked state...
-#define 	WIFI_REASOC_STATE	       0x00000002
-#define	WIFI_SLEEP_STATE	       0x00000004
-#define	WIFI_STATION_STATE	0x00000008
-#define	WIFI_AP_STATE				0x00000010
-#define   WIFI_UNDER_LINKING		0x00000080
-#define WIFI_MESH_STATE					0x00000200
-//#define WIFI_UNDER_CMD			0x00000200
-// ========== P2P Section Start ===============
-#define	WIFI_P2P_LISTEN_STATE		0x00010000
-#define	WIFI_P2P_GROUP_FORMATION_STATE		0x00020000
-// ========== P2P Section End ===============
-#define WIFI_UNDER_WPS			0x00000100
-#define WIFI_SITE_MONITOR		0x00000800		//to indicate the station is under site surveying
-
-#ifdef WDS
-#define	WIFI_WDS				0x00001000
-#define	WIFI_WDS_RX_BEACON	0x00002000		// already rx WDS AP beacon
-#endif
-#ifdef AUTO_CONFIG
-#define	WIFI_AUTOCONF			0x00004000
-#define	WIFI_AUTOCONF_IND	0x00008000
-#endif
-
-//#ifdef UNDER_MPTEST
-#define	WIFI_MP_STATE						0x00010000
-#define	WIFI_MP_CTX_BACKGROUND			0x00020000	// in continous tx background
-#define	WIFI_MP_CTX_ST					0x00040000	// in continous tx with single-tone
-#define	WIFI_MP_CTX_BACKGROUND_PENDING	0x00080000	// pending in continous tx background due to out of skb
-#define	WIFI_MP_CTX_CCK_HW				0x00100000	// in continous tx
-#define	WIFI_MP_CTX_CCK_CS				0x00200000	// in continous tx with carrier suppression
-#define   WIFI_MP_LPBK_STATE				0x00400000
-//#endif
-#define WIFI_OP_CH_SWITCHING			0x00800000
-
-enum {
-	MLME_ACTION_UNKNOWN,
-	MLME_ACTION_NONE,
-	MLME_SCAN_ENABLE, /* WIFI_SITE_MONITOR */
-	MLME_SCAN_ENTER, /* WIFI_SITE_MONITOR && !SCAN_DISABLE && !SCAN_BACK_OP */
-	MLME_SCAN_DONE, /*  WIFI_SITE_MONITOR && (SCAN_DISABLE || SCAN_BACK_OP) */
-	MLME_SCAN_DISABLE, /* WIFI_SITE_MONITOR is going to be cleared */
-	MLME_STA_CONNECTING,
-	MLME_STA_CONNECTED,
-	MLME_STA_DISCONNECTED,
-	MLME_TDLS_LINKED,
-	MLME_TDLS_NOLINK,
-	MLME_AP_STARTED,
-	MLME_AP_STOPPED,
-	MLME_MESH_STARTED,
-	MLME_MESH_STOPPED,
-	MLME_OPCH_SWITCH,
-};
-
-
-//#define _FW_UNDER_CMD		WIFI_UNDER_CMD
-#define _FW_UNDER_LINKING	WIFI_UNDER_LINKING
-#define _FW_LINKED			WIFI_ASOC_STATE
-#define _FW_UNDER_SURVEY	WIFI_SITE_MONITOR
-
-enum dot11AuthAlgrthmNum {
-	dot11AuthAlgrthm_Open = 0,
-	dot11AuthAlgrthm_Shared,
-	dot11AuthAlgrthm_8021X,
-	dot11AuthAlgrthm_SAE,
-	dot11AuthAlgrthm_Auto,
-	dot11AuthAlgrthm_WAPI,
-	dot11AuthAlgrthm_FT_PSK,
-	dot11AuthAlgrthm_MaxNum
-};
-
-/**
- * enum mfp_options - Management frame protection (IEEE 802.11w) options
- */
-enum mfp_options {
-	NO_MGMT_FRAME_PROTECTION = 0,
-	MGMT_FRAME_PROTECTION_OPTIONAL = 1,
-	MGMT_FRAME_PROTECTION_REQUIRED = 2,
-};
-#define MGMT_FRAME_PROTECTION_DEFAULT 3
-
-#define WPA_CAPABILITY_MFPR BIT(6)
-#define WPA_CAPABILITY_MFPC BIT(7)
-
-// Scan type including active and passive scan.
-typedef enum _RT_SCAN_TYPE {
-	SCAN_PASSIVE = 1,
-	SCAN_ACTIVE,
-	SCAN_MIX,
-} RT_SCAN_TYPE, *PRT_SCAN_TYPE;
-
-struct scan_priv {
-	u8										scan_type_user_config;
-	rtw_channel_scan_time_t 				chan_scan_time;
-	u8										hidden_ssid_disable;
-	u16 									max_ap_record_num;
-	_queue 									scan_report_list;
-	u16 									scan_cnt;
-	u8										report_each_mode_enable; /* Every time a AP is scanned, it will be reported to user immediately */
-	void 									*scan_user_data;
-	scan_user_callback_t					scan_user_callback;
-	scan_report_each_mode_user_callback_t	scan_report_each_mode_user_callback;
-};
-
-typedef struct rtw_scan_report_node {
-	_list list;
-	rtw_scan_result_t scanned_AP_info;
-} rtw_scan_report_node_t;
-
-/*
-
-there are several "locks" in mlme_priv,
-since mlme_priv is a shared resource between many threads,
-like ISR/Call-Back functions, the OID handlers, and even timer functions.
-
-
-Each _queue has its own locks, already.
-Other items are protected by mlme_priv.lock.
-
-To avoid possible dead lock, any thread trying to modifiying mlme_priv
-SHALL not lock up more than one locks at a time!
-
-*/
-
-
-#define traffic_threshold	10
-#define	traffic_scan_period	500
-
-struct sitesurvey_ctrl {
-	u64	last_tx_pkts;
-	uint	last_rx_pkts;
-	sint	traffic_busy;
-	_timer	sitesurvey_ctrl_timer;
-};
-
-typedef struct _RT_LINK_DETECT_T {
-	u32			NumTxOkInPeriod;
-	u32			NumRxOkInPeriod;
-	u32			NumRxUnicastOkInPeriod;
-	u32			NumRxBcnInPeriod;
-	BOOLEAN			bBusyTraffic;
-	BOOLEAN			bHigherBusyTraffic;	// For interrupt migration purpose.
-	BOOLEAN			bHigherBusyRxTraffic;	// We may disable Tx interrupt according as Rx traffic.
-	BOOLEAN			bHigherBusyTxTraffic;	// We may disable Tx interrupt according as Tx traffic.
-} RT_LINK_DETECT_T, *PRT_LINK_DETECT_T;
-
-struct wifidirect_info {
-	enum P2P_ROLE			role;
-	enum P2P_STATE			p2p_state;
-	u8						baction_tx_pending;
-	u8						pending_peer[ETH_ALEN];
-	struct xmit_frame			*pending_action;
-	_timer					pre_tx_scan_timer;
-};
-
-#ifdef CONFIG_LAYER2_ROAMING
-#define RTW_ROAM_SCAN_RESULT_EXP_MS (5*1000)
-#define RTW_ROAM_RSSI_DIFF_TH 10
-#define RTW_ROAM_SCAN_INTERVAL (5)    /* 5*(2 second)*/
-#define RTW_ROAM_RSSI_THRESHOLD 50
-
-enum {
-	RTW_ROAM_ON_EXPIRED = BIT(0),
-	RTW_ROAM_ON_RESUME = BIT(1),
-	RTW_ROAM_ACTIVE = BIT(2),
-	RTW_ROAM_ON_BTM = BIT(3),
-};
-
-enum {
-	RTW_NO_ROAM = 0,
-	RTW_ROAM_BTM_RUNNING = 1,
-	RTW_ROAM_LAYER2_RUNNING = 2,
-};
-#endif
-
-enum {
-	RTW_MLME_PREPARE_JOIN = 0,
-	RTW_MLME_JOIN_FAIL = 1,
-	RTW_MLME_JOIN_SUCCESS = 2,
-};
-
-struct mlme_priv {
-
-	_lock	lock;
-	u8 bScanInProcess;
-	u8	to_join; //flag
-	u8 	rx_stbc;
-
-	u8		*nic_hdl;
-
-	_queue	scanned_queue;
-	struct wlan_network	*free_bss_buf;
-	u8			free_bss_buf_used;
-
-	struct scan_priv scanpriv;
-
-	NDIS_802_11_SSID	assoc_ssid;
-	u8	assoc_bssid[6];
-
-#ifdef CONFIG_WOWLAN
-	u8	ip_addr[4];
-#endif
-
-	_timer assoc_timer;
-
-	u8 assoc_by_bssid;
-
-	_timer scan_to_timer; // driver itself handles scan_timeout status.
-	u32 scan_start_time; // used to evaluate the time spent in scanning
-
-	RT_LINK_DETECT_T	LinkDetectInfo;
-	_timer	dynamic_chk_timer; //dynamic/periodic check timer
-
-	u8 	key_mask; //use for ips to set wep key after ips_leave
-	u8	acm_mask; // for wmm acm mask
-	u8	ChannelPlan;
-	RT_SCAN_TYPE 	scan_mode; // active: 1, passive: 0
-
-	u32 lastscantime;
-
-#ifdef CONFIG_MULTICAST
-	u32 multicast_list[MULTICAST_LIST_SIZE];
-#endif
-	//For fast reconnection to keep frame info temporarily
-	union recv_frame *p_copy_recv_frame;
-	unsigned short disassoc_reason;
-};
-
-#define RTW_AUTO_SCAN_REASON_UNSPECIFIED		0
-#define RTW_AUTO_SCAN_REASON_2040_BSS			BIT(0)
-#define RTW_AUTO_SCAN_REASON_ACS				BIT(1)
-#define RTW_AUTO_SCAN_REASON_ROAM				BIT(2)
-#define RTW_AUTO_SCAN_REASON_MESH_OFFCH_CAND	BIT(3)
-
-static inline u8 *rtw_get_capability_from_ie(u8 *ie)
-{
-	return (ie + 8 + 2);
-}
-
-static inline u16 rtw_get_capability(WLAN_BSSID_EX *bss)
-{
-	u16	val;
-
-	rtw_memcpy((u8 *)&val, rtw_get_capability_from_ie(bss->IEs), 2);
-
-	return val;
-}
-
-static inline u8 *rtw_get_beacon_interval_from_ie(u8 *ie)
-{
-	return (ie + 8);
-}
-
-extern void rtw_joinbss_event_prehandle(_adapter *adapter, u8 *pbuf);
-
-extern void rtw_atimdone_event_callback(_adapter *adapter, u8 *pbuf);
-extern void rtw_cpwm_event_callback(_adapter *adapter, u8 *pbuf);
-
-extern void rtw_free_network_queue(_adapter *adapter);
-extern void rtw_init_mlme_priv(_adapter *adapter);// (struct mlme_priv *pmlmepriv);
-
-extern void rtw_free_mlme_priv(_adapter *adapter);
-
-
-extern sint rtw_select_and_join_from_scanned_queue(struct mlme_priv *pmlmepriv);
-extern sint rtw_set_key(_adapter *adapter, struct security_priv *psecuritypriv, sint keyid, u8 set_tx);
-extern sint rtw_linked_check(_adapter *padapter);
-
-#ifdef CONFIG_CONCURRENT_MODE
-sint rtw_buddy_adapter_up(_adapter *padapter);
-sint check_buddy_fwstate(_adapter *padapter, sint state);
-#endif //CONFIG_CONCURRENT_MODE
-sint check_both_fwstate(_adapter *padapter, sint state);
-
-extern u16 rtw_get_capability(WLAN_BSSID_EX *bss);
-extern void rtw_scan_update_scanned_network(_adapter *adapter, WLAN_BSSID_EX *target);
-extern void rtw_disconnect_hdl_under_linked(_adapter *adapter, struct sta_info *psta, u8 free_assoc);
-extern struct wlan_network *rtw_find_network(_queue *scanned_queue, u8 *addr);
-
-extern void rtw_free_assoc_resources(_adapter *adapter, int lock_scanned_queue);
-extern void rtw_indicate_disconnect(_adapter *adapter);
-extern void rtw_indicate_connect(_adapter *adapter);
-void rtw_scan_abort(_adapter *adapter);
-
-extern int rtw_restruct_sec_ie(_adapter *adapter, u8 *in_ie, u8 *out_ie, uint in_len);
-extern int rtw_restruct_wmm_ie(_adapter *adapter, u8 *in_ie, u8 *out_ie, uint in_len, uint initial_out_len);
-//extern void rtw_init_registrypriv_dev_network(_adapter *adapter);
-
-//extern void rtw_update_registrypriv_dev_network(_adapter *adapter);
-
-extern void rtw_scan_timeout_handler(void *FunctionContext);
-
-extern u8 rtw_dynamic_check_timer_handlder(_adapter *adapter);
-
-void rtw_free_mlme_priv_ie_data(_adapter *padapter);
-
-extern struct wlan_network *_rtw_dequeue_network(_queue *queue);
-
-u8 *rtw_get_capability_from_ie(u8 *ie);
-u8 *rtw_get_beacon_interval_from_ie(u8 *ie);
-
-unsigned int rtw_restructure_ht_ie(_adapter *padapter, u8 *in_ie, u8 *out_ie, uint in_len, uint *pout_len);
-void rtw_update_ht_cap(_adapter *padapter, u8 *pie, uint ie_len);
-void rtw_issue_addbareq_cmd(_adapter *padapter, struct xmit_frame *pxmitframe);
-
-int rtw_is_same_bss(_adapter *adapter, struct wlan_network *pnetwork);
-int rtw_scan_is_same_network(WLAN_BSSID_EX *src, WLAN_BSSID_EX *dst);
-
-void rtw_get_bcn_info(struct wlan_network *pnetwork);
-
-#ifdef CONFIG_INTEL_PROXIM
-void rtw_proxim_enable(_adapter *padapter);
-void rtw_proxim_disable(_adapter *padapter);
-void rtw_proxim_send_packet(_adapter *padapter, u8 *pbuf, u16 len, u8 hw_rate);
-#endif //CONFIG_INTEL_PROXIM
-
-extern void rtw_os_indicate_disconnect(_adapter *adapter);
-extern void rtw_reset_securitypriv(_adapter *adapter);
-#endif //__RTL871X_MLME_H_
-
diff --git a/os/board/rtl8720e/src/component/wifi/driver/include/rtw_mlme_ext.h b/os/board/rtl8720e/src/component/wifi/driver/include/rtw_mlme_ext.h
deleted file mode 100644
index 5b2f0b1cf..000000000
--- a/os/board/rtl8720e/src/component/wifi/driver/include/rtw_mlme_ext.h
+++ /dev/null
@@ -1,726 +0,0 @@
-/******************************************************************************
- *
- * Copyright(c) 2007 - 2012 Realtek Corporation. All rights reserved.
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of version 2 of the GNU General Public License as
- * published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
- * more details.
- *
- * You should have received a copy of the GNU General Public License along with
- * this program; if not, write to the Free Software Foundation, Inc.,
- * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
- *
- *
- ******************************************************************************/
-#ifndef __RTW_MLME_EXT_H_
-#define __RTW_MLME_EXT_H_
-
-
-//	Commented by Albert 20101105
-//	Increase the SURVEY_TO value from 100 to 150  ( 100ms to 150ms )
-//	The Realtek 8188CE SoftAP will spend around 100ms to send the probe response after receiving the probe request.
-//	So, this driver tried to extend the dwell time for each scanning channel.
-//	This will increase the chance to receive the probe response from SoftAP.
-
-#if CONFIG_AUTO_RECONNECT
-
-#endif
-
-//TODO
-#define FAST_SURVEY_TO	(25) //Fast connection time, scan only partial channel
-#define SURVEY_TO		(100) //Reduce connection time
-#define MAX_CNT_SCAN_TIMES	(3) //Max all-channel loop scan times when connect to but fail scan the target ap
-#define MAX_CNT_AUTH_TIMES	(3) //Max connect times in case of receiving deauth/deassoc during auth&&assoc procedure and not reporting disconnect event
-#define PASSIVE_SURVEY_TO		(110) //Passive scan should > 102.4ms
-//#define SURVEY_TO		(300) //Increase time to stay each channel - Alex Fang
-#define REAUTH_TO		(800) //(50)
-#define REASSOC_TO		(300) //(50)
-//#define DISCONNECT_TO	(3000)
-#define ADDBA_TO			(2000)
-#define DEFRAG_TO (2000)
-
-#define LINKED_TO (1) //unit:2 sec, 1x2=2 sec
-
-#define AP_CSA_TO			(102)
-
-#define REAUTH_LIMIT	(4)
-#define REASSOC_LIMIT	(4)
-#define READDBA_LIMIT	(2)
-
-
-#define ROAMING_LIMIT	8
-
-//#define	IOCMD_REG0		0x10250370
-//#define	IOCMD_REG1		0x10250374
-//#define	IOCMD_REG2		0x10250378
-
-//#define	FW_DYNAMIC_FUN_SWITCH	0x10250364
-
-//#define	WRITE_BB_CMD		0xF0000001
-//#define	SET_CHANNEL_CMD	0xF3000000
-//#define	UPDATE_RA_CMD	0xFD0000A2
-
-#define _HW_STATE_NOLINK_		0x00
-#define _HW_STATE_ADHOC_		0x01
-#define _HW_STATE_STATION_ 	0x02
-#define _HW_STATE_AP_			0x03
-#define _HW_STATE_MONITOR_ 	0x04
-
-#define RTW_MAX_SCAN_REPORT_NODE 64
-
-#define		_1M_RATE_	0
-#define		_2M_RATE_	1
-#define		_5M_RATE_	2
-#define		_11M_RATE_	3
-#define		_6M_RATE_	4
-#define		_9M_RATE_	5
-#define		_12M_RATE_	6
-#define		_18M_RATE_	7
-#define		_24M_RATE_	8
-#define		_36M_RATE_	9
-#define		_48M_RATE_	10
-#define		_54M_RATE_	11
-
-#define MAX_COUNTRY_NUM 250
-
-#define WAIT_FOR_BCN_TO_MIN	(6000)
-#define WAIT_FOR_BCN_TO_MAX	(20000)
-
-#define DEL_STA_MAC_ID	0x7F
-
-#define rltk_ap_compatibility_is_enable(a,b) ((a & b) ? 1 : 0)
-
-//
-// Channel Plan Type.
-// Note:
-//	We just add new channel plan when the new channel plan is different from any of the following
-//	channel plan.
-//	If you just wnat to customize the acitions(scan period or join actions) about one of the channel plan,
-//	customize them in RT_CHANNEL_INFO in the RT_CHANNEL_LIST.
-//
-typedef enum _RT_CHANNEL_DOMAIN {
-	//===== new channel plan mapping, (2GDOMAIN_5GDOMAIN) =====//
-	RT_CHANNEL_DOMAIN_WORLD_NULL = 0x20,
-	RT_CHANNEL_DOMAIN_ETSI1_NULL = 0x21,
-	RT_CHANNEL_DOMAIN_FCC1_NULL = 0x22,
-	RT_CHANNEL_DOMAIN_MKK1_NULL = 0x23,
-	RT_CHANNEL_DOMAIN_ETSI2_NULL = 0x24,
-	RT_CHANNEL_DOMAIN_FCC1_FCC1 = 0x25,
-	RT_CHANNEL_DOMAIN_WORLD_ETSI1 = 0x26,
-	RT_CHANNEL_DOMAIN_MKK1_MKK1 = 0x27,
-	RT_CHANNEL_DOMAIN_WORLD_KCC1 = 0x28,
-	RT_CHANNEL_DOMAIN_WORLD_FCC2 = 0x29,
-	RT_CHANNEL_DOMAIN_FCC2_NULL = 0x2A,
-	RT_CHANNEL_DOMAIN_IC1_IC2 = 0x2B,
-	RT_CHANNEL_DOMAIN_MKK2_NULL = 0x2C,
-	RT_CHANNEL_DOMAIN_WORLD_CHILE1 = 0x2D,
-	RT_CHANNEL_DOMAIN_WORLD1_WORLD1 = 0x2E,
-	RT_CHANNEL_DOMAIN_WORLD_CHILE2 = 0x2F,
-	RT_CHANNEL_DOMAIN_WORLD_FCC3 = 0x30,
-	RT_CHANNEL_DOMAIN_WORLD_FCC4 = 0x31,
-	RT_CHANNEL_DOMAIN_WORLD_FCC5 = 0x32,
-	RT_CHANNEL_DOMAIN_WORLD_FCC6 = 0x33,
-	RT_CHANNEL_DOMAIN_FCC1_FCC7 = 0x34,
-	RT_CHANNEL_DOMAIN_WORLD_ETSI2 = 0x35,
-	RT_CHANNEL_DOMAIN_WORLD_ETSI3 = 0x36,
-	RT_CHANNEL_DOMAIN_MKK1_MKK2 = 0x37,
-	RT_CHANNEL_DOMAIN_MKK1_MKK3 = 0x38,
-	RT_CHANNEL_DOMAIN_FCC1_NCC1 = 0x39,
-	RT_CHANNEL_DOMAIN_ETSI1_ETSI1 = 0x3A,
-	RT_CHANNEL_DOMAIN_ETSI1_ACMA1 = 0x3B,
-	RT_CHANNEL_DOMAIN_ETSI1_ETSI6 = 0x3C,
-	RT_CHANNEL_DOMAIN_ETSI1_ETSI12 = 0x3D,
-	RT_CHANNEL_DOMAIN_KCC1_KCC2 = 0x3E,
-	RT_CHANNEL_DOMAIN_FCC1_FCC11 = 0x3F,
-	RT_CHANNEL_DOMAIN_FCC1_NCC2 = 0x40,
-	RT_CHANNEL_DOMAIN_GLOBAL_NULL = 0x41,
-	RT_CHANNEL_DOMAIN_ETSI1_ETSI4 = 0x42,
-	RT_CHANNEL_DOMAIN_FCC1_FCC2 = 0x43,
-	RT_CHANNEL_DOMAIN_FCC1_NCC3 = 0x44,
-	RT_CHANNEL_DOMAIN_WORLD_ACMA1 = 0x45,
-	RT_CHANNEL_DOMAIN_FCC1_FCC8 = 0x46,
-	RT_CHANNEL_DOMAIN_WORLD_ETSI6 = 0x47,
-	RT_CHANNEL_DOMAIN_WORLD_ETSI7 = 0x48,
-	RT_CHANNEL_DOMAIN_WORLD_ETSI8 = 0x49,
-	RT_CHANNEL_DOMAIN_IC2_IC2 = 0x4A,
-	RT_CHANNEL_DOMAIN_KCC1_KCC3 = 0x4B,
-	RT_CHANNEL_DOMAIN_FCC1_FCC15 = 0x4C,
-	RT_CHANNEL_DOMAIN_FCC2_MEX1 = 0x4D,
-	RT_CHANNEL_DOMAIN_ETSI1_ETSI22 = 0x4E,
-	RT_CHANNEL_DOMAIN_NULL_MKK9 = 0x4F,
-	RT_CHANNEL_DOMAIN_WORLD_ETSI9 = 0x50,
-	RT_CHANNEL_DOMAIN_WORLD_ETSI10 = 0x51,
-	RT_CHANNEL_DOMAIN_WORLD_ETSI11 = 0x52,
-	RT_CHANNEL_DOMAIN_FCC1_NCC4 = 0x53,
-	RT_CHANNEL_DOMAIN_WORLD_ETSI12 = 0x54,
-	RT_CHANNEL_DOMAIN_FCC1_FCC9 = 0x55,
-	RT_CHANNEL_DOMAIN_WORLD_ETSI13 = 0x56,
-	RT_CHANNEL_DOMAIN_FCC1_FCC10 = 0x57,
-	RT_CHANNEL_DOMAIN_MKK2_MKK4 = 0x58,
-	RT_CHANNEL_DOMAIN_WORLD_ETSI14 = 0x59,
-	RT_CHANNEL_DOMAIN_NULL_FCC19 = 0x5A,
-	RT_CHANNEL_DOMAIN_NULL_FCC20 = 0x5B,
-	RT_CHANNEL_DOMAIN_NULL_FCC21 = 0x5C,
-	RT_CHANNEL_DOMAIN_ETSI1_ETSI23	= 0x5D,
-	RT_CHANNEL_DOMAIN_ETSI1_ETSI2 = 0x5E,
-	RT_CHANNEL_DOMAIN_MKK2_MKK10 = 0x5F,
-	RT_CHANNEL_DOMAIN_FCC1_FCC5 = 0x60,
-	RT_CHANNEL_DOMAIN_FCC2_FCC7 = 0x61,
-	RT_CHANNEL_DOMAIN_FCC2_FCC1 = 0x62,
-	RT_CHANNEL_DOMAIN_WORLD_ETSI15 = 0x63,
-	RT_CHANNEL_DOMAIN_MKK2_MKK5 = 0x64,
-	RT_CHANNEL_DOMAIN_ETSI1_ETSI16 = 0x65,
-	RT_CHANNEL_DOMAIN_FCC1_FCC14 = 0x66,
-	RT_CHANNEL_DOMAIN_FCC1_FCC12 = 0x67,
-	RT_CHANNEL_DOMAIN_FCC2_FCC14 = 0x68,
-	RT_CHANNEL_DOMAIN_FCC2_FCC12 = 0x69,
-	RT_CHANNEL_DOMAIN_ETSI1_ETSI17 = 0x6A,
-	RT_CHANNEL_DOMAIN_WORLD_FCC16 = 0x6B,
-	RT_CHANNEL_DOMAIN_WORLD_FCC13 = 0x6C,
-	RT_CHANNEL_DOMAIN_FCC2_FCC15 = 0x6D,
-	RT_CHANNEL_DOMAIN_WORLD_FCC12 = 0x6E,
-	RT_CHANNEL_DOMAIN_NULL_ETSI8 = 0x6F,
-	RT_CHANNEL_DOMAIN_NULL_ETSI18 = 0x70,
-	RT_CHANNEL_DOMAIN_NULL_ETSI17 = 0x71,
-	RT_CHANNEL_DOMAIN_NULL_ETSI19 = 0x72,
-	RT_CHANNEL_DOMAIN_WORLD_FCC7 = 0x73,
-	RT_CHANNEL_DOMAIN_FCC2_FCC17 = 0x74,
-	RT_CHANNEL_DOMAIN_WORLD_ETSI20 = 0x75,
-	RT_CHANNEL_DOMAIN_FCC2_FCC11 = 0x76,
-	RT_CHANNEL_DOMAIN_WORLD_ETSI21 = 0x77,
-	RT_CHANNEL_DOMAIN_FCC1_FCC18 = 0x78,
-	RT_CHANNEL_DOMAIN_MKK2_MKK1 = 0x79,
-	RT_CHANNEL_DOMAIN_ETSI1_ETSI25 = 0x7A,
-	RT_CHANNEL_DOMAIN_ETSI1_ETSI24 = 0x7B,
-	RT_CHANNEL_DOMAIN_ETSI1_ETSI26 = 0x7C,
-	RT_CHANNEL_DOMAIN_MKK1_MKK11 = 0x7D,
-	RT_CHANNEL_DOMAIN_MKK2_MKK11 = 0x7E,
-
-	//===== Add new channel plan above this line===============//
-	RT_CHANNEL_DOMAIN_REALTEK_DEFINE = 0x7F,
-	RT_CHANNEL_DOMAIN_MAX = 0x80
-} RT_CHANNEL_DOMAIN, *PRT_CHANNEL_DOMAIN;
-
-typedef enum _RT_CHANNEL_DOMAIN_2G {
-	RTW_RD_2G_NULL = 0,	/* Do not support 2G*/
-	RTW_RD_2G_01 = 1,	/* Worldwide 13, Canada */
-	RTW_RD_2G_02 = 2,	/* Europe, Japan */
-	RTW_RD_2G_03 = 3,		/* Worldwide 11, US, Canada, Korea */
-	RTW_RD_2G_04 = 4,		/* Japan */
-	RTW_RD_2G_05 = 5,	/* France */
-	RTW_RD_2G_06 = 6,	/* 2G Global, include channel 14 */
-	//===== Add new channel plan above this line===============//
-	RT_CHANNEL_DOMAIN_2G_MAX,
-} RT_CHANNEL_DOMAIN_2G, *PRT_CHANNEL_DOMAIN_2G;
-
-typedef enum _RT_CHANNEL_DOMAIN_5G {
-	RTW_RD_5G_NULL = 0,		/*Do not support 5G*/
-	RTW_RD_5G_01 = 1,		/*US, Canada, Australia, New Zealand, Mexico (w/o Weather radar), (w/o Ch120~Ch128)*/
-	RTW_RD_5G_02 = 2,		/*Europe, Japan (W52, W53, W56)*/
-	RTW_RD_5G_03 = 3,		/*Australia, New Zealand, US, Korea*/
-	RTW_RD_5G_04 = 4,		/*Russia (w/o Ch136, Ch140)*/
-	RTW_RD_5G_05 = 5,		/*Korea*/
-	RTW_RD_5G_06 = 6,		/*FCC w/o DFS Channels, Jordan*/
-	RTW_RD_5G_07 = 7,		/*Bolivia, Chile, El Salvador, Venezuela, China */
-	RTW_RD_5G_08 = 8,		/*Venezuela, Indonesia (w/o Ch165)*/
-	RTW_RD_5G_09 = 9,		/*China, Taiwan w/o DFS, Qatar*/
-	RTW_RD_5G_10 = 10,		/*Japan (W52, W53), Israel, Bahrain, Egypt, India, China, Malaysia*/
-	RTW_RD_5G_11 = 11,		/*Japan (W56)*/
-	RTW_RD_5G_12 = 12,		/*Taiwan, (w/o Weather radar)(w/o Ch52, Ch120~Ch128)*/
-	RTW_RD_5G_13 = 13,		/*Taiwan, Band2, Band4*/
-	RTW_RD_5G_14 = 14,		/*Europe, Japan (W52), w/o DFS, Band1 only*/
-	RTW_RD_5G_15 = 15,		/*Latin America, Indonesia*/
-	RTW_RD_5G_16 = 16,		/*Lebanon*/
-	RTW_RD_5G_17 = 17,		/*Russia*/
-	RTW_RD_5G_18 = 18,		/*Taiwan (w/o Weather radar)(w/o Ch120~Ch128)*/
-	RTW_RD_5G_19 = 19,		/*ETSI, FCC (w/o Weather radar)(w/o Ch120~Ch128)*/
-	RTW_RD_5G_20 = 20,		/*Argentina(w/o Weather radar)(w/o Ch120~Ch128, Ch165)*/
-	RTW_RD_5G_21 = 21,		/*Russia*/
-	RTW_RD_5G_22 = 22,		/*US (include Ch144), Chile, Korea (2018 Dec 05 New standard, include ch144)*/
-	RTW_RD_5G_23 = 23,		/*Malaysia*/
-	RTW_RD_5G_24 = 24,		/*Japan, Europe*/
-	RTW_RD_5G_25 = 25,		/*Europe, FCC*/
-	RTW_RD_5G_26 = 26,		/*FCC*/
-	RTW_RD_5G_27 = 27,		/*FCC w/o Weather radar(w/o Ch120~Ch128)*/
-	RTW_RD_5G_28 = 28,		/*FCC w/o Band3 China*/
-	RTW_RD_5G_29 = 29,		/*FCC w/o Band3*/
-	RTW_RD_5G_30 = 30,		/*ETSI w/o DFS Band2&3*/
-	RTW_RD_5G_31 = 31,		/*Europe*/
-	RTW_RD_5G_32 = 32,		/*Europe*/
-	RTW_RD_5G_33 = 33,		/*Canada (w/o Weather radar)(w/o Ch120~Ch128, include Ch144)*/
-	RTW_RD_5G_34 = 34,		/*Australia, New Zealand (w/o Weather radar)(w/o Ch120~Ch128)*/
-	RTW_RD_5G_35 = 35,		/**/
-	RTW_RD_5G_36 = 36,		/*5G Worldwide (include Ch144) Band2&3 w/i DFS for AP mode.*/
-	RTW_RD_5G_37 = 37,		/*5G Worldwide Band1&2*/
-	RTW_RD_5G_38 = 38,		/*Chile (Band2,Band3)*/
-	RTW_RD_5G_39 = 39,		/*Japan*/
-	RTW_RD_5G_40 = 40,		/*Japan*/
-	RTW_RD_5G_41 = 41,		/*Japan*/
-	RTW_RD_5G_42 = 42,		/*Europe*/
-	RTW_RD_5G_43 = 43,		/*Japan, FCC*/
-	RTW_RD_5G_44 = 44,		/*FCC*/
-	RTW_RD_5G_45 = 45,		/*FCC w/o Band3*/
-	RTW_RD_5G_46 = 46,		/*Indonesia*/
-	RTW_RD_5G_47 = 47,		/*Japan, Singapore*/
-	RTW_RD_5G_48 = 48,		/*Japan*/
-	RTW_RD_5G_49 = 49,		/**/
-	RTW_RD_5G_50 = 50,		/*Russia*/
-	RTW_RD_5G_51 = 51,		/*Tunisia*/
-	RTW_RD_5G_52 = 52,		/*US (include Ch144)(2018 Dec 05 New standard, include ch144)Add FCC 5.9G Channel*/
-	RTW_RD_5G_53 = 53,		/*Korea*/
-	RTW_RD_5G_54 = 54,
-	//===== Add new channel plan above this line===============//
-	RT_CHANNEL_DOMAIN_5G_MAX
-} RT_CHANNEL_DOMAIN_5G, *PRT_CHANNEL_DOMAIN_5G;
-
-#define rtw_is_channel_plan_valid(chplan) (chplan<RT_CHANNEL_DOMAIN_MAX || chplan == RT_CHANNEL_DOMAIN_REALTEK_DEFINE)
-
-typedef struct _RT_CHANNEL_PLAN {
-	unsigned char	Channel[MAX_CHANNEL_NUM];
-	unsigned char	Len;
-} RT_CHANNEL_PLAN, *PRT_CHANNEL_PLAN;
-
-typedef struct _RT_CHANNEL_PLAN_2G {
-	unsigned char	Channel[MAX_CHANNEL_NUM_2G];
-	unsigned char	Len;
-} RT_CHANNEL_PLAN_2G, *PRT_CHANNEL_PLAN_2G;
-
-typedef struct _RT_CHANNEL_PLAN_5G {
-	unsigned char	Channel[MAX_CHANNEL_NUM_5G];
-	unsigned char	Len;
-} RT_CHANNEL_PLAN_5G, *PRT_CHANNEL_PLAN_5G;
-
-typedef struct _RT_CHANNEL_PLAN_MAP {
-	unsigned char	ChannelPlan;
-	unsigned char	Index2G;
-#if defined(SUPPORT_5G_CHANNEL)
-	unsigned char	Index5G;
-#endif
-	unsigned char	PwrLmt2G; /* value of REGULATION_TXPWR_LMT */
-#if defined(SUPPORT_5G_CHANNEL)
-	unsigned char	PwrLmt5G;
-#endif
-} RT_CHANNEL_PLAN_MAP, *PRT_CHANNEL_PLAN_MAP;
-
-
-typedef struct _RT_CHANNEL_PLAN_COUNTRY_MAP {
-	char *country_code;
-	RT_CHANNEL_DOMAIN domain;
-
-} RT_CHANNEL_PLAN_COUNTRY_MAP, *PRT_CHANNEL_PLAN_COUNTRY_MAP;
-
-
-
-enum Associated_AP {
-	atherosAP	= 0,
-	broadcomAP	= 1,
-	ciscoAP		= 2,
-	marvellAP	= 3,
-	ralinkAP	= 4,
-	realtekAP	= 5,
-	airgocapAP 	= 6,
-	unknownAP	= 7,
-	maxAP,
-};
-
-enum SCAN_STATE {
-	SCAN_DISABLE = 0,
-	SCAN_START = 1,
-	SCAN_TXNULL = 2,
-	SCAN_PROCESS = 3,
-	SCAN_COMPLETE = 4,
-	/* backop */
-	SCAN_BACKING_OP = 5,
-	SCAN_BACK_OP = 6,
-	SCAN_LEAVING_OP = 7,
-	SCAN_LEAVE_OP = 8,
-	SCAN_STATE_MAX,
-};
-
-enum WIFI_INDICATE_MODE {
-	WIFI_INDICATE_DISABLE = 0,
-	WIFI_INDICATE_NORMAL = 1,
-	WIFI_INDICATE_WILD = 2,
-	WIFI_INDICATE_MAX,
-};
-
-struct	ss_res {
-	int	state;
-	int	bss_cnt;
-	int	channel_idx;
-	int	scan_mode;
-	NDIS_802_11_SSID ssid[RTW_SSID_SCAN_AMOUNT];
-#ifdef CONFIG_IEEE80211K
-	u32 token; 	/* 0: use to identify caller */
-	u16 duration;	/* 0: use default */
-#endif
-};
-
-typedef struct  transition_disable {
-	u8 bitmap; //Transition Disable Bitmap
-	u32 AKM_suite; //Secure algorithm (keymgmt)
-	u8 ssid[RTW_ESSID_MAX_SIZE + 1]; /**< SSID name (AP name)  */
-	u8 passphrase[IW_PASSPHRASE_MAX_SIZE + 1];
-	int ssid_len;      /**< SSID length */
-	int passphrase_len;
-} transition_disable_ctx, *ptransition_disable_ctx;
-
-//#define AP_MODE	0x0C
-//#define STATION_MODE	0x08
-//#define AD_HOC_MODE	0x04
-//#define NO_LINK_MODE	0x00
-
-#define WIFI_FW_NULL_STATE		_HW_STATE_NOLINK_
-#define	WIFI_FW_STATION_STATE		_HW_STATE_STATION_
-#define	WIFI_FW_AP_STATE		_HW_STATE_AP_
-
-#define	WIFI_FW_AUTH_NULL		0x00000100
-#define	WIFI_FW_AUTH_STATE		0x00000200
-#define	WIFI_FW_AUTH_SUCCESS		0x00000400
-
-#define	WIFI_FW_ASSOC_STATE		0x00002000
-#define	WIFI_FW_ASSOC_SUCCESS		0x00004000
-
-#define	WIFI_FW_LINKING_STATE		(WIFI_FW_AUTH_NULL | WIFI_FW_AUTH_STATE | WIFI_FW_AUTH_SUCCESS |WIFI_FW_ASSOC_STATE)
-
-struct FW_Sta_Info {
-	struct sta_info	*psta;
-	u32	status;
-	u32	rx_pkt;
-	u32	retry;
-	NDIS_802_11_RATES_EX  SupportedRates;
-};
-
-/*
- * Usage:
- * When one iface acted as AP mode and the other iface is STA mode and scanning,
- * it should switch back to AP's operating channel periodically.
- * Parameters info:
- * When the driver scanned RTW_SCAN_NUM_OF_CH channels, it would switch back to AP's operating channel for
- * RTW_STAY_AP_CH_MILLISECOND * SURVEY_TO milliseconds.
- * Example:
- * For chip supports 2.4G + 5GHz and AP mode is operating in channel 1,
- * RTW_SCAN_NUM_OF_CH is 8, RTW_STAY_AP_CH_MILLISECOND is 3 and SURVEY_TO is 100.
- * When it's STA mode gets set_scan command,
- * it would
- * 1. Doing the scan on channel 1.2.3.4.5.6.7.8
- * 2. Back to channel 1 for 300 milliseconds
- * 3. Go through doing site survey on channel 9.10.11.36.40.44.48.52
- * 4. Back to channel 1 for 300 milliseconds
- * 5. ... and so on, till survey done.
- */
-#if defined CONFIG_STA_MODE_SCAN_UNDER_AP_MODE && defined CONFIG_CONCURRENT_MODE
-#define RTW_SCAN_NUM_OF_CH			8
-#define RTW_STAY_AP_CH_MILLISECOND	3	// this value is a multiplier,for example, when this value is 3, it would stay AP's op ch for 
-// 3 * SURVEY_TO millisecond.
-#endif //defined CONFIG_STA_MODE_SCAN_UNDER_AP_MODE && defined CONFIG_CONCURRENT_MODE
-
-#ifndef _CUS_IE_
-#define _CUS_IE_
-typedef struct _cus_ie {
-	u8 *ie;
-	u8 type;
-} rtw_custom_ie_t, *p_rtw_custom_ie_t;
-#endif /* _CUS_IE_ */
-
-struct mlme_ext_info {
-	u32	state;
-	u32	reauth_count;
-	u32	reassoc_count;
-	u32	link_count;
-	u32	auth_seq;
-	u32	auth_algo;	// 802.11 auth, could be open, shared, auto
-	u32	authModeToggle;
-	u32	enc_algo;//encrypt algorithm;
-	u32	key_index;	// this is only valid for legendary wep, 0~3 for key id.
-	u32	iv;
-	u8	chg_txt[128];
-	u16	aid;
-	u16	bcn_interval;
-	u16	capability;
-	u8	slotTime;
-	u8	preamble_mode;
-	u8	WMM_enable;
-	u8	DTIM_period;
-	u8	ERP_IE;
-	u8	HT_enable;
-	u8	HT_caps_enable;
-	u8	HT_info_enable;
-	u8	HT_protection;
-	u8	agg_enable_bitmap;
-	u8	ADDBA_retry_count;
-	u8	candidate_tid_bitmap;
-	u8	dialogToken;
-	// Accept ADDBA Request
-	BOOLEAN bAcceptAddbaReq;
-	u8	bwmode_updated;
-	u8	hidden_ssid_mode;
-
-	u8	cur_channel;
-	u8	cur_bwmode;
-	u8	cur_ch_offset;//PRIME_CHNL_OFFSET
-
-	p_rtw_custom_ie_t cus_ven_ie;
-	u8 cus_ie_num;
-
-	struct ADDBA_request		ADDBA_req;
-	struct WMM_para_element	WMM_param;
-	struct HT_caps_element	HT_caps;
-	struct HT_info_element		HT_info;
-
-#ifdef CONFIG_80211AX_HE
-	struct HE_caps_element		HE_caps;
-	unsigned char					HE_op[HE_OP_ELE_MAX_LEN];
-#endif
-
-	struct FW_Sta_Info		FW_sta_info[NUM_STA];
-
-#ifdef CONFIG_STA_MODE_SCAN_UNDER_AP_MODE
-	u8 scan_cnt;
-#endif //CONFIG_STA_MODE_SCAN_UNDER_AP_MODE
-#ifdef CONFIG_SAE_SUPPORT
-	u8 user_group_id;			//for user to set group id
-	struct sae_data *sae_priv;
-	_lock sae_lock;
-#endif
-
-	int pmk_cache_enable;
-	struct pmksa_cache *pmksa;
-
-#ifdef CONFIG_CONCURRENT_MODE
-	u8 bConcurrentFlushingSTA;
-#endif
-
-};
-
-// The channel information about this channel including joining, scanning, and power constraints.
-#define PSCAN_ENABLE          0x01 //enable for partial channel scan
-#define PSCAN_FAST_SURVEY     0x02 //set to select scan time to FAST_SURVEY_TO and resend probe request
-#define PSCAN_SIMPLE_CONFIG   0x04 //set to select scan time to FAST_SURVEY_TO and resend probe request
-#define PSCAN_PASSIVE_SCAN    0x08 //partial passive channel scan
-#define PSCAN_SET_SSID_DONE   0x80 //When receive probe response, this bit is set to 1
-
-#define PSCAN_DISABLE_MASK    0xFE //disable PSCAN_ENABLE
-#define PSCAN_CLEAR_SSID_DONE 0x7F //clear PSCAN_SET_SSID_DONE
-#define PSCAN_CLEAR_PASSIVE_SCAN 0xF7 //clear PSCAN_PASSIVE_SCAN
-#define PSCAN_RETRY_TIMES        7 //the retry times of resending probe request when PSCAN_FAST_SURVEY is set
-
-typedef struct _RT_CHANNEL_INFO {
-	u8				ChannelNum;		// The channel number.
-	RT_SCAN_TYPE	ScanType;		// Scan type such as passive or active scan.
-#ifdef CONFIG_FIND_BEST_CHANNEL
-	u32				rx_count;
-#endif
-#ifdef CONFIG_DFS
-	u8 hidden_bss_cnt; /* per scan count */
-#endif
-	u8	pscan_config;
-} RT_CHANNEL_INFO, *PRT_CHANNEL_INFO;
-
-extern int rtw_is_channel_set_contains_channel(RT_CHANNEL_INFO *channel_set, const u32 channel_num, int *pchannel_idx);
-
-struct mlme_ext_priv {
-	u16	mgnt_seq;
-#ifdef CONFIG_IEEE80211W
-	u16	sa_query_seq;
-	u64 mgnt_80211w_IPN;
-	u64 mgnt_80211w_IPN_rx;
-	u8 key_type_11w; // for debug
-#endif /* CONFIG_IEEE80211W */
-
-	//struct fw_priv 	fwpriv;
-
-	u8	wireless_mode_support;//A, B, G, auto
-	u8	band_type_support;
-	NDIS_802_11_RATES_EX	default_supported_rates;
-
-	u8	cur_wireless_mode;	// NETWORK_TYPE
-	u8	max_chan_nums;
-	RT_CHANNEL_INFO		channel_set[MAX_CHANNEL_NUM + 1];
-	u8	basicrate[NumRates];
-	u8	datarate[NumRates];
-
-	struct ss_res		sitesurvey_res;
-
-	//for ap mode, network includes ap's cap_info
-	_timer		survey_timer;
-	_timer		link_timer;
-	//_timer		ADDBA_timer;
-
-#ifdef CONFIG_IEEE80211R
-	_timer		ft_link_timer;
-	_timer		ft_roam_timer;
-#endif
-
-	u8	scan_abort;
-	u8	user_tx_rate; // TXRATE when USERATE is set.
-
-	u8	retry; //retry for issue probereq
-
-	unsigned char bstart_bss;
-
-	/* for softap power save */
-#if CONFIG_AUTO_RECONNECT
-	_timer reconnect_timer;
-	u8 reconnect_deauth_filtered;
-	u8 reconnect_times;
-	u8 reconnect_cnt;
-	u16 reconnect_timeout; // the unit is second
-	u8 saved_alg;
-	u8 saved_essid[32 + 1];
-	u8 saved_key[32 + 1];
-	u8 saved_key_idx;
-	u8 saved_wpa_passphrase[IW_PASSPHRASE_MAX_SIZE + 1];
-	u8 saved_eap_method;
-	u8 auto_reconnect;
-#endif
-	u8 partial_scan;
-
-	_timer csa_timer;
-	u8 csa_channel;
-	u8 csa_ongoing;//flag
-
-	transition_disable_ctx transition_disable;
-};
-
-enum {
-	RTW_CHF_2G = BIT0,
-	RTW_CHF_5G = BIT1,
-	RTW_CHF_DFS = BIT2,
-	RTW_CHF_LONG_CAC = BIT3,
-	RTW_CHF_NON_DFS = BIT4,
-	RTW_CHF_NON_LONG_CAC = BIT5,
-	RTW_CHF_NON_OCP = BIT6,
-};
-#define mlmeext_scan_state(mlmeext) ((mlmeext)->sitesurvey_res.state)
-
-int rtw_chset_search_ch(RT_CHANNEL_INFO *ch_set, const u32 ch);
-u8 rtw_chset_is_chbw_valid(RT_CHANNEL_INFO *ch_set, u8 ch, u8 bw, u8 offset);
-
-bool rtw_mlme_band_check(_adapter *adapter, const u32 ch);
-u8 init_channel_set(_adapter *padapter, u8 ChannelPlan, RT_CHANNEL_INFO *channel_set);
-void free_mlme_ext_priv(_adapter *padapter);
-extern void init_addba_retry_timer(_adapter *padapter, struct sta_info *psta);
-#ifdef CONFIG_IEEE80211W
-extern void init_dot11w_expire_timer(_adapter *padapter, struct sta_info *psta);
-#endif /* CONFIG_IEEE80211W */
-extern struct xmit_frame *alloc_mgtxmitframe(struct xmit_priv *pxmitpriv);
-extern struct xmit_frame *alloc_FwRsvdframe(struct xmit_priv *pxmitpriv, u32 size);
-//void fill_fwpriv(_adapter * padapter, struct fw_priv *pfwpriv);
-
-unsigned char networktype_to_raid(unsigned char network_type);
-extern void wifi_rom_updateBratetbl(u8 *mBratesOS);
-void wifi_rom_updateBratetbl_softap(u8 *bssrateset, u32 bssratelen);
-
-void Save_DM_Func_Flag(_adapter *padapter);
-void Restore_DM_Func_Flag(_adapter *padapter);
-void Switch_DM_Func(_adapter *padapter, u32 mode, u8 enable);
-
-u8 wifi_rom_get_offset_by_chbw(u8 ch, u8 bw, u8 *r_offset);
-
-void wifi_rom_write_cam(u8 entry, u16 ctrl, u8 *mac, u8 *key);
-
-void CAM_empty_entry(PADAPTER Adapter, u8 ucIndex);
-
-
-int allocate_fw_sta_entry(_adapter *padapter);
-void flush_all_cam_entry(_adapter *padapter);
-
-BOOLEAN IsLegal5GChannel(PADAPTER Adapter, u8 channel);
-
-void rtw_scan_one_channel(_adapter *padapter);
-u8 rtw_scan_collect_bss_info(_adapter *padapter, union recv_frame *precv_frame, WLAN_BSSID_EX *bssid);
-void rtw_scan_update_network(WLAN_BSSID_EX *dst, WLAN_BSSID_EX *src, _adapter *padapter, bool update_ie);
-
-int get_bsstype(unsigned short capability);
-
-int is_client_associated_to_ap(_adapter *padapter);
-
-void HT_caps_handler(_adapter *padapter, PNDIS_802_11_VARIABLE_IEs pIE);
-void HT_info_handler(_adapter *padapter, PNDIS_802_11_VARIABLE_IEs pIE);
-
-void VCS_update(_adapter *padapter, struct sta_info *psta);
-
-void update_wireless_mode(_adapter *padapter);
-int update_sta_support_rate(_adapter *padapter, u8 *pvar_ie, uint var_ie_len, int cam_idx);
-
-//for sta/adhoc mode
-void update_sta_info(_adapter *padapter, struct sta_info *psta);
-unsigned int wifi_rom_update_basic_rate(unsigned char *ptn, unsigned int ptn_sz);
-unsigned int wifi_rom_update_supported_rate(unsigned char *ptn, unsigned int ptn_sz);
-unsigned int wifi_rom_update_mcs_rate(struct HT_caps_element *pHT_caps);
-int wifi_rom_cckrates_included(unsigned char *rate, int ratelen);
-int wifi_rom_cckratesonly_included(unsigned char *rate, int ratelen);
-unsigned int wifi_rom_ratetbl2rateset(u8 datarate[], u8 basicrate[], unsigned char *rateset);
-void wifi_rom_HT_caps_handler(struct HT_caps_element *HT_caps, PNDIS_802_11_VARIABLE_IEs pIE);
-
-void set_sta_rate(_adapter *padapter, struct sta_info *psta);
-
-unsigned int receive_disconnect(_adapter *padapter, unsigned char *MacAddr, unsigned short reason);
-
-unsigned char wifi_rom_get_highest_rateidx(u32 mask);
-int support_short_GI(_adapter *padapter, struct HT_caps_element *pHT_caps, u8 bwmode);
-unsigned int is_ap_in_tkip(_adapter *padapter);
-unsigned int is_ap_in_wep(_adapter *padapter);
-unsigned int should_forbid_n_rate(_adapter *padapter);
-
-void report_join_res(_adapter *padapter, int res);
-void rtw_scan_one_beacon_report(_adapter *padapter, union recv_frame *precv_frame);
-void report_surveydone_event(_adapter *padapter);
-void report_del_sta_event(_adapter *padapter, unsigned char *MacAddr, unsigned short reason);
-void report_add_sta_event(_adapter *padapter, unsigned char *MacAddr, int cam_idx);
-
-void beacon_timing_control(_adapter *padapter);
-extern u8 set_tx_beacon_cmd(_adapter *padapter);
-unsigned int setup_beacon_frame(_adapter *padapter, unsigned char *beacon_frame);
-
-void start_clnt_assoc(_adapter *padapter);
-void start_clnt_auth(_adapter *padapter);
-void start_clnt_join(_adapter *padapter);
-
-void mlmeext_joinbss_event_callback(_adapter *padapter, int join_res);
-void mlmeext_sta_del_event_callback(_adapter *padapter);
-void mlmeext_sta_add_event_callback(_adapter *padapter, struct sta_info *psta);
-
-void linked_status_chk(_adapter *padapter);
-
-void rtw_scan_timer_hdl(void *FunctionContext);
-void link_timer_hdl(void *FunctionContext);
-
-#define set_survey_timer(mlmeext, ms) \
-	do { \
-		rtw_set_timer(&(mlmeext)->survey_timer, (ms)); \
-	} while(0)
-
-#define set_link_timer(mlmeext, ms) \
-	do { \
-		rtw_set_timer(&(mlmeext)->link_timer, (ms)); \
-	} while(0)
-
-#ifdef CONFIG_CONCURRENT_MODE
-sint check_buddy_mlmeinfo_state(_adapter *padapter, u32 state);
-void concurrent_chk_joinbss_done(_adapter *padapter, int join_res);
-#endif //CONFIG_CONCURRENT_MODE
-
-#ifdef CONFIG_PLATFORM_ARM_SUN8I
-#define BUSY_TRAFFIC_SCAN_DENY_PERIOD	8000
-#else
-#define BUSY_TRAFFIC_SCAN_DENY_PERIOD	12000
-#endif
-
-extern u8 _rtw_free_stainfo_hdl(_adapter *padapter, unsigned char *pbuf);
-
-#if CONFIG_AUTO_RECONNECT
-extern void reconnect_timer_hdl(void *FunctionContext);
-#endif
-
-extern void csa_timer_hdl(void *FunctionContext);
-extern void csa_process(_adapter *padapter, u8 new_ch_no, u8 new_ch_count);
-
-#endif
-
diff --git a/os/board/rtl8720e/src/component/wifi/driver/include/rtw_mp.h b/os/board/rtl8720e/src/component/wifi/driver/include/rtw_mp.h
deleted file mode 100644
index bdd238f49..000000000
--- a/os/board/rtl8720e/src/component/wifi/driver/include/rtw_mp.h
+++ /dev/null
@@ -1,820 +0,0 @@
-/******************************************************************************
- *
- * Copyright(c) 2007 - 2012 Realtek Corporation. All rights reserved.
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of version 2 of the GNU General Public License as
- * published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
- * more details.
- *
- * You should have received a copy of the GNU General Public License along with
- * this program; if not, write to the Free Software Foundation, Inc.,
- * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
- *
- *
- ******************************************************************************/
-#ifndef _RTW_MP_H_
-#define _RTW_MP_H_
-
-//	00 - Success
-//	11 - Error
-#define STATUS_SUCCESS				(0x00000000L)
-#define STATUS_PENDING				(0x00000103L)
-
-#define STATUS_UNSUCCESSFUL			(0xC0000001L)
-#define STATUS_INSUFFICIENT_RESOURCES		(0xC000009AL)
-#define STATUS_NOT_SUPPORTED			(0xC00000BBL)
-
-#define NDIS_STATUS_SUCCESS			((NDIS_STATUS)STATUS_SUCCESS)
-#define NDIS_STATUS_PENDING			((NDIS_STATUS)STATUS_PENDING)
-#define NDIS_STATUS_NOT_RECOGNIZED		((NDIS_STATUS)0x00010001L)
-#define NDIS_STATUS_NOT_COPIED			((NDIS_STATUS)0x00010002L)
-#define NDIS_STATUS_NOT_ACCEPTED		((NDIS_STATUS)0x00010003L)
-#define NDIS_STATUS_CALL_ACTIVE			((NDIS_STATUS)0x00010007L)
-
-#define NDIS_STATUS_FAILURE			((NDIS_STATUS)STATUS_UNSUCCESSFUL)
-#define NDIS_STATUS_RESOURCES			((NDIS_STATUS)STATUS_INSUFFICIENT_RESOURCES)
-#define NDIS_STATUS_CLOSING			((NDIS_STATUS)0xC0010002L)
-#define NDIS_STATUS_BAD_VERSION			((NDIS_STATUS)0xC0010004L)
-#define NDIS_STATUS_BAD_CHARACTERISTICS		((NDIS_STATUS)0xC0010005L)
-#define NDIS_STATUS_ADAPTER_NOT_FOUND		((NDIS_STATUS)0xC0010006L)
-#define NDIS_STATUS_OPEN_FAILED			((NDIS_STATUS)0xC0010007L)
-#define NDIS_STATUS_DEVICE_FAILED		((NDIS_STATUS)0xC0010008L)
-#define NDIS_STATUS_MULTICAST_FULL		((NDIS_STATUS)0xC0010009L)
-#define NDIS_STATUS_MULTICAST_EXISTS		((NDIS_STATUS)0xC001000AL)
-#define NDIS_STATUS_MULTICAST_NOT_FOUND		((NDIS_STATUS)0xC001000BL)
-#define NDIS_STATUS_REQUEST_ABORTED		((NDIS_STATUS)0xC001000CL)
-#define NDIS_STATUS_RESET_IN_PROGRESS		((NDIS_STATUS)0xC001000DL)
-#define NDIS_STATUS_CLOSING_INDICATING		((NDIS_STATUS)0xC001000EL)
-#define NDIS_STATUS_NOT_SUPPORTED		((NDIS_STATUS)STATUS_NOT_SUPPORTED)
-#define NDIS_STATUS_INVALID_PACKET		((NDIS_STATUS)0xC001000FL)
-#define NDIS_STATUS_OPEN_LIST_FULL		((NDIS_STATUS)0xC0010010L)
-#define NDIS_STATUS_ADAPTER_NOT_READY		((NDIS_STATUS)0xC0010011L)
-#define NDIS_STATUS_ADAPTER_NOT_OPEN		((NDIS_STATUS)0xC0010012L)
-#define NDIS_STATUS_NOT_INDICATING		((NDIS_STATUS)0xC0010013L)
-#define NDIS_STATUS_INVALID_LENGTH		((NDIS_STATUS)0xC0010014L)
-#define NDIS_STATUS_INVALID_DATA		((NDIS_STATUS)0xC0010015L)
-#define NDIS_STATUS_BUFFER_TOO_SHORT		((NDIS_STATUS)0xC0010016L)
-#define NDIS_STATUS_INVALID_OID			((NDIS_STATUS)0xC0010017L)
-#define NDIS_STATUS_ADAPTER_REMOVED		((NDIS_STATUS)0xC0010018L)
-#define NDIS_STATUS_UNSUPPORTED_MEDIA		((NDIS_STATUS)0xC0010019L)
-#define NDIS_STATUS_GROUP_ADDRESS_IN_USE	((NDIS_STATUS)0xC001001AL)
-#define NDIS_STATUS_FILE_NOT_FOUND		((NDIS_STATUS)0xC001001BL)
-#define NDIS_STATUS_ERROR_READING_FILE		((NDIS_STATUS)0xC001001CL)
-#define NDIS_STATUS_ALREADY_MAPPED		((NDIS_STATUS)0xC001001DL)
-#define NDIS_STATUS_RESOURCE_CONFLICT		((NDIS_STATUS)0xC001001EL)
-#define NDIS_STATUS_NO_CABLE			((NDIS_STATUS)0xC001001FL)
-
-#define NDIS_STATUS_INVALID_SAP			((NDIS_STATUS)0xC0010020L)
-#define NDIS_STATUS_SAP_IN_USE			((NDIS_STATUS)0xC0010021L)
-#define NDIS_STATUS_INVALID_ADDRESS		((NDIS_STATUS)0xC0010022L)
-#define NDIS_STATUS_VC_NOT_ACTIVATED		((NDIS_STATUS)0xC0010023L)
-#define NDIS_STATUS_DEST_OUT_OF_ORDER		((NDIS_STATUS)0xC0010024L)  // cause 27
-#define NDIS_STATUS_VC_NOT_AVAILABLE		((NDIS_STATUS)0xC0010025L)  // cause 35,45
-#define NDIS_STATUS_CELLRATE_NOT_AVAILABLE	((NDIS_STATUS)0xC0010026L)  // cause 37
-#define NDIS_STATUS_INCOMPATABLE_QOS		((NDIS_STATUS)0xC0010027L)  // cause 49
-#define NDIS_STATUS_AAL_PARAMS_UNSUPPORTED	((NDIS_STATUS)0xC0010028L)  // cause 93
-#define NDIS_STATUS_NO_ROUTE_TO_DESTINATION	((NDIS_STATUS)0xC0010029L)  // cause 3
-
-typedef enum _ANTENNA_PATH {
-	ANTENNA_NONE	= 0x00,
-	ANTENNA_D		,
-	ANTENNA_C		,
-	ANTENNA_CD		,
-	ANTENNA_B		,
-	ANTENNA_BD		,
-	ANTENNA_BC		,
-	ANTENNA_BCD 	,
-	ANTENNA_A		,
-	ANTENNA_AD		,
-	ANTENNA_AC		,
-	ANTENNA_ACD 	,
-	ANTENNA_AB		,
-	ANTENNA_ABD 	,
-	ANTENNA_ABC 	,
-	ANTENNA_ABCD
-} ANTENNA_PATH;
-
-
-#define MAX_MP_XMITBUF_SZ 	2048
-#define NR_MP_XMITFRAME		8
-
-struct mp_xmit_frame {
-	_list	list;
-
-	struct pkt_attrib attrib;
-
-	_pkt *pkt;
-
-	int frame_tag;
-
-	_adapter *padapter;
-
-	uint mem[(MAX_MP_XMITBUF_SZ >> 2)];
-};
-
-struct mp_wiparam {
-	u32 bcompleted;
-	u32 act_type;
-	u32 io_offset;
-	u32 io_value;
-};
-
-typedef void(*wi_act_func)(void *padapter);
-
-struct mp_tx {
-	u8 stop;
-	u32 count, sended;
-	u8 payload;
-	struct pkt_attrib attrib;
-	struct tx_desc desc;
-	u8 *pallocated_buf;
-	u8 *buf;
-	u32 buf_size, write_size;
-	//_thread_hdl_	PktTxThread;
-	struct task_struct	MpXmitThread;
-};
-
-#define MP_MAX_LINES		1000
-#define MP_MAX_LINES_BYTES	256
-
-typedef struct _RT_PMAC_PKT_INFO {
-	UCHAR			MCS;
-	UCHAR			Nss;
-	UCHAR			Nsts;
-	UINT			N_sym;
-	UCHAR			SIGA2B3;
-	UCHAR			PPDU_Type;
-	UCHAR			HE_ERSU_RU106;
-} RT_PMAC_PKT_INFO, *PRT_PMAC_PKT_INFO;
-
-typedef struct _RT_PMAC_TX_INFO {
-	u8			bEnPMacTx: 1;		/* 0: Disable PMac 1: Enable PMac */
-	u8			Mode: 3;				/* 0: Packet TX 3:Continuous TX */
-	u8			Ntx: 4;				/* 0-7 */
-	u16			TX_RATE;			/* MPT_RATE_E */
-	u16			TX_RATE_HEX;
-	u8			TX_SC;
-	u8			bSGI: 1;
-	u8			bSPreamble: 1;
-	u8			bSTBC: 1;
-	u8			bLDPC: 1;
-	u8			NDP_sound: 1;
-	u8			BandWidth: 3;		/* 0: 20 1:40 2:80Mhz */
-	u8			m_STBC;			/* bSTBC + 1 */
-	u16			PacketPeriod;
-	u32			PacketCount;
-	u32			PacketLength;
-	u8			PacketPattern;
-	u16			SFD;
-	u8			SignalField;
-	u8			ServiceField;
-	u16			LENGTH;
-	u8			CRC16[2];
-	u8			LSIG[3];
-	u8			HT_SIG[6];
-	u8			VHT_SIG_A[6];
-	u8			VHT_SIG_B[4];
-	u8			VHT_SIG_B_CRC;
-	u8			VHT_Delimiter[4];
-	u8			MacAddress[6];
-	u16			RU_Alloc;
-} RT_PMAC_TX_INFO, *PRT_PMAC_TX_INFO;
-
-typedef void (*MPT_WORK_ITEM_HANDLER)(IN void *Adapter);
-typedef struct _MPT_CONTEXT {
-	// Indicate if we have started Mass Production Test.
-	BOOLEAN			bMassProdTest;
-
-	// Indicate if the driver is unloading or unloaded.
-	BOOLEAN			bMptDrvUnload;
-
-	_sema			MPh2c_Sema;
-	_timer			MPh2c_timeout_timer;
-// Event used to sync H2c for BT control
-
-	BOOLEAN		MptH2cRspEvent;
-	BOOLEAN		MptBtC2hEvent;
-	BOOLEAN		bMPh2c_timeout;
-
-	/* 8190 PCI does not support NDIS_WORK_ITEM. */
-	// Work Item for Mass Production Test.
-	//NDIS_WORK_ITEM	MptWorkItem;
-//	RT_WORK_ITEM		MptWorkItem;
-	// Event used to sync the case unloading driver and MptWorkItem is still in progress.
-//	NDIS_EVENT		MptWorkItemEvent;
-	// To protect the following variables.
-//	NDIS_SPIN_LOCK		MptWorkItemSpinLock;
-	// Indicate a MptWorkItem is scheduled and not yet finished.
-	BOOLEAN			bMptWorkItemInProgress;
-	// An instance which implements function and context of MptWorkItem.
-	MPT_WORK_ITEM_HANDLER	CurrMptAct;
-
-	// 1=Start, 0=Stop from UI.
-	u32			MptTestStart;
-	// _TEST_MODE, defined in MPT_Req2.h
-	u32			MptTestItem;
-	// Variable needed in each implementation of CurrMptAct.
-	u32			MptActType; 	// Type of action performed in CurrMptAct.
-	// The Offset of IO operation is depend of MptActType.
-	u32			MptIoOffset;
-	// The Value of IO operation is depend of MptActType.
-	u32			MptIoValue;
-	// The RfPath of IO operation is depend of MptActType.
-	u32			MptRfPath;
-
-	WIRELESS_MODE		MptWirelessModeToSw;	// Wireless mode to switch.
-	u8			MptChannelToSw; 	// Channel to switch.
-	u8			MptInitGainToSet; 	// Initial gain to set.
-	//u32			bMptAntennaA; 		// TRUE if we want to use antenna A.
-	u32			MptBandWidth;		// bandwidth to switch.
-	u32			MptRateIndex;		// rate index.
-	// Register value kept for Single Carrier Tx test.
-	u8			btMpCckTxPower;
-	// Register value kept for Single Carrier Tx test.
-	u8			btMpOfdmTxPower;
-	// For MP Tx Power index
-	u8			TxPwrLevel[2];	// rf-A, rf-B
-
-	// Content of RCR Regsiter for Mass Production Test.
-	u32			MptRCR;
-	// TRUE if we only receive packets with specific pattern.
-	BOOLEAN			bMptFilterPattern;
-	// Rx OK count, statistics used in Mass Production Test.
-	u32			MptRxOkCnt;
-	// Rx CRC32 error count, statistics used in Mass Production Test.
-	u32			MptRxCrcErrCnt;
-
-	BOOLEAN			bCckContTx;	// TRUE if we are in CCK Continuous Tx test.
-	BOOLEAN			bOfdmContTx;	// TRUE if we are in OFDM Continuous Tx test.
-	BOOLEAN			bStartContTx; 	// TRUE if we have start Continuous Tx test.
-	// TRUE if we are in Single Carrier Tx test.
-	BOOLEAN			bSingleCarrier;
-	// TRUE if we are in Carrier Suppression Tx Test.
-	BOOLEAN			bCarrierSuppression;
-	//TRUE if we are in Single Tone Tx test.
-	BOOLEAN			bSingleTone;
-
-	// ACK counter asked by K.Y..
-	BOOLEAN			bMptEnableAckCounter;
-	u32			MptAckCounter;
-
-	// SD3 Willis For 8192S to save 1T/2T RF table for ACUT	Only fro ACUT delete later ~~~!
-	//s8		BufOfLines[2][MAX_LINES_HWCONFIG_TXT][MAX_BYTES_LINE_HWCONFIG_TXT];
-	//s8			BufOfLines[2][MP_MAX_LINES][MP_MAX_LINES_BYTES];
-	//s32			RfReadLine[2];
-
-	u8		APK_bound[2];	//for APK	path A/path B
-	BOOLEAN		bMptIndexEven;
-
-	u8			h2cReqNum;
-	u8			c2hBuf[20];
-
-	u8          btInBuf[100];
-	u32			mptOutLen;
-	u8          mptOutBuf[100];
-#if defined(CONFIG_RTL8195B) || defined(CONFIG_RTL8710C) || defined(CONFIG_RTL8730A) || defined(CONFIG_RTL8735B) || defined(CONFIG_RTL8720E) || defined(CONFIG_RTL8730E)
-	RT_PMAC_TX_INFO		PMacTxInfo;
-	RT_PMAC_PKT_INFO	PMacPktInfo;
-#endif
-} MPT_CONTEXT, *PMPT_CONTEXT;
-//#endif
-
-//#define RTPRIV_IOCTL_MP 					( SIOCIWFIRSTPRIV + 0x17)
-enum {
-	WRITE_REG = 1,
-	READ_REG,
-	WRITE_RF,
-	READ_RF,
-	WRITE_SYS,
-	READ_SYS,
-	MP_START,
-	MP_STOP,
-	MP_RATE,
-	MP_CHANNEL,
-	MP_BANDWIDTH,
-	MP_TXPOWER,
-	MP_RXPATH,
-	MP_ANT_TX,
-	MP_ANT_RX,
-	MP_CTX,
-	MP_HW_TX,
-	MP_QUERY,
-	MP_ARX,
-	MP_PSD,
-	MP_PWRTRK,
-	MP_THER,
-	MP_IOCTL,
-	EFUSE_GET,
-	EFUSE_SET,
-	CONFIG_GET,
-	CONFIG_SET,
-	MP_RESET_STATS,
-	MP_DUMP,
-	MP_PHYPARA,
-	MP_SetRFPathSwh,
-	MP_QueryDrvStats,
-	MP_SetBT,
-	TEST_CFG,
-	MP_NULL,
-	MP_GET_TXPOWER_INX,
-	MP_SET_PREAMBLE,
-	MP_DISABLE_BT_COEXIST,
-	MP_PwrCtlDM,
-	MP_IQK,
-	MP_LCK,
-	MP_DPK,
-	MP_GET_TSSIDE,
-	MP_SET_TSSIDE,
-	MP_PHYDM,
-	MP_TX_PLCP_USER,
-	MP_TX_PLCP_DATA
-};
-
-struct mp_priv {
-	_adapter *papdater;
-
-	//Testing Flag
-	u32 mode;//0 for normal type packet, 1 for loopback packet (16bytes TXCMD)
-
-	u32 prev_fw_state;
-
-	//OID cmd handler
-	struct mp_wiparam workparam;
-//	u8 act_in_progress;
-
-	//Tx Section
-	u8 TID;
-	u32 tx_pktcount;
-	u32 pktInterval;
-	struct mp_tx tx;
-
-	//Rx Section
-	u8 rx_pkt_by_mac;
-	u32 rx_pktcount;
-	u32 rx_crcerrpktcount;
-	u32 rx_macpktcount;
-	u32 rx_pktloss;
-
-	struct recv_stat rxstat;
-
-	//RF/BB relative
-	u8 channel;
-	u8 do_dpk;
-	u8 bandwidth;
-	u8 prime_channel_offset;
-	u8 txpoweridx;
-	u8 txpoweridx_b;
-	u8 rateidx; /*in MGN_RATE format */
-	u32 preamble;
-//	u8 modem;
-	u32 CrystalCap;
-//	u32 curr_crystalcap;
-
-	u16 antenna_tx;
-	u16 antenna_rx;
-//	u8 curr_rfpath;
-
-	/* add for support pmac tx: start */
-	u8 ppdu_type;  //0:cck;1:legacy;2:ht_mf;3:ht_gf;4:vht;5:he_su;6:he_er_su;7:he_mu_ofdma;8:he_tb
-	u8 er_su_ru_106_en;  //he_er_su:0-242tone;1-106tone
-	u16 ru_alloc;
-	/* add for support pmac tx: end */
-
-	u8 check_mp_pkt;
-	u32 rssi_avg_cal;
-	u32 rssi_avg;
-	u32 rssi_count;
-
-	u8 bSetTxPower;
-	u8 bCCKTxPowerAdjust;
-	u8 bFAStatistics;
-	u8 mp_dm;
-	struct wlan_network mp_network;
-	NDIS_802_11_MAC_ADDRESS network_macaddr;
-
-	u8 *pallocated_mp_xmitframe_buf;
-	u8 *pmp_xmtframe_buf;
-	_queue free_mp_xmitqueue;
-	u32 free_mp_xmitframe_cnt;
-
-	MPT_CONTEXT MptCtx;
-};
-
-typedef struct _IOCMD_STRUCT_ {
-	u8	cmdclass;
-	u16	value;
-	u8	index;
-} IOCMD_STRUCT;
-
-struct rf_reg_param {
-	u32 path;
-	u32 offset;
-	u32 value;
-};
-
-struct bb_reg_param {
-	u32 offset;
-	u32 value;
-};
-//=======================================================================
-
-#define LOWER 	_TRUE
-#define RAISE	_FALSE
-
-/* Hardware Registers */
-#if 0
-#if 0
-#define IOCMD_CTRL_REG			0x102502C0
-#define IOCMD_DATA_REG			0x102502C4
-#else
-#define IOCMD_CTRL_REG			0x10250370
-#define IOCMD_DATA_REG			0x10250374
-#endif
-
-#define IOCMD_GET_THERMAL_METER		0xFD000028
-
-#define IOCMD_CLASS_BB_RF		0xF0
-#define IOCMD_BB_READ_IDX		0x00
-#define IOCMD_BB_WRITE_IDX		0x01
-#define IOCMD_RF_READ_IDX		0x02
-#define IOCMD_RF_WRIT_IDX		0x03
-#endif
-#define BB_REG_BASE_ADDR		0x800
-
-/* MP variables */
-#if 0
-#define _2MAC_MODE_	0
-#define _LOOPBOOK_MODE_	1
-#endif
-typedef enum _MP_MODE_ {
-	MP_OFF,
-	MP_ON,
-	MP_ERR,
-	MP_CONTINUOUS_TX,
-	MP_SINGLE_CARRIER_TX,
-	MP_CARRIER_SUPPRISSION_TX,
-	MP_SINGLE_TONE_TX,
-	MP_PACKET_TX,
-	MP_PACKET_RX
-} MP_MODE;
-
-typedef enum _TEST_MODE {
-	TEST_NONE,
-	PACKETS_TX,
-	PACKETS_RX,
-	CONTINUOUS_TX,
-	OFDM_Single_Tone_TX,
-	CCK_Carrier_Suppression_TX
-} TEST_MODE;
-
-#define MAX_RF_PATH_NUMS	MAX_RF_PATH
-
-
-extern u8 mpdatarate[NumRates];
-
-/* MP set force data rate base on the definition. */
-typedef enum _MPT_RATE_INDEX {
-	/* CCK rate. */
-	MPT_RATE_1M,	/* 0 */
-	MPT_RATE_2M,
-	MPT_RATE_55M,
-	MPT_RATE_11M,	/* 3 */
-
-	/* OFDM rate. */
-	MPT_RATE_6M,	/* 4 */
-	MPT_RATE_9M,
-	MPT_RATE_12M,
-	MPT_RATE_18M,
-	MPT_RATE_24M,
-	MPT_RATE_36M,
-	MPT_RATE_48M,
-	MPT_RATE_54M,	/* 11 */
-
-	/* HT rate. */
-	MPT_RATE_MCS0,	/* 12 */
-	MPT_RATE_MCS1,
-	MPT_RATE_MCS2,
-	MPT_RATE_MCS3,
-	MPT_RATE_MCS4,
-	MPT_RATE_MCS5,
-	MPT_RATE_MCS6,
-	MPT_RATE_MCS7,	/* 19 */
-	MPT_RATE_MCS8,
-	MPT_RATE_MCS9,
-	MPT_RATE_MCS10,
-	MPT_RATE_MCS11,
-	MPT_RATE_MCS12,
-	MPT_RATE_MCS13,
-	MPT_RATE_MCS14,
-	MPT_RATE_MCS15,	/* 27 */
-	MPT_RATE_MCS16,
-	MPT_RATE_MCS17, // #29
-	MPT_RATE_MCS18,
-	MPT_RATE_MCS19,
-	MPT_RATE_MCS20,
-	MPT_RATE_MCS21,
-	MPT_RATE_MCS22, // #34
-	MPT_RATE_MCS23,
-	MPT_RATE_MCS24,
-	MPT_RATE_MCS25,
-	MPT_RATE_MCS26,
-	MPT_RATE_MCS27, // #39
-	MPT_RATE_MCS28, // #40
-	MPT_RATE_MCS29, // #41
-	MPT_RATE_MCS30, // #42
-	MPT_RATE_MCS31, // #43
-
-	/* VHT rate. Total: 20*/
-	MPT_RATE_VHT1SS_MCS0 = 100,//  #44
-	MPT_RATE_VHT1SS_MCS1, // #
-	MPT_RATE_VHT1SS_MCS2,
-	MPT_RATE_VHT1SS_MCS3,
-	MPT_RATE_VHT1SS_MCS4,
-	MPT_RATE_VHT1SS_MCS5,
-	MPT_RATE_VHT1SS_MCS6, // #
-	MPT_RATE_VHT1SS_MCS7,
-	MPT_RATE_VHT1SS_MCS8,
-	MPT_RATE_VHT1SS_MCS9, //#53
-	MPT_RATE_VHT2SS_MCS0, /* #54 */
-	MPT_RATE_VHT2SS_MCS1,
-	MPT_RATE_VHT2SS_MCS2,
-	MPT_RATE_VHT2SS_MCS3,
-	MPT_RATE_VHT2SS_MCS4,
-	MPT_RATE_VHT2SS_MCS5,
-	MPT_RATE_VHT2SS_MCS6,
-	MPT_RATE_VHT2SS_MCS7,
-	MPT_RATE_VHT2SS_MCS8,
-	MPT_RATE_VHT2SS_MCS9, /* #63 */
-	MPT_RATE_VHT3SS_MCS0,
-	MPT_RATE_VHT3SS_MCS1,
-	MPT_RATE_VHT3SS_MCS2,
-	MPT_RATE_VHT3SS_MCS3,
-	MPT_RATE_VHT3SS_MCS4,
-	MPT_RATE_VHT3SS_MCS5,
-	MPT_RATE_VHT3SS_MCS6, /*  #126 */
-	MPT_RATE_VHT3SS_MCS7,
-	MPT_RATE_VHT3SS_MCS8,
-	MPT_RATE_VHT3SS_MCS9,
-	MPT_RATE_VHT4SS_MCS0,
-	MPT_RATE_VHT4SS_MCS1, /*  #131 */
-	MPT_RATE_VHT4SS_MCS2,
-	MPT_RATE_VHT4SS_MCS3,
-	MPT_RATE_VHT4SS_MCS4,
-	MPT_RATE_VHT4SS_MCS5,
-	MPT_RATE_VHT4SS_MCS6, /*  #136 */
-	MPT_RATE_VHT4SS_MCS7,
-	MPT_RATE_VHT4SS_MCS8,
-	MPT_RATE_VHT4SS_MCS9,
-	MPT_RATE_HE1SS_MCS0,
-	MPT_RATE_HE1SS_MCS1,
-	MPT_RATE_HE1SS_MCS2,
-	MPT_RATE_HE1SS_MCS3,
-	MPT_RATE_HE1SS_MCS4,
-	MPT_RATE_HE1SS_MCS5,
-	MPT_RATE_HE1SS_MCS6,
-	MPT_RATE_HE1SS_MCS7,
-	MPT_RATE_HE1SS_MCS8,
-	MPT_RATE_HE1SS_MCS9,
-	MPT_RATE_HE1SS_MCS10,
-	MPT_RATE_HE1SS_MCS11,/* 151 */
-	MPT_RATE_LAST
-} MPT_RATE_E, *PMPT_RATE_E;
-
-#define MAX_TX_PWR_INDEX_N_MODE 64	// 0x3F
-
-typedef enum _POWER_MODE_ {
-	POWER_LOW = 0,
-	POWER_NORMAL
-} POWER_MODE;
-
-
-#define RX_PKT_BROADCAST	1
-#define RX_PKT_DEST_ADDR	2
-#define RX_PKT_PHY_MATCH	3
-
-#if 0
-#define RPTMaxCount 0x000FFFFF;
-
-// parameter 1 : BitMask
-// 	bit 0  : OFDM PPDU
-//	bit 1  : OFDM False Alarm
-//	bit 2  : OFDM MPDU OK
-//	bit 3  : OFDM MPDU Fail
-//	bit 4  : CCK PPDU
-//	bit 5  : CCK False Alarm
-//	bit 6  : CCK MPDU ok
-//	bit 7  : CCK MPDU fail
-//	bit 8  : HT PPDU counter
-//	bit 9  : HT false alarm
-//	bit 10 : HT MPDU total
-//	bit 11 : HT MPDU OK
-//	bit 12 : HT MPDU fail
-//	bit 15 : RX full drop
-typedef enum _RXPHY_BITMASK_ {
-	OFDM_PPDU_BIT = 0,
-	OFDM_FALSE_BIT,
-	OFDM_MPDU_OK_BIT,
-	OFDM_MPDU_FAIL_BIT,
-	CCK_PPDU_BIT,
-	CCK_FALSE_BIT,
-	CCK_MPDU_OK_BIT,
-	CCK_MPDU_FAIL_BIT,
-	HT_PPDU_BIT,
-	HT_FALSE_BIT,
-	HT_MPDU_BIT,
-	HT_MPDU_OK_BIT,
-	HT_MPDU_FAIL_BIT,
-} RXPHY_BITMASK;
-#endif
-
-typedef enum _ENCRY_CTRL_STATE_ {
-	HW_CONTROL,		//hw encryption& decryption
-	SW_CONTROL,		//sw encryption& decryption
-	HW_ENCRY_SW_DECRY,	//hw encryption & sw decryption
-	SW_ENCRY_HW_DECRY	//sw encryption & hw decryption
-} ENCRY_CTRL_STATE;
-
-typedef enum _PREAMBLE {
-	Long_Preamble	= 0x01,
-	Short_Preamble		,
-	Long_GI 			,
-	Short_GI
-} PREAMBLE;
-
-typedef enum	_MPT_TXPWR_DEF {
-	MPT_CCK,
-	MPT_OFDM, // L and HT OFDM
-	MPT_OFDM_AND_HT,
-	MPT_HT,
-	MPT_VHT
-} MPT_TXPWR_DEF;
-
-typedef enum _OFDM_TX_MODE {
-	OFDM_ALL_OFF		= 0,
-	OFDM_ContinuousTx	= 1,
-	OFDM_SingleCarrier	= 2,
-	OFDM_SingleTone 	= 4,
-} OFDM_TX_MODE;
-
-typedef enum _MP_PPDU_TYPE {
-	RTW_MP_TYPE_CCK = 0,
-	RTW_MP_TYPE_LEGACY,
-	RTW_MP_TYPE_HT_MF,
-	RTW_MP_TYPE_HT_GF,
-	RTW_MP_TYPE_VHT,
-	RTW_MP_TYPE_HE_SU,
-	RTW_MP_TYPE_HE_ER_SU,
-	RTW_MP_TYPE_HE_MU_OFDMA,
-	RTW_MP_TYPE_HE_TB
-} PPDU_TYPE;
-
-#define PPDU_TYPE_STR(idx)\
-	(idx == RTW_MP_TYPE_CCK) ? "CCK" :\
-	(idx == RTW_MP_TYPE_LEGACY) ? "LEGACY" :\
-	(idx == RTW_MP_TYPE_HT_MF) ? "HT_MF" :\
-	(idx == RTW_MP_TYPE_HT_GF) ? "HT_GF" :\
-	(idx == RTW_MP_TYPE_VHT) ? "VHT" :\
-	(idx == RTW_MP_TYPE_HE_SU) ? "HE_SU" :\
-	(idx == RTW_MP_TYPE_HE_ER_SU) ? "HE_ER_SU" :\
-	(idx == RTW_MP_TYPE_HE_MU_OFDMA) ? "HE_MU" :\
-	(idx == RTW_MP_TYPE_HE_TB) ? "HE_TB" :\
-	"UNknow"
-
-#define MPT_IS_CCK_RATE(_value)		(MPT_RATE_1M <= _value && _value <= MPT_RATE_11M)
-#define MPT_IS_OFDM_RATE(_value)	(MPT_RATE_6M <= _value && _value <= MPT_RATE_54M)
-#define MPT_IS_HT_RATE(_value)		(MPT_RATE_MCS0 <= _value && _value <= MPT_RATE_MCS31)
-#define MPT_IS_HT_1S_RATE(_value)	(MPT_RATE_MCS0 <= _value && _value <= MPT_RATE_MCS7)
-#define MPT_IS_HT_2S_RATE(_value)	(MPT_RATE_MCS8 <= _value && _value <= MPT_RATE_MCS15)
-#define MPT_IS_HT_3S_RATE(_value)	(MPT_RATE_MCS16 <= _value && _value <= MPT_RATE_MCS23)
-#define MPT_IS_HT_4S_RATE(_value)	(MPT_RATE_MCS24 <= _value && _value <= MPT_RATE_MCS31)
-
-#define MPT_IS_VHT_RATE(_value)		(MPT_RATE_VHT1SS_MCS0 <= _value && _value <= MPT_RATE_VHT4SS_MCS9)
-#define MPT_IS_VHT_1S_RATE(_value)	(MPT_RATE_VHT1SS_MCS0 <= _value && _value <= MPT_RATE_VHT1SS_MCS9)
-#define MPT_IS_VHT_2S_RATE(_value)	(MPT_RATE_VHT2SS_MCS0 <= _value && _value <= MPT_RATE_VHT2SS_MCS9)
-#define MPT_IS_VHT_3S_RATE(_value)	(MPT_RATE_VHT3SS_MCS0 <= _value && _value <= MPT_RATE_VHT3SS_MCS9)
-#define MPT_IS_VHT_4S_RATE(_value)	(MPT_RATE_VHT4SS_MCS0 <= _value && _value <= MPT_RATE_VHT4SS_MCS9)
-
-#define MPT_IS_HE_1S_RATE(_value)	(MPT_RATE_HE1SS_MCS0 <= _value && _value <= MPT_RATE_HE1SS_MCS11)
-
-#define MPT_IS_2SS_RATE(_rate) ((MPT_RATE_MCS8 <= _rate && _rate <= MPT_RATE_MCS15) || \
-	(MPT_RATE_VHT2SS_MCS0 <= _rate && _rate <= MPT_RATE_VHT2SS_MCS9))
-#define MPT_IS_3SS_RATE(_rate) ((MPT_RATE_MCS16 <= _rate && _rate <= MPT_RATE_MCS23) || \
-	(MPT_RATE_VHT3SS_MCS0 <= _rate && _rate <= MPT_RATE_VHT3SS_MCS9))
-#define MPT_IS_4SS_RATE(_rate) ((MPT_RATE_MCS24 <= _rate && _rate <= MPT_RATE_MCS31) || \
-	(MPT_RATE_VHT4SS_MCS0 <= _rate && _rate <= MPT_RATE_VHT4SS_MCS9))
-
-//=======================================================================
-//extern struct mp_xmit_frame *alloc_mp_xmitframe(struct mp_priv *pmp_priv);
-//extern int free_mp_xmitframe(struct xmit_priv *pxmitpriv, struct mp_xmit_frame *pmp_xmitframe);
-
-extern s32 init_mp_priv(_adapter *padapter);
-extern void free_mp_priv(struct mp_priv *pmp_priv);
-extern s32 wifi_hal_mp_init(_adapter *padapter, u8 Channel);
-extern void MPT_DeInitAdapter(_adapter *padapter);
-extern s32 mp_start_test(_adapter *padapter);
-extern void mp_stop_test(_adapter *padapter);
-
-//=======================================================================
-//extern void	IQCalibrateBcut(_adapter * pAdapter);
-
-//extern u32	bb_reg_read(_adapter * Adapter, u16 offset);
-//extern u8	bb_reg_write(_adapter * Adapter, u16 offset, u32 value);
-//extern u32	rf_reg_read(_adapter * Adapter, u8 path, u8 offset);
-//extern u8	rf_reg_write(_adapter * Adapter, u8 path, u8 offset, u32 value);
-
-//extern u32	get_bb_reg(_adapter * Adapter, u16 offset, u32 bitmask);
-//extern u8	set_bb_reg(_adapter * Adapter, u16 offset, u32 bitmask, u32 value);
-//extern u32	get_rf_reg(_adapter * Adapter, u8 path, u8 offset, u32 bitmask);
-//extern u8	set_rf_reg(_adapter * Adapter, u8 path, u8 offset, u32 bitmask, u32 value);
-
-extern u32 _read_rfreg(_adapter *padapter, u8 rfpath, u32 addr, u32 bitmask);
-extern void _write_rfreg(_adapter *padapter, u8 rfpath, u32 addr, u32 bitmask, u32 val);
-
-extern u32 read_macreg(_adapter *padapter, u32 addr, u32 sz);
-extern void write_macreg(_adapter *padapter, u32 addr, u32 val, u32 sz);
-extern u32 read_bbreg(_adapter *padapter, u32 addr, u32 bitmask);
-extern void write_bbreg(_adapter *padapter, u32 addr, u32 bitmask, u32 val);
-extern u32 read_rfreg(_adapter *padapter, u8 rfpath, u32 addr);
-extern void write_rfreg(_adapter *padapter, u8 rfpath, u32 addr, u32 val);
-
-extern void wifi_hal_mp_resetbb(_adapter *pAdapter);
-extern void wifi_hal_mp_settxedca(_adapter *pAdapter);
-extern void wifi_hal_mp_rx_cca(_adapter *pAdapter, bool cca_en);
-extern int wifi_hal_mp_arx(struct net_device *dev, struct rtw_point *wrqu);
-extern void wifi_hal_mp_txdesc(PADAPTER adapter, struct mp_priv *pmp_priv);
-extern void wifi_hal_mp_dump(_adapter *padapter, u32 column);
-extern void wifi_hal_mp_rx_filter(_adapter *padapter);
-extern void wifi_hal_mp_dpk(struct net_device *dev, struct rtw_point *wrqu);
-extern void PHY_SetRFPathSwitch(PADAPTER pAdapter, BOOLEAN is_main);
-
-extern void	SetChannel(_adapter *pAdapter);
-extern void	SetBandwidth(_adapter *pAdapter);
-extern void	SetTxPower(_adapter *pAdapter);
-extern void	SetAntennaPathPower(_adapter *pAdapter);
-//extern void	SetTxAGCOffset(_adapter * pAdapter, u32 ulTxAGCOffset);
-extern void	SetDataRate(_adapter *pAdapter);
-
-extern void	SetAntenna(_adapter *pAdapter);
-
-//extern void	SetCrystalCap(_adapter * pAdapter);
-
-extern s32	SetThermalMeter(_adapter *pAdapter, u8 target_ther);
-extern void	GetThermalMeter(_adapter *pAdapter, u8 *value);
-
-extern void	SetContinuousTx(_adapter *pAdapter, u8 bStart);
-extern void	SetSingleCarrierTx(_adapter *pAdapter, u8 bStart);
-extern void	SetSingleToneTx(_adapter *pAdapter, u8 bStart);
-extern void	SetCarrierSuppressionTx(_adapter *pAdapter, u8 bStart);
-extern void PhySetTxPowerLevel(_adapter *pAdapter);
-
-extern void	fill_txdesc_for_mp(_adapter *padapter, struct tx_desc *ptxdesc);
-extern void	SetPacketTx(_adapter *padapter);
-extern void	SetPacketRx(_adapter *pAdapter, u8 bStartRx);
-
-extern void	ResetPhyRxPktCount(_adapter *pAdapter);
-extern u32	GetPhyRxPktReceived(_adapter *pAdapter);
-extern u32	GetPhyRxPktCRC32Error(_adapter *pAdapter);
-
-extern s32	SetPowerTracking(_adapter *padapter, u8 enable);
-extern void	GetPowerTracking(_adapter *padapter, u8 *enable);
-
-extern u32	wifi_hal_mp_query_psd(_adapter *pAdapter, u8 *data, int data_len);
-extern void wifi_hal_mp_crystal_cap(_adapter *pAdapter, u32 CrystalCapVal);
-
-
-extern void Hal_SetAntenna(_adapter *pAdapter);
-extern void Hal_SetBandwidth(_adapter *pAdapter);
-
-extern void Hal_SetTxPower(_adapter *pAdapter);
-extern void Hal_SetCarrierSuppressionTx(_adapter *pAdapter, u8 bStart);
-extern void Hal_SetSingleToneTx(_adapter *pAdapter, u8 bStart);
-extern void Hal_SetSingleCarrierTx(_adapter *pAdapter, u8 bStart);
-extern void Hal_SetContinuousTx(_adapter *pAdapter, u8 bStart);
-extern void Hal_SetBandwidth(_adapter *pAdapter);
-
-extern void Hal_SetDataRate(_adapter *pAdapter);
-extern void Hal_SetChannel(_adapter *pAdapter);
-extern void Hal_SetAntennaPathPower(_adapter *pAdapter);
-extern s32 Hal_SetThermalMeter(_adapter *pAdapter, u8 target_ther);
-extern s32 Hal_SetPowerTracking(_adapter *padapter, u8 enable);
-extern void Hal_GetPowerTracking(_adapter *padapter, u8 *enable);
-extern void Hal_GetThermalMeter(_adapter *pAdapter, u8 *value);
-extern void Hal_mpt_SwitchRfSetting(_adapter *pAdapter);
-extern void Hal_MPT_CCKTxPowerAdjust(_adapter *Adapter);
-extern void Hal_MPT_CCKTxPowerAdjustbyIndex(_adapter *pAdapter, BOOLEAN beven);
-extern void Hal_TriggerRFThermalMeter(_adapter *pAdapter);
-extern u8 Hal_ReadRFThermalMeter(_adapter *pAdapter);
-extern void Hal_SetCCKContinuousTx(_adapter *pAdapter, u8 bStart);
-extern void Hal_SetOFDMContinuousTx(_adapter *pAdapter, u8 bStart);
-extern void _rtw_mp_xmit_priv(struct xmit_priv *pxmitpriv);
-extern void MP_PHY_SetRFPathSwitch(_adapter *pAdapter, BOOLEAN bMain);
-extern u32 mpt_ProQueryCalTxPower(_adapter *pAdapter, u8 RfPath);
-extern void MPT_PwrCtlDM(PADAPTER padapter, u32 bstart);
-extern u8 MgntRateToMPTRate(u8 rate);
-#endif //_RTW_MP_H_
-
diff --git a/os/board/rtl8720e/src/component/wifi/driver/include/rtw_odm.h b/os/board/rtl8720e/src/component/wifi/driver/include/rtw_odm.h
deleted file mode 100644
index 3ae81f86a..000000000
--- a/os/board/rtl8720e/src/component/wifi/driver/include/rtw_odm.h
+++ /dev/null
@@ -1,95 +0,0 @@
-/******************************************************************************
- *
- * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of version 2 of the GNU General Public License as
- * published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
- * more details.
- *
- * You should have received a copy of the GNU General Public License along with
- * this program; if not, write to the Free Software Foundation, Inc.,
- * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
- *
- *
- ******************************************************************************/
-
-#ifndef _RTW_ODM_H_
-#define _RTW_ODM_H_
-
-#include <drv_types.h>
-#include <hal_data.h>
-
-#if (PHYDM_VERSION == 2)
-void rtw_odm_acquirespinlock(_adapter *adapter, enum rt_spinlock_type type);
-void rtw_odm_releasespinlock(_adapter *adapter, enum rt_spinlock_type type);
-#endif /* (PHYDM_VERSION == 2) */
-
-#if (PHYDM_VERSION == 3)
-#define rtw_phydm_ability_ops(adapter, ops, ability)
-#define rtw_phydm_set_dbg_info(padapter, dm_func)
-/*mapping to habb_supportability_t*/
-typedef enum _ODM_Support_Ability_Definition {
-	ODM_BB_DIG = BIT11,
-	ODM_BB_RA_MASK = BIT0,
-	ODM_BB_DYNAMIC_TXPWR = BIT7,
-	ODM_BB_FA_CNT = BIT1,
-	ODM_BB_CCK_PD					= 0,/*not exist*/
-} ODM_ABILITY_E;
-#endif /*(PHYDM_VERSION == 3)*/
-
-typedef enum _HAL_PHYDM_OPS {
-	HAL_PHYDM_DIS_ALL_FUNC,
-	HAL_PHYDM_FUNC_SET,
-	HAL_PHYDM_FUNC_CLR,
-	HAL_PHYDM_ABILITY_BK,
-	HAL_PHYDM_ABILITY_RESTORE,
-	HAL_PHYDM_ABILITY_SET,
-	HAL_PHYDM_ABILITY_GET,
-} HAL_PHYDM_OPS;
-
-u32 rtw_phydm_ability_ops(_adapter *adapter, HAL_PHYDM_OPS ops, u32 ability);
-void rtw_phydm_set_dbg_info(_adapter *padapter, u32 dm_func);
-bool rtw_odm_adaptivity_needed(_adapter *adapter);
-
-#define rtw_phydm_func_disable_all(adapter) \
-		rtw_phydm_ability_ops(adapter, HAL_PHYDM_DIS_ALL_FUNC, 0)
-
-#define rtw_phydm_func_for_offchannel(adapter) \
-		do { \
-			rtw_phydm_ability_ops(adapter, HAL_PHYDM_DIS_ALL_FUNC, 0); \
-			if (rtw_odm_adaptivity_needed(adapter)) \
-				rtw_phydm_ability_ops(adapter, HAL_PHYDM_FUNC_SET, ODM_BB_ADAPTIVITY); \
-		} while (0)
-
-#define rtw_phydm_func_clr(adapter, ability)	\
-		rtw_phydm_ability_ops(adapter, HAL_PHYDM_FUNC_CLR, ability)
-
-#define rtw_phydm_func_set(adapter, ability)	\
-		rtw_phydm_ability_ops(adapter, HAL_PHYDM_FUNC_SET, ability)
-
-#define rtw_phydm_ability_backup(adapter)	\
-		rtw_phydm_ability_ops(adapter, HAL_PHYDM_ABILITY_BK, 0)
-
-#define rtw_phydm_ability_restore(adapter)	\
-		rtw_phydm_ability_ops(adapter, HAL_PHYDM_ABILITY_RESTORE, 0)
-
-#define rtw_phydm_ability_set(adapter, ability)	\
-		rtw_phydm_ability_ops(adapter, HAL_PHYDM_ABILITY_SET, ability)
-
-static inline u32 rtw_phydm_ability_get(_adapter *adapter)
-{
-#if (PHYDM_VERSION == 3)
-	//TODO
-	return 0;
-#else
-	return rtw_phydm_ability_ops(adapter, HAL_PHYDM_ABILITY_GET, 0);
-#endif
-}
-
-#endif	//_RTW_ODM_H_
-
diff --git a/os/board/rtl8720e/src/component/wifi/driver/include/rtw_p2p.h b/os/board/rtl8720e/src/component/wifi/driver/include/rtw_p2p.h
deleted file mode 100644
index 24f63b4ad..000000000
--- a/os/board/rtl8720e/src/component/wifi/driver/include/rtw_p2p.h
+++ /dev/null
@@ -1,37 +0,0 @@
-#ifndef _RTW_P2P_H_
-#define _RTW_P2P_H_
-
-#define P2P_WILDCARD_SSID "DIRECT-"
-#define P2P_WILDCARD_SSID_LEN 7
-
-
-#define RTW_P2P_SEND_ACTION_SUCCESS	0
-#define RTW_P2P_SEND_ACTION_FAILED		2
-
-static inline bool rtw_p2p_chk_state(struct wifidirect_info *wdinfo, enum P2P_STATE state)
-{
-	return wdinfo->p2p_state == state;
-}
-static inline bool rtw_p2p_chk_role(struct wifidirect_info *wdinfo, enum P2P_ROLE role)
-{
-	return wdinfo->role == role;
-}
-
-extern void rtw_p2p_remain_on_channel(struct net_device *dev, u8 channel, u8 wait_time);
-extern void rtw_p2p_cancel_remain_on_channel(struct net_device *dev);
-extern void rtw_p2p_special_scan_param(struct net_device *dev, u8 channel, u8 *mac);
-extern void rtw_p2p_set_p2p_role(struct net_device *dev, u32 role);
-extern void rtw_p2p_set_p2p_state(struct net_device *dev, u32 state);
-extern int rtw_p2p_send_mgnt(_adapter *padapter, u8 *data, u16 len, u16 flags);
-extern void rtw_p2p_indicate_mgnt(_adapter *padapter, u8 *data, u16 len, u8 channel);
-extern void rtw_p2p_indicate_sta_disassoc(_adapter *padapter, u8 *addr);
-extern void rtw_p2p_indicate_send_action_done(_adapter *padapter, u16 status);
-
-extern int rtw_p2p_init_mlme_ext(_adapter *padapter);
-extern void rtw_p2p_deinit_mlme_ext(_adapter *padapter);
-extern int rtw_init_p2p_wdinfo(_adapter *padapter);
-extern void rtw_deinit_p2p_wdinfo(_adapter *padapter);
-extern void rtw_p2p_pre_tx_scan_cmd_callback(_adapter *padapter);
-
-#endif //_RTW_P2P_H_
-
diff --git a/os/board/rtl8720e/src/component/wifi/driver/include/rtw_pmksa_cache.h b/os/board/rtl8720e/src/component/wifi/driver/include/rtw_pmksa_cache.h
deleted file mode 100644
index b9aed84d6..000000000
--- a/os/board/rtl8720e/src/component/wifi/driver/include/rtw_pmksa_cache.h
+++ /dev/null
@@ -1,170 +0,0 @@
-#ifndef _RTW_PMKSA_CACHE_H_
-#define _RTW_PMKSA_CACHE_H_
-
-/*
-** pmksa internal control flag
-**
-*/
-#if WIFI_LOGO_CERTIFICATION
-#define rtw_pmk_cache_enable 1		/* 1:enable;  0:disable  */
-#else
-#define rtw_pmk_cache_enable 0
-#endif
-/*
-** pmksa internal encrypted bssid size
-**
-*/
-#define PMK_AES_CRYPTO_BLOCKSIZE16	16
-
-/*
-** struct pmksa_cache_entry
-**
-*/
-struct pmksa_cache_entry {
-	struct pmksa_cache *ppmksa;
-	struct pmksa_cache_entry *next;
-	u8 pmkid[PMKID_LEN];
-	u8 pmk[PMK_LEN];
-	u8 addr1[ETH_ALEN];
-	u32 akmp; 					/* WPA_KEY_MGMT_* */
-	_timer expire_timer;
-	u8 encrypted_addr1[PMK_AES_CRYPTO_BLOCKSIZE16]; /*the mac address is encrypt with password to make sure the same rounter has been connected*/
-};
-
-
-/*
-** struct pmksa_cache
-**
-*/
-struct pmksa_cache {
-	_lock lock;
-	struct pmksa_cache_entry *pmksa_entry; 		/* PMKSA cache entry list head */
-	struct pmksa_cache_entry *pcurrent_pmksa;	/* current PMKSA */
-	u32 pmksa_entry_count; 						/* number of entries in PMKSA cache */
-	u32 use_cached_pmksa;
-};
-
-
-/*********************************************************************************************
-Function:  init pmksa cache resource
-
-Parameter: @ppmksa: pointer to pmksa_cache
-
-result:    0:success; -1 fail
-*********************************************************************************************/
-int rtw_pmksa_cache_init(_adapter *padapter);
-
-
-/*********************************************************************************************
-Function:  free pmksa cache resource
-
-Parameter: @ppmksa: pointer to pmksa_cache
-
-result:    0:success; -1 fail
-*********************************************************************************************/
-int rtw_pmksa_cache_deinit(_adapter *padapter);
-
-
-/*********************************************************************************************
-Function:  free a pmksa cache entry
-
-Parameter: @pentry: entry to be free
-
-result:    none
-*********************************************************************************************/
-void rtw_pmksa_cache_entry_free(struct pmksa_cache_entry *pentry);
-
-
-/*********************************************************************************************
-Function:  used to encrypt the mac address by take password as key.
-
-Parameter:	@passphase:	password
-			@mac_addr:	mac address
-			@out_addr:	the encrpyted mac_addr
-
-result:    none
-*********************************************************************************************/
-void rtw_pmksa_cache_encrypt_macaddr(u8 *passphrase, u8 *mac_addr, u8 *out_addr);
-
-
-/*********************************************************************************************
-Function:  add a new pmksa cache entry to entry list
-
-Parameter:	@ppmksa: pointer to pmksa_cache
-			@pmk:	 PMK
-			@pmkid:  PMKID
-			@addr1:  peer STA mac addr
-			@akmp:	 AKM suite OUI
-
-result:    retuern pmksa_entry_count if success;
-           rerturn -1 if fail
-*********************************************************************************************/
-int rtw_pmksa_cache_entry_add(struct pmksa_cache *ppmksa, u8 *pmk, u8 *pmkid, u8 *addr1, u32 akmp, u8 *encrypt_addr);
-
-
-/*********************************************************************************************
-Function:  remove a pmksa cache entry to entry list
-
-Parameter: @ppmksa:  pointer to pmksa
-		   @pdelete: pointer to the pmksa entry to be removed
-
-result:    pointer to the head pmksa cache entry
-*********************************************************************************************/
-struct pmksa_cache_entry *rtw_pmksa_cache_entry_remove(struct pmksa_cache *ppmksa, struct pmksa_cache_entry *pdelete);
-
-
-/*********************************************************************************************
-Function:  search an entry in the cache list by peer mac addr and akmp
-
-Parameter: @ppmksa: pointer to pmksa_cache
-		   @addr1: peer STA mac addr
-		   @akmp: expected akmp
-
-result:    success: the entry searched
-		   fail:    NULL
-*********************************************************************************************/
-struct pmksa_cache_entry *rtw_pmksa_cache_entry_search(struct pmksa_cache *ppmksa, u8 *addr1, u32 akmp);
-
-
-/*********************************************************************************************
-Function:  search an entry in the cache list by peer mac addr
-
-Parameter: @ppmksa: pointer to pmksa_cache
-		   @addr1: peer STA mac addr
-
-result:    none
-*********************************************************************************************/
-void rtw_pmksa_cache_set_current_entry(struct pmksa_cache *ppmksa, struct pmksa_cache_entry *pentry);
-
-
-
-/*********************************************************************************************
-Function:  search an entry in the cache list by peer mac addr
-
-Parameter: @ppmksa: pointer to pmksa_cache
-		   @addr1: peer STA mac addr
-
-result:    success: the current PMK entry
-		   fail:    NULL
-*********************************************************************************************/
-struct pmksa_cache_entry *rtw_pmksa_cache_get_current_entry(struct pmksa_cache *ppmksa);
-
-/*********************************************************************************************
-Function:  append pmkid to RSN IE
-			Check the RSN IE length
-			If the RSN IE length <= 20, the RSN IE didn't include the PMKID information
-			0-11th element in the array are the fixed IE
-			12th element in the array is the RSNE ID
-			13th element in the array is the RSNE length
-
-Parameter: @padapter: pointer to pmksa_cache
-		   @pmkid: pmkid cached
-		   @ie: pointer to RSNIE
-		   @ie_len: length of RSNIE
-
-result:    ie length
-*********************************************************************************************/
-u32 rtw_pmksa_append_pmkid(_adapter *padapter, u8 *pmkid, u8 *ie, uint *ie_len);
-//u32 rtw_pmksa_append_pmkid(_adapter *padapter,u8 *pmkid, u8 *ie, uint ie_len);
-
-#endif
diff --git a/os/board/rtl8720e/src/component/wifi/driver/include/rtw_promisc.h b/os/board/rtl8720e/src/component/wifi/driver/include/rtw_promisc.h
deleted file mode 100644
index d1abcaeac..000000000
--- a/os/board/rtl8720e/src/component/wifi/driver/include/rtw_promisc.h
+++ /dev/null
@@ -1,54 +0,0 @@
-/******************************************************************************
- *
- * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of version 2 of the GNU General Public License as
- * published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
- * more details.
- *
- * You should have received a copy of the GNU General Public License along with
- * this program; if not, write to the Free Software Foundation, Inc.,
- * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
- *
- *
- ******************************************************************************/
-
-#ifndef _RTW_PROMISC_H_
-#define _RTW_PROMISC_H_
-#include <drv_types.h>
-#ifdef CONFIG_PROMISC
-void promisc_deinit(_adapter *padapter);
-//void promisc_set_enable(_adapter *padapter, u8 enabled, u8 len_used);
-int promisc_recv_func(_adapter *padapter, union recv_frame *rframe);
-int promisc_recv_lens_func(void *padapter, u8 *payload, u8 plen);
-int promisc_filter_with_len(u16 len);
-void promisc_init_packet_filter(void);
-int promisc_add_packet_filter(u8 filter_id, rtw_packet_filter_pattern_t *patt, rtw_packet_filter_rule_t rule);
-int promisc_enable_packet_filter(u8 filter_id);
-int promisc_disable_packet_filter(u8 filter_id);
-int promisc_remove_packet_filter(u8 filter_id);
-int promisc_filter_retransmit_pkt(u8 enable, u8 filter_interval_ms);
-int promisc_ctrl_packet_rpt(u8 enable);
-void promisc_filter_by_ap_and_phone_mac(u8 enable, void *ap_mac, void *phone_mac);
-#endif
-int promisc_set(rtw_rcr_level_t enabled, void (*callback)(unsigned char *, unsigned int, void *), unsigned char len_used);
-unsigned char is_promisc_enabled(void);
-int promisc_get_fixed_channel(void *fixed_bssid, u8 *ssid, int *ssid_length);
-void promisc_issue_probereq(void);
-void promisc_issue_probersp(unsigned char *da);
-void promisc_stop_tx_beacn(void);
-void promisc_resume_tx_beacn(void);
-void promisc_get_ap_info(rtw_result_t (*func)(char *ssid, u8 ssid_len, s16 rssi, char channel, char security));
-void _promisc_deinit(_adapter *padapter);
-int _promisc_recv_func(_adapter *padapter, union recv_frame *rframe);
-#if defined(CONFIG_UNSUPPORT_PLCPHDR_RPT) && CONFIG_UNSUPPORT_PLCPHDR_RPT
-int _promisc_recv_lens_func(_adapter *padapter, u8 *payload, u8 plen);
-#endif
-
-#endif	//_RTW_PROMISC_H_
-
diff --git a/os/board/rtl8720e/src/component/wifi/driver/include/rtw_psk.h b/os/board/rtl8720e/src/component/wifi/driver/include/rtw_psk.h
deleted file mode 100644
index fbe5a97d4..000000000
--- a/os/board/rtl8720e/src/component/wifi/driver/include/rtw_psk.h
+++ /dev/null
@@ -1,399 +0,0 @@
-/*
- *  Header files of WPA PSK module
- *
- *  $Id: 8192cd_psk.h,v 1.1 2009/11/06 12:26:48 victoryman Exp $
- *
- *  Copyright (c) 2009 Realtek Semiconductor Corp.
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License version 2 as
- *  published by the Free Software Foundation.
- */
-
-#ifndef _RTW_PSK_H_
-#define _RTW_PSK_H_
-
-#define GMK_LEN					32
-#define GTK_LEN					32
-#define IGTK_LEN					16
-#define PMK_LEN					32
-#define PMKID_LEN				16
-#define KEY_NONCE_LEN			32
-#define NumGroupKey				4
-#define KEY_RC_LEN				8
-#define KEY_IV_LEN				16
-#define KEY_RSC_LEN				8
-#define KEY_ID_LEN				8
-#define KEY_MIC_LEN				16
-#define KEY_MATERIAL_LEN		2
-#define PTK_LEN_EAPOLMIC        16
-#define PTK_LEN_EAPOLENC        16
-#define PTK_LEN_TKIP           	64
-#define PTK_LEN_CCMP            48
-#define LIB1X_ETHER_EAPOL_TYPE	0x888E
-
-#ifdef CONFIG_IEEE80211W
-#define WPA_IGTK_LEN 16
-#define WPA_IGTK_MAX_LEN 32
-#endif /* CONFIG_IEEE80211W */
-
-#define DescTypePos				0
-#define KeyInfoPos				1
-#define KeyLenPos				3
-#define ReplayCounterPos		5
-#define KeyNoncePos				13
-#define KeyIVPos				45
-#define KeyRSCPos				61
-#define KeyIDPos				69
-#define KeyMICPos				77
-#define KeyDataLenPos			93
-#define KeyDataPos				95
-#define LIB1X_EAPOL_VER				1	//0000 0001B
-#define LIB1X_EAPOL_EAPPKT			0       //0000 0000B
-#define LIB1X_EAPOL_START			1	//0000 0001B
-#define LIB1X_EAPOL_LOGOFF			2       //0000 0010B
-#define LIB1X_EAPOL_KEY				3	//0000 0011B
-#define LIB1X_EAPOL_ENCASFALERT			4	//0000 0100B
-
-
-#define A_SHA_DIGEST_LEN		20
-#define ETHER_HDRLEN			14
-#define LIB1X_EAPOL_HDRLEN		4
-#define INFO_ELEMENT_SIZE       128
-#define MAX_EAPOLMSG_LEN        512
-#define MAX_EAPOLKEYMSG_LEN		(MAX_EAPOLMSG_LEN-(ETHER_HDRLEN+LIB1X_EAPOL_HDRLEN))
-#define EAPOLMSG_HDRLEN			95      //EAPOL-key payload length without KeyData
-#define WPA_ELEMENT_ID			0xDD
-#define WPA2_ELEMENT_ID			0x30
-
-#ifndef TRUE
-#define TRUE					1
-#endif
-#ifndef FALSE
-#define FALSE					0
-#endif
-
-#define ETHER_ADDRLEN					6
-#define PMK_EXPANSION_CONST				"Pairwise key expansion"
-#define PMK_EXPANSION_CONST_SIZE		22
-#define GMK_EXPANSION_CONST				"Group key expansion"
-#define GMK_EXPANSION_CONST_SIZE		19
-#define IGTK_EXPANSION_CONST				"IGTK key expansion"
-#define RANDOM_EXPANSION_CONST			"Init Counter"
-#define RANDOM_EXPANSION_CONST_SIZE		12
-
-
-/*
-	2008-12-16, For Corega CG-WLCB54GL 54Mbps NIC interoperability issue.
-	The behavior of this NIC when it connect to the other AP with WPA/TKIP is:
-		AP	<----------------------> 	STA
-			....................
-			------------> Assoc Rsp (ok)
-			------------> EAPOL-key (4-way msg 1)
-			<------------ unknown TKIP encryption data
-			------------> EAPOL-key (4-way msg 1)
-			<------------ unknown TKIP encryption data
-			.....................
-			<------------ disassoc (code=8, STA is leaving) when the 5 seconds timer timeout counting from Assoc_Rsp is got.
-			....................
-			------------> Assoc Rsp (ok)
-			<-----------> EAPOL-key (4-way handshake success)
-
-	If MAX_RESEND_NUM=3, our AP will send disassoc (code=15, 4-way timeout) to STA before STA sending disassoc to AP.
-	And this NIC will always can not connect to our AP.
-	set MAX_RESEND_NUM=5 can fix this issue.
- */
-//#define MAX_RESEND_NUM	3
-#define MAX_RESEND_NUM		5
-
-/*
-	Revise STA EAPOL-key(4-2) resend time from "RESEND_TIME" to "CLIENT_RESEND_TIME" to make sure one 4-1 followed
-	by only one 4-2 but not 'several' to fix:
-	As to AP "HUAWEI WS5100", in case of situation that if STA (re)connect to the AP with a wrong password for several times
-	and in each (re)connect the 4-2 msg with the wrong pw info (re)sent more than once in response to every 4-1, then the AP will
-	probably put the STA into blacklist and won't respond to STA's AUTH again even the STA may has corrected the password.
-
-	AP(WS5100)	<-----------> 	STA
-					....................
-					------------> Assoc Rsp (ok)
-					------------> EAPOL-key (4-1)
-					<------------ EAPOL-key (4-2 with wrong pw info)
-					<------------ EAPOL-key (resend 4-2 with wrong pw info)
-
-					------------> EAPOL-key (4-way msg 1)
-					<------------ EAPOL-key (4-2 with wrong pw info)
-					<------------ EAPOL-key (resend 4-2 with wrong pw info)
-					....................
-*/
-#define RESEND_TIME			1000
-#define CLIENT_RESEND_TIME		1200
-#define WAIT_TIME			7000
-
-#define GK_REKEY_TIME		3600000		//Set rekey period to 1 hour
-
-typedef enum {
-	desc_type_RSN	= 2,
-	desc_type_WPA	= 254
-} DescTypeRSN;
-
-typedef enum {
-	type_Group	= 0,
-	type_Pairwise	= 1
-} KeyType;
-
-typedef enum {
-	key_desc_ver1 	= 1,
-	key_desc_ver2 	= 2,
-	key_desc_ver3 	= 3 //AES_128_CMAC, for 802.11w
-} KeyDescVer;
-
-enum {
-	PSK_WPA		= 1,
-	PSK_WPA2	= 2
-};
-
-enum {
-	PSK_STATE_IDLE,
-	PSK_STATE_PTKSTART,
-	PSK_STATE_PTKINITNEGOTIATING,
-	PSK_STATE_PTKINITDONE,
-};
-
-enum {
-	PSK_GSTATE_REKEYNEGOTIATING,
-	PSK_GSTATE_REKEYESTABLISHED,
-	PSK_GSTATE_KEYERROR,
-};
-
-typedef	struct _OCTET_STRING {
-	unsigned char	*Octet;
-	int		Length;
-} OCTET_STRING;
-
-typedef union _LARGE_INTEGER {
-	unsigned char 	charData[8];
-	struct {
-		unsigned long 	HighPart;
-		unsigned long 	LowPart;
-	} field;
-} LARGE_INTEGER, *PLARGE_INTEGER;
-
-typedef union _OCTET16_INTEGER {
-	unsigned char 	charData[16];
-	struct {
-		LARGE_INTEGER	HighPart;
-		LARGE_INTEGER	LowPart;
-	} field;
-} OCTET16_INTEGER;
-
-typedef union  _OCTET32_INTEGER {
-	unsigned char	charData[32];
-	struct {
-		OCTET16_INTEGER	HighPart;
-		OCTET16_INTEGER	LowPart;
-	} field;
-} OCTET32_INTEGER;
-
-#ifdef CONFIG_IEEE80211W
-#define WPA_IGTK_KDE_PREFIX_LEN (2 + 6)
-struct wpa_igtk_kde {
-	u8 keyid[2];
-	u8 pn[6];
-	u8 igtk[WPA_IGTK_MAX_LEN];
-} ;
-#endif /* CONFIG_IEEE80211W */
-
-// group key info
-typedef struct _wpa_global_info {
-	OCTET32_INTEGER		Counter;
-//Save PSK to global array
-//	unsigned char		PSK[A_SHA_DIGEST_LEN * 2];
-	int					GTKAuthenticator;
-	int					GKeyDoneStations;
-	int					GInitAKeys;
-	int					GUpdateStationKeys;
-	int					GkeyReady;
-	OCTET_STRING		AuthInfoElement;
-	unsigned char		AuthInfoBuf[INFO_ELEMENT_SIZE];
-	unsigned char		MulticastCipher;
-	unsigned int		AuthKeyMgmt;	// add for 802.11w
-	OCTET_STRING		GNonce;
-	unsigned char		GNonceBuf[KEY_NONCE_LEN];
-	unsigned char		GTK[NumGroupKey][GTK_LEN];
-	unsigned char		GMK[GMK_LEN];
-	int					GN;
-	int					GM;
-	int					GTKRekey;
-#ifdef CONFIG_GK_REKEY
-	struct timer_list	GKRekeyTimer;
-#endif
-
-#ifdef CONFIG_IEEE80211W
-	unsigned char		IGTK_IPN[2][8];
-	unsigned char		IGTK[2][WPA_IGTK_MAX_LEN];
-	int				GN_igtk;
-	int				GM_igtk;
-	int		IGTK_len;
-#endif
-} WPA_GLOBAL_INFO;
-
-// wpa sta info
-typedef struct _wpa_sta_info {
-	int					state;
-	int					gstate;
-	int					RSNEnabled;		// bit0-WPA, bit1-WPA2
-	int					PInitAKeys;
-	unsigned char		UnicastCipher;
-	LARGE_INTEGER		CurrentReplayCounter;
-	LARGE_INTEGER		ReplayCounterStarted; // david+1-12-2007
-	OCTET_STRING		ANonce;
-	OCTET_STRING		SNonce;
-	unsigned char		AnonceBuf[KEY_NONCE_LEN];
-	unsigned char		SnonceBuf[KEY_NONCE_LEN];
-	unsigned char		PMK[PMK_LEN];
-	unsigned char		PTK[PTK_LEN_TKIP];
-	OCTET_STRING		EAPOLMsgRecvd;
-	OCTET_STRING		EAPOLMsgSend;
-	OCTET_STRING		EapolKeyMsgRecvd;
-	OCTET_STRING		EapolKeyMsgSend;
-
-	unsigned char		eapSendBuf[MAX_EAPOLMSG_LEN];
-//	unsigned char		eapRecvdBuf[MAX_EAPOLMSG_LEN];
-	struct timer_list	resendTimer;
-	int					resendCnt;
-	struct timer_list	waitTimer;	// wait for 4-1 or 2-1
-	int					clientHndshkProcessing;
-	int					clientHndshkDone;
-	int 				clientGkeyUpdate;
-	LARGE_INTEGER		clientMICReportReplayCounter;
-} WPA_STA_INFO;
-
-typedef struct _LIB1X_EAPOL_KEY {
-	unsigned char		key_desc_ver;
-	unsigned char		key_info[2];
-	unsigned char		key_len[2];
-	unsigned char		key_replay_counter[KEY_RC_LEN];
-	unsigned char		key_nounce[KEY_NONCE_LEN];
-	unsigned char		key_iv[KEY_IV_LEN];
-	unsigned char		key_rsc[KEY_RSC_LEN];
-	unsigned char		key_id[KEY_ID_LEN];
-	unsigned char		key_mic[KEY_MIC_LEN];
-	unsigned char		key_data_len[KEY_MATERIAL_LEN];
-	unsigned char		*key_data;
-} lib1x_eapol_key;
-
-struct lib1x_eapol {
-	unsigned char		protocol_version;
-	unsigned char		packet_type;			// This makes it odd in number !
-	unsigned short		packet_body_length;
-};
-
-struct wlan_ethhdr_t {
-	unsigned char		daddr[WLAN_ETHADDR_LEN];
-	unsigned char		saddr[WLAN_ETHADDR_LEN];
-	unsigned short		type;
-};
-
-typedef enum {
-	DOT11_PortStatus_Unauthorized,
-	DOT11_PortStatus_Authorized,
-	DOT11_PortStatus_Guest
-} DOT11_PORT_STATUS;
-
-#ifdef CONFIG_MOVE_PSK_TO_ROM
-static __inline__ OCTET_STRING SubStr(OCTET_STRING f, unsigned short s, unsigned short l)
-{
-	OCTET_STRING res;
-
-	res.Length = l;
-	res.Octet = f.Octet + s;
-
-	return res;
-}
-#endif
-
-#define SetSubStr(f,a,l)					memcpy(f.Octet+l,a.Octet,a.Length)
-#define GetKeyInfo0(f, mask) 				((f.Octet[KeyInfoPos + 1] & mask) ? 1 : 0)
-#define SetKeyInfo0(f,mask,b)				(f.Octet[KeyInfoPos + 1] = (f.Octet[KeyInfoPos + 1] & ~mask) | ( b?mask:0x0) )
-#define GetKeyInfo1(f, mask)				((f.Octet[KeyInfoPos] & mask) ? 1 : 0)
-#define SetKeyInfo1(f,mask,b)				(f.Octet[KeyInfoPos] = (f.Octet[KeyInfoPos] & ~mask) | ( b?mask:0x0) )
-
-// EAPOLKey
-#define Message_DescType(f)				(f.Octet[DescTypePos])
-#define Message_setDescType(f, type)		(f.Octet[DescTypePos] = type)
-// Key Information Filed
-#define Message_KeyDescVer(f)			(f.Octet[KeyInfoPos+1] & 0x07)
-#define Message_setKeyDescVer(f, v)		(f.Octet[KeyInfoPos+1] &= 0xf8) , f.Octet[KeyInfoPos+1] |= (v & 0x07)
-#define Message_KeyType(f)				GetKeyInfo0(f, 0x08)
-#define Message_setKeyType(f, b)			SetKeyInfo0(f,0x08,b)
-#define Message_KeyIndex(f)				((f.Octet[KeyInfoPos+1] & 0x30) >> 4) & 0x03
-#define Message_setKeyIndex(f, v)			(f.Octet[KeyInfoPos+1] &= 0xcf), f.Octet[KeyInfoPos+1] |= ((v<<4) & 0x30)
-#define Message_setInstall(f, b)			SetKeyInfo0(f,0x40,b)
-#define Message_setKeyAck(f, b)			SetKeyInfo0(f,0x80,b)
-
-#define Message_KeyMIC(f)				GetKeyInfo1(f, 0x01)
-#define Message_setKeyMIC(f, b)			SetKeyInfo1(f,0x01,b)
-#define Message_Secure(f)				GetKeyInfo1(f,0x02)
-#define Message_setSecure(f, b)			SetKeyInfo1(f,0x02,b)
-#define Message_Error(f)					GetKeyInfo1(f,0x04)
-#define Message_setError(f, b)				SetKeyInfo1(f,0x04,b)
-#define Message_Request(f)				GetKeyInfo1(f,0x08)
-#define Message_setRequest(f, b)			SetKeyInfo1(f,0x08,b)
-#define Message_setReserved(f, v)			(f.Octet[KeyInfoPos] |= (v<<4&0xff))
-#define Message_KeyLength(f)				((unsigned short)(f.Octet[KeyLenPos] <<8) + (unsigned short)(f.Octet[KeyLenPos+1]))
-#define Message_setKeyLength(f, v)		(f.Octet[KeyLenPos] = (v&0xff00) >>8 ,  f.Octet[KeyLenPos+1] = (v&0x00ff))
-
-#define Message_KeyNonce(f)				SubStr(f, KeyNoncePos, KEY_NONCE_LEN)
-#define Message_setKeyNonce(f, v)			SetSubStr(f, v, KeyNoncePos)
-#define Message_EqualKeyNonce(f1, f2)		memcmp(f1.Octet + KeyNoncePos, f2.Octet, KEY_NONCE_LEN)? 0:1
-#define Message_setKeyIV(f, v)			SetSubStr(f, v, KeyIVPos)
-#define Message_setKeyRSC(f, v)			SetSubStr(f, v, KeyRSCPos)
-#define Message_setKeyID(f, v)			SetSubStr(f, v, KeyIDPos)
-#define Message_setMIC(f, v)				SetSubStr(f, v, KeyMICPos)
-#define Message_KeyDataLength(f)			((unsigned short)(f.Octet[KeyDataLenPos] <<8) + (unsigned short)(f.Octet[KeyDataLenPos+1]))
-#define Message_setKeyDataLength(f, v)	(f.Octet[KeyDataLenPos] = (v&0xff00) >>8 ,  f.Octet[KeyDataLenPos+1] = (v&0x00ff))
-#define Message_setKeyData(f, v)			SetSubStr(f, v, KeyDataPos);
-
-#define Message_CopyReplayCounter(f1, f2)	memcpy(f1.Octet + ReplayCounterPos, f2.Octet + ReplayCounterPos, KEY_RC_LEN)
-#define Message_DefaultReplayCounter(li)	(((li.field.HighPart == 0xffffffff) && (li.field.LowPart == 0xffffffff) ) ?1:0)
-
-#define LargeIntegerOverflow(x)			(x.field.HighPart == 0xffffffff) && (x.field.LowPart == 0xffffffff)
-#define LargeIntegerZero(x)				memset(&x.charData, 0, 8)
-#define Octet16IntegerOverflow(x)			LargeIntegerOverflow(x.field.HighPart) && LargeIntegerOverflow(x.field.LowPart)
-#define Octet16IntegerZero(x)				memset(&x.charData, 0, 16)
-#define SetNonce(ocDst, oc32Counter)		wifi_rom_set_eapolkeyiv(ocDst, oc32Counter)
-
-#if defined(CONFIG_IEEE80211W) || defined(CONFIG_SAE_SUPPORT)
-extern const unsigned char igtk_expansion_const[];
-#endif
-
-int wpa_key_mgmt_sae(int akm);
-int wpa_key_mgmt_sha256(int akm);
-int wpa_key_mgmt_sha384(int akm);
-void ClientSendEAPOL(_adapter *padapter, struct sta_info *psta, int resend);
-void SendEAPOL(_adapter *padapter, struct sta_info *psta, int resend);
-void EAPOLKeyRecvd(_adapter *padapter, struct sta_info *psta);
-void ClientEAPOLKeyRecvd(_adapter *padapter, struct sta_info *psta);
-void init_wpa_sta_info(_adapter *padapter, struct sta_info *psta);
-void psk_init(_adapter *padapter, unsigned char *pie, unsigned short ielen);
-void psk_derive(_adapter *padapter, unsigned char *passphrase, unsigned char *ssid);
-u16 wifi_rom_psk_strip_rsn_pairwise(u8 *ie, u16 ie_len);
-u16 wifi_rom_psk_strip_wpa_pairwise(u8 *ie, u16 ie_len);
-extern void wifi_rom_message_replaycounter_oc2li(OCTET_STRING f, LARGE_INTEGER *li);
-extern int wifi_rom_message_equalreplaycounter(LARGE_INTEGER li1, OCTET_STRING f);
-extern int wifi_rom_message_smallerequalreplaycounter(LARGE_INTEGER li1, OCTET_STRING f);
-extern int wifi_rom_message_largerreplaycounter(LARGE_INTEGER li1, OCTET_STRING f);
-extern void wifi_rom_message_setreplaycounter(OCTET_STRING f, unsigned long h, unsigned long l);
-extern void wifi_rom_inc_largeinteger(LARGE_INTEGER *x);
-extern OCTET32_INTEGER *wifi_rom_inc_octet32_integer(OCTET32_INTEGER *x);
-extern void wifi_rom_set_eapolkeyiv(OCTET_STRING ocDst, OCTET32_INTEGER oc32Counter);
-extern int wifi_rom_check_mic(OCTET_STRING EAPOLMsgRecvd, unsigned char *key, int keylen);
-extern int wifi_rom_decrypt_WPA2keydata(OCTET_STRING EAPOLMsgRecvd, OCTET_STRING EapolKeyMsgRecvd, unsigned char *key, int keylen, unsigned char *kek,
-										int keklen,
-										unsigned char *kout, int kout_size);
-extern int wifi_rom_decrypt_GTK(OCTET_STRING EAPOLMsgRecvd, unsigned char *kek, int keklen, int keylen, unsigned char *kout, int kout_size);
-
-u16 psk_strip_rsn_akmp(u8 *ie, u16 ie_len, u32 wpa_mode);
-
-#endif // _RTW_PSK_H_
-
diff --git a/os/board/rtl8720e/src/component/wifi/driver/include/rtw_pwrctrl.h b/os/board/rtl8720e/src/component/wifi/driver/include/rtw_pwrctrl.h
deleted file mode 100644
index 244c25d57..000000000
--- a/os/board/rtl8720e/src/component/wifi/driver/include/rtw_pwrctrl.h
+++ /dev/null
@@ -1,246 +0,0 @@
-/******************************************************************************
- *
- * Copyright(c) 2007 - 2012 Realtek Corporation. All rights reserved.
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of version 2 of the GNU General Public License as
- * published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
- * more details.
- *
- * You should have received a copy of the GNU General Public License along with
- * this program; if not, write to the Free Software Foundation, Inc.,
- * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
- *
- *
- ******************************************************************************/
-#ifndef __RTW_PWRCTRL_H_
-#define __RTW_PWRCTRL_H_
-
-#define FW_PWR0		0
-#define FW_PWR1 	1
-#define FW_PWR2 	2
-#define FW_PWR3 	3
-
-
-#define HW_PWR0		7
-#define HW_PWR1 	6
-#define HW_PWR2 	2
-#define HW_PWR3		0
-#define HW_PWR4		8
-
-#define FW_PWRMSK	0x7
-
-
-#define XMIT_ALIVE	BIT(0)
-#define RECV_ALIVE	BIT(1)
-#define CMD_ALIVE	BIT(2)
-#define EVT_ALIVE	BIT(3)
-#ifdef CONFIG_BT_COEXIST
-#define BTCOEX_ALIVE	BIT(4)
-#endif /* CONFIG_BT_COEXIST */
-
-#define LPS_TX_TP_TH	3000	//Kbps
-#define LPS_RX_TP_TH	3000	//Kbps
-#define LPS_BI_TP_TH	5000	//Kbps
-#define LPS_TP_CHK_CNT	5
-
-/*
-	BIT[2:0] = HW state
-	BIT[3] = Protocol PS state,   0: register active state , 1: register sleep state
-	BIT[4] = sub-state
-*/
-
-#define PS_DPS				BIT(0)
-#define PS_LCLK				(PS_DPS)
-#define PS_RF_OFF			BIT(1)
-#define PS_ALL_ON			BIT(2)
-#define PS_ST_ACTIVE		BIT(3)
-
-#define PS_ISR_ENABLE		BIT(4)
-#define PS_IMR_ENABLE		BIT(5)
-#define PS_ACK				BIT(6)
-#define PS_TOGGLE			BIT(7)
-
-#define PS_STATE_MASK		(0x0F)
-#define PS_STATE_HW_MASK	(0x07)
-#define PS_SEQ_MASK			(0xc0)
-
-#define PS_STATE(x)		(PS_STATE_MASK & (x))
-#define PS_STATE_HW(x)	(PS_STATE_HW_MASK & (x))
-#define PS_SEQ(x)		(PS_SEQ_MASK & (x))
-
-#define PS_STATE_S0		(PS_DPS)
-#define PS_STATE_S1		(PS_LCLK)
-#define PS_STATE_S2		(PS_RF_OFF)
-#define PS_STATE_S3		(PS_ALL_ON)
-#define PS_STATE_S4		((PS_ST_ACTIVE) | (PS_ALL_ON))
-
-
-#define PS_IS_RF_ON(x)	((x) & (PS_ALL_ON))
-#define PS_IS_ACTIVE(x)	((x) & (PS_ST_ACTIVE))
-#define CLR_PS_STATE(x)	((x) = ((x) & (0xF0)))
-
-
-struct reportpwrstate_parm {
-	unsigned char mode;
-	unsigned char state; //the CPWM value
-	unsigned short rsvd;
-};
-
-
-typedef _sema _pwrlock;
-
-
-__inline static void _init_pwrlock(_pwrlock *plock)
-{
-	rtw_init_sema(plock, 1);
-}
-
-__inline static void _free_pwrlock(_pwrlock *plock)
-{
-	rtw_free_sema(plock);
-}
-
-
-__inline static void _enter_pwrlock(_pwrlock *plock)
-{
-	rtw_down_sema(plock);
-}
-
-
-__inline static void _exit_pwrlock(_pwrlock *plock)
-{
-	rtw_up_sema(plock);
-}
-
-#define LPS_DELAY_TIME	1 // 1 sec
-
-#define EXE_PWR_NONE	0x01
-#define EXE_PWR_IPS		0x02
-#define EXE_PWR_LPS		0x04
-
-// RF state.
-typedef enum _rt_rf_power_state {
-	rf_on,		// RF is on after RFSleep or RFOff
-	rf_sleep,	// 802.11 Power Save mode
-	rf_off,		// HW/SW Radio OFF or Inactive Power Save
-	//=====Add the new RF state above this line=====//
-	rf_max
-} rt_rf_power_state;
-
-// RF Off Level for IPS or HW/SW radio off
-#define	RT_RF_OFF_LEVL_ASPM			BIT(0)	// PCI ASPM
-#define	RT_RF_OFF_LEVL_CLK_REQ		BIT(1)	// PCI clock request
-#define	RT_RF_OFF_LEVL_PCI_D3			BIT(2)	// PCI D3 mode
-#define	RT_RF_OFF_LEVL_HALT_NIC		BIT(3)	// NIC halt, re-initialize hw parameters
-#define	RT_RF_OFF_LEVL_FREE_FW		BIT(4)	// FW free, re-download the FW
-#define	RT_RF_OFF_LEVL_FW_32K		BIT(5)	// FW in 32k
-#define	RT_RF_PS_LEVEL_ALWAYS_ASPM	BIT(6)	// Always enable ASPM and Clock Req in initialization.
-#define	RT_RF_LPS_DISALBE_2R			BIT(30)	// When LPS is on, disable 2R if no packet is received or transmittd.
-#define	RT_RF_LPS_LEVEL_ASPM			BIT(31)	// LPS with ASPM
-
-enum _PS_BBRegBackup_ {
-	PSBBREG_RF0 = 0,
-	PSBBREG_RF1,
-	PSBBREG_RF2,
-	PSBBREG_AFE0,
-	PSBBREG_TOTALCNT
-};
-
-struct pwrctrl_priv {
-	_pwrlock	lock;
-
-	u8	ips_user_req;
-	u8	ips_driver_req;
-	uint	bips_processing;
-	u32	ips_deny_time; /* will deny IPS when system time is smaller than this */
-	u8	ps_processing; /* temporarily used to mark whether in rtw_ps_processor */
-
-	u8	lps_user_req;
-	u8	lps_driver_req;
-	u8	lps_cur_state;
-
-	u8	LpsIdleCount;
-	u8	lps_mode;
-	u32	DelayLPSLastTimeStamp;
-
-	u8	lps_level; /*LPS_NORMAL,LPA_CG,LPS_PG*/
-	u8	lps_dtim;
-	u8	lps_enter_threshold;
-
-	u8	lps_chk_by_tp;
-	u16	lps_tx_tp_th; // Kbps
-	u16	lps_rx_tp_th; // Kbps
-	u16	lps_bi_tp_th; // Kbps // TRX TP
-	int	lps_chk_cnt_th;
-	int	lps_chk_cnt;
-
-	u8	bInSuspend;
-	u8	bcn_ant_mode;
-	u64  wowlan_fw_iv;
-#ifdef CONFIG_WOWLAN
-	u8	wowlan_mode;
-	u8	wowlan_wake_reason;
-#endif // CONFIG_WOWLAN
-	_timer pwr_state_check_timer;
-	int	pwr_state_check_interval;
-	u8	pwr_state_check_cnts;
-
-	rt_rf_power_state	rf_pwrstate;//cur power state
-	//rt_rf_power_state 	current_rfpwrstate;
-	rt_rf_power_state	change_rfpwrstate;
-
-	u8	bkeepfwalive;
-
-#ifdef TDMA_POWER_SAVING
-	u8	tdma_slot_period;
-	u8	tdma_rfon_period_len_1;
-	u8	tdma_rfon_period_len_2;
-	u8	tdma_rfon_period_len_3;
-#endif
-
-#if defined (CONFIG_FW_DRIVER_COEXIST) || defined (CONFIG_MSFT) && CONFIG_MSFT
-	u32 dynamic_timer_record;
-	u32 pwr_check_timer_record;
-#endif
-
-};
-
-#define RTW_PWR_STATE_CHK_INTERVAL 2000
-
-#define _rtw_set_pwr_state_check_timer(pwrctrlpriv, ms) \
-	do { \
-		rtw_set_timer(&(pwrctrlpriv)->pwr_state_check_timer, (ms)); \
-	} while(0)
-
-#define rtw_set_pwr_state_check_timer(pwrctrlpriv) \
-	_rtw_set_pwr_state_check_timer((pwrctrlpriv), (pwrctrlpriv)->pwr_state_check_interval)
-
-extern void rtw_init_pwrctrl_priv(_adapter *adapter);
-extern void rtw_free_pwrctrl_priv(_adapter *adapter);
-extern void rtw_set_ps_mode(PADAPTER padapter, u8 ps_mode, u8 smart_ps, u8 bcn_ant_mode);
-extern void rtw_set_rpwm(_adapter *padapter, u8 val8);
-extern void LeaveAllPowerSaveMode(PADAPTER Adapter);
-void ips_enter(_adapter *padapter);
-int ips_leave(_adapter *padapter);
-
-void rtw_ps_processor(_adapter *padapter);
-
-s32 LPS_RF_ON_check(PADAPTER padapter, u32 delay_ms);
-void LPS_Enter(PADAPTER padapter);
-void LPS_Leave(PADAPTER padapter);
-
-//TODO
-//u8 rtw_interface_ps_func(_adapter *padapter,HAL_INTF_PS_FUNC efunc_id,u8* val);
-int _rtw_pwr_wakeup(_adapter *padapter, u32 ips_deffer_ms, const char *caller);
-#define rtw_pwr_wakeup(adapter) _rtw_pwr_wakeup(adapter, RTW_PWR_STATE_CHK_INTERVAL, __FUNCTION__)
-int rtw_pm_set_ips_enable(_adapter *padapter, u8 enable);
-int rtw_pm_set_lps_enable(_adapter *padapter, u8 enable);
-int rtw_pm_set_lps_level(_adapter *padapter, u8 level);
-int rtw_pm_set_tdma_param(_adapter *padapter, u8 tdma_slot_period, u8 tdma_rfon_period_len_1, u8 tdma_rfon_period_len_2, u8 tdma_rfon_period_len_3);
-#endif  //__RTL871X_PWRCTRL_H_
-
diff --git a/os/board/rtl8720e/src/component/wifi/driver/include/rtw_pwrctrl_sd1.h b/os/board/rtl8720e/src/component/wifi/driver/include/rtw_pwrctrl_sd1.h
deleted file mode 100644
index fade4bbff..000000000
--- a/os/board/rtl8720e/src/component/wifi/driver/include/rtw_pwrctrl_sd1.h
+++ /dev/null
@@ -1,154 +0,0 @@
-/******************************************************************************
- *
- * Copyright(c) 2007 - 2012 Realtek Corporation. All rights reserved.
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of version 2 of the GNU General Public License as
- * published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
- * more details.
- *
- * You should have received a copy of the GNU General Public License along with
- * this program; if not, write to the Free Software Foundation, Inc.,
- * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
- *
- *
- ******************************************************************************/
-#ifndef __RTW_PWRCTRL_SD1_H_
-#define __RTW_PWRCTRL_SD1_H_
-
-#ifdef CONFIG_WOWLAN_SD1
-#define DEFAULT_PATTERN_NUM 1  		/* ICMP */
-#define MAX_CUSTOM_PATTERN_NUM 20
-#define MAX_WKFM_CAM_NUM	22		/* Frame Mask Cam number for pattern match */
-#define MAX_WKFM_SIZE		16 /* (16 bytes for WKFM bit mask, 16*8 = 128 bits) */
-#define MAX_WKFM_PATTERN_SIZE	128
-#define WKFMCAM_ADDR_NUM 8//6
-//#define WKFMCAM_SIZE 		24 /* each entry need 6*4 bytes */
-
-enum pattern_type {
-	PATTERN_BROADCAST = 0,
-	PATTERN_MULTICAST,
-	PATTERN_UNICAST,
-	PATTERN_VALID,
-	PATTERN_INVALID,
-};
-
-typedef struct rtl_priv_pattern {
-	int len;
-	char content[MAX_WKFM_PATTERN_SIZE];
-	char mask[MAX_WKFM_SIZE];
-} rtl_priv_pattern_t;
-
-#endif
-
-struct pwrctrl_priv_sd1 {
-
-#ifdef CONFIG_WOWLAN_SD1
-	u8      wowlan_txpause_status;
-	u8      bLowPwrRxBCN;
-	u8      bLowPwrRxBCNOfdmOff;
-
-#if defined(CONFIG_WOWLAN_HW_CAM)
-	u8		wowlan_pattern;
-	u8		wowlan_magic;
-	u8		wowlan_unicast;
-	bool	default_patterns_en;
-	_mutex	wowlan_pattern_cam_mutex;
-	u8		wowlan_pattern_idx;
-	struct rtl_priv_pattern	patterns[MAX_WKFM_CAM_NUM];
-#endif
-#ifdef CONFIG_WOWLAN_CUSTOM_PATTERN
-	wowlan_pattern_t	wowlan_custom_pattern[MAX_CUSTOM_PATTERN_NUM];
-	u8		wowlan_custom_pattern_count;
-#endif
-#endif // CONFIG_WOWLAN
-
-#ifdef CONFIG_LPS_PG
-	u8 lpspg_rsvd_page_locate;
-	u8 blpspg_info_up;
-#endif
-
-#ifdef CONFIG_WOWLAN_SSL_KEEP_ALIVE
-	u8 ssl_info_rsvd_page_locate;
-	u8 ssl_pattern_rsvd_page_locate;
-#endif
-
-#ifdef CONFIG_SMART_DTIM
-	u8  smartdtim_enable;
-	u8  smartdtim_resume_enable;
-	u8  smartdtim_check_period;
-	u8  smartdtim_threshold;
-	u8  smartdtim_change_dtim;
-#endif
-
-#ifdef CONFIG_WOWLAN_DHCP_RENEW
-	u8  dhcp_renew_rsvd_page_locate;
-	u8 *dhcp_renew_pkt;
-	u32 dhcp_renew_pkt_size;
-	u16 dhcp_renew_lease_time;
-	u16 dhcp_renew_t1;
-#endif
-
-#ifdef CONFIG_WOWLAN_DYNAMIC_TX_PWR
-	u8  dynamic_tx_pwr_threshold_rssi_low;
-	u8  dynamic_tx_pwr_threshold_rssi_high;
-	u8  dynamic_tx_pwr_offset_db_low;
-	u8  dynamic_tx_pwr_offset_db_high;
-#endif
-
-#ifdef CONFIG_ARP_KEEP_ALIVE
-	u8  arp_rsp_keep_alive_enable;
-	u8  gw_ip[4];
-	u8  tcp_ip[4];
-	u8  tcp_mac[6];
-#endif
-
-#ifdef CONFIG_WOWLAN_PARAM
-	u8  wowlan_param_conf;
-	u8  fw_disconnect_check_period;
-	u8  fw_disconnect_trypktnum;
-	u8  pno_enable;
-	u8  pno_timeout;
-	u8  l2_keepalive_period;
-#endif
-
-#ifdef CONFIG_ARP_REQUEST_KEEP_ALIVE
-	u8  arpreq_enable;
-	u8  arpreq_powerbit;
-	u8  arpreq_dtim1to;
-	u8  arpreq_rsvd_page_locate;
-#endif
-
-#ifdef CONFIG_WOWLAN_IO_WDT
-	u8  wdt_enable;
-	u8  wdt_gpio;
-	u8  wdt_interval;
-#endif
-
-#ifdef CONFIG_WOWLAN_SSL_SERVER_KEEP_ALIVE
-	u8  serverkeepalive_enable;
-	u8  serverkeepalive_timeout_l;
-	u8  serverkeepalive_timeout_h;
-#endif
-
-#ifdef CONFIG_WOWLAN_TCP_KEEP_ALIVE
-	u8  tcp_keep_alive_rsvd_page_locate;
-	u32 tcp_keep_alive_interval_ms;
-	u32 tcp_keep_alive_resend_ms;
-	u8  tcp_keep_alive_wake_sys;
-	u8 *tcp_keep_alive_pkt;
-	u32 tcp_keep_alive_pkt_size;
-#ifdef CONFIG_WOWLAN_DTIMTO
-	u8  tcp_keep_alive_dtimto_enable;
-	u8  tcp_keep_alive_dtimto_retry_inc;
-	u8  tcp_keep_alive_dtimto_ack_timeout;
-#endif
-#endif
-
-};
-
-#endif
diff --git a/os/board/rtl8720e/src/component/wifi/driver/include/rtw_qos.h b/os/board/rtl8720e/src/component/wifi/driver/include/rtw_qos.h
deleted file mode 100644
index 328102b0b..000000000
--- a/os/board/rtl8720e/src/component/wifi/driver/include/rtw_qos.h
+++ /dev/null
@@ -1,33 +0,0 @@
-/******************************************************************************
- *
- * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of version 2 of the GNU General Public License as
- * published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
- * more details.
- *
- * You should have received a copy of the GNU General Public License along with
- * this program; if not, write to the Free Software Foundation, Inc.,
- * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
- *
- *
- ******************************************************************************/
-
-
-#ifndef _RTW_QOS_H_
-#define _RTW_QOS_H_
-
-struct	qos_priv	{
-
-	u32	  qos_option;	//bit mask option: u-apsd, s-apsd, ts, block ack...
-
-};
-
-
-#endif	//_RTL871X_QOS_H_
-
diff --git a/os/board/rtl8720e/src/component/wifi/driver/include/rtw_recv.h b/os/board/rtl8720e/src/component/wifi/driver/include/rtw_recv.h
deleted file mode 100644
index 63f1b1087..000000000
--- a/os/board/rtl8720e/src/component/wifi/driver/include/rtw_recv.h
+++ /dev/null
@@ -1,587 +0,0 @@
-/******************************************************************************
- *
- * Copyright(c) 2007 - 2012 Realtek Corporation. All rights reserved.
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of version 2 of the GNU General Public License as
- * published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
- * more details.
- *
- * You should have received a copy of the GNU General Public License along with
- * this program; if not, write to the Free Software Foundation, Inc.,
- * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
- *
- *
- ******************************************************************************/
-#ifndef _RTW_RECV_H_
-#define _RTW_RECV_H_
-#include <hal_pg.h>
-
-#define NR_RECVFRAME 16	//Increase recv frame due to rx reorder - Andy Sun
-
-
-#ifndef CONFIG_HIGH_TP
-//	#define NR_RECVBUFF (8)	//Decrease recv buffer due to memory limitation - Alex Fang
-#define NR_RECVBUFF (1)	//Decrease recv buffer due to memory limitation - YangJue
-#else
-#define NR_RECVBUFF (32)
-#endif //CONFIG_HIGH_TP
-
-#define RECV_BULK_IN_ADDR			0x80
-#define RECV_INT_IN_ADDR			0x81
-
-#define PHY_RSSI_SLID_WIN_MAX			100
-#define PHY_LINKQUALITY_SLID_WIN_MAX		20
-
-// Rx smooth factor
-#define Rx_Smooth_Factor			(20)
-
-#define RXFRAME_ALIGN				8
-#define RXFRAME_ALIGN_SZ			(1<<RXFRAME_ALIGN)
-
-#define DRVINFO_SZ				4 // unit is 8bytes
-
-#define MAX_RXFRAME_CNT				512
-#define MAX_RX_NUMBLKS				(32)
-#define RECVFRAME_HDR_ALIGN			128
-
-#define SNAP_SIZE sizeof(struct ieee80211_snap_hdr)
-
-#define RX_MPDU_QUEUE				0
-#define RX_CMD_QUEUE				1
-#define RX_MAX_QUEUE				2
-
-#define MAX_SUBFRAME_COUNT			64
-#define RX_SC_ENTRY_NUM				4
-
-#define SIG_SAMP_INTERVAL			1000
-
-//for Rx reordering buffer control
-struct recv_reorder_ctrl {
-	_adapter	*padapter;
-	u8 enable;
-	u16 indicate_seq;//=wstart_b, init_value=0xffff
-	u16 wend_b;
-	u16 wsize_b;
-	_queue pending_recvframe_queue;
-	_timer reordering_ctrl_timer;
-	u8 bReorderWaiting;
-};
-
-struct	stainfo_rxcache	{
-	u16 	tid_rxseq[16];
-	/*
-		unsigned short 	tid0_rxseq;
-		unsigned short 	tid1_rxseq;
-		unsigned short 	tid2_rxseq;
-		unsigned short 	tid3_rxseq;
-		unsigned short 	tid4_rxseq;
-		unsigned short 	tid5_rxseq;
-		unsigned short 	tid6_rxseq;
-		unsigned short 	tid7_rxseq;
-		unsigned short 	tid8_rxseq;
-		unsigned short 	tid9_rxseq;
-		unsigned short 	tid10_rxseq;
-		unsigned short 	tid11_rxseq;
-		unsigned short 	tid12_rxseq;
-		unsigned short 	tid13_rxseq;
-		unsigned short 	tid14_rxseq;
-		unsigned short 	tid15_rxseq;
-	*/
-};
-
-struct smooth_rssi_data {
-	u32	elements[100];	//array to store values
-	u32	index;			//index to current array to store
-	u32	total_num;		//num of valid elements
-	u32	total_val;		//sum of valid elements
-};
-
-struct rx_pkt_attrib	{
-	u16	pkt_len;
-	u8	physt;
-	u8	drvinfo_sz;
-	u8	shift_sz;
-	u8	hdrlen; //the WLAN Header Len
-	u8 	to_fr_ds;
-	u8 	amsdu;
-	u8	qos;
-	u8	priority;
-	u8	pw_save;
-	u8	mdata;
-	u16	seq_num;
-	u8	frag_num;
-	u8	mfrag;
-	u8	order;
-	u8	privacy; //in frame_ctrl field
-	u8	bdecrypted;
-	u8	encrypt; //when 0 indicate no encrypt. when non-zero, indicate the encrypt algorith
-	u8	iv_len;
-	u8	icv_len;
-	u8	crc_err;
-	u8	icv_err;
-
-	u16 eth_type;
-
-	u8 	dst[ETH_ALEN];
-	u8 	src[ETH_ALEN];
-	u8 	ta[ETH_ALEN];
-	u8 	ra[ETH_ALEN];
-	u8 	bssid[ETH_ALEN];
-
-	u8 ack_policy;
-
-//#ifdef CONFIG_TCP_CSUM_OFFLOAD_RX
-	u8	tcpchk_valid; // 0: invalid, 1: valid
-	u8	ip_chkrpt; //0: incorrect, 1: correct
-	u8	tcp_chkrpt; //0: incorrect, 1: correct
-//#endif
-	u8 	key_index;
-
-	u8	mcs_rate;
-	u8	rxht;
-	u8 	sgi;
-	u8 	pkt_rpt_type;
-	u32	MacIDValidEntry[2];	// 64 bits present 64 entry.
-
-
-	u16   data_rate;
-	/*
-		u8	signal_qual;
-		s8	rx_mimo_signal_qual[2];
-		u8	signal_strength;
-		u32	RxPWDBAll;
-		s32	RecvSignalPower;
-	*/
-#ifdef RX_SHORTCUT
-	u8 wifi_addr[3 * ETH_ALEN];
-#endif
-
-	struct phydm_phyinfo_struct phy_info;
-#if (PHYDM_VERSION == 3) /*for halbb physts_rxd*/
-	u8 A1_matched;
-	u8 macid_from_rxdesc;
-	u8 frame_type; //subtype not included
-	u8 bc;
-#endif
-
-};
-
-//These definition is used for Rx packet reordering.
-#define SN_LESS(a, b)		(((a-b)&0x800)!=0)
-#define SN_EQUAL(a, b)	(a == b)
-#if defined(CONFIG_RX_REORDER_WIN_SIZE)
-#define REORDER_WIN_SIZE	CONFIG_RX_REORDER_WIN_SIZE	//NR_RECVFRAME
-#else
-#define REORDER_WIN_SIZE	4	// reduce due to skbdata num limit//NR_RECVFRAME
-#endif
-//#define REORDER_ENTRY_NUM	128
-#define REORDER_WAIT_TIME	(30) // (ms)
-
-#define RECVBUFF_ALIGN_SZ 8
-
-#define RXDESC_SIZE	24
-#define RXDESC_OFFSET RXDESC_SIZE
-
-struct recv_stat {
-	unsigned int rxdw0;
-
-	unsigned int rxdw1;
-
-	unsigned int rxdw2;
-
-	unsigned int rxdw3;
-
-	unsigned int rxdw4;
-
-	unsigned int rxdw5;
-
-};
-
-
-struct recv_buf_stat {
-	unsigned int rxdw0;
-
-	unsigned int rxdw1;
-};
-
-#define EOR BIT(30)
-
-#define MAX_RX_QUEUE		1 // MSDU packet queue, Rx Command Queue
-
-#if defined(CONFIG_LX_HCI)
-#define LX_MAX_RX_COUNT		4 //RX_Q_DESC_NUM// 128
-struct rtw_rx_ring {
-#if (RTL8721D_SUPPORT == 1)
-	struct recv_buf_stat	*desc;
-#else
-	struct recv_stat	*desc;
-#endif
-	dma_addr_t		dma;
-	unsigned int		idx;
-	struct sk_buff		*rx_buf[LX_MAX_RX_COUNT];
-};
-#endif // CONFIG_LX_HCI
-
-#if defined(CONFIG_AXI_HCI)
-#if defined(CONFIG_RX_RING_COUNT)
-#define AXI_MAX_RX_COUNT	CONFIG_RX_RING_COUNT //RX_Q_DESC_NUM// 128
-#else
-#define AXI_MAX_RX_COUNT	4 //RX_Q_DESC_NUM// 128
-#endif
-struct rtw_rx_ring {
-	struct recv_buf_stat	*desc;
-
-	dma_addr_t		dma;
-	unsigned int		idx;
-	struct sk_buff		*rx_buf[AXI_MAX_RX_COUNT];
-};
-#endif // CONFIG_AXI_HCI
-
-#ifdef RX_SHORTCUT
-struct rx_sc_entry {
-	u8 shortcut_hdr[2 * ETH_ALEN];
-	u8 wifi_addr[3 * ETH_ALEN]; //A1 A2 A3
-	u32 is_dirty;//0 is free, 1 is alloced
-};
-#endif // RX_SHORTCUT
-
-/*
-accesser of recv_priv: rtw_recv_entry(dispatch / passive level); recv_thread(passive) ; returnpkt(dispatch)
-; halt(passive) ;
-
-using enter_critical section to protect
-*/
-struct recv_priv {
-	_queue			free_recv_queue;
-	_queue			uc_swdec_pending_queue;
-	u8			*pallocated_frame_buf;
-	u8			*precv_frame_buf;
-	uint			free_recvframe_cnt;
-	_adapter		*adapter;
-	u8			*pallocated_recv_buf;
-	u8			*precv_buf;    // 4 alignment
-	_queue			free_recv_buf_queue;
-	u32			free_recv_buf_queue_cnt;
-	struct rtw_rx_ring	rx_ring[MAX_RX_QUEUE];
-	int			rxringcount;
-	u16			rxbuffersize;
-#ifdef RX_SHORTCUT
-	struct rx_sc_entry	rx_sc_ent[RX_SC_ENTRY_NUM];
-	int			rx_sc_replace_idx;
-#endif
-};
-
-#ifdef CONFIG_PROMISC
-struct promisc_priv {
-	u8 promisc_enabled;
-	u8 promisc_len_used;
-	u8 promisc_type;
-	_list promisc_list;
-	u32 promisc_bk_rcr;
-	u16 promisc_bk_rxfltmap2;
-	u8 promisc_mgntframe_enabled;
-	s8 promisc_dest_ap_rssi_avg;
-};
-#endif
-
-struct sta_recv_priv {
-	sint	option;
-	_queue defrag_q;	 //keeping the fragment frame until defrag
-	struct	stainfo_rxcache rxcache;
-};
-
-struct recv_buf {
-	_list list;
-	PADAPTER adapter;
-	u32	len;
-	u8	*phead;
-	u8	*pdata;
-	u8	*ptail;
-	u8	*pend;
-	_pkt	*pskb;
-};
-
-/*
-	head  ----->
-
-		data  ----->
-
-			payload
-
-		tail  ----->
-
-
-	end   ----->
-
-	len = (unsigned int )(tail - data);
-
-*/
-struct recv_frame_hdr {
-	_list	list;
-#ifndef CONFIG_BSD_RX_USE_MBUF
-	struct sk_buff	 *pkt;
-	struct sk_buff	 *pkt_newalloc;
-#else // CONFIG_BSD_RX_USE_MBUF
-	_pkt	*pkt;
-	_pkt *pkt_newalloc;
-#endif // CONFIG_BSD_RX_USE_MBUF
-
-	_adapter  *adapter;
-
-	u8 fragcnt;
-
-	int frame_tag;
-
-	struct rx_pkt_attrib attrib;
-
-	uint  len;
-	u8 *rx_head;
-	u8 *rx_data;
-	u8 *rx_tail;
-	u8 *rx_end;
-
-	void *precvbuf;
-
-
-	//
-	struct sta_info *psta;
-	//for A-MPDU Rx reordering buffer control
-	struct recv_reorder_ctrl *preorder_ctrl;
-};
-
-union recv_frame {
-
-	union {
-		_list list;
-		struct recv_frame_hdr hdr;
-		uint mem[RECVFRAME_HDR_ALIGN >> 2];
-	} u;
-
-	//uint mem[MAX_RXSZ>>2];
-
-};
-
-typedef enum _RX_PACKET_TYPE {
-	NORMAL_RX = 0,//Normal rx packet
-	CH_INFO_NDPA = 1,//Channel info trigger by NDPA or normal pkt
-	CH_INFO_RSP = 2,//Channel info trigger by response pkt
-	PPDU_STATUS = 4,// phystatus
-	C2H_PACKET = 5
-} RX_PACKET_TYPE, *PRX_PACKET_TYPE;
-
-extern void rtw_init_recvframe(union recv_frame *precvframe, struct recv_priv *precvpriv);
-extern int	 rtw_free_recvframe(union recv_frame *precvframe, _queue *pfree_recv_queue);
-
-#define rtw_dequeue_recvframe(queue) rtw_alloc_recvframe(queue)
-
-extern union recv_frame *rtw_alloc_recvframe(_queue *pfree_recv_queue);   //get a free recv_frame from pfree_recv_queue
-union recv_frame *recvframe_chk_defrag(PADAPTER padapter, union recv_frame *precv_frame);
-extern void rtw_free_recvframe_queue(_queue *pframequeue,  _queue *pfree_recv_queue);
-u32 rtw_free_uc_swdec_pending_queue(_adapter *adapter);
-
-void rtw_reordering_ctrl_timeout_handler(void *pcontext);
-
-
-__inline static u8 *get_rxmem(union recv_frame *precvframe)
-{
-	//always return rx_head...
-	if (precvframe == NULL) {
-		return NULL;
-	}
-
-	return precvframe->u.hdr.rx_head;
-}
-
-__inline static u8 *get_rx_status(union recv_frame *precvframe)
-{
-
-	return get_rxmem(precvframe);
-
-}
-
-
-
-__inline static u8 *get_recvframe_data(union recv_frame *precvframe)
-{
-
-	//alwasy return rx_data
-	if (precvframe == NULL) {
-		return NULL;
-	}
-
-	return precvframe->u.hdr.rx_data;
-
-}
-
-__inline static u8 *recvframe_pull(union recv_frame *precvframe, sint sz)
-{
-	// rx_data += sz; move rx_data sz bytes  hereafter
-
-	//used for extract sz bytes from rx_data, update rx_data and return the updated rx_data to the caller
-
-
-	if (precvframe == NULL) {
-		return NULL;
-	}
-
-
-	precvframe->u.hdr.rx_data += sz;
-
-	if (precvframe->u.hdr.rx_data > precvframe->u.hdr.rx_tail) {
-		precvframe->u.hdr.rx_data -= sz;
-		return NULL;
-	}
-
-	precvframe->u.hdr.len -= sz;
-
-	return precvframe->u.hdr.rx_data;
-
-}
-
-__inline static u8 *recvframe_put(union recv_frame *precvframe, sint sz)
-{
-	// rx_tai += sz; move rx_tail sz bytes  hereafter
-
-	//used for append sz bytes from ptr to rx_tail, update rx_tail and return the updated rx_tail to the caller
-	//after putting, rx_tail must be still larger than rx_end.
-
-	if (precvframe == NULL) {
-		return NULL;
-	}
-
-	precvframe->u.hdr.rx_tail += sz;
-
-	if (precvframe->u.hdr.rx_tail > precvframe->u.hdr.rx_end) {
-		precvframe->u.hdr.rx_tail -= sz;
-		return NULL;
-	}
-
-	precvframe->u.hdr.len += sz;
-
-	return precvframe->u.hdr.rx_tail;
-
-}
-
-
-
-__inline static u8 *recvframe_pull_tail(union recv_frame *precvframe, sint sz)
-{
-	// rmv data from rx_tail (by yitsen)
-
-	//used for extract sz bytes from rx_end, update rx_end and return the updated rx_end to the caller
-	//after pulling, rx_end must be still larger than rx_data.
-
-	if (precvframe == NULL) {
-		return NULL;
-	}
-
-	precvframe->u.hdr.rx_tail -= sz;
-
-	if (precvframe->u.hdr.rx_tail < precvframe->u.hdr.rx_data) {
-		precvframe->u.hdr.rx_tail += sz;
-		return NULL;
-	}
-
-	precvframe->u.hdr.len -= sz;
-
-	return precvframe->u.hdr.rx_tail;
-
-}
-
-__inline static _buffer *get_rxbuf_desc(union recv_frame *precvframe)
-{
-	_buffer *buf_desc = NULL;
-
-	if (precvframe == NULL) {
-		return NULL;
-	}
-
-	return buf_desc;
-}
-
-
-__inline static union recv_frame *rxmem_to_recvframe(u8 *rxmem)
-{
-	//due to the design of 2048 bytes alignment of recv_frame, we can reference the union recv_frame
-	//from any given member of recv_frame.
-	// rxmem indicates the any member/address in recv_frame
-
-	return (union recv_frame *)(((SIZE_PTR)rxmem >> RXFRAME_ALIGN) << RXFRAME_ALIGN);
-
-}
-
-__inline static union recv_frame *pkt_to_recvframe(_pkt *pkt)
-{
-	/* To avoid gcc warnings */
-	(void) pkt;
-
-	u8 *buf_star = NULL;
-	union recv_frame *precv_frame = NULL;
-
-	precv_frame = rxmem_to_recvframe((unsigned char *)buf_star);
-
-	return precv_frame;
-}
-
-__inline static u8 *pkt_to_recvmem(_pkt *pkt)
-{
-	// return the rx_head
-
-	union recv_frame *precv_frame = pkt_to_recvframe(pkt);
-
-	return 	precv_frame->u.hdr.rx_head;
-
-}
-
-__inline static u8 *pkt_to_recvdata(_pkt *pkt)
-{
-	// return the rx_data
-
-	union recv_frame *precv_frame = pkt_to_recvframe(pkt);
-
-	return 	precv_frame->u.hdr.rx_data;
-
-}
-
-
-__inline static sint get_recvframe_len(union recv_frame *precvframe)
-{
-	return precvframe->u.hdr.len;
-}
-
-
-__inline static s32 translate_percentage_to_dbm(u32 SignalStrengthIndex)
-{
-	s32	SignalPower; // in dBm.
-
-	// Translate to dBm (x=0.9y-95).
-	SignalPower = (s32)((SignalStrengthIndex * 18) / 20);
-	SignalPower -= 95;
-
-	return SignalPower;
-}
-
-
-struct sta_info;
-
-extern void  mgt_dispatcher(_adapter *padapter, union recv_frame *precv_frame);
-int process_recv_indicatepkts(_adapter *padapter, union recv_frame *prframe);
-
-void rtw_rxhandler(_adapter *padapter, struct recv_buf *precvbuf);
-union recv_frame *decryptor(_adapter *padapter, union recv_frame *precv_frame);
-
-#ifdef RX_SHORTCUT
-void rtw_free_rx_sc_entrys(ADAPTER *Adapter);
-int rtw_get_rx_sc_index(ADAPTER *Adapter, unsigned char *hdr);
-int rtw_get_rx_sc_free_entry(ADAPTER *Adapter, unsigned char *hdr);
-int rtw_check_rx_shortcut_path(_adapter *adapter, union recv_frame *precv_frame);
-#endif
-extern void rtw_signal_stat_timer_hdl(void *FunctionContext);
-
-#endif
-
diff --git a/os/board/rtl8720e/src/component/wifi/driver/include/rtw_rm.h b/os/board/rtl8720e/src/component/wifi/driver/include/rtw_rm.h
deleted file mode 100644
index ac7197958..000000000
--- a/os/board/rtl8720e/src/component/wifi/driver/include/rtw_rm.h
+++ /dev/null
@@ -1,95 +0,0 @@
-#ifndef __RTW_RM_H_
-#define __RTW_RM_H_
-
-#ifdef CONFIG_IEEE80211K
-#define RM_TIMER_NUM 		32
-#define RM_ALL_MEAS		BIT(1)
-#define RM_ID_FOR_ALL(aid)	((aid<<16)|RM_ALL_MEAS)
-
-#define RM_CAP_ARG(x) ((u8 *)(x))[4], ((u8 *)(x))[3], ((u8 *)(x))[2], ((u8 *)(x))[1], ((u8 *)(x))[0]
-#define RM_CAP_FMT "%02x %02x%02x %02x%02x"
-
-/* remember to modify rm_event_name() when adding new event */
-enum RM_EV_ID {
-	RM_EV_state_in,
-	RM_EV_busy_timer_expire,
-	RM_EV_delay_timer_expire,
-	RM_EV_meas_timer_expire,
-	RM_EV_retry_timer_expire,
-	RM_EV_repeat_delay_expire,
-	RM_EV_request_timer_expire,
-	RM_EV_wait_report,
-	RM_EV_start_meas,
-	RM_EV_survey_done,
-	RM_EV_recv_rep,
-	RM_EV_cancel,
-	RM_EV_state_out,
-	RM_EV_max
-};
-
-struct rm_event {
-	u32 rmid;
-	enum RM_EV_ID evid;
-	_list list;
-};
-
-struct rm_clock {
-	struct rm_obj *prm;
-	ATOMIC_T counter;
-	enum RM_EV_ID evid;
-};
-
-struct rm_priv {
-#ifdef CONFIG_IEEE80211K
-	u8 enable;
-	_queue ev_queue;
-	_queue rm_queue;
-	_timer rm_timer;
-
-	struct rm_clock clock[RM_TIMER_NUM];
-	u8 rm_en_cap_def[5];
-	u8 rm_en_cap_assoc[5];
-
-	/* rm debug */
-	void *prm_sel;
-
-#if defined(CONFIG_RTW_WNM)
-	struct roam_nb_info *nb_info;
-#endif
-#endif
-
-#ifdef CONFIG_LAYER2_ROAMING
-	u8 roam_flags;
-	u8 roam_status;
-	u8 to_roam; /* roaming trying times */
-	struct wlan_network *roam_network; /* the target of active roam */
-	u8 roam_rssi_diff_th; /* rssi difference threshold for active scan candidate selection */
-	u8 roam_scan_int;		/* scan interval for active roam (Unit:2 second)*/
-	u16 roam_scanr_exp_ms; /* scan result expire time in ms  for roam */
-	u8 roam_tgt_addr[ETH_ALEN]; /* request to roam to speicific target without other consideration */
-	u8 roam_rssi_threshold;
-	u32 last_roaming;
-	bool need_to_roam;
-	u8 previous_ap[ETH_ALEN];
-#endif
-
-#ifdef CONFIG_IEEE80211R
-	u8	ft_flags;
-	struct ft_roam_info *ft_info;
-#endif
-
-};
-
-void rtw_rm_enable(_adapter *padapter);
-void rtw_rm_disable(_adapter *padapter);
-void rtw_check_peer_rm_cap(_adapter *padapter, struct wlan_network *pnetwork);
-
-unsigned int onAction_rm(_adapter *padapter, union recv_frame *precv_frame);
-void RM_IE_handler(_adapter *padapter, PNDIS_802_11_VARIABLE_IEs pIE);
-
-int rm_post_event(_adapter *padapter, u32 rmid, enum RM_EV_ID evid);
-void rm_handler(_adapter *padapter, struct rm_event *pev);
-
-u8 rm_add_nb_req(_adapter *padapter, struct sta_info *psta);
-#endif
-#endif /* __RTW_RM_H_ */
diff --git a/os/board/rtl8720e/src/component/wifi/driver/include/rtw_rm_fsm.h b/os/board/rtl8720e/src/component/wifi/driver/include/rtw_rm_fsm.h
deleted file mode 100644
index 4599743bc..000000000
--- a/os/board/rtl8720e/src/component/wifi/driver/include/rtw_rm_fsm.h
+++ /dev/null
@@ -1,376 +0,0 @@
-#ifndef __RTW_RM_FSM_H_
-#define __RTW_RM_FSM_H_
-
-#ifdef CONFIG_IEEE80211K
-
-#define RM_SUPPORT_IWPRIV_DBG	1
-#define RM_MORE_DBG_MSG		1
-
-//#define DBG_BCN_REQ_DETAIL	0
-//#define DBG_BCN_REQ_WILDCARD	0
-//#define DBG_BCN_REQ_SSID	0
-//#define DBG_BCN_REQ_SSID_NAME	"RealKungFu"
-
-#define RM_REQ_TIMEOUT		10000	/* 10 seconds */
-#define RM_MEAS_TIMEOUT		10000	/* 10 seconds */
-#define RM_REPT_SCAN_INTVL	5000	/*  5 seconds */
-#define RM_REPT_POLL_INTVL	2000	/*  2 seconds */
-#define RM_COND_INTVL		2000	/*  2 seconds */
-#define RM_SCAN_DENY_TIMES	10
-#define RM_BUSY_TRAFFIC_TIMES	10
-#define RM_WAIT_BUSY_TIMEOUT	1000	/*  1 seconds */
-
-#define MEAS_REQ_MOD_PARALLEL	BIT(0)
-#define MEAS_REQ_MOD_ENABLE	BIT(1)
-#define MEAS_REQ_MOD_REQUEST	BIT(2)
-#define MEAS_REQ_MOD_REPORT	BIT(3)
-#define MEAS_REQ_MOD_DUR_MAND	BIT(4)
-
-#define MEAS_REP_MOD_LATE	BIT(0)
-#define MEAS_REP_MOD_INCAP	BIT(1)
-#define MEAS_REP_MOD_REFUSE	BIT(2)
-
-#define RM_MASTER		BIT(0)	/* STA who issue meas_req */
-#define RM_SLAVE		0	/* STA who do measurement */
-
-#define CLOCK_UNIT		10	/* ms */
-#define RTW_MAX_NB_RPT_IE_NUM	16
-
-#define RM_GET_AID(rmid)	((rmid&0xffff0000)>>16)
-#define RM_IS_ID_FOR_ALL(rmid)	(rmid&RM_ALL_MEAS)
-
-#define	MAX_OP_CHANNEL_SET_NUM	15
-
-/* IEEE 802.11-2012 Table 8-59 Measurement Type definitions
-*  for measurement request
-*  modify rm_meas_type_req_name() when adding new type
-*/
-enum meas_type_of_req {
-	BASIC_REQ = 0,	/* spectrum measurement */
-	CCA_REQ = 1,
-	RPI_HISTO_REQ = 2,
-	CH_LOAD_REQ = 3,
-	NOISE_HISTO_REQ = 4,
-	BCN_REQ = 5,
-	FRAME_REQ = 6,
-	STA_STATIS_REQ = 7,
-	LCI_REQ = 8,
-	MEAS_TYPE_REQ_MAX = 9
-};
-
-/* IEEE 802.11-2012 Table 8-81 Measurement Type definitions
-*  for measurement report
-*  modify rm_type_rep_name() when adding new type
-*/
-enum meas_type_of_rep {
-	BASIC_REP = 0,	/* spectrum measurement */
-	CCA_REP = 1,
-	RPI_HISTO_REP = 2,
-	CH_LOAD_REP = 3,	/* radio measurement */
-	NOISE_HISTO_REP = 4,
-	BCN_REP = 5,
-	FRAME_REP = 6,
-	STA_STATIS_REP = 7,	/* Radio measurement and WNM */
-	LCI_REP = 8,
-	MEAS_TYPE_REP_MAX = 9
-};
-
-/*
-* Beacon request
-*/
-/* IEEE 802.11-2012 Table 8-64 Measurement mode for Beacon Request element */
-enum bcn_req_meas_mode {
-	BCN_REQ_PASSIVE = 0,
-	BCN_REQ_ACTIVE = 1,
-	BCN_REQ_BCN_TABLE = 2
-};
-
-/* IEEE 802.11-2012 Table 8-65 optional subelement IDs for Beacon Request */
-enum bcn_req_opt_sub_id {
-	BCN_REQ_SSID = 0,		/* len 0-32 */
-	BCN_REQ_REP_INFO = 1,		/* len 2 */
-	BCN_REQ_REP_DETAIL = 2,		/* len 1 */
-	BCN_REQ_REQ = 10,		/* len 0-237 */
-	BCN_REQ_AC_CH_REP = 51		/* len 1-237 */
-};
-
-/* IEEE 802.11-2012 Table 8-66 Reporting condition of Beacon Report */
-enum bcn_rep_cound_id {
-	BCN_REP_COND_IMMEDIATELY = 0,	/* default */
-	BCN_REP_COND_RCPI_GREATER = 1,
-	BCN_REP_COND_RCPI_LESS = 2,
-	BCN_REP_COND_RSNI_GREATER = 3,
-	BCN_REP_COND_RSNI_LESS = 4,
-	BCN_REP_COND_MAX = 5
-};
-
-struct opt_rep_info {
-	u8 cond;
-	u8 threshold;
-};
-
-#define BCN_REQ_OPT_MAX_NUM		16
-struct bcn_req_opt {
-	/* all req cmd id */
-	u8 opt_id[BCN_REQ_OPT_MAX_NUM];
-	u8 opt_id_num;
-	u8 rep_detail;
-	NDIS_802_11_SSID ssid;
-
-	/* bcn report condition */
-	struct opt_rep_info rep_cond;
-
-	/* 0:default(Report to be issued after each measurement) */
-	u8 *req_start;	/*id : 10 request;start  */
-	u8 req_len;	/*id : 10 request;length */
-};
-
-/*
-* channel load
-*/
-/* IEEE 802.11-2012 Table 8-60 optional subelement IDs for channel load request */
-enum ch_load_opt_sub_id {
-	CH_LOAD_RSVD = 0,
-	CH_LOAD_REP_INFO = 1
-};
-
-/* IEEE 802.11-2012 Table 8-61 Reporting condition for channel load Report */
-enum ch_load_cond_id {
-	CH_LOAD_COND_IMMEDIATELY = 0,	/* default */
-	CH_LOAD_COND_ANPI_EQUAL_GRRATER = 1,
-	CH_LOAD_COND_ANPI_EQUAL_LESS = 2,
-	CH_LOAD_COND_MAX = 3
-};
-
-/*
-* Noise histogram
-*/
-/* IEEE 802.11-2012 Table 8-62 optional subelement IDs for noise histogram */
-enum noise_histo_opt_sub_id {
-	NOISE_HISTO_RSVD = 0,
-	NOISE_HISTO_REP_INFO = 1
-};
-
-/* IEEE 802.11-2012 Table 8-63 Reporting condition for noise historgarm Report */
-enum noise_histo_cond_id {
-	NOISE_HISTO_COND_IMMEDIATELY = 0,	/* default */
-	NOISE_HISTO_COND_ANPI_EQUAL_GRRATER = 1,
-	NOISE_HISTO_COND_ANPI_EQUAL_LESS = 2,
-	NOISE_HISTO_COND_MAX = 3
-};
-
-struct meas_req_opt {
-	/* report condition */
-	struct opt_rep_info rep_cond;
-};
-
-/*
-* State machine
-*/
-enum RM_STATE {
-	RM_ST_IDLE,
-	RM_ST_DO_MEAS,
-	RM_ST_WAIT_MEAS,
-	RM_ST_SEND_REPORT,
-	RM_ST_RECV_REPORT,
-	RM_ST_END,
-	RM_ST_MAX
-};
-
-struct rm_meas_req {
-	u8 category;
-	u8 action_code;		/* T8-206  */
-	u8 diag_token;
-	u16 rpt;
-
-	u8 e_id;
-	u8 len;
-	u8 m_token;
-	u8 m_request_mode;		/* req:F8-105, rep:F8-141 */
-	u8 m_type;		/* T8-59 */
-	u8 op_class;
-	u8 ch_num;
-	u16 rand_intvl;		/* units of TU */
-	u16 meas_dur;		/* units of TU */
-
-	u8 bssid[6];		/* for bcn_req */
-	u8 m_mode;		/* for bcn_req */
-
-	u8 *pssid;
-	u8 *opt_s_elem_start;
-	int opt_s_elem_len;
-
-	s8 tx_pwr_used;		/* for link measurement */
-	s8 tx_pwr_max;		/* for link measurement */
-
-	union {
-		struct bcn_req_opt bcn;
-		struct meas_req_opt clm;
-		struct meas_req_opt nhm;
-	} opt;
-
-	struct rtw_ieee80211_channel ch_set[MAX_OP_CHANNEL_SET_NUM];
-	u8 ch_set_ch_amount;
-	s8 rx_pwr;		/* in dBm */
-	u8 rx_bw;
-	u8 rx_rate;
-	u8 rx_rsni;
-};
-
-struct rm_meas_rep {
-	u8 category;
-	u8 action_code;		/* T8-206  */
-	u8 diag_token;
-
-	u8 e_id;		/* T8-54, 38 request; 39 report */
-	u8 len;
-	u8 m_token;
-	u8 m_mode;		/* req:F8-105, rep:F8-141 */
-	u8 m_type;		/* T8-59 */
-	u8 op_class;
-	u8 ch_num;
-
-	u8 ch_load;
-	u8 anpi;
-	u8 ipi[11];
-
-	u16 rpt;
-	u8 bssid[6];		/* for bcn_rep */
-};
-
-#define MAX_BUF_NUM	128
-struct data_buf {
-	u8 *pbuf;
-	u16 len;
-};
-
-struct rm_obj {
-
-	/* aid << 16
-		|diag_token << 8
-		|B(1) 1/0:All_AID/UNIC
-		|B(0) 1/0:RM_MASTER/RM_SLAVE */
-	u32 rmid;
-
-	enum RM_STATE state;
-	struct rm_meas_req q;
-	struct rm_meas_rep p;
-	struct sta_info *psta;
-	struct rm_clock *pclock;
-
-	/* meas report */
-	u64 meas_start_time;
-	u64 meas_end_time;
-	int wait_busy;
-	u8 poll_mode;
-	u8 free_run_counter_valid; /* valid:_SUCCESS/invalid:_FAIL */
-
-	struct data_buf buf[MAX_BUF_NUM];
-
-	_list list;
-};
-
-/*
-* Measurement
-*/
-struct opt_subelement {
-	u8 id;
-	u8 length;
-	u8 *data;
-};
-
-/* 802.11-2012 Table 8-206 Radio Measurment Action field */
-enum rm_action_code {
-	RM_ACT_RADIO_MEAS_REQ = 0,
-	RM_ACT_RADIO_MEAS_REP = 1,
-	RM_ACT_LINK_MEAS_REQ = 2,
-	RM_ACT_LINK_MEAS_REP = 3,
-	RM_ACT_NB_REP_REQ = 4,	/* 4 */
-	RM_ACT_NB_REP_RESP = 5,
-	RM_ACT_RESV,
-	RM_ACT_MAX
-};
-
-/* 802.11-2012 Table 8-119 RM Enabled Capabilities definition */
-enum rm_cap_en {
-	RM_LINK_MEAS_CAP_EN,
-	RM_NB_REP_CAP_EN,		/* neighbor report */
-	RM_PARAL_MEAS_CAP_EN,		/* parallel report */
-	RM_REPEAT_MEAS_CAP_EN,
-	RM_BCN_PASSIVE_MEAS_CAP_EN,
-	RM_BCN_ACTIVE_MEAS_CAP_EN,
-	RM_BCN_TABLE_MEAS_CAP_EN,
-	RM_BCN_MEAS_REP_COND_CAP_EN,	/* conditions */
-
-	RM_FRAME_MEAS_CAP_EN,
-	RM_CH_LOAD_CAP_EN,
-	RM_NOISE_HISTO_CAP_EN,		/* noise historgram */
-	RM_STATIS_MEAS_CAP_EN,		/* statistics */
-	RM_LCI_MEAS_CAP_EN,		/* 12 */
-	RM_LCI_AMIMUTH_CAP_EN,
-	RM_TRANS_STREAM_CAT_MEAS_CAP_EN,
-	RM_TRIG_TRANS_STREAM_CAT_MEAS_CAP_EN,
-
-	RM_AP_CH_REP_CAP_EN,
-	RM_RM_MIB_CAP_EN,
-	RM_OP_CH_MAX_MEAS_DUR0,		/* 18-20 */
-	RM_OP_CH_MAX_MEAS_DUR1,
-	RM_OP_CH_MAX_MEAS_DUR2,
-	RM_NONOP_CH_MAX_MEAS_DUR0,	/* 21-23 */
-	RM_NONOP_CH_MAX_MEAS_DUR1,
-	RM_NONOP_CH_MAX_MEAS_DUR2,
-
-	RM_MEAS_PILOT_CAP0,		/* 24-26 */
-	RM_MEAS_PILOT_CAP1,
-	RM_MEAS_PILOT_CAP2,
-	RM_MEAS_PILOT_TRANS_INFO_CAP_EN,
-	RM_NB_REP_TSF_OFFSET_CAP_EN,
-	RM_RCPI_MEAS_CAP_EN,		/* 29 */
-	RM_RSNI_MEAS_CAP_EN,
-	RM_BSS_AVG_ACCESS_DELAY_CAP_EN,
-
-	RM_AVALB_ADMIS_CAPACITY_CAP_EN,
-	RM_ANT_CAP_EN,
-	RM_RSVD,			/* 34-39 */
-	RM_MAX
-};
-
-void rm_timer_callback(void *data);
-char *rm_state_name(enum RM_STATE state);
-char *rm_event_name(enum RM_EV_ID evid);
-char *rm_type_req_name(u8 meas_type);
-int _rm_post_event(_adapter *padapter, u32 rmid, enum RM_EV_ID evid);
-int rm_enqueue_rmobj(_adapter *padapter, struct rm_obj *obj, bool to_head);
-
-void rm_free_rmobj(struct rm_obj *prm);
-struct rm_obj *rm_alloc_rmobj(_adapter *padapter);
-struct rm_obj *rm_get_rmobj(_adapter *padapter, u32 rmid);
-struct sta_info *rm_get_psta(_adapter *padapter, u32 rmid);
-
-int retrieve_radio_meas_result(struct rm_obj *prm);
-int rm_radio_meas_report_cond(struct rm_obj *prm);
-int rm_recv_radio_mens_req(_adapter *padapter,
-						   union recv_frame *precv_frame, struct sta_info *psta);
-int rm_recv_radio_mens_rep(_adapter *padapter,
-						   union recv_frame *precv_frame, struct sta_info *psta);
-int rm_recv_link_mens_req(_adapter *padapter,
-						  union recv_frame *precv_frame, struct sta_info *psta);
-int rm_recv_link_mens_rep(_adapter *padapter,
-						  union recv_frame *precv_frame, struct sta_info *psta);
-int rm_radio_mens_nb_rep(_adapter *padapter,
-						 union recv_frame *precv_frame, struct sta_info *psta);
-int issue_null_reply(struct rm_obj *prm);
-int issue_beacon_rep(struct rm_obj *prm);
-int issue_nb_req(struct rm_obj *prm);
-int issue_radio_meas_req(struct rm_obj *prm);
-int issue_radio_meas_rep(struct rm_obj *prm);
-int issue_link_meas_req(struct rm_obj *prm);
-int issue_link_meas_rep(struct rm_obj *prm);
-
-void rm_set_rep_mode(struct rm_obj *prm, u8 mode);
-
-int ready_for_scan(struct rm_obj *prm);
-int rm_sitesurvey(struct rm_obj *prm);
-
-#endif /*CONFIG_IEEE80211K*/
-#endif /*__RTW_RM_FSM_H_*/
diff --git a/os/board/rtl8720e/src/component/wifi/driver/include/rtw_rm_op_class.h b/os/board/rtl8720e/src/component/wifi/driver/include/rtw_rm_op_class.h
deleted file mode 100644
index a41957b16..000000000
--- a/os/board/rtl8720e/src/component/wifi/driver/include/rtw_rm_op_class.h
+++ /dev/null
@@ -1,229 +0,0 @@
-/*
- * Operating classes in different countries of 802.11-2016.
- *
- * Copyright (C) 2021 Realsil <juanhong_sheng@realsil.com.cn>
- *
- * RTK WLAN Raddio Measurement driver for Ameba.
- *
- */
-
-#ifndef __RTW_RM_OP_CLASS_H_
-#define __RTW_RM_OP_CLASS_H_
-
-#ifdef CONFIG_IEEE80211K
-typedef struct _RT_OPERATING_CLASS {
-	int	op_class;
-	int	global_op_class;
-	int	Len;
-	u16	Channel[MAX_OP_CHANNEL_SET_NUM];
-} RT_OPERATING_CLASS, *PRT_OPERATING_CLASS;
-
-typedef struct _OPERATING_CLASS {
-	int len_total ;
-	RT_OPERATING_CLASS *operating_cls;
-} OPERATING_CLASS;
-
-
-/* 802.11-2016 Table E-1 Operationg classes in United States */
-const RT_OPERATING_CLASS RTW_OP_CLASS_US[] = {
-	{  0,   0,  0, {0}},	/* 0, OP_CLASS_NULL */
-	{  1, 115,  4, {36, 40, 44, 48}},	/* 1, OP_CLASS_1 */
-	{  2, 118,  4, {52, 56, 60, 64}},
-	{  3, 124,  4, {149, 153, 157, 161}},
-	{
-		4, 121, 12, {
-			100, 104, 108, 112, 116, 120, 124, 128,
-			132, 136, 140, 144
-		}
-	},
-	{  5, 125,  5, {149, 153, 157, 161, 165}},
-	{  6, 103, 10, {1, 2, 3, 4, 5, 6, 7, 8, 9, 10}},	/* 5, OP_CLASS_5 */
-	{  7, 103, 10, {1, 2, 3, 4, 5, 6, 7, 8, 9, 10}},
-	{  8, 102,  5, {11, 13, 15, 17, 19}},
-	{  9, 102,  5, {11, 13, 15, 17, 19}},
-	{ 10, 101,  2, {21, 25}},
-	{ 11, 101,  2, {21, 25}},	/* 11, OP_CLASS_11 */
-	{ 12,  81, 11, {1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11}},
-	{ 13,  94,  2, {133, 137}},
-	{ 14,  95,  4, {132, 134, 136, 138}},
-	{ 15,  96,  8, {131, 132, 133, 134, 135, 136, 137, 138}},	/* 15, OP_CLASS_15 */
-	{
-		16,   0, 15, {
-			170, 171, 172, 173, 174, 175, 176, 177,
-			178, 179, 180, 181, 182, 183, 184
-		}
-	},
-	{
-		17,   0, 14, {
-			171, 172, 173, 174, 175, 176, 177, 178,
-			179, 180, 181, 182, 183, 184
-		}
-	},
-	{
-		18,   0, 12, {
-			172, 173, 174, 175, 176, 177, 178, 179,
-			180, 181, 182, 183
-		}
-	},
-	{ 22, 116,  2, {36, 44}},	/* 22, OP_CLASS_22 */
-	{ 23, 119,  2, {52, 60}},
-	{ 24, 122,  6, {100, 108, 116, 124, 132, 140}},
-	{ 25, 126,  2, {149, 157}},
-	{ 26, 126,  2, {149, 157}},
-	{ 27, 117,  2, {40, 48}},
-	{ 28, 120,  2, {56, 64}},
-	{ 29, 123,  6, {104, 112, 120, 128, 136, 144}},
-	{ 30, 127,  2, {153, 161}},
-	{ 31, 127,  2, {153, 161}},	/* 31, OP_CLASS_31 */
-	{ 32,  83,  7, {1, 2, 3, 4, 5, 6, 7}},
-	{ 33,  84,  7, {5, 6, 7, 8, 9, 10, 11}},
-	{ 34, 180,  6, {1, 2, 3, 4, 5, 6}}
-};
-
-
-
-/* 802.11-2016 Table E-2 Operationg classes in Europe */
-const RT_OPERATING_CLASS RTW_OP_CLASS_EU[] = {
-	{  0,   0,  0, {0}},	/* 0, OP_CLASS_NULL */
-	{  1, 115,  4, {36, 40, 44, 48}},	/* 1, OP_CLASS_1 */
-	{  2, 118,  4, {52, 56, 60, 64}},
-	{
-		3, 121, 11, {
-			100, 104, 108, 112, 116, 120, 124, 128,
-			132, 136, 140
-		}
-	},
-	{  4,  81, 13, {1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13}},
-	{  5, 116,  2, {36, 44}},	/* 5, OP_CLASS_5 */
-	{  6, 119,  2, {52, 60}},
-	{  7, 122,  5, {100, 108, 116, 124, 132}},
-	{  8, 117,  2, {40, 48}},
-	{  9, 120,  2, {56, 64}},
-	{ 10, 123,  5, {104, 112, 120, 128, 136}},
-	{ 11,  83,  9, {1, 2, 3, 4, 5, 6, 7, 8, 9}},	/* 11, OP_CLASS_11 */
-	{ 12,  84,  9, {5, 6, 7, 8, 9, 10, 11, 12, 13}},
-	{
-		13,   0, 14, {
-			171, 172, 173, 174, 175, 176, 177, 178,
-			179, 180, 181, 182, 183, 184
-		}
-	},
-	{
-		14,   0, 14, {
-			171, 172, 173, 174, 175, 176, 177, 178,
-			179, 180, 181, 182, 183, 184
-		}
-	},
-	{
-		15,   0, 12, {
-			172, 173, 174, 175, 176, 177, 178, 179,
-			180, 181, 182, 183
-		}
-	},	/* 15, OP_CLASS_15 */
-	{
-		16,   0, 11, {
-			100, 104, 108, 112, 116, 120, 124, 128,
-			132, 136, 140
-		}
-	},
-	{ 17, 125,  6, {149, 153, 157, 161, 165, 169}},
-	{ 18, 180,  4, {1, 2, 3, 4}}
-};
-
-
-/* 802.11-2016 Table E-3 Operationg classes in Japan */
-const RT_OPERATING_CLASS RTW_OP_CLASS_JP[] = {
-	{  0,   0,  0, {0}},	/* 0, OP_CLASS_NULL */
-	{  1, 115,  4, {36, 40, 44, 48}},	/* 1, OP_CLASS_1 */
-	{  2, 112,  3, {8, 12, 16}},
-	{  3, 112,  3, {8, 12, 16}},
-	{  4, 112,  3, {8, 12, 16}},
-	{  5, 112,  3, {8, 12, 16}},	/* 5, OP_CLASS_5 */
-	{  6, 112,  3, {8, 12, 16}},
-	{  7, 109,  4, {184, 188, 192, 196}},
-	{  8, 109,  4, {184, 188, 192, 196}},
-	{  9, 109,  4, {184, 188, 192, 196}},
-	{ 10, 109,  4, {184, 188, 192, 196}},
-	{ 11, 109,  4, {184, 188, 192, 196}},	/* 11, OP_CLASS_11 */
-	{ 12, 113,  4, {7, 8, 9, 11}},
-	{ 13, 113,  4, {7, 8, 9, 11}},
-	{ 14, 113,  4, {7, 8, 9, 11}},
-	{ 15, 113,  4, {7, 8, 9, 11}},	/* 15, OP_CLASS_15 */
-	{ 16, 110,  6, {183, 184, 185, 187, 188, 189}},
-	{ 17, 110,  6, {183, 184, 185, 187, 188, 189}},
-	{ 18, 110,  6, {183, 184, 185, 187, 188, 189}},
-	{ 16, 110,  6, {183, 184, 185, 187, 188, 189}},
-	{ 17, 110,  6, {183, 184, 185, 187, 188, 189}},
-	{ 18, 114,  6, {6, 7, 8, 9, 10, 11}},	/* 21, OP_CLASS_21 */
-	{ 22, 114,  6, {6, 7, 8, 9, 10, 11}},
-	{ 23, 114,  6, {6, 7, 8, 9, 10, 11}},
-	{ 24, 114,  6, {6, 7, 8, 9, 10, 11}},
-	{ 25, 111,  8, {182, 183, 184, 185, 186, 187, 188, 189}},	/* 25, OP_CLASS_25 */
-	{ 26, 111,  8, {182, 183, 184, 185, 186, 187, 188, 189}},
-	{ 27, 111,  8, {182, 183, 184, 185, 186, 187, 188, 189}},
-	{ 28, 111,  8, {182, 183, 184, 185, 186, 187, 188, 189}},
-	{ 29, 111,  8, {182, 183, 184, 185, 186, 187, 188, 189}},
-	{ 30,  81, 13, {1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13}},
-	{ 31,  82,  1, {14}},	/* 31, OP_CLASS_31 */
-	{ 32, 118,  4, {52, 56, 60, 64}},
-	{ 33, 118,  4, {52, 56, 60, 64}},
-	{
-		34, 121, 11, {
-			100, 104, 108, 112, 116, 120, 124, 128,
-			132, 136, 140
-		}
-	},
-	{
-		35, 121, 11, {
-			100, 104, 108, 112, 116, 120, 124, 128,
-			132, 136, 140
-		}
-	},	/* 35, OP_CLASS_35 */
-	{ 36, 116,  2, {36, 44}},
-	{ 37, 119,  2, {52, 60}},
-	{ 38, 119,  2, {52, 60}},
-	{ 39, 122,  5, {100, 108, 116, 124, 132}},
-	{ 40, 122,  5, {100, 108, 116, 124, 132}},
-	{ 41, 117,  2, {40, 48}},	/* 41, OP_CLASS_41 */
-	{ 42, 120,  2, {56, 64}},
-	{ 43, 120,  2, {56, 64}},
-	{ 44, 123,  5, {104, 112, 120, 128, 136}},
-	{ 45, 123,  5, {104, 112, 120, 128, 136}},	/* 45, OP_CLASS_45 */
-	{ 46, 104,  2, {184, 192}},
-	{ 47, 104,  2, {184, 192}},
-	{ 48, 104,  2, {184, 192}},
-	{ 49, 104,  2, {184, 192}},
-	{ 50, 104,  2, {184, 192}},
-	{ 51, 105,  2, {188, 196}},	/* 51, OP_CLASS_51 */
-	{ 52, 105,  2, {188, 196}},
-	{ 53, 105,  2, {188, 196}},
-	{ 54, 105,  2, {188, 196}},
-	{ 55, 105,  2, {188, 196}},	/* 55, OP_CLASS_55 */
-	{ 56,  83,  9, {1, 2, 3, 4, 5, 6, 7, 8, 9}},
-	{ 57,  84,  9, {5, 6, 7, 8, 9, 10, 11, 12, 13}},
-	{
-		58, 121, 11, {
-			100, 104, 108, 112, 116, 120, 124, 128,
-			132, 136, 140
-		}
-	},
-	{ 59, 180,  4, {1, 2, 3, 4}}
-};
-
-
-/* 802.11-2016 Table E-5 Operationg classes in China */
-const RT_OPERATING_CLASS RTW_OP_CLASS_CN[] = {
-	{  0,   0,  0, {0}},	/* 0, OP_CLASS_NULL */
-	{  1, 115,  4, {36, 40, 44, 48}},	/* 1, OP_CLASS_1 */
-	{  2, 118,  4, {52, 56, 60, 64}},
-	{  3, 125,  5, {149, 153, 157, 161, 165}},
-	{  4, 116,  2, {36, 44}},
-	{  5, 119,  2, {52, 60}},	/* 5, OP_CLASS_5 */
-	{  6, 126,  2, {149, 157}},
-	{  7,  81, 13, {1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13}},
-	{  8,  83,  9, {1, 2, 3, 4, 5, 6, 7, 8, 9}},
-	{  9,  84,  9, {5, 6, 7, 8, 9, 10, 11, 12, 13}},
-};
-
-#endif
-#endif /* __RTW_RM_OP_CLASS_H_ */
diff --git a/os/board/rtl8720e/src/component/wifi/driver/include/rtw_rm_util.h b/os/board/rtl8720e/src/component/wifi/driver/include/rtw_rm_util.h
deleted file mode 100644
index 8c51cb6eb..000000000
--- a/os/board/rtl8720e/src/component/wifi/driver/include/rtw_rm_util.h
+++ /dev/null
@@ -1,40 +0,0 @@
-#ifndef _RTW_RM_UTIL_H_
-#define _RTW_RM_UTIL_H_
-/*
- * define the following channels as the max channels in each channel plan.
- * 2G, total 14 chnls
- * {1,2,3,4,5,6,7,8,9,10,11,12,13,14}
- * 5G, total 25 chnls
- * {36,40,44,48,52,56,60,64,100,104,108,112,116,120,124,128,132,136,140,144,149,153,157,161,165}
- */
-#ifndef MAX
-#define MAX(x, y) (((x) > (y)) ? (x) : (y))
-#endif
-
-#ifdef CONFIG_IEEE80211K
-struct rate_section_ent {
-	u8 tx_num; /* value of RF_TX_NUM */
-	u8 rate_num;
-	u8 *rates;
-};
-
-#define rate_section_to_tx_num(section) (rates_by_sections[(section)].tx_num)
-#define rate_section_rate_num(section) (rates_by_sections[(section)].rate_num)
-#endif
-
-void rm_init_rtw_op_class(_adapter *padapter);
-u8 rm_set_rtw_op_class(u32 country_code);
-u8 rm_get_oper_class_via_ch(u8 ch);
-u8 rm_get_ch_set(struct rtw_ieee80211_channel *pch_set, u8 op_class, u8 ch_num);
-u8 rm_get_bcn_rsni(struct rm_obj *prm, struct wlan_network *pnetwork);
-u8 rm_get_bcn_rcpi(struct rm_obj *prm, struct wlan_network *pnetwork);
-u8 rm_get_frame_rsni(struct rm_obj *prm, union recv_frame *pframe);
-u8 translate_percentage_to_rcpi(u32 SignalStrengthIndex);
-u8 translate_dbm_to_rcpi(s8 SignalPower);
-int is_wildcard_bssid(u8 *bssid);
-
-int rm_get_path_a_max_tx_power(_adapter *adapter, s8 *path_a);
-int rm_get_tx_power(PADAPTER adapter, enum rf_path path, u8 rate, s8 *pwr);
-int rm_get_rx_sensitivity(PADAPTER adapter, enum channel_width bw, u8 rate, s8 *pwr);
-
-#endif /* _RTW_RM_UTIL_H_ */
diff --git a/os/board/rtl8720e/src/component/wifi/driver/include/rtw_sae.h b/os/board/rtl8720e/src/component/wifi/driver/include/rtw_sae.h
deleted file mode 100644
index c31fca18b..000000000
--- a/os/board/rtl8720e/src/component/wifi/driver/include/rtw_sae.h
+++ /dev/null
@@ -1,410 +0,0 @@
-/******************************************************************************
- *
- * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of version 2 of the GNU General Public License as
- * published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
- * more details.
- *
- * You should have received a copy of the GNU General Public License along with
- * this program; if not, write to the Free Software Foundation, Inc.,
- * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
- *
- *
- ******************************************************************************/
-#ifndef __RTW_SAE_H_
-#define __RTW_SAE_H_
-
-#include "rtw_opt_crypto_ssl.h"
-
-#if (CONFIG_SAE_DH_SUPPORT == 1)
-#include "dh_groups.h"
-#endif
-/*********************************************************************************************
-
-                     						Micro Defination
-
-*********************************************************************************************/
-#define SAE_KCK_LEN 		32
-#define SAE_PMK_LEN 		32
-#define SAE_PMKID_LEN 		16
-#define SAE_GRP_SIZE 		10			/* SAE group size: 6 ECC group + 4 FFC group */
-#define SAE_PWE_MAX_CNT  	40
-#define SAE_MAX_PRIME_LEN	512
-#define SAE_MAX_ECC_PRIME_LEN 66
-
-#define SAE_SEQ_COMMIT 		1
-#define SAE_SEQ_CONFIRM 	2
-
-#define dot11RSNASAESync    5
-
-/* Special value returned by sae_parse_commit() */
-#define SAE_SILENTLY_DISCARD 65535
-
-
-#ifndef MAC2STR
-#define MAC2STR(a) (a)[0], (a)[1], (a)[2], (a)[3], (a)[4], (a)[5]
-#define MACSTR "%02x:%02x:%02x:%02x:%02x:%02x"
-#endif
-/*********************************************************************************************
-
-                     						Data Structure
-
-*********************************************************************************************/
-
-enum sae_state {
-	SAE_NOTHING,
-	SAE_COMMITTED,
-	SAE_CONFIRMED,
-	SAE_ACCEPTED
-};
-
-enum sae_type {
-	_SAE_TYPE_COMMIT_,
-	_SAE_TYPE_CONFIRM_
-};
-
-enum sae_group_config {
-	_GRP_KEEP_CURRENT_,		/* keep current group id */
-	_GRP_AUTO_SELECT_, 		/* auto select a group id in sae_groups[] */
-	_GRP_USER_CONFIG_		/* manually config the group id through user cmd */
-};
-
-/*
-**  event defination(32bits):
-**
-**  [ 31:16 ]	[ ~ ]	   [ 9 ]	   [ 8 ]	   [ 7 ]	 [ 6 ]		[ 5 ]	 [ 4 ]	  [ 3 ]   [ 2 ]  [ 1 ]	[ 0 ]
-**   status  | reserve | moregroups | lowmac | highmac | badauth | diffgroup | badgroup | badid  | con	| com  | init
-*/
-enum sae_event {
-	_SAE_INIT_ 		 = BIT(0),
-	_SAE_COM_  		 = BIT(1),
-	_SAE_CON_  		 = BIT(2),
-	_SAE_BADID_ 	 = BIT(3),
-	_SAE_BADGROUP_ 	 = BIT(4),
-	_SAE_DIFFGROUP_  = BIT(5),
-	_SAE_BADAUTH_	 = BIT(6),
-	_SAE_HIGMAC_	 = BIT(7),
-	_SAE_LOWMAC_	 = BIT(8),
-	_SAE_MOREGROUPS_ = BIT(9),
-};
-
-struct sae_octect_buf {
-	u8 *pbuf;
-	u8  length;
-};
-
-struct sae_data {
-	_adapter	*padapter;	/* pointer to adapter */
-	enum sae_state state;
-	u16 sc;					/* own send-confirm counter */
-	u16 rc;					/* peer send-confirm counter */
-	u32 sync;	 			/* protocol instance variable: Sync */
-	u16 group;				/* FCC(Finite Cyclic Cryptography) group ID */
-	u32 sae_grp_idx;		/* index to the current group in the sae_groups	*/
-	u16 last_peer_cmit_seq_num;	/* seq number of commit frame in wlan header */
-	u16 last_peer_cfrm_seq_num;	/* seq number of confirm frame in wlan header */
-	u16 last_status;		/* status code */
-	u8 h2e;					/* hash to element support */
-	u8 pmk[SAE_PMK_LEN];
-	u8 pmkid[SAE_PMKID_LEN];
-	u8 kck[SAE_KCK_LEN];
-
-	sae_crypto_bignum order;
-	u32 order_len;
-	sae_crypto_bignum prime;
-	u32 prime_len;
-
-	sae_crypto_bignum rand;
-	sae_crypto_bignum mask;
-
-	sae_crypto_bignum own_commit_scalar;
-	sae_crypto_bignum peer_commit_scalar;
-
-	sae_ecc_crypto *ecc;
-	sae_ecc_point pwe_ecc;
-	sae_ecc_point own_commit_element_ecc;
-	sae_ecc_point peer_commit_element_ecc;
-	sae_ecc_point pt_ecc;
-
-	const struct dh_group *dh;
-	sae_crypto_bignum pwe_ffc;
-	sae_crypto_bignum own_commit_element_ffc;
-	sae_crypto_bignum peer_commit_element_ffc;
-	sae_crypto_bignum pt_ffc;
-
-	/*
-	** password to generate PWE,get from wpa passphase
-	** or password identifier from auth frame
-	*/
-	struct sae_octect_buf sae_password;
-	struct sae_octect_buf anti_clogging_token;
-
-};
-
-/*********************************************************************************************
-
-                     						Debug Info
-
-*********************************************************************************************/
-
-extern int sae_debug_level;
-
-//#define SAE_DEBUG_ENABLE
-#define _SAE_MSG_INFO_	2
-#define _SAE_MSG_ERR_	1
-
-#ifdef SAE_DEBUG_ENABLE
-#define sae_printf(level, fmt, arg...)     \
-do {\
-	if(level <= sae_debug_level)	\
-		printf("\r\nSAE: " fmt, ##arg);\
-}while(0)
-#else
-#define sae_printf(level, fmt, arg...)
-#endif
-
-
-/*********************************************************************************************
-
-                     						SAE Function
-
-*********************************************************************************************/
-
-
-/*********************************************************************************************
-Function:  compare s1 and s2
-
-Parameter: @s1: input 1
-           @s2: input 2
-           @n: length of input string
-
-return:    0: if equal
-           >0: if s1 > s2
-           <0: if s1 < s2
-*********************************************************************************************/
-int sae_memcmp(void *s1, void *s2, u8 n);
-
-
-/*********************************************************************************************
-Function:  shift buffer
-
-Parameter: @buf: pointer of buffer to shift
-           @len: the length of buffer
-           @bits: bit counter of buffer
-
-return:    void
-*********************************************************************************************/
-void sae_buf_shift_right(u8 *buf, size_t len, size_t bits);
-
-
-/*********************************************************************************************
-Function:  check if sync is greater than dot11RSNASAESync
-
-Parameter: @sae: pointer to sae data
-
-result:    1: yes; 0: no
-*********************************************************************************************/
-int rtw_sae_check_big_sync(struct sae_data *sae);
-
-
-/*********************************************************************************************
-Function:  switch sae state
-
-Parameter: @sae: 	   pointer to sae data
-           @peer_addr: peer mac address
-           @sate:  	   enum sae_state{}
-           @reason:    a string for mark
-
-result:    void
-*********************************************************************************************/
-void rtw_sae_set_state(struct sae_data *sae, u8 *peer_addr, enum sae_state state, const char *reason);
-
-
-/*********************************************************************************************
-Function:  ecc initialization of group id
-
-Parameter: @group_id: group definition of spec, the default value is 19/20/21/25/26
-
-return:    sae_ecc_crypto *: pointer of cryto ecc
-*********************************************************************************************/
-sae_ecc_crypto *sae_crypto_ecc_init(unsigned char group_id);
-
-
-/*********************************************************************************************
-Function:  ecc clear
-
-Parameter: @pointer of ecc group
-
-return:    void
-*********************************************************************************************/
-void sae_crypto_ecc_free(sae_ecc_crypto *ecc);
-
-
-/*********************************************************************************************
-Function:  generate SAE commit msg
-		   1.)select a finite cyclic group
-		   2.)generate pwe
-		   3.)generate rand/mask
-		   4.)generate commit-scalar
-		   5.)generate commit-element
-
-Parameter: @sae:       pointer to sae_data
-           @own_addr:  pointer to own mac address
-           @peer_add:  pointer to peer mac address
-           @group_config: _GRP_KEEP_CURRENT_, _GRP_AUTO_SELECT_, _GRP_USER_CONFIG_
-
-result:    0:success; -1: fail
-*********************************************************************************************/
-int rtw_sae_generate_commit_msg(struct sae_data *sae, u8 *own_addr, u8 *peer_addr, enum sae_group_config group_config);
-
-
-/*********************************************************************************************
-Function:  prepare SAE commit frame
-
-Parameter: @pframe:		   pointer to next position of left frame buffer
-           @sae:		   pointer to sae data
-           @available_len: available size of buffer
-           @frame_len:     current size of frame
-           @status: 	   status code response to peer STA
-
-result:    pointer to position of next available memeroy
-*********************************************************************************************/
-u8 *rtw_sae_prepare_commit(u8 *pframe,	struct sae_data *sae, u32 available_len,	u32 *frame_len, u16 status);
-
-
-/*********************************************************************************************
-Function:  prepare SAE confirm frame
-
-Parameter: @pframe:		   pointer to next position of left frame buffer
-           @sae:		   pointer to sae data
-           @available_len: available size of buffer
-           @frame_len: 	   current size of frame
-
-result:    pointer to position of next available memeroy
-*********************************************************************************************/
-u8 *rtw_sae_prepare_confirm(u8 *pframe, struct sae_data *sae, u32 available_len,	u32 *frame_len);
-
-
-/*********************************************************************************************
-Function:  derive PWE
-
-Parameter: @sae_priv: pointer of sae_data
-           @addr1: array of local mac address
-           @addr2: array of peer mac address
-           @password: array of password denote as ASCII
-           @password_len: password size
-
-return:    0 if successful
-           -1 if failed
-*********************************************************************************************/
-int sae_derive_pwe_ecc(struct sae_data *sae_priv, unsigned char *addr1, unsigned char *addr2,
-					   unsigned char *password, unsigned int password_len);
-
-
-/*********************************************************************************************
-Function:  derive PWE for ffc
-
-Parameter: @sae_priv: pointer of sae_data
-           @addr1: array of local mac address
-           @addr2: array of peer mac address
-           @password: array of password denote as ASCII
-           @password_len: password size
-
-return:    0 if successful
-           -1 if failed
-*********************************************************************************************/
-int sae_derive_pwe_ffc(struct sae_data *sae_priv, unsigned char *addr1, unsigned char *addr2,
-					   unsigned char *password, unsigned int password_len);
-
-
-/*********************************************************************************************
-Function:  derive k
-		   K = scalar-op(rand, (elem-op(scalar-op(peer-commit-scalar, PWE),PEER-COMMIT-ELEMENT)))
-		   If K is identity element (point-at-infinity), reject
-		   k = F(K) (= x coordinate)
-
-Parameter: @sae_priv: pointer of sae_data
-           @k: output key
-
-return:    0 if successful
-           -1 if failed
-*********************************************************************************************/
-int sae_derive_k_ecc(struct sae_data *sae_priv, unsigned char *k);
-
-
-/*********************************************************************************************
-Function:  derive k ffc
-		   K = scalar-op(rand, (elem-op(scalar-op(peer-commit-scalar, PWE),PEER-COMMIT-ELEMENT)))
-		   If K is identity element (point-at-infinity), reject
-		   k = F(K) (= x coordinate)
-
-Parameter: @sae_priv: pointer of sae_data
-           @k: output key
-
-return:    0 if successful
-           -1 if failed
-*********************************************************************************************/
-int sae_derive_k_ffc(struct sae_data *sae_priv, unsigned char *k);
-
-
-/*********************************************************************************************
-Function:  derive pmk,kck and pmkid
-		   keyseed = H(<0>32, k)
-	  	   KCK || PMK = KDF-512(keyseed, "SAE KCK and PMK",(commit-scalar + peer-commit-scalar) modulo r)
-	  	   PMKID = L((commit-scalar + peer-commit-scalar) modulo r, 0, 128)
-
-Parameter: @sae_priv: pointer of sae_data
-           @k: output key
-
-return:    0 if successful
-           -1 if failed
-*********************************************************************************************/
-int sae_derive_pmk_and_kck(struct sae_data *sae_priv, unsigned char *k, unsigned int k_len);
-
-
-/*********************************************************************************************
-Function:  handle the sae auth and trigger the state machine
-
-Parameter: @padater:     pointer to device
-		   @psta:        pointer to sta_info
-		   @sae: 	     pointer to sae data
-		   @own_addr:    local mac address
-		   @peer_addr:   peer mac address
-		   @sae_msg:     pointer to sae message(the part after status code in the auth frame)
-		   @sae_msg_len: sae msg length
-		   @seq_num:  	 auth seq num in the received auth frame
-		   @status:		 statue code in the received auth frame
-
-result:    0: no error; -1; some error happened
-*********************************************************************************************/
-int rtw_sae_handle_auth(_adapter *padapter, struct sta_info *psta, struct sae_data *sae,
-						u8 *own_addr, u8 *peer_addr, u8 *sae_msg, u32 sae_msg_len, u16 seq_num, u16 status);
-
-
-/*********************************************************************************************
-Function:  allocate and start a sae instance
-
-Parameter: @padater: pointer to device
-
-result:    pointer to new sae data
-*********************************************************************************************/
-struct sae_data *rtw_sae_allocate_instance(_adapter *padapter);
-
-
-/*********************************************************************************************
-Function:  remove sae instance and free memory
-
-Parameter: @sae: pointer to sae data
-
-result:    void
-*********************************************************************************************/
-void rtw_sae_free_instance(_adapter *padapter, const char *reason);
-
-#endif	//__RTW_SAE_H_
-
diff --git a/os/board/rtl8720e/src/component/wifi/driver/include/rtw_security.h b/os/board/rtl8720e/src/component/wifi/driver/include/rtw_security.h
deleted file mode 100644
index bd72bc911..000000000
--- a/os/board/rtl8720e/src/component/wifi/driver/include/rtw_security.h
+++ /dev/null
@@ -1,366 +0,0 @@
-/******************************************************************************
- *
- * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of version 2 of the GNU General Public License as
- * published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
- * more details.
- *
- * You should have received a copy of the GNU General Public License along with
- * this program; if not, write to the Free Software Foundation, Inc.,
- * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
- *
- *
- ******************************************************************************/
-#ifndef __RTW_SECURITY_H_
-#define __RTW_SECURITY_H_
-
-
-#define _NO_PRIVACY_		0x0
-#define _WEP40_				0x1
-#define _TKIP_				0x2
-#define _TKIP_WTMIC_		0x3
-#define _AES_				0x4
-#define _WEP104_			0x5
-#define _WEP_WPA_MIXED_		0x07  // WEP + WPA
-#define _SMS4_				0x06
-#ifdef CONFIG_IEEE80211W
-#define _BIP_				0x8
-#endif /* CONFIG_IEEE80211W */
-#define _GCMP_ 0x07
-#define _GCMP_256_ (_GCMP_ | BIT(3))
-#define _CCMP_256_ (_AES_ | BIT(3))
-
-/* 802.11W use wrong key */
-#define IEEE80211W_RIGHT_KEY	0x0
-#define IEEE80211W_WRONG_KEY	0x1
-#define IEEE80211W_NO_KEY		0x2
-
-#define is_wep_enc(alg) (((alg) == _WEP40_) || ((alg) == _WEP104_))
-
-#define _WPA_IE_ID_	0xdd
-#define _WPA2_IE_ID_	0x30
-
-#define SHA256_MAC_LEN 32
-#define AES_BLOCK_SIZE 16
-#define AES_PRIV_SIZE (4 * 44)
-#define _AES_IV_LEN_ 8
-
-#define RTW_KEK_LEN 16
-#define RTW_KCK_LEN 16
-#define RTW_TKIP_MIC_LEN 8
-#define RTW_REPLAY_CTR_LEN 8
-
-typedef enum {
-	ENCRYP_PROTOCOL_OPENSYS,   //open system
-	ENCRYP_PROTOCOL_WEP,       //WEP
-	ENCRYP_PROTOCOL_WPA,       //WPA
-	ENCRYP_PROTOCOL_WPA2,      //WPA2
-	ENCRYP_PROTOCOL_WPA_WPA2,  //WPA & WPA2
-	ENCRYP_PROTOCOL_WAPI,      //WAPI: Not support in this version
-	ENCRYP_PROTOCOL_MAX
-} ENCRYP_PROTOCOL_E;
-
-union pn48	{
-
-	s64	val;
-	struct {
-		u8 TSC0;
-		u8 TSC1;
-		u8 TSC2;
-		u8 TSC3;
-		u8 TSC4;
-		u8 TSC5;
-		u8 TSC6;
-		u8 TSC7;
-	} _byte_;
-};
-
-
-struct security_priv {
-	u32	  dot11AuthAlgrthm;		// 802.11 auth, could be open, shared, 8021x and authswitch
-	u32	  dot11PrivacyAlgrthm;	// This specify the privacy for shared auth. algorithm.
-
-	/* WEP */
-	u32	  dot11PrivacyKeyIndex;	// this is only valid for legendary wep, 0~3 for key id. (tx key index)
-	union Keytype dot11DefKey[4];			// this is only valid for def. key
-	u32 	dot11DefKeylen[4];
-
-	u32 dot118021XGrpPrivacy;	// This specify the privacy algthm. used for Grp key
-	u32 AuthKeyMgmt;	// This specify the auth key algthm. used for 11w
-	u32	dot118021XGrpKeyid;		// key id used for Grp Key ( tx key index)
-	union Keytype	dot118021XGrpKey[4];	// 802.1x Group Key, for inx0 and inx1
-	union Keytype	dot118021XGrptxmickey[4];
-	union Keytype	dot118021XGrprxmickey[4];
-	union pn48		dot11Grptxpn;			// PN48 used for Grp Key xmit.
-	union pn48		dot11Grprxpn[4];			// PN48 used for Grp Key recv. NumGroupKey: 4.
-
-	//extend security capabilities for AP_MODE
-	unsigned int wpa_psk;//0:disable, bit(0): WPA, bit(1):WPA2
-	unsigned int wpa_group_cipher;
-	unsigned int wpa2_group_cipher;
-	unsigned int wpa_pairwise_cipher;
-	unsigned int wpa2_pairwise_cipher;
-
-#ifdef CONFIG_IEEE80211W
-	u8   ieee80211w;//11w capability
-	//u8	mfp_enable;//enable mfp or not
-	u8	binstallBIPkey;
-	u32	dot11wBIPKeyid;						/* key id used for BIP Key ( tx key index) */
-	union Keytype	dot11wBIPKey[6];		/* BIP Key, for index4 and index5 */
-	//u64		dot11wBIPtxpn;			/* PN48 used for Grp Key xmit. */
-	//u64		dot11wBIPrxpn;			/* PN48 used for Grp Key recv. */
-#endif
-#ifdef CONFIG_SAE_SUPPORT
-	u8 h2e;
-#endif
-
-	u8	binstallGrpkey;
-	u8	busetkipkey;
-	//_timer tkip_timer;
-	u8	bcheck_grpkey;
-	u8	bgrpkey_handshake;
-
-	//u8	packet_cnt;//unused, removed
-
-	s32	sw_encrypt;
-
-	s32 	hw_decrypted;//if the rx packets is hw_decrypted==_FALSE, it means the hw has not been ready.
-
-
-	//keeps the auth_type & enc_status from upper layer ioctl(wpa_supplicant or wzc)
-	u32 ndisauthtype;	// NDIS_802_11_AUTHENTICATION_MODE
-	u32 ndisencryptstatus;	// NDIS_802_11_ENCRYPTION_STATUS
-	u32 wpa_mode;
-
-	//WLAN_BSSID_EX sec_bss;  //for joinbss (h2c buffer) usage //YJ,del,140410
-
-	//for tkip countermeasure
-	u32 last_mic_err_time;
-	u8	btkip_countermeasure;
-	u8	btkip_wait_report;
-	u32 btkip_countermeasure_time;
-
-	WPA_GLOBAL_INFO		wpa_global_info;
-
-	u8 wpa_passphrase[IW_PASSPHRASE_MAX_SIZE + 1];
-
-#ifdef CONFIG_WPS
-	u8	wps_phase;
-#endif
-#ifdef CONFIG_EAP
-	u8	eap_phase;
-#endif
-
-};
-
-struct share_security_priv {
-	u8 supplicant_ie[MAX_WPA_IE_LEN];  //store sta security information element
-	u8 rsnxe_ie[MAX_WPA_IE_LEN];
-};
-
-struct sha256_state {
-	u64 length;
-	u32 state[8], curlen;
-	u8 buf[64];
-};
-
-
-#define GET_ENCRY_ALGO(psecuritypriv, psta, encry_algo, bmcst)\
-do{\
-	switch(psecuritypriv->dot11AuthAlgrthm)\
-	{\
-		case dot11AuthAlgrthm_Open:\
-		case dot11AuthAlgrthm_Shared:\
-		case dot11AuthAlgrthm_Auto:\
-			encry_algo = (u8)psecuritypriv->dot11PrivacyAlgrthm;\
-			break;\
-		case dot11AuthAlgrthm_8021X:\
-			if(bmcst)\
-				encry_algo = (u8)psecuritypriv->dot118021XGrpPrivacy;\
-			else\
-				encry_algo =(u8) psta->dot118021XPrivacy;\
-			break;\
-	     case dot11AuthAlgrthm_WAPI:\
-		     encry_algo = (u8)psecuritypriv->dot11PrivacyAlgrthm;\
-		     break;\
-	}\
-}while(0)
-
-
-#define SET_ICE_IV_LEN( iv_len, icv_len, encrypt)\
-do{\
-	switch(encrypt)\
-	{\
-		case _WEP40_:\
-		case _WEP104_:\
-			iv_len = 4;\
-			icv_len = 4;\
-			break;\
-		case _TKIP_:\
-			iv_len = 8;\
-			icv_len = 4;\
-			break;\
-		case _AES_:\
-			iv_len = 8;\
-			icv_len = 8;\
-			break;\
-		case _SMS4_:\
-			iv_len = 18;\
-			icv_len = 16;\
-			break;\
-		default:\
-			iv_len = 0;\
-			icv_len = 0;\
-			break;\
-	}\
-}while(0)
-
-
-#define GET_TKIP_PN(iv,dot11txpn)\
-do{\
-	dot11txpn._byte_.TSC0=iv[2];\
-	dot11txpn._byte_.TSC1=iv[0];\
-	dot11txpn._byte_.TSC2=iv[4];\
-	dot11txpn._byte_.TSC3=iv[5];\
-	dot11txpn._byte_.TSC4=iv[6];\
-	dot11txpn._byte_.TSC5=iv[7];\
-}while(0)
-
-
-#define ROL32( A, n )	( ((A) << (n)) | ( ((A)>>(32-(n)))  & ( (1UL << (n)) - 1 ) ) )
-#define ROR32( A, n ) 	ROL32( (A), 32-(n) )
-
-extern const u32 Te0[256];
-extern const u32 Te1[256];
-extern const u32 Te2[256];
-extern const u32 Te3[256];
-extern const u32 Te4[256];
-extern const u32 Td0[256];
-extern const u32 Td1[256];
-extern const u32 Td2[256];
-extern const u32 Td3[256];
-extern const u32 Td4[256];
-extern const u32 rcon[10];
-extern const u8 Td4s[256];
-extern const u8 rcons[10];
-
-#define RCON(i) (rcons[(i)] << 24)
-
-static inline u32 rotr(u32 val, int bits)
-{
-	return (val >> bits) | (val << (32 - bits));
-}
-
-#define TE0(i) Te0[((i) >> 24) & 0xff]
-#define TE1(i) rotr(Te0[((i) >> 16) & 0xff], 8)
-#define TE2(i) rotr(Te0[((i) >> 8) & 0xff], 16)
-#define TE3(i) rotr(Te0[(i) & 0xff], 24)
-#define TE41(i) ((Te0[((i) >> 24) & 0xff] << 8) & 0xff000000)
-#define TE42(i) (Te0[((i) >> 16) & 0xff] & 0x00ff0000)
-#define TE43(i) (Te0[((i) >> 8) & 0xff] & 0x0000ff00)
-#define TE44(i) ((Te0[(i) & 0xff] >> 8) & 0x000000ff)
-#define TE421(i) ((Te0[((i) >> 16) & 0xff] << 8) & 0xff000000)
-#define TE432(i) (Te0[((i) >> 8) & 0xff] & 0x00ff0000)
-#define TE443(i) (Te0[(i) & 0xff] & 0x0000ff00)
-#define TE414(i) ((Te0[((i) >> 24) & 0xff] >> 8) & 0x000000ff)
-#define TE4(i) ((Te0[(i)] >> 8) & 0x000000ff)
-
-#define TD0(i) Td0[((i) >> 24) & 0xff]
-#define TD1(i) rotr(Td0[((i) >> 16) & 0xff], 8)
-#define TD2(i) rotr(Td0[((i) >> 8) & 0xff], 16)
-#define TD3(i) rotr(Td0[(i) & 0xff], 24)
-#define TD41(i) (Td4s[((i) >> 24) & 0xff] << 24)
-#define TD42(i) (Td4s[((i) >> 16) & 0xff] << 16)
-#define TD43(i) (Td4s[((i) >> 8) & 0xff] << 8)
-#define TD44(i) (Td4s[(i) & 0xff])
-#define TD0_(i) Td0[(i) & 0xff]
-#define TD1_(i) rotr(Td0[(i) & 0xff], 8)
-#define TD2_(i) rotr(Td0[(i) & 0xff], 16)
-#define TD3_(i) rotr(Td0[(i) & 0xff], 24)
-
-#define GETU32(pt) (((u32)(pt)[0] << 24) ^ ((u32)(pt)[1] << 16) ^ \
-			((u32)(pt)[2] <<  8) ^ ((u32)(pt)[3]))
-
-#define PUTU32(ct, st) { \
-(ct)[0] = (u8)((st) >> 24); (ct)[1] = (u8)((st) >> 16); \
-(ct)[2] = (u8)((st) >>  8); (ct)[3] = (u8)(st); }
-
-#define WPA_GET_BE32(a) ((((u32) (a)[0]) << 24) | (((u32) (a)[1]) << 16) | \
-			 (((u32) (a)[2]) << 8) | ((u32) (a)[3]))
-
-#define WPA_PUT_LE16(a, val)			\
-	do {					\
-		(a)[1] = ((u16) (val)) >> 8;	\
-		(a)[0] = ((u16) (val)) & 0xff;	\
-	} while (0)
-
-#define WPA_PUT_BE32(a, val)					\
-	do {							\
-		(a)[0] = (u8) ((((u32) (val)) >> 24) & 0xff);	\
-		(a)[1] = (u8) ((((u32) (val)) >> 16) & 0xff);	\
-		(a)[2] = (u8) ((((u32) (val)) >> 8) & 0xff);	\
-		(a)[3] = (u8) (((u32) (val)) & 0xff);		\
-	} while (0)
-
-#define WPA_PUT_BE64(a, val)				\
-	do {						\
-		(a)[0] = (u8) (((u64) (val)) >> 56);	\
-		(a)[1] = (u8) (((u64) (val)) >> 48);	\
-		(a)[2] = (u8) (((u64) (val)) >> 40);	\
-		(a)[3] = (u8) (((u64) (val)) >> 32);	\
-		(a)[4] = (u8) (((u64) (val)) >> 24);	\
-		(a)[5] = (u8) (((u64) (val)) >> 16);	\
-		(a)[6] = (u8) (((u64) (val)) >> 8);	\
-		(a)[7] = (u8) (((u64) (val)) & 0xff);	\
-	} while (0)
-
-/* ===== start - public domain SHA256 implementation ===== */
-
-/* This is based on SHA256 implementation in LibTomCrypt that was released into
- * public domain by Tom St Denis. */
-
-/* the K array */
-static const unsigned long K[64] = {
-	0x428a2f98UL, 0x71374491UL, 0xb5c0fbcfUL, 0xe9b5dba5UL, 0x3956c25bUL,
-	0x59f111f1UL, 0x923f82a4UL, 0xab1c5ed5UL, 0xd807aa98UL, 0x12835b01UL,
-	0x243185beUL, 0x550c7dc3UL, 0x72be5d74UL, 0x80deb1feUL, 0x9bdc06a7UL,
-	0xc19bf174UL, 0xe49b69c1UL, 0xefbe4786UL, 0x0fc19dc6UL, 0x240ca1ccUL,
-	0x2de92c6fUL, 0x4a7484aaUL, 0x5cb0a9dcUL, 0x76f988daUL, 0x983e5152UL,
-	0xa831c66dUL, 0xb00327c8UL, 0xbf597fc7UL, 0xc6e00bf3UL, 0xd5a79147UL,
-	0x06ca6351UL, 0x14292967UL, 0x27b70a85UL, 0x2e1b2138UL, 0x4d2c6dfcUL,
-	0x53380d13UL, 0x650a7354UL, 0x766a0abbUL, 0x81c2c92eUL, 0x92722c85UL,
-	0xa2bfe8a1UL, 0xa81a664bUL, 0xc24b8b70UL, 0xc76c51a3UL, 0xd192e819UL,
-	0xd6990624UL, 0xf40e3585UL, 0x106aa070UL, 0x19a4c116UL, 0x1e376c08UL,
-	0x2748774cUL, 0x34b0bcb5UL, 0x391c0cb3UL, 0x4ed8aa4aUL, 0x5b9cca4fUL,
-	0x682e6ff3UL, 0x748f82eeUL, 0x78a5636fUL, 0x84c87814UL, 0x8cc70208UL,
-	0x90befffaUL, 0xa4506cebUL, 0xbef9a3f7UL, 0xc67178f2UL
-};
-
-
-/* Various logical functions */
-#define RORc(x, y) \
-( ((((unsigned long) (x) & 0xFFFFFFFFUL) >> (unsigned long) ((y) & 31)) | \
-   ((unsigned long) (x) << (unsigned long) (32 - ((y) & 31)))) & 0xFFFFFFFFUL)
-#define Ch(x,y,z)       (z ^ (x & (y ^ z)))
-#define Maj(x,y,z)      (((x | y) & z) | (x & y))
-#define S(x, n)         RORc((x), (n))
-#define R(x, n)         (((x)&0xFFFFFFFFUL)>>(n))
-#define Sigma0(x)       (S(x, 2) ^ S(x, 13) ^ S(x, 22))
-#define Sigma1(x)       (S(x, 6) ^ S(x, 11) ^ S(x, 25))
-#define Gamma0(x)       (S(x, 7) ^ S(x, 18) ^ R(x, 3))
-#define Gamma1(x)       (S(x, 17) ^ S(x, 19) ^ R(x, 10))
-#ifndef MIN
-#define MIN(x, y) (((x) < (y)) ? (x) : (y))
-#endif
-
-#ifdef CONFIG_IEEE80211W
-u32	rtw_BIP_verify(_adapter *padapter, u8 *precvframe);
-#endif /* CONFIG_IEEE80211W */
-#endif	//__RTL871X_SECURITY_H_
-
diff --git a/os/board/rtl8720e/src/component/wifi/driver/include/rtw_skbuff.h b/os/board/rtl8720e/src/component/wifi/driver/include/rtw_skbuff.h
new file mode 100755
index 000000000..2ee83cf3f
--- /dev/null
+++ b/os/board/rtl8720e/src/component/wifi/driver/include/rtw_skbuff.h
@@ -0,0 +1,121 @@
+/******************************************************************************
+ * Copyright (c) 2013-2016 Realtek Semiconductor Corp.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ ******************************************************************************/
+#ifndef __SKBUFF_H__
+#define __SKBUFF_H__
+
+#include "rtw_wifi_constants.h"
+#include "osdep_service.h"
+
+/*skb size = HW info + wlan over head + ethernet len + safety*/
+#define MAX_SKB_BUF_SIZE	(((WLAN_HW_INFO_LEN+WLAN_MAX_PROTOCOL_OVERHEAD+WLAN_MAX_ETHFRM_LEN+8)\
+							+ SKB_CACHE_SZ) & ~(SKB_CACHE_SZ-1))
+
+/*TX reserve size before 802.3 pkt*/
+#define WLAN_ETHHDR_LEN	14
+#define SKB_WLAN_TX_EXTRA_LEN	(TXDESC_SIZE+WLAN_HDR_A4_QOS_HTC_LEN+WLAN_MAX_IV_LEN+WLAN_SNAP_HEADER-WLAN_ETHHDR_LEN)
+
+#define SKB_DATA_ALIGN(X)	(((X) + (4 - 1)) & ~(4 - 1))
+
+struct  sk_buff_head {
+	struct list_head	*next, *prev;
+	unsigned int 		qlen;
+};
+
+struct sk_buff {
+	/* These two members must be first. */
+	struct sk_buff		*next;		/* Next buffer in list */
+	struct sk_buff		*prev;		/* Previous buffer in list */
+
+	struct sk_buff_head	*list;		/* List we are on */
+	unsigned char		*head;		/* Head of buffer */
+	unsigned char		*data;		/* Data head pointer */
+	unsigned char		*tail;		/* Tail pointer	*/
+	unsigned char		*end;		/* End pointer */
+	void	*dev;		/* Device we arrived on/are leaving by */
+	unsigned int 		len;		/* Length of actual data */
+
+	int 			dyalloc_flag;
+	unsigned char	busy;
+	unsigned char	no_free;
+};
+
+struct skb_info {
+	struct list_head list;
+	struct sk_buff skb;
+} SKB_ALIGNMENT; /*total size should be align to max(AP_cache_size, NP_cache_size), single core no need*/
+
+struct skb_data {
+	struct list_head list;
+	unsigned char buf[MAX_SKB_BUF_SIZE] SKB_ALIGNMENT;/* buf start address and size alignmengt for pre allocate skb*/
+	atomic_t ref;
+};
+
+struct skb_priv_t {
+	/*skb_data for store data*/
+	struct skb_data *skb_data_pool;
+	struct list_head skb_data_list;
+	int skb_data_num;
+	int skb_data_used;
+	int skb_data_max_used;
+	/*skb_info for managing skb_data*/
+	struct skb_info *skb_info_pool;
+	struct list_head skb_info_list;
+	int skb_info_num;
+	int skb_info_used;
+	int skb_info_max_used;
+	int skb_fail_cnt;
+};
+
+extern struct skb_priv_t skbpriv;
+struct net_device;
+
+#define dev_kfree_skb_any(skb)	kfree_skb_chk_key(skb, skb->dev);
+
+__inline static unsigned char *skb_pull(struct sk_buff *skb, unsigned int len)
+{
+	if (len > skb->len) {
+		return NULL;
+	}
+
+	skb->len -= len;
+	skb->data = (unsigned char *)(((unsigned int)skb->data) + len);
+
+	return skb->data;
+}
+
+/**
+ *	skb_put - add data to a buffer
+ *	@skb: buffer to use
+ *	@len: amount of data to add
+ *
+ *	This function extends the used data area of the buffer. If this would
+ *	exceed the total buffer size the kernel will panic. A pointer to the
+ *	first byte of the extra data is returned.
+ */
+
+__inline static unsigned char *skb_put(struct sk_buff *skb, unsigned int len)
+{
+	unsigned char *tmp = skb->tail;
+	skb->tail += len;
+	skb->len += len;
+	if (skb->tail > skb->end) {
+		ASSERT(0);
+	}
+
+	return tmp;
+}
+
+#endif //__SKBUFF_H__
diff --git a/os/board/rtl8720e/src/component/wifi/driver/include/rtw_timer.h b/os/board/rtl8720e/src/component/wifi/driver/include/rtw_timer.h
new file mode 100755
index 000000000..197dc2ffd
--- /dev/null
+++ b/os/board/rtl8720e/src/component/wifi/driver/include/rtw_timer.h
@@ -0,0 +1,53 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2012 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+#ifndef __RTW_TIMER_H_
+#define __RTW_TIMER_H_
+
+#define AP_CSA_TO	(102)
+#define REAUTH_TO	(800) //(50)
+#define REASSOC_TO	(300) //(50)
+#define REAUTH_LIMIT	(4)
+#define REASSOC_LIMIT	(4)
+
+#if( configSUPPORT_STATIC_ALLOCATION == 1 )
+#if defined (CONFIG_AS_INIC_NP) && CONFIG_AS_INIC_NP
+#define MAX_TIMER_BUF_NUM		18
+#elif defined (CONFIG_AS_INIC_AP) && CONFIG_AS_INIC_AP
+#define MAX_TIMER_BUF_NUM		5
+#else
+#define MAX_TIMER_BUF_NUM		23
+#endif
+#endif
+
+void init_timer(struct timer_list *timer);
+void mod_timer(struct timer_list *timer, uint32_t delay_time_ms);
+void  cancel_timer_ex(struct timer_list *timer);
+void del_timer_sync(struct timer_list *timer);
+void init_timer_wrapper(void);
+void deinit_timer_wrapper(void);
+/* void *adapter useless in rtw_init_timer, may clear later. */
+void rtw_init_timer(_timer *ptimer, void *adapter, TIMER_FUN pfunc, void *cntx, const char *name);
+void rtw_set_timer(_timer *ptimer, uint32_t delay_time);
+uint8_t  rtw_cancel_timer(_timer *ptimer);
+void rtw_del_timer(_timer *ptimer);
+void init_timer_pool(void);
+void deinit_timer_pool(void);
+
+#endif //__RTW_TIMER_H_
diff --git a/os/board/rtl8720e/src/component/wifi/driver/include/wifi_constants.h b/os/board/rtl8720e/src/component/wifi/driver/include/rtw_wifi_constants.h
old mode 100644
new mode 100755
similarity index 72%
rename from os/board/rtl8720e/src/component/wifi/driver/include/wifi_constants.h
rename to os/board/rtl8720e/src/component/wifi/driver/include/rtw_wifi_constants.h
index 5e966f85d..75595afc1
--- a/os/board/rtl8720e/src/component/wifi/driver/include/wifi_constants.h
+++ b/os/board/rtl8720e/src/component/wifi/driver/include/rtw_wifi_constants.h
@@ -1,45 +1,38 @@
 /******************************************************************************
- * Copyright (c) 2013-2016 Realtek Semiconductor Corp.
  *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
  *
- *     http://www.apache.org/licenses/LICENSE-2.0
  *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
  ******************************************************************************/
+#ifndef	__RTW_WIFI_CONSTANTS_H_
+#define __RTW_WIFI_CONSTANTS_H_
 
-/**
-  ******************************************************************************
-  * @file    wifi_constants.h
-  * @author
-  * @version
-  * @brief   This file provides the data types used for wlan API.
-  ******************************************************************************
-  */
-
-#ifndef _WIFI_CONSTANTS_H
-#define _WIFI_CONSTANTS_H
+#include "basic_types.h"
+#include "section_config.h"
+#include "platform_stdlib.h"
 
-/** @defgroup WIFI
- *  @brief      WIFI module
- *  @{
- */
+#include "rtw_autoconf.h"
+#include "rtw_byteorder.h"
 
-#ifdef	__cplusplus
-extern "C" {
+#if defined (__ICCARM__)
+#define _WEAK           __weak
+#else
+#define _WEAK           __attribute__ ((weak))
 #endif
 
-/** @defgroup WIFI_Exported_Constants WIFI Exported Constants
-  * @{
-  */
-
-
 /** @defgroup WLAN_Defs
    *@{
    */
@@ -75,197 +68,112 @@ extern "C" {
 #define SOFTAP_WLAN_NAME	"wlan1"
 #endif
 
+#define IsSupported24G(band_type) ((band_type) & BAND_CAP_2G? _TRUE : _FALSE)
+#define IsSupported5G(band_type) ((band_type) & BAND_CAP_5G ?  _TRUE : _FALSE)
 
-/** @} */
+#define IsLegacyOnly(NetType)  ((NetType) == ((NetType) & (WLAN_MD_11BG | WLAN_MD_11A)))
 
+#define IsSupportedTxOFDM(NetType) ((NetType) & (WLAN_MD_11G | WLAN_MD_11A) ? _TRUE : _FALSE)
+
+#define is_supported_ht(NetType) ((NetType) & (WLAN_MD_11N) ? _TRUE : _FALSE)
+#define is_supported_vht(NetType) ((NetType) & (WLAN_MD_11AC) ? _TRUE : _FALSE)
+#define is_supported_he(NetType) ((NetType) & (WLAN_MD_11AX) ? _TRUE : _FALSE)
+
+#define IS_HT_RATE(_rate)				(((_rate) & 0x80) ? _TRUE : _FALSE)
+#define IS_CCK_RATE(_rate) 				(MGN_1M == _rate || _rate == MGN_2M || _rate == MGN_5_5M || _rate == MGN_11M )
+#define IS_OFDM_RATE(_rate)				(MGN_6M <= _rate && _rate <= MGN_54M )
 
-/** @addtogroup MAC_Defs
-   *@{
-   */
 /**
  * @brief  mac address format.
  */
 #define MAC_ARG(x)		((u8*)(x))[0],((u8*)(x))[1],\
 				((u8*)(x))[2],((u8*)(x))[3],\
 				((u8*)(x))[4],((u8*)(x))[5]
-/** @} */
-
-
-/** @defgroup Security_Defs
-   *@{
-   */
-#define WEP_ENABLED         0x0001      /**< wep enable */
-#define TKIP_ENABLED       0x0002      /**< tkip enable */
-#define AES_ENABLED        0x0004      /**< aes enable */
-#define WSEC_SWFLAG        0x0008    /**< WSEC SWFLAG */
-#define AES_CMAC_ENABLED        0x0010   /**< aes cmac enable */
-#define ENTERPRISE_ENABLED			0x0020   /**< enterprise enable */
-#define SHARED_ENABLED  0x00008000     /**< shared enable */
-#define WPA_SECURITY    0x00200000      /**< wpa */
-#define WPA2_SECURITY   0x00400000     /**< wpa2 */
-#define WPA3_SECURITY		0x00800000  /**< wpa3 */
-#define WPS_ENABLED     0x10000000      /**< wps  enable*/
-#define RTW_MAX_PSK_LEN		(64) /**< maxmum psk length */
-#define RTW_MIN_PSK_LEN		(8)   /**< minimum psk length */
-#define MCSSET_LEN			16      /**<mcsset length */
-/**
-  * @}
-  */
+#define MAC_FMT "%02x:%02x:%02x:%02x:%02x:%02x"
 
-/**
-  * @}
-  */
+#define is_broadcast_mac_addr(Addr) ((((Addr[0]) & 0xff) == 0xff) && (((Addr[1]) & 0xff) == 0xff) && \
+(((Addr[2]) & 0xff) == 0xff) && (((Addr[3]) & 0xff) == 0xff) && (((Addr[4]) & 0xff) == 0xff) && \
+(((Addr[5]) & 0xff) == 0xff))
+#define is_zero_mac_addr(Addr)	((Addr[0] == 0x00) && (Addr[1] == 0x00) && (Addr[2] == 0x00) &&   \
+                    (Addr[3] == 0x00) && (Addr[4] == 0x00) && (Addr[5] == 0x00))
 
-/** @defgroup WIFI_Exported_Types WIFI Exported Types
-  * @{
-  */
+#define AUTH_ALG_OPEN_SYSTEM	0x1
+#define AUTH_ALG_SHARED_KEY	0x2
+#define AUTH_ALG_SAE		0x8
+#define AUTH_ALG_LEAP		0x00000004
 
-/** @defgroup Enums
+/** @defgroup Security_Defs
    *@{
    */
+#define WEP_ENABLED		0x0001		/**< wep enable */
+#define TKIP_ENABLED		0x0002		/**< tkip enable */
+#define AES_ENABLED		0x0004		/**< aes enable */
+#define WSEC_SWFLAG		0x0008		/**< WSEC SWFLAG */
+#define AES_CMAC_ENABLED	0x0010		/**< aes cmac enable */
+#define ENTERPRISE_ENABLED	0x0020		/**< enterprise enable */
+#define SHARED_ENABLED		0x00008000	/**< shared enable */
+#define WPA_SECURITY		0x00200000	/**< wpa */
+#define WPA2_SECURITY		0x00400000	/**< wpa2 */
+#define WPA3_SECURITY		0x00800000	/**< wpa3 */
+#define WPS_ENABLED		0x10000000	/**< wps  enable*/
+
+#define RTW_MAX_PSK_LEN		(64)		/**< maxmum psk length */
+#define RTW_MIN_PSK_LEN		(8)		/**< minimum psk length */
+#define MCSSET_LEN		16		/**<mcsset length */
+
+/* adaptivity */
+#define RTW_ADAPTIVITY_EN_DISABLE			0
+#define RTW_ADAPTIVITY_EN_ENABLE			1
+
+#ifndef CONFIG_WIFI_CRITICAL_CODE_SECTION
+#define CONFIG_WIFI_CRITICAL_CODE_SECTION
+#endif
 
-/**
- * @brief The enumeration lists the results of the function.
- */
-typedef enum {
-	RTW_SUCCESS                      = 0,    /**< Success */
-	RTW_PENDING                      = 1,    /**< Pending */
-	RTW_TIMEOUT                      = 2,    /**< Timeout */
-	RTW_PARTIAL_RESULTS              = 3,    /**< Partial results */
-	RTW_INVALID_KEY                  = 4,        /**< Invalid key */
-	RTW_DOES_NOT_EXIST               = 5,    /**< Does not exist */
-	RTW_NOT_AUTHENTICATED            = 6,    /**< Not authenticated */
-	RTW_NOT_KEYED                    = 7,    /**< Not keyed */
-	RTW_IOCTL_FAIL                   = 8,    /**< IOCTL fail */
-	RTW_BUFFER_UNAVAILABLE_TEMPORARY = 9,    /**< Buffer unavailable temporarily */
-	RTW_BUFFER_UNAVAILABLE_PERMANENT = 10,   /**< Buffer unavailable permanently */
-	RTW_WPS_PBC_OVERLAP              = 11,   /**< WPS PBC overlap */
-	RTW_CONNECTION_LOST              = 12,   /**< Connection lost */
-
-	RTW_ERROR                        = -1,   /**< Generic Error */
-	RTW_BADARG                       = -2,   /**< Bad Argument */
-	RTW_BADOPTION                    = -3,   /**< Bad option */
-	RTW_NOTUP                        = -4,   /**< Not up */
-	RTW_NOTDOWN                      = -5,  /**< Not down */
-	RTW_NOTAP                        = -6,   /**< Not AP */
-	RTW_NOTSTA                       = -7,   /**< Not STA  */
-	RTW_BADKEYIDX                    = -8,   /**< BAD Key Index */
-	RTW_RADIOOFF                     = -9,   /**< Radio Off */
-	RTW_NOTBANDLOCKED                = -10,  /**< Not  band locked */
-	RTW_NOCLK                        = -11,  /**< No Clock */
-	RTW_BADRATESET                   = -12,  /**< BAD Rate valueset */
-	RTW_BADBAND                      = -13,  /**< BAD Band */
-	RTW_BUFTOOSHORT                  = -14,  /**< Buffer too short */
-	RTW_BUFTOOLONG                   = -15,  /**< Buffer too long */
-	RTW_BUSY                         = -16,  /**< Busy */
-	RTW_NOTASSOCIATED                = -17,  /**< Not Associated */
-	RTW_BADSSIDLEN                   = -18,  /**< Bad SSID len */
-	RTW_OUTOFRANGECHAN               = -19,  /**< Out of Range Channel */
-	RTW_BADCHAN                      = -20,  /**< Bad Channel */
-	RTW_BADADDR                      = -21,  /**< Bad Address */
-	RTW_NORESOURCE                   = -22,  /**< Not Enough Resources */
-	RTW_UNSUPPORTED                  = -23,  /**< Unsupported */
-	RTW_BADLEN                       = -24,  /**< Bad length */
-	RTW_NOTREADY                     = -25,  /**< Not Ready */
-	RTW_EPERM                        = -26,  /**< Not Permitted */
-	RTW_NOMEM                        = -27,  /**< No Memory */
-	RTW_ASSOCIATED                   = -28,  /**< Associated */
-	RTW_RANGE                        = -29,  /**< Not In Range */
-	RTW_NOTFOUND                     = -30,  /**< Not Found */
-	RTW_WME_NOT_ENABLED              = -31,  /**< WME Not Enabled */
-	RTW_TSPEC_NOTFOUND               = -32,  /**< TSPEC Not Found */
-	RTW_ACM_NOTSUPPORTED             = -33,  /**< ACM Not Supported */
-	RTW_NOT_WME_ASSOCIATION          = -34,  /**< Not WME Association */
-	RTW_SDIO_ERROR                   = -35,  /**< SDIO Bus Error */
-	RTW_WLAN_DOWN                    = -36,  /**< WLAN Not Accessible */
-	RTW_BAD_VERSION                  = -37,  /**< Incorrect version */
-	RTW_TXFAIL                       = -38,  /**< TX failure */
-	RTW_RXFAIL                       = -39,  /**< RX failure */
-	RTW_NODEVICE                     = -40,  /**< Device not present */
-	RTW_UNFINISHED                   = -41,  /**< To be finished */
-	RTW_NONRESIDENT                  = -42,  /**< access to nonresident overlay */
-	RTW_DISABLED                     = -43   /**< Disabled in this build */
-} rtw_result_t;
+/* struct iw_encode_ext ->alg */
+enum RTW_IW_ENC_ALG {
+	RTW_ENCODE_ALG_NONE = 0,
+	RTW_ENCODE_ALG_WEP,
+	RTW_ENCODE_ALG_TKIP,
+	RTW_ENCODE_ALG_CCMP,
+	RTW_ENCODE_ALG_PMK,
+	RTW_ENCODE_ALG_AES_CMAC //IGTK
+};
 
 /**
- * @brief The enumeration lists the possible security types to set when connection.\n
- *			Station mode supports OPEN, WEP, and WPA2.\n
- *			AP mode support OPEN and WPA2.
- */
-typedef enum {
-	RTW_SECURITY_OPEN           = 0,                                                /**< Open security                           */
-	RTW_SECURITY_WEP_PSK        = WEP_ENABLED,                                      /**< WEP Security with open authentication   */
-	RTW_SECURITY_WEP_SHARED     = (WEP_ENABLED | SHARED_ENABLED),                   /**< WEP Security with shared authentication */
-	RTW_SECURITY_WPA_TKIP_PSK   = (WPA_SECURITY  | TKIP_ENABLED),                   /**< WPA Security with TKIP                  */
-	RTW_SECURITY_WPA_AES_PSK    = (WPA_SECURITY  | AES_ENABLED),                    /**< WPA Security with AES                   */
-	RTW_SECURITY_WPA_MIXED_PSK  = ( WPA_SECURITY | AES_ENABLED | TKIP_ENABLED ),    /**< WPA Security with AES & TKIP            */
-	RTW_SECURITY_WPA2_AES_PSK   = (WPA2_SECURITY | AES_ENABLED),                    /**< WPA2 Security with AES                  */
-	RTW_SECURITY_WPA2_TKIP_PSK  = (WPA2_SECURITY | TKIP_ENABLED),                   /**< WPA2 Security with TKIP                 */
-	RTW_SECURITY_WPA2_MIXED_PSK = (WPA2_SECURITY | AES_ENABLED | TKIP_ENABLED),     /**< WPA2 Security with AES & TKIP           */
-	RTW_SECURITY_WPA_WPA2_TKIP_PSK = ( WPA_SECURITY  | WPA2_SECURITY | TKIP_ENABLED), /**< WPA/WPA2 Security with TKIP           */
-	RTW_SECURITY_WPA_WPA2_AES_PSK = ( WPA_SECURITY  | WPA2_SECURITY | AES_ENABLED),   /**< WPA/WPA2 Security with AES            */
-	RTW_SECURITY_WPA_WPA2_MIXED_PSK = ( WPA_SECURITY  | WPA2_SECURITY | TKIP_ENABLED | AES_ENABLED), /**< WPA/WPA2 Security with AES & TKIP      */
-	RTW_SECURITY_WPA_WPA2_MIXED = (WPA_SECURITY  | WPA2_SECURITY),                  /**< WPA/WPA2 Security                       */
-	RTW_SECURITY_WPA2_AES_CMAC = (WPA2_SECURITY | AES_CMAC_ENABLED),                /**< WPA2 Security with AES and Management Frame Protection*/
-	RTW_SECURITY_WPA2_ENTERPRISE = (WPA2_SECURITY | ENTERPRISE_ENABLED),            /**< WPA2 Security with 802.1X authentication>*/
-	RTW_SECURITY_WPA_WPA2_ENTERPRISE = (WPA_SECURITY | WPA2_SECURITY | ENTERPRISE_ENABLED), /** <WPA/WPA2 Security with 802.1X authentication>*/
-
-	RTW_SECURITY_WPS_OPEN       = WPS_ENABLED,                                      /**< WPS with open security                  */
-	RTW_SECURITY_WPS_SECURE     = (WPS_ENABLED | AES_ENABLED),                      /**< WPS with AES security                   */
-
-	RTW_SECURITY_WPA3_AES_PSK 	= (WPA3_SECURITY | AES_ENABLED),                    /**< WPA3-SAE with AES security              */
-	RTW_SECURITY_WPA2_WPA3_MIXED = (WPA2_SECURITY | WPA3_SECURITY | AES_ENABLED),   /**< WPA3-SAE/WPA2 with AES security         */
-
-	RTW_SECURITY_UNKNOWN        = -1,                                               /**< May be returned by scan function if security is unknown. Do not pass this to the join function! */
-
-	RTW_SECURITY_FORCE_32_BIT   = 0x7fffffff                                        /**< Exists only to force rtw_security_t type to 32 bits */
-} rtw_security_t;
-
+  * @}wext_send_mgnt bit type
+  */
+#define RTW_SEND_AND_WAIT_ACK 				2
+#define RTW_SEND_BY_HIGH_RATE				4 // IEEE80211_OFDM_RATE_54MB
+#define RTW_NAV_BY_USER						8
 
-/**
- * @brief The enumeration lists wpa mode
- */
-typedef enum {
-	WPA_AUTO_MODE,
-	WPA_ONLY_MODE,
-	WPA2_ONLY_MODE,
-	WPA3_ONLY_MODE,
-	WPA_WPA2_MIXED_MODE,
-	WPA2_WPA3_MIXED_MODE
-} rtw_wpa_mode;
+/* Modes of operation */
+enum RTK_IW_MODE {
+	RTW_MODE_INFRA,			/* Multi cell network, roaming, ... */
+	RTW_MODE_MASTER			/* Synchronisation master or Access Point */
+};
 
 /**
- * @brief The enumeration lists encryption types
- */
+* @brief  The enumeration lists the promisc levels.
+*/
 typedef enum {
-	RTW_ENCRYPTION_UNKNOWN = 0,    /**< unknown encryption type*/
-	RTW_ENCRYPTION_OPEN = 1,           /**< open encryption type*/
-	RTW_ENCRYPTION_WEP40 = 2,         /**< WEP40 encryption type*/
-	RTW_ENCRYPTION_WPA_TKIP = 3,   /**< WPA+TKIP encryption type*/
-	RTW_ENCRYPTION_WPA_AES = 4,    /**< WPA+AES encryption type*/
-	RTW_ENCRYPTION_WPA2_TKIP = 5,/**< WPA2+TKIP encryption type*/
-	RTW_ENCRYPTION_WPA2_AES = 6,  /**< WPA2+AES encryption type*/
-	RTW_ENCRYPTION_WPA2_MIXED = 7,  /**< WPA2+MIXED encryption type*/
-	RTW_ENCRYPTION_WEP104 = 9,          /**< WEP104 encryption type*/
-	RTW_ENCRYPTION_UNDEF = 0xFF    /**< undefined encryption type*/
-} rtw_encryption_t;
-
+	RTW_PROMISC_DISABLE = 0,	/**< Disable the promisc */
+	RTW_PROMISC_ENABLE = 1,	/**< Fetch all ethernet packets */
+	RTW_PROMISC_ENABLE_1 = 2, /**< Fetch only B/M packets */
+	RTW_PROMISC_ENABLE_2 = 3, /**< Fetch all 802.11 packets*/
+	RTW_PROMISC_ENABLE_3 = 4, /**< Fetch only B/M 802.11 packets*/
+	RTW_PROMISC_ENABLE_4 = 5, /**< Fetch all 802.11 packets & MIMO PLCP headers. Please note that the PLCP header would be struct rtw_rx_info_t defined in wifi_conf.h*/
+	RTW_PROMISC_ENABLE_5 = 6 /**< Fetch all unicast 802.11 packets, data frame and beacon in same BSSID*/
+} rtw_rcr_level_t;
 
+#if (defined(CONFIG_UNSUPPORT_PLCPHDR_RPT) && CONFIG_UNSUPPORT_PLCPHDR_RPT) || defined __DOXYGEN__
 /**
- * @brief The enumeration lists false and true
+ * @brief The enumeration lists the promisc rx type.
  */
 typedef enum {
-	RTW_FALSE = 0,   /**< false*/
-	RTW_TRUE  = 1    /**< true*/
-} rtw_bool_t;
-
-/**
-* @brief The enumeration lists band types
-*/
-typedef enum {
-	RTW_802_11_BAND_5GHZ   = 0, /**< Denotes 5GHz radio band */
-	RTW_802_11_BAND_2_4GHZ = 1  /**< Denotes 2.4GHz radio band */
-} rtw_802_11_band_t;
+	RTW_RX_NORMAL = 0,  /**< The supported 802.11 packet*/
+	RTW_RX_UNSUPPORT = 1 /**<  Unsupported 802.11 packet info */
+} rtw_rx_type_t;
+#endif
 
 /**
 * @brief The enumeration lists all the country codes able to set to Wi-Fi driver.
@@ -470,288 +378,85 @@ typedef enum {
 } rtw_country_code_t;
 
 /**
-* @brief The enumeration lists the trp tis types.
-*/
+ * @brief The enumeration lists wpa mode
+ */
 typedef enum {
-	RTW_TRP_TIS_DISABLE = 0,
-	RTW_TRP_TIS_NORMAL = 1,
-	RTW_TRP_TIS_DYNAMIC = 3,				///< enable dynamic mechanism
-	RTW_TRP_TIS_FIX_ACK_RATE = 5,			///< fix ack rate to 6M
-	RTW_TRP_TIS_FIX_PHY_ACK_HIGH_RATE = 9		///< fix phy ack rate to RATE_54M | RATE_48M | RATE_36M | RATE_24M | RATE_18M | RATE_12M | RATE_9M | RATE_6M
-} rtw_trp_tis_mode_t;
+	WPA_AUTO_MODE,
+	WPA_ONLY_MODE,
+	WPA2_ONLY_MODE,
+	WPA3_ONLY_MODE,
+	WPA_WPA2_MIXED_MODE,
+	WPA2_WPA3_MIXED_MODE
+} rtw_wpa_mode;
 
 /**
-  * @brief The enumeration lists the supported operation mode by WIFI driver,
-  *			including station and AP mode.
-  */
+ * @brief The enumeration lists the possible security types to set when connection.\n
+ *			Station mode supports OPEN, WEP, and WPA2.\n
+ *			AP mode support OPEN and WPA2.
+ */
 typedef enum {
-	RTW_MODE_NONE = 0,  ///<none
-	RTW_MODE_STA,          ///<sta mode
-	RTW_MODE_AP,           ///<ap mode
-	RTW_MODE_STA_AP,   ///< ap and sta mode
-	RTW_MODE_PROMISC,///<promisc mode
-	RTW_MODE_P2P         ///<p2p mode
-} rtw_mode_t;
+	RTW_SECURITY_OPEN           = 0,                                                /**< Open security                           */
+	RTW_SECURITY_WEP_PSK        = WEP_ENABLED,                                      /**< WEP Security with open authentication   */
+	RTW_SECURITY_WEP_SHARED     = (WEP_ENABLED | SHARED_ENABLED),                   /**< WEP Security with shared authentication */
+	RTW_SECURITY_WPA_TKIP_PSK   = (WPA_SECURITY  | TKIP_ENABLED),                   /**< WPA Security with TKIP                  */
+	RTW_SECURITY_WPA_AES_PSK    = (WPA_SECURITY  | AES_ENABLED),                    /**< WPA Security with AES                   */
+	RTW_SECURITY_WPA_MIXED_PSK  = ( WPA_SECURITY | AES_ENABLED | TKIP_ENABLED ),    /**< WPA Security with AES & TKIP            */
+	RTW_SECURITY_WPA2_AES_PSK   = (WPA2_SECURITY | AES_ENABLED),                    /**< WPA2 Security with AES                  */
+	RTW_SECURITY_WPA2_TKIP_PSK  = (WPA2_SECURITY | TKIP_ENABLED),                   /**< WPA2 Security with TKIP                 */
+	RTW_SECURITY_WPA2_MIXED_PSK = (WPA2_SECURITY | AES_ENABLED | TKIP_ENABLED),     /**< WPA2 Security with AES & TKIP           */
+	RTW_SECURITY_WPA_WPA2_TKIP_PSK = ( WPA_SECURITY  | WPA2_SECURITY | TKIP_ENABLED), /**< WPA/WPA2 Security with TKIP           */
+	RTW_SECURITY_WPA_WPA2_AES_PSK = ( WPA_SECURITY  | WPA2_SECURITY | AES_ENABLED),   /**< WPA/WPA2 Security with AES            */
+	RTW_SECURITY_WPA_WPA2_MIXED_PSK = ( WPA_SECURITY  | WPA2_SECURITY | TKIP_ENABLED | AES_ENABLED), /**< WPA/WPA2 Security with AES & TKIP      */
+	RTW_SECURITY_WPA_WPA2_MIXED = (WPA_SECURITY  | WPA2_SECURITY),                  /**< WPA/WPA2 Security                       */
+	RTW_SECURITY_WPA2_AES_CMAC = (WPA2_SECURITY | AES_CMAC_ENABLED),                /**< WPA2 Security with AES and Management Frame Protection*/
+	RTW_SECURITY_WPA2_ENTERPRISE = (WPA2_SECURITY | ENTERPRISE_ENABLED),            /**< WPA2 Security with 802.1X authentication>*/
+	RTW_SECURITY_WPA_WPA2_ENTERPRISE = (WPA_SECURITY | WPA2_SECURITY | ENTERPRISE_ENABLED), /** <WPA/WPA2 Security with 802.1X authentication>*/
 
-/**
-  * @brief The enumeration lists the scan status
-  */
-typedef enum {
-	RTW_SCAN_FULL = 0,   ///< scan full  mode
-	RTW_SCAN_SOCIAL,    ///< scan social  mode
-	RTW_SCAN_ONE         ///< scan one mode
-} rtw_scan_mode_t;
+	RTW_SECURITY_WPS_OPEN       = WPS_ENABLED,                                      /**< WPS with open security                  */
+	RTW_SECURITY_WPS_SECURE     = (WPS_ENABLED | AES_ENABLED),                      /**< WPS with AES security                   */
 
-/**
-  * @brief  The enumeration lists the supported autoreconnect mode by WIFI driver.
-  */
-typedef enum {
-	RTW_AUTORECONNECT_DISABLE,  ///< disable auto reconnect
-	RTW_AUTORECONNECT_FINITE,    ///< finite auto reconnect
-	RTW_AUTORECONNECT_INFINITE ///< infinite auto reconnect
-} rtw_autoreconnect_mode_t;
+	RTW_SECURITY_WPA3_AES_PSK 	= (WPA3_SECURITY | AES_ENABLED),                    /**< WPA3-SAE with AES security              */
+	RTW_SECURITY_WPA2_WPA3_MIXED = (WPA2_SECURITY | WPA3_SECURITY | AES_ENABLED),   /**< WPA3-SAE/WPA2 with AES security         */
 
-/**
-  * @brief  The enumeration lists the status to describe the connection link.
-  */
-typedef enum {
-	RTW_LINK_DISCONNECTED = 0, ///< disconnect status
-	RTW_LINK_CONNECTED             ///< connect status
-} rtw_link_status_t;
+	RTW_SECURITY_UNKNOWN        = -1,                                               /**< May be returned by scan function if security is unknown. Do not pass this to the join function! */
 
+	RTW_SECURITY_FORCE_32_BIT   = 0x7fffffff                                        /**< Exists only to force rtw_security_t type to 32 bits */
+} rtw_security_t;
 
 /**
-  * @brief  The enumeration lists the bss types.
-  */
+ * @brief The enumeration lists encryption types
+ */
 typedef enum {
-	RTW_BSS_TYPE_INFRASTRUCTURE = 0, /**< Denotes infrastructure network                  */
-	RTW_BSS_TYPE_ADHOC          = 1, /**< Denotes an 802.11 ad-hoc IBSS network           */
-	RTW_BSS_TYPE_ANY            = 2, /**< Denotes either infrastructure or ad-hoc network */
+	RTW_ENCRYPTION_UNKNOWN = 0,    /**< unknown encryption type*/
+	RTW_ENCRYPTION_OPEN = 1,           /**< open encryption type*/
+	RTW_ENCRYPTION_WEP40 = 2,         /**< WEP40 encryption type*/
+	RTW_ENCRYPTION_WPA_TKIP = 3,   /**< WPA+TKIP encryption type*/
+	RTW_ENCRYPTION_WPA_AES = 4,    /**< WPA+AES encryption type*/
+	RTW_ENCRYPTION_WPA2_TKIP = 5,/**< WPA2+TKIP encryption type*/
+	RTW_ENCRYPTION_WPA2_AES = 6,  /**< WPA2+AES encryption type*/
+	RTW_ENCRYPTION_WPA2_MIXED = 7,  /**< WPA2+MIXED encryption type*/
+	RTW_ENCRYPTION_WEP104 = 9,          /**< WEP104 encryption type*/
+	RTW_ENCRYPTION_UNDEF = 0xFF    /**< undefined encryption type*/
+} rtw_encryption_t;
 
-	RTW_BSS_TYPE_UNKNOWN        = -1 /**< May be returned by scan function if BSS type is unknown. Do not pass this to the Join function */
-} rtw_bss_type_t;
+enum WIFI_STATUS_CODE {
+	_STATS_SUCCESSFUL_			= 0,
+	_STATS_FAILURE_				= 1,
+	_STATS_CAP_FAIL_			= 10,
+	_STATS_NO_ASOC_				= 11,
+	_STATS_OTHER_				= 12,
+	_STATS_NO_SUPP_ALG_			= 13,
+	_STATS_OUT_OF_AUTH_SEQ_		= 14,
+	_STATS_CHALLENGE_FAIL_		= 15,
+	_STATS_AUTH_TIMEOUT_		= 16,
+	_STATS_UNABLE_HANDLE_STA_	= 17,
+	_STATS_RATE_FAIL_			= 18,
+	_STATS_REFUSED_TEMPORARILY_ = 30,
+	_STATS_SAE_HASH_TO_ELEMENT_ = 126,
+};
 
 /**
-  * @brief  The enumeration lists the scan options.
-  */
-typedef enum {
-	RTW_SCAN_ACTIVE              = 0x01,     /**< active scan */
-	RTW_SCAN_PASSIVE             = 0x02,    /**< passive scan*/
-	RTW_SCAN_NO_HIDDEN_SSID      = 0x04, /**< Filter hidden ssid APs*/
-	RTW_SCAN_REPORT_EACH         = 0x08    /**< report each */
-} rtw_scan_option_t;
-
-/**
-  * @brief  The enumeration lists the command type.
-  */
-typedef enum {
-	COMMAND1					= 0x01   /**< COMMAND1 */
-} rtw_command_type;
-
-/**
-  * @brief  The enumeration lists the WPS types.
-  */
-typedef enum {
-	RTW_WPS_TYPE_DEFAULT 		    	= 0x0000,   /**< default type */
-	RTW_WPS_TYPE_USER_SPECIFIED 		= 0x0001,  /**< user specified type */
-	RTW_WPS_TYPE_MACHINE_SPECIFIED   	= 0x0002,  /**< machine specified type */
-	RTW_WPS_TYPE_REKEY 			        = 0x0003,       /**< retry key type */
-	RTW_WPS_TYPE_PUSHBUTTON 		    = 0x0004,    /**< push button type */
-	RTW_WPS_TYPE_REGISTRAR_SPECIFIED 	= 0x0005,  /**< register specified type */
-	RTW_WPS_TYPE_NONE                   = 0x0006,              /**< none */
-	RTW_WPS_TYPE_WSC                    = 0x0007                /**< wsc type */
-} rtw_wps_type_t;
-
-
-/**
-  * @brief  The enumeration lists all the network bgn mode.
-  */
-typedef enum {
-	RTW_NETWORK_B   = 1,    /**< b mode */
-	RTW_NETWORK_A   = 2,    /**< a mode */
-	RTW_NETWORK_BG  = 3,   /**< bg mode */
-	RTW_NETWORK_A_N   = 10,    /**< a+n mode */
-	RTW_NETWORK_BGN = 13, /**< bgn mode */
-	RTW_NETWORK_A_N_AC   = 26,    /**< a+n+ac mode */
-	RTW_NETWORK_BGN_AX = 45, /**< bgn+ax mode */
-	RTW_NETWORK_A_N_AC_AX   = 58    /**< a+n+ac+ax mode */
-} rtw_network_mode_t;
-
-/**
-  * @brief  The enumeration lists the interfaces.
-  */
-typedef enum {
-	RTW_STA_INTERFACE     = 0, /**<  STA or Client Interface  */
-	RTW_AP_INTERFACE      = 1 /**<  SoftAP Interface         */
-} rtw_interface_t;
-
-/**
-  * @brief  The enumeration lists the packet filter rules.
-  */
-typedef enum {
-	RTW_POSITIVE_MATCHING  = 0, /**< Receive the data matching with this pattern and discard the other data   */
-	RTW_NEGATIVE_MATCHING  = 1  /**< Discard the data matching with this pattern and receive the other data */
-} rtw_packet_filter_rule_t;
-
-/**
-  * @brief  The enumeration lists the promisc levels.
-  */
-typedef enum {
-	RTW_PROMISC_DISABLE = 0,  /**< Disable the promisc */
-	RTW_PROMISC_ENABLE = 1,   /**< Fetch all ethernet packets */
-	RTW_PROMISC_ENABLE_1 = 2, /**< Fetch only B/M packets */
-	RTW_PROMISC_ENABLE_2 = 3, /**< Fetch all 802.11 packets*/
-	RTW_PROMISC_ENABLE_3 = 4, /**< Fetch only B/M 802.11 packets*/
-	RTW_PROMISC_ENABLE_4 = 5, /**< Fetch all 802.11 packets & MIMO PLCP headers. Please note that the PLCP header would be struct rtw_rx_info_t defined in wifi_structures.h*/
-	RTW_PROMISC_ENABLE_5 = 6 /**< Fetch all unicast 802.11 packets, data frame and beacon in same BSSID*/
-} rtw_rcr_level_t;
-
-#if (defined(CONFIG_UNSUPPORT_PLCPHDR_RPT) && CONFIG_UNSUPPORT_PLCPHDR_RPT) || defined __DOXYGEN__
-/**
- * @brief The enumeration lists the promisc rx type.
- */
-typedef enum {
-	RTW_RX_NORMAL = 0,  /**< The supported 802.11 packet*/
-	RTW_RX_UNSUPPORT = 1 /**<  Unsupported 802.11 packet info */
-} rtw_rx_type_t;
-#endif
-
-/**
-  * @brief The enumeration lists the join status.
-  */
-typedef enum {
-	RTW_JOINSTATUS_UNKNOWN = 0,    /**< unknown */
-	RTW_JOINSTATUS_STARTING,          /**< starting phase */
-	RTW_JOINSTATUS_SCANNING,          /**< scanning phase */
-	RTW_JOINSTATUS_AUTHENTICATING,  /**< authenticating phase */
-	RTW_JOINSTATUS_AUTHENTICATED,   /**< authenticated phase */
-	RTW_JOINSTATUS_ASSOCIATING,       /**< associating phase */
-	RTW_JOINSTATUS_ASSOCIATED,         /**< associated phase */
-	RTW_JOINSTATUS_4WAY_HANDSHAKING, /**< 4 way handshaking phase */
-	RTW_JOINSTATUS_4WAY_HANDSHAKE_DONE, /**< 4 way handshake done phase */
-	RTW_JOINSTATUS_SUCCESS,                        /**< join success  */
-	RTW_JOINSTATUS_FAIL,                               /**< join fail  */
-	RTW_JOINSTATUS_DISCONNECT,                 /**< disconnect */
-	//TODO: RTW_JOINSTATUS_ABORTED,
-} rtw_join_status_t;
-
-/**
-  * @brief  The enumeration lists the disconnect reasons.
-  */
-typedef enum {
-	RTW_NO_ERROR,        /**< no error */
-	RTW_NONE_NETWORK,   /**< none network */
-	RTW_AUTH_FAIL,            /**< auth fail */
-	RTW_ASSOC_FAIL,          /**< assocation fail */
-	RTW_WRONG_PASSWORD, /**< wrong password */
-	RTW_4WAY_HANDSHAKE_TIMEOUT, /**< 4 way handshake timeout*/
-	RTW_CONNECT_FAIL,  /**< connect fail*/
-	RTW_DHCP_FAIL,        /**< dhcp fail*/
-	RTW_UNKNOWN,         /**< unknown*/
-} rtw_connect_error_flag_t;
-
-/**
-  * @brief channel switch
-  */
-typedef enum {
-	RTW_CH_SWITCH_FAIL = -1,           ///<channel switch fail
-	RTW_CH_SWITCH_SUCCESS = 0,      ///<channel switch success
-} rtw_channel_switch_res_t;
-
-/**
-  * @brief The enumeration lists the power status.
-  */
-typedef enum {
-	RTW_TX_PWR_PERCENTAGE_100 = 0, /**< 100%, default target output power.	 */
-	RTW_TX_PWR_PERCENTAGE_75 = 1, /**< 75% */
-	RTW_TX_PWR_PERCENTAGE_50 = 2, /**< 50% */
-	RTW_TX_PWR_PERCENTAGE_25 = 3, /**< 25% */
-	RTW_TX_PWR_PERCENTAGE_12_5 = 4, /**< 12.5% */
-} rtw_tx_pwr_percentage_t;
-
-/**
-  * @brief pm option
-  */
-typedef enum {
-	RTW_PM_OPTION_IPS_MODE,       ///< ips mode
-	RTW_PM_OPTION_LPS_MODE,      ///< lps mode
-	RTW_PM_OPTION_TDMA_PARAM,///<tdma param mode
-} rtw_pm_option_t;
-
-/**
-  * @brief wowlan option
-  */
-typedef enum {
-	RTW_WOWLAN_CTRL,            ///< control mode
-	RTW_WOWLAN_SET_PATTREN,///< set pattren mode
-	RTW_WOWLAN_REDOWNLOAD_FW,///< redownload fw
-} rtw_wowlan_option_t;
-
-/**
-  * @brief  The enumeration is event type indicated from wlan driver.
-  */
-typedef enum {
-	/* common event */
-	WIFI_EVENT_STA_ASSOC = 0,		///<used in p2p, simple config, 11s, customer
-	WIFI_EVENT_STA_DISASSOC,		///<used in p2p, customer
-	WIFI_EVENT_RX_MGNT,				///<used in p2p, customer
-	WIFI_EVENT_CONNECT,				///<used in ipv6 example, p2p, wifi_manager example
-	WIFI_EVENT_DISCONNECT,			///<used in wifi_manager example, p2p, eap
-
-	WIFI_EVENT_GROUP_KEY_CHANGED,
-	WIFI_EVENT_RECONNECTION_FAIL,
-	WIFI_EVENT_ICV_ERROR,
-	WIFI_EVENT_CHALLENGE_FAIL,
-
-	WIFI_EVENT_JOIN_STATUS,			///<internally use for joinstatus indicate
-
-	/* p2p event */
-	WIFI_EVENT_P2P_SEND_ACTION_DONE,
-
-	/* wpa event */
-	WIFI_EVENT_WPA_STA_WPS_START,
-	WIFI_EVENT_WPA_WPS_FINISH,
-	WIFI_EVENT_WPA_EAPOL_START,
-	WIFI_EVENT_WPA_EAPOL_RECVD,
-
-	/* csi rx done event */
-	WIFI_EVENT_CSI_DONE,
-
-	WIFI_EVENT_MAX,
-} rtw_event_indicate_t;
-
-/**
-  * @brief Power Mgnt
-  */
-typedef enum {
-	PS_MODE_ACTIVE	= 0	, ///< active mode
-	PS_MODE_MIN		,       ///< min mode
-	PS_MODE_MAX		,       ///< max mode
-	PS_MODE_DTIM		,      ///<dtim mode
-	PS_MODE_VOIP		,      ///< voip mode
-	PS_MODE_UAPSD_WMM	, ///< uapsd wmm mode
-	PS_MODE_UAPSD		,       ///< uapsd mode mode
-	PS_MODE_IBSS		,       ///< ibss mode
-	PS_MODE_WWLAN		,///< wwlan mode
-	PS_MODE_RESUME		,///< resume mode
-	PM_Radio_Off		,      ///< radio off mode
-	PM_Card_Disable		,      ///<card disable
-	PS_MODE_NUM                 ///< mode nums
-} Power_Mgnt;
-
-/**
-  * The enumeration lists the power save status.
-  */
-typedef enum {
-	LPS_NORMAL = 0, ///< normal
-	LPS_LCLK,          ///< lclk
-	LPS_PG,             ///<pg
-	LPS_LEVEL_MAX,
-} lps_level;
-
-
-/**
-  * @brief The enumeration lists the BIT 7 HT Rate.
+  * @brief The enumeration lists the BIT 7 HT Rate.
   */
 typedef enum {
 	MGN_1M		= 0x02,     /**< 0x02 */
@@ -890,6 +595,11 @@ typedef enum {
 	MGN_UNKNOWN
 } MGN_RATE;
 
+#define	PACKET_NORMAL			0
+#define	PACKET_DHCP			1
+#define	PACKET_ARP			2
+#define	PACKET_EAPOL			3
+
 /**
   * @brief The enumeration lists the BIT 7 HT Rate.
   */
@@ -930,19 +640,327 @@ typedef enum {
 } rtw_csi_accuracy;
 
 /**
-  * @}
+  * @brief The enumeration lists the power status.
   */
+typedef enum {
+	RTW_TX_PWR_PERCENTAGE_100	= 0, /**< 100%, default target output power.	 */
+	RTW_TX_PWR_PERCENTAGE_75	= 1, /**< 75% */
+	RTW_TX_PWR_PERCENTAGE_50	= 2, /**< 50% */
+	RTW_TX_PWR_PERCENTAGE_25	= 3, /**< 25% */
+	RTW_TX_PWR_PERCENTAGE_12_5	= 4, /**< 12.5% */
+} rtw_tx_pwr_percentage_t;
 
 /**
-  * @}
+  * @brief Power Mgnt
   */
+typedef enum {
+	PS_MODE_ACTIVE	= 0	, ///< active mode
+	PS_MODE_MIN		,       ///< min mode
+	PS_MODE_MAX		,       ///< max mode
+	PS_MODE_DTIM		,      ///<dtim mode
+	PS_MODE_UAPSD_WMM	, ///< uapsd wmm mode
+	PS_MODE_UAPSD		,       ///< uapsd mode mode
+	PM_Card_Disable		,      ///<card disable
+} Power_Mgnt;
 
-#ifdef	__cplusplus
-}
-#endif
+/**
+* @brief The enumeration lists the trp tis types.
+*/
+typedef enum {
+	RTW_TRP_TIS_DISABLE = 0,
+	RTW_TRP_TIS_NORMAL = 1,
+	RTW_TRP_TIS_DYNAMIC = 3,					///< enable dynamic mechanism
+	RTW_TRP_TIS_FIX_ACK_RATE = 5,			///< fix ack rate to 6M
+	RTW_TRP_TIS_FIX_PHY_ACK_HIGH_RATE = 9	///< fix phy ack rate to RATE_54M | RATE_48M | RATE_36M | RATE_24M | RATE_18M | RATE_12M | RATE_9M | RATE_6M
+} rtw_trp_tis_mode_t;
+
+/**
+* @brief The enumeration lists band types
+*/
+typedef enum {
+	RTW_802_11_BAND_5GHZ   = 0, /**< Denotes 5GHz radio band */
+	RTW_802_11_BAND_2_4GHZ = 1  /**< Denotes 2.4GHz radio band */
+} rtw_802_11_band_t;
 
+/**
+ * @brief The enumeration lists false and true
+ */
+typedef enum {
+	RTW_FALSE = 0,   /**< false*/
+	RTW_TRUE  = 1    /**< true*/
+} rtw_bool_t;
 
 /**
-  * @}
+  * @brief  The enumeration lists the bss types.
   */
-#endif /* _WIFI_CONSTANTS_H */
+typedef enum {
+	RTW_BSS_TYPE_INFRASTRUCTURE 	= 0, /**< Denotes infrastructure network                  */
+	RTW_BSS_TYPE_ADHOC          		= 1, /**< Denotes an 802.11 ad-hoc IBSS network           */
+	RTW_BSS_TYPE_ANY            			= 2, /**< Denotes either infrastructure or ad-hoc network */
+	RTW_BSS_TYPE_UNKNOWN        		= -1 /**< May be returned by scan function if BSS type is unknown. Do not pass this to the Join function */
+} rtw_bss_type_t;
+
+/**
+  * @brief  The enumeration lists the scan options.
+  */
+typedef enum {
+	RTW_SCAN_ACTIVE              	= 0x01,     /**< active scan */
+	RTW_SCAN_PASSIVE             	= 0x02,    /**< passive scan*/
+	RTW_SCAN_NO_HIDDEN_SSID	= 0x04, /**< Filter hidden ssid APs*/
+	RTW_SCAN_REPORT_EACH	= 0x08    /**< report each */
+} rtw_scan_option_t;
+
+/**
+  * @brief  The enumeration lists the WPS types.
+  */
+typedef enum {
+	RTW_WPS_TYPE_DEFAULT 		    		= 0x0000,	/**< default type */
+	RTW_WPS_TYPE_USER_SPECIFIED 		= 0x0001,	/**< user specified type */
+	RTW_WPS_TYPE_MACHINE_SPECIFIED   	= 0x0002,	/**< machine specified type */
+	RTW_WPS_TYPE_REKEY 			        	= 0x0003,	/**< retry key type */
+	RTW_WPS_TYPE_PUSHBUTTON 		    	= 0x0004,	/**< push button type */
+	RTW_WPS_TYPE_REGISTRAR_SPECIFIED 	= 0x0005,	/**< register specified type */
+	RTW_WPS_TYPE_NONE                   		= 0x0006, 	/**< none */
+	RTW_WPS_TYPE_WSC                    		= 0x0007		/**< wsc type */
+} rtw_wps_type_t;
+
+/**
+  * @brief  The enumeration lists all the network bgn mode.
+  */
+typedef enum {
+	RTW_NETWORK_B			= 1,		/**< b mode */
+	RTW_NETWORK_A			= 2,		/**< a mode */
+	RTW_NETWORK_BG  			= 3,		/**< bg mode */
+	RTW_NETWORK_A_N   		= 10,	/**< a+n mode */
+	RTW_NETWORK_BGN 		= 13,	/**< bgn mode */
+	RTW_NETWORK_A_N_AC   	= 26,	/**< a+n+ac mode */
+	RTW_NETWORK_BGN_AX 		= 45,	/**< bgn+ax mode */
+	RTW_NETWORK_A_N_AC_AX   = 58	/**< a+n+ac+ax mode */
+} rtw_network_mode_t;
+
+/**
+  * @brief  The enumeration lists the disconnect reasons.
+  */
+typedef enum {
+	RTW_NO_ERROR,        /**< no error */
+	RTW_NONE_NETWORK,   /**< none network */
+	RTW_AUTH_FAIL,            /**< auth fail */
+	RTW_ASSOC_FAIL,          /**< assocation fail */
+	RTW_WRONG_PASSWORD, /**< wrong password */
+	RTW_4WAY_HANDSHAKE_TIMEOUT, /**< 4 way handshake timeout*/
+	RTW_CONNECT_FAIL,  /**< connect fail*/
+	RTW_DHCP_FAIL,        /**< dhcp fail*/
+	RTW_UNKNOWN,         /**< unknown*/
+} rtw_connect_error_flag_t;
+
+/**
+  * @brief The enumeration lists the join status.
+  */
+typedef enum {
+	RTW_JOINSTATUS_UNKNOWN = 0,				/**< unknown */
+	RTW_JOINSTATUS_STARTING,				/**< starting phase */
+	RTW_JOINSTATUS_SCANNING,				/**< scanning phase */
+	RTW_JOINSTATUS_AUTHENTICATING,			/**< authenticating phase */
+	RTW_JOINSTATUS_AUTHENTICATED,			/**< authenticated phase */
+	RTW_JOINSTATUS_ASSOCIATING,				/**< associating phase */
+	RTW_JOINSTATUS_ASSOCIATED,			 	/**< associated phase */
+	RTW_JOINSTATUS_4WAY_HANDSHAKING,		/**< 4 way handshaking phase */
+	RTW_JOINSTATUS_4WAY_HANDSHAKE_DONE,	/**< 4 way handshake done phase */
+	RTW_JOINSTATUS_SUCCESS,					/**< join success  */
+	RTW_JOINSTATUS_FAIL,						/**< join fail  */
+	RTW_JOINSTATUS_DISCONNECT,				/**< disconnect */
+	//TODO: RTW_JOINSTATUS_ABORTED,
+} rtw_join_status_t;
+
+/**
+ * @brief The enumeration lists the results of the function.
+ */
+typedef enum {
+	RTW_SUCCESS                      = 0,    /**< Success */
+	RTW_PENDING                      = 1,    /**< Pending */
+	RTW_TIMEOUT                      = 2,    /**< Timeout */
+	RTW_PARTIAL_RESULTS              = 3,    /**< Partial results */
+	RTW_INVALID_KEY                  = 4,        /**< Invalid key */
+	RTW_DOES_NOT_EXIST               = 5,    /**< Does not exist */
+	RTW_NOT_AUTHENTICATED            = 6,    /**< Not authenticated */
+	RTW_NOT_KEYED                    = 7,    /**< Not keyed */
+	RTW_IOCTL_FAIL                   = 8,    /**< IOCTL fail */
+	RTW_BUFFER_UNAVAILABLE_TEMPORARY = 9,    /**< Buffer unavailable temporarily */
+	RTW_BUFFER_UNAVAILABLE_PERMANENT = 10,   /**< Buffer unavailable permanently */
+	RTW_WPS_PBC_OVERLAP              = 11,   /**< WPS PBC overlap */
+	RTW_CONNECTION_LOST              = 12,   /**< Connection lost */
+
+	RTW_ERROR                        = -1,   /**< Generic Error */
+	RTW_BADARG                       = -2,   /**< Bad Argument */
+	RTW_BADOPTION                    = -3,   /**< Bad option */
+	RTW_NOTUP                        = -4,   /**< Not up */
+	RTW_NOTDOWN                      = -5,  /**< Not down */
+	RTW_NOTAP                        = -6,   /**< Not AP */
+	RTW_NOTSTA                       = -7,   /**< Not STA  */
+	RTW_BADKEYIDX                    = -8,   /**< BAD Key Index */
+	RTW_RADIOOFF                     = -9,   /**< Radio Off */
+	RTW_NOTBANDLOCKED                = -10,  /**< Not  band locked */
+	RTW_NOCLK                        = -11,  /**< No Clock */
+	RTW_BADRATESET                   = -12,  /**< BAD Rate valueset */
+	RTW_BADBAND                      = -13,  /**< BAD Band */
+	RTW_BUFTOOSHORT                  = -14,  /**< Buffer too short */
+	RTW_BUFTOOLONG                   = -15,  /**< Buffer too long */
+	RTW_BUSY                         = -16,  /**< Busy */
+	RTW_NOTASSOCIATED                = -17,  /**< Not Associated */
+	RTW_BADSSIDLEN                   = -18,  /**< Bad SSID len */
+	RTW_OUTOFRANGECHAN               = -19,  /**< Out of Range Channel */
+	RTW_BADCHAN                      = -20,  /**< Bad Channel */
+	RTW_BADADDR                      = -21,  /**< Bad Address */
+	RTW_NORESOURCE                   = -22,  /**< Not Enough Resources */
+	RTW_UNSUPPORTED                  = -23,  /**< Unsupported */
+	RTW_BADLEN                       = -24,  /**< Bad length */
+	RTW_NOTREADY                     = -25,  /**< Not Ready */
+	RTW_EPERM                        = -26,  /**< Not Permitted */
+	RTW_NOMEM                        = -27,  /**< No Memory */
+	RTW_ASSOCIATED                   = -28,  /**< Associated */
+	RTW_RANGE                        = -29,  /**< Not In Range */
+	RTW_NOTFOUND                     = -30,  /**< Not Found */
+	RTW_WME_NOT_ENABLED              = -31,  /**< WME Not Enabled */
+	RTW_TSPEC_NOTFOUND               = -32,  /**< TSPEC Not Found */
+	RTW_ACM_NOTSUPPORTED             = -33,  /**< ACM Not Supported */
+	RTW_NOT_WME_ASSOCIATION          = -34,  /**< Not WME Association */
+	RTW_SDIO_ERROR                   = -35,  /**< SDIO Bus Error */
+	RTW_WLAN_DOWN                    = -36,  /**< WLAN Not Accessible */
+	RTW_BAD_VERSION                  = -37,  /**< Incorrect version */
+	RTW_TXFAIL                       = -38,  /**< TX failure */
+	RTW_RXFAIL                       = -39,  /**< RX failure */
+	RTW_NODEVICE                     = -40,  /**< Device not present */
+	RTW_UNFINISHED                   = -41,  /**< To be finished */
+	RTW_NONRESIDENT                  = -42,  /**< access to nonresident overlay */
+	RTW_DISABLED                     = -43   /**< Disabled in this build */
+} rtw_result_t;
+
+/**
+  * @brief The enumeration lists the supported operation mode by WIFI driver,
+  *			including station and AP mode.
+  */
+typedef enum {
+	RTW_MODE_NONE = 0,  ///<none
+	RTW_MODE_STA,          ///<sta mode
+	RTW_MODE_AP,           ///<ap mode
+	RTW_MODE_STA_AP,   ///< ap and sta mode
+} rtw_mode_t;
+
+/**
+  * @brief  The enumeration lists the supported autoreconnect mode by WIFI driver.
+  */
+typedef enum {
+	RTW_AUTORECONNECT_DISABLE,  ///< disable auto reconnect
+	RTW_AUTORECONNECT_FINITE,    ///< finite auto reconnect
+	RTW_AUTORECONNECT_INFINITE ///< infinite auto reconnect
+} rtw_autoreconnect_mode_t;
+
+/**
+  * @brief  The enumeration lists the interfaces.
+  */
+typedef enum {
+	RTW_STA_INTERFACE     = 0, /**<  STA or Client Interface  */
+	RTW_AP_INTERFACE      = 1 /**<  SoftAP Interface         */
+} rtw_interface_t;
+
+/* For freertos, core, hal, rf, halbb. */
+enum phl_phy_idx {
+	HW_PHY_0,
+	HW_PHY_1,
+	HW_PHY_MAX
+};
+
+/**
+  * @brief  The enumeration lists the packet filter rules.
+  */
+typedef enum {
+	RTW_POSITIVE_MATCHING  = 0, /**< Receive the data matching with this pattern and discard the other data   */
+	RTW_NEGATIVE_MATCHING  = 1  /**< Discard the data matching with this pattern and receive the other data */
+} rtw_packet_filter_rule_t;
+
+/**
+  * @brief channel switch
+  */
+typedef enum {
+	RTW_CH_SWITCH_FAIL = -1,           ///<channel switch fail
+	RTW_CH_SWITCH_SUCCESS = 0,      ///<channel switch success
+} rtw_channel_switch_res_t;
+
+/**
+  * @brief wowlan option
+  */
+typedef enum {
+	RTW_WOWLAN_CTRL,            ///< control mode
+	RTW_WOWLAN_SET_PATTREN,///< set pattren mode
+	RTW_WOWLAN_REDOWNLOAD_FW,///< redownload fw
+} rtw_wowlan_option_t;
+
+/**
+  * @brief  The enumeration is event type indicated from wlan driver.
+  */
+typedef enum {
+	/* common event */
+	WIFI_EVENT_STA_ASSOC = 0,		///<used in p2p, simple config, 11s, customer
+	WIFI_EVENT_STA_DISASSOC,		///<used in p2p, customer
+	WIFI_EVENT_RX_MGNT,				///<used in p2p, customer
+	WIFI_EVENT_CONNECT,				///<used in ipv6 example, p2p, wifi_manager example
+	WIFI_EVENT_DISCONNECT,			///<used in wifi_manager example, p2p, eap
+
+	WIFI_EVENT_GROUP_KEY_CHANGED,
+	WIFI_EVENT_RECONNECTION_FAIL,
+	WIFI_EVENT_ICV_ERROR,
+	WIFI_EVENT_CHALLENGE_FAIL,
+
+	WIFI_EVENT_JOIN_STATUS,			///<internally use for joinstatus indicate
+
+	/* wpa event */
+	WIFI_EVENT_WPA_STA_WPS_START,
+	WIFI_EVENT_WPA_WPS_FINISH,
+	WIFI_EVENT_WPA_EAPOL_START,
+	WIFI_EVENT_WPA_EAPOL_RECVD,
+
+	/* csi rx done event */
+	WIFI_EVENT_CSI_DONE,
+
+	WIFI_EVENT_MAX,
+} rtw_event_indicate_t;
+
+/**
+  * The enumeration lists the power save status.
+  */
+typedef enum {
+	LPS_NORMAL = 0, ///< normal
+	LPS_PG,             ///<pg
+	LPS_LEVEL_MAX,
+} lps_level;
+
+enum gen_ie_type {
+	P2PWPS_PROBE_REQ_IE = 0,
+	P2PWPS_PROBE_RSP_IE,
+	P2PWPS_BEACON_IE,
+	P2PWPS_ASSOC_REQ_IE,
+	P2PWPS_ASSOC_RSP_IE
+};
+
+#ifndef _CUSTOM_IE_TYPE_
+#define _CUSTOM_IE_TYPE_
+typedef enum CUSTOM_IE_TYPE {
+	PROBE_REQ = BIT(0),
+	PROBE_RSP = BIT(1),
+	BEACON	  = BIT(2),
+	ASSOC_REQ = BIT(3),
+} rtw_custom_ie_type_t;
+#endif /* _CUSTOM_IE_TYPE_ */
+
+#include "rtw_ethernet.h"
+#include "rtw_80211spec_macro.h"
+#include "rtw_80211spec_struct.h"
+#include "rtw_80211spec_enum.h"
+#include "rtw_80211spec_ft.h"
+#include "rtw_80211spec_he.h"
+#include "rtw_80211spec_ht.h"
+#include "rtw_80211spec_twt.h"
+#include "rtw_80211spec_vht.h"
+#include "rtw_80211spec_wnm.h"
+
+#endif
diff --git a/os/board/rtl8720e/src/component/wifi/driver/include/rtw_wifi_struct.h b/os/board/rtl8720e/src/component/wifi/driver/include/rtw_wifi_struct.h
new file mode 100755
index 000000000..414e942b7
--- /dev/null
+++ b/os/board/rtl8720e/src/component/wifi/driver/include/rtw_wifi_struct.h
@@ -0,0 +1,207 @@
+#ifndef __RTW_WIFI_STRUCT_H_
+#define __RTW_WIFI_STRUCT_H_
+
+typedef unsigned char	NDIS_802_11_MAC_ADDRESS[6];
+typedef long			NDIS_802_11_RSSI;			// in dBm
+
+typedef enum _NDIS_802_11_NETWORK_INFRASTRUCTURE {
+	Ndis802_11Infrastructure,
+	Ndis802_11AutoUnknown,
+	Ndis802_11APMode,
+} NDIS_802_11_NETWORK_INFRASTRUCTURE, *PNDIS_802_11_NETWORK_INFRASTRUCTURE;
+
+typedef enum _NDIS_802_11_NETWORK_TYPE {
+	Ndis802_11FH,
+	Ndis802_11DS,
+	Ndis802_11OFDM5,
+	Ndis802_11OFDM24,
+	Ndis802_11NetworkTypeMax	// not a real type, defined as an upper bound
+} NDIS_802_11_NETWORK_TYPE, *PNDIS_802_11_NETWORK_TYPE;
+
+typedef struct _NDIS_802_11_CONFIGURATION_FH {
+	u32 		  Length;			  // Length of structure
+	u32 		  HopPattern;		  // As defined by 802.11, MSB set
+	u32 		  HopSet;			  // to one if non-802.11
+	u32 		  DwellTime;		  // units are Kusec
+} NDIS_802_11_CONFIGURATION_FH;
+
+typedef struct _NDIS_802_11_CONFIGURATION {
+	u32 		  BeaconPeriod; 	  // units are Kusec
+	u32 		  ATIMWindow;		  // units are Kusec
+	u32 		  DSConfig; 		  // Frequency, units are kHz
+	NDIS_802_11_CONFIGURATION_FH	FHConfig;
+} NDIS_802_11_CONFIGURATION;
+
+struct _WLAN_PHY_INFO {
+	u8	SignalStrength; 	//(in percentage)
+	u8	SignalQuality;		//(in percentage)
+	u8	Optimum_antenna;	//for Antenna diversity
+	u8		Reserved_0;
+#ifdef CONFIG_IEEE80211K
+	u8	is_cck_rate;	/* 1:cck_rate */
+	s8	rx_snr[4];
+	u32 free_cnt;	/* freerun counter */
+#endif
+} _PACKED_;
+typedef struct _WLAN_PHY_INFO WLAN_PHY_INFO;
+
+typedef struct _WLAN_BCN_INFO {
+	/* these infor get from rtw_get_encrypt_info when
+	 *	 * translate scan to UI */
+	u8	encryp_protocol;	//ENCRYP_PROTOCOL_E: OPEN/WEP/WPA/WPA2/WAPI
+	int group_cipher;		//WPA/WPA2 group cipher
+	int pairwise_cipher;	//WPA/WPA2/WEP pairwise cipher
+	int is_8021x;
+	u8 is_1M_beacon;		// check if the beacon uses 1M data rate
+
+	/* bwmode 20/40 and ch_offset UP/LOW */
+	unsigned short	ht_cap_info;
+	unsigned char	ht_info_infos_0;
+} WLAN_BCN_INFO;
+
+#ifdef CONFIG_MBSSID_AX
+#define MAX_VIRTUAL_AP_NUM	8
+typedef struct _mbssid_virtual_ap_info {
+	u8					bssid_idx;	// from bssid-index ie
+	NDIS_802_11_SSID	Ssid;		//from ssid ie
+} mbssid_virtual_ap_info_t;
+
+typedef struct _mbssid_info {
+	u8 mbssid_enable;	// AP support mbssid
+	u8 mbssid_complete; // MBSSID element carriy complete non-transmitted BSSID profile
+	u8 mbssid_ema;		//enhanced MBSSID advertisement
+	u8 bssid_max;		//max_bssid_indicator
+	u8 bssid_ref[6];		// transmitted-BSSID
+	u8 virtual_ap_num;	// num of non-transmitted BSSID
+	u8 bssid_idx_to_join;	//bssid index of non-transmitted BSSID to join
+	u8 is_virtual_ap;		// 1: ap to join is non-transmitted
+	mbssid_virtual_ap_info_t virtual_ap_info[MAX_VIRTUAL_AP_NUM];	// store non-transmitted BSSID profile
+	u8 *mbssid_ie;		//start with non-transmitted BSSID profile
+	u16 mbssid_ie_len;
+} mbssid_info_t;
+#endif
+
+typedef struct _WLAN_BSSID_EX {
+	u32 				Length;
+	u8					MacAddress[6];
+#ifdef CONFIG_MBSSID_AX
+	mbssid_info_t mbssid_info;
+#endif
+
+	u8					Reserved[2];		//[0]: IS beacon frame
+	NDIS_802_11_SSID			Ssid;
+	u32 				Privacy;
+	NDIS_802_11_RSSI			Rssi;			//(in dBM,raw data ,get from PHY)
+	NDIS_802_11_NETWORK_TYPE		NetworkTypeInUse;
+	NDIS_802_11_CONFIGURATION		Configuration;
+	NDIS_802_11_RATES_EX		SupportedRates;
+	WLAN_PHY_INFO				PhyInfo;
+	u32 				IELength;
+	u8					IEs[MAX_IE_SZ]; 	//(timestamp, beacon interval, and capability information)
+} WLAN_BSSID_EX;
+
+struct	wlan_network {
+	_list	list;
+	int network_type;	//refer to ieee80211.h for WIRELESS_11A/B/G
+	int fixed;			// set to fixed when not to be removed as site-surveying
+	unsigned long	last_scanned; //timestamp for the network
+	int aid;			//will only be valid when a BSS is joinned.
+	int join_res;
+	WLAN_BSSID_EX	network; //must be the last item
+	WLAN_BCN_INFO	BcnInfo;
+};
+
+struct net_device_stats {
+
+	unsigned long	rx_packets;				/*!< total packets received       */
+	unsigned long	tx_packets;				/*!<total packets transmitted    */
+	unsigned long	rx_dropped;				/*!< no space in buffers    */
+	unsigned long	tx_dropped;				/*!< no space available  */
+	unsigned long	rx_bytes;				/*!< total bytes received         */
+	unsigned long	tx_bytes;				/*!< total bytes transmitted      */
+	unsigned long	rx_overflow;			/*!< rx fifo overflow count       */
+
+	u64		last_tx_bytes;
+	u64		last_tx_pkts;
+	u64		last_rx_bytes;
+	u16		rx_reorder_drop_cnt;
+	u16		rx_reorder_timeout_cnt;
+	_timer		signal_stat_timer;
+	u32		is_any_non_be_pkts;
+	struct signal_stat signal_qual_data;
+	struct signal_stat signal_strength_data;
+	struct signal_stat signal_snr_data;
+
+	/* For display the phy informatiom */
+	int RxSNRdB[2];
+	s8 rssi;
+	s8 snr;
+	u8 signal_strength;
+	u8 signal_qual;
+#if defined(CONFIG_RTL8735B)
+	u8 signal_strength_backup;
+#endif // defined(CONFIG_RTL8735B)
+};
+
+/* ------------------------ iwpriv related ------------------------ */
+#undef IFNAMSIZ
+#define IFNAMSIZ	16
+
+/*
+ *	Generic format for most parameters that fit in an int
+ */
+struct	rtw_param {
+	__s32		value;		/* The value of the parameter itself */
+	__u8		fixed;		/* Hardware should not use auto select */
+	__u8		disabled;	/* Disable the feature */
+	__u16		flags;		/* Various specifc flags (if any) */
+};
+
+struct	rtw_point {
+	void		*pointer;	/* Pointer to the data  (in user space) */
+	__u16		length;		/* number of fields or size in bytes */
+	__u16		flags;		/* Optional params */
+};
+
+struct	rtw_freq {
+	__s32		m;		/* Mantissa */
+	__s16		e;		/* Exponent */
+	__u8		i;		/* List index (when in range struct) */
+	__u8		flags;		/* Flags (fixed/auto) */
+};
+
+
+union rtwreq_data {
+	/* Config - generic */
+	char			name[IFNAMSIZ];	/* Name : used to verify the presence of  wireless extensions. * Name of the protocol/provider... */
+	struct rtw_point	essid;		/* Extended network name */
+	struct rtw_param	nwid;		/* network id (or domain - the cell) */
+	struct rtw_freq		freq;		/* frequency or channel : * 0-1000 = channel * > 1000 = frequency in Hz */
+	struct rtw_param	sens;		/* signal level threshold */
+	struct rtw_param	snr;		/* signal noise ratio */
+	struct rtw_param	bitrate;	/* default bit rate */
+	struct rtw_param	txpower;	/* default transmit power */
+	struct rtw_param	rts;		/* RTS threshold threshold */
+	struct rtw_param	frag;		/* Fragmentation threshold */
+	__u32			mode;		/* Operation mode */
+	struct rtw_param	retry;		/* Retry limits & lifetime */
+	struct rtw_point	encoding;	/* Encoding stuff : tokens */
+	struct rtw_param	power;		/* PM duration/timeout */
+	struct sockaddr_t	ap_addr;	/* Access point address */
+	struct sockaddr_t	addr;		/* Destination address (hw/mac) */
+	struct rtw_param	param;		/* Other small parameters */
+	struct rtw_point	data;		/* Other large parameters */
+	struct rtw_point	passphrase;	/* Extended network name */
+};
+
+struct rtwreq {
+	char		ifr_name[IFNAMSIZ];	/* if name, e.g. "eth0" */
+	union		rtwreq_data	u;
+};
+
+struct rtw_priv_args {
+	__u32		cmd;		/* Number of the ioctl to issue */
+	char		name[IFNAMSIZ];	/* Name of the extension */
+};
+
+#endif
diff --git a/os/board/rtl8720e/src/component/wifi/driver/include/rtw_wnm.h b/os/board/rtl8720e/src/component/wifi/driver/include/rtw_wnm.h
deleted file mode 100644
index 4fd5e552d..000000000
--- a/os/board/rtl8720e/src/component/wifi/driver/include/rtw_wnm.h
+++ /dev/null
@@ -1,159 +0,0 @@
-#ifndef __RTW_WNM_H_
-#define __RTW_WNM_H_
-
-#define WNM_SUPPORT_IWPRIV_DBG 1
-#define RTW_RRM_NB_RPT_EN		BIT(1)
-#define RTW_MAX_NB_RPT_NUM	16
-
-#define rtw_roam_busy_scan(a, nb)	\
-	(nb && (rtw_get_mlmepriv(a)->LinkDetectInfo.bBusyTraffic == _TRUE) && \
-	(((nb)->ch_cnt) < ((nb)->nb_rpt_ch_list_num)))
-
-#define rtw_wnm_btm_preference_cap(a) \
-	(rtw_get_rmpriv(a)->nb_info && rtw_get_rmpriv(a)->nb_info->preference_en == _TRUE)
-
-#define rtw_btm_roam(a)	\
-	((rtw_to_roam(a) > 0) && rtw_chk_roam_flags(a, RTW_ROAM_ON_BTM) \
-	&& (rtw_get_rmpriv(a)->roam_status == RTW_ROAM_BTM_RUNNING))
-
-/* target Bssid can not be own mac address*/
-#define rtw_wnm_btm_diff_bss(a) \
-	((rtw_wnm_btm_preference_cap(a)) && \
-	(is_zero_mac_addr(rtw_get_rmpriv(a)->nb_info->roam_target_addr) == _FALSE) && \
-	(rtw_memcmp(rtw_get_rmpriv(a)->nb_info->roam_target_addr,\
-		rtw_get_bssid(a), ETH_ALEN) == _FALSE)  && \
-	(rtw_memcmp(rtw_get_rmpriv(a)->nb_info->roam_target_addr,\
-		(a)->mac_addr,ETH_ALEN) == _FALSE))
-
-
-#define rtw_wnm_btm_roam_candidate(a, c) \
-	((rtw_wnm_btm_preference_cap(a)) && \
-	(is_zero_mac_addr(rtw_get_rmpriv(a)->nb_info->roam_target_addr) == _FALSE) && \
-	(rtw_memcmp(rtw_get_rmpriv(a)->nb_info->roam_target_addr,\
-		(c)->network.MacAddress, ETH_ALEN)))
-
-#define rtw_wnm_set_ext_cap_btm(_pEleStart, _val) \
-	SET_BITS_TO_LE_1BYTE(((u8 *)(_pEleStart))+2, 3, 1, _val)
-
-#define wnm_btm_bss_term_inc(p) (*((u8 *)((p)+3)) & BSS_TERMINATION_INCLUDED)
-
-#define wnm_btm_ess_disassoc_im(p) (*((u8 *)((p)+3)) & ESS_DISASSOC_IMMINENT)
-
-#define wnm_btm_dialog_token(p) (*((u8 *)((p)+2)))
-
-#define wnm_btm_req_mode(p) (*((u8 *)((p)+3)))
-
-#define wnm_btm_disassoc_timer(p) (*((u16 *)((p)+4)))
-
-#define wnm_btm_valid_interval(p) (*((u8 *)((p)+6)))
-
-#define wnm_btm_term_duration_offset(p) ((p)+7)
-
-#define RTW_WLAN_ACTION_WNM_NB_RPT_ELEM	0x34
-
-enum rtw_ieee80211_wnm_actioncode {
-	RTW_WLAN_ACTION_WNM_BTM_QUERY = 6,
-	RTW_WLAN_ACTION_WNM_BTM_REQ = 7,
-	RTW_WLAN_ACTION_WNM_BTM_RSP = 8,
-	RTW_WLAN_ACTION_WNM_NOTIF_REQ = 26,
-	RTW_WLAN_ACTION_WNM_NOTIF_RSP = 27,
-};
-
-/*IEEE Std 80211k Figure 7-95b Neighbor Report element format*/
-struct nb_rpt_hdr {
-	u8 id; /*0x34: Neighbor Report Element ID*/
-	u8 len;
-	u8 bssid[ETH_ALEN];
-	u32 bss_info;
-	u8 reg_class;
-	u8 ch_num;
-	u8 phy_type;
-};
-
-/*IEEE Std 80211v, Figure 7-9 BSS Termination Duration subelement field format */
-struct btm_term_duration {
-	u8 id;
-	u8 len;
-	u64 tsf;		/* value of the TSF counter when BSS termination will occur in the future */
-	u16 duration;		/* number of minutes for which the BSS is not present*/
-};
-
-/*IEEE Std 80211v, Figure 7-10 BSS Transition Management Request frame body format */
-struct btm_req_hdr {
-	u8 dialog_token;
-	u8 req_mode;
-	/* number of TBTTs until the AP sends a Disassociation frame to this STA */
-	u16 disassoc_timer;
-	/* number of TBTTs until the BSS transition candidate list is no longer valid */
-	u8 validity_interval;
-	struct btm_term_duration term_duration;
-};
-
-struct btm_rpt_cache {
-	u8 dialog_token;
-	u8 req_mode;
-	u16 disassoc_timer;
-	u8 validity_interval;
-	struct btm_term_duration term_duration;
-
-	/* from BTM req */
-	u32 validity_time;
-	u32 disassoc_time;
-
-	systime req_stime;
-};
-
-/*IEEE Std 80211v,  Table 7-43b Optional Subelement IDs for Neighbor Report*/
-/* BSS Transition Candidate Preference */
-#define WNM_BTM_CAND_PREF_SUBEID 0x03
-
-/* BSS Termination Duration */
-#define WNM_BTM_TERM_DUR_SUBEID		0x04
-
-struct wnm_btm_cant {
-	struct nb_rpt_hdr nb_rpt;
-	u8 preference;	/* BSS Transition Candidate Preference */
-};
-
-enum rtw_btm_req_mod {
-	PREFERRED_CANDIDATE_LIST_INCLUDED = BIT(0),
-	ABRIDGED = BIT(1),
-	DISASSOC_IMMINENT = BIT(2),
-	BSS_TERMINATION_INCLUDED = BIT(3),
-	ESS_DISASSOC_IMMINENT = BIT(4),
-};
-
-struct roam_nb_info {
-	struct nb_rpt_hdr nb_rpt[RTW_MAX_NB_RPT_NUM];
-	struct rtw_ieee80211_channel nb_rpt_ch_list[RTW_MAX_NB_RPT_NUM];
-	struct btm_rpt_cache btm_cache;
-	bool	nb_rpt_valid;
-	u8	nb_rpt_ch_list_num;
-	u8 preference_en;
-	u8 roam_target_addr[ETH_ALEN];
-	u32	last_nb_rpt_entries;
-	u8 nb_rpt_is_same;
-	s8 disassoc_waiting;
-	u8 ch_cnt;
-	_timer roam_scan_timer;
-	_timer disassoc_chk_timer;
-};
-
-u8 rtw_wnm_btm_reassoc_req(_adapter *padapter);
-void rtw_wnm_roam_scan_hdl(void *ctx);
-void rtw_wnm_disassoc_chk_hdl(void *ctx);
-u8 rtw_wnm_try_btm_roam_imnt(_adapter *padapter);
-void rtw_wnm_process_btm_req(_adapter *padapter,  u8 *pframe, u32 frame_len);
-void rtw_wnm_reset_btm_candidate(struct roam_nb_info *pnb);
-void rtw_wnm_reset_btm_state(_adapter *padapter);
-void rtw_wnm_reset_btm_cache(_adapter *padapter);
-void rtw_wnm_issue_action(_adapter *padapter, u8 action, u8 reason, u8 dialog);
-void rtw_wnm_update_reassoc_req_ie(_adapter *padapter);
-
-void rtw_roam_nb_info_init(_adapter *padapter);
-u8 rtw_roam_nb_scan_list_set(
-	_adapter *padapter, struct sitesurvey_parm *pparm);
-u32 rtw_wnm_btm_candidates_survey(_adapter *padapter,
-								  u8 *pframe, u32 elem_len, u8 is_preference);
-#endif /* __RTW_WNM_H_ */
-
diff --git a/os/board/rtl8720e/src/component/wifi/driver/include/rtw_xmit.h b/os/board/rtl8720e/src/component/wifi/driver/include/rtw_xmit.h
deleted file mode 100644
index a5646a422..000000000
--- a/os/board/rtl8720e/src/component/wifi/driver/include/rtw_xmit.h
+++ /dev/null
@@ -1,549 +0,0 @@
-/******************************************************************************
- *
- * Copyright(c) 2007 - 2012 Realtek Corporation. All rights reserved.
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of version 2 of the GNU General Public License as
- * published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
- * more details.
- *
- * You should have received a copy of the GNU General Public License along with
- * this program; if not, write to the Free Software Foundation, Inc.,
- * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
- *
- *
- ******************************************************************************/
-#ifndef _RTW_XMIT_H_
-#define _RTW_XMIT_H_
-
-/*---------------------------------------
-  Define MAX_XMITBUF_SZ
----------------------------------------*/
-#if defined(CONFIG_LX_HCI) || defined(CONFIG_AXI_HCI)
-
-#ifdef CONFIG_TX_AGGREGATION	//effect only for SDIO and GSPI Interface
-#define MAX_XMITBUF_SZ	(20480)	// 20k
-#else
-
-#if defined(CONFIG_LX_HCI) || defined(CONFIG_AXI_HCI)
-#define HAL_INTERFACE_OVERHEAD_XMIT_BUF 0
-#endif
-
-// Consideration for MAX_XMITBUF_SZ size
-// 	Check more detail information in MAX_SKB_BUF_SIZE
-//	Tx: [INTF_CMD][TX_DESC][WLAN_HDR][QoS][IV][SNAP][Data][MIC][ICV][INTF_STATUS]
-//	HAL_INTERFACE_OVERHEAD: HAL_INTERFACE_CMD is 4/0 for SPI/PCIE, HAL_INTERFACE_STATUS is 8/0 for SPI/PCIE
-//	WLAN_MAX_ETHFRM_LEN : May not be required because WLAN_HEADER +SNAP can totally
-//			cover ethernet header.Keep in only for safety.
-
-#define MAX_XMITBUF_SZ		(HAL_INTERFACE_OVERHEAD_XMIT_BUF+\
-							TXDESC_SIZE+\
-							WLAN_MAX_PROTOCOL_OVERHEAD + WLAN_MAX_ETHFRM_LEN +\
-							SKB_RESERVED_FOR_SAFETY)
-
-#endif	//#ifdef CONFIG_TX_AGGREGATION
-
-#endif	//interface define. SDIO/GSPI/LXbus/PCI/USB
-
-/*--------------------------------------------------------------*/
-/*  Define MAX_XMITBUF_SZ										*/
-/*--------------------------------------------------------------*/
-#if defined(CONFIG_LX_HCI) || defined(CONFIG_AXI_HCI)
-#define NR_XMITBUFF (8)
-#endif //interface define
-
-/*--------------------------------------------------------------*/
-/*  Define XMITBUF_ALIGN_SZ										*/
-/*--------------------------------------------------------------*/
-#define XMITBUF_ALIGN_SZ 4
-
-#define MAX_CMDBUF_SZ	(5120)	//(4096)
-/*--------------------------------------------------------------*/
-/*  Define xmit extension buff, size/numbers							*/
-/*--------------------------------------------------------------*/
-#define MAX_XMIT_EXTBUF_SZ	(1536)
-
-#define NR_XMIT_EXTBUFF		(8)	//Decrease ext xmit buffer due to memory limitation - Alex Fang
-
-#define MAX_NUMBLKS		(1)
-
-#define XMIT_VO_QUEUE (0)
-#define XMIT_VI_QUEUE (1)
-#define XMIT_BE_QUEUE (2)
-#define XMIT_BK_QUEUE (3)
-
-#if defined(CONFIG_PLATFORM_8735B)
-#define VO_QUEUE_INX		0
-#define VI_QUEUE_INX		1
-#define BE_QUEUE_INX		2
-#define BK_QUEUE_INX		3
-#define BCN_QUEUE_INX		4
-#define MGT_QUEUE_INX		5
-#define HIGH_QUEUE_INX		6
-#define HIGH1_QUEUE_INX		7
-#define H2C_QUEUE_INX		8
-#define HW_QUEUE_ENTRY		9
-#else
-#define VO_QUEUE_INX		0
-#define VI_QUEUE_INX		1
-#define BE_QUEUE_INX		2
-#define BK_QUEUE_INX		3
-#define BCN_QUEUE_INX		4
-#define MGT_QUEUE_INX		5
-#define HIGH_QUEUE_INX		6
-#define TXCMD_QUEUE_INX		7
-#ifdef CONFIG_WLAN_HAL_TEST
-#define HIGH1_QUEUE_INX		8
-#define HIGH2_QUEUE_INX		9
-#define HIGH3_QUEUE_INX		10
-#define HIGH4_QUEUE_INX		11
-#define HIGH5_QUEUE_INX		12
-#define HIGH6_QUEUE_INX		13
-#define HIGH7_QUEUE_INX		14
-#define HW_QUEUE_ENTRY		15
-#else
-#define HW_QUEUE_ENTRY		8
-#endif
-#endif // #if defined(CONFIG_PLATFORM_8735B)
-
-#define WEP_IV(pattrib_iv, dot11txpn, keyidx)\
-do{\
-	pattrib_iv[0] = dot11txpn._byte_.TSC0;\
-	pattrib_iv[1] = dot11txpn._byte_.TSC1;\
-	pattrib_iv[2] = dot11txpn._byte_.TSC2;\
-	pattrib_iv[3] = ((keyidx & 0x3)<<6);\
-	dot11txpn.val = (dot11txpn.val == 0xffffff) ? 0: (dot11txpn.val+1);\
-}while(0)
-
-
-#define TKIP_IV(pattrib_iv, dot11txpn, keyidx)\
-do{\
-	pattrib_iv[0] = dot11txpn._byte_.TSC1;\
-	pattrib_iv[1] = (dot11txpn._byte_.TSC1 | 0x20) & 0x7f;\
-	pattrib_iv[2] = dot11txpn._byte_.TSC0;\
-	pattrib_iv[3] = BIT(5) | ((keyidx & 0x3)<<6);\
-	pattrib_iv[4] = dot11txpn._byte_.TSC2;\
-	pattrib_iv[5] = dot11txpn._byte_.TSC3;\
-	pattrib_iv[6] = dot11txpn._byte_.TSC4;\
-	pattrib_iv[7] = dot11txpn._byte_.TSC5;\
-	dot11txpn.val = dot11txpn.val == 0xffffffffffffULL ? 0: (dot11txpn.val+1);\
-}while(0)
-
-#define AES_IV(pattrib_iv, dot11txpn, keyidx)\
-do{\
-	pattrib_iv[0] = dot11txpn._byte_.TSC0;\
-	pattrib_iv[1] = dot11txpn._byte_.TSC1;\
-	pattrib_iv[2] = 0;\
-	pattrib_iv[3] = BIT(5) | ((keyidx & 0x3)<<6);\
-	pattrib_iv[4] = dot11txpn._byte_.TSC2;\
-	pattrib_iv[5] = dot11txpn._byte_.TSC3;\
-	pattrib_iv[6] = dot11txpn._byte_.TSC4;\
-	pattrib_iv[7] = dot11txpn._byte_.TSC5;\
-	dot11txpn.val = dot11txpn.val == 0xffffffffffffULL ? 0: (dot11txpn.val+1);\
-}while(0)
-
-#define GCMP_IV(pattrib_iv, dot11txpn, keyidx)\
-do {\
-	pattrib_iv[0] = dot11txpn._byte_.TSC0;\
-	pattrib_iv[1] = dot11txpn._byte_.TSC1;\
-	pattrib_iv[2] = 0;\
-	pattrib_iv[3] = BIT(5) | ((keyidx & 0x3)<<6);\
-	pattrib_iv[4] = dot11txpn._byte_.TSC2;\
-	pattrib_iv[5] = dot11txpn._byte_.TSC3;\
-	pattrib_iv[6] = dot11txpn._byte_.TSC4;\
-	pattrib_iv[7] = dot11txpn._byte_.TSC5;\
-	dot11txpn.val = dot11txpn.val == 0xffffffffffffULL ? 0 : (dot11txpn.val+1);\
-} while (0)
-
-
-#if defined(CONFIG_RTL8721D) || defined(CONFIG_RTL8730A) \
-	|| defined(CONFIG_RTL8710C) || defined(CONFIG_RTL8720E) || defined(CONFIG_RTL8730E) || defined(CONFIG_RTL8721F)
-#define TXDESC_SIZE 40
-#elif defined(CONFIG_RTL8195B) || defined(CONFIG_RTL8735B)
-#define TXDESC_SIZE 48
-#else
-#define TXDESC_SIZE 32
-#endif
-
-#define TXDESC_OFFSET TXDESC_SIZE
-#define TX_DESC_NEXT_DESC_OFFSET	40
-#define TX_FRAGMENTATION_THRESHOLD 	2346
-
-#ifdef TX_SHORTCUT
-#define TX_SC_ENTRY_NUM 		4
-#endif
-
-union Keytype {
-	u8   skey[16];
-	u32  lkey[4];
-};
-
-// Suppose (TX_DESC_MODE=1) ==> Segment number for each tx_buf_desc is 4. 2X4 = 8 (double words).
-struct tx_buf_desc {
-	unsigned int txdw0;
-	unsigned int txdw1;
-	unsigned int txdw2;
-	unsigned int txdw3;
-	unsigned int txdw4;
-	unsigned int txdw5;
-	unsigned int txdw6;
-	unsigned int txdw7;
-};
-
-struct tx_desc {
-	//DWORD 0
-	unsigned int txdw0;
-	unsigned int txdw1;
-	unsigned int txdw2;
-	unsigned int txdw3;
-	unsigned int txdw4;
-	unsigned int txdw5;
-	unsigned int txdw6;
-	unsigned int txdw7;
-#if defined(CONFIG_LX_HCI)|| defined(CONFIG_RTL8195B) || defined(CONFIG_RTL8710C) || defined(CONFIG_RTL8735B) || \
-	defined(CONFIG_RTL8730A) || defined(CONFIG_RTL8720E) || defined(CONFIG_RTL8730E) || defined(CONFIG_RTL8721F)
-	unsigned int txdw8;
-	unsigned int txdw9;
-#endif
-#if defined(CONFIG_RTL8195B) || defined(CONFIG_RTL8735B)
-	unsigned int txdw10;
-	unsigned int txdw11;
-#endif
-};
-
-
-union txdesc {
-	struct tx_desc txdesc;
-	unsigned int value[TXDESC_SIZE >> 2];
-};
-
-#if defined(CONFIG_AXI_HCI) || defined(CONFIG_WLAN_HAL_TEST)
-#define PCI_MAX_TX_QUEUE_COUNT	 HW_QUEUE_ENTRY
-#else
-#define PCI_MAX_TX_QUEUE_COUNT	8
-#endif
-
-struct rtw_tx_ring {
-#if ((RTL8721D_SUPPORT == 1) || (RTL8735B_SUPPORT == 1) || (RTL8720E_SUPPORT == 1) || (RTL8730E_SUPPORT == 1)) || (RTL8721F_SUPPORT == 1)
-	struct tx_buf_desc	*desc;
-#else
-	struct tx_desc	*desc;
-#endif
-	dma_addr_t		dma;
-	unsigned int		idx;
-	unsigned int		entries;
-	_queue			queue;
-	u32				qlen;
-};
-
-struct	hw_xmit	{
-	_queue sta_queue;
-	int	accnt;
-};
-
-//reduce size
-struct pkt_attrib {
-	u8	type;
-	u8	subtype;
-	u8	bswenc;
-	u8	dhcp_pkt;
-	u16	ether_type;
-	u16	seqnum;
-#if defined(CONFIG_RTL8195B) || defined(CONFIG_RTL8710C) || defined(CONFIG_RTL8735B)
-	u8	hw_ssn_sel;	/* for HW_SEQ0,1,2,3 */
-#endif
-	u16	pkt_hdrlen;	//the original 802.3 pkt header len
-	u16	hdrlen;		//the WLAN Header Len
-	u32	pktlen;		//the original 802.3 pkt raw_data len (not include ether_hdr data)
-	u32	last_txcmdsz;
-	u8	encrypt;	//when 0 indicate no encrypt. when non-zero, indicate the encrypt algorith
-#if defined(CONFIG_CONCURRENT_MODE)
-	u8	bmc_camid;
-#endif
-	u8	iv_len;
-	u8	icv_len;
-	u8	iv[18];
-	u8	icv[16];
-	u8	priority;
-	u8	ack_policy;
-	u8	mac_id;
-	u8	vcs_mode;	//virtual carrier sense method
-	u8 	dst[ETH_ALEN];
-	u8	src[ETH_ALEN];
-	u8	ta[ETH_ALEN];
-	u8 	ra[ETH_ALEN];
-	u8	key_idx;
-	u8	qos_en;
-	u8	ht_en;
-	u8	raid;//rate adpative id
-	u8	bwmode;
-	u8	ch_offset;//PRIME_CHNL_OFFSET
-	u8	sgi;//short GI
-	u8	ampdu_en;//tx ampdu enable
-	u8	mdata;//more data bit
-	u8	pctrl;//per packet txdesc control enable
-	u8	triggered;//for ap mode handling Power Saving sta
-	u8	qsel;
-	u8	eosp;
-	u8	order;// +htc/order bit: fc->bit15
-	u8	rate;
-	u8	intel_proxim;
-	u8 	retry_ctrl;
-	u8 	retry_limit_by_user; //for user control retry limit
-	struct sta_info *psta;
-
-#ifdef TX_SHORTCUT
-	u8 sc_entry_id;
-	u8 ether_hdr[14];
-#endif
-	u8	navusehdr;	//NAVUSEHDR
-
-#if defined (CONFIG_MSFT) && CONFIG_MSFT
-	u8 rate_fallback_table_idx;
-#endif
-#ifdef CONFIG_RELAY_MESH
-	u8	tx_swap;
-	u8 	ul_swap;
-#endif
-};
-
-#define WLANHDR_OFFSET	64
-
-#define NULL_FRAMETAG		(0x0)
-#define DATA_FRAMETAG		0x01
-#define L2_FRAMETAG		0x02
-#define MGNT_FRAMETAG		0x03
-#define AMSDU_FRAMETAG		0x04
-
-#define EII_FRAMETAG		0x05
-#define IEEE8023_FRAMETAG  	0x06
-
-#define MP_FRAMETAG		0x07
-
-#define TXAGG_FRAMETAG 		0x08
-
-enum {
-	XMITBUF_DATA = 0,
-	XMITBUF_MGNT = 1,
-	XMITBUF_CMD = 2,
-};
-
-struct  submit_ctx {
-	u32 submit_time; /* */
-	u32 timeout_ms; /* <0: not synchronous, 0: wait forever, >0: up to ms waiting */
-	int status; /* status for operation */
-};
-
-enum {
-	RTW_SCTX_SUBMITTED = -1,
-	RTW_SCTX_DONE_SUCCESS = 0,
-	RTW_SCTX_DONE_UNKNOWN,
-	RTW_SCTX_DONE_BUF_ALLOC,
-	RTW_SCTX_DONE_BUF_FREE,
-	RTW_SCTX_DONE_WRITE_PORT_ERR,
-	RTW_SCTX_DONE_TX_DESC_NA,
-	RTW_SCTX_DONE_TX_DENY,
-};
-
-
-void rtw_sctx_init(struct submit_ctx *sctx, int timeout_ms);
-int rtw_sctx_wait(struct submit_ctx *sctx);
-void rtw_sctx_done_err(struct submit_ctx **sctx, int status);
-void rtw_sctx_done(struct submit_ctx **sctx);
-
-typedef struct _XIMT_BUF_ {
-	u32			AllocatBufAddr;
-	u32			BufAddr;
-	u32			BufLen;
-} XIMT_BUF, *PXIMT_BUF;
-
-struct xmit_buf {
-	_list			list;
-	_adapter		*padapter;
-	_pkt			*pkt;
-	u8			*pbuf;
-	void			*priv_data;
-	u16			buf_tag; // 0: Normal xmitbuf, 1: extension xmitbuf, 2:cmd xmitbuf
-	u16			flags;
-	u32			alloc_sz;
-	u32			len;
-	struct submit_ctx	*sctx;
-#if defined(DBG_XMIT_BUF )|| defined(DBG_XMIT_BUF_EXT)
-	u8			no;
-#endif
-#if defined(CONFIG_LX_HCI) || defined(CONFIG_AXI_HCI)
-	XIMT_BUF		BufInfo[4];
-	u32			BlockNum;
-#endif
-};
-
-struct xmit_frame {
-	_list			list;
-	struct pkt_attrib	attrib;
-	_pkt			*pkt;
-	int			frame_tag;
-	_adapter		*padapter;
-	u8			*buf_addr;
-	struct xmit_buf		*pxmitbuf;
-
-#if defined(CONFIG_LX_HCI) || defined(CONFIG_AXI_HCI)
-	u32 TxDexAddr;
-	u32 HdrLen;
-	u32 PayLoadAddr;
-	u32 PayLoadLen;
-	u32 TotalLen;
-	u32 BlockNum;
-	XIMT_BUF BufInfo[4];
-	BOOLEAN NoCoalesce;
-#endif
-#ifdef CONFIG_XMIT_ACK
-	u8 ack_report;
-#endif
-#ifdef TX_SHORTCUT
-	int tx_shortcut_idx;
-#endif
-	u8 raw_type;//Test code construct trigger frame for mu test
-};
-
-struct tx_servq {
-	_list	tx_pending;
-	_queue	sta_pending;
-	int qcnt;
-};
-
-struct sta_xmit_priv {
-	sint	option;
-	sint	apsd_setting;	//When bit mask is on, the associated edca queue supports APSD.
-	struct tx_servq	blk_q;
-	_list 	legacy_dz;
-	_list  apsd;
-	u16 txseq_tid[MAXTID];
-};
-
-
-struct	hw_txqueue	{
-	volatile sint	head;
-	volatile sint	tail;
-	volatile sint 	free_sz;	//in units of 64 bytes
-	volatile sint      free_cmdsz;
-	volatile sint	 txsz[8];
-	uint	ff_hwaddr;
-	uint	cmd_hwaddr;
-	sint	ac_tag;
-};
-
-struct agg_pkt_info {
-	u16 offset;
-	u16 pkt_len;
-};
-
-
-struct xmit_priv {
-	_lock			lock;
-	u8			*pallocated_frame_buf;
-	u8			*pxmit_frame_buf;
-	uint			free_xmitframe_cnt;
-	_queue			free_xmit_queue;
-	_adapter		*adapter;
-	u8			vcs;
-	// Tx
-	struct rtw_tx_ring	tx_ring[PCI_MAX_TX_QUEUE_COUNT];
-	u8			beaconDMAing;		//flag of indicating beacon is transmiting to HW by DMA
-	_queue			free_xmitbuf_queue;
-	u8			*pallocated_xmitbuf;
-	u8			*pxmitbuf;
-	uint			free_xmitbuf_cnt;
-#if USE_XMIT_EXTBUFF
-	_queue			free_xmit_extbuf_queue;
-	u8			*pallocated_xmit_extbuf;
-	u8			*pxmit_extbuf;
-	uint			free_xmit_extbuf_cnt;
-#endif
-#if (defined(CONFIG_RTL8195B) || defined(CONFIG_RTL8735B))
-	u8			hw_ssn_seq_no;/* mapping to REG_HW_SEQ 0,1,2,3 */
-#endif // (defined(CONFIG_RTL8195B) || defined(CONFIG_RTL8735B))
-#ifdef CONFIG_XMIT_ACK
-	u8			ccx_txok;
-#endif
-	u16			tx_agg_max_num;
-};
-
-extern struct xmit_buf *rtw_alloc_xmitbuf_ext(struct xmit_priv *pxmitpriv, u32 size);
-extern s32 rtw_free_xmitbuf_ext(struct xmit_priv *pxmitpriv, struct xmit_buf *pxmitbuf);
-
-extern struct xmit_buf *rtw_alloc_xmitbuf(struct xmit_priv *pxmitpriv);
-extern s32 rtw_free_xmitbuf(struct xmit_priv *pxmitpriv, struct xmit_buf *pxmitbuf);
-
-extern struct xmit_frame *rtw_alloc_xmitframe(struct xmit_priv *pxmitpriv);
-extern s32 rtw_free_xmitframe(struct xmit_priv *pxmitpriv, struct xmit_frame *pxmitframe);
-extern void rtw_free_xmitframe_queue(struct xmit_priv *pxmitpriv, _queue *pframequeue);
-struct tx_servq *rtw_get_sta_pending(_adapter *padapter, struct sta_info *psta);
-extern s32 rtw_xmitframe_enqueue(_adapter *padapter, struct xmit_frame *pxmitframe);
-extern struct xmit_frame *rtw_dequeue_xframe(struct xmit_priv *pxmitpriv, struct hw_xmit *phwxmit_i);
-
-void rtw_count_tx_stats(_adapter *padapter, struct xmit_frame *pxmitframe, int sz);
-extern void rtw_update_protection(_adapter *padapter, u8 *ie, uint ie_len);
-extern s32 rtw_make_wlanhdr(_adapter *padapter, u8 *hdr, struct pkt_attrib *pattrib);
-extern s32 rtw_put_snap(u8 *data, u16 h_proto);
-
-extern s32 rtw_xmit_classifier(_adapter *padapter, struct xmit_frame *pxmitframe);
-extern u32 rtw_calculate_wlan_pkt_size_by_attribue(struct pkt_attrib *pattrib);
-#define rtw_wlan_pkt_size(f) rtw_calculate_wlan_pkt_size_by_attribue(&f->attrib)
-extern s32 rtw_xmitframe_coalesce(_adapter *padapter, _pkt *pkt, struct xmit_frame *pxmitframe);
-s32 _rtw_init_hw_txqueue(struct hw_txqueue *phw_txqueue, u8 ac_tag);
-void _rtw_init_sta_xmit_priv(struct sta_xmit_priv *psta_xmitpriv);
-
-
-s32 rtw_txframes_pending(_adapter *padapter);
-s32 rtw_txframes_sta_ac_pending(_adapter *padapter, struct pkt_attrib *pattrib);
-void rtw_txframes_update_attrib_vcs_info(_adapter *padapter, struct xmit_frame *pxmitframe);
-
-
-s32 _rtw_init_xmit_priv(struct xmit_priv *pxmitpriv, _adapter *padapter);
-void _rtw_free_xmit_priv(struct xmit_priv *pxmitpriv);
-
-
-s32 rtw_xmit(_adapter *padapter, _pkt **pkt);
-
-sint xmitframe_enqueue_for_sleeping_sta(_adapter *padapter, struct xmit_frame *pxmitframe);
-void stop_sta_xmit(_adapter *padapter, struct sta_info *psta);
-void wakeup_sta_to_xmit(_adapter *padapter, struct sta_info *psta);
-void xmit_delivery_enabled_frames(_adapter *padapter, struct sta_info *psta);
-
-u8 query_ra_short_GI(struct sta_info *psta, u8 bw);
-u8	qos_acm(u8 acm_mask, u8 priority);
-
-s32 xmitframe_addmic(_adapter *padapter, struct xmit_frame *pxmitframe);
-s32 xmitframe_swencrypt(_adapter *padapter, struct xmit_frame *pxmitframe);
-
-#ifdef CONFIG_XMIT_THREAD_MODE
-void	enqueue_pending_xmitbuf(struct xmit_priv *pxmitpriv, struct xmit_buf *pxmitbuf);
-struct xmit_buf	*dequeue_pending_xmitbuf(struct xmit_priv *pxmitpriv);
-struct xmit_buf	*dequeue_pending_xmitbuf_under_survey(struct xmit_priv *pxmitpriv);
-sint	check_pending_xmitbuf(struct xmit_priv *pxmitpriv);
-thread_return	rtw_xmit_thread(thread_context context);
-#endif
-
-u32	rtw_get_ff_hwaddr(struct xmit_frame	*pxmitframe);
-int dump_mgntframe(_adapter *padapter, struct xmit_frame *pmgntframe);
-
-extern s32 rtw_xmit_data(PADAPTER padapter, struct xmit_frame *pxmitframe);
-extern s32 rtw_xmit_xmitbuf(_adapter *padapter, struct xmit_buf *pxmitbuf);
-#ifdef CONFIG_IEEE80211W
-extern s32 rtw_mgmt_xmitframe_coalesce(_adapter *padapter, _pkt *pkt, struct xmit_frame *pxmitframe);
-#endif
-
-#ifdef TX_SHORTCUT
-void rtw_free_tx_sc_entrys(ADAPTER *Adapter, struct sta_info *pstat);
-int rtw_get_tx_sc_index(struct sta_info *pstat, unsigned char *hdr);
-int rtw_get_tx_sc_free_entry(struct sta_info *pstat, unsigned char *hdr);
-#endif
-
-extern unsigned int nr_xmitframe;
-extern unsigned int nr_xmitbuff;
-#endif	//_RTL871X_XMIT_H_
-
diff --git a/os/board/rtl8720e/src/component/wifi/driver/include/sta_info.h b/os/board/rtl8720e/src/component/wifi/driver/include/sta_info.h
deleted file mode 100644
index 13fe648f3..000000000
--- a/os/board/rtl8720e/src/component/wifi/driver/include/sta_info.h
+++ /dev/null
@@ -1,296 +0,0 @@
-/******************************************************************************
- *
- * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of version 2 of the GNU General Public License as
- * published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
- * more details.
- *
- * You should have received a copy of the GNU General Public License along with
- * this program; if not, write to the Free Software Foundation, Inc.,
- * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
- *
- *
- ******************************************************************************/
-#ifndef __STA_INFO_H_
-#define __STA_INFO_H_
-
-#define NUM_ACL 16
-
-//if mode ==0, then the sta is allowed once the addr is hit.
-//if mode ==1, then the sta is rejected once the addr is non-hit.
-struct rtw_wlan_acl_node {
-	_list		        list;
-	u8       addr[ETH_ALEN];
-	u8       valid;
-};
-
-//mode=0, disable
-//mode=1, accept unless in deny list
-//mode=2, deny unless in accept list
-struct wlan_acl_pool {
-	int mode;
-	int num;
-	struct rtw_wlan_acl_node aclnode[NUM_ACL];
-	_queue	acl_node_q;
-};
-
-typedef struct _RSSI_STA {
-	s32	UndecoratedSmoothedPWDB;
-	s32	UndecoratedSmoothedCCK;
-	s32	UndecoratedSmoothedOFDM;
-	u64	PacketMap;
-	u8	ValidBit;
-	u32	OFDM_pkt;
-} RSSI_STA, *PRSSI_STA;
-
-struct	stainfo_stats	{
-
-	u64 rx_mgnt_pkts;
-	u64 rx_ctrl_pkts;
-	u64 rx_data_pkts;
-	u64	rx_bytes;
-	u64	tx_bytes;
-
-	u64	last_rx_mgnt_pkts;
-	u64	last_rx_ctrl_pkts;
-	u64	last_rx_data_pkts;
-	u64	last_rx_bytes;
-	u64 last_tx_bytes;
-
-	u32 rx_tp_kbits;
-	u32 tx_tp_kbits;
-};
-
-#ifdef TX_SHORTCUT
-struct tx_sc_entry {
-	u8 shortcut_hdr[128];//tx_desc(32B) + wlanhdr + snap[6];
-	u32 sc_hdr_len;
-	u8 ethhdr[14];
-	struct pkt_attrib	attrib;
-	u32 fr_len;
-};
-#endif
-
-struct sta_info {
-
-	_lock	lock;
-	_list		list; //sta_list
-	//_list asoc_list; //20061114
-	//_list sleep_list;//sleep_q
-	//_list wakeup_list;//wakeup_q
-	_adapter *padapter;
-
-	struct sta_xmit_priv sta_xmitpriv;
-	struct sta_recv_priv sta_recvpriv;
-
-#if (PHYDM_VERSION == 3)
-	struct rtw_phl_stainfo_t *phl_sta;
-#else
-	struct cmn_sta_info cmn;
-#endif
-
-	WPA_STA_INFO		*wpa_sta_info;
-
-#ifdef CONFIG_TWT
-	u8 twt_id;	/*bit0 represent id0, .......bit7 represent id7*/
-#endif
-
-	_queue sleep_q;
-	unsigned int sleepq_len;
-
-	uint state;
-	//uint aid;
-	//uint mac_id;
-	uint qos_option;
-
-	uint	ieee8021x_blocked;	//0: allowed, 1:blocked
-	uint	dot118021XPrivacy; //aes, tkip...
-	union Keytype	dot11tkiptxmickey;
-	union Keytype	dot11tkiprxmickey;
-	union Keytype	dot118021x_UncstKey;
-	union pn48		dot11txpn;			// PN48 used for Unicast xmit.
-	union pn48		dot11rxpn;			// PN48 used for Unicast recv.
-#ifdef CONFIG_IEEE80211W
-	union pn48		dot11wtxpn;			/* PN48 used for Unicast mgmt xmit. */
-	_timer dot11w_expire_timer;
-#endif /* CONFIG_IEEE80211W */
-
-
-	u8	bssrateset[16];
-	u32	bssratelen;
-	s32	signal_quality;
-
-	u8	cts2self;
-	u8	rtsen;
-
-	u8	raid;	//ax useless
-	u8 	init_rate;
-	struct stainfo_stats sta_stats;
-
-	//for A-MPDU TX, ADDBA timeout check
-	_timer addba_retry_timer;
-	//for empty defrag queue
-	_timer defrag_queue_timer;
-	//for A-MPDU Rx reordering buffer control
-	struct recv_reorder_ctrl *recvreorder_ctrl[MAXTID];
-	//for A-MPDU Tx
-	//unsigned char		ampdu_txen_bitmap;
-	u16	BA_starting_seqctrl[MAXTID];
-
-
-	struct ht_priv	htpriv;
-
-#ifdef CONFIG_80211AC_VHT
-	struct vht_priv vhtpriv;
-#endif
-
-#ifdef CONFIG_80211AX_HE
-	struct he_priv hepriv;
-#endif
-
-	//Notes:
-	//STA_Mode:
-	//curr_network(mlme_priv/security_priv/qos/ht) + sta_info: (STA & AP) CAP/INFO
-	//scan_q: AP CAP/INFO
-
-	//AP_Mode:
-	//curr_network(mlme_priv/security_priv/qos/ht) : AP CAP/INFO
-	//sta_info: (AP & STA) CAP/INFO
-
-	u8 bpairwise_key_installed;
-
-	_list asoc_list;
-	_list auth_list;
-
-	unsigned int expire_to;
-#ifdef CONFIG_AP_POLLING_CLIENT_ALIVE
-	unsigned int tx_null0;
-	unsigned int tx_null0_fail;
-	unsigned int tx_null0_retry;
-#endif
-	unsigned int auth_seq;
-	unsigned int authalg;
-	unsigned char chg_txt[128];
-
-	u16 capability;
-	u32 flags;
-
-	int dot8021xalg;//0:disable, 1:psk, 2:802.1x
-	int wpa_psk;//0:disable, bit(0): WPA, bit(1):WPA2
-	int wpa_group_cipher;
-	int wpa2_group_cipher;
-	int wpa_pairwise_cipher;
-	int wpa2_pairwise_cipher;
-
-	u8 wpa_ie[32];
-
-	u8 nonerp_set;
-	u8 no_short_slot_time_set;
-	u8 no_short_preamble_set;
-	u8 no_ht_gf_set;
-	u8 no_ht_set;
-	u8 ht_20mhz_set;
-
-	unsigned int tx_ra_bitmap;
-	u8 qos_info;
-
-	u8 max_sp_len;
-	u8 uapsd_bk;//BIT(0): Delivery enabled, BIT(1): Trigger enabled
-	u8 uapsd_be;
-	u8 uapsd_vi;
-	u8 uapsd_vo;
-
-	u8 has_legacy_ac;
-	unsigned int sleepq_ac_len;
-
-#ifdef CONFIG_LPS_PG
-	u8		lps_pg_rssi_lv;
-#endif
-
-	//for DM
-	RSSI_STA	 rssi_stat;
-
-	//
-	// ================ODM Relative Info=======================
-	// Please be care, dont declare too much structure here. It will cost memory * STA support num.
-	//
-	//
-	// 2011/10/20 MH Add for ODM STA info.
-	//
-	// Driver Write
-	u8		bValid;				// record the sta status link or not?
-	//u8		WirelessMode;		//
-	u8		IOTPeer;			// Enum value.	HT_IOT_PEER_E
-	u8		rssi_level;			//for Refresh RA mask
-	// ODM Write
-	//1 PHY_STATUS_INFO
-	u8		RSSI_Path[4];		//
-	u8		RSSI_Ave;
-	u8		RXEVM[4];
-	u8		RXSNR[4];
-
-#ifdef TX_SHORTCUT
-	struct tx_sc_entry	tx_sc_ent[TX_SC_ENTRY_NUM];
-	int tx_sc_replace_idx;
-#endif
-#ifdef CONFIG_CSI
-	u32 rx_csi_cnt;
-#endif
-};
-
-#define sta_rx_pkts(sta) \
-	(sta->sta_stats.rx_mgnt_pkts \
-	+ sta->sta_stats.rx_ctrl_pkts \
-	+ sta->sta_stats.rx_data_pkts)
-
-#define sta_last_rx_pkts(sta) \
-	(sta->sta_stats.last_rx_mgnt_pkts \
-	+ sta->sta_stats.last_rx_ctrl_pkts \
-	+ sta->sta_stats.last_rx_data_pkts)
-
-#define sta_update_last_rx_pkts(sta) \
-	do { \
-		sta->sta_stats.last_rx_mgnt_pkts = sta->sta_stats.rx_mgnt_pkts; \
-		sta->sta_stats.last_rx_ctrl_pkts = sta->sta_stats.rx_ctrl_pkts; \
-		sta->sta_stats.last_rx_data_pkts = sta->sta_stats.rx_data_pkts; \
-	} while(0)
-
-#define STA_RX_PKTS_ARG(sta) \
-	sta->sta_stats.rx_mgnt_pkts \
-	, sta->sta_stats.rx_ctrl_pkts \
-	, sta->sta_stats.rx_data_pkts
-
-#define STA_LAST_RX_PKTS_ARG(sta) \
-	sta->sta_stats.last_rx_mgnt_pkts \
-	, sta->sta_stats.last_rx_ctrl_pkts \
-	, sta->sta_stats.last_rx_data_pkts
-
-#define STA_PKTS_FMT "(m:%llu, c:%llu, d:%llu)"
-
-struct	sta_priv {
-	_lock sta_list_lock;
-	_list   sta_list;
-	int asoc_sta_count;
-
-	_adapter *padapter;
-
-};
-
-extern struct sta_info *rtw_alloc_stainfo(struct	sta_priv *pstapriv, u8 *hwaddr);
-extern u32 rtw_free_stainfo_enqueue_cmd(_adapter *padapter, struct sta_info *psta);
-extern u32 rtw_free_stainfo(_adapter *padapter, struct sta_info *psta);
-extern void rtw_free_all_stainfo(_adapter *padapter);
-extern struct sta_info *rtw_get_stainfo(struct sta_priv *pstapriv, u8 *hwaddr);
-extern u32 rtw_init_bcmc_stainfo(_adapter *padapter);
-extern struct sta_info *rtw_get_bcmc_stainfo(_adapter *padapter);
-extern u8 rtw_access_ctrl(_adapter *padapter, u8 *mac_addr);
-extern struct recv_reorder_ctrl *rtw_alloc_reorder_ctrl(_adapter *padapter);
-extern void rtw_free_reorder_ctrl(_adapter *padapter, struct sta_info *psta, u8 tid);
-#endif //_STA_INFO_H_
-
diff --git a/os/board/rtl8720e/src/component/wifi/driver/include/wifi.h b/os/board/rtl8720e/src/component/wifi/driver/include/wifi.h
deleted file mode 100644
index a8d55f763..000000000
--- a/os/board/rtl8720e/src/component/wifi/driver/include/wifi.h
+++ /dev/null
@@ -1,1365 +0,0 @@
-/******************************************************************************
- *
- * Copyright(c) 2007 - 2012 Realtek Corporation. All rights reserved.
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of version 2 of the GNU General Public License as
- * published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
- * more details.
- *
- * You should have received a copy of the GNU General Public License along with
- * this program; if not, write to the Free Software Foundation, Inc.,
- * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
- *
- *
- ******************************************************************************/
-#ifndef _WIFI_H_
-#define _WIFI_H_
-
-#include <rtw_byteorder.h>
-#include <wlan_basic_types.h>
-
-
-#ifdef BIT
-//#error	"BIT define occurred earlier elsewhere!\n"
-#undef BIT
-#endif
-#define BIT(x)	(1U << (x))
-
-#ifdef CONFIG_CONCURRENT_MODE
-#define MACID_NUM_SW_LIMIT ((NUM_STA) + 2)
-#else
-#define MACID_NUM_SW_LIMIT NUM_STA
-#endif //CONFIG_CONCURRENT_MODE
-
-#define WLAN_ETHHDR_LEN		14
-#define WLAN_ETHADDR_LEN	6
-#define WLAN_IEEE_OUI_LEN	3
-#define WLAN_ADDR_LEN		6
-#define WLAN_CRC_LEN		4
-#define WLAN_BSSID_LEN		6
-#define WLAN_BSS_TS_LEN		8
-#define WLAN_HDR_A3_LEN		24
-#define WLAN_HDR_A4_LEN		30
-#define WLAN_HDR_A3_QOS_LEN	26
-#define WLAN_HDR_A4_QOS_LEN	32
-#define WLAN_HDR_A3_QOS_HTC_LEN	30
-#define WLAN_HDR_A4_QOS_HTC_LEN	36
-#define WLAN_SSID_MAXLEN	32
-#define WLAN_DATA_MAXLEN	2312
-
-#define WLAN_A3_PN_OFFSET	24
-#define WLAN_A4_PN_OFFSET	30
-
-#define WLAN_MIN_ETHFRM_LEN	60
-#if WIFI_LOGO_CERTIFICATION
-#define WLAN_MAX_ETHFRM_LEN	4000
-#else
-#if defined(CONFIG_ETH_LARGE_PKT)
-// customer requirement, send udp multicast frames around 1890 bytes without fragmentation
-#define WLAN_MAX_ETHFRM_LEN	1904
-#else
-#define WLAN_MAX_ETHFRM_LEN	1514
-#endif
-#endif
-#define WLAN_ETHHDR_LEN		14
-#define WLAN_SNAP_HEADER	8
-#define WLAN_MAX_IV_LEN		8
-#define WLAN_MAX_ICV_LEN	8
-#define WLAN_MAX_MIC_LEN	8
-
-#define WLAN_MAX_PROTOCOL_OVERHEAD (WLAN_HDR_A4_QOS_LEN+WLAN_MAX_IV_LEN\
-						+WLAN_SNAP_HEADER+WLAN_MAX_MIC_LEN+WLAN_MAX_ICV_LEN)	//=64
-
-#define P80211CAPTURE_VERSION	0x80211001
-
-// This value is tested by WiFi 11n Test Plan 5.2.3.
-// This test verifies the WLAN NIC can update the NAV through sending the CTS with large duration.
-#define	WiFiNavUpperUs				30000	// 30 ms
-// enum WLAN_IDX{
-// 	WLAN0_IDX = 0,
-// 	WLAN1_IDX,
-// 	WLAN_UNDEF = -1
-// };
-
-#ifdef GREEN_HILL
-#pragma pack(1)
-#endif
-
-enum WIFI_FRAME_TYPE {
-	WIFI_MGT_TYPE  =	(0),
-	WIFI_CTRL_TYPE =	(BIT(2)),
-	WIFI_DATA_TYPE =	(BIT(3)),
-	WIFI_QOS_DATA_TYPE	= (BIT(7) | BIT(3)),	//!< QoS Data
-
-};
-
-enum WIFI_FRAME_SUBTYPE {
-
-	// below is for mgt frame
-	WIFI_ASSOCREQ       = (0 | WIFI_MGT_TYPE),
-	WIFI_ASSOCRSP       = (BIT(4) | WIFI_MGT_TYPE),
-	WIFI_REASSOCREQ     = (BIT(5) | WIFI_MGT_TYPE),
-	WIFI_REASSOCRSP     = (BIT(5) | BIT(4) | WIFI_MGT_TYPE),
-	WIFI_PROBEREQ       = (BIT(6) | WIFI_MGT_TYPE),
-	WIFI_PROBERSP       = (BIT(6) | BIT(4) | WIFI_MGT_TYPE),
-	WIFI_BEACON         = (BIT(7) | WIFI_MGT_TYPE),
-	WIFI_ATIM           = (BIT(7) | BIT(4) | WIFI_MGT_TYPE),
-	WIFI_DISASSOC       = (BIT(7) | BIT(5) | WIFI_MGT_TYPE),
-	WIFI_AUTH           = (BIT(7) | BIT(5) | BIT(4) | WIFI_MGT_TYPE),
-	WIFI_DEAUTH         = (BIT(7) | BIT(6) | WIFI_MGT_TYPE),
-	WIFI_ACTION         = (BIT(7) | BIT(6) | BIT(4) | WIFI_MGT_TYPE),
-
-	// below is for control frame
-	WIFI_PSPOLL         = (BIT(7) | BIT(5) | WIFI_CTRL_TYPE),
-	WIFI_RTS            = (BIT(7) | BIT(5) | BIT(4) | WIFI_CTRL_TYPE),
-	WIFI_CTS            = (BIT(7) | BIT(6) | WIFI_CTRL_TYPE),
-	WIFI_ACK            = (BIT(7) | BIT(6) | BIT(4) | WIFI_CTRL_TYPE),
-	WIFI_CFEND          = (BIT(7) | BIT(6) | BIT(5) | WIFI_CTRL_TYPE),
-	WIFI_CFEND_CFACK    = (BIT(7) | BIT(6) | BIT(5) | BIT(4) | WIFI_CTRL_TYPE),
-	WIFI_TRIGGER        = (BIT(5) | WIFI_CTRL_TYPE),
-
-	// below is for data frame
-	WIFI_DATA           = (0 | WIFI_DATA_TYPE),
-	WIFI_DATA_CFACK     = (BIT(4) | WIFI_DATA_TYPE),
-	WIFI_DATA_CFPOLL    = (BIT(5) | WIFI_DATA_TYPE),
-	WIFI_DATA_CFACKPOLL = (BIT(5) | BIT(4) | WIFI_DATA_TYPE),
-	WIFI_DATA_NULL      = (BIT(6) | WIFI_DATA_TYPE),
-	WIFI_CF_ACK         = (BIT(6) | BIT(4) | WIFI_DATA_TYPE),
-	WIFI_CF_POLL        = (BIT(6) | BIT(5) | WIFI_DATA_TYPE),
-	WIFI_CF_ACKPOLL     = (BIT(6) | BIT(5) | BIT(4) | WIFI_DATA_TYPE),
-	WIFI_QOS_DATA_NULL	= (BIT(6) | WIFI_QOS_DATA_TYPE),
-
-};
-
-enum WIFI_REASON_CODE	{
-	_RSON_RESERVED_					= 0,
-	_RSON_UNSPECIFIED_				= 1,
-	_RSON_AUTH_NO_LONGER_VALID_		= 2,
-	_RSON_DEAUTH_STA_LEAVING_		= 3,
-	_RSON_INACTIVITY_				= 4,
-	_RSON_UNABLE_HANDLE_			= 5,
-	_RSON_CLS2_						= 6,
-	_RSON_CLS3_						= 7,
-	_RSON_DISAOC_STA_LEAVING_		= 8,
-	_RSON_ASOC_NOT_AUTH_			= 9,
-
-	// WPA reason
-	_RSON_INVALID_IE_				= 13,
-	_RSON_MIC_FAILURE_				= 14,
-	_RSON_4WAY_HNDSHK_TIMEOUT_		= 15,
-	_RSON_GROUP_KEY_UPDATE_TIMEOUT_	= 16,
-	_RSON_DIFF_IE_					= 17,
-	_RSON_MLTCST_CIPHER_NOT_VALID_	= 18,
-	_RSON_UNICST_CIPHER_NOT_VALID_	= 19,
-	_RSON_AKMP_NOT_VALID_			= 20,
-	_RSON_UNSUPPORT_RSNE_VER_		= 21,
-	_RSON_INVALID_RSNE_CAP_			= 22,
-	_RSON_IEEE_802DOT1X_AUTH_FAIL_	= 23,
-
-	//belowing are Realtek definition
-	_RSON_PMK_NOT_AVAILABLE_		= 24,
-	_RSON_TDLS_TEAR_TOOFAR_			= 25,
-	_RSON_TDLS_TEAR_UN_RSN_			= 26,
-};
-
-/* Reason codes (IEEE 802.11-2007, 7.3.1.7, Table 7-22) */
-#if 0
-#define WLAN_REASON_UNSPECIFIED 1
-#define WLAN_REASON_PREV_AUTH_NOT_VALID 2
-#define WLAN_REASON_DEAUTH_LEAVING 3
-#define WLAN_REASON_DISASSOC_DUE_TO_INACTIVITY 4
-#define WLAN_REASON_DISASSOC_AP_BUSY 5
-#define WLAN_REASON_CLASS2_FRAME_FROM_NONAUTH_STA 6
-#define WLAN_REASON_CLASS3_FRAME_FROM_NONASSOC_STA 7
-#define WLAN_REASON_DISASSOC_STA_HAS_LEFT 8
-#define WLAN_REASON_STA_REQ_ASSOC_WITHOUT_AUTH 9
-#endif
-/* IEEE 802.11h */
-#define WLAN_REASON_PWR_CAPABILITY_NOT_VALID 10
-#define WLAN_REASON_SUPPORTED_CHANNEL_NOT_VALID 11
-#if 0
-/* IEEE 802.11i */
-#define WLAN_REASON_INVALID_IE 13
-#define WLAN_REASON_MICHAEL_MIC_FAILURE 14
-#define WLAN_REASON_4WAY_HANDSHAKE_TIMEOUT 15
-#define WLAN_REASON_GROUP_KEY_UPDATE_TIMEOUT 16
-#define WLAN_REASON_IE_IN_4WAY_DIFFERS 17
-#define WLAN_REASON_GROUP_CIPHER_NOT_VALID 18
-#define WLAN_REASON_PAIRWISE_CIPHER_NOT_VALID 19
-#define WLAN_REASON_AKMP_NOT_VALID 20
-#define WLAN_REASON_UNSUPPORTED_RSN_IE_VERSION 21
-#define WLAN_REASON_INVALID_RSN_IE_CAPAB 22
-#define WLAN_REASON_IEEE_802_1X_AUTH_FAILED 23
-#define WLAN_REASON_CIPHER_SUITE_REJECTED 24
-#endif
-
-enum WIFI_STATUS_CODE {
-	_STATS_SUCCESSFUL_			= 0,
-	_STATS_FAILURE_				= 1,
-	_STATS_CAP_FAIL_			= 10,
-	_STATS_NO_ASOC_				= 11,
-	_STATS_OTHER_				= 12,
-	_STATS_NO_SUPP_ALG_			= 13,
-	_STATS_OUT_OF_AUTH_SEQ_		= 14,
-	_STATS_CHALLENGE_FAIL_		= 15,
-	_STATS_AUTH_TIMEOUT_		= 16,
-	_STATS_UNABLE_HANDLE_STA_	= 17,
-	_STATS_RATE_FAIL_			= 18,
-	_STATS_REFUSED_TEMPORARILY_ = 30,
-	_STATS_SAE_HASH_TO_ELEMENT_ = 126,
-};
-
-/* Status codes (IEEE 802.11-2007, 7.3.1.9, Table 7-23) */
-#if 0
-#define WLAN_STATUS_SUCCESS 0
-#define WLAN_STATUS_UNSPECIFIED_FAILURE 1
-#define WLAN_STATUS_CAPS_UNSUPPORTED 10
-#define WLAN_STATUS_REASSOC_NO_ASSOC 11
-#define WLAN_STATUS_ASSOC_DENIED_UNSPEC 12
-#define WLAN_STATUS_NOT_SUPPORTED_AUTH_ALG 13
-#define WLAN_STATUS_UNKNOWN_AUTH_TRANSACTION 14
-#define WLAN_STATUS_CHALLENGE_FAIL 15
-#define WLAN_STATUS_AUTH_TIMEOUT 16
-#define WLAN_STATUS_AP_UNABLE_TO_HANDLE_NEW_STA 17
-#define WLAN_STATUS_ASSOC_DENIED_RATES 18
-#endif
-//entended
-/* IEEE 802.11b */
-#define WLAN_STATUS_ASSOC_DENIED_NOSHORT 19
-#define WLAN_STATUS_ASSOC_DENIED_NOPBCC 20
-#define WLAN_STATUS_ASSOC_DENIED_NOAGILITY 21
-/* IEEE 802.11h */
-#define WLAN_STATUS_SPEC_MGMT_REQUIRED 22
-#define WLAN_STATUS_PWR_CAPABILITY_NOT_VALID 23
-#define WLAN_STATUS_SUPPORTED_CHANNEL_NOT_VALID 24
-/* IEEE 802.11g */
-#define WLAN_STATUS_ASSOC_DENIED_NO_SHORT_SLOT_TIME 25
-#define WLAN_STATUS_ASSOC_DENIED_NO_ER_PBCC 26
-#define WLAN_STATUS_ASSOC_DENIED_NO_DSSS_OFDM 27
-/* IEEE 802.11w */
-#define WLAN_STATUS_ASSOC_REJECTED_TEMPORARILY 30
-#define WLAN_STATUS_ROBUST_MGMT_FRAME_POLICY_VIOLATION 31
-/* IEEE 802.11i */
-#define WLAN_STATUS_INVALID_IE 40
-#define WLAN_STATUS_GROUP_CIPHER_NOT_VALID 41
-#define WLAN_STATUS_PAIRWISE_CIPHER_NOT_VALID 42
-#define WLAN_STATUS_AKMP_NOT_VALID 43
-#define WLAN_STATUS_UNSUPPORTED_RSN_IE_VERSION 44
-#define WLAN_STATUS_INVALID_RSN_IE_CAPAB 45
-#define WLAN_STATUS_CIPHER_REJECTED_PER_POLICY 46
-#define WLAN_STATUS_TS_NOT_CREATED 47
-#define WLAN_STATUS_DIRECT_LINK_NOT_ALLOWED 48
-#define WLAN_STATUS_DEST_STA_NOT_PRESENT 49
-#define WLAN_STATUS_DEST_STA_NOT_QOS_STA 50
-#define WLAN_STATUS_ASSOC_DENIED_LISTEN_INT_TOO_LARGE 51
-/* IEEE 802.11r */
-#define WLAN_STATUS_INVALID_FT_ACTION_FRAME_COUNT 52
-#define WLAN_STATUS_INVALID_PMKID 53
-#define WLAN_STATUS_INVALID_MDIE 54
-#define WLAN_STATUS_INVALID_FTIE 55
-
-#define WLAN_STATUS_SAE_HASH_TO_ELEMENT 126
-
-enum WIFI_REG_DOMAIN {
-	DOMAIN_FCC		= 1,
-	DOMAIN_IC		= 2,
-	DOMAIN_ETSI		= 3,
-	DOMAIN_SPAIN	= 4,
-	DOMAIN_FRANCE	= 5,
-	DOMAIN_MKK		= 6,
-	DOMAIN_ISRAEL	= 7,
-	DOMAIN_MKK1		= 8,
-	DOMAIN_MKK2		= 9,
-	DOMAIN_MKK3		= 10,
-	DOMAIN_MAX
-};
-
-#define _TO_DS_		BIT(8)
-#define _FROM_DS_	BIT(9)
-#define _MORE_FRAG_	BIT(10)
-#define _RETRY_		BIT(11)
-#define _PWRMGT_	BIT(12)
-#define _MORE_DATA_	BIT(13)
-#define _PRIVACY_	BIT(14)
-#define _ORDER_			BIT(15)
-
-#define SetToDs(pbuf)	\
-	do	{	\
-		*(unsigned short *)(void*)(pbuf) |= cpu_to_le16(_TO_DS_); \
-	} while(0)
-
-#define GetToDs(pbuf)	(((*(unsigned short *)(void*)(pbuf)) & le16_to_cpu(_TO_DS_)) != 0)
-
-#define ClearToDs(pbuf)	\
-	do	{	\
-		*(unsigned short *)(void*)(pbuf) &= (~cpu_to_le16(_TO_DS_)); \
-	} while(0)
-
-#define SetFrDs(pbuf)	\
-	do	{	\
-		*(unsigned short *)(void*)(pbuf) |= cpu_to_le16(_FROM_DS_); \
-	} while(0)
-
-#define GetFrDs(pbuf)	(((*(unsigned short *)(void*)(pbuf)) & le16_to_cpu(_FROM_DS_)) != 0)
-
-#define ClearFrDs(pbuf)	\
-	do	{	\
-		*(unsigned short *)(void*)(pbuf) &= (~cpu_to_le16(_FROM_DS_)); \
-	} while(0)
-
-#define get_tofr_ds(pframe)	((GetToDs(pframe) << 1) | GetFrDs(pframe))
-
-
-#define SetMFrag(pbuf)	\
-	do	{	\
-		*(unsigned short *)(void*)(pbuf) |= cpu_to_le16(_MORE_FRAG_); \
-	} while(0)
-
-#define GetMFrag(pbuf)	(((*(unsigned short *)(void*)(pbuf)) & le16_to_cpu(_MORE_FRAG_)) != 0)
-
-#define ClearMFrag(pbuf)	\
-	do	{	\
-		*(unsigned short *)(void*)(pbuf) &= (~cpu_to_le16(_MORE_FRAG_)); \
-	} while(0)
-
-#define SetRetry(pbuf)	\
-	do	{	\
-		*(unsigned short *)(void*)(pbuf) |= cpu_to_le16(_RETRY_); \
-	} while(0)
-
-#define GetRetry(pbuf)	(((*(unsigned short *)(void*)(pbuf)) & le16_to_cpu(_RETRY_)) != 0)
-
-#define ClearRetry(pbuf)	\
-	do	{	\
-		*(unsigned short *)(void*)(pbuf) &= (~cpu_to_le16(_RETRY_)); \
-	} while(0)
-
-#define SetPwrMgt(pbuf)	\
-	do	{	\
-		*(unsigned short *)(void*)(pbuf) |= cpu_to_le16(_PWRMGT_); \
-	} while(0)
-
-#define GetPwrMgt(pbuf)	(((*(unsigned short *)(void*)(pbuf)) & le16_to_cpu(_PWRMGT_)) != 0)
-
-#define ClearPwrMgt(pbuf)	\
-	do	{	\
-		*(unsigned short *)(void*)(pbuf) &= (~cpu_to_le16(_PWRMGT_)); \
-	} while(0)
-
-#define SetMData(pbuf)	\
-	do	{	\
-		*(unsigned short *)(void*)(pbuf) |= cpu_to_le16(_MORE_DATA_); \
-	} while(0)
-
-#define GetMData(pbuf)	(((*(unsigned short *)(void*)(pbuf)) & le16_to_cpu(_MORE_DATA_)) != 0)
-
-#define ClearMData(pbuf)	\
-	do	{	\
-		*(unsigned short *)(void*)(pbuf) &= (~cpu_to_le16(_MORE_DATA_)); \
-	} while(0)
-
-#define SetPrivacy(pbuf)	\
-	do	{	\
-		*(unsigned short *)(void*)(pbuf) |= cpu_to_le16(_PRIVACY_); \
-	} while(0)
-
-#define GetPrivacy(pbuf)	(((*(unsigned short *)(void*)(pbuf)) & le16_to_cpu(_PRIVACY_)) != 0)
-
-#define ClearPrivacy(pbuf)	\
-	do	{	\
-		*(unsigned short *)(void*)(pbuf) &= (~cpu_to_le16(_PRIVACY_)); \
-	} while(0)
-
-#define SetOrder(pbuf)	\
-	do	{	\
-		*(unsigned short *)(void*)(pbuf) |= cpu_to_le16(_ORDER_); \
-	} while (0)
-
-#define ClearOrder(pbuf)	\
-	do	{	\
-		*(unsigned short *)(void*)(pbuf) &= (~cpu_to_le16(_ORDER_)); \
-	} while(0)
-
-#define GetOrder(pbuf)	(((*(unsigned short *)(void*)(pbuf)) & le16_to_cpu(_ORDER_)) != 0)
-
-#define GetFrameType(pbuf)	(le16_to_cpu(*(unsigned short *)(void*)(pbuf)) & (BIT(3) | BIT(2)))
-
-#define get_frame_sub_type(pbuf)	(cpu_to_le16(*(unsigned short *)(void*)(pbuf)) & (BIT(7) | BIT(6) | BIT(5) | BIT(4) | BIT(3) | BIT(2)))
-
-
-#define set_frame_sub_type(pbuf, type) \
-	do {    \
-		*(unsigned short *)(void*)(pbuf) &= cpu_to_le16(~(BIT(7) | BIT(6) | BIT(5) | BIT(4) | BIT(3) | BIT(2))); \
-		*(unsigned short *)(void*)(pbuf) |= cpu_to_le16(type); \
-	} while (0)
-
-#define SetFrameType(pbuf,type)	\
-	do { 	\
-		*(unsigned short *)(void*)(pbuf) &= cpu_to_le16(~(BIT(3) | BIT(2))); \
-		*(unsigned short *)(void*)(pbuf) |= cpu_to_le16(type); \
-	} while(0)
-
-#define GetFrameSubType(pbuf)	(cpu_to_le16(*(unsigned short *)(void*)(pbuf)) & (BIT(7) | BIT(6) | BIT(5) | BIT(4) | BIT(3) | BIT(2)))
-
-#define SetFrameSubType(pbuf,type) \
-	do {    \
-		*(unsigned short *)(void*)(pbuf) &= cpu_to_le16(~(BIT(7) | BIT(6) | BIT(5) | BIT(4) | BIT(3) | BIT(2))); \
-		*(unsigned short *)(void*)(pbuf) |= cpu_to_le16(type); \
-	} while(0)
-
-#define GetSequence(pbuf)	(cpu_to_le16(*(unsigned short *)(void*)((SIZE_PTR)(pbuf) + 22)) >> 4)
-
-#define GetFragNum(pbuf)	(cpu_to_le16(*(unsigned short *)(void*)((SIZE_PTR)(pbuf) + 22)) & 0x0f)
-
-#define GetTupleCache(pbuf)	(cpu_to_le16(*(unsigned short *)(void*)((SIZE_PTR)(pbuf) + 22)))
-
-#define SetFragNum(pbuf, num) \
-	do {    \
-		*(unsigned short *)(void*)((SIZE_PTR)(pbuf) + 22) = \
-			((*(unsigned short *)(void*)((SIZE_PTR)(pbuf) + 22)) & le16_to_cpu(~(0x000f))) | \
-			cpu_to_le16(0x0f & (num));     \
-	} while(0)
-
-#define SetSeqNum(pbuf, num) \
-	do {    \
-		*(unsigned short *)(void*)((SIZE_PTR)(pbuf) + 22) = \
-			((*(unsigned short *)(void*)((SIZE_PTR)(pbuf) + 22)) & le16_to_cpu((unsigned short)~0xfff0)) | \
-			le16_to_cpu((unsigned short)(0xfff0 & (num << 4))); \
-	} while(0)
-#define GetFrameControl(pbuf)(cpu_to_le16(*(unsigned short*)(void*)((SIZE_PTR)(pbuf))))
-#define GetDuration(pbuf) (cpu_to_le16(*(unsigned short*)(void*)((SIZE_PTR)(pbuf) + 2)))
-#define SetDuration(pbuf, dur) \
-	do {    \
-		*(unsigned short *)(void*)((SIZE_PTR)(pbuf) + 2) = cpu_to_le16(0xffff & (dur)); \
-	} while(0)
-
-
-#define SetPriority(pbuf, tid)	\
-	do	{	\
-		*(unsigned short *)(void*)(pbuf) |= cpu_to_le16(tid & 0xf); \
-	} while(0)
-
-#define GetPriority(pbuf)	((le16_to_cpu(*(unsigned short *)(void*)(pbuf))) & 0xf)
-
-#define SetEOSP(pbuf, eosp)	\
-	do	{	\
-		*(unsigned short *)(void*)(pbuf) |= cpu_to_le16( (eosp & 1) << 4); \
-	} while(0)
-
-#define SetAckpolicy(pbuf, ack)	\
-	do	{	\
-		*(unsigned short *)(void*)(pbuf) |= cpu_to_le16( (ack & 3) << 5); \
-	} while(0)
-
-#define GetAckpolicy(pbuf) (((le16_to_cpu(*(unsigned short *)(void*)pbuf)) >> 5) & 0x3)
-
-#define GetAMsdu(pbuf) (((le16_to_cpu(*(unsigned short *)(void*)pbuf)) >> 7) & 0x1)
-
-#define SetAMsdu(pbuf, amsdu)	\
-	do	{	\
-		*(unsigned short *)(void*)(pbuf) |= cpu_to_le16( (amsdu & 1) << 7); \
-	} while(0)
-
-#define GetAid(pbuf)	(cpu_to_le16(*(unsigned short *)(void*)((SIZE_PTR)(pbuf) + 2)) & 0x3fff)
-
-#define GetTid(pbuf)	(cpu_to_le16(*(unsigned short *)(void*)((SIZE_PTR)(pbuf) + (((GetToDs(pbuf)<<1)|GetFrDs(pbuf))==3?30:24))) & 0x000f)
-
-#define GetAddr1Ptr(pbuf)	((unsigned char *)((SIZE_PTR)(pbuf) + 4))
-
-#define GetAddr2Ptr(pbuf)	((unsigned char *)((SIZE_PTR)(pbuf) + 10))
-
-#define GetAddr3Ptr(pbuf)	((unsigned char *)((SIZE_PTR)(pbuf) + 16))
-
-#define GetAddr4Ptr(pbuf)	((unsigned char *)((SIZE_PTR)(pbuf) + 24))
-
-//WIFI_WMM
-#define GetQosControl(pbuf) (unsigned char *)((SIZE_PTR)(pbuf) + (((GetToDs(pbuf)<<1)|GetFrDs(pbuf))==3?30:24))
-
-#define MacAddr_isBcst(addr) \
-( \
-	( (addr[0] == 0xff) && (addr[1] == 0xff) && \
-		(addr[2] == 0xff) && (addr[3] == 0xff) && \
-		(addr[4] == 0xff) && (addr[5] == 0xff) )  ? _TRUE : _FALSE \
-)
-
-__inline static int IS_MCAST(unsigned char *da)
-{
-	if ((*da) & 0x01) {
-		return _TRUE;
-	} else {
-		return _FALSE;
-	}
-}
-
-__inline static unsigned char *get_ta(unsigned char *pframe)
-{
-	unsigned char 	*ta;
-	ta = GetAddr2Ptr(pframe);
-	return ta;
-}
-
-__inline static unsigned char *get_da(unsigned char *pframe)
-{
-	unsigned char 	*da;
-	unsigned int	to_fr_ds	= (GetToDs(pframe) << 1) | GetFrDs(pframe);
-
-	switch (to_fr_ds) {
-	case 0x00:	// ToDs=0, FromDs=0
-		da = GetAddr1Ptr(pframe);
-		break;
-	case 0x01:	// ToDs=0, FromDs=1
-		da = GetAddr1Ptr(pframe);
-		break;
-	case 0x02:	// ToDs=1, FromDs=0
-		da = GetAddr3Ptr(pframe);
-		break;
-	default:	// ToDs=1, FromDs=1
-		da = GetAddr3Ptr(pframe);
-		break;
-	}
-
-	return da;
-}
-
-
-__inline static unsigned char *get_sa(unsigned char *pframe)
-{
-	unsigned char 	*sa;
-	unsigned int	to_fr_ds	= (GetToDs(pframe) << 1) | GetFrDs(pframe);
-
-	switch (to_fr_ds) {
-	case 0x00:	// ToDs=0, FromDs=0
-		sa = GetAddr2Ptr(pframe);
-		break;
-	case 0x01:	// ToDs=0, FromDs=1
-		sa = GetAddr3Ptr(pframe);
-		break;
-	case 0x02:	// ToDs=1, FromDs=0
-		sa = GetAddr2Ptr(pframe);
-		break;
-	default:	// ToDs=1, FromDs=1
-		sa = GetAddr4Ptr(pframe);
-		break;
-	}
-
-	return sa;
-}
-
-__inline static unsigned char *get_hdr_bssid(unsigned char *pframe)
-{
-	unsigned char 	*sa;
-	unsigned int	to_fr_ds	= (GetToDs(pframe) << 1) | GetFrDs(pframe);
-
-	switch (to_fr_ds) {
-	case 0x00:	// ToDs=0, FromDs=0
-		sa = GetAddr3Ptr(pframe);
-		break;
-	case 0x01:	// ToDs=0, FromDs=1
-		sa = GetAddr2Ptr(pframe);
-		break;
-	case 0x02:	// ToDs=1, FromDs=0
-		sa = GetAddr1Ptr(pframe);
-		break;
-	case 0x03:	// ToDs=1, FromDs=1
-		sa = GetAddr1Ptr(pframe);
-		break;
-	default:
-		sa = NULL; //???????
-		break;
-	}
-
-	return sa;
-}
-
-
-__inline static int IsFrameTypeCtrl(unsigned char *pframe)
-{
-	if (WIFI_CTRL_TYPE == GetFrameType(pframe)) {
-		return _TRUE;
-	} else {
-		return _FALSE;
-	}
-}
-/*-----------------------------------------------------------------------------
-			Below is for the security related definition
-------------------------------------------------------------------------------*/
-#define _RESERVED_FRAME_TYPE_	0
-#define _SKB_FRAME_TYPE_		2
-#define _PRE_ALLOCMEM_			1
-#define _PRE_ALLOCHDR_			3
-#define _PRE_ALLOCLLCHDR_		4
-#define _PRE_ALLOCICVHDR_		5
-#define _PRE_ALLOCMICHDR_		6
-
-#define _SIFSTIME_				((priv->pmib->dot11BssType.net_work_type&WLAN_MD_11A)?16:10)
-#define _ACKCTSLNG_				14	//14 bytes long, including crclng
-#define _CRCLNG_				4
-
-#define _ASOCREQ_IE_OFFSET_		4	// excluding wlan_hdr
-#define	_ASOCRSP_IE_OFFSET_		6
-#define _REASOCREQ_IE_OFFSET_	10
-#define _REASOCRSP_IE_OFFSET_	6
-#define _PROBEREQ_IE_OFFSET_	0
-#define	_PROBERSP_IE_OFFSET_	12
-#define _AUTH_IE_OFFSET_		6
-#define _DEAUTH_IE_OFFSET_		0
-#define _BEACON_IE_OFFSET_		12
-#define _PUBLIC_ACTION_IE_OFFSET_	8
-
-#define _FIXED_IE_LENGTH_			_BEACON_IE_OFFSET_
-
-#define _SSID_IE_				0
-#define _SUPPORTEDRATES_IE_	1
-#define _DSSET_IE_				3
-#define _TIM_IE_					5
-#define _IBSS_PARA_IE_			6
-#define _COUNTRY_IE_			7
-#define _CHLGETXT_IE_			16
-#define _SUPPORTED_CH_IE_		36
-#define _CH_SWTICH_ANNOUNCE_	37	//Secondary Channel Offset
-#define	_MEAS_REQ_IE_		38
-#define	_MEAS_RSP_IE_		39
-#define _RSN_IE_2_				48
-#define _SSN_IE_1_					221
-#define _ERPINFO_IE_			42
-#define _EXT_SUPPORTEDRATES_IE_	50
-
-#define _HT_CAPABILITY_IE_			45
-#define _MDIE_					54
-#define _FTIE_						55
-#define _TIMEOUT_ITVL_IE_			56
-#define _SRC_IE_				59
-#define _HT_EXTRA_INFO_IE_			61
-#define _HT_ADD_INFO_IE_			61 //_HT_EXTRA_INFO_IE_
-#define _WAPI_IE_					68
-#define _EID_RRM_EN_CAP_IE_			70
-
-#define _RIC_Descriptor_IE_			75
-#ifdef CONFIG_IEEE80211W
-#define _MME_IE_					76 /* 802.11w Management MIC element */
-#endif /* CONFIG_IEEE80211W */
-
-#define _LINK_ID_IE_					101
-#define _CH_SWITCH_TIMING_		104
-#define _PTI_BUFFER_STATUS_		106
-#define _EXT_CAP_IE_				127
-#define _VENDOR_SPECIFIC_IE_		221
-#define _RSNXE_IE_					244
-
-#define	_RESERVED47_				47
-
-typedef	enum _ELEMENT_ID {
-	EID_SsId					= 0, /* service set identifier (0:32) */
-	EID_SupRates				= 1, /* supported rates (1:8) */
-	EID_FHParms				= 2, /* FH parameter set (5) */
-	EID_DSParms				= 3, /* DS parameter set (1) */
-	EID_CFParms				= 4, /* CF parameter set (6) */
-	EID_Tim						= 5, /* Traffic Information Map (4:254) */
-	EID_IbssParms				= 6, /* IBSS parameter set (2) */
-	EID_Country					= 7, /* */
-
-	/* Form 7.3.2: Information elements in 802.11E/D13.0, page 46. */
-	EID_QBSSLoad				= 11,
-	EID_EDCAParms				= 12,
-	EID_TSpec					= 13,
-	EID_TClass					= 14,
-	EID_Schedule				= 15,
-	/*  */
-
-	EID_Ctext					= 16, /* challenge text*/
-	EID_POWER_CONSTRAINT		= 32, /* Power Constraint*/
-
-	/* vivi for WIFITest, 802.11h AP, 20100427 */
-	/* 2010/12/26 MH The definition we can declare always!! */
-	EID_PowerCap				= 33,
-	EID_TPC				= 35,
-	EID_SupportedChannels		= 36,
-	EID_ChlSwitchAnnounce		= 37,
-
-	EID_MeasureRequest			= 38, /* Measurement Request */
-	EID_MeasureReport			= 39, /* Measurement Report */
-
-	EID_ERPInfo				= 42,
-
-	/* Form 7.3.2: Information elements in 802.11E/D13.0, page 46. */
-	EID_TSDelay				= 43,
-	EID_TCLASProc				= 44,
-	EID_HTCapability			= 45,
-	EID_QoSCap					= 46,
-	/*  */
-
-	EID_WPA2					= 48,
-	EID_ExtSupRates			= 50,
-
-	EID_FTIE					= 55, /* Defined in 802.11r */
-	EID_Timeout				= 56, /* Defined in 802.11r */
-
-	EID_SupRegulatory			= 59, /* Supported Requlatory Classes 802.11y */
-	EID_HTInfo					= 61,
-	EID_SecondaryChnlOffset		= 62,
-
-	EID_BSSCoexistence			= 72, /* 20/40 BSS Coexistence */
-	EID_BSSIntolerantChlReport	= 73,
-	EID_OBSS					= 74, /* Overlapping BSS Scan Parameters */
-
-	EID_LinkIdentifier			= 101, /* Defined in 802.11z */
-	EID_WakeupSchedule		= 102, /* Defined in 802.11z */
-	EID_ChnlSwitchTimeing		= 104, /* Defined in 802.11z */
-	EID_PTIControl				= 105, /* Defined in 802.11z */
-	EID_PUBufferStatus			= 106, /* Defined in 802.11z */
-
-	EID_EXTCapability			= 127, /* Extended Capabilities */
-	/* From S19:Aironet IE and S21:AP IP address IE in CCX v1.13, p16 and p18. */
-	EID_Aironet					= 133, /* 0x85: Aironet Element for Cisco CCX */
-	EID_CiscoIP					= 149, /* 0x95: IP Address IE for Cisco CCX */
-
-	EID_CellPwr					= 150, /* 0x96: Cell Power Limit IE. Ref. 0x96. */
-
-	EID_CCKM					= 156,
-
-	EID_Vendor					= 221, /* 0xDD: Vendor Specific */
-
-	EID_WAPI					= 68,
-	EID_VHTCapability 			= 191, /* Based on 802.11ac D2.0 */
-	EID_VHTOperation 			= 192, /* Based on 802.11ac D2.0 */
-	EID_AID						= 197, /* Based on 802.11ac D4.0 */
-	EID_OpModeNotification		= 199, /* Based on 802.11ac D3.0 */
-} ELEMENT_ID, *PELEMENT_ID;
-
-
-/*-----------------------------------------------------------------------------
-            Below is for mesh related definition
-------------------------------------------------------------------------------*/
-
-/*used in Multihop category */
-#define _PROXY_UPDATES_ACTION_ID_         0
-#define _PROXY_UPDATES_CONFIRM_ACTION_ID_ 1
-
-#define _SECONDARY_CHANNEL_OFFSET_IE_					62
-#define _WLAN_MESH_CAP_IE_			   113	// WLAN mesh configuration IE
-#define _MESH_ID_IE_				   114	// MESH ID infoemation element
-#define _MESH_LINK_METRIC_REPORT_IE_   115	// Local link state announcement IE
-#define _MESH_PEER_MGMT_IE_            117	// MESH peering managment IE
-#define _MESH_CHANNEL_SWITCH_IE_       118
-#define _MESH_AWAKE_WINDOW_IE_    119 //MESH awake window
-#define _MESH_GANN_IE_	               125
-#define _MESH_RANN_IE_	               126
-#define _MESH_PREQ_IE_	               130
-#define _MESH_PREP_IE_	               131
-#define _MESH_PERR_IE_	               132
-#define _PROXY_UPDATE_IE_			   137
-#define _PROXY_UPDATE_CONFIRM_IE_	   138
-#define _MESH_AMPE_IE_					139
-#define _MESH_MIC_IE_					140
-
-// CATUTION: below ALL undefine !!
-#define _OFDM_PARAMETER_SET_IE_		   200
-#define _NEIGHBOR_LIST_IE_			   205	// neighbor list IE
-#define _UCG_SWITCH_ANNOU_IE_		   210
-#define _MDAOP_ADVERTISMENTS_IE_	   211
-#define _MOAOP_SET_TEARDOWN_IE_		   212
-#define _PEER_LINK_OPEN_IE_			   223
-#define _PEER_LINK_CONFIRM_IE_		   224
-#define _PEER_LINK_CLOSE_IE_		   225
-
-/* ---------------------------------------------------------------------------
-					Below is the fixed elements...
------------------------------------------------------------------------------*/
-#define _AUTH_ALGM_NUM_			2
-#define _AUTH_SEQ_NUM_			2
-#define _BEACON_ITERVAL_		2
-#define _CAPABILITY_			2
-#define _CURRENT_APADDR_		6
-#define _LISTEN_INTERVAL_		2
-#define _RSON_CODE_				2
-#define _ASOC_ID_				2
-#define _STATUS_CODE_			2
-#define _TIMESTAMP_				8
-
-#define AUTH_ODD_TO				0
-#define AUTH_EVEN_TO			1
-
-#define WLAN_ETHCONV_ENCAP		1
-#define WLAN_ETHCONV_RFC1042	2
-#define WLAN_ETHCONV_8021h		3
-
-#define cap_ESS BIT(0)
-#define cap_IBSS BIT(1)
-#define cap_CFPollable BIT(2)
-#define cap_CFRequest BIT(3)
-#define cap_Privacy BIT(4)
-#define cap_ShortPremble BIT(5)
-#define cap_PBCC	BIT(6)
-#define cap_ChAgility	BIT(7)
-#define cap_SpecMgmt	BIT(8)
-#define cap_QoS	BIT(9)
-#define cap_ShortSlot	BIT(10)
-
-/*-----------------------------------------------------------------------------
-				Below is the definition for 802.11i / 802.1x
-------------------------------------------------------------------------------*/
-#define _IEEE8021X_MGT_			1		// WPA
-#define _IEEE8021X_PSK_			2		// WPA with pre-shared key
-
-/*
-#define _NO_PRIVACY_			0
-#define _WEP_40_PRIVACY_		1
-#define _TKIP_PRIVACY_			2
-#define _WRAP_PRIVACY_			3
-#define _CCMP_PRIVACY_			4
-#define _WEP_104_PRIVACY_		5
-#define _WEP_WPA_MIXED_PRIVACY_ 6	// WEP + WPA
-*/
-
-#ifdef CONFIG_IEEE80211W
-#define _MME_IE_LENGTH_  18
-#endif /* CONFIG_IEEE80211W */
-
-/*-----------------------------------------------------------------------------
-				Below is the definition for WMM
-------------------------------------------------------------------------------*/
-#define _WMM_IE_Length_				7  // for WMM STA
-#define _WMM_Para_Element_Length_		24
-
-
-/**
-* struct rtw_ieee80211_ht_cap - HT capabilities
-*
-* This structure refers to "HT capabilities element" as
-* described in 802.11n draft section 7.3.2.52
-*/
-
-#ifdef RTW_PACK_STRUCT_USE_INCLUDES
-#  include "pack_begin.h"
-#endif
-RTW_PACK_STRUCT_BEGIN
-struct rtw_ieee80211_ht_cap {
-	unsigned short 	cap_info;
-	unsigned char 	ampdu_params_info;
-	unsigned char 	supp_mcs_set[16];
-	unsigned short 	extended_ht_cap_info;
-	unsigned int		tx_BF_cap_info;
-	unsigned char	       antenna_selection_info;
-} RTW_PACK_STRUCT_STRUCT;
-#ifdef RTW_PACK_STRUCT_USE_INCLUDES
-#  include "pack_end.h"
-#endif
-
-
-/**
- * struct rtw_ieee80211_ht_cap - HT additional information
- *
- * This structure refers to "HT information element" as
- * described in 802.11n draft section 7.3.2.53
- */
-#ifdef RTW_PACK_STRUCT_USE_INCLUDES
-#  include "pack_begin.h"
-#endif
-RTW_PACK_STRUCT_BEGIN
-struct ieee80211_ht_addt_info {
-	unsigned char 	control_chan;
-	unsigned char		ht_param;
-	unsigned short	operation_mode;
-	unsigned short	stbc_param;
-	unsigned char		basic_set[16];
-} RTW_PACK_STRUCT_STRUCT;
-RTW_PACK_STRUCT_END
-#ifdef RTW_PACK_STRUCT_USE_INCLUDES
-#  include "pack_end.h"
-#endif
-
-#ifdef RTW_PACK_STRUCT_USE_INCLUDES
-#  include "pack_begin.h"
-#endif
-RTW_PACK_STRUCT_BEGIN
-struct HT_caps_element {
-	union {
-		struct {
-			unsigned short	HT_caps_info;
-			unsigned char	AMPDU_para;
-			unsigned char	MCS_rate[16];
-			unsigned short	HT_ext_caps;
-			unsigned int	Beamforming_caps;
-			unsigned char	ASEL_caps;
-		}
-#ifdef __CC_ARM
-		__attribute__((packed))
-#endif
-		HT_cap_element;
-		unsigned char HT_cap[26];
-	}
-#ifdef __CC_ARM
-	__attribute__((packed))
-#endif
-	u;
-} RTW_PACK_STRUCT_STRUCT;
-RTW_PACK_STRUCT_END
-#ifdef RTW_PACK_STRUCT_USE_INCLUDES
-#  include "pack_end.h"
-#endif
-
-#ifdef RTW_PACK_STRUCT_USE_INCLUDES
-#  include "pack_begin.h"
-#endif
-RTW_PACK_STRUCT_BEGIN
-struct HT_info_element {
-	unsigned char	primary_channel;
-	unsigned char	infos[5];
-	unsigned char	MCS_rate[16];
-} RTW_PACK_STRUCT_STRUCT;
-RTW_PACK_STRUCT_END
-#ifdef RTW_PACK_STRUCT_USE_INCLUDES
-#  include "pack_end.h"
-#endif
-
-
-#ifdef RTW_PACK_STRUCT_USE_INCLUDES
-#  include "pack_begin.h"
-#endif
-RTW_PACK_STRUCT_BEGIN
-struct AC_param {
-	unsigned char		ACI_AIFSN;
-	unsigned char		CW;
-	unsigned short	TXOP_limit;
-} RTW_PACK_STRUCT_STRUCT;
-RTW_PACK_STRUCT_END
-#ifdef RTW_PACK_STRUCT_USE_INCLUDES
-#  include "pack_end.h"
-#endif
-
-#ifdef RTW_PACK_STRUCT_USE_INCLUDES
-#  include "pack_begin.h"
-#endif
-RTW_PACK_STRUCT_BEGIN
-struct WMM_para_element {
-	unsigned char		QoS_info;
-	unsigned char		reserved;
-	struct AC_param	ac_param[4];
-} RTW_PACK_STRUCT_STRUCT;
-RTW_PACK_STRUCT_END
-#ifdef RTW_PACK_STRUCT_USE_INCLUDES
-#  include "pack_end.h"
-#endif
-
-#ifdef RTW_PACK_STRUCT_USE_INCLUDES
-#  include "pack_begin.h"
-#endif
-RTW_PACK_STRUCT_BEGIN
-struct ADDBA_request {
-	unsigned char		dialog_token;
-	unsigned short	BA_para_set;
-	unsigned short	BA_timeout_value;
-	unsigned short	BA_starting_seqctrl;
-} RTW_PACK_STRUCT_STRUCT;
-RTW_PACK_STRUCT_END
-#ifdef RTW_PACK_STRUCT_USE_INCLUDES
-#  include "pack_end.h"
-#endif
-
-typedef enum _HT_CAP_AMPDU_FACTOR {
-	MAX_AMPDU_FACTOR_8K		= 0,
-	MAX_AMPDU_FACTOR_16K	= 1,
-	MAX_AMPDU_FACTOR_32K	= 2,
-	MAX_AMPDU_FACTOR_64K	= 3,
-} HT_CAP_AMPDU_FACTOR;
-
-/* 802.11n HT capabilities masks */
-#define IEEE80211_HT_CAP_SUP_WIDTH		0x0002
-#define IEEE80211_HT_CAP_GRN_FLD		0x0010
-#define IEEE80211_HT_CAP_SGI_20			0x0020
-#define IEEE80211_HT_CAP_SGI_40			0x0040
-#define IEEE80211_HT_CAP_TX_STBC			0x0080
-#define IEEE80211_HT_CAP_RX_STBC		0x0300
-#define IEEE80211_HT_CAP_DELAY_BA		0x0400
-#define IEEE80211_HT_CAP_MAX_AMSDU		0x0800
-#define IEEE80211_HT_CAP_DSSSCCK40		0x1000
-/* 802.11n HT capability AMPDU settings */
-#define IEEE80211_HT_CAP_AMPDU_FACTOR		0x03
-#define IEEE80211_HT_CAP_AMPDU_DENSITY		0x1C
-/* 802.11n HT capability MSC set */
-#define IEEE80211_SUPP_MCS_SET_UEQM		4
-#define IEEE80211_HT_CAP_MAX_STREAMS		4
-#define IEEE80211_SUPP_MCS_SET_LEN		10
-/* maximum streams the spec allows */
-#define IEEE80211_HT_CAP_MCS_TX_DEFINED		0x01
-#define IEEE80211_HT_CAP_MCS_TX_RX_DIFF		0x02
-#define IEEE80211_HT_CAP_MCS_TX_STREAMS		0x0C
-#define IEEE80211_HT_CAP_MCS_TX_UEQM		0x10
-/* 802.11n HT IE masks */
-#define IEEE80211_HT_IE_CHA_SEC_OFFSET		0x03
-#define IEEE80211_HT_IE_CHA_SEC_NONE	 	0x00
-#define IEEE80211_HT_IE_CHA_SEC_ABOVE 		0x01
-#define IEEE80211_HT_IE_CHA_SEC_BELOW 		0x03
-#define IEEE80211_HT_IE_CHA_WIDTH		0x04
-#define IEEE80211_HT_IE_HT_PROTECTION		0x0003
-#define IEEE80211_HT_IE_NON_GF_STA_PRSNT	0x0004
-#define IEEE80211_HT_IE_NON_HT_STA_PRSNT	0x0010
-
-/* block-ack parameters */
-#define IEEE80211_ADDBA_PARAM_POLICY_MASK 0x0002
-#define IEEE80211_ADDBA_PARAM_TID_MASK 0x003C
-#define RTW_IEEE80211_ADDBA_PARAM_BUF_SIZE_MASK 0xFFC0
-#define IEEE80211_DELBA_PARAM_TID_MASK 0xF000
-#define IEEE80211_DELBA_PARAM_INITIATOR_MASK 0x0800
-
-/*
- * A-PMDU buffer sizes
- * According to IEEE802.11n spec size varies from 8K to 64K (in powers of 2)
- */
-#define IEEE80211_MIN_AMPDU_BUF 0x8
-#define IEEE80211_MAX_AMPDU_BUF 0x40
-
-#define OP_MODE_PURE                    0
-#define OP_MODE_MAY_BE_LEGACY_STAS      1
-#define OP_MODE_20MHZ_HT_STA_ASSOCED    2
-#define OP_MODE_MIXED                   3
-
-#define HT_INFO_HT_PARAM_SECONDARY_CHNL_OFF_MASK	((u8) BIT(0) | BIT(1))
-#define HT_INFO_HT_PARAM_SECONDARY_CHNL_ABOVE		((u8) BIT(0))
-#define HT_INFO_HT_PARAM_SECONDARY_CHNL_BELOW		((u8) BIT(0) | BIT(1))
-#define HT_INFO_HT_PARAM_REC_TRANS_CHNL_WIDTH		((u8) BIT(2))
-#define HT_INFO_HT_PARAM_RIFS_MODE			((u8) BIT(3))
-#define HT_INFO_HT_PARAM_CTRL_ACCESS_ONLY		((u8) BIT(4))
-#define HT_INFO_HT_PARAM_SRV_INTERVAL_GRANULARITY	((u8) BIT(5))
-
-#define HT_INFO_OPERATION_MODE_OP_MODE_MASK	\
-		((u8) (0x0003))
-#define HT_INFO_OPERATION_MODE_OP_MODE_OFFSET		0
-#define HT_INFO_OPERATION_MODE_NON_GF_DEVS_PRESENT	((u8) BIT(2))
-#define HT_INFO_OPERATION_MODE_TRANSMIT_BURST_LIMIT	((u8) BIT(3))
-#define HT_INFO_OPERATION_MODE_NON_HT_STA_PRESENT	((u8) BIT(4))
-
-#define HT_INFO_STBC_PARAM_DUAL_BEACON			((u16) BIT(6))
-#define HT_INFO_STBC_PARAM_DUAL_STBC_PROTECT		((u16) BIT(7))
-#define HT_INFO_STBC_PARAM_SECONDARY_BCN		((u16) BIT(8))
-#define HT_INFO_STBC_PARAM_LSIG_TXOP_PROTECT_ALLOWED	((u16) BIT(9))
-#define HT_INFO_STBC_PARAM_PCO_ACTIVE			((u16) BIT(10))
-#define HT_INFO_STBC_PARAM_PCO_PHASE			((u16) BIT(11))
-
-
-
-//#endif
-
-//	===============WPS Section===============
-//	For WPSv1.0
-#define WPSOUI							0x0050f204
-//	WPS attribute ID
-#define WPS_ATTR_VER1					0x104A
-#define WPS_ATTR_SIMPLE_CONF_STATE	0x1044
-#define WPS_ATTR_RESP_TYPE			0x103B
-#define WPS_ATTR_UUID_E				0x1047
-#define WPS_ATTR_MANUFACTURER		0x1021
-#define WPS_ATTR_MODEL_NAME			0x1023
-#define WPS_ATTR_MODEL_NUMBER		0x1024
-#define WPS_ATTR_SERIAL_NUMBER		0x1042
-#define WPS_ATTR_PRIMARY_DEV_TYPE	0x1054
-#define WPS_ATTR_SEC_DEV_TYPE_LIST	0x1055
-#define WPS_ATTR_DEVICE_NAME			0x1011
-#define WPS_ATTR_CONF_METHOD			0x1008
-#define WPS_ATTR_RF_BANDS				0x103C
-#define WPS_ATTR_DEVICE_PWID			0x1012
-#define WPS_ATTR_REQUEST_TYPE			0x103A
-#define WPS_ATTR_ASSOCIATION_STATE	0x1002
-#define WPS_ATTR_CONFIG_ERROR			0x1009
-#define WPS_ATTR_VENDOR_EXT			0x1049
-#define WPS_ATTR_SELECTED_REGISTRAR	0x1041
-
-//	Value of WPS attribute "WPS_ATTR_DEVICE_NAME
-#define WPS_MAX_DEVICE_NAME_LEN		32
-
-//	Value of WPS Request Type Attribute
-#define WPS_REQ_TYPE_ENROLLEE_INFO_ONLY			0x00
-#define WPS_REQ_TYPE_ENROLLEE_OPEN_8021X		0x01
-#define WPS_REQ_TYPE_REGISTRAR					0x02
-#define WPS_REQ_TYPE_WLAN_MANAGER_REGISTRAR	0x03
-
-//	Value of WPS Response Type Attribute
-#define WPS_RESPONSE_TYPE_INFO_ONLY	0x00
-#define WPS_RESPONSE_TYPE_8021X		0x01
-#define WPS_RESPONSE_TYPE_REGISTRAR	0x02
-#define WPS_RESPONSE_TYPE_AP			0x03
-
-//	Value of WPS WiFi Simple Configuration State Attribute
-#define WPS_WSC_STATE_NOT_CONFIG	0x01
-#define WPS_WSC_STATE_CONFIG			0x02
-
-//	Value of WPS Version Attribute
-#define WPS_VERSION_1					0x10
-
-//	Value of WPS Configuration Method Attribute
-#define WPS_CONFIG_METHOD_FLASH		0x0001
-#define WPS_CONFIG_METHOD_ETHERNET	0x0002
-#define WPS_CONFIG_METHOD_LABEL		0x0004
-#define WPS_CONFIG_METHOD_DISPLAY	0x0008
-#define WPS_CONFIG_METHOD_E_NFC		0x0010
-#define WPS_CONFIG_METHOD_I_NFC		0x0020
-#define WPS_CONFIG_METHOD_NFC		0x0040
-#define WPS_CONFIG_METHOD_PBC		0x0080
-#define WPS_CONFIG_METHOD_KEYPAD	0x0100
-#define WPS_CONFIG_METHOD_VPBC		0x0280
-#define WPS_CONFIG_METHOD_PPBC		0x0480
-#define WPS_CONFIG_METHOD_VDISPLAY	0x2008
-#define WPS_CONFIG_METHOD_PDISPLAY	0x4008
-
-//	Value of Category ID of WPS Primary Device Type Attribute
-#define WPS_PDT_CID_DISPLAYS			0x0007
-#define WPS_PDT_CID_MULIT_MEDIA		0x0008
-#define WPS_PDT_CID_RTK_WIDI			WPS_PDT_CID_MULIT_MEDIA
-
-//	Value of Sub Category ID of WPS Primary Device Type Attribute
-#define WPS_PDT_SCID_MEDIA_SERVER	0x0005
-#define WPS_PDT_SCID_RTK_DMP			WPS_PDT_SCID_MEDIA_SERVER
-
-//	Value of Device Password ID
-#define WPS_DPID_PIN					0x0000
-#define WPS_DPID_USER_SPEC			0x0001
-#define WPS_DPID_MACHINE_SPEC			0x0002
-#define WPS_DPID_REKEY					0x0003
-#define WPS_DPID_PBC					0x0004
-#define WPS_DPID_REGISTRAR_SPEC		0x0005
-
-//	Value of WPS RF Bands Attribute
-#define WPS_RF_BANDS_2_4_GHZ		0x01
-#define WPS_RF_BANDS_5_GHZ		0x02
-
-//	Value of WPS Association State Attribute
-#define WPS_ASSOC_STATE_NOT_ASSOCIATED			0x00
-#define WPS_ASSOC_STATE_CONNECTION_SUCCESS		0x01
-#define WPS_ASSOC_STATE_CONFIGURATION_FAILURE	0x02
-#define WPS_ASSOC_STATE_ASSOCIATION_FAILURE		0x03
-#define WPS_ASSOC_STATE_IP_FAILURE				0x04
-
-//	=====================P2P Section=====================
-//	For P2P
-#define	P2POUI							0x506F9A09
-
-//	P2P Attribute ID
-#define	P2P_ATTR_STATUS					0x00
-#define	P2P_ATTR_MINOR_REASON_CODE		0x01
-#define	P2P_ATTR_CAPABILITY				0x02
-#define	P2P_ATTR_DEVICE_ID				0x03
-#define	P2P_ATTR_GO_INTENT				0x04
-#define	P2P_ATTR_CONF_TIMEOUT			0x05
-#define	P2P_ATTR_LISTEN_CH				0x06
-#define	P2P_ATTR_GROUP_BSSID				0x07
-#define	P2P_ATTR_EX_LISTEN_TIMING		0x08
-#define	P2P_ATTR_INTENTED_IF_ADDR		0x09
-#define	P2P_ATTR_MANAGEABILITY			0x0A
-#define	P2P_ATTR_CH_LIST					0x0B
-#define	P2P_ATTR_NOA						0x0C
-#define	P2P_ATTR_DEVICE_INFO				0x0D
-#define	P2P_ATTR_GROUP_INFO				0x0E
-#define	P2P_ATTR_GROUP_ID					0x0F
-#define	P2P_ATTR_INTERFACE				0x10
-#define	P2P_ATTR_OPERATING_CH			0x11
-#define	P2P_ATTR_INVITATION_FLAGS		0x12
-
-//	Value of Status Attribute
-#define	P2P_STATUS_SUCCESS						0x00
-#define	P2P_STATUS_FAIL_INFO_UNAVAILABLE		0x01
-#define	P2P_STATUS_FAIL_INCOMPATIBLE_PARAM		0x02
-#define	P2P_STATUS_FAIL_LIMIT_REACHED			0x03
-#define	P2P_STATUS_FAIL_INVALID_PARAM			0x04
-#define	P2P_STATUS_FAIL_REQUEST_UNABLE			0x05
-#define	P2P_STATUS_FAIL_PREVOUS_PROTO_ERR		0x06
-#define	P2P_STATUS_FAIL_NO_COMMON_CH			0x07
-#define	P2P_STATUS_FAIL_UNKNOWN_P2PGROUP		0x08
-#define	P2P_STATUS_FAIL_BOTH_GOINTENT_15		0x09
-#define	P2P_STATUS_FAIL_INCOMPATIBLE_PROVSION	0x0A
-#define	P2P_STATUS_FAIL_USER_REJECT				0x0B
-
-//	Value of Inviation Flags Attribute
-#define	P2P_INVITATION_FLAGS_PERSISTENT			BIT(0)
-
-#define	DMP_P2P_DEVCAP_SUPPORT	(P2P_DEVCAP_SERVICE_DISCOVERY | \
-									P2P_DEVCAP_CLIENT_DISCOVERABILITY | \
-									P2P_DEVCAP_CONCURRENT_OPERATION | \
-									P2P_DEVCAP_INVITATION_PROC)
-
-#define	DMP_P2P_GRPCAP_SUPPORT	(P2P_GRPCAP_INTRABSS)
-
-//	Value of Device Capability Bitmap
-#define	P2P_DEVCAP_SERVICE_DISCOVERY		BIT(0)
-#define	P2P_DEVCAP_CLIENT_DISCOVERABILITY	BIT(1)
-#define	P2P_DEVCAP_CONCURRENT_OPERATION	BIT(2)
-#define	P2P_DEVCAP_INFRA_MANAGED			BIT(3)
-#define	P2P_DEVCAP_DEVICE_LIMIT				BIT(4)
-#define	P2P_DEVCAP_INVITATION_PROC			BIT(5)
-
-//	Value of Group Capability Bitmap
-#define	P2P_GRPCAP_GO							BIT(0)
-#define	P2P_GRPCAP_PERSISTENT_GROUP			BIT(1)
-#define	P2P_GRPCAP_GROUP_LIMIT				BIT(2)
-#define	P2P_GRPCAP_INTRABSS					BIT(3)
-#define	P2P_GRPCAP_CROSS_CONN				BIT(4)
-#define	P2P_GRPCAP_PERSISTENT_RECONN		BIT(5)
-#define	P2P_GRPCAP_GROUP_FORMATION			BIT(6)
-
-//	P2P Public Action Frame ( Management Frame )
-#define	P2P_PUB_ACTION_ACTION				0x09
-
-//	P2P Public Action Frame Type
-#define	P2P_GO_NEGO_REQ						0
-#define	P2P_GO_NEGO_RESP						1
-#define	P2P_GO_NEGO_CONF						2
-#define	P2P_INVIT_REQ							3
-#define	P2P_INVIT_RESP							4
-#define	P2P_DEVDISC_REQ						5
-#define	P2P_DEVDISC_RESP						6
-#define	P2P_PROVISION_DISC_REQ				7
-#define	P2P_PROVISION_DISC_RESP				8
-
-//	P2P Action Frame Type
-#define	P2P_NOTICE_OF_ABSENCE	0
-#define	P2P_PRESENCE_REQUEST		1
-#define	P2P_PRESENCE_RESPONSE	2
-#define	P2P_GO_DISC_REQUEST		3
-
-
-#define	P2P_MAX_PERSISTENT_GROUP_NUM		10
-
-#define	P2P_PROVISIONING_SCAN_CNT			3
-
-#define	P2P_WILDCARD_SSID_LEN				7
-
-#define	P2P_FINDPHASE_EX_NONE				0	// default value, used when: (1)p2p disabed or (2)p2p enabled but only do 1 scan phase
-#define	P2P_FINDPHASE_EX_FULL				1	// used when p2p enabled and want to do 1 scan phase and P2P_FINDPHASE_EX_MAX-1 find phase
-#define	P2P_FINDPHASE_EX_SOCIAL_FIRST		(P2P_FINDPHASE_EX_FULL+1)
-#define	P2P_FINDPHASE_EX_MAX					4
-#define	P2P_FINDPHASE_EX_SOCIAL_LAST		P2P_FINDPHASE_EX_MAX
-
-#define	P2P_PROVISION_TIMEOUT				5000	//	5 seconds timeout for sending the provision discovery request
-#define	P2P_CONCURRENT_PROVISION_TIMEOUT	3000	//	3 seconds timeout for sending the provision discovery request under concurrent mode
-#define	P2P_GO_NEGO_TIMEOUT					5000	//	5 seconds timeout for receiving the group negotation response
-#define	P2P_CONCURRENT_GO_NEGO_TIMEOUT		3000	//	3 seconds timeout for sending the negotiation request under concurrent mode
-#define	P2P_TX_PRESCAN_TIMEOUT				100		//	100ms
-#define	P2P_INVITE_TIMEOUT					5000	//	5 seconds timeout for sending the invitation request
-#define	P2P_CONCURRENT_INVITE_TIMEOUT		3000	//	3 seconds timeout for sending the invitation request under concurrent mode
-
-#define	P2P_MAX_INTENT						15
-
-#define	P2P_MAX_NOA_NUM						2
-
-//	WPS Configuration Method
-#define	WPS_CM_NONE							0x0000
-#define	WPS_CM_LABEL							0x0004
-#define	WPS_CM_DISPLYA						0x0008
-#define	WPS_CM_EXTERNAL_NFC_TOKEN			0x0010
-#define	WPS_CM_INTEGRATED_NFC_TOKEN		0x0020
-#define	WPS_CM_NFC_INTERFACE					0x0040
-#define	WPS_CM_PUSH_BUTTON					0x0080
-#define	WPS_CM_KEYPAD						0x0100
-#define	WPS_CM_SW_PUHS_BUTTON				0x0280
-#define	WPS_CM_HW_PUHS_BUTTON				0x0480
-#define	WPS_CM_SW_DISPLAY_PIN				0x2008
-#define	WPS_CM_LCD_DISPLAY_PIN				0x4008
-
-
-//wext_send_mgnt bit type
-#define P2P_SEND_ACTION_AFTER_PROBE_RSP	 	1
-#define RTW_SEND_AND_WAIT_ACK 				2
-#define RTW_SEND_BY_HIGH_RATE				4 // IEEE80211_OFDM_RATE_54MB
-#define RTW_NAV_BY_USER						8
-
-enum gen_ie_type {
-	P2PWPS_PROBE_REQ_IE = 0,
-	P2PWPS_PROBE_RSP_IE,
-	P2PWPS_BEACON_IE,
-	P2PWPS_ASSOC_REQ_IE,
-	P2PWPS_ASSOC_RSP_IE
-};
-
-enum P2P_ROLE {
-	P2P_ROLE_DISABLE = 0,
-	P2P_ROLE_DEVICE = 1,
-	P2P_ROLE_CLIENT = 2,
-	P2P_ROLE_GO = 3
-};
-
-enum P2P_STATE {
-	P2P_STATE_NONE = 0,							//	P2P disable
-	P2P_STATE_IDLE = 1,								//	P2P had enabled and do nothing
-	P2P_STATE_LISTEN = 2,							//	In pure listen state
-	P2P_STATE_SCAN = 3,							//	In scan phase
-	P2P_STATE_FIND_PHASE_LISTEN = 4,				//	In the listen state of find phase
-	P2P_STATE_FIND_PHASE_SEARCH = 5,				//	In the search state of find phase
-	P2P_STATE_TX_PROVISION_DIS_REQ = 6,			//	In P2P provisioning discovery
-	P2P_STATE_RX_PROVISION_DIS_RSP = 7,
-	P2P_STATE_RX_PROVISION_DIS_REQ = 8,
-	P2P_STATE_GONEGO_ING = 9,						//	Doing the group owner negoitation handshake
-	P2P_STATE_GONEGO_OK = 10,						//	finish the group negoitation handshake with success
-	P2P_STATE_GONEGO_FAIL = 11,					//	finish the group negoitation handshake with failure
-	P2P_STATE_RECV_INVITE_REQ_MATCH = 12,		//	receiving the P2P Inviation request and match with the profile.
-	P2P_STATE_PROVISIONING_ING = 13,				//	Doing the P2P WPS
-	P2P_STATE_PROVISIONING_DONE = 14,			//	Finish the P2P WPS
-	P2P_STATE_TX_INVITE_REQ = 15,					//	Transmit the P2P Invitation request
-	P2P_STATE_RX_INVITE_RESP = 16,				//	Receiving the P2P Invitation response
-	P2P_STATE_RECV_INVITE_REQ_DISMATCH = 17,	//	receiving the P2P Inviation request and dismatch with the profile.
-	P2P_STATE_RECV_INVITE_REQ_GO = 18,			//	receiving the P2P Inviation request and this wifi is GO.
-	P2P_STATE_RECV_INVITE_REQ_JOIN = 19,			//	receiving the P2P Inviation request to join an existing P2P Group.
-	P2P_STATE_FORMATION_COMPLETE = 20,
-	P2P_STATE_CONNECTED = 21,
-};
-
-enum P2P_WPSINFO {
-	P2P_NO_WPSINFO						= 0,
-	P2P_GOT_WPSINFO_PEER_DISPLAY_PIN	= 1,
-	P2P_GOT_WPSINFO_SELF_DISPLAY_PIN	= 2,
-	P2P_GOT_WPSINFO_PBC					= 3,
-};
-
-#define	P2P_PRIVATE_IOCTL_SET_LEN		64
-
-enum P2P_PROTO_WK_ID {
-	P2P_FIND_PHASE_WK = 0,
-	P2P_RESTORE_STATE_WK = 1,
-	P2P_PRE_TX_PROVDISC_PROCESS_WK = 2,
-	P2P_PRE_TX_NEGOREQ_PROCESS_WK = 3,
-	P2P_PRE_TX_INVITEREQ_PROCESS_WK = 4,
-	P2P_AP_P2P_CH_SWITCH_PROCESS_WK = 5,
-	P2P_RO_CH_WK = 6,
-};
-
-enum P2P_PS {
-	P2P_PS_DISABLE = 0,
-	P2P_PS_ENABLE = 1,
-	P2P_PS_SCAN = 2,
-	P2P_PS_SCAN_DONE = 3,
-	P2P_PS_ALLSTASLEEP = 4, // for owner
-};
-
-//	=====================WFD Section=====================
-//	For Wi-Fi Display
-#define	WFD_ATTR_DEVICE_INFO			0x00
-#define	WFD_ATTR_ASSOC_BSSID			0x01
-#define	WFD_ATTR_COUPLED_SINK_INFO	0x06
-#define	WFD_ATTR_LOCAL_IP_ADDR		0x08
-#define	WFD_ATTR_SESSION_INFO		0x09
-#define	WFD_ATTR_ALTER_MAC			0x0a
-
-//	For WFD Device Information Attribute
-#define	WFD_DEVINFO_SOURCE					0x0000
-#define	WFD_DEVINFO_PSINK					0x0001
-#define	WFD_DEVINFO_SSINK					0x0002
-
-#define	WFD_DEVINFO_SESSION_AVAIL			0x0010
-#define	WFD_DEVINFO_WSD						0x0040
-#define	WFD_DEVINFO_PC_TDLS					0x0080
-
-#ifndef _CUSTOM_IE_TYPE_
-#define _CUSTOM_IE_TYPE_
-typedef enum CUSTOM_IE_TYPE {
-	PROBE_REQ = BIT(0),
-	PROBE_RSP = BIT(1),
-	BEACON	  = BIT(2),
-	ASSOC_REQ = BIT(3),
-} rtw_custom_ie_type_t;
-#endif /* _CUSTOM_IE_TYPE_ */
-
-#endif // _WIFI_H_
-
diff --git a/os/board/rtl8720e/src/component/wifi/driver/include/wifi_performance_monitor.h b/os/board/rtl8720e/src/component/wifi/driver/include/wifi_performance_monitor.h
old mode 100644
new mode 100755
index 9cb7a5b7e..12eddc5a7
--- a/os/board/rtl8720e/src/component/wifi/driver/include/wifi_performance_monitor.h
+++ b/os/board/rtl8720e/src/component/wifi/driver/include/wifi_performance_monitor.h
@@ -1,8 +1,6 @@
 #ifndef __WIFI_PERFORMANCE_MONITOR_H__
 #define __WIFI_PERFORMANCE_MONITOR_H__
 
-#include <platform_stdlib.h>
-
 #ifdef CONFIG_PLATFORM_8721D
 #include "rtl8721d.h"
 #endif
@@ -28,7 +26,6 @@ struct WIFI_TIME {
 
 	u32 recv_func_posthandle_time;
 	u32 recv_func_posthandle_time1;
-	u32 recv_func_posthandle_time2;
 	u32 recv_func_posthandle_time3;
 
 	u32 process_recv_indicatepkts_time;
diff --git a/os/board/rtl8720e/src/component/wifi/driver/include/wifi_structures.h b/os/board/rtl8720e/src/component/wifi/driver/include/wifi_structures.h
deleted file mode 100644
index 3ea0f282a..000000000
--- a/os/board/rtl8720e/src/component/wifi/driver/include/wifi_structures.h
+++ /dev/null
@@ -1,529 +0,0 @@
-/******************************************************************************
- * Copyright (c) 2013-2016 Realtek Semiconductor Corp.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
-  *******************************************************************************/
-
-/**
-  ******************************************************************************
-  * @file    wifi_structures.h
-  * @author
-  * @version
-  * @brief   This file provides the data structures used for wlan API.
-  ******************************************************************************
-  */
-
-#ifndef _WIFI_STRUCTURES_H
-#define _WIFI_STRUCTURES_H
-
-/** @addtogroup WIFI
- *  @brief      WIFI module
- *  @{
- */
-
-//#include <freertos/freertos_service.h>
-#include "wifi_constants.h"
-#include "dlist.h"
-#ifdef	__cplusplus
-extern "C" {
-#endif
-
-#if defined(__IAR_SYSTEMS_ICC__) || defined (__GNUC__) || defined(__CC_ARM) || (defined(__ARMCC_VERSION) && (__ARMCC_VERSION >= 6010050))
-#pragma pack(1)
-#endif
-
-/** @addtogroup WIFI_Exported_Types WIFI Exported Types
-  * @{
-  */
-
-
-/** @defgroup Structs
-   *@{
-   */
-/**
-  * @brief  The structure is used to describe the SSID.
-  */
-typedef struct {
-	unsigned char len;     /**< SSID length */
-	unsigned char val[33]; /**< SSID name (AP name)  */
-} rtw_ssid_t;
-#if defined(__IAR_SYSTEMS_ICC__) || defined (__GNUC__) || defined(__CC_ARM) || (defined(__ARMCC_VERSION) && (__ARMCC_VERSION >= 6010050))
-#pragma pack()
-#endif
-
-#if defined(__IAR_SYSTEMS_ICC__) || defined (__GNUC__) || defined(__CC_ARM) || (defined(__ARMCC_VERSION) && (__ARMCC_VERSION >= 6010050))
-#pragma pack(1)
-#endif
-
-/**
-  * @brief  The structure is used to describe the unique 6-byte MAC address.
-  */
-typedef struct {
-	unsigned char octet[6]; /**< Unique 6-byte MAC address */
-} rtw_mac_t;
-#if defined(__IAR_SYSTEMS_ICC__) || defined (__GNUC__) || defined(__CC_ARM) || (defined(__ARMCC_VERSION) && (__ARMCC_VERSION >= 6010050))
-#pragma pack()
-#endif
-
-/**
-  * @brief  The structure is used to describe the setting about SSID,
-  *			security type, password and default channel, used to start AP mode.
-  * @note  The data length of string pointed by ssid should not exceed 32,
-  *        and the data length of string pointed by password should not exceed 64.
-  */
-typedef struct {
-	rtw_ssid_t 			ssid;
-	unsigned char		hidden_ssid;
-	rtw_security_t		security_type;
-	unsigned char 		*password;
-	unsigned char 		password_len;
-	unsigned char		channel;
-} rtw_softap_info_t;
-
-typedef void (*ap_channel_switch_callback_t)(unsigned char channel, rtw_channel_switch_res_t ret);
-
-typedef void (*rtw_joinstatus_callback_t)(\
-		rtw_join_status_t join_status);
-
-/**
-  * @brief  The structure is used to describe the connection setting about SSID,
-  *			security type and password,etc., used when connecting to an AP.
-  * @note  The data length of string pointed by ssid should not exceed 32,
-  *        and the data length of string pointed by password should not exceed 64.
-  * @note  If this struct is used for wifi connect, the channel is used to config
-  *        whether it is a full channel scan(when channel is set to 0), or it will
-  *        only scan one channel(do active scan on the configured channel).
-  * @note  pscan_option set to PSCAN_FAST_SURVEY means do fast survey on the specified channel
-  *        set to 0 means do normal scan on the specified channel or full channel.
-  */
-typedef struct {
-	rtw_ssid_t 					ssid;
-	rtw_mac_t					bssid;
-	rtw_security_t				security_type;
-	unsigned char 				*password;
-	int 						password_len;
-	int							key_id;
-	unsigned char				channel;        /**< set to 0 means full channel scan, set to other value means only scan on the specified channel */
-	unsigned char				pscan_option;   /**< used when the specified channel is set, set to 0 for normal partial scan, set to PSCAN_FAST_SURVEY for fast survey*/
-	rtw_joinstatus_callback_t	joinstatus_user_callback;   /**< user callback for processing joinstatus, please set to NULL if not use it */
-} rtw_network_info_t;
-
-#if defined(__IAR_SYSTEMS_ICC__) || defined(__GNUC__) || defined(__CC_ARM) || (defined(__ARMCC_VERSION) && (__ARMCC_VERSION >= 6010050))
-#pragma pack(1)
-#endif
-
-typedef int (*wifi_do_fast_connect_ptr)(void);
-typedef int (*write_fast_connect_info_ptr)(unsigned int data1, unsigned int data2);
-typedef void (*p_wlan_autoreconnect_hdl_t)(rtw_security_t, char *, int, char *, int, int);
-
-/**
-  * @brief  The structure is used to describe the scan result of the AP.
-  */
-typedef struct {
-	rtw_ssid_t              SSID;             /**< Service Set Identification (i.e. Name of Access Point)                    */
-	rtw_mac_t               BSSID;            /**< Basic Service Set Identification (i.e. MAC address of Access Point)       */
-	signed short		                  signal_strength;  /**< Receive Signal Strength Indication in dBm. <-90=Very poor, >-30=Excellent */
-	rtw_bss_type_t          bss_type;         /**< Network type                                                              */
-	rtw_security_t          security;         /**< Security type                                                             */
-	rtw_wps_type_t          wps_type;         /**< WPS type                                                                  */
-	unsigned int                      channel;          /**< Radio channel that the AP beacon was received on                          */
-	rtw_802_11_band_t       band;             /**< Radio band                                                                */
-} rtw_scan_result_t;
-
-/**
-  * @brief  The structure is used to describe the data needed by scan result handler function.
-  */
-typedef struct rtw_scan_handler_result {
-    rtw_scan_result_t ap_details;
-    rtw_bool_t        scan_complete;
-    void*               user_data;
-} rtw_scan_handler_result_t;
-
-#if defined(__IAR_SYSTEMS_ICC__) || defined(__GNUC__) || defined(__CC_ARM) || (defined(__ARMCC_VERSION) && (__ARMCC_VERSION >= 6010050))
-#pragma pack()
-#endif
-
-/**
-* @brief channel scan time
-*/
-typedef struct {
-	unsigned short active_scan_time;      /*!< active scan time per channel, units: millisecond, default is 100ms */
-	unsigned short passive_scan_time;     /*!< passive scan time per channel, units: millisecond, default is 110ms */
-} rtw_channel_scan_time_t;
-
-typedef rtw_result_t (*scan_user_callback_t)(\
-		unsigned int ap_num, void *user_data);
-
-typedef rtw_result_t (*scan_report_each_mode_user_callback_t)(\
-		rtw_scan_result_t *scanned_ap_info, void *user_data);
-
-/**
-  * @brief  The structure is used to describe the scan parameters used for scan,
-  * @note  The data length of string pointed by ssid should not exceed 32,
-  *        and the data length of string pointed by password should not exceed 64.
-  */
-typedef struct {
-	rtw_scan_option_t						options;
-	char									*ssid;
-	unsigned char							*channel_list;
-	unsigned char							channel_list_num;
-	rtw_channel_scan_time_t 				chan_scan_time;
-	unsigned short							max_ap_record_num;     /**< config the max number of recorded AP, when set to 0, use default value 64 */
-	void									*scan_user_data;
-	scan_user_callback_t					scan_user_callback;   /**< used for normal asynchronized mode */
-	scan_report_each_mode_user_callback_t	scan_report_each_mode_user_callback; /*used for RTW_SCAN_REPORT_EACH mode */
-} rtw_scan_param_t;
-
-#if defined(__IAR_SYSTEMS_ICC__) || defined(__GNUC__) || defined(__CC_ARM) || (defined(__ARMCC_VERSION) && (__ARMCC_VERSION >= 6010050))
-#pragma pack(1)
-#endif
-
-
-/**
-  * @brief  The structure is used to store the WIFI setting gotten from WIFI driver.
-  */
-typedef struct {
-	rtw_mode_t			mode;   /**< the mode of current wlan interface */
-	unsigned char 		ssid[33];   /**< the ssid of connected AP or softAP */
-	unsigned char		bssid[6];   /**< the bssid of connected AP or softAP */
-	unsigned char		channel;
-	rtw_security_t		security_type;   /**< the security type of connected AP or softAP */
-	unsigned char 		password[65];   /**< the password of connected AP or softAP */
-	unsigned char		key_idx;
-	unsigned char		iw_mode;	/**< RTK_IW_MODE */
-	unsigned char		alg;		/**< RTW_IW_ENC_ALG */
-	unsigned int		auth_type;
-} rtw_wifi_setting_t;
-#if defined(__IAR_SYSTEMS_ICC__) || defined(__GNUC__) || defined(__CC_ARM) || (defined(__ARMCC_VERSION) && (__ARMCC_VERSION >= 6010050))
-#pragma pack()
-#endif
-
-extern rtw_wifi_setting_t wifi_setting[2];
-
-/**
-  * @brief  The structure is used to describe the setting when configure the network.
-  */
-typedef struct {
-	unsigned int		boot_mode;
-	unsigned char 		ssid[32];
-	unsigned char		ssid_len;
-	unsigned char		security_type;
-	unsigned char		password[65];
-	unsigned char		password_len;
-	unsigned char		channel;
-} rtw_wifi_config_t;
-
-/**
-  * @brief  The structure is used to describe the maclist.
-  */
-typedef struct {
-	unsigned int    count;         /**< Number of MAC addresses in the list    */
-	rtw_mac_t mac_list[1];   /**< Variable length array of MAC addresses */
-} rtw_maclist_t;
-
-/**
-  * @brief  The structure is used to describe the bss info of the network.\n
-  *			It include the version, BSSID, beacon_period, capability, SSID,
-  *			channel, atm_window, dtim_period, RSSI e.g.
-  */
-typedef struct {
-	unsigned int      version;                ///< version field
-	unsigned int      length;                 ///< byte length of data in this record
-	/* starting at version and including IEs */
-	rtw_mac_t     BSSID;
-	unsigned short      beacon_period;          ///< units are Kusec
-	unsigned short      capability;             ///< Capability information
-	unsigned char       SSID_len;
-	unsigned char       SSID[32];
-	unsigned char       channel;
-	unsigned short      atim_window;            ///< units are Kusec
-	unsigned char       dtim_period;            ///< DTIM period
-	signed short       RSSI;                   ///< receive signal strength (in dBm)
-
-	unsigned char       n_cap;                  ///< BSS is 802.11N Capable
-	unsigned int      nbss_cap;               ///< 802.11N BSS Capabilities (based on HT_CAP_*)
-	unsigned char       basic_mcs[MCSSET_LEN];  ///< 802.11N BSS required MCS set
-
-	unsigned short      ie_offset;              ///< offset at which IEs start, from beginning
-	unsigned int      ie_length;             ///< byte length of Information Elements
-} rtw_bss_info_t;
-
-/**
-  * @brief  The structure is used to set WIFI packet filter pattern.
-  */
-typedef struct {
-	unsigned short	offset;     ///< Offset in bytes to start filtering (referenced to the start of the ethernet packet)
-	unsigned short	mask_size;  ///< Size of the mask in bytes
-	unsigned char	*mask;       ///< Pattern mask bytes to be ANDed with the pattern eg. "\xff00" (must be in network byte order)
-	unsigned char	*pattern;    ///< Pattern bytes used to filter eg. "\x0800"  (must be in network byte order)
-} rtw_packet_filter_pattern_t;
-
-/**
-  * @brief  The structure is used to describe the 802.11 frame info
-  */
-typedef struct {
-	unsigned short i_fc;
-	unsigned short i_dur;
-	unsigned char i_addr1[6];
-	unsigned char i_addr2[6];
-	unsigned char i_addr3[6];
-	unsigned short i_seq;
-	unsigned char bssid[6];
-	unsigned char encrypt;
-	signed char rssi;
-#if (defined(CONFIG_UNSUPPORT_PLCPHDR_RPT) && CONFIG_UNSUPPORT_PLCPHDR_RPT) || defined __DOXYGEN__
-	rtw_rx_type_t type;
-#endif
-} ieee80211_frame_info_t;
-
-#if (defined(CONFIG_UNSUPPORT_PLCPHDR_RPT) && CONFIG_UNSUPPORT_PLCPHDR_RPT) || defined __DOXYGEN__
-/**
-  * @brief  The structure is used to describe the plcp header
-  */
-typedef struct {
-	unsigned short length;	///< length without FCS
-	unsigned char filter;		///< 1: HT-20 2T and not LDPC pkt; 2: HT-40 2T and not LDPC pkt; 3: LDPC pkt
-	signed char rssi;	///< -128~-1
-	unsigned short channel;	///< channel whick this pkt in
-unsigned char agg:
-	1;		///< aggregation pkt or not. If an AMPDU contains only one MPDU then above 'length' is the antual pkt length without FCS, buuut if it contains multiple MPDUs then above 'length' is useless because it cannot tell how many MPDUs are contained and how long is each MPDU.
-	unsigned char mcs: 7;		///< mcs index
-} rtw_rx_info_t;
-
-/**
-  * @brief  The structure is used to describe the plcp info
-  */
-struct rtw_plcp_info {
-	struct rtw_plcp_info *prev;
-	struct rtw_plcp_info *next;
-	rtw_rx_info_t rtw_plcp_info;
-};
-
-/**
-  * @brief  The structure is used to describe therx buffer
-  */
-struct rtw_rx_buffer {
-	struct rtw_plcp_info *head; ///< head
-	struct rtw_plcp_info *tail;   ///< tail
-};
-#endif
-
-/**
-  * @brief  The structure is used to describe the packet filter info
-  */
-typedef struct {
-	char filter_id;
-	rtw_packet_filter_pattern_t patt;
-	rtw_packet_filter_rule_t rule;
-	unsigned char enable;
-} rtw_packet_filter_info_t;
-
-/**
-  * @brief  The structure is used to describe the mac filter list
-  */
-typedef struct {
-	struct list_head node;
-	unsigned char mac_addr[6];
-} rtw_mac_filter_list_t;
-
-#if defined CONFIG_RTL8735B || defined __DOXYGEN__
-/**
-  * @brief  The structure is used to describe the wowlan pattern
-  */
-typedef struct {
-	unsigned char eth_da[6];
-	unsigned char eth_sa[6];
-	unsigned char eth_proto_type[2];
-	unsigned char header_len[1];
-	unsigned char ip_proto[1];
-	unsigned char ip_sa[4];
-	unsigned char ip_da[4];
-	unsigned char src_port[2];
-	unsigned char dest_port[2];
-	unsigned char flag2[1];
-	unsigned char mask[6];
-	unsigned char window[2];
-	unsigned char checksum[2];
-	unsigned char urgent_pointer[2];
-	unsigned char payload[64];
-	unsigned char payload_mask[9];
-} wowlan_pattern_t;
-#else
-
-/**
-  * @brief  The structure is used to describe the wowlan pattern
-  */
-typedef struct {
-	unsigned char eth_da[6];
-	unsigned char eth_sa[6];
-	unsigned char eth_proto_type[2];
-	unsigned char header_len[1];
-	//unsigned char header_content[8];
-	unsigned char ip_proto[1];
-	//unsigned char checksum[2];
-	unsigned char ip_sa[4];
-	unsigned char ip_da[4];
-	unsigned char src_port[2];
-	unsigned char dest_port[2];
-	unsigned char mask[5];
-} wowlan_pattern_t;
-#endif
-
-/**
-  * @brief  The structure is used to describe the psk info
-  */
-struct psk_info {
-	unsigned char index;                  ///<  index
-	unsigned char psk_essid[32 + 4]; ///< refer to NDIS_802_11_LENGTH_SSID + 4
-	unsigned char psk_passphrase[64 + 1]; ///< refer to IW_PASSPHRASE_MAX_SIZE + 1
-	unsigned char wpa_global_PSK[20 * 2]; ///< refer to A_SHA_DIGEST_LEN * 2
-};
-
-/**
-  * @brief  The structure is used to describe the sw statistics
-  */
-typedef struct { /* software statistics for tx and rx*/
-	unsigned long   rx_packets;             /*!< total packets received       */
-	unsigned long   tx_packets;             /*!<total packets transmitted    */
-	unsigned long   rx_dropped;             /*!< no space in buffers    */
-	unsigned long   tx_dropped;             /*!< no space available  */
-	unsigned long   rx_bytes;               /*!< total bytes received         */
-	unsigned long   tx_bytes;               /*!< total bytes transmitted      */
-	unsigned long   rx_overflow;            /*!< rx fifo overflow count       */
-	unsigned int    max_skbbuf_used_number; /*!< max skb buffer used number       */
-	unsigned int    skbbuf_used_number;     /*!< current used skbbuf number       */
-	unsigned int    max_skbdata_used_number;/*!< max skb data used number       */
-	unsigned int    skbdata_used_number;    /*!< current used skbdata number       */
-} rtw_sw_statistics_t;
-
-/**
-  * @brief  The structure is used to describe the phy statistics
-  */
-typedef struct {
-	signed char rssi;          /*!<average rssi in 1 sec */
-	signed char snr;          /*!< average snr in 1 sec (not include cck rate)*/
-	/* todo*/
-	unsigned int false_alarm_cck;
-	unsigned int false_alarm_ofdm;
-	unsigned int cca_cck;
-	unsigned int cca_ofdm;
-	unsigned int tx_retry;
-	unsigned short tx_drop;
-	unsigned int rx_drop;
-} rtw_phy_statistics_t;
-
-/**
-  * @brief  The structure is used to describe the data description
-  */
-typedef struct {
-	unsigned char wlan_idx;      /**< index of wlan interface which will transmit */
-	unsigned char *buf;          /**< poninter of buf where raw data is stored*/
-	unsigned short buf_len;      /**< the length of raw data*/
-	unsigned short flags;        /**< send options*/
-	unsigned char tx_rate;       /**< specific tx rate, please refer to enum MGN_RATE in wifi_constants.h*/
-	unsigned char retry_limit;   /**< retry limit configure, when set to 0, will use default retry limit 12*/
-	/* todo*/
-	unsigned int tx_power;
-} raw_data_desc_t;
-
-/**
-  * @brief  The structure is used to describe the wifi user configuration
-  */
-struct  wifi_user_conf {
-	unsigned char rtw_adaptivity_en;
-	unsigned char rtw_adaptivity_mode;
-	unsigned char rtw_adaptivity_th_l2h_ini;
-
-	unsigned char rtw_tx_pwr_lmt_enable;	///< 0: disable, 1: enable, 2: Depend on efuse(flash)
-	unsigned char rtw_tx_pwr_by_rate;	///< 0: disable, 1: enable, 2: Depend on efuse(flash)
-	unsigned char rtw_trp_tis_cert_en;
-
-	unsigned char rtw_cmd_tsk_spt_wap3;
-
-	rtw_wpa_mode wifi_wpa_mode;
-
-	unsigned char g_user_ap_sta_num;
-
-	/* power save */
-	unsigned char lps_dtim;
-	unsigned char lps_enter_threshold;
-	unsigned char rtw_power_mgnt;
-	unsigned char rtw_lps_level;
-	unsigned char smart_ps;
-
-	/* AP */
-	unsigned char bForwardingDisabled;
-
-	unsigned char bChDeauthDisabled;
-
-	unsigned char bAcceptAddbaReq;
-	unsigned char bIssueAddbaReq;	///< 0: disable issue addba request, 1: enable issue addba request
-
-	unsigned char ampdu_factor;	///for vht capability IE
-
-	unsigned char bCheckDestAddress; ///< 0: don't check dest mac and ip address for station, 1: check dest mac and ip address for station
-
-	/*
-	The ap_compatibilty_enabled is used to configure the wlan settings, each bit controls one aspect.
-	bit 0: (0: follow 802.11 spec, do not issue deauth, 1(default): issue deauth in 1st REAUTH_TO to be compatible with ap)
-	bit 1: (0: do not check beacon info to connect with AP with multiple SSID, 1(default): check beacon info)
-	bit 2: (0(default): do not issue deauth at start of auth, 1: issue deauth at start of auth)
-	bit 3: (0: do not switch WEP auth algo unless WLAN_STATUS_NOT_SUPPORTED_AUTH_ALG, 1(default): switch WEP auth algo from shared key to open system in 1st REAUTH_TO)
-	other bits: reserved
-	*/
-	unsigned char ap_compatibilty_enabled;
-
-	unsigned char max_roaming_times;
-
-	unsigned char ap_polling_sta;
-
-	unsigned char channel_plan;
-
-	unsigned char country_code;
-
-	/*for auto reconnect*/
-	unsigned char auto_reconnect_count;
-	unsigned char auto_reconnect_interval; // in sec
-} ;
-extern  struct wifi_user_conf wifi_user_config;
-
-/**
-  * @brief  The structure is used to describe the cfg parameters used for csi report,
-  * @note  The mac_addr if not specified, the default value must be 0.
-  */
-typedef struct {
-	rtw_csi_group_num group_num;
-	rtw_csi_mode mode;
-	rtw_csi_action act;
-	rtw_csi_accuracy accuracy;
-	unsigned char enable;
-	unsigned char trig_period;  /* unit:ms*/
-	unsigned char data_rate;
-	unsigned char mac_addr[6];
-} rtw_csi_action_parm_t;
-
-/** @} */
-
-#ifdef	__cplusplus
-}
-#endif
-
-/**
-  * @}
-  */
-
-/**
-  * @}
-  */
-
-#endif /* _WIFI_STRUCTURES_H */
diff --git a/os/board/rtl8720e/src/component/wifi/driver/include/wlan_basic_types.h b/os/board/rtl8720e/src/component/wifi/driver/include/wlan_basic_types.h
deleted file mode 100644
index eab8ab93c..000000000
--- a/os/board/rtl8720e/src/component/wifi/driver/include/wlan_basic_types.h
+++ /dev/null
@@ -1,395 +0,0 @@
-/******************************************************************************
- *
- * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of version 2 of the GNU General Public License as
- * published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
- * more details.
- *
- * You should have received a copy of the GNU General Public License along with
- * this program; if not, write to the Free Software Foundation, Inc.,
- * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
- *
- *
- ******************************************************************************/
-#ifndef __WLAN_BASIC_TYPES_H__
-#define __WLAN_BASIC_TYPES_H__
-
-
-/* ================================================
-  * Sections (1) rtl8195a and (2) other MCU based wlan driver
-  * For 8195a, some of the definitions are already defined in system wise "basic_types.h"
-  *================================================ */
-#define _SUCCESS		1
-#define _PASS		1
-#define _FAIL		0
-
-//ERRNO Define
-#define  EPERM     1  /* Operation not permitted */
-#define  ENOENT     2  /* No such file or directory */
-#define  ESRCH     3  /* No such process */
-#define  EINTR     4  /* Interrupted system call */
-#define  EIO     5  /* I/O error */
-#define  ENXIO     6  /* No such device or address */
-#define  E2BIG     7  /* Arg list too long */
-#define  ENOEXEC     8  /* Exec format error */
-#define  EBADF     9  /* Bad file number */
-#define  ECHILD    10  /* No child processes */
-#define  EAGAIN    11  /* Try again */
-#define  ENOMEM    12  /* Out of memory */
-#define  EACCES    13  /* Permission denied */
-#define  EFAULT    14  /* Bad address */
-#define  ENOTBLK    15  /* Block device required */
-#define  EBUSY    16  /* Device or resource busy */
-#define  EEXIST    17  /* File exists */
-#define  EXDEV    18  /* Cross-device link */
-#define  ENODEV    19  /* No such device */
-#define  ENOTDIR    20  /* Not a directory */
-#define  EISDIR    21  /* Is a directory */
-#define  EINVAL    22  /* Invalid argument */
-#define  ENFILE    23  /* File table overflow */
-#define  EMFILE    24  /* Too many open files */
-#define  ENOTTY    25  /* Not a typewriter */
-#define  ETXTBSY    26  /* Text file busy */
-#define  EFBIG    27  /* File too large */
-#define  ENOSPC    28  /* No space left on device */
-#define  ESPIPE    29  /* Illegal seek */
-#define  EROFS    30  /* Read-only file system */
-#define  EMLINK    31  /* Too many links */
-#define  EPIPE    32  /* Broken pipe */
-#define  EDOM    33  /* Math argument out of domain of func */
-#define  ERANGE    34  /* Math result not representable */
-#define  EDEADLK    35  /* Resource deadlock would occur */
-#define  ENAMETOOLONG  36  /* File name too long */
-#define  ENOLCK    37  /* No record locks available */
-#define  ENOSYS    38  /* Function not implemented */
-#define  ENOTEMPTY  39  /* Directory not empty */
-#define  ELOOP    40  /* Too many symbolic links encountered */
-#define  EWOULDBLOCK  EAGAIN  /* Operation would block */
-#define  ENOMSG    42  /* No message of desired type */
-#define  EIDRM    43  /* Identifier removed */
-#define  ECHRNG    44  /* Channel number out of range */
-#define  EL2NSYNC  45  /* Level 2 not synchronized */
-#define  EL3HLT    46  /* Level 3 halted */
-#define  EL3RST    47  /* Level 3 reset */
-#define  ELNRNG    48  /* Link number out of range */
-#define  EUNATCH    49  /* Protocol driver not attached */
-#define  ENOCSI    50  /* No CSI structure available */
-#define  EL2HLT    51  /* Level 2 halted */
-#define  EBADE    52  /* Invalid exchange */
-#define  EBADR    53  /* Invalid request descriptor */
-#define  EXFULL    54  /* Exchange full */
-#define  ENOANO    55  /* No anode */
-#define  EBADRQC    56  /* Invalid request code */
-#define  EBADSLT    57  /* Invalid slot */
-
-#define  EDEADLOCK  EDEADLK
-
-#define  EBFONT    59  /* Bad font file format */
-#define  ENOSTR    60  /* Device not a stream */
-#define  ENODATA    61  /* No data available */
-#define  ETIME    62  /* Timer expired */
-#define  ENOSR    63  /* Out of streams resources */
-#define  ENONET    64  /* Machine is not on the network */
-#define  ENOPKG    65  /* Package not installed */
-#define  EREMOTE    66  /* Object is remote */
-#define  ENOLINK    67  /* Link has been severed */
-#define  EADV    68  /* Advertise error */
-#define  ESRMNT    69  /* Srmount error */
-#define  ECOMM    70  /* Communication error on send */
-#define  EPROTO    71  /* Protocol error */
-#define  EMULTIHOP  72  /* Multihop attempted */
-#define  EDOTDOT    73  /* RFS specific error */
-#define  EBADMSG    74  /* Not a data message */
-#define  EOVERFLOW  75  /* Value too large for defined data type */
-#define  ENOTUNIQ  76  /* Name not unique on network */
-#define  EBADFD    77  /* File descriptor in bad state */
-#define  EREMCHG    78  /* Remote address changed */
-#define  ELIBACC    79  /* Can not access a needed shared library */
-#define  ELIBBAD    80  /* Accessing a corrupted shared library */
-#define  ELIBSCN    81  /* .lib section in a.out corrupted */
-#define  ELIBMAX    82  /* Attempting to link in too many shared libraries */
-#define  ELIBEXEC  83  /* Cannot exec a shared library directly */
-#define  EILSEQ    84  /* Illegal byte sequence */
-#define  ERESTART  85  /* Interrupted system call should be restarted */
-#define  ESTRPIPE  86  /* Streams pipe error */
-#define  EUSERS    87  /* Too many users */
-#define  ENOTSOCK  88  /* Socket operation on non-socket */
-#define  EDESTADDRREQ  89  /* Destination address required */
-#define  EMSGSIZE  90  /* Message too long */
-#define  EPROTOTYPE  91  /* Protocol wrong type for socket */
-#define  ENOPROTOOPT  92  /* Protocol not available */
-#define  EPROTONOSUPPORT  93  /* Protocol not supported */
-#define  ESOCKTNOSUPPORT  94  /* Socket type not supported */
-#define  EOPNOTSUPP  95  /* Operation not supported on transport endpoint */
-#define  EPFNOSUPPORT  96  /* Protocol family not supported */
-#define  EAFNOSUPPORT  97  /* Address family not supported by protocol */
-#define  EADDRINUSE  98  /* Address already in use */
-#define  EADDRNOTAVAIL  99  /* Cannot assign requested address */
-#define  ENETDOWN  100  /* Network is down */
-#define  ENETUNREACH  101  /* Network is unreachable */
-#define  ENETRESET  102  /* Network dropped connection because of reset */
-#define  ECONNABORTED  103  /* Software caused connection abort */
-#define  ECONNRESET  104  /* Connection reset by peer */
-#define  ENOBUFS    105  /* No buffer space available */
-#define  EISCONN    106  /* Transport endpoint is already connected */
-#define  ENOTCONN  107  /* Transport endpoint is not connected */
-#define  ESHUTDOWN  108  /* Cannot send after transport endpoint shutdown */
-#define  ETOOMANYREFS  109  /* Too many references: cannot splice */
-#define  ETIMEDOUT  110  /* Connection timed out */
-#define  ECONNREFUSED  111  /* Connection refused */
-#define  EHOSTDOWN  112  /* Host is down */
-#define  EHOSTUNREACH  113  /* No route to host */
-#define  EALREADY  114  /* Operation already in progress */
-#define  EINPROGRESS  115  /* Operation now in progress */
-#define  ESTALE    116  /* Stale NFS file handle */
-#define  EUCLEAN    117  /* Structure needs cleaning */
-#define  ENOTNAM    118  /* Not a XENIX named type file */
-#define  ENAVAIL    119  /* No XENIX semaphores available */
-#define  EISNAM    120  /* Is a named type file */
-#define  EREMOTEIO  121  /* Remote I/O error */
-#define  EDQUOT    122  /* Quota exceeded */
-
-#define  ENOMEDIUM  123  /* No medium found */
-#define  EMEDIUMTYPE  124  /* Wrong medium type */
-
-
-#define ENSROK    0 /* DNS server returned answer with no data */
-#define ENSRNODATA  160 /* DNS server returned answer with no data */
-#define ENSRFORMERR 161 /* DNS server claims query was misformatted */
-#define ENSRSERVFAIL 162  /* DNS server returned general failure */
-#define ENSRNOTFOUND 163  /* Domain name not found */
-#define ENSRNOTIMP  164 /* DNS server does not implement requested operation */
-#define ENSRREFUSED 165 /* DNS server refused query */
-#define ENSRBADQUERY 166  /* Misformatted DNS query */
-#define ENSRBADNAME 167 /* Misformatted domain name */
-#define ENSRBADFAMILY 168 /* Unsupported address family */
-#define ENSRBADRESP 169 /* Misformatted DNS reply */
-#define ENSRCONNREFUSED 170 /* Could not contact DNS servers */
-#define ENSRTIMEOUT 171 /* Timeout while contacting DNS servers */
-#define ENSROF    172 /* End of file */
-#define ENSRFILE  173 /* Error reading file */
-#define ENSRNOMEM 174 /* Out of memory */
-#define ENSRDESTRUCTION 175 /* Application terminated lookup */
-#define ENSRQUERYDOMAINTOOLONG  176 /* Domain name is too long */
-#define ENSRCNAMELOOP 177 /* Domain name is too long */
-
-#define _KEEP_AUTH 3
-
-
-
-
-
-/* ================================================
-  * Sections only for other MCU based wlan driver
-  *========================================== ======*/
-#if !defined(CONFIG_PLATFORM_8721D) && !defined(CONFIG_PLATFORM_AMEBAD2) && !defined(CONFIG_PLATFORM_8735B) && !defined(CONFIG_PLATFORM_AMEBALITE) && !defined(CONFIG_PLATFORM_AMEBADPLUS)
-#include <drv_conf.h>
-
-#define SUCCESS	0
-#define FAIL	(-1)
-
-//
-// pack & weak attribute
-//
-#if defined (__ICCARM__)
-
-#define RTW_PACK_STRUCT_STRUCT
-#define RTW_PACK_STRUCT_USE_INCLUDES
-
-#define RTW_WEAK					__weak
-
-#elif defined (__CC_ARM)
-
-#define RTW_PACK_STRUCT_BEGIN	__packed
-#define RTW_PACK_STRUCT_STRUCT
-#define RTW_PACK_STRUCT_END
-
-#define RTW_WEAK					 __weak
-
-#elif defined (__GNUC__)
-
-#define RTW_PACK_STRUCT_BEGIN
-#define RTW_PACK_STRUCT_STRUCT 	__attribute__ ((__packed__))
-#define RTW_PACK_STRUCT_END
-
-#define RTW_WEAK					__attribute__ ((weak))
-
-#else
-
-#define RTW_PACK_STRUCT_BEGIN
-#define RTW_PACK_STRUCT_STRUCT
-#define RTW_PACK_STRUCT_END
-#define RTW_PACK_STRUCT_USE_INCLUDES
-#endif
-
-#ifndef BIT
-#define BIT(x)	((u32)1 << (x))
-#endif
-
-#define MEM_ALIGNMENT_OFFSET	(sizeof (SIZE_T))
-#define MEM_ALIGNMENT_PADDING	(sizeof(SIZE_T) - 1)
-
-#define SIZE_PTR SIZE_T
-#define SSIZE_PTR SSIZE_T
-
-//port from fw by thomas
-// TODO: Belows are Sync from SD7-Driver. It is necessary to check correctness
-
-/*
- *	Call endian free function when
- *		1. Read/write packet content.
- *		2. Before write integer to IO.
- *		3. After read integer from IO.
-*/
-
-//
-// Byte Swapping routine.
-//
-#define EF2Byte 	le16_to_cpu
-#define EF4Byte	le32_to_cpu
-
-//
-// Read LE format data from memory
-//
-#define ReadEF1Byte(_ptr)		EF1Byte(*((u8 *)(_ptr)))
-#define ReadEF2Byte(_ptr)		EF2Byte(*((u16 *)(_ptr)))
-#define ReadEF4Byte(_ptr)		EF4Byte(*((u32 *)(_ptr)))
-
-//
-// Write LE data to memory
-//
-#define WriteEF1Byte(_ptr, _val)	(*((u8 *)(_ptr)))=EF1Byte(_val)
-#define WriteEF2Byte(_ptr, _val)	(*((u16 *)(_ptr)))=EF2Byte(_val)
-#define WriteEF4Byte(_ptr, _val)	(*((u32 *)(_ptr)))=EF4Byte(_val)
-
-//
-//	Example:
-//		BIT_LEN_MASK_32(0) => 0x00000000
-//		BIT_LEN_MASK_32(1) => 0x00000001
-//		BIT_LEN_MASK_32(2) => 0x00000003
-//		BIT_LEN_MASK_32(32) => 0xFFFFFFFF
-//
-#define BIT_LEN_MASK_32(__BitLen) \
-	(0xFFFFFFFF >> (32 - (__BitLen)))
-//
-//	Example:
-//		BIT_OFFSET_LEN_MASK_32(0, 2) => 0x00000003
-//		BIT_OFFSET_LEN_MASK_32(16, 2) => 0x00030000
-//
-#define BIT_OFFSET_LEN_MASK_32(__BitOffset, __BitLen) \
-	(BIT_LEN_MASK_32(__BitLen) << (__BitOffset))
-
-//
-//	Description:
-//		Return 4-byte value in host byte ordering from
-//		4-byte pointer in litten-endian system.
-//
-#define LE_P4BYTE_TO_HOST_4BYTE(__pStart) \
-	(EF4Byte(*((u32 *)(__pStart))))
-
-//
-//	Description:
-//		Translate subfield (continuous bits in little-endian) of 4-byte value in litten byte to
-//		4-byte value in host byte ordering.
-//
-#define LE_BITS_TO_4BYTE(__pStart, __BitOffset, __BitLen) \
-	( \
-		( LE_P4BYTE_TO_HOST_4BYTE(__pStart) >> (__BitOffset) ) \
-		& \
-		BIT_LEN_MASK_32(__BitLen) \
-	)
-
-//
-//	Description:
-//		Set subfield of little-endian 4-byte value to specified value.
-//
-#define SET_BITS_TO_LE_4BYTE(__pStart, __BitOffset, __BitLen, __Value) \
-	*((u32 *)(__pStart)) = \
-		EF4Byte( \
-			LE_BITS_CLEARED_TO_4BYTE(__pStart, __BitOffset, __BitLen) \
-			| \
-			( (((u32)__Value) & BIT_LEN_MASK_32(__BitLen)) << (__BitOffset) ) \
-		);
-
-
-#define BIT_LEN_MASK_16(__BitLen) \
-		(0xFFFF >> (16 - (__BitLen)))
-
-#define BIT_OFFSET_LEN_MASK_16(__BitOffset, __BitLen) \
-	(BIT_LEN_MASK_16(__BitLen) << (__BitOffset))
-
-#define LE_P2BYTE_TO_HOST_2BYTE(__pStart) \
-	(EF2Byte(*((u16 *)(__pStart))))
-
-#define LE_BITS_TO_2BYTE(__pStart, __BitOffset, __BitLen) \
-	( \
-		( LE_P2BYTE_TO_HOST_2BYTE(__pStart) >> (__BitOffset) ) \
-		& \
-		BIT_LEN_MASK_16(__BitLen) \
-	)
-
-#define SET_BITS_TO_LE_2BYTE(__pStart, __BitOffset, __BitLen, __Value) \
-	*((u16 *)(__pStart)) = \
-		EF2Byte( \
-			LE_BITS_CLEARED_TO_2BYTE(__pStart, __BitOffset, __BitLen) \
-			| \
-			( (((u16)__Value) & BIT_LEN_MASK_16(__BitLen)) << (__BitOffset) ) \
-		);
-
-#define BIT_LEN_MASK_8(__BitLen) \
-		(0xFF >> (8 - (__BitLen)))
-
-#define BIT_OFFSET_LEN_MASK_8(__BitOffset, __BitLen) \
-	(BIT_LEN_MASK_8(__BitLen) << (__BitOffset))
-
-#define LE_P1BYTE_TO_HOST_1BYTE(__pStart) \
-	(EF1Byte(*((u8 *)(__pStart))))
-
-#define LE_BITS_TO_1BYTE(__pStart, __BitOffset, __BitLen) \
-	( \
-		( LE_P1BYTE_TO_HOST_1BYTE(__pStart) >> (__BitOffset) ) \
-		& \
-		BIT_LEN_MASK_8(__BitLen) \
-	)
-
-#define LE_BITS_CLEARED_TO_1BYTE(__pStart, __BitOffset, __BitLen) \
-	( \
-		LE_P1BYTE_TO_HOST_1BYTE(__pStart) \
-		& \
-		( ~BIT_OFFSET_LEN_MASK_8(__BitOffset, __BitLen) ) \
-	)
-
-#define SET_BITS_TO_LE_1BYTE(__pStart, __BitOffset, __BitLen, __Value) \
-	*((u8 *)(__pStart)) = \
-		EF1Byte( \
-			LE_BITS_CLEARED_TO_1BYTE(__pStart, __BitOffset, __BitLen) \
-			| \
-			( (((u8)__Value) & BIT_LEN_MASK_8(__BitLen)) << (__BitOffset) ) \
-		);
-
-//pclint
-#define LE_BITS_CLEARED_TO_1BYTE_8BIT(__pStart, __BitOffset, __BitLen) \
-	( \
-		LE_P1BYTE_TO_HOST_1BYTE(__pStart) \
-	)
-
-
-// Get the N-bytes aligment offset from the current length
-#define N_BYTE_ALIGMENT(__Value, __Aligment) ((__Aligment == 1) ? (__Value) : (((__Value + __Aligment - 1) / __Aligment) * __Aligment))
-
-typedef unsigned char	BOOLEAN, *PBOOLEAN;
-
-#define TEST_FLAG(__Flag,__testFlag)		(((__Flag) & (__testFlag)) != 0)
-
-
-
-#endif//! defined(CONFIG_PLATFORM_8195A)
-
-#endif //__WLAN_BASIC_TYPES_H__
-
diff --git a/os/board/rtl8720e/src/component/wifi/driver/include/wlan_bssdef.h b/os/board/rtl8720e/src/component/wifi/driver/include/wlan_bssdef.h
deleted file mode 100644
index 7d0f0ccf5..000000000
--- a/os/board/rtl8720e/src/component/wifi/driver/include/wlan_bssdef.h
+++ /dev/null
@@ -1,443 +0,0 @@
-/******************************************************************************
- *
- * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of version 2 of the GNU General Public License as
- * published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
- * more details.
- *
- * You should have received a copy of the GNU General Public License along with
- * this program; if not, write to the Free Software Foundation, Inc.,
- * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
- *
- *
- ******************************************************************************/
-#ifndef __WLAN_BSSDEF_H__
-#define __WLAN_BSSDEF_H__
-
-
-#define MAX_IE_SZ	768 //384//
-#define NDIS_802_11_LENGTH_SSID         32
-#define NDIS_802_11_LENGTH_RATES        12
-#define NDIS_802_11_LENGTH_RATES_EX     16
-
-typedef unsigned char   NDIS_802_11_MAC_ADDRESS[6];
-typedef long    		NDIS_802_11_RSSI;           // in dBm
-typedef unsigned char   NDIS_802_11_RATES[NDIS_802_11_LENGTH_RATES];        // Set of 8 data rates
-typedef unsigned char   NDIS_802_11_RATES_EX[NDIS_802_11_LENGTH_RATES_EX];  // Set of 16 data rates
-
-
-typedef  u32  NDIS_802_11_KEY_INDEX;
-typedef unsigned long long NDIS_802_11_KEY_RSC;
-
-
-typedef struct _NDIS_802_11_SSID {
-	u32  SsidLength;
-	u8  Ssid[NDIS_802_11_LENGTH_SSID + 4];
-}
-#ifdef __CC_ARM
-__attribute__((packed))
-#endif
-NDIS_802_11_SSID, *PNDIS_802_11_SSID;
-
-typedef enum _NDIS_802_11_NETWORK_TYPE {
-	Ndis802_11FH,
-	Ndis802_11DS,
-	Ndis802_11OFDM5,
-	Ndis802_11OFDM24,
-	Ndis802_11NetworkTypeMax    // not a real type, defined as an upper bound
-} NDIS_802_11_NETWORK_TYPE, *PNDIS_802_11_NETWORK_TYPE;
-
-typedef struct _NDIS_802_11_CONFIGURATION_FH {
-	u32           Length;             // Length of structure
-	u32           HopPattern;         // As defined by 802.11, MSB set
-	u32           HopSet;             // to one if non-802.11
-	u32           DwellTime;          // units are Kusec
-}
-#ifdef __CC_ARM
-__attribute__((packed))
-#endif
-NDIS_802_11_CONFIGURATION_FH, *PNDIS_802_11_CONFIGURATION_FH;
-
-
-/*
-	FW will only save the channel number in DSConfig.
-	ODI Handler will convert the channel number to freq. number.
-*/
-typedef struct _NDIS_802_11_CONFIGURATION {
-	u32           Length;             // Length of structure
-	u32           BeaconPeriod;       // units are Kusec
-	u32           ATIMWindow;         // units are Kusec
-	u32           DSConfig;           // Frequency, units are kHz
-	NDIS_802_11_CONFIGURATION_FH    FHConfig;
-}
-#ifdef __CC_ARM
-__attribute__((packed))
-#endif
-NDIS_802_11_CONFIGURATION, *PNDIS_802_11_CONFIGURATION;
-
-
-
-typedef enum _NDIS_802_11_NETWORK_INFRASTRUCTURE {
-	Ndis802_11Infrastructure,
-	Ndis802_11AutoUnknown,
-	Ndis802_11InfrastructureMax,     // Not a real value, defined as upper bound
-	Ndis802_11APMode,
-	Ndis802_11Monitor
-} NDIS_802_11_NETWORK_INFRASTRUCTURE, *PNDIS_802_11_NETWORK_INFRASTRUCTURE;
-
-
-
-
-
-typedef struct _NDIS_802_11_FIXED_IEs {
-	u8  Timestamp[8];
-	u16  BeaconInterval;
-	u16  Capabilities;
-} NDIS_802_11_FIXED_IEs, *PNDIS_802_11_FIXED_IEs;
-
-
-
-typedef struct _NDIS_802_11_VARIABLE_IEs {
-	u8  ElementID;
-	u8  Length;
-	u8  data[1];
-} NDIS_802_11_VARIABLE_IEs, *PNDIS_802_11_VARIABLE_IEs;
-
-
-
-/*
-
-
-
-Length is the 4 bytes multiples of the sume of
-	sizeof (NDIS_802_11_MAC_ADDRESS) + 2 + sizeof (NDIS_802_11_SSID) + sizeof (u32)
-+   sizeof (NDIS_802_11_RSSI) + sizeof (NDIS_802_11_NETWORK_TYPE) + sizeof (NDIS_802_11_CONFIGURATION)
-+   sizeof (NDIS_802_11_RATES_EX) + IELength
-
-Except the IELength, all other fields are fixed length. Therefore, we can define a marco to present the
-partial sum.
-
-*/
-
-typedef enum _NDIS_802_11_AUTHENTICATION_MODE {
-	Ndis802_11AuthModeOpen,
-	Ndis802_11AuthModeShared,
-	Ndis802_11AuthModeAutoSwitch,
-	Ndis802_11AuthModeWPA,
-	Ndis802_11AuthModeWPAPSK,
-	Ndis802_11AuthModeWPANone,
-	Ndis802_11AuthModeWAPI,
-	Ndis802_11AuthModeWPA2,
-	Ndis802_11AuthModeWPA2PSK,
-	Ndis802_11AuthModeWPA3,
-	Ndis802_11AuthModeWPA3PSK,
-	Ndis802_11AuthModeMax               // Not a real mode, defined as upper bound
-} NDIS_802_11_AUTHENTICATION_MODE, *PNDIS_802_11_AUTHENTICATION_MODE;
-
-typedef enum _NDIS_802_11_WEP_STATUS {
-	Ndis802_11WEPEnabled,
-	Ndis802_11Encryption1Enabled = Ndis802_11WEPEnabled,
-	Ndis802_11WEPDisabled,
-	Ndis802_11EncryptionDisabled = Ndis802_11WEPDisabled,
-	Ndis802_11WEPKeyAbsent,
-	Ndis802_11Encryption1KeyAbsent = Ndis802_11WEPKeyAbsent,
-	Ndis802_11WEPNotSupported,
-	Ndis802_11EncryptionNotSupported = Ndis802_11WEPNotSupported,
-	Ndis802_11Encryption2Enabled,
-	Ndis802_11Encryption2KeyAbsent,
-	Ndis802_11Encryption3Enabled,
-	Ndis802_11Encryption3KeyAbsent,
-	Ndis802_11_EncrypteionWAPI
-} NDIS_802_11_WEP_STATUS, *PNDIS_802_11_WEP_STATUS,
-NDIS_802_11_ENCRYPTION_STATUS, *PNDIS_802_11_ENCRYPTION_STATUS;
-
-
-#define NDIS_802_11_AI_REQFI_CAPABILITIES      1
-#define NDIS_802_11_AI_REQFI_LISTENINTERVAL    2
-#define NDIS_802_11_AI_REQFI_CURRENTAPADDRESS  4
-
-#define NDIS_802_11_AI_RESFI_CAPABILITIES      1
-#define NDIS_802_11_AI_RESFI_STATUSCODE        2
-#define NDIS_802_11_AI_RESFI_ASSOCIATIONID     4
-
-typedef struct _NDIS_802_11_AI_REQFI {
-	u16 Capabilities;
-	u16 ListenInterval;
-	NDIS_802_11_MAC_ADDRESS  CurrentAPAddress;
-} NDIS_802_11_AI_REQFI, *PNDIS_802_11_AI_REQFI;
-
-typedef struct _NDIS_802_11_AI_RESFI {
-	u16 Capabilities;
-	u16 StatusCode;
-	u16 AssociationId;
-} NDIS_802_11_AI_RESFI, *PNDIS_802_11_AI_RESFI;
-
-typedef struct _NDIS_802_11_ASSOCIATION_INFORMATION {
-	u32                   Length;
-	u16                  AvailableRequestFixedIEs;
-	NDIS_802_11_AI_REQFI    RequestFixedIEs;
-	u32                   RequestIELength;
-	u32                   OffsetRequestIEs;
-	u16                  AvailableResponseFixedIEs;
-	NDIS_802_11_AI_RESFI    ResponseFixedIEs;
-	u32                   ResponseIELength;
-	u32                   OffsetResponseIEs;
-} NDIS_802_11_ASSOCIATION_INFORMATION, *PNDIS_802_11_ASSOCIATION_INFORMATION;
-
-typedef enum _NDIS_802_11_RELOAD_DEFAULTS {
-	Ndis802_11ReloadWEPKeys
-} NDIS_802_11_RELOAD_DEFAULTS, *PNDIS_802_11_RELOAD_DEFAULTS;
-
-
-// Key mapping keys require a BSSID
-typedef struct _NDIS_802_11_KEY {
-	u32           Length;             // Length of this structure
-	u32           KeyIndex;
-	u32           KeyLength;          // length of key in bytes
-	NDIS_802_11_MAC_ADDRESS BSSID;
-	NDIS_802_11_KEY_RSC KeyRSC;
-	u8           KeyMaterial[32];     // variable length depending on above field
-} NDIS_802_11_KEY, *PNDIS_802_11_KEY;
-
-typedef struct _NDIS_802_11_REMOVE_KEY {
-	u32                   Length;        // Length of this structure
-	u32                   KeyIndex;
-	NDIS_802_11_MAC_ADDRESS BSSID;
-} NDIS_802_11_REMOVE_KEY, *PNDIS_802_11_REMOVE_KEY;
-
-typedef struct _NDIS_802_11_WEP {
-	u32     Length;        // Length of this structure
-	u32     KeyIndex;      // 0 is the per-client key, 1-N are the global keys
-	u32     KeyLength;     // length of key in bytes
-	u8     KeyMaterial[16];// variable length depending on above field
-} NDIS_802_11_WEP, *PNDIS_802_11_WEP;
-
-typedef struct _NDIS_802_11_AUTHENTICATION_REQUEST {
-	u32 Length;            // Length of structure
-	NDIS_802_11_MAC_ADDRESS Bssid;
-	u32 Flags;
-} NDIS_802_11_AUTHENTICATION_REQUEST, *PNDIS_802_11_AUTHENTICATION_REQUEST;
-
-typedef enum _NDIS_802_11_STATUS_TYPE {
-	Ndis802_11StatusType_Authentication,
-	Ndis802_11StatusType_MediaStreamMode,
-	Ndis802_11StatusType_PMKID_CandidateList,
-	Ndis802_11StatusTypeMax    // not a real type, defined as an upper bound
-} NDIS_802_11_STATUS_TYPE, *PNDIS_802_11_STATUS_TYPE;
-
-typedef struct _NDIS_802_11_STATUS_INDICATION {
-	NDIS_802_11_STATUS_TYPE StatusType;
-} NDIS_802_11_STATUS_INDICATION, *PNDIS_802_11_STATUS_INDICATION;
-
-// mask for authentication/integrity fields
-#define NDIS_802_11_AUTH_REQUEST_AUTH_FIELDS        0x0f
-#define NDIS_802_11_AUTH_REQUEST_REAUTH			0x01
-#define NDIS_802_11_AUTH_REQUEST_KEYUPDATE		0x02
-#define NDIS_802_11_AUTH_REQUEST_PAIRWISE_ERROR		0x06
-#define NDIS_802_11_AUTH_REQUEST_GROUP_ERROR		0x0E
-
-// MIC check time, 60 seconds.
-#define MIC_CHECK_TIME	60000000
-
-typedef struct _NDIS_802_11_AUTHENTICATION_EVENT {
-	NDIS_802_11_STATUS_INDICATION       Status;
-	NDIS_802_11_AUTHENTICATION_REQUEST  Request[1];
-} NDIS_802_11_AUTHENTICATION_EVENT, *PNDIS_802_11_AUTHENTICATION_EVENT;
-
-typedef struct _NDIS_802_11_TEST {
-	u32 Length;
-	u32 Type;
-	union {
-		NDIS_802_11_AUTHENTICATION_EVENT AuthenticationEvent;
-		NDIS_802_11_RSSI RssiTrigger;
-	} tt;
-} NDIS_802_11_TEST, *PNDIS_802_11_TEST;
-
-typedef struct _WLAN_PHY_INFO {
-	u8	SignalStrength;		//(in percentage)
-	u8	SignalQuality;		//(in percentage)
-	u8	Optimum_antenna;  	//for Antenna diversity
-	u8  	Reserved_0;
-#ifdef CONFIG_IEEE80211K
-	u8	is_cck_rate;	/* 1:cck_rate */
-	s8	rx_snr[4];
-	u32	free_cnt; 	/* freerun counter */
-#endif
-}
-#ifdef __CC_ARM
-__attribute__((packed))
-#endif
-WLAN_PHY_INFO, *PWLAN_PHY_INFO;
-
-typedef struct _WLAN_BCN_INFO {
-	/* these infor get from rtw_get_encrypt_info when
-	 * 	 * translate scan to UI */
-	u8	encryp_protocol;	//ENCRYP_PROTOCOL_E: OPEN/WEP/WPA/WPA2/WAPI
-	int	group_cipher;		//WPA/WPA2 group cipher
-	int	pairwise_cipher;	//WPA/WPA2/WEP pairwise cipher
-	int	is_8021x;
-	u8 is_1M_beacon;		// check if the beacon uses 1M data rate
-
-	/* bwmode 20/40 and ch_offset UP/LOW */
-	unsigned short 	ht_cap_info;
-	unsigned char	ht_info_infos_0;
-} WLAN_BCN_INFO, *PWLAN_BCN_INFO;
-
-#ifdef CONFIG_MBSSID_AX
-#define MAX_VIRTUAL_AP_NUM	8
-typedef struct _mbssid_virtual_ap_info {
-	u8					bssid_idx;	// from bssid-index ie
-	NDIS_802_11_SSID	Ssid;		//from ssid ie
-} mbssid_virtual_ap_info_t;
-
-typedef struct _mbssid_info {
-	u8 mbssid_enable;	// AP support mbssid
-	u8 mbssid_complete;	// MBSSID element carriy complete non-transmitted BSSID profile
-	u8 mbssid_ema;		//enhanced MBSSID advertisement
-	u8 bssid_max;		//max_bssid_indicator
-	u8 bssid_ref[6];		// transmitted-BSSID
-	u8 virtual_ap_num;	// num of non-transmitted BSSID
-	u8 bssid_idx_to_join;	//bssid index of non-transmitted BSSID to join
-	u8 is_virtual_ap;		// 1: ap to join is non-transmitted
-	mbssid_virtual_ap_info_t virtual_ap_info[MAX_VIRTUAL_AP_NUM]; 	// store non-transmitted BSSID profile
-	u8 *mbssid_ie; 		//start with non-transmitted BSSID profile
-	u16 mbssid_ie_len;
-} mbssid_info_t;
-#endif
-
-/* temporally add #pragma pack for structure alignment issue of
-*   WLAN_BSSID_EX and get_WLAN_BSSID_EX_sz()
-*/
-#ifdef RTW_PACK_STRUCT_USE_INCLUDES
-#  include "pack_begin.h"
-#endif
-
-typedef struct _WLAN_BSSID_EX {
-	u32					Length;
-	u8					MacAddress[6];
-#ifdef CONFIG_MBSSID_AX
-	mbssid_info_t mbssid_info;
-#endif
-
-	u8					Reserved[2];		//[0]: IS beacon frame
-	NDIS_802_11_SSID			Ssid;
-	u32					Privacy;
-	NDIS_802_11_RSSI			Rssi;			//(in dBM,raw data ,get from PHY)
-	NDIS_802_11_NETWORK_TYPE		NetworkTypeInUse;
-	NDIS_802_11_CONFIGURATION		Configuration;
-	NDIS_802_11_NETWORK_INFRASTRUCTURE	InfrastructureMode;
-	NDIS_802_11_RATES_EX  		SupportedRates;
-	WLAN_PHY_INFO				PhyInfo;
-	u32  				IELength;
-	u8  				IEs[MAX_IE_SZ];		//(timestamp, beacon interval, and capability information)
-}
-WLAN_BSSID_EX, *PWLAN_BSSID_EX;
-
-#ifdef RTW_PACK_STRUCT_USE_INCLUDES
-#  include "pack_end.h"
-#endif
-
-
-__inline  static uint get_WLAN_BSSID_EX_sz(WLAN_BSSID_EX *bss)
-{
-#if 0
-	uint t_len;
-
-	t_len = sizeof(u32)
-			+ sizeof(NDIS_802_11_MAC_ADDRESS)
-			+ 2
-			+ sizeof(NDIS_802_11_SSID)
-			+ sizeof(u32)
-			+ sizeof(NDIS_802_11_RSSI)
-			+ sizeof(NDIS_802_11_NETWORK_TYPE)
-			+ sizeof(NDIS_802_11_CONFIGURATION)
-			+ sizeof(NDIS_802_11_NETWORK_INFRASTRUCTURE)
-			+ sizeof(NDIS_802_11_RATES_EX)
-			//all new member add here
-			+ sizeof(WLAN_PHY_INFO)
-			//all new member add here
-			+ sizeof(u32)
-			+ bss->IELength;
-	return t_len;
-#else
-	return (sizeof(WLAN_BSSID_EX) - MAX_IE_SZ + bss->IELength);
-#endif
-}
-
-struct	wlan_network {
-	_list	list;
-	int	network_type;	//refer to ieee80211.h for WIRELESS_11A/B/G
-	int	fixed;			// set to fixed when not to be removed as site-surveying
-	unsigned long	last_scanned; //timestamp for the network
-	int	aid;			//will only be valid when a BSS is joinned.
-	int	join_res;
-	WLAN_BSSID_EX	network; //must be the last item
-	WLAN_BCN_INFO	BcnInfo;
-};
-
-enum VCS_TYPE {
-	NONE_VCS,
-	RTS_CTS,
-	CTS_TO_SELF
-};
-
-
-
-
-#define PWR_CAM 0
-#define PWR_MINPS 1
-#define PWR_MAXPS 2
-#define PWR_UAPSD 3
-#define PWR_VOIP 4
-
-
-enum UAPSD_MAX_SP {
-	NO_LIMIT,
-	TWO_MSDU,
-	FOUR_MSDU,
-	SIX_MSDU
-};
-
-
-#define NUM_PRE_AUTH_KEY 16
-#define NUM_PMKID_CACHE NUM_PRE_AUTH_KEY
-
-/*
-* 	WPA2
-*/
-
-typedef struct _PMKID_CANDIDATE {
-	NDIS_802_11_MAC_ADDRESS BSSID;
-	u32 Flags;
-} PMKID_CANDIDATE, *PPMKID_CANDIDATE;
-
-typedef struct _NDIS_802_11_PMKID_CANDIDATE_LIST {
-	u32 Version;       // Version of the structure
-	u32 NumCandidates; // No. of pmkid candidates
-	PMKID_CANDIDATE CandidateList[1];
-} NDIS_802_11_PMKID_CANDIDATE_LIST, *PNDIS_802_11_PMKID_CANDIDATE_LIST;
-
-
-typedef struct _NDIS_802_11_AUTHENTICATION_ENCRYPTION {
-	NDIS_802_11_AUTHENTICATION_MODE AuthModeSupported;
-	NDIS_802_11_ENCRYPTION_STATUS EncryptStatusSupported;
-
-} NDIS_802_11_AUTHENTICATION_ENCRYPTION, *PNDIS_802_11_AUTHENTICATION_ENCRYPTION;
-
-typedef struct _NDIS_802_11_CAPABILITY {
-	u32  Length;
-	u32  Version;
-	u32  NoOfPMKIDs;
-	u32  NoOfAuthEncryptPairsSupported;
-	NDIS_802_11_AUTHENTICATION_ENCRYPTION AuthenticationEncryptionSupported[1];
-
-} NDIS_802_11_CAPABILITY, *PNDIS_802_11_CAPABILITY;
-
-#endif //#ifndef WLAN_BSSDEF_H_
-
diff --git a/os/board/rtl8720e/src/component/wifi/driver/src/osdep/Make.defs b/os/board/rtl8720e/src/component/wifi/driver/src/core/Make.defs
similarity index 95%
rename from os/board/rtl8720e/src/component/wifi/driver/src/osdep/Make.defs
rename to os/board/rtl8720e/src/component/wifi/driver/src/core/Make.defs
index a09cf2511..c53c2a94a 100644
--- a/os/board/rtl8720e/src/component/wifi/driver/src/osdep/Make.defs
+++ b/os/board/rtl8720e/src/component/wifi/driver/src/core/Make.defs
@@ -49,7 +49,7 @@
 #
 ############################################################################
 
-CSRCS += lwip_intf.c
+CSRCS += rtw_timer.c
 
-DEPPATH += --dep-path component/wifi/driver/src/osdep
-VPATH += :component/wifi/driver/src/osdep
+DEPPATH += --dep-path component/wifi/driver/src/core
+VPATH += :component/wifi/driver/src/core
diff --git a/os/board/rtl8720e/src/component/wifi/driver/src/core/option/rtw_opt_crypto_ssl.h b/os/board/rtl8720e/src/component/wifi/driver/src/core/option/rtw_opt_crypto_ssl.h
deleted file mode 100644
index a6f2cacf7..000000000
--- a/os/board/rtl8720e/src/component/wifi/driver/src/core/option/rtw_opt_crypto_ssl.h
+++ /dev/null
@@ -1,91 +0,0 @@
-/******************************************************************************
- *
- * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of version 2 of the GNU General Public License as
- * published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
- * more details.
- *
- * You should have received a copy of the GNU General Public License along with
- * this program; if not, write to the Free Software Foundation, Inc.,
- * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
- *
- *
- ******************************************************************************/
-#ifndef __RTW_SAE_CRYPTO_MBEDTLS_H_
-#define __RTW_SAE_CRYPTO_MBEDTLS_H_
-
-#if !defined(MBEDTLS_CONFIG_FILE)
-#include "mbedtls/config.h"
-#else
-#include MBEDTLS_CONFIG_FILE
-#endif
-
-#include "mbedtls/ecp.h"
-#include "mbedtls/sha256.h"
-
-/************************************************************************************************
-
-                  Structure definition
-
-*************************************************************************************************/
-#define sae_ecc_crypto mbedtls_ecp_group
-#define sae_crypto_bignum mbedtls_mpi
-#define sae_ecc_point mbedtls_ecp_point
-
-
-/************************************************************************************************
-
-                  Function Declaration
-
-************************************************************************************************/
-//Initialization Function
-int rtw_platform_set_calloc_free(void *(*calloc_func)(size_t, size_t), void (*free_func)(void *));
-//ECC Alogorithm Function
-int rtw_crypto_ecc_init(sae_ecc_crypto *ecc, unsigned char group_id);
-void rtw_crypto_ecc_free(sae_ecc_crypto *ecc);
-int rtw_crypto_ecc_get_param_a(sae_ecc_crypto *ecc, sae_crypto_bignum *a);
-int rtw_crypto_ecc_get_param_b(sae_ecc_crypto *ecc, sae_crypto_bignum *b);
-int rtw_crypto_ecc_get_param_order(sae_ecc_crypto *ecc, sae_crypto_bignum *n);
-int rtw_crypto_ecc_get_param_prime(sae_ecc_crypto *ecc, sae_crypto_bignum *prime);
-int rtw_crypto_ecc_point_write_bignum(sae_ecc_crypto *ecc, sae_crypto_bignum *x, sae_crypto_bignum *y, sae_ecc_point *p);
-int rtw_crypto_ecc_point_read_bignum(sae_ecc_crypto *ecc, sae_crypto_bignum *x, sae_crypto_bignum *y, sae_ecc_point *p);
-void rtw_crypto_ecc_point_init(sae_ecc_point *point);
-void rtw_crypto_ecc_point_free(sae_ecc_point *point);
-int rtw_crypto_ecc_point_mul_bignum(sae_ecc_crypto *ecc, sae_ecc_point *R, sae_crypto_bignum *m, sae_ecc_point *P);
-int rtw_crypto_ecc_point_add_point(sae_ecc_crypto *ecc, sae_ecc_point *X, sae_ecc_point *A, sae_ecc_point *B);
-int rtw_crypto_ecc_point_is_at_infinity(sae_ecc_point *point);
-int rtw_crypto_ecc_point_is_on_curve(sae_ecc_crypto *ecc, sae_ecc_point *P);
-int rtw_crypto_ecc_point_cmp(sae_ecc_point *P1, sae_ecc_point *P2);
-
-
-//Big number operation and computatio Function
-#define SAE_BIGNUM_CHK(f) do { if( ( ret = f ) != 0 ) goto cleanup; } while( 0 )
-void rtw_crypto_bignum_init(sae_crypto_bignum *X);
-void rtw_crypto_bignum_free(sae_crypto_bignum *X);
-int rtw_crypto_bignum_copy(sae_crypto_bignum *X, sae_crypto_bignum *Y);
-size_t rtw_crypto_bignum_bitlen(sae_crypto_bignum *X);
-size_t rtw_crypto_bignum_get_bit(sae_crypto_bignum *X, size_t pos);
-size_t rtw_crypto_bignum_size(sae_crypto_bignum *X);
-int rtw_crypto_bignum_read_binary(sae_crypto_bignum *X, const unsigned char *buf, size_t buf_len);
-int rtw_crypto_bignum_write_binary(sae_crypto_bignum *X, unsigned char *buf, size_t buf_len);
-int rtw_crypto_bignum_shift_r(sae_crypto_bignum *X, size_t count);
-int rtw_crypto_bignum_cmp_bignum(sae_crypto_bignum *X, sae_crypto_bignum *Y);
-int rtw_crypto_bignum_cmp_int(sae_crypto_bignum *X, int z);
-int rtw_crypto_bignum_add_bignum(sae_crypto_bignum *X, sae_crypto_bignum *A, sae_crypto_bignum *B);
-int rtw_crypto_bignum_add_int(sae_crypto_bignum *X, sae_crypto_bignum *A, int b);
-int rtw_crypto_bignum_sub_bignum(sae_crypto_bignum *X, sae_crypto_bignum *A, sae_crypto_bignum *B);
-int rtw_crypto_bignum_sub_int(sae_crypto_bignum *X, sae_crypto_bignum *A, int b);
-int rtw_crypto_bignum_div_bignum(sae_crypto_bignum *Q, sae_crypto_bignum *R, sae_crypto_bignum *A, sae_crypto_bignum *B);
-int rtw_crypto_bignum_mod_bignum(sae_crypto_bignum *X, sae_crypto_bignum *A, sae_crypto_bignum *N);
-int rtw_crypto_bignum_add_mod(sae_crypto_bignum *X, sae_crypto_bignum *A, sae_crypto_bignum *B, sae_crypto_bignum *N);
-int rtw_crypto_bignum_mul_mod(sae_crypto_bignum *X, sae_crypto_bignum *A, sae_crypto_bignum *B, sae_crypto_bignum *N);
-int rtw_crypto_bignum_exp_mod(sae_crypto_bignum *X, sae_crypto_bignum *A, sae_crypto_bignum *B, sae_crypto_bignum *N);
-int rtw_crypto_bignum_assign(sae_crypto_bignum *X, sae_crypto_bignum *Y, unsigned char inv);
-int rtw_crypto_bignum_inverse(sae_crypto_bignum *X, sae_crypto_bignum *A, sae_crypto_bignum *N);
-#endif
diff --git a/os/board/rtl8720e/src/component/wifi/driver/src/core/option/rtw_opt_skbuf.c b/os/board/rtl8720e/src/component/wifi/driver/src/core/option/rtw_opt_skbuf.c
deleted file mode 100644
index be104239b..000000000
--- a/os/board/rtl8720e/src/component/wifi/driver/src/core/option/rtw_opt_skbuf.c
+++ /dev/null
@@ -1,68 +0,0 @@
-#include <section_config.h>
-#include <osdep_service.h>
-#include <skbuff.h>
-
-#define MAX_SKB_BUF_SIZE     1658	// should >= the size in wlan driver
-#define MAX_SKB_BUF_NUM      8
-#define MAX_LOCAL_SKB_NUM    (MAX_SKB_BUF_NUM + 2)
-
-/* DO NOT modify skb_buf and skb_data structure */
-struct skb_buf {
-	struct list_head list;
-	struct sk_buff skb;
-};
-struct skb_data {
-	struct list_head list;
-	unsigned char buf[MAX_SKB_BUF_SIZE];
-	atomic_t ref;
-};
-
-unsigned int nr_xmitframe = MAX_SKB_BUF_NUM;
-unsigned int nr_xmitbuff = MAX_SKB_BUF_NUM;
-int max_local_skb_num = MAX_LOCAL_SKB_NUM;
-int max_skb_buf_num = MAX_SKB_BUF_NUM;
-
-/* DO NOT access skb_pool and skb_data_pool out of wlan driver */
-struct skb_buf skb_pool[MAX_LOCAL_SKB_NUM];
-
-#define SKB_DATA_POOL_USING_GLOBAL_BUF	1
-#if SKB_DATA_POOL_USING_GLOBAL_BUF
-// SRAM_BD_DATA_SECTION default in SRAM. Can modify image2.icf to link to the end of SDRAM
-SECTION(".sdram.bss")
-struct skb_data skb_data_pool[MAX_SKB_BUF_NUM];
-#else
-// Change to use heap (malloc) to save SRAM memory
-SECTION(".sdram.bss")
-struct skb_data *skb_data_pool;
-
-extern struct list_head skbdata_list;
-extern int skbdata_used_num;
-extern int max_skbdata_used_num;
-void init_skb_data_pool(void)
-{
-	int i;
-
-	//printf("\ninit_skb_data_pool\n");
-	skb_data_pool = (struct skb_data *)rtw_zmalloc(max_skb_buf_num * sizeof(struct skb_data));
-	if (!skb_data_pool) {
-		printf("\nskb_data_pool alloc fail\n");
-		return;
-	}
-
-	memset(skb_data_pool, '\0', max_skb_buf_num * sizeof(struct skb_data));
-	INIT_LIST_HEAD(&skbdata_list);
-
-	for (i = 0; i < max_skb_buf_num; i++) {
-		INIT_LIST_HEAD(&skb_data_pool[i].list);
-		list_add_tail(&skb_data_pool[i].list, &skbdata_list);
-	}
-	skbdata_used_num = 0;
-	max_skbdata_used_num = 0;
-}
-
-void deinit_skb_data_pool(void)
-{
-	//printf("\ndeinit_skb_data_pool\n");
-	rtw_mfree((void *)skb_data_pool, MAX_SKB_BUF_NUM * sizeof(struct skb_data));
-}
-#endif
diff --git a/os/board/rtl8720e/src/component/wifi/driver/src/core/option/rtw_opt_skbuf_rtl8720e.c b/os/board/rtl8720e/src/component/wifi/driver/src/core/option/rtw_opt_skbuf_rtl8720e.c
deleted file mode 100644
index 838decc6d..000000000
--- a/os/board/rtl8720e/src/component/wifi/driver/src/core/option/rtw_opt_skbuf_rtl8720e.c
+++ /dev/null
@@ -1,76 +0,0 @@
-#include <osdep_service.h>
-#include <skbuff.h>
-#include <autoconf.h>
-#include <section_config.h>
-
-#ifndef CONFIG_MP_INCLUDED
-
-#ifdef CONFIG_HIGH_TP_TEST
-#define MAX_SKB_BUF_NUM      10
-#define MAX_LOCAL_SKB_NUM    (MAX_SKB_BUF_NUM + 2)
-#define RX_Q_DESC_NUM		4
-#else
-#define MAX_SKB_BUF_NUM      6
-#define MAX_LOCAL_SKB_NUM    (MAX_SKB_BUF_NUM + 2)
-#define RX_Q_DESC_NUM		4
-#endif
-
-unsigned int nr_recvframe = MAX_SKB_BUF_NUM;
-unsigned int nr_xmitframe = MAX_SKB_BUF_NUM;
-unsigned int nr_xmitbuff = MAX_SKB_BUF_NUM;
-int max_local_skb_num = MAX_LOCAL_SKB_NUM;
-int max_skb_buf_num = MAX_SKB_BUF_NUM;
-u8 rxq_desc_num = RX_Q_DESC_NUM;
-
-/* DO NOT modify below structure */
-//----------------------------------------------------------------------------//
-#if WIFI_LOGO_CERTIFICATION
-#define MAX_SKB_BUF_SIZE     4144
-#else
-#define MAX_SKB_BUF_SIZE     1658
-#endif
-
-struct skb_buf {
-	struct list_head list;
-	struct sk_buff skb;
-#if defined(CONFIG_AS_INIC_NP)
-	u8 rsvd[10]; /* keep total size 64B alignment */
-#endif
-};
-
-struct skb_data {
-	/* starting address must be aligned by 32 bytes for km4 cache. */
-	struct list_head list __attribute__((aligned(32)));
-	unsigned char buf[MAX_SKB_BUF_SIZE];
-	/* to protect ref when to invalid cache, its address must be
-	 * aligned by 32 bytes. */
-	atomic_t ref __attribute__((aligned(32)));
-};
-
-
-#if WIFI_LOGO_CERTIFICATION
-#define MAX_RECVBUF_SZ     4598
-#else
-#define MAX_RECVBUF_SZ     2112
-#endif
-
-
-struct rx_ring_pool_t {
-	u8 buf[RX_Q_DESC_NUM][MAX_RECVBUF_SZ];
-} __attribute__((aligned(32)));
-
-struct rx_ring_pool_t rx_ring_pool __attribute__((aligned(32)));
-
-SRAM_NOCACHE_DATA_SECTION
-#ifdef RSICV_CORE_KR4
-//rx_desc size/addr 32 bytes alignment for lite-kr4 cache
-u8 rx_ring_des[RX_Q_DESC_NUM][8] __attribute__((aligned(32)));
-#else
-u8 rx_ring_des[RX_Q_DESC_NUM][8];
-#endif
-//----------------------------------------------------------------------------//
-
-/* DO NOT access skb_pool and skb_data_pool out of wlan driver */
-struct skb_buf skb_pool[MAX_LOCAL_SKB_NUM];
-struct skb_data skb_data_pool[MAX_SKB_BUF_NUM];
-#endif
diff --git a/os/board/rtl8720e/src/component/os/os_dep/timer_service.c b/os/board/rtl8720e/src/component/wifi/driver/src/core/rtw_timer.c
old mode 100644
new mode 100755
similarity index 85%
rename from os/board/rtl8720e/src/component/os/os_dep/timer_service.c
rename to os/board/rtl8720e/src/component/wifi/driver/src/core/rtw_timer.c
index 54c471dbb..877db6ab8
--- a/os/board/rtl8720e/src/component/os/os_dep/timer_service.c
+++ b/os/board/rtl8720e/src/component/wifi/driver/src/core/rtw_timer.c
@@ -3,7 +3,10 @@
  * Copyright(c) 2007 - 2012 Realtek Corporation. All rights reserved.
  *
  ******************************************************************************/
-#include "osdep_service.h"
+#include <basic_types.h>
+#include <osdep_service.h>
+#include <rtw_timer.h>
+#include <rtw_debug.h>
 
 #if( configSUPPORT_STATIC_ALLOCATION == 1 )
 
@@ -43,7 +46,7 @@ static __inline__ void *get_timer_from_poll(struct list_head *phead, int *count)
 
 	*count = *count + 1;
 
-	restore_flags(irq_flags);
+	restore_flags();
 
 	return (unsigned char *)timer;
 }
@@ -56,12 +59,6 @@ static void release_timer_to_poll(unsigned char *buf, struct list_head *phead, i
 
 	*count = *count - 1;
 }
-
-static u8 rtw_get_timer_dynamic_flag(_timerHandle xTimer)
-{
-	StaticTimer_t *ptimer = (StaticTimer_t *)xTimer;
-	return ptimer->ucDummy8;
-}
 #endif
 
 void init_timer_pool(void)
@@ -118,7 +115,6 @@ void deinit_timer_wrapper(void)
 		DBG_ERR("Need to delete %d timer_entry", timer_used_num);
 	}
 
-
 	unsigned int irq_flags = save_and_cli();
 
 	while (rtw_end_of_queue_search(&timer_table, get_next(&timer_table)) == _FALSE) {
@@ -136,8 +132,6 @@ void timer_wrapper(_timerHandle timer_hdl)
 	_list *plist;
 	struct timer_list *timer_entry = NULL;
 
-	DBG_TRACE("%s is called", __FUNCTION__);
-
 	unsigned int irq_flags = save_and_cli();
 
 	plist = get_next(&timer_table);
@@ -175,7 +169,7 @@ void init_timer(struct timer_list *timer)
 		if (timerbuf == NULL) {
 			if (timerpool_flag) {
 				timer_dynamic_num++;
-				printf("static timer is not avaliable. timerbuf_used_num: %d\n", timerbuf_used_num);
+				//printf("static timer is not avaliable. timerbuf_used_num: %d\n", timerbuf_used_num);
 			}
 			goto exit1;
 		} else {
@@ -188,7 +182,7 @@ void init_timer(struct timer_list *timer)
 								   (TimerCallbackFunction_t)timer_wrapper,		// Timer callback
 								   timerbuf		// The buffer that will hold the software timer structure.
 							   );
-
+			timer->statically_alloc = 1;
 		}
 
 		if (timerbuf_used_num > max_timerbuf_used_num) {
@@ -198,6 +192,7 @@ void init_timer(struct timer_list *timer)
 		goto exit2;
 exit1:
 #endif
+
 		timer->timer_hdl = rtw_timerCreate(
 							   (signed const char *)"Timer", 		// Just a text name, not used by the RTOS kernel.
 							   TIMER_MAX_DELAY,		// Timer Period, not 0
@@ -205,6 +200,7 @@ exit1:
 							   NULL,			// Uniq id used to identify which timer expire..
 							   timer_wrapper		// Timer callback
 						   );
+		timer->statically_alloc = 0;
 #if ( configSUPPORT_STATIC_ALLOCATION == 1 )
 exit2:
 #endif
@@ -228,45 +224,16 @@ exit2:
 void mod_timer(struct timer_list *timer, u32 delay_time_ms)
 {
 	if (timer->timer_hdl == NULL) {
-		timer->timer_hdl = rtw_timerCreate(
-							   (signed const char *)"Timer", 		// Just a text name, not used by the RTOS kernel.
-							   TIMER_MAX_DELAY,		// Timer Period, not 0
-							   _FALSE,		// Whether timer will auto-load themselves when expires
-							   NULL,			// Uniq id used to identify which timer expire..
-							   timer_wrapper		// Timer callback
-						   );
-						   
-		if (timer->timer_hdl == NULL) {
-			DBG_ERR("Fail to init timer");
-		} else {
-			unsigned int irq_flags = save_and_cli();
-			rtw_list_insert_head(&timer->list, &timer_table);
-			restore_flags(irq_flags);
-
-			timer_used_num ++;
-			if (timer_used_num > max_timer_used_num) {
-				max_timer_used_num = timer_used_num;
-			}
-		}
+		DBG_ERR("mod_timer: the timer is not init, need init first");
 	} else if (rtw_timerIsTimerActive(timer->timer_hdl) == _TRUE) {
 		rtw_timerStop(timer->timer_hdl, TIMER_MAX_DELAY);
 	}
 
 	//Set Timer period
-	if (timer->timer_hdl != NULL){
+	if (timer->timer_hdl != NULL)
 		if (rtw_timerChangePeriod(timer->timer_hdl, rtw_ms_to_systime(delay_time_ms), TIMER_MAX_DELAY) == _FAIL) {
 			DBG_ERR("Fail to set timer period");
 		}
-	}
-}
-
-int timer_pending(const struct timer_list *timer)
-{
-	if (timer->timer_hdl != NULL) {
-		return 1;
-	} else {
-		return 0;
-	}
 }
 
 void  cancel_timer_ex(struct timer_list *timer)
@@ -292,7 +259,7 @@ void  cancel_timer_ex(struct timer_list *timer)
 	restore_flags(irq_flags);
 
 	if (plist == &timer_table) {
-		DBG_TRACE("Fail to find the timer_entry(%08X) in timer table", timer->timer_hdl);
+		RTW_INFO("Fail to find the timer_entry(%08X) in timer table", timer->timer_hdl);
 	} else {
 		rtw_timerStop(timer->timer_hdl, TIMER_MAX_DELAY);
 	}
@@ -307,7 +274,7 @@ void  del_timer_sync(struct timer_list *timer)
 		return;
 	}
 #if ( configSUPPORT_STATIC_ALLOCATION == 1 )
-	if (rtw_get_timer_dynamic_flag(timer->timer_hdl)) {
+	if (timer->statically_alloc) {
 		unsigned int irq_flags = save_and_cli();
 		release_timer_to_poll((unsigned char *)timer->timer_hdl, &wrapper_timerbuf_list, &timerbuf_used_num);
 		restore_flags(irq_flags);
diff --git a/os/board/rtl8720e/src/component/wifi/driver/src/core/wifi_performance_monitor.c b/os/board/rtl8720e/src/component/wifi/driver/src/core/wifi_performance_monitor.c
old mode 100644
new mode 100755
index da45ebda0..5b2bdcd5c
--- a/os/board/rtl8720e/src/component/wifi/driver/src/core/wifi_performance_monitor.c
+++ b/os/board/rtl8720e/src/component/wifi/driver/src/core/wifi_performance_monitor.c
@@ -1,4 +1,24 @@
-#include "wifi_performance_monitor.h"
+#include <rtw_adapter.h>
+#include "wifi_hal.h"
+
+#ifndef CONFIG_AS_INIC_AP
+#if PHYDM_VERSION == 3
+#ifdef CONFIG_RTL8720E
+#define RF_8720E_SUPPORT
+#define RF_5G_NOT_SUPPORT
+#endif
+#ifdef CONFIG_RTL8730E
+#define RF_8730E_SUPPORT
+#endif
+#define RF_6G_NOT_SUPPORT
+#define RF_MULTIPATH_NOT_SUPPORT
+#define RF_BW_20M_ONLY
+#define IOT_SMALL_RAM
+#define RF_NONBF
+#include "halrf_precomp.h"
+#include "halbb_precomp.h"
+#endif
+#endif
 
 #ifdef WIFI_PERFORMANCE_MONITOR
 struct WIFI_TIME wifi_time_test;
@@ -49,8 +69,8 @@ void wifi_performance_print()
 	printf("recv_func_time: %d us \n\r", wifi_time_result.recv_func_time);
 	printf("recv_func_prehandle: %d us \n\r", wifi_time_result.recv_func_prehandle_time);
 	printf("validate_recv_frame: %d, validate_recv_data_frame: %d us \n\r", wifi_time_result.validate_recv_frame_time, wifi_time_result.validate_recv_frame_time1);
-	printf("recv_func_posthandle: %d,  decryptor: %d, portctrl: %d, count_rx_ststs: %d us \n\r", wifi_time_result.recv_func_posthandle_time,
-		   wifi_time_result.recv_func_posthandle_time1, wifi_time_result.recv_func_posthandle_time2, wifi_time_result.recv_func_posthandle_time3);
+	printf("recv_func_posthandle: %d,  decryptor: %d, count_rx_ststs: %d us \n\r", wifi_time_result.recv_func_posthandle_time,
+		   wifi_time_result.recv_func_posthandle_time1,  wifi_time_result.recv_func_posthandle_time3);
 	printf("Process_recv_indicatepkts: %d us \n\r", wifi_time_result.process_recv_indicatepkts_time);
 	printf("rtw_recv_indicatpkt: %d us \n\r", wifi_time_result.rtw_recv_indicatept_time);
 	printf("rltk_netif_rx: %d us \n\r", wifi_time_result.rltk_netif_rx_time);
@@ -79,10 +99,60 @@ void wifi_performance_print()
 	printf("rtw_xmit_data: %d us \n\r",   wifi_time_result.xmit_data_time);
 	printf("pre_xmitframe: %d, check_nic: %d, alloc_xmitbuf: %d us \n\r",   wifi_time_result.pre_xmitframe_time,   wifi_time_result.pre_xmitframe_time1,
 		   wifi_time_result.pre_xmitframe_time2);
-	printf("xmitframe_direct: %d us \n\r",   wifi_time_result.xmitframe_direct_time);
+	printf("wifi_hal_xmitframe_direct: %d us \n\r",   wifi_time_result.xmitframe_direct_time);
 	printf("xmitframe_coalesce: %d us \n\r",   wifi_time_result.xmitframe_coalesce_time);
 	printf("dump_xframe: %d us \n\r",   wifi_time_result.dump_xframe_time);
 #endif
 }
 #endif //WIFI_PERFORMANCE_MONITOR
+#ifndef CONFIG_AS_INIC_AP
+static u32 wifi_size_cal(char *name, u32 num, u32 size, u8 is_struct)
+{
+	static u32 total = 0;
+	u32 task_tcb_sz = 0;
+	u32 temp = 0;
+
+	temp = size;
+	if (is_struct) {
+		size = N_BYTE_ALIGMENT((size * num), portBYTE_ALIGNMENT) + portBYTE_ALIGNMENT;
+	} else { /*thread*/
+		if (portBYTE_ALIGNMENT == 32) {
+			task_tcb_sz = 192;
+		} else if (portBYTE_ALIGNMENT == 64) {
+			task_tcb_sz = 256;
+		}
+		size = size * 4 + task_tcb_sz;
+	}
+	total += size;
+	printf("%-25s %-8d \r%-8d \r%-8d\n", name, temp, num, size);
+	return total;
+}
+
+u32 wifi_heap_size_printt(void)
+{
+	u32 total;
+
+	total = wifi_size_cal("skb_info", skbpriv.skb_info_num, sizeof(struct skb_info), 1);
+	total = wifi_size_cal("skb_data", skbpriv.skb_data_num, sizeof(struct skb_data), 1);
+	total = wifi_size_cal("recv_frame", skbpriv.skb_data_num, sizeof(union recv_frame), 1);
+	total = wifi_size_cal("xmit_frame", nr_xmitframe, sizeof(struct xmit_frame), 1);
+	total = wifi_size_cal("xmit_buf", skbpriv.skb_data_num, sizeof(struct xmit_buf), 1);
+	total = wifi_size_cal("xmit_buf ext", NR_XMIT_EXTBUFF, sizeof(struct xmit_buf), 1);
+	total = wifi_size_cal("bcmc sta_info", 1, (sizeof(struct sta_info)), 1);
+#if PHYDM_VERSION == 3
+	total = wifi_size_cal("bcmc rtw_phl_stainfo_t", 1, (sizeof(struct rtw_phl_stainfo_t)), 1);
+	total = wifi_size_cal("bcmc rtw_hal_stainfo_t", 1, (sizeof(struct rtw_hal_stainfo_t)), 1);
+	total = wifi_size_cal("bb_info", 1, sizeof(struct bb_info), 1);
+	total = wifi_size_cal("bb_cmn_info", 1, sizeof(struct bb_cmn_info), 1);
+	total = wifi_size_cal("rf_info", 1, sizeof(struct rf_info), 1);
+#endif
+	/*threads*/
+	total = wifi_size_cal("single_thread", 1, RECV_TASKLET_STACKSIZE, 0);
+	total = wifi_size_cal("little_stack_thread", 1, LITTLE_STACKSIZE, 0);
+#if defined (CONFIG_WOWLAN) && defined (CONFIG_FW_DRIVER_COEXIST) && CONFIG_FW_DRIVER_COEXIST
+	total = wifi_size_cal("resume_thread", 1, DRIVER_RESUME_TASK_STACKSIZE, 0);
+#endif
+	return total;
+}
 
+#endif
diff --git a/os/board/rtl8720e/src/component/wifi/driver/src/hal/hal_com_c2h.h b/os/board/rtl8720e/src/component/wifi/driver/src/hal/hal_com_c2h.h
deleted file mode 100644
index 51528c172..000000000
--- a/os/board/rtl8720e/src/component/wifi/driver/src/hal/hal_com_c2h.h
+++ /dev/null
@@ -1,113 +0,0 @@
-/******************************************************************************
- *
- * Copyright(c) 2007 - 2012 Realtek Corporation. All rights reserved.
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of version 2 of the GNU General Public License as
- * published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
- * more details.
- *
- * You should have received a copy of the GNU General Public License along with
- * this program; if not, write to the Free Software Foundation, Inc.,
- * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
- *
- *
- ******************************************************************************/
-#ifndef __COMMON_C2H_H__
-#define __COMMON_C2H_H__
-
-#define C2H_TYPE_REG 0
-#define C2H_TYPE_PKT 1
-
-/*
-* C2H event format:
-* Fields    TRIGGER    PAYLOAD    SEQ    PLEN    ID
-* BITS     [127:120]    [119:16]   [15:8]  [7:4]  [3:0]
-*/
-#define C2H_ID(_c2h)		LE_BITS_TO_1BYTE(((u8*)(_c2h)), 0, 4)
-#define C2H_PLEN(_c2h)		LE_BITS_TO_1BYTE(((u8*)(_c2h)), 4, 4)
-#define C2H_SEQ(_c2h)		LE_BITS_TO_1BYTE(((u8*)(_c2h)) + 1, 0, 8)
-#define C2H_PAYLOAD(_c2h)	(((u8*)(_c2h)) + 2)
-
-#define SET_C2H_ID(_c2h, _val)		SET_BITS_TO_LE_1BYTE(((u8*)(_c2h)), 0, 4, _val)
-#define SET_C2H_PLEN(_c2h, _val)	SET_BITS_TO_LE_1BYTE(((u8*)(_c2h)), 4, 4, _val)
-#define SET_C2H_SEQ(_c2h, _val)		SET_BITS_TO_LE_1BYTE(((u8*)(_c2h)) + 1 , 0, 8, _val)
-
-/*
-* C2H event format:
-* Fields    TRIGGER     PLEN      PAYLOAD    SEQ      ID
-* BITS    [127:120]  [119:112]  [111:16]   [15:8]   [7:0]
-*/
-#define C2H_ID_88XX(_c2h)		LE_BITS_TO_1BYTE(((u8*)(_c2h)), 0, 8)
-#define C2H_SEQ_88XX(_c2h)		LE_BITS_TO_1BYTE(((u8*)(_c2h)) + 1, 0, 8)
-#define C2H_PAYLOAD_88XX(_c2h)	(((u8*)(_c2h)) + 2)
-#define C2H_PLEN_88XX(_c2h)		LE_BITS_TO_1BYTE(((u8*)(_c2h)) + 14, 0, 8)
-#define C2H_TRIGGER_88XX(_c2h)	LE_BITS_TO_1BYTE(((u8*)(_c2h)) + 15, 0, 8)
-
-#define SET_C2H_ID_88XX(_c2h, _val)		SET_BITS_TO_LE_1BYTE(((u8*)(_c2h)), 0, 8, _val)
-#define SET_C2H_SEQ_88XX(_c2h, _val)	SET_BITS_TO_LE_1BYTE(((u8*)(_c2h)) + 1, 0, 8, _val)
-#define SET_C2H_PLEN_88XX(_c2h, _val)	SET_BITS_TO_LE_1BYTE(((u8*)(_c2h)) + 14, 0, 8, _val)
-
-typedef enum _C2H_EVT {
-	C2H_DBG = 0x00,
-	C2H_LB = 0x01,
-	C2H_TXBF = 0x02,
-	C2H_CCX_TX_RPT = 0x03,
-	C2HID_AP_REQ_TXRPT = 0x04,
-	C2H_FW_SCAN_COMPLETE = 0x7,
-	C2H_BT_INFO = 0x09,
-	C2H_BT_MP_INFO = 0x0B,
-	C2H_RA_RPT = 0x0C,
-	C2HID_SPE_STATIS = 0x0D,
-	C2H_RA_PARA_RPT = 0x0E,
-	C2H_FW_CHNL_SWITCH_COMPLETE = 0x10,
-	C2H_IQK_FINISH = 0x11,
-	C2H_MAILBOX_STATUS = 0x15,
-	C2H_P2P_RPORT = 0x16,
-	C2H_MCC = 0x17,
-	C2H_MAC_HIDDEN_RPT = 0x19,
-	C2H_MAC_HIDDEN_RPT_2 = 0x1A,
-	C2H_BCN_EARLY_RPT = 0x1E,
-	C2H_DEFEATURE_DBG = 0x22,
-	C2H_TSF_RPT = 0x24,
-	C2H_WLAN_INFO = 0x27,
-#if defined(CONFIG_UNSUPPORT_PLCPHDR_RPT) && (CONFIG_UNSUPPORT_PLCPHDR_RPT)
-	C2H_PLCPHDR_RPT = 0x2B,
-#endif
-	C2H_DEFEATURE_RSVD = 0xFD,
-	C2H_EXTEND = 0xff,
-} C2H_EVT;
-
-typedef enum _EXTEND_C2H_EVT {
-	EXTEND_C2H_DBG_PRINT = 0
-} EXTEND_C2H_EVT;
-
-#define C2H_REG_LEN 16
-
-/* C2H_IQK_FINISH, 0x11 */
-#define IQK_OFFLOAD_LEN 1
-void c2h_iqk_offload(_adapter *adapter, u8 *data, u8 len);
-int	c2h_iqk_offload_wait(_adapter *adapter, u32 timeout_ms);
-#define rtl8812_iqk_wait c2h_iqk_offload_wait /* TODO: remove this after phydm call c2h_iqk_offload_wait instead */
-
-#ifdef CONFIG_RTW_MAC_HIDDEN_RPT
-/* C2H_MAC_HIDDEN_RPT, 0x19 */
-#define MAC_HIDDEN_RPT_LEN 8
-int c2h_mac_hidden_rpt_hdl(_adapter *adapter, u8 *data, u8 len);
-
-/* C2H_MAC_HIDDEN_RPT_2, 0x1A */
-#define MAC_HIDDEN_RPT_2_LEN 5
-int c2h_mac_hidden_rpt_2_hdl(_adapter *adapter, u8 *data, u8 len);
-int hal_read_mac_hidden_rpt(_adapter *adapter);
-#endif /* CONFIG_RTW_MAC_HIDDEN_RPT */
-
-/* C2H_DEFEATURE_DBG, 0x22 */
-#define DEFEATURE_DBG_LEN 1
-int c2h_defeature_dbg_hdl(_adapter *adapter, u8 *data, u8 len);
-
-int c2h_tsf_rpt_hdl(_adapter *adapter, u8 *data, u8 len);
-#endif /* __COMMON_C2H_H__ */
diff --git a/os/board/rtl8720e/src/component/wifi/driver/src/hal/hal_data.h b/os/board/rtl8720e/src/component/wifi/driver/src/hal/hal_data.h
deleted file mode 100644
index 18456e331..000000000
--- a/os/board/rtl8720e/src/component/wifi/driver/src/hal/hal_data.h
+++ /dev/null
@@ -1,469 +0,0 @@
-#ifndef __HAL_DATA_H__
-#define __HAL_DATA_H__
-
-
-#include "hal_com.h"
-#if (PHYDM_VERSION == 2)
-#include "phydm/phydm_precomp.h"
-#endif
-
-#ifdef CONFIG_RTL8721D
-#include "rtl8721d_hal.h"
-#endif
-
-#ifdef CONFIG_RTL8721F
-#include "rtl8721f_hal.h"
-#endif
-
-#ifdef CONFIG_RTL8730A
-#include "rtl8730a_hal.h"
-#endif
-
-#ifdef CONFIG_RTL8730E
-#include "rtl8730e_hal.h"
-#endif
-
-#ifdef CONFIG_RTL8720E
-#include "rtl8720e_hal.h"
-#endif
-
-#ifdef CONFIG_RTL8195B
-#include "rtl8195b/rtl8195b_hal.h"
-#endif
-
-#ifdef CONFIG_RTL8710C
-#include "rtl8710c/rtl8710c_hal.h"
-#endif
-
-#ifdef CONFIG_RTL8735B
-#include "rtl8735b/rtl8735b_hal.h"
-#endif
-
-enum _EFUSE_DEF_TYPE {
-	TYPE_EFUSE_MAX_SECTION				= 0,
-	TYPE_EFUSE_REAL_CONTENT_LEN			= 1,
-	TYPE_AVAILABLE_EFUSE_BYTES_BANK		= 2,
-	TYPE_AVAILABLE_EFUSE_BYTES_TOTAL	= 3,
-	TYPE_EFUSE_MAP_LEN					= 4,
-	TYPE_EFUSE_PROTECT_BYTES_BANK		= 5,
-	TYPE_EFUSE_CONTENT_LEN_BANK			= 6,
-	TYPE_EFUSE_REMAIN_LEN				= 7,
-};
-//
-// <Roger_Notes> For RTL8723 WiFi/BT/GPS multi-function configuration. 2010.10.06.
-//
-typedef enum _RT_MULTI_FUNC {
-	RT_MULTI_FUNC_NONE	= 0x00,
-	RT_MULTI_FUNC_WIFI 	= 0x01,
-	RT_MULTI_FUNC_BT 		= 0x02,
-	RT_MULTI_FUNC_GPS 	= 0x04,
-} RT_MULTI_FUNC, *PRT_MULTI_FUNC;
-//
-// <Roger_Notes> For RTL8723 WiFi PDn/GPIO polarity control configuration. 2010.10.08.
-//
-typedef enum _RT_POLARITY_CTL {
-	RT_POLARITY_LOW_ACT 	= 0,
-	RT_POLARITY_HIGH_ACT 	= 1,
-} RT_POLARITY_CTL, *PRT_POLARITY_CTL;
-
-// For RTL8723 regulator mode. by tynli. 2011.01.14.
-typedef enum _RT_REGULATOR_MODE {
-	RT_SWITCHING_REGULATOR 	= 0,
-	RT_LDO_REGULATOR 			= 1,
-} RT_REGULATOR_MODE, *PRT_REGULATOR_MODE;
-
-// Tx Power Limit Table Size
-#define MAX_REGULATION_NUM						TXPWR_LMT_MAX_REGULATION_NUM
-#define MAX_2_4G_BANDWITH_NUM					2 // 20M, 40M
-#if defined(NOT_SUPPORT_RF_MULTIPATH) && (!defined(CONFIG_80211AC_VHT))
-#define MAX_RATE_SECTION_NUM					3 // CCk, OFDM, HT
-#define MAX_BASE_NUM_IN_PHY_REG_PG_2_4G			3 //  CCK:1,OFDM:1, HT:1(MCS0_MCS7)
-#else
-#define MAX_RATE_SECTION_NUM					10
-#define MAX_BASE_NUM_IN_PHY_REG_PG_2_4G			10 //  CCK:1,OFDM:1, HT:4, VHT:4
-#endif
-#define MAX_5G_BANDWITH_NUM						4
-#define MAX_BASE_NUM_IN_PHY_REG_PG_5G			9 // OFDM:1, HT:4, VHT:4
-
-#define PAGE_SIZE_128	128
-#define PAGE_SIZE_256	256
-#define PAGE_SIZE_512	512
-
-#define HCI_SUS_ENTER		0
-#define HCI_SUS_LEAVING		1
-#define HCI_SUS_LEAVE		2
-#define HCI_SUS_ENTERING	3
-#define HCI_SUS_ERR			4
-
-//efuse
-#define	EFUSE_WIFI				0
-#define 	EFUSE_MAP_SIZE			512
-
-#if (PHYDM_VERSION == 2)
-//structure
-#define DM_ODM_T struct dm_struct
-#define PDM_ODM_T struct dm_struct*
-#define DIG_T struct phydm_dig_struct
-#define pDIG_T struct phydm_dig_struct*
-#define pFAT_T struct phydm_fat_struct*
-#endif
-
-typedef struct _BB_INIT_REGISTER {
-	u16	offset;
-	u32	value;
-
-} BB_INIT_REGISTER, *PBB_INIT_REGISTER;
-
-struct 	dm_priv {
-	u32	InitODMFlag;
-	//* Upper and Lower Signal threshold for Rate Adaptive*/
-	int	UndecoratedSmoothedPWDB;
-	int	UndecoratedSmoothedCCK;
-	int	EntryMinUndecoratedSmoothedPWDB;
-	int	EntryMaxUndecoratedSmoothedPWDB;
-	int	MinUndecoratedPWDBForDM;
-	int	LastMinUndecoratedPWDBForDM;
-	u8	PowerIndex_backup[6];
-};
-
-#ifdef CONFIG_CSI
-struct csi_priv {
-	struct rx_csi_pool *csi_pool;  /* csi buffer pool */
-	struct rx_csi_data *handing_buf;  /* handing csi packet */
-	u8 csi_handle_flag;  /* 0: wait new csi; 1: handling curr csi */
-	u16 per_macid_csi_en;  /* latch per sta csi en or dis, bitx indicate macid=x*/
-	u8 num_csi_sta;  /* record the number of sta which en csi*/
-	u8 num_bit_per_tone;
-	u16 num_sub_carrier;
-};
-#endif /* CONFIG_CSI */
-
-struct hal_spec_t {
-	char *ic_name;
-	u8 macid_num;
-
-	u8 sec_cam_ent_num;
-	u8 sec_cap;
-
-	u8 rfpath_num_2g: 4;	/* used for tx power index path */
-	u8 rfpath_num_5g: 4;	/* used for tx power index path */
-
-	u8 max_tx_cnt;
-	u8 tx_nss_num: 4;
-	u8 rx_nss_num: 4;
-	u8 band_cap;	/* value of BAND_CAP_XXX */
-	u8 bw_cap;		/* value of BW_CAP_XXX */
-	u8 port_num;
-	u8 proto_cap;	/* value of PROTO_CAP_XXX */
-	u8 wl_func;		/* value of WL_FUNC_XXX */
-	u8 hci_type;	/* value of HCI Type */
-#if (PHYDM_VERSION == 3)
-	struct protocol_cap_t protocol_cap;
-#endif
-
-	u16 max_ampdu_buffer_size;
-};
-
-#ifdef RTW_HALMAC
-struct phy_spec_t {
-	u32 trx_cap;
-	u32 stbc_cap;
-	u32 ldpc_cap;
-	u32 txbf_param;
-	u32 txbf_cap;
-};
-#endif
-
-typedef struct hal_com_data {
-	struct rtw_hal_com_t	hal_com;	/*shared with ax submodules*/
-#if (PHYDM_VERSION == 3)
-	void			*bb;		/*ax halbb, useless for phydm*/
-	void			*rf;		/*ax halrf, useless for phydm*/
-#elif (PHYDM_VERSION == 2)
-	struct dm_priv		dmpriv;
-	DM_ODM_T 		odmpriv;
-#endif
-#ifdef CONFIG_CSI
-	struct csi_priv		csipriv;
-#endif
-	HAL_VERSION		VersionID;
-	/* current WIFI_PHY values */
-
-	u16			BasicRateSet;
-	u8			tx_rate_ToS_cfg;	/* 8 bit control 8 ToS type */
-	u8			tx_rate_by_ToS[8];	/*record different ToS's tx rate which configured by user */
-
-#ifdef RTW_HALMAC
-	struct phy_spec_t	phy_spec;
-#endif
-	u8			rf_type;
-#if defined(CONFIG_RTL8721F) || defined(CONFIG_RTL8721D)
-	u32			ChipID;
-#endif
-	u8			NumTotalRFPath;
-	u8			EEPROMRegulatory;
-
-#if ((PHYDM_VERSION == 2) || (PHYDM_VERSION == 3))
-	u8			eeprom_thermal_meter;
-#endif
-
-	u8			Regulation2_4G;
-#if defined(SUPPORT_5G_CHANNEL)
-	u8			Regulation5G;
-#endif
-
-	/* PHY DM & DM Section */
-	_lock			IQKSpinLock;
-	u8			bNeedIQK;
-	u32			AcParam_BE; //Original parameter for BE, use for EDCA turbo.
-
-#if defined(CONFIG_RTL8721D)
-#if defined(NOT_SUPPORT_RF_MULTIPATH)
-	BB_REGISTER_DEFINITION_T	PHYRegDef[1];	//Radio A
-	u32	RfRegChnlVal[1];
-#else
-	BB_REGISTER_DEFINITION_T	PHYRegDef[4];	//Radio A/B/C/D
-	u32	RfRegChnlVal[2];
-#endif // NOT_SUPPORT_RF_MULTIPATH
-#endif // CONFIG_RTL8721D
-
-	/* for host message to fw */
-	u8			LastHMEBoxNum;
-
-#ifdef CONFIG_BT_COEXIST
-	u8			ant_path; /* for 8730E BT s0/s1 selection	 */
-	u8			EEPROMBluetoothCoexist;
-	u8			EEPROMBluetoothType;
-	u8			EEPROMBluetoothAntNum;
-	/* Upper and Lower Signal threshold for Rate Adaptive*/
-	int			entry_min_undecorated_smoothed_pwdb;
-#endif
-
-#ifdef CONFIG_BT_COEXIST_SOC
-	u8			EEPROMBluetoothCoexist;
-#endif
-
-	u8			CurAntenna;
-	u8			AntDivCfg;
-	u8			AntDivGPIO;
-	u8			AMPDUDensity;
-
-	// Auto FSM to Turn On, include clock, isolation, power control for MAC only
-	u8			bMacPwrCtrlOn;
-#if defined(CONFIG_AXI_HCI)
-	u32			IntArray[4];
-	u32			IntrMask[4];
-#else
-	u32			IntArray[3];
-	u32			IntrMask[3];
-#endif
-
-	u16			RxExpectTag;
-
-	struct hal_spec_t	hal_spec;
-
-#ifdef RTW_HALMAC
-	u8			drv_rsvd_page_number;
-	u8			not_xmitframe_fw_dl; /*not use xmitframe to download fw*/
-#endif
-
-#if (PHYDM_VERSION == 2)
-	u8			phydm_op_mode;
-#endif
-
-	_mutex fw_h2c_mutex;
-	_mutex set_chan_mutex;
-	u16			interface_type;	//USB,SDIO,SPI,PCI
-
-#if defined(CONFIG_RTL8735B) || defined(CONFIG_RTL8721D) || defined(CONFIG_RTL8721F)
-	u8			fw_ractrl;
-#endif
-
-#if defined(CONFIG_RTL8735B)
-	u32			ReceiveConfig;
-	u8			dram_type;
-	u8			dram_size;
-	u8			external_lna_2g;
-#if defined(SUPPORT_5G_CHANNEL)
-	u8			external_pa_5g;
-	u8			external_lna_5g;
-#endif // SUPPORT_5G_CHANNEL
-	u8			INIDATA_RATE[32];	/* MACID_NUM_SW_LIMIT: 32 */
-	_lock			GntBTSpinLock;
-#endif // CONFIG_RTL8735B
-
-} HAL_DATA_COMMON, *PHAL_DATA_COMMON;
-
-#if (PHYDM_VERSION == 2)
-#define TXPWR_LMT_RS_CCK	0
-#define TXPWR_LMT_RS_OFDM	1
-#define TXPWR_LMT_RS_HT 	2
-#define TXPWR_LMT_RS_VHT	3
-
-//register definition
-#define KFREE_FLAG_ON		BIT(0)
-#define KFREE_FLAG_THERMAL_K_ON	BIT(1)
-
-
-#define REG_BLUE_TOOTH	rBlue_Tooth
-#define REG_CCK_0_AFE_SETTING	rCCK0_AFESetting
-#define REG_CONFIG_ANT_A	rConfig_AntA
-#define REG_CONFIG_ANT_B	rConfig_AntB
-
-#define REG_FPGA0_IQK	rFPGA0_IQK
-#define REG_FPGA0_RFMOD rFPGA0_RFMOD
-#define REG_FPGA0_TX_GAIN_STAGE rFPGA0_TxGainStage
-#define REG_FPGA0_XA_RF_INTERFACE_OE	rFPGA0_XA_RFInterfaceOE
-#define REG_FPGA0_XB_RF_INTERFACE_OE	rFPGA0_XB_RFInterfaceOE
-#define REG_FPGA0_XA_HSSI_PARAMETER1	rFPGA0_XA_HSSIParameter1
-#define REG_FPGA0_XA_LSSI_PARAMETER 	rFPGA0_XA_LSSIParameter
-#define REG_FPGA0_XB_HSSI_PARAMETER1	rFPGA0_XB_HSSIParameter1
-#define REG_FPGA0_XB_LSSI_PARAMETER 	rFPGA0_XB_LSSIParameter
-#define REG_FPGA0_XB_LSSI_READ_BACK 	rFPGA0_XB_LSSIReadBack
-#define REG_FPGA0_XAB_RF_INTERFACE_SW	rFPGA0_XAB_RFInterfaceSW
-#define REG_FPGA0_XAB_RF_PARAMETER		rFPGA0_XAB_RFParameter
-#define REG_FPGA0_XCD_RF_INTERFACE_SW	rFPGA0_XCD_RFInterfaceSW
-#define REG_FPGA0_XCD_SWITCH_CONTROL	rFPGA0_XCD_SwitchControl
-
-#define REG_IQK_AGC_RSP 	rIQK_AGC_Rsp
-#define REG_IQK_AGC_PTS 	rIQK_AGC_Pts
-#define REG_IQK_AGC_CONT	rIQK_AGC_Cont
-
-#define REG_OFDM_0_AGC_RSSI_TABLE	rOFDM0_AGCRSSITable
-#define REG_OFDM_0_ECCA_THRESHOLD		rOFDM0_ECCAThreshold
-#define REG_OFDM_0_RX_IQ_EXT_ANTA	rOFDM0_RxIQExtAnta
-#define REG_OFDM_0_TRX_PATH_ENABLE	rOFDM0_TRxPathEnable
-#define REG_OFDM_0_TR_MUX_PAR	rOFDM0_TRMuxPar
-#define REG_OFDM_0_XA_AGC_CORE1 rOFDM0_XAAGCCore1
-#define REG_OFDM_0_XB_AGC_CORE1 rOFDM0_XBAGCCore1
-#define REG_OFDM_0_XA_RX_IQ_IMBALANCE	rOFDM0_XARxIQImbalance
-#define REG_OFDM_0_XB_RX_IQ_IMBALANCE	rOFDM0_XBRxIQImbalance
-#define REG_OFDM_0_XA_TX_IQ_IMBALANCE	rOFDM0_XATxIQImbalance
-#define REG_OFDM_0_XB_TX_IQ_IMBALANCE	rOFDM0_XBTxIQImbalance
-#define REG_OFDM_0_XC_TX_AFE	rOFDM0_XCTxAFE
-#define REG_OFDM_0_XD_TX_AFE	rOFDM0_XDTxAFE
-
-#define REG_TX_AGC_A_CCK_11_CCK_1_JAGUAR	rTxAGC_A_CCK11_CCK1_JAguar
-#define REG_TX_AGC_A_CCK_1_MCS32	rTxAGC_A_CCK1_Mcs32
-#define REG_TX_AGC_A_MCS11_MCS8_JAGUAR	rTxAGC_A_MCS11_MCS8_JAguar
-#define REG_TX_AGC_A_MCS15_MCS12_JAGUAR	rTxAGC_A_MCS15_MCS12_JAguar
-#define REG_TX_AGC_A_MCS19_MCS16_JAGUAR	rTxAGC_A_MCS19_MCS16_JAguar
-#define REG_TX_AGC_A_MCS23_MCS20_JAGUAR	rTxAGC_A_MCS23_MCS20_JAguar
-#define REG_TX_AGC_A_MCS3_MCS0_JAGUAR	rTxAGC_A_MCS3_MCS0_JAguar
-#define REG_TX_AGC_A_MCS7_MCS4_JAGUAR	rTxAGC_A_MCS7_MCS4_JAguar
-#define REG_TX_AGC_A_MCS03_MCS00	rTxAGC_A_Mcs03_Mcs00
-#define REG_TX_AGC_A_MCS07_MCS04	rTxAGC_A_Mcs07_Mcs04
-#define REG_TX_AGC_A_MCS11_MCS08	rTxAGC_A_Mcs11_Mcs08
-#define REG_TX_AGC_A_MCS15_MCS12	rTxAGC_A_Mcs15_Mcs12
-#define REG_TX_AGC_A_NSS1_INDEX3_NSS1_INDEX0_JAGUAR	rTxAGC_A_Nss1Index3_Nss1Index0_JAguar
-#define REG_TX_AGC_A_NSS1_INDEX7_NSS1_INDEX4_JAGUAR	rTxAGC_A_Nss1Index7_Nss1Index4_JAguar
-#define REG_TX_AGC_A_NSS2_INDEX1_NSS1_INDEX8_JAGUAR	rTxAGC_A_Nss2Index1_Nss1Index8_JAguar
-#define REG_TX_AGC_A_NSS2_INDEX5_NSS2_INDEX2_JAGUAR	rTxAGC_A_Nss2Index5_Nss2Index2_JAguar
-#define REG_TX_AGC_A_NSS2_INDEX9_NSS2_INDEX6_JAGUAR	rTxAGC_A_Nss2Index9_Nss2Index6_JAguar
-#define REG_TX_AGC_A_NSS3_INDEX3_NSS3_INDEX0_JAGUAR	rTxAGC_A_Nss3Index3_Nss3Index0_JAguar
-#define REG_TX_AGC_A_NSS3_INDEX7_NSS3_INDEX4_JAGUAR	rTxAGC_A_Nss3Index7_Nss3Index4_JAguar
-#define REG_TX_AGC_A_NSS3_INDEX9_NSS3_INDEX8_JAGUAR	rTxAGC_A_Nss3Index9_Nss3Index8_JAguar
-#define REG_TX_AGC_A_OFDM18_OFDM6_JAGUAR	rTxAGC_A_Ofdm18_Ofdm6_JAguar
-#define REG_TX_AGC_A_OFDM54_OFDM24_JAGUAR	rTxAGC_A_Ofdm54_Ofdm24_JAguar
-#define REG_TX_AGC_A_RATE18_06	rTxAGC_A_Rate18_06
-#define REG_TX_AGC_A_RATE54_24	rTxAGC_A_Rate54_24
-#define REG_TX_AGC_B_CCK_11_A_CCK_2_11	rTxAGC_B_CCK11_A_CCK2_11
-#define REG_TX_AGC_B_CCK_11_CCK_1_JAGUAR	rTxAGC_B_CCK11_CCK1_JAguar
-#define REG_TX_AGC_B_CCK_1_55_MCS32	rTxAGC_B_CCK1_55_Mcs32
-#define REG_TX_AGC_B_MCS11_MCS8_JAGUAR	rTxAGC_B_MCS11_MCS8_JAguar
-#define REG_TX_AGC_B_MCS15_MCS12_JAGUAR	rTxAGC_B_MCS15_MCS12_JAguar
-#define REG_TX_AGC_B_MCS19_MCS16_JAGUAR	rTxAGC_B_MCS19_MCS16_JAguar
-#define REG_TX_AGC_B_MCS23_MCS20_JAGUAR	rTxAGC_B_MCS23_MCS20_JAguar
-#define REG_TX_AGC_B_MCS3_MCS0_JAGUAR	rTxAGC_B_MCS3_MCS0_JAguar
-#define REG_TX_AGC_B_MCS7_MCS4_JAGUAR	rTxAGC_B_MCS7_MCS4_JAguar
-#define REG_TX_AGC_B_MCS03_MCS00	rTxAGC_B_Mcs03_Mcs00
-#define REG_TX_AGC_B_MCS07_MCS04	rTxAGC_B_Mcs07_Mcs04
-#define REG_TX_AGC_B_MCS11_MCS08	rTxAGC_B_Mcs11_Mcs08
-#define REG_TX_AGC_B_MCS15_MCS12	rTxAGC_B_Mcs15_Mcs12
-#define REG_TX_AGC_B_NSS1_INDEX3_NSS1_INDEX0_JAGUAR	rTxAGC_B_Nss1Index3_Nss1Index0_JAguar
-#define REG_TX_AGC_B_NSS1_INDEX7_NSS1_INDEX4_JAGUAR	rTxAGC_B_Nss1Index7_Nss1Index4_JAguar
-#define REG_TX_AGC_B_NSS2_INDEX1_NSS1_INDEX8_JAGUAR	rTxAGC_B_Nss2Index1_Nss1Index8_JAguar
-#define REG_TX_AGC_B_NSS2_INDEX5_NSS2_INDEX2_JAGUAR	rTxAGC_B_Nss2Index5_Nss2Index2_JAguar
-#define REG_TX_AGC_B_NSS2_INDEX9_NSS2_INDEX6_JAGUAR	rTxAGC_B_Nss2Index9_Nss2Index6_JAguar
-#define REG_TX_AGC_B_NSS3_INDEX3_NSS3_INDEX0_JAGUAR	rTxAGC_B_Nss3Index3_Nss3Index0_JAguar
-#define REG_TX_AGC_B_NSS3_INDEX7_NSS3_INDEX4_JAGUAR	rTxAGC_B_Nss3Index7_Nss3Index4_JAguar
-#define REG_TX_AGC_B_NSS3_INDEX9_NSS3_INDEX8_JAGUAR	rTxAGC_B_Nss3Index9_Nss3Index8_JAguar
-#define REG_TX_AGC_B_OFDM18_OFDM6_JAGUAR	rTxAGC_B_Ofdm18_Ofdm6_JAguar
-#define REG_TX_AGC_B_OFDM54_OFDM24_JAGUAR	rTxAGC_B_Ofdm54_Ofdm24_JAguar
-#define REG_TX_AGC_B_RATE18_06	rTxAGC_B_Rate18_06
-#define REG_TX_AGC_B_RATE54_24	rTxAGC_B_Rate54_24
-
-#define REG_TX_CCK_BBON rTx_CCK_BBON
-#define REG_TX_CCK_RFON rTx_CCK_RFON
-#define REG_TX_OFDM_BBON	rTx_OFDM_BBON
-#define REG_TX_OFDM_RFON	rTx_OFDM_RFON
-#define REG_TX_IQK	rTx_IQK
-#define REG_TX_IQK_TONE_A	rTx_IQK_Tone_A
-#define REG_TX_IQK_TONE_B	rTx_IQK_Tone_B
-#define REG_TX_IQK_PI_A rTx_IQK_PI_A
-#define REG_TX_IQK_PI_B rTx_IQK_PI_B
-#define REG_TX_POWER_AFTER_IQK_A	rTx_Power_After_IQK_A
-#define REG_TX_POWER_AFTER_IQK_B	rTx_Power_After_IQK_B
-#define REG_TX_POWER_BEFORE_IQK_A	rTx_Power_Before_IQK_A
-#define REG_TX_POWER_BEFORE_IQK_B	rTx_Power_Before_IQK_B
-#define REG_TX_TO_RX	rTx_To_Rx
-#define REG_TX_TO_TX	rTx_To_Tx
-
-#define REG_RX_CCK	rRx_CCK
-#define REG_RX_IQK	rRx_IQK
-#define REG_RX_IQK_TONE_A	rRx_IQK_Tone_A
-#define REG_RX_IQK_TONE_B	rRx_IQK_Tone_B
-#define REG_RX_IQK_PI_A rRx_IQK_PI_A
-#define REG_RX_IQK_PI_B rRx_IQK_PI_B
-#define REG_RX_OFDM rRx_OFDM
-#define REG_RX_POWER_AFTER_IQK_A_2	rRx_Power_After_IQK_A_2
-#define REG_RX_POWER_AFTER_IQK_B_2	rRx_Power_After_IQK_B_2
-#define REG_RX_POWER_BEFORE_IQK_A_2 rRx_Power_Before_IQK_A_2
-#define REG_RX_POWER_BEFORE_IQK_B_2 rRx_Power_Before_IQK_B_2
-#define REG_RX_TO_RX	rRx_TO_Rx
-#define REG_RX_WAIT_CCA rRx_Wait_CCA
-#define REG_RX_WAIT_RIFS	rRx_Wait_RIFS
-
-
-#define REG_TX_IQK_TONE_B	rTx_IQK_Tone_B
-#define REG_TX_IQK_PI_A rTx_IQK_PI_A
-
-#define REG_PMPD_ANAEN	rPMPD_ANAEN
-#define REG_SLEEP	rSleep
-#define REG_STANDBY rStandby
-
-#define RX_SMOOTH_FACTOR	Rx_Smooth_Factor
-
-//function redefine
-#define hw_rate_to_m_rate HwRateToMRate
-#define phy_set_tx_power_index_by_rate_section PHY_SetTxPowerIndexByRateSection
-#define phy_store_tx_power_by_rate PHY_StoreTxPowerByRate
-#define _rtw_memset rtw_memset
-#define _rtw_memcpy rtw_memcpy
-#define _rtw_memcmp rtw_memcmp
-#define hal_func HalFunc
-#define set_hw_reg_handler SetHwRegHandler
-#define get_hal_def_var_handler GetHalDefVarHandler
-#endif // #if (PHYDM_VERSION == 2)
-
-#define ODM_COMP_COMMON	BIT(30)
-
-typedef struct _ROM_INFO {
-	u1Byte	EEPROMVersion;
-	u1Byte	CrystalCap;
-	u8Byte	DebugComponents;
-	u4Byte	DebugLevel;
-} ROM_INFO, *PROM_INFO;
-extern ROM_INFO					ROMInfo;
-
-typedef struct hal_com_data HAL_DATA_TYPE, *PHAL_DATA_TYPE;
-
-#define GET_HAL_SPEC(__pAdapter)			(&(rtw_get_haldata((__pAdapter))->hal_spec))
-#define rtw_is_hw_init_completed(adapter)		(((PADAPTER)adapter)->hw_init_completed == _TRUE)
-
-/* alias for phydm coding style */
-#define REG_A_TX_SCALE_JAGUAR			rA_TxScale_Jaguar
-
-#define RX_SMOOTH_FACTOR	Rx_Smooth_Factor
-
-#endif //__HAL_DATA_H__
diff --git a/os/board/rtl8720e/src/component/wifi/driver/src/hal/hal_def.h b/os/board/rtl8720e/src/component/wifi/driver/src/hal/hal_def.h
deleted file mode 100644
index 3413ff373..000000000
--- a/os/board/rtl8720e/src/component/wifi/driver/src/hal/hal_def.h
+++ /dev/null
@@ -1,523 +0,0 @@
-#ifndef __HAL_DEF_H__
-#define __HAL_DEF_H__
-
-/*
-* structs defined in this file are shared with halbb or halrf
-*/
-/*==================hal_general_def.h of g6 driver==============*/
-#define FL_COMP_VER BIT0
-#define FL_COMP_INIT BIT1
-#define FL_COMP_TASK BIT2
-#define FL_COMP_CNS BIT3
-#define FL_COMP_H2C BIT4
-#define FL_COMP_C2H BIT5
-#define FL_COMP_TX BIT6
-#define FL_COMP_RX BIT7
-#define FL_COMP_IPSEC BIT8
-#define FL_COMP_TIMER BIT9
-#define FL_COMP_DBGPKT BIT10
-#define FL_COMP_PS BIT11
-#define FL_COMP_BB BIT16
-#define FL_COMP_MCC BIT20
-
-/*control of pwr by limit and power by rate*/
-enum hal_pwr_by_rate_setting {
-	PW_BY_RATE_ALL_SAME = 0,
-	PW_BY_RATE_ON = 1
-};
-
-enum hal_pwr_limit_type {
-	PWLMT_DISABLE = 0,
-	PWBYRATE_AND_PWLMT = 1,
-	PWLMT_BY_EFUSE = 2
-};
-
-enum rtw_chip_id {
-	CHIP_WIFI6_8852A,
-	CHIP_WIFI6_8834A,
-	CHIP_WIFI6_8852B,
-	CHIP_WIFI6_8852C,
-	CHIP_WIFI6_8192XB,
-	CHIP_WIFI6_8832BR,
-	CHIP_WIFI6_8852BP,
-	CHIP_WIFI6_8730E,
-	CHIP_WIFI6_8720E,
-	CHIP_WIFI6_MAX
-};
-
-enum rtw_cv {/*cut version*/
-	CAV,
-	CBV,
-	CCV,
-	CDV,
-	CEV,
-	CFV,
-	CGV,
-	CTV,
-	CMAXV,
-};
-
-/*==================hal_def.h of g6 driver===================*/
-
-struct rtw_trx_stat {
-	u16 rx_rate_plurality;
-};
-
-enum rtw_hal_status {
-	RTW_HAL_STATUS_SUCCESS, /* 0 */
-	RTW_HAL_STATUS_FAILURE, /* 1 */
-	RTW_HAL_STATUS_RESOURCE, /* 2 */
-	RTW_HAL_STATUS_IO_INIT_FAILURE, /* 3 */
-	RTW_HAL_STATUS_MAC_INIT_FAILURE, /* 4 */
-	RTW_HAL_STATUS_BB_INIT_FAILURE, /* 5 */
-	RTW_HAL_STATUS_RF_INIT_FAILURE, /* 6 */
-	RTW_HAL_STATUS_BTC_INIT_FAILURE, /* 7 */
-	RTW_HAL_STATUS_HAL_INIT_FAILURE, /* 8 */
-	RTW_HAL_STATUS_EFUSE_UNINIT, /* 9 */
-	RTW_HAL_STATUS_EFUSE_IVALID_OFFSET, /* 10 */
-	RTW_HAL_STATUS_EFUSE_PG_FAIL, /* 11 */
-	RTW_HAL_STATUS_MAC_API_FAILURE, /* 12 */
-	RTW_HAL_STATUS_BB_CH_INFO_LAST_SEG, /*13*/
-	RTW_HAL_STATUS_UNKNOWN_RFE_TYPE, /* 14 */
-	RTW_HAL_STATUS_TIMEOUT, /* 15 */
-};
-
-struct rtw_rssi_info {
-	u8 rssi; /* u(8,1), hal-bb provide, read only : 0~110 (dBm = rssi -110) */
-	u16 rssi_ma; /* u(16,5),  hal-bb provide, read only : u16 U(12,4)*/
-	u16 rssi_ma_path[4];
-	u16 pkt_cnt_data;
-	u8 rssi_bcn; /* u(8,1), beacon RSSI, hal-bb provide, read only : 0~110 (dBm = rssi -110) */
-	u16 rssi_bcn_ma; /* u(16,5),  beacon RSSI, hal-bb provide, read only*/
-	u16 rssi_bcn_ma_path[4];
-	u16 pkt_cnt_bcn;
-	u8 ma_factor: 4;
-	u8 ma_factor_bcn: 4;
-	u8 rssi_ofdm; /* u(8,1),  hal-bb provide, read only : packet, for debug */
-	u8 rssi_cck; /* u(8,1),  hal-bb provide, read only : packet, for debug */
-	u8 assoc_rssi; /* phl_rx provide, read only */
-	/* phl_rx provide, read only : Moving Average RSSI information for the STA */
-	u8 ma_rssi; /* moving average : 0 ~ PHL_MAX_RSSI (dBm = rssi - PHL_MAX_RSSI) */
-	u8 ma_rssi_mgnt; /* moving average rssi for beacon/probe : 0 ~ PHL_MAX_RSSI (dBm = rssi - PHL_MAX_RSSI) */
-	u16 snr_ma; /* u(16,4), hal-bb provide, read only, SNR= snr_ma dBm*/
-};
-enum hal_rate_mode {
-	HAL_LEGACY_MODE	= 0,
-	HAL_HT_MODE	= 1,
-	HAL_VHT_MODE	= 2,
-	HAL_HE_MODE	= 3
-};
-
-enum hal_rate_bw {
-	HAL_RATE_BW_20	= 0,
-	HAL_RATE_BW_40	= 1,
-	HAL_RATE_BW_80	= 2,
-	HAL_RATE_BW_160	= 3,
-};
-
-struct rtw_rate_info {
-	enum rtw_gi_ltf gi_ltf; /* 3bit GILTF */
-	enum hal_rate_mode mode; /* 2bit 0:legacy, 1:HT, 2:VHT, 3:HE*/
-	enum hal_rate_bw bw; /*2bit 0:5M/10M/20M, 1:40M, 2:80M, 3:160M or 80+80*/
-	u8 mcs_ss_idx; /*HE: 3bit SS + 4bit MCS; non-HE: 5bit MCS/rate idx */
-};
-
-enum rtw_h2c_pkt_type { //AX_TODO:need fw further check
-	H2CB_TYPE_CMD = 0,
-	H2CB_TYPE_DATA = 1,
-	H2CB_TYPE_LONG_DATA = 2,
-	H2CB_TYPE_MAX = 0x3
-};
-
-struct rtw_g6_h2c_hdr { //AX_TODO:need fw further check
-	u8 h2c_class; //0x0~0x7: Phydm; 0x8~0xF: RF; 0x10~0x17: BTC
-	u8 h2c_func;
-	u8 seq_valid: 1;
-	u8 seq: 3;
-	u8 seq_stop: 1;
-	enum rtw_h2c_pkt_type type; //0:cmd ; 1:cmd+data ; 2:cmd+long data
-	u16 content_len: 12;
-	u16 rec_ack: 1; //Ack when receive H2C
-	u16 done_ack: 1; //Ack when FW execute H2C cmd done
-	u16 rsvd2: 2;
-};
-
-enum tx_pause_rson {
-	PAUSE_RSON_NOR_SCAN, /*normal scan*/
-	PAUSE_RSON_UNSPEC_BY_MACID, /*P2P_SCAN*/
-	PAUSE_RSON_RFK,
-	PAUSE_RSON_PSD,
-	PAUSE_RSON_DFS,
-	PAUSE_RSON_DFS_CSA,
-	PAUSE_RSON_DBCC,
-	PAUSE_RSON_RESET,
-	PAUSE_RSON_MAX
-};
-
-/*HW_BAND0 - CMAC0 + PHY0 + S0*/
-/*HW_BAND1 - CMAC1 + PHY1 + S1*/
-enum phl_band_idx {
-	HW_BAND_0,
-	HW_BAND_1,
-	HW_BAND_MAX
-};
-
-enum phl_phy_idx {
-	HW_PHY_0,
-	HW_PHY_1,
-	HW_PHY_MAX
-};
-
-/* from cmn_sta_info */
-struct rtw_ra_sta_info {
-	/*u8 rate_id;			remove !!! use wmode in phl, [PHYDM] ratr_idx*/
-	/*u8 rssi_level;			[PHYDM]*/
-	/*u8 is_first_connect:1;		change connect flow, [PHYDM] CE: ra_rpt_linked, AP: H2C_rssi_rpt*/
-	/*u8 is_support_sgi:1;		mov to phl [driver]*/
-	/*u8 is_vht_enable:2;		mov to phl [driver]*/
-	/*u8 disable_ra:1;			mov to hal [driver]*/
-	/*u8 disable_pt:1;			remove for no PT, [driver] remove is_disable_power_training*/
-	/*u8 txrx_state:2;			///////////////need to check if needed, [PHYDM] 0: Tx, 1:Rx, 2:bi-direction*/
-	/*u8 is_noisy:1;			///////////////need to check if needed, [PHYDM]*/
-	u16 curr_tx_rate;			/*use struct bb_rate_info, [PHYDM] FW->Driver*/
-	enum channel_width ra_bw_mode;	/*remove to phl, [Driver] max bandwidth, for RA only*/
-	enum channel_width curr_tx_bw;	/*bb_rate_info, [PHYDM] FW->Driver*/
-	/* u8 drv_ractrl; */
-
-	/* Ctrl */
-	bool dis_ra; /*move from rtw_hal_stainfo_t*/
-	bool ra_registered;/*move from rtw_hal_stainfo_t*/
-	u64 ra_mask;/*move from rtw_hal_stainfo_t*/ /*drv decide by specific req*/
-	u64 cur_ra_mask;/*move from rtw_hal_stainfo_t*/
-
-	/*halbb create, mod by driver and decide by rssi or other*/
-	u8 cal_giltf; /* 3bit gi_ltf ctrl by driver*/			// only halbb_ra used
-	bool fix_giltf_en; /*giltf from cal_giltf or halbb*/	// only halbb_ra used
-	bool fixed_rt_en;								// only halbb_ra used
-	struct rtw_rate_info fixed_rt_i;					// only halbb_ra used
-
-	/* Report */
-	struct rtw_rate_info rpt_rt_i;						// halbb support, core get raid from this report
-	u8 curr_retry_ratio;		/*[HALBB] FW->Driver*/	//halbb support
-
-	bool ra_csi_rate_en;								// halbb beamforming set
-	bool fixed_csi_rate_en;							// halbb beamforming set
-	u8 band_num;									// halbb beamforming set
-	struct rtw_rate_info csi_rate;						// halbb beamforming set
-
-	u8 avg_agg;				//no use
-	u32 tx_ok_cnt[4];			//halbb support
-	u32 tx_retry_cnt[4];		//halbb support
-	u32 tx_total_cnt;			//halbb support
-	/*u64 ramask;*/
-};
-
-enum rtw_tpu_op_mode {
-	TPU_NORMAL_MODE		= 0,
-	TPU_DBG_MODE		= 1
-};
-
-enum phl_pwr_table {
-	PWR_BY_RATE	= BIT0,
-	PWR_LIMIT	= BIT1,
-	PWR_LIMIT_RU	= BIT2
-};
-
-#define HAL_MAX_PATH	1
-
-/*[TX Power Unit(TPU) array size]*/
-#define TPU_SIZE_PWR_TAB	16 /*MCS0~MCS11(12) + {dcm_0,1,3,4}4 = 16*/
-#define TPU_SIZE_PWR_TAB_lGCY	12 /*cck(4) + ofdm(8) = 12*/
-#define TPU_SIZE_MODE		5  /*0~4: HE, VHT, HT, Legacy, CCK, */
-#define TPU_SIZE_BW		5 /*0~4: 80_80, 160, 80, 40, 20*/
-#define TPU_SIZE_RUA		3 /*{26, 52, 106}*/
-#define TPU_SIZE_BW20_SC	8 /*8 * 20M = 160M*/
-#define TPU_SIZE_BW40_SC	4 /*4 * 40M = 160M*/
-#define TPU_SIZE_BW80_SC	2 /*2 * 80M = 160M*/
-#define TPU_SIZE_BF		2 /*{NON_BF, BF}*/
-
-struct rtw_tpu_pwr_by_rate_info { /*TX Power Unit (TPU)*/
-	s8 pwr_by_rate_lgcy[TPU_SIZE_PWR_TAB_lGCY];
-	s8 pwr_by_rate[HAL_MAX_PATH][TPU_SIZE_PWR_TAB];
-};
-
-struct rtw_tpu_pwr_imt_info { /*TX Power Unit (TPU)*/
-	s8 pwr_lmt_cck_20m[HAL_MAX_PATH][TPU_SIZE_BF];
-	s8 pwr_lmt_cck_40m[HAL_MAX_PATH][TPU_SIZE_BF];
-	s8 pwr_lmt_lgcy_20m[HAL_MAX_PATH][TPU_SIZE_BF]; /*ofdm*/
-	s8 pwr_lmt_20m[HAL_MAX_PATH][TPU_SIZE_BW20_SC][TPU_SIZE_BF];
-	s8 pwr_lmt_40m[HAL_MAX_PATH][TPU_SIZE_BW40_SC][TPU_SIZE_BF];
-	s8 pwr_lmt_80m[HAL_MAX_PATH][TPU_SIZE_BW80_SC][TPU_SIZE_BF];
-	s8 pwr_lmt_160m[HAL_MAX_PATH][TPU_SIZE_BF];
-	s8 pwr_lmt_40m_0p5[HAL_MAX_PATH][TPU_SIZE_BF];
-	s8 pwr_lmt_40m_2p5[HAL_MAX_PATH][TPU_SIZE_BF];
-};
-
-struct rtw_tpu_info { /*TX Power Unit (TPU)*/
-	enum rtw_tpu_op_mode op_mode; /*In debug mode, only debug tool control TPU APIs*/
-	bool normal_mode_lock_en;
-	s8 ofst_int; /*SW: S(8,3) -16 ~ +15.875 (dB)*/
-	u8 ofst_fraction; /*[0:3] * 0.125(dBm)*/
-	u8 base_cw_0db; /*[63~39~15]: [+24~0~-24 dBm]*/
-	u16 tssi_16dBm_cw;
-	/*[Ref Pwr]*/
-	s16 ref_pow_ofdm; /*-> HW: s(9,2)*/
-	s16 ref_pow_cck; /*-> HW: s(9,2)*/
-	u16 ref_pow_ofdm_cw; /*BBCR 0x58E0[9:0]*/
-	u16 ref_pow_cck_cw; /*BBCR 0x58E0[21:12]*/
-	/*[Pwr Ofsset]*/ /*-> HW: s(7,1)*/
-	s8 pwr_ofst_mode[TPU_SIZE_MODE]; /*0~4: HE, VHT, HT, Legacy, CCK, */
-	s8 pwr_ofst_bw[TPU_SIZE_BW]; /*0~4: 80_80, 160, 80, 40, 20*/
-	/*[Pwr By rate]*/ /*-> HW: s(7,1)*/
-	struct rtw_tpu_pwr_by_rate_info rtw_tpu_pwr_by_rate_i;
-	/*[Pwr Limit]*/ /*-> HW: s(7,1)*/
-	struct rtw_tpu_pwr_imt_info rtw_tpu_pwr_imt_i;
-	/*[Pwr Limit RUA]*/ /*-> HW: s(7,1)*/
-	s8 pwr_lmt_ru[HAL_MAX_PATH][TPU_SIZE_RUA][TPU_SIZE_BW20_SC];
-	u16 pwr_lmt_ru_mem_size;
-	bool pwr_lmt_en;
-	u8 tx_ptrn_shap_idx;
-	u8 tx_ptrn_shap_idx_cck;
-};
-
-struct rtw_hal_stat_info {
-	u32 cnt_fail_all;
-	u32 cnt_cck_fail;
-	u32 cnt_ofdm_fail;
-	u32 cnt_cca_all;
-	u32 cnt_ofdm_cca;
-	u32 cnt_cck_cca;
-	u32 cnt_crc32_error_all;
-	u32 cnt_he_crc32_error;
-	u32 cnt_vht_crc32_error;
-	u32 cnt_ht_crc32_error ;
-	u32 cnt_ofdm_crc32_error;
-	u32 cnt_cck_crc32_error;
-	u32 cnt_crc32_ok_all;
-	u32 cnt_he_crc32_ok;
-	u32 cnt_vht_crc32_ok;
-	u32 cnt_ht_crc32_ok;
-	u32 cnt_ofdm_crc32_ok;
-	u32 cnt_cck_crc32_ok;
-	u32 igi_fa_rssi;
-	u32 cck_mac_txen;
-	u32 cck_phy_txon;
-	u32 ofdm_mac_txen;
-	u32 ofdm_phy_txon;
-};
-
-struct rtw_hw_band {
-	struct rtw_chan_def cur_chandef;
-#if (PHYDM_VERSION == 3)
-	struct rtw_tpu_info rtw_tpu_i; /*TX Power Unit (TPU)*/
-	struct rtw_hal_stat_info stat_info;
-#endif
-};
-
-enum phl_rf_mode {
-	RF_MODE_NORMAL		= 0,
-	RF_MODE_SHUTDOWN	= 1,
-	RF_MODE_STANDBY		= 2,
-	RF_MODE_RX		= 3,
-	RF_MODE_TX		= 4,
-	RF_MODE_MAX
-};
-
-struct rtw_cfo_info {
-	s32		cfo_tail;
-	s32		pre_cfo_avg;
-	s32		cfo_avg;
-	u16		cfo_cnt;
-	u32		tp;
-};
-
-#define FL_CFG_OP_SET 0
-#define FL_CFG_OP_CLR 1
-#define FL_CFG_OP_INFO 2
-
-#define FL_CFG_TYPE_LEVEL 0
-#define FL_CFG_TYPE_OUTPUT 1
-#define FL_CFG_TYPE_COMP 2
-#define FL_CFG_TYPE_COMP_EXT 3
-
-#define FL_LV_OFF 0
-#define FL_LV_CRT 1
-#define FL_LV_SER 2
-#define FL_LV_WARN 3
-#define FL_LV_LOUD 4
-#define FL_LV_TR 5
-
-#define FL_OP_UART BIT0
-#define FL_OP_C2H BIT1
-#define FL_OP_SNI BIT2
-
-struct hal_dfs_rpt {
-	u8 *dfs_ptr;
-	u16 dfs_num;
-	u8 phy_idx; /*phy0,phy1*/
-};
-
-struct rtw_hal_mac_ax_cctl_info {
-	/* dword 0 */
-	u32 datarate: 9;
-	u32 force_txop: 1;
-	u32 data_bw: 2;
-	u32 data_gi_ltf: 3;
-	u32 darf_tc_index: 1;
-	u32 arfr_ctrl: 4;
-	u32 acq_rpt_en: 1;
-	u32 mgq_rpt_en: 1;
-	u32 ulq_rpt_en: 1;
-	u32 twtq_rpt_en: 1;
-	u32 rsvd0: 1;
-	u32 disrtsfb: 1;
-	u32 disdatafb: 1;
-	u32 tryrate: 1;
-	u32 ampdu_density: 4;
-	/* dword 1 */
-	u32 data_rty_lowest_rate: 9;
-	u32 ampdu_time_sel: 1;
-	u32 ampdu_len_sel: 1;
-	u32 rts_txcnt_lmt_sel: 1;
-	u32 rts_txcnt_lmt: 4;
-	u32 rtsrate: 9;
-	u32 rsvd1: 2;
-	u32 vcs_stbc: 1;
-	u32 rts_rty_lowest_rate: 4;
-	/* dword 2 */
-	u32 data_tx_cnt_lmt: 6;
-	u32 data_txcnt_lmt_sel: 1;
-	u32 max_agg_num_sel: 1;
-	u32 rts_en: 1;
-	u32 cts2self_en: 1;
-	u32 cca_rts: 2;
-	u32 hw_rts_en: 1;
-	u32 rts_drop_data_mode: 2;
-	u32 preld_en: 1;
-	u32 ampdu_max_len: 11;
-	u32 ul_mu_dis: 1;
-	u32 ampdu_max_time: 4;
-	/* dword 3 */
-	u32 max_agg_num: 9;
-	u32 ba_bmap: 2;
-	u32 rsvd3: 5;
-	u32 vo_lftime_sel: 3;
-	u32 vi_lftime_sel: 3;
-	u32 be_lftime_sel: 3;
-	u32 bk_lftime_sel: 3;
-	u32 sectype: 4;
-	/* dword 4 */
-	u32 multi_port_id: 3;
-	u32 bmc: 1;
-	u32 mbssid: 4;
-	u32 navusehdr: 1;
-	u32 txpwr_mode: 3;
-	u32 data_dcm: 1;
-	u32 data_er: 1;
-	u32 data_ldpc: 1;
-	u32 data_stbc: 1;
-	u32 a_ctrl_bqr: 1;
-	u32 a_ctrl_uph: 1;
-	u32 a_ctrl_bsr: 1;
-	u32 a_ctrl_cas: 1;
-	u32 data_bw_er: 1;
-	u32 lsig_txop_en: 1;
-	u32 rsvd4: 5;
-	u32 ctrl_cnt_vld: 1;
-	u32 ctrl_cnt: 4;
-	/* dword 5 */
-	u32 resp_ref_rate: 9;
-	u32 rsvd5: 3;
-	u32 all_ack_support: 1;
-	u32 bsr_queue_size_format: 1;
-	u32 bsr_om_upd_en: 1;
-	u32 macid_fwd_idc: 1;
-	u32 ntx_path_en: 4;
-	u32 path_map_a: 2;
-	u32 path_map_b: 2;
-	u32 path_map_c: 2;
-	u32 path_map_d: 2;
-	u32 antsel_a: 1;
-	u32 antsel_b: 1;
-	u32 antsel_c: 1;
-	u32 antsel_d: 1;
-	/* dword 6 */
-	u32 addr_cam_index: 8;
-	u32 paid: 9;
-	u32 uldl: 1;
-	u32 doppler_ctrl: 2;
-	u32 nominal_pkt_padding: 2;
-	u32 nominal_pkt_padding40: 2;
-	u32 txpwr_tolerence: 6;
-	/*u32 rsvd9:2;*/
-	u32 nominal_pkt_padding80: 2;
-	/* dword 7 */
-	u32 nc: 3;
-	u32 nr: 3;
-	u32 ng: 2;
-	u32 cb: 2;
-	u32 cs: 2;
-	u32 csi_txbf_en: 1;
-	u32 csi_stbc_en: 1;
-	u32 csi_ldpc_en: 1;
-	u32 csi_para_en: 1;
-	u32 csi_fix_rate: 9;
-	u32 csi_gi_ltf: 3;
-	u32 nominal_pkt_padding160: 2;
-	u32 csi_bw: 2;
-};
-
-#define HAL_MAX_MU_STA_NUM 6
-struct hal_mu_score_tbl_ctrl {
-	u32 mu_sc_thr: 2;
-	u32 mu_opt: 1;
-	u32 rsvd: 29;
-};
-#define HAL_MAX_MU_SCORE_SIZE 8 /* Unit: Byte */
-struct hal_mu_score_tbl_score {
-	u8 valid;
-	u16 macid;
-	u8 score[HAL_MAX_MU_SCORE_SIZE]; /*by case: [1:0], [3:2], ..... */
-};
-struct hal_mu_score_tbl {
-	struct hal_mu_score_tbl_ctrl mu_ctrl;
-	//_os_lock lock;
-	u8 num_mu_sta; /*By IC, shall alway <= than HAL_MAX_MU_STA_NUM , 0 = tbl invalid */
-	u8 sz_mu_score; /*By IC, shall alway <= than HAL_MAX_MU_SCORE_SIZE , 0 = score invalid */
-	struct hal_mu_score_tbl_score mu_score[HAL_MAX_MU_STA_NUM]; /* mu_score[num_mu_sta] */
-};
-
-struct rtw_hal_com_t {
-	u8 test;
-#if (PHYDM_VERSION == 3)
-	enum rtw_chip_id chip_id;
-	enum rtw_cv cv;/* cut version */
-	struct dev_cap_t dev_hw_cap;/* halbb/halrf will set these values */
-	void *hal_priv;/*pointer to hal_com_data*/
-	void *adapter; /*pointer to adapter*/
-	struct rtw_trx_stat trx_stat;/*halbb will set value*/
-	u8 assoc_sta_cnt; /*number of associated nodes (sta or ap)*/
-	void *drv_priv; /* useless, for halbb/rf_interface compile issue, driver no need take care*/
-	bool dbcc_en; /* useless, could be deleted later when halbb code all use DBCC macro*/
-	u8 rfpath_rx_num;
-	u8 rfpath_tx_num;
-#endif
-	struct rtw_hw_band band[MAX_BAND_NUM];/*band0/band1 for DBCC*/
-	bool csi_para_ctrl_sel; /*AX_TODO: beamformee related*/
-	struct hal_mu_score_tbl bb_mu_score_tbl;
-};
-
-enum rtw_dv_sel {
-	DAV,
-	DDV,
-};
-
-struct rtw_hal_stainfo_t {
-	struct rtw_rssi_info rssi_stat;
-	/* from cmn_sta_info */
-	struct rtw_ra_sta_info	ra_info;
-	void *bb_sta;
-	struct rtw_cfo_info cfo_stat;
-};
-#endif
-
diff --git a/os/board/rtl8720e/src/component/wifi/driver/src/hal/hal_dm.h b/os/board/rtl8720e/src/component/wifi/driver/src/hal/hal_dm.h
deleted file mode 100644
index 7b5b790d8..000000000
--- a/os/board/rtl8720e/src/component/wifi/driver/src/hal/hal_dm.h
+++ /dev/null
@@ -1,23 +0,0 @@
-/******************************************************************************
- *
- * Copyright(c) 2007 - 2017 Realtek Corporation.
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of version 2 of the GNU General Public License as
- * published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
- * more details.
- *
- *****************************************************************************/
-#ifndef __HAL_DM_H__
-#define __HAL_DM_H__
-
-//#define dvobj_to_phydm(dvobj) adapter_to_phydm(dvobj_get_primary_adapter(dvobj))
-
-void rtw_hal_turbo_edca(_adapter *adapter);
-void rtw_phydm_ra_registed(_adapter *adapter, struct sta_info *psta);
-
-#endif /* __HAL_DM_H__ */
diff --git a/os/board/rtl8720e/src/component/wifi/driver/src/hal/hal_halmac.h b/os/board/rtl8720e/src/component/wifi/driver/src/hal/hal_halmac.h
deleted file mode 100644
index f8cd412fc..000000000
--- a/os/board/rtl8720e/src/component/wifi/driver/src/hal/hal_halmac.h
+++ /dev/null
@@ -1,129 +0,0 @@
-/******************************************************************************
- *
- * Copyright(c) 2015 - 2016 Realtek Corporation. All rights reserved.
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of version 2 of the GNU General Public License as
- * published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
- * more details.
- *
- * You should have received a copy of the GNU General Public License along with
- * this program; if not, write to the Free Software Foundation, Inc.,
- * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
- *
- *
- ******************************************************************************/
-#ifndef _HAL_HALMAC_H_
-#define _HAL_HALMAC_H_
-
-#include <drv_types.h>		/* adapter_to_dvobj(), struct intf_hdl and etc. */
-#include <hal_data.h>		/* struct hal_spec_t */
-#include "halmac_hw_cfg.h"	/* PHALMAC_ADAPTER and etc. */
-#include "halmac_api.h"	/* PHALMAC_ADAPTER and etc. */
-#if defined(CONFIG_RTL8195B)
-#include "halmac_88xx/halmac_88xx_cfg.h"
-#include "halmac_88xx/halmac_8195b/halmac_8195b_cfg.h"
-#endif
-#if defined(CONFIG_RTL8710C)
-#include "halmac_88xx/halmac_88xx_cfg.h"
-#include "halmac_88xx/halmac_8710c/halmac_8710c_cfg.h"
-#endif
-#if defined(CONFIG_RTL8735B)
-#include "halmac_88xx/halmac_88xx_cfg.h"
-#include "halmac_88xx/halmac_8735b/halmac_8735b_cfg.h"
-#endif
-
-/* HALMAC Definition for Driver */
-#define RTW_HALMAC_H2C_MAX_SIZE		8
-#define RTW_HALMAC_BA_SSN_RPT_SIZE	4
-
-#define set_adapter_halmac(p, mac)	(rtw_get_pshare(p)->halmac = (mac))
-#define adapter_to_halmac(p)		(rtw_get_pshare(p)->halmac)
-//#define dvobj_to_regsty(dvobj) (&(((_adapter*)(dvobj->if1))->registrypriv))
-
-/* for H2C cmd */
-#define MAX_H2C_BOX_NUMS 4
-#define MESSAGE_BOX_SIZE 4
-#define EX_MESSAGE_BOX_SIZE 4
-
-#define rtw_hal_power_on(padapter)	wifi_hal_power_on(padapter)
-#define rtw_hal_power_off(padapter)	wifi_hal_power_off(padapter)
-#define rtw_hal_init_mac_register(padapter)	wifi_hal_init_phy_parameter_mac(padapter)
-#define rtw_hal_init_phy(padapter)	wifi_hal_phy_init(padapter)
-
-#ifdef RTW_HALMAC
-struct halmac_indicator {
-	struct submit_ctx *sctx;
-	u8 *buffer;
-	u32 buf_size;
-	u32 ret_size;
-	u32 status;
-};
-#endif
-
-typedef enum _RTW_HALMAC_MODE {
-	RTW_HALMAC_MODE_NORMAL,
-	RTW_HALMAC_MODE_WIFI_TEST,
-} RTW_HALMAC_MODE;
-
-extern HALMAC_PLATFORM_API rtw_halmac_platform_api;
-
-/* HALMAC API for Driver(HAL) */
-u8 rtw_halmac_read8(_adapter *padapter, u32 addr, s32 *err);
-u16 rtw_halmac_read16(_adapter *padapter, u32 addr, s32 *err);
-u32 rtw_halmac_read32(_adapter *padapter, u32 addr, s32 *err);
-void rtw_halmac_read_mem(_adapter *padapter, u32 addr, u32 cnt, u8 *pmem);
-#ifdef CONFIG_SDIO_INDIRECT_ACCESS
-u8 rtw_halmac_iread8(struct intf_hdl *pintfhdl, u32 addr);
-u16 rtw_halmac_iread16(struct intf_hdl *pintfhdl, u32 addr);
-u32 rtw_halmac_iread32(struct intf_hdl *pintfhdl, u32 addr);
-#endif
-s32 rtw_halmac_write8(_adapter *padapter, u32 addr, u8 value, s32 *err);
-s32 rtw_halmac_write16(_adapter *padapter, u32 addr, u16 value, s32 *err);
-s32 rtw_halmac_write32(_adapter *padapter, u32 addr, u32 value, s32 *err);
-
-int rtw_halmac_init_adapter(_adapter *padapter, PHALMAC_PLATFORM_API);
-int rtw_halmac_deinit_adapter(_adapter *padapter);
-int rtw_halmac_poweron(_adapter *padapter);
-int rtw_halmac_poweroff(_adapter *padapter);
-
-int rtw_halmac_init_hal(_adapter *padapter);
-int rtw_halmac_init_hal_fw(_adapter *padapter, u8 *fw, u32 fwsize);
-int rtw_halmac_init_hal_fw_file(_adapter *padapter, u8 *fwpath);
-int rtw_halmac_deinit_hal(_adapter *padapter);
-int rtw_halmac_dlfw(_adapter *padapter, u8 *fw, u32 fwsize);
-int rtw_halmac_dlfw_from_file(_adapter *padapter, u8 *fwpath);
-int rtw_halmac_phy_power_switch(_adapter *padapter, u8 enable);
-int rtw_halmac_send_h2c(_adapter *padapter, u8 *h2c);
-int rtw_halmac_c2h_handle(_adapter *padapter, u8 *c2h, u32 size);
-
-int rtw_halmac_get_physical_efuse_size(_adapter *padapter, u32 *size);
-int rtw_halmac_read_physical_efuse_map(_adapter *padapter, u8 *map, u32 size);
-int rtw_halmac_get_logical_efuse_size(_adapter *padapter, u32 *size);
-int rtw_halmac_read_logical_efuse_map(_adapter *padapter, u8 *map, u32 size);
-int rtw_halmac_write_logical_efuse_map(_adapter *padapter, u8 *map, u32 size, u8 *maskmap, u32 masksize);
-int rtw_halmac_read_logical_efuse(_adapter *padapter, u32 offset, u32 cnt, u8 *data);
-int rtw_halmac_write_logical_efuse(_adapter *padapter, u32 offset, u32 cnt, u8 *data);
-
-int rtw_halmac_config_rx_info(_adapter *padapter, HALMAC_DRV_INFO);
-int rtw_halmac_set_mac_address(_adapter *padapter, enum _IFACE_TYPE, u8 *addr);
-int rtw_halmac_set_bssid(_adapter *padapter, enum _IFACE_TYPE hwport, u8 *addr);
-
-int rtw_halmac_set_bandwidth(_adapter *padapter, u8 channel, u8 pri_ch_idx, u8 bw);
-int rtw_halmac_rx_agg_switch(_adapter *padapter, u8 enable);
-int rtw_halmac_get_hw_value(_adapter *padapter, HALMAC_HW_ID hw_id, VOID *pvalue);
-int rtw_halmac_get_wow_reason(_adapter *padapter, u8 *reason);
-int rtw_halmac_get_drv_info_sz(_adapter *padapter, u8 *sz);
-int rtw_halmac_get_rsvd_drv_pg_bndy(_adapter *padapter, u16 *drv_pg);
-int rtw_halmac_fill_hal_spec(_adapter *padapter, struct hal_spec_t *);
-
-u32 rtw_hal_power_on(_adapter *padapter);
-
-#ifdef CONFIG_SUPPORT_TRX_SHARED
-void dump_trx_share_mode(void *sel, _adapter *adapter);
-#endif
-#endif /* _HAL_HALMAC_H_ */
diff --git a/os/board/rtl8720e/src/component/wifi/driver/src/hal/hal_headers_le.h b/os/board/rtl8720e/src/component/wifi/driver/src/hal/hal_headers_le.h
deleted file mode 100644
index 2cd3d856a..000000000
--- a/os/board/rtl8720e/src/component/wifi/driver/src/hal/hal_headers_le.h
+++ /dev/null
@@ -1,95 +0,0 @@
-#ifndef __HAL_HEADERS_LE_H__
-#define __HAL_HEADERS_LE_H__
-
-/*this file is shared for 11ax submodules*/
-#include <drv_types.h>
-#include "hal_data.h"
-
-/*==================phl_types.h of g6 driver=====================*/
-#define _os_dbgdump printf
-typedef _timer _os_timer;
-
-#ifndef false
-#define false 0
-#endif
-
-#ifndef true
-#define true 1
-#endif
-
-#ifndef ARRAY_SIZE
-#define ARRAY_SIZE(arr) (sizeof(arr) / sizeof((arr)[0]))
-#endif
-
-/*==================pltfm_ops_linux.h of g6 driver==================*/
-static inline void _os_init_timer(void *d, _os_timer *timer,
-								  void (*call_back_func)(void *context), void *context,
-								  const char *sz_id)
-{
-	(void) d;
-	rtw_init_timer(timer, NULL, call_back_func, context, sz_id);
-}
-
-static inline void _os_set_timer(void *d, _os_timer *timer, u32 ms_delay)
-{
-	(void) d;
-	rtw_set_timer(timer, ms_delay);
-}
-
-static inline void _os_cancel_timer(void *d, _os_timer *timer)
-{
-	(void) d;
-	rtw_cancel_timer(timer);
-}
-
-static inline void _os_release_timer(void *d, _os_timer *timer)
-{
-	(void) d;
-	rtw_del_timer(timer);
-}
-
-#define _os_mem_alloc(d, sz)  rtw_zmalloc(sz)
-#define _os_mem_free(d, buf, sz)  rtw_mfree(buf, sz)
-#define _os_mem_set(d, buf, val, sz)  rtw_memset(buf, val, sz)
-#define _os_mem_cpy(d, dst, src, sz)  rtw_memcpy(dst, src, sz)
-#define _os_mem_cmp(d, dst, src, sz)  rtw_memcmp(dst, src, sz)
-
-#define hal_mem_set(hal, buf, val, sz) rtw_memset(buf, val, sz)
-#define hal_mem_cpy(hal, dst, src, sz) rtw_memcpy(dst, src, sz)
-
-#define _os_delay_ms(d, ms)  rtw_mdelay_os(ms)
-#define _os_delay_us(d, us)  rtw_udelay_os(us)
-
-#define _os_get_cur_time_us() rtw_get_current_time() //AX_TODO: need find a us timer
-
-#define _os_snprintf(s, sz, fmt, ...) snprintf(s, sz, fmt, ##__VA_ARGS__)
-
-#define _os_strcmp(s1, s2) strcmp(s1, s2)
-#define _os_strcpy(dest, src) strcpy(dest, src)
-#define _os_sscanf(buf, fmt, ...) sscanf(buf, fmt, ##__VA_ARGS__)
-#define _os_strsep(s, ct) strsep(s, ct)
-#define _os_strlen(buf) strlen(buf)
-
-#define hal_read32(hal, addr) HAL_READ32(WIFI_REG_BASE, addr)
-#define hal_read16(hal, addr) HAL_READ16(WIFI_REG_BASE, addr)
-#define hal_read8(hal, addr) HAL_READ8(WIFI_REG_BASE, addr)
-#define hal_write32(hal, addr, val) HAL_WRITE32(WIFI_REG_BASE, addr, val)
-#define hal_write16(hal, addr, val) HAL_WRITE16(WIFI_REG_BASE, addr, val)
-#define hal_write8(hal, addr, val) HAL_WRITE8(WIFI_REG_BASE, addr, val)
-
-#define phl_is_mp_mode(_phl_com)	(_phl_com->drv_mode == RTW_DRV_MODE_MP)
-
-/*==================hal_headers_le.h of g6 driver==================*/
-static inline void *hal_mem_alloc(struct rtw_hal_com_t *h, u32 buf_sz)
-{
-	(void)h;
-	return rtw_zmalloc(buf_sz);
-}
-
-static inline void hal_mem_free(struct rtw_hal_com_t *h, void *buf, u32 buf_sz)
-{
-	(void)h;
-	rtw_mfree(buf, buf_sz);
-}
-
-#endif
\ No newline at end of file
diff --git a/os/board/rtl8720e/src/component/wifi/driver/src/hal/phy_g6/bb/halbb.h b/os/board/rtl8720e/src/component/wifi/driver/src/hal/phy_g6/bb/halbb.h
deleted file mode 100644
index 266ecc8d1..000000000
--- a/os/board/rtl8720e/src/component/wifi/driver/src/hal/phy_g6/bb/halbb.h
+++ /dev/null
@@ -1,461 +0,0 @@
-/******************************************************************************
- *
- * Copyright(c) 2007 - 2020  Realtek Corporation.
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of version 2 of the GNU General Public License as
- * published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
- * more details.
- *
- * The full GNU General Public License is included in this distribution in the
- * file called LICENSE.
- *
- * Contact Information:
- * wlanfae <wlanfae@realtek.com>
- * Realtek Corporation, No. 2, Innovation Road II, Hsinchu Science Park,
- * Hsinchu 300, Taiwan.
- *
- * Larry Finger <Larry.Finger@lwfinger.net>
- *
- *****************************************************************************/
-
-#ifndef __HALBB_H__
-#define __HALBB_H__
-
-/*@--------------------------[Define] ---------------------------------------*/
-
-#define	ACTIVE_TP_THRESHOLD	1
-#define BB_WATCH_DOG_PERIOD	2 /*sec*/
-#define is_sta_active(sta)	((sta) && (sta->active))
-#define HALBB_SNPRINT_SIZE	200
-#define HALBB_SNPRINT_SIZE_S	20
-#ifdef BB_8720E_SUPPORT
-#define BB_EFUSE_BAND_NUM	2
-#else
-#define BB_EFUSE_BAND_NUM	5
-#endif
-#define IC_LNA_NUM		7
-#define IC_TIA_NUM		2
-#define IC_RXBB_NUM 1
-#define IC_LNA_OP1DB_NUM	7
-#define IC_TIA_LNA_OP1DB_NUM	8
-#define EFUSE_OFST_NUM		1
-#define PIN_for_gain_NUM 16
-
-
-/*@--------------------------[Enum]------------------------------------------*/
-
-enum bb_trx_state_t {
-	BB_TX_STATE	= 0,
-	BB_RX_STATE	= 1,
-	BB_BI_DIR_STATE	= 2
-};
-
-enum bb_trafic_t {
-	TRAFFIC_NO_TP		= 0,
-	TRAFFIC_ULTRA_LOW	= 1,
-	TRAFFIC_LOW		= 2,
-	TRAFFIC_MID		= 3,
-	TRAFFIC_HIGH		= 4
-};
-
-enum efuse_bit_mask {
-	LOW_MASK = 0,
-	HIGH_MASK = 1
-};
-/*@--------------------------[Structure]-------------------------------------*/
-
-struct halbb_pause_lv {
-	s8			lv_dig;
-	s8			lv_cfo;
-	s8			lv_edcca;
-};
-
-struct bb_func_hooker_info {
-	void (*pause_bb_dm_handler)(struct bb_info *bb, u32 *val_buf, u8 val_len);
-};
-
-struct	bb_iot_info {
-	u8		is_linked_cmw500:1;
-	u8		patch_id_00000000:1;
-	u8		rsvd:6;
-};
-
-struct bb_path_info {
-	/*[Path info]*/
-	u8			tx_path_en; /*TX path enable*/
-	u8			rx_path_en; /*RX path enable*/
-	#ifdef HALBB_COMPILE_ABOVE_4SS
-	enum bb_path		tx_4ss_path_map; /*@Use N-X for 4STS rate*/
-	#endif
-	#ifdef HALBB_COMPILE_ABOVE_3SS
-	enum bb_path		tx_3ss_path_map; /*@Use N-X for 3STS rate*/
-	#endif
-	#ifdef HALBB_COMPILE_ABOVE_2SS
-	enum bb_path		tx_2ss_path_map; /*@Use N-X for 2STS rate*/
-	#endif
-	enum bb_path		tx_1ss_path_map; /*@Use N-X for 1STS rate*/
-};
-
-struct bb_link_info {
-	/*[Link Info]*/
-	bool			is_linked;
-	bool			is_linked_pre;
-	bool			first_connect;
-	bool			first_disconnect;
-	enum bb_trx_state_t	txrx_state_all;
-	/*[One Entry TP Info]*/
-	bool			is_one_entry_only;
-	u32			one_entry_macid;
-	u32			one_entry_tp;
-	u32			one_entry_tp_pre;
-	u16			tp_active_th;
-	bool			one_entry_tp_active_occur;
-	bool			is_match_bssid;
-	/*[Client Number]*/
-	u8			num_linked_client;
-	u8			num_linked_client_pre;
-	u8			num_active_client;
-	u8			num_active_client_pre;
-	/*[TP & Traffic]*/
-	u8			traffic_load;
-	u8			traffic_load_pre;
-	u16			tx_rate;
-	u16			rx_rate_plurality;
-	u16			rx_rate_plurality_mu;
-	u32			tx_tp;			/*@Mbps*/
-	u32			rx_tp;			/*@Mbps*/
-	u32			total_tp;		/*@Mbps*/
-	u16			consecutive_idle_time;	/*@unit: second*/
-	u16			wlan_mode_bitmap; /*enum wlan_mode*/
-};
-
-struct bb_ch_info {
-	u8 			fc_ch_idx;
-	bool			is_2g;
-	u8			rssi_min;
-	u16			rssi_min_macid;
-	u8			pre_rssi_min;
-	u8			rssi_max;
-	u16			rssi_max_macid;
-	u8			rxsc_160;
-	u8			rxsc_80;
-	u8			rxsc_40;
-	u8			rxsc_20;
-	u8			rxsc_l;
-	u8			is_noisy;
-	u8			rf_central_ch_cfg; /*report in phy-sts*/
-};
-
-struct bb_cmn_backup_info {
-	u8			cur_tx_path;
-	u8			cur_rx_path;
-	s16			cur_tx_pwr;
-	u8			cur_pd_lower_bound;
-	u8			last_rpl;
-	u32			last_rssi;
-	u16			last_cfo;
-	struct rssi_physts 	last_rssi_rpt;
-	struct rxevm_physts 	last_rxevm_rpt;
-};
-
-struct bb_gain_info {
-	bool op1db_chk;
-	bool gain_chk;
-	bool bypass_gain_chk;
-	s8 lna_gain[BB_GAIN_BAND_NUM][HALBB_MAX_PATH][IC_LNA_NUM];
-	u8 tia_gain[BB_GAIN_BAND_NUM][HALBB_MAX_PATH][IC_TIA_NUM];
-	s8 rxbb_gain[BB_GAIN_BAND_NUM][HALBB_MAX_PATH][IC_RXBB_NUM];
-	s8 pin_for_gain_idx[BB_GAIN_BAND_NUM][HALBB_MAX_PATH][PIN_for_gain_NUM];
-	s8 lna_gain_bypass[BB_GAIN_BAND_NUM][HALBB_MAX_PATH][IC_LNA_NUM];
-	s8 lna_op1db[BB_GAIN_BAND_NUM][HALBB_MAX_PATH][IC_LNA_NUM];
-	s8 tia_lna_op1db[BB_GAIN_BAND_NUM][HALBB_MAX_PATH][IC_LNA_NUM + 1]; // TIA0_LNA0~6 + TIA1_LNA6
-	s8 efuse_ofst[BB_GAIN_BAND_NUM][HALBB_MAX_PATH][EFUSE_OFST_NUM];
-	s8 rpl_ofst_20[BB_GAIN_BAND_NUM][HALBB_MAX_PATH];
-	s8 rpl_ofst_40[BB_GAIN_BAND_NUM][HALBB_MAX_PATH][BB_RXSC_NUM_40];
-	s8 rpl_ofst_80[BB_GAIN_BAND_NUM][HALBB_MAX_PATH][BB_RXSC_NUM_80];
-	s8 rpl_ofst_160[BB_GAIN_BAND_NUM][HALBB_MAX_PATH][BB_RXSC_NUM_160];
-};
-
-struct bb_efuse_info{
-	bool normal_efuse_check;
-	bool hidden_efuse_check;
-	s8 gain_offset[HALBB_MAX_PATH][BB_BAND_NUM_MAX]; // S(8,0)
-	s8 gain_cs[HALBB_MAX_PATH][BB_BAND_NUM_MAX]; // S(8,0)
-	s8 gain_cg[HALBB_MAX_PATH][BB_BAND_NUM_MAX]; // S(8,0)
-	s8 hidden_efuse[BB_HIDE_EFUSE_SIZE];
-
-	s8 lna_err_2g[HALBB_MAX_PATH][7]; // S(6,2)
-	s8 lna_err_5g[HALBB_MAX_PATH][7]; // S(6,2)
-
-	s8 frontend_loss[HALBB_MAX_PATH];
-	s8 rpl_bias_comp[HALBB_MAX_PATH];
-	s8 rssi_bias_comp[HALBB_MAX_PATH];
-
-	s8 efuse_ofst[HW_PHY_MAX]; // 8852A:S(5,2) 8852B:S(8,4)
-	s8 efuse_ofst_path[HALBB_MAX_PATH]; // 8852C: S(8,4)
-	s8 efuse_ofst_tb[HW_PHY_MAX]; // 8852A:S(7,4) 8852B:S(8,4)
-	s8 efuse_ofst_tb_path[HALBB_MAX_PATH]; // 8852C: S(8,4)
-};
-
-struct vht_mu_cr_backup_table {
-	u32 muic_en_a;
-	u32 lpbw_sw_symb0_a;
-	u32 ch_tracking_symb0_a;
-	u32 lpbw_sel_d1_a;
-	u32 ch_tracking_symb1_a;
-	u32 ch_tracking_a1_a;
-	u32 lpbw_sel_p1_a;
-	u32 noise_tracking_en_a;
-};
-
-struct bb_cmn_dbg_info {
-	bool cmn_log_2_cnsl_en;
-};
-
-struct bb_cmn_info {
-	u8 bb_dm_number;
-	bool cck_blk_en;
-	enum phl_phy_idx cck_phy_map;
-	bool bb_dbcc_en;
-#ifdef HALBB_PSD_SUPPORT
-	struct bb_psd_info	bb_psd_i;
-#endif
-#ifdef HALBB_LA_MODE_SUPPORT
-	struct bb_la_mode_info	bb_la_mode_i;
-#endif
-#ifdef HALBB_DYN_CSI_RSP_SUPPORT
-	struct bf_ch_raw_info bf_ch_raw_i;
-#endif
-	struct bb_spur_info bb_spur_i;
-	struct bb_echo_cmd_info	bb_echo_cmd_i;
-	struct bb_func_hooker_info bb_func_hooker_i;
-	struct bb_cmn_dbg_info bb_cmn_dbg_i;
-};
-
-#ifdef HALBB_DIG_MCC_SUPPORT
-#define PD_IDX_MIN	0
-#define NUM_MAX_IGI_CNT	7
-#define INVALID_INIT_VAL 0xff
-
-/*For 2G/5G/6G*/
-enum mcc_band {
-	MCC_BAND_1 = 0,
-	MCC_BAND_2,
-	MCC_BAND_NUM
-};
-
-struct halbb_mcc_dm {
-	bool		mcc_pre_status_en;
-	u8		mcc_reg_id[NUM_MAX_IGI_CNT];
-	u8		sta_cnt[MCC_BAND_NUM];
-	u16		mcc_dm_reg[NUM_MAX_IGI_CNT];
-	u16		mcc_dm_mask[NUM_MAX_IGI_CNT];
-	u16		mcc_dm_val[NUM_MAX_IGI_CNT][MCC_BAND_NUM];
-	/*mcc DIG*/
-	u8		rssi_min[MCC_BAND_NUM];
-
-	/* need to be config by driver*/
-	bool		mcc_status_en;
-	u8		softap_macid;
-	struct rtw_chan_def mcc_rf_ch[MCC_BAND_NUM];
-
-};
-/**
- * @struct _mcc_h2c_
- * @brief _mcc_h2c_
- *
- */
- struct mcc_h2c_reg_content {
-	// MCCDM
-	u8 addr_lsb;
-	u8 addr_msb;
-	u8 bmask_lsb;
-	u8 bmask_msb;
-	u8 val_lsb;
-	u8 val_msb;
-};
-
-struct mcc_h2c {
-	// MCCDM
-	u8 reg_cnt;
-	u8 mcc_dm_en: 1;
-	u8 mcc_ch_idx: 1;
-	u8 mcc_set: 1;
-	u8 phy0_en: 1;
-	u8 phy1_en: 1;
-	u8 rsvd0: 3;
-	u8 ch_lsb;
-	u8 ch_msb;
-	struct mcc_h2c_reg_content mcc_reg_content[NUM_MAX_IGI_CNT];
-};
-#endif
-
-struct bb_info {
-	struct rtw_phl_com_t	*phl_com;
-	struct rtw_hal_com_t	*hal_com;
-	struct rtw_phl_stainfo_t *phl_sta_info[PHL_MAX_STA_NUM];
-	u8			phl2bb_macid_table[PHL_MAX_STA_NUM];
-	bool			sta_exist[PHL_MAX_STA_NUM];
-	/*[DBCC]*/
-#ifdef HALBB_DBCC_SUPPORT
-	struct bb_info		*bb_phy_hooker;
-#endif
-	enum phl_phy_idx	bb_phy_idx;
-	struct bb_cmn_info	*bb_cmn_hooker;
-	/*[Common Info]*/
-	struct bb_gain_info	bb_gain_i;
-	struct bb_efuse_info	bb_efuse_i;
-	enum bb_ic_t		ic_type;
-	enum bb_ic_sub_t	ic_sub_type;
-	enum bb_cr_t		cr_type;
-	u8			num_rf_path;
-	u8			bb_sta_cnt;
-	/*[System Info]*/
-	bool			is_mp_mode_pre;
-	enum bb_watchdog_mode_t bb_watchdog_mode;
-	bool			bb_cmn_info_init_ready;
-	bool			bb_dm_init_ready;
-	u32			bb_sys_up_time;
-	bool			bb_watchdog_en;
-	u8			bb_watchdog_period; /*2s, 4s, 8s...,254s*/
-	bool			bb_ic_api_en;
-	u8			pre_dbg_priority;
-	char			dbg_buf[HALBB_SNPRINT_SIZE];
-	/*[DM Info]*/
-	bool			is_noisy;
-	bool			adv_bb_dm_en;
-	u64			support_ability;	/*HALBB function Supportability*/
-	u64			manual_support_ability;
-	u64			pause_ability;		/*HALBB function pause Supportability*/
-	struct halbb_pause_lv	pause_lv_table;
-	/*[FW Info]*/
-	u8			fwofld_last_cmd;
-	u64			fw_dbg_component;
-	/*[Drv Dbg Info]*/
-	u64			dbg_component;
-	u8			cmn_dbg_msg_period;
-	u16			cmn_dbg_msg_component;
-	u8			cmn_dbg_msg_cnt;
-	bool			is_disable_phy_api;
-	/*[Dummy]*/
-	bool			bool_dummy;
-	u8			u8_dummy;
-	u16			u16_dummy;
-	u32			u32_dummy;
-	/*[Link Info]*/
-	enum rf_path 		tx_path; /*PMAC Tx Path*/
-	enum rf_path 		rx_path;
-	/*[pmac]*/
-	bool			dyn_pmac_tri_en;
-	bool			pmac_tri_en;
-	u32			pmac_tri_idx;
-	u32			pmac_pwr_ofst;
-
-	/*@=== [HALBB Structure] ============================================*/
-#ifdef BB_8852A_2_SUPPORT
-	struct bb_8852a_2_info	bb_8852a_2_i;
-	struct bb_h2c_fw_cmw	bb_fw_cmw_i;
-	struct vht_mu_cr_backup_table vht_mu_backup_val;
-#endif
-#ifdef HALBB_DBCC_SUPPORT
-	struct bb_dbcc_info	bb_dbcc_i;
-#endif
-#ifdef HALBB_RA_SUPPORT
-	struct bb_ra_info	bb_ra_i[PHL_MAX_STA_NUM];
-#endif
-#ifdef HALBB_ENV_MNTR_SUPPORT
-	struct bb_env_mntr_info bb_env_mntr_i;
-#endif
-#ifdef HALBB_EDCCA_SUPPORT
-	struct bb_edcca_info	bb_edcca_i;
-#endif
-#ifdef HALBB_DFS_SUPPORT
-	struct bb_dfs_info	bb_dfs_i;
-#endif
-#ifdef HALBB_STATISTICS_SUPPORT
-	struct bb_stat_info	bb_stat_i;
-#endif
-#ifdef HALBB_DIG_SUPPORT
-	struct bb_dig_info	bb_dig_i;
-#endif
-#ifdef HALBB_CFO_TRK_SUPPORT
-	struct bb_cfo_trk_info	bb_cfo_trk_i;
-#endif
-#ifdef HALBB_UL_TB_CTRL_SUPPORT
-	struct bb_ul_tb_info	bb_ul_tb_i;
-#endif
-#ifdef HALBB_PHYSTS_PARSING_SUPPORT
-	struct bb_physts_info	bb_physts_i;
-#endif
-#ifdef HALBB_LA_MODE_SUPPORT
-	struct bb_la_mode_info	bb_la_mode_i;
-#endif
-	struct bb_pwr_ctrl_info	bb_pwr_ctrl_i;
-#ifdef HALBB_PWR_CTRL_SUPPORT
-	struct bb_dyncca_info	bb_dyncca_i;
-#endif
-
-#ifdef HALBB_PMAC_TX_SUPPORT
-	struct bb_plcp_info bb_plcp_i;
-#endif
-	struct bb_link_info	bb_link_i;
-	struct bb_path_info	bb_path_i;
-	struct bb_ch_info	bb_ch_i;
-	struct bb_api_info	bb_api_i;
-	struct bb_iot_info	bb_iot_i;
-	struct bb_dbg_info	bb_dbg_i;
-	struct bb_c2h_fw_tx_rpt	bb_fwtx_c2h_i;
-	struct bb_h2c_fw_tx_setting	bb_fwtx_h2c_i;
-	struct bb_h2c_fw_edcca	bb_fw_edcca_i;
-	struct bb_h2c_he_sigb	bb_h2c_he_sigb_i;
-	struct bb_fw_dbg_cmn_info	bb_fwdbg_i;
-	struct bb_cmn_rpt_info	bb_cmn_rpt_i;
-	struct bb_rpt_info bb_rpt_i;
-	struct rxevm_physts	rxevm;
-	struct bb_cmn_backup_info	bb_cmn_backup_i;
-	struct bb_spur_info 	bb_spur_i;
-#ifdef HALBB_CH_INFO_SUPPORT
-	struct bb_ch_rpt_info	bb_ch_rpt_i;
-#endif
-#ifdef HALBB_AUTO_DBG_SUPPORT
-	struct bb_auto_dbg_info bb_auto_dbg_i;
-#endif
-#ifdef HALBB_ANT_DIV_SUPPORT
-	struct bb_antdiv_info bb_ant_div_i;
-#endif
-#ifdef HALBB_DYN_L2H_SUPPORT
-	struct bb_dyn_l2h_info bb_dyn_l2h_i;
-#endif
-#ifdef HALBB_PATH_DIV_SUPPORT
-	struct bb_pathdiv_info bb_path_div_i;
-#endif
-	/*@=== [HALBB Timer] ================================================*/
-#ifdef HALBB_RUA_SUPPORT
-	/*struct rtw_rua_tbl rtw_rua_t;*/
-#endif
-#ifdef HALBB_DIG_MCC_SUPPORT
-	struct halbb_mcc_dm mcc_dm;
-#endif
-#ifdef HALBB_DYN_1R_CCA_SUPPORT
-	struct bb_dyn_1r_cca_info bb_dyn_1r_cca_i;
-#endif
-};
-
- 
-/*@--------------------------[Prptotype]-------------------------------------*/
-u8 halbb_get_rssi_min(struct bb_info *bb);
-void halbb_cmn_info_self_reset(struct bb_info *bb);
-void halbb_sta_info_dbg(struct bb_info *bb, char input[][16], u32 *_used,
-			char *output, u32 *_out_len);
-void halbb_supportability_dbg(struct bb_info *bb, char input[][16], u32 *_used,
-			     char *output, u32 *_out_len);
-void halbb_pause_func_dbg(struct bb_info *bb, char input[][16], u32 *_used,
-			  char *output, u32 *_out_len);
-void halbb_store_data(struct bb_info *bb);
-void halbb_sta_rssi_reset_all(struct bb_info *bb);
-#endif
diff --git a/os/board/rtl8720e/src/component/wifi/driver/src/hal/phy_g6/bb/halbb_ant_div.h b/os/board/rtl8720e/src/component/wifi/driver/src/hal/phy_g6/bb/halbb_ant_div.h
deleted file mode 100644
index 270684f46..000000000
--- a/os/board/rtl8720e/src/component/wifi/driver/src/hal/phy_g6/bb/halbb_ant_div.h
+++ /dev/null
@@ -1,284 +0,0 @@
-/******************************************************************************
- *
- * Copyright(c) 2007 - 2020  Realtek Corporation.
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of version 2 of the GNU General Public License as
- * published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
- * more details.
- *
- * The full GNU General Public License is included in this distribution in the
- * file called LICENSE.
- *
- * Contact Information:
- * wlanfae <wlanfae@realtek.com>
- * Realtek Corporation, No. 2, Innovation Road II, Hsinchu Science Park,
- * Hsinchu 300, Taiwan.
- *
- * Larry Finger <Larry.Finger@lwfinger.net>
- *
- *****************************************************************************/
-#ifndef __HALBB_ANT_DIV_H__
-#define __HALBB_ANT_DIV_H__
-
-/*@--------------------------[Define] ---------------------------------------*/
-#define EVM_BASED_ANTDIV 0
-#define CN_BASED_ANTDIV 1
-
-#define TP_MAX_DOMINATION 0
-#define TP_HIGHEST_DOMINATION 1
-#define TP_AVG_DOMINATION 2
-
-#define	ANTDIV_INIT	0xff
-#define	MAIN_ANT	1		/*@ant A or ant Main   or S1*/
-#define	AUX_ANT		2		/*@AntB or ant Aux   or S0*/
-#define	MAX_ANT		3		/* @3 for AP using*/
-
-#define ANT1_2G 0
-/* @= ANT2_5G for 8723D  BTG S1 RX S0S1 diversity for 8723D, TX fixed at S1 */
-#define ANT2_2G 1
-/* @= ANT1_5G for 8723D  BTG S0  RX S0S1 diversity for 8723D, TX fixed at S1 */
-
-#define ANTDIV_MAX_STA_NUM PHL_MAX_STA_NUM
-#define ANTDIV_RSSI_TH_HIGH	30
-#define ANTDIV_RSSI_TH_LOW	20
-#define ANTDIV_PERIOD	1
-#define ANTDIV_TRAINING_NUM 6
-
-#define FORCE_RSSI_DIFF 10
-
-#define ANTDIV_DELAY 1
-#define ANTDIV_INTVL 10
-
-#define ANTDIV_DEC_TP_HIGH 100
-#define ANTDIV_DEC_TP_LOW 5
-#define ANTDIV_DEC_EVM 4
-#define TP_LOWER_BOUND 1
-
-/* @Antenna Diversty Control type */
-#define	ODM_AUTO_ANT		0
-#define	ODM_FIX_MAIN_ANT	1
-#define	ODM_FIX_AUX_ANT		2
-
-#define ANTDIV_ON	1
-#define ANTDIV_OFF	0
-
-#define ANT_PATH_A	0
-#define ANT_PATH_B	1
-#define ANT_PATH_AB	2
-
-/*@--------------------------[Enum]------------------------------------------*/
-enum bb_antdiv_mode_t {
-	AUTO_ANT	= 0,
-	FIX_MAIN_ANT	= 1,
-	FIX_AUX_ANT	= 2,
-};
-
-enum bb_tp_method_t {
-	TP_MAX	= 0,
-	TP_HIGHEST	= 1,
-	TP_AVG	= 2,
-};
-
-enum bb_evm_method_t {
-	EVM_LINEAR_AVG	= 0,
-	EVM_DB_AVG	= 1,
-};
-
-enum bb_antdiv_method_t {
-	EVM_BASED	= 0,
-	CN_BASED	= 1,
-};
-
-
-/*@--------------------------[Structure]-------------------------------------*/
-
-struct bb_antdiv_rssi_info { /*all in U(8,1)*/
-	/*acc value*/
-	u32 rssi_cck_avg_acc;
-	u32 rssi_ofdm_avg_acc;
-	u32 rssi_t_avg_acc;
-	u8 rssi_cck_avg;
-	u8 rssi_ofdm_avg;
-	u8 rssi_t_avg;
-	u8 rssi_final;
-	u16 pkt_cnt_t;
-	u16 pkt_cnt_cck;
-	u16 pkt_cnt_ofdm;
-};
-
-struct bb_antdiv_cn_info {
-	u32 main_cn_avg_acc;  /*U(7,1)*/
-	u32 aux_cn_avg_acc;  /*U(7,1)*/
-};
-
-struct bb_antdiv_evm_info {
-	u32 main_evm_1ss;/*U(8,2)*/ /*only for 1SS & L-OFDM*/
-	u32 main_evm_min_acc; /*U(8,2)*/ /*only for >= 2SS*/
-	u32 main_evm_max_acc; /*U(8,2)*/ /*only for >= 2SS*/
-	u32 aux_evm_1ss;/*U(8,2)*/ /*only for 1SS & L-OFDM*/
-	u32 aux_evm_min_acc; /*U(8,2)*/ /*only for >= 2SS*/
-	u32 aux_evm_max_acc; /*U(8,2)*/ /*only for >= 2SS*/
-	u8 evm_diff;
-	bool no_change_flag;
-};
-
-struct bb_antdiv_rate_info {
-	/*====[Phy rate counter main ant]=============================================*/
-	u16		main_pkt_cnt_cck;
-	u16		main_pkt_cnt_ofdm; /*L-OFDM*/
-	u16		main_pkt_cnt_t; /*HT, VHT, HE = pkt_cnt_1ss + pkt_cnt_2ss*/
-	u16		main_pkt_cnt_1ss; /*HT, VHT, HE*/
-	u16		main_pkt_cnt_2ss; /*HT, VHT, HE*/
-	/*Legacy*/
-	u16		main_pkt_cnt_legacy[LEGACY_RATE_NUM];
-	/*HT*/
-	u16		main_pkt_cnt_ht[HT_RATE_NUM];
-	/*VHT*/
-	u16		main_pkt_cnt_vht[VHT_RATE_NUM];
-	/*HE*/
-	u16		main_pkt_cnt_he[HE_RATE_NUM];
-	
-	u16		main_max_cnt;
-	u16		main_max_idx;
-	/*====[Phy rate counter] aux ant=============================================*/
-	u16		aux_pkt_cnt_cck;
-	u16		aux_pkt_cnt_ofdm; /*L-OFDM*/
-	u16		aux_pkt_cnt_t; /*HT, VHT, HE = pkt_cnt_1ss + pkt_cnt_2ss*/
-	u16		aux_pkt_cnt_1ss; /*HT, VHT, HE*/
-	u16		aux_pkt_cnt_2ss; /*HT, VHT, HE*/
-	/*Legacy*/
-	u16		aux_pkt_cnt_legacy[LEGACY_RATE_NUM];
-	/*HT*/
-	u16		aux_pkt_cnt_ht[HT_RATE_NUM];
-	/*VHT*/
-	u16		aux_pkt_cnt_vht[VHT_RATE_NUM];
-	/*HE*/
-	u16		aux_pkt_cnt_he[HE_RATE_NUM];
-
-	u16		aux_max_cnt;
-	u16		aux_max_idx;
-	u16		main_cnt_all;
-	u16		aux_cnt_all;
-
-	u64		main_tp;
-	u64		aux_tp;
-	u64		tp_diff;
-
-	bool no_change_flag;
-	bool main_ht_pkt_not_zero;
-	bool main_vht_pkt_not_zero;
-	bool main_he_pkt_not_zero;
-	bool aux_ht_pkt_not_zero;
-	bool aux_vht_pkt_not_zero;
-	bool aux_he_pkt_not_zero;
-};
-
-struct bb_antdiv_cr_info {
-	u32 path0_r_ant_train_en;			
-	u32 path0_r_ant_train_en_m;			
-	u32 path0_r_tx_ant_sel;				
-	u32 path0_r_tx_ant_sel_m;			
-	u32 path0_r_rfe_buf_en;				
-	u32 path0_r_rfe_buf_en_m;			
-	u32 path0_r_lnaon_agc;				
-	u32 path0_r_lnaon_agc_m;			
-	u32 path0_r_trsw_bit_bt;			
-	u32 path0_r_trsw_bit_bt_m;			
-	u32 path0_r_trsw_s;					
-	u32 path0_r_trsw_s_m;				
-	u32 path0_r_trsw_o;					
-	u32 path0_r_trsw_o_m;				
-	u32 path0_r_trswb_o;
-	u32 path0_r_trswb_o_m;				
-	u32 path0_r_bt_force_antidx;		
-	u32 path0_r_bt_force_antidx_m;		
-	u32 path0_r_bt_force_antidx_en;		
-	u32 path0_r_bt_force_antidx_en_m;	
-	u32 path0_r_ant_module_rfe_opt;		
-	u32 path0_r_ant_module_rfe_opt_m;	
-	u32 path0_r_rfsw_tr;
-	u32 path0_r_rfsw_tr_m;
-	u32 path0_r_antsel;
-	u32 path0_r_antsel_m;				
-	u32 path0_r_rfsw_ant_31_0;			
-	u32 path0_r_rfsw_ant_31_0_m;		
-	u32 path0_r_rfsw_ant_63_32;		
-	u32 path0_r_rfsw_ant_63_32_m;		
-	u32 path0_r_rfsw_ant_95_64;		
-	u32 path0_r_rfsw_ant_95_64_m;		
-	u32 path0_r_rfsw_ant_127_96;		
-	u32 path0_r_rfsw_ant_127_96_m;		
-};
-
-struct bb_antdiv_info {
-	struct bb_antdiv_cr_info bb_antdiv_cr_i;
-	/* For CN cacluation */
-	struct bb_antdiv_cn_info bb_cn_i;
-	/* For EVM cacluation */
-	struct bb_antdiv_evm_info bb_evm_i;
-	/* For MCS cacluation */
-	struct bb_antdiv_rate_info bb_rate_i;
-	/* For RSSI */
-	struct bb_antdiv_rssi_info bb_rssi_i;
-	
-	enum	bb_antdiv_mode_t antdiv_mode;
-	enum	bb_antdiv_method_t antdiv_method;
-	enum	bb_antdiv_mode_t pre_antdiv_mode;
-	enum	bb_tp_method_t tp_decision_method;
-	enum	bb_evm_method_t evm_decision_method;
-
-	/* Training state & period related*/
-	u8	antdiv_wd_cnt;
-	u8	antdiv_training_state_cnt;
-	u32	antdiv_intvl;
-	u32	antdiv_delay;
-	u32	antdiv_train_num;
-	u8	antdiv_period;
-	u8	tp_lb;
-
-	/* antenna setting */
-	u8	pre_target_ant;
-	u8	training_ant;
-	u8	target_ant;
-	u8	target_ant_cn;
-	u8	target_ant_evm;
-	u8	target_ant_tp;
-
-	/* Decision*/
-	u16 tp_diff_th_high;
-	u16 tp_diff_th_low;
-	u8 evm_diff_th;
-	
-	/*Phy-sts related */
-	bool get_stats;
-	bool antdiv_use_ctrl_frame;
-	struct halbb_timer_info antdiv_timer_i;
-};
-
-struct bb_info;
-/*@--------------------------[Prptotype]-------------------------------------*/
-void halbb_antdiv_io_en(struct bb_info *bb);
-void halbb_antdiv_timer_init(struct bb_info *bb);
-void halbb_cr_cfg_antdiv_init(struct bb_info *bb);
-void halbb_antdiv_reg_init(struct bb_info *bb);
-void halbb_antdiv_init(struct bb_info *bb);
-void halbb_antdiv_reset(struct bb_info *bb);
-void halbb_antdiv_reset_training_stat(struct bb_info *bb);
-void halbb_antdiv_set_ant(struct bb_info *bb, u8 ant);
-void halbb_antdiv_get_highest_mcs(struct bb_info *bb);
-void halbb_antdiv_get_evm_target_ant(struct bb_info *bb);
-void halbb_antdiv_training_state(struct bb_info *bb);
-void halbb_antdiv_decision_state(struct bb_info *bb);
-void halbb_evm_based_antdiv(struct bb_info *bb);
-void halbb_antenna_diversity(struct bb_info *bb);
-void halbb_antdiv_phy_sts(struct bb_info *bb, u32 physts_bitmap,
-		       struct physts_rxd *desc);
-void halbb_antdiv_dbg(struct bb_info *bb, char input[][16], u32 *_used,
-			      char *output, u32 *_out_len);
-#endif
-
diff --git a/os/board/rtl8720e/src/component/wifi/driver/src/hal/phy_g6/bb/halbb_api.h b/os/board/rtl8720e/src/component/wifi/driver/src/hal/phy_g6/bb/halbb_api.h
deleted file mode 100644
index fa144a231..000000000
--- a/os/board/rtl8720e/src/component/wifi/driver/src/hal/phy_g6/bb/halbb_api.h
+++ /dev/null
@@ -1,78 +0,0 @@
-/******************************************************************************
- *
- * Copyright(c) 2019 Realtek Corporation.
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of version 2 of the GNU General Public License as
- * published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
- * more details.
- *
- *****************************************************************************/
-#ifndef _HALBB_API_H_
-#define _HALBB_API_H_
-
-#include "halbb_ic_hw_info.h"
-#include "halbb_dbcc_ex.h"
-
-/*@--------------------------[Define] ---------------------------------------*/
-#define IGI_2_RSSI(igi)		(igi - 10)
-
-#define FUNC_ENABLE 1
-#define FUNC_DISABLE 2
-/*@--------------------------[Enum]------------------------------------------*/
-enum bb_rfe_src_sel {
-	PAPE_RFM		= 0,
-	GNT_BT_INV		= 1,
-	LNA0N			= 2,
-	LNAON_RFM		= 3,
-	TRSW_RFM		= 4,
-	TRSW_RFM_B		= 5,
-	GNT_BT			= 6,
-	ZERO			= 7,
-	ANTSEL_0		= 8,
-	ANTSEL_1		= 9,
-	ANTSEL_2		= 0xa,
-	ANTSEL_3		= 0xb,
-	ANTSEL_4		= 0xc,
-	ANTSEL_5		= 0xd,
-	ANTSEL_6		= 0xe,
-	ANTSEL_7		= 0xf
-};
-
-
-/*@--------------------------[Structure]-------------------------------------*/
-struct bb_api_info {
-	u32 rxiqc_reg1; /*N-mode: for pathA REG0xc14*/
-	u32 rxiqc_reg2; /*N-mode: for pathB REG0xc1c*/
-	u8 tx_queue_bitmap; /*REG0x520[23:16]*/
-	u8 ccktx_path;
-	u8 pri_ch_idx;
-	u8 central_ch;
-	u8 bw;
-	enum band_type band;
-};
-/*@--------------------------[Prptotype]-------------------------------------*/
-struct bb_info;
-u8 halbb_ch_2_band(struct bb_info *bb, u8 fc_ch);
-u16 halbb_get_csi_buf_idx(struct bb_info *bb, u8 buf_idx, u8 txsc_idx);
-
-void halbb_reset_bb_phy(struct bb_info *bb, enum phl_phy_idx phy_idx);
-void halbb_gpio_setting_init(struct bb_info *bb);
-void halbb_pre_agc_en(struct bb_info *bb, bool enable);
-void halbb_set_gain_error(struct bb_info *bb, u8 central_ch, enum band_type band, enum rf_path path);
-u8 halbb_stop_ic_trx(struct bb_info *bb, u8 set_type);
-void halbb_ic_api_dbg(struct bb_info *bb, char input[][16], u32 *_used,
-			char *output, u32 *_out_len);
-u16 halbb_fc_mapping(struct bb_info *bb, enum band_type band, u8 central_ch);
-void halbb_ic_hw_setting_non_io(struct bb_info *bb);
-void halbb_ic_hw_setting_low_io(struct bb_info *bb);
-void halbb_ic_hw_setting_dbcc(struct bb_info *bb);
-void halbb_ic_hw_setting(struct bb_info *bb);
-void halbb_ic_hw_setting_dbg(struct bb_info *bb, char input[][16], 
-			     u32 *_used, char *output, u32 *_out_len);
-void halbb_btc_bb_switchchannel_para(struct bb_info *bb, u8 central_ch, u8 bt_on);
-#endif
diff --git a/os/board/rtl8720e/src/component/wifi/driver/src/hal/phy_g6/bb/halbb_api_ex.h b/os/board/rtl8720e/src/component/wifi/driver/src/hal/phy_g6/bb/halbb_api_ex.h
deleted file mode 100644
index f2a7cc6d2..000000000
--- a/os/board/rtl8720e/src/component/wifi/driver/src/hal/phy_g6/bb/halbb_api_ex.h
+++ /dev/null
@@ -1,118 +0,0 @@
-/******************************************************************************
- *
- * Copyright(c) 2020 Realtek Corporation.
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of version 2 of the GNU General Public License as
- * published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
- * more details.
- *
- *****************************************************************************/
-#ifndef _HALBB_API_EX_H_
-#define _HALBB_API_EX_H_
-#include "halbb_ic_hw_info.h"
-#include "halbb_api.h"
-/*@--------------------------[Prptotype]-------------------------------------*/
-struct bb_info;
-struct bb_mcc_i {
-	enum role_type type;
-	struct rtw_chan_def *chandef;
-	u32 *macid_bitmap;
-	u8 macid_map_len;
-	u8 self_macid;
-};
-
-u16 halbb_cfg_cmac_tx_ant(struct bb_info *bb, enum rf_path tx_path);
-void halbb_gpio_setting_all(struct bb_info *bb, u8 rfe_idx);
-void halbb_gpio_setting(struct bb_info *bb, u8 gpio_idx, enum bb_path path,
-			bool inv, enum bb_rfe_src_sel src);
-u8 halbb_get_txsc(struct bb_info *bb, u8 pri_ch, u8 central_ch,
-		  enum channel_width cbw, enum channel_width dbw);
-
-void halbb_reset_bb(struct bb_info *bb);
-
-u32 halbb_read_rf_reg(struct bb_info *bb, enum rf_path path, u32 addr, u32 mask);
-
-bool halbb_write_rf_reg(struct bb_info *bb, enum rf_path path, u32 addr, u32 mask,
-			u32 data);
-bool halbb_rf_set_bb_reg(struct bb_info *bb, u32 addr, u32 bit_mask, u32 data);
-u32 halbb_rf_get_bb_reg(struct bb_info *bb, u32 addr, u32 mask);
-void halbb_ctrl_rf_mode(struct bb_info *bb, enum phl_rf_mode mode);
-
-bool halbb_ctrl_rx_path(struct bb_info *bb, enum rf_path rx_path);
-
-bool halbb_ctrl_tx_path(struct bb_info *bb, enum rf_path rx_path);
-
-void halbb_ctrl_trx_path(struct bb_info *bb, enum rf_path tx_path, u8 tx_nss,
-			 enum rf_path rx_path, u8 rx_nss);
-
-void halbb_tssi_bb_reset(struct bb_info *bb);
-
-void halbb_dfs_en(struct bb_info *bb, bool en);
-
-void halbb_adc_en(struct bb_info *bb, bool en);
-
-void halbb_tssi_cont_en(struct bb_info *bb, bool en, enum rf_path path);
-
-void halbb_bb_reset_en(struct bb_info *bb, bool en, enum phl_phy_idx phy_idx);
-
-bool halbb_ctrl_bw(struct bb_info *bb, u8 pri_ch, enum band_type band, enum channel_width bw,
-		   enum phl_phy_idx phy_idx);
-
-bool halbb_ctrl_bw_ch(struct bb_info *bb, u8 pri_ch, u8 central_ch_seg0,
-		      u8 central_ch_seg1, enum band_type band,
-		      enum channel_width bw, enum phl_phy_idx phy_idx);
-
-void halbb_ctrl_rx_cca(struct bb_info *bb, bool cca_en, enum phl_phy_idx phy_idx);
-
-bool halbb_query_cck_en(struct bb_info *bb, enum phl_phy_idx phy_idx);
-
-void halbb_ctrl_cck_en(struct bb_info *bb, bool cck_enable,
-		       enum phl_phy_idx phy_idx);
-
-void halbb_ctrl_ofdm_en(struct bb_info *bb, bool ofdm_enable,
-			enum phl_phy_idx phy_idx);
-
-void halbb_ctrl_btg(struct bb_info *bb, bool btg);
-
-void halbb_ctrl_btc_preagc(struct bb_info *bb, bool bt_en);
-
-void halbb_pop_en(struct bb_info *bb, bool en, enum phl_phy_idx phy_idx);
-
-bool halbb_querry_pop_en(struct bb_info *bb, enum phl_phy_idx phy_idx);
-
-bool halbb_set_pd_lower_bound(struct bb_info *bb, u8 bound,
-			      enum channel_width bw, enum phl_phy_idx phy_idx);
-
-bool halbb_set_pd_lower_bound_cck(struct bb_info *bb, u8 bound,
-			      enum channel_width bw, enum phl_phy_idx phy_idx);
-
-u8 halbb_querry_pd_lower_bound(struct bb_info *bb, bool get_en_info,
-			       enum phl_phy_idx phy_idx);
-
-u8 halbb_get_losel(struct bb_info *bb);
-
-void halbb_set_igi(struct bb_info *bb, u8 lna_idx, bool tia_idx, u8 rxbb_idx,
-		   enum rf_path path);
-void halbb_set_tx_pow_pattern_shap(struct bb_info *bb, u8 ch,
-				   bool is_ofdm, enum phl_phy_idx phy_idx);
-void halbb_set_tx_pow_ref(struct bb_info *bb, enum phl_phy_idx phy_idx);
-
-void halbb_normal_efuse_verify(struct bb_info *bb, s8 rx_gain_offset,
-			       enum rf_path rx_path, enum phl_phy_idx phy_idx);
-
-u8 halbb_upd_mcc_macid(struct bb_info *bb, struct bb_mcc_i *mi);
-
-void halbb_mcc_stop(struct bb_info *bb);
-
-u8 halbb_mcc_start(struct bb_info *bb, struct bb_mcc_i *mi_1,
-		   struct bb_mcc_i *mi_2);
-
-void halbb_normal_efuse_verify_cck(struct bb_info *bb, s8 rx_gain_offset,
-				   enum rf_path rx_path,
-				   enum phl_phy_idx phy_idx);
-#endif
\ No newline at end of file
diff --git a/os/board/rtl8720e/src/component/wifi/driver/src/hal/phy_g6/bb/halbb_auto_dbg.h b/os/board/rtl8720e/src/component/wifi/driver/src/hal/phy_g6/bb/halbb_auto_dbg.h
deleted file mode 100644
index 84b1e7115..000000000
--- a/os/board/rtl8720e/src/component/wifi/driver/src/hal/phy_g6/bb/halbb_auto_dbg.h
+++ /dev/null
@@ -1,55 +0,0 @@
-/******************************************************************************
- *
- * Copyright(c) 2007 - 2020  Realtek Corporation.
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of version 2 of the GNU General Public License as
- * published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
- * more details.
- *
- * The full GNU General Public License is included in this distribution in the
- * file called LICENSE.
- *
- * Contact Information:
- * wlanfae <wlanfae@realtek.com>
- * Realtek Corporation, No. 2, Innovation Road II, Hsinchu Science Park,
- * Hsinchu 300, Taiwan.
- *
- * Larry Finger <Larry.Finger@lwfinger.net>
- *
- *****************************************************************************/
-#ifndef __HALBB_AUTO_DBG_H__
-#define __HALBB_AUTO_DBG_H__
-#ifdef HALBB_AUTO_DBG_SUPPORT
-/*@--------------------------[Define] ---------------------------------------*/
-
-/*@--------------------------[Enum]------------------------------------------*/
-enum bb_auto_dbg_t {
-	AUTO_DBG_CHECK_HANG	= BIT(0),
-	AUTO_DBG_CHECK_TX	= BIT(1)
-};
-
-/*@--------------------------[Structure]-------------------------------------*/
-
-struct bb_chk_hang_info {
-	u32 table_size;
-	u32 *dbg_port_table;
-	u32 *dbg_port_val;
-};
-
-struct bb_auto_dbg_info {
-	enum bb_auto_dbg_t auto_dbg_type;
-	struct bb_chk_hang_info bb_chk_hang_i;
-};
-
-struct bb_info;
-/*@--------------------------[Prptotype]-------------------------------------*/
-void halbb_auto_debug(struct bb_info *bb);
-void halbb_auto_debug_init(struct bb_info *bb);
-#endif
-#endif
-
diff --git a/os/board/rtl8720e/src/component/wifi/driver/src/hal/phy_g6/bb/halbb_cfg_ic.h b/os/board/rtl8720e/src/component/wifi/driver/src/hal/phy_g6/bb/halbb_cfg_ic.h
deleted file mode 100644
index 2aecaaa26..000000000
--- a/os/board/rtl8720e/src/component/wifi/driver/src/hal/phy_g6/bb/halbb_cfg_ic.h
+++ /dev/null
@@ -1,54 +0,0 @@
-/******************************************************************************
- *
- * Copyright(c) 2007 - 2020  Realtek Corporation.
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of version 2 of the GNU General Public License as
- * published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
- * more details.
- *
- * The full GNU General Public License is included in this distribution in the
- * file called LICENSE.
- *
- * Contact Information:
- * wlanfae <wlanfae@realtek.com>
- * Realtek Corporation, No. 2, Innovation Road II, Hsinchu Science Park,
- * Hsinchu 300, Taiwan.
- *
- * Larry Finger <Larry.Finger@lwfinger.net>
- *
- *****************************************************************************/
-#ifndef __HALBB_CFG_IC_H__
-#define __HALBB_CFG_IC_H__
-
-#ifdef CONFIG_RTL8852A
-	//#define BB_8852A_CAV_SUPPORT /*CAV*/
-	#define BB_8852A_2_SUPPORT /*> CBV*/
-#endif
-
-#if defined(CONFIG_RTL8852B) || defined(CONFIG_RTL8852BP)
-	#define BB_8852B_SUPPORT
-#endif
-
-#ifdef CONFIG_RTL8852C
-	#define BB_8852C_SUPPORT
-#endif
-
-#if defined(CONFIG_RTL8192XB) || defined(CONFIG_RTL8832BR)
-	#define BB_8192XB_SUPPORT
-#endif
-
-#ifdef CONFIG_RTL8730E
-#define BB_8730E_SUPPORT
-#endif
-
-#ifdef CONFIG_RTL8720E
-#define BB_8720E_SUPPORT
-#endif
-
-#endif
-
diff --git a/os/board/rtl8720e/src/component/wifi/driver/src/hal/phy_g6/bb/halbb_cfo_trk.h b/os/board/rtl8720e/src/component/wifi/driver/src/hal/phy_g6/bb/halbb_cfo_trk.h
deleted file mode 100644
index cfdbd9faa..000000000
--- a/os/board/rtl8720e/src/component/wifi/driver/src/hal/phy_g6/bb/halbb_cfo_trk.h
+++ /dev/null
@@ -1,200 +0,0 @@
-/******************************************************************************
- *
- * Copyright(c) 2007 - 2020  Realtek Corporation.
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of version 2 of the GNU General Public License as
- * published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
- * more details.
- *
- * The full GNU General Public License is included in this distribution in the
- * file called LICENSE.
- *
- * Contact Information:
- * wlanfae <wlanfae@realtek.com>
- * Realtek Corporation, No. 2, Innovation Road II, Hsinchu Science Park,
- * Hsinchu 300, Taiwan.
- *
- * Larry Finger <Larry.Finger@lwfinger.net>
- *
- *****************************************************************************/
-#ifndef __HALBB_CFO_TRK_H__
-#define __HALBB_CFO_TRK_H__
-
-/*@--------------------------[Define] ---------------------------------------*/
-
-#define		CFO_TRK_TH_SIZE		4
-#define		CFO_TRK_TH_4		30 /* @kHz disable CFO_Track threshold*/
-#define		CFO_TRK_TH_3		20 /* @kHz disable CFO_Track threshold*/
-#define		CFO_TRK_TH_2		10 /* @kHz disable CFO_Track threshold*/
-#define		CFO_TRK_TH_1		3 /* @kHz disable CFO_Track threshold*/
-#define		CFO_STEP_1		1 /* @kHz disable CFO_Track threshold*/
-#define		CFO_STEP_2		1 /* @kHz disable CFO_Track threshold*/
-#define		CFO_STEP_3		3 /* @kHz disable CFO_Track threshold*/
-#define		CFO_STEP_4		3 /* @kHz disable CFO_Track threshold*/
-#define		CFO_TRK_ENABLE_TH	3 /* @kHz enable CFO_Track threshold*/
-#define		CFO_TRK_STOP_TH		3 /* @kHz disable CFO_Track threshold*/
-#define		NO_PKT_RETURN_TH	10
-#define		CFO_VALID_BOUNDARY		50
-
-#define		CFO_SW_COMP_FINE_TUNE	5 /* @kHz expected CFO Comp. per Xcap ofst*/ /*0.8ppm~1ppm per Xcap ofst*/
-#define		DIGI_CFO_COMP_LIMIT 5 /* @kHz enable digital CFO comp threshold*/
-
-#define		DIGI_CFO_COMP_LIMIT	5 /* @kHz enable digital CFO comp threshold*/
-
-#define		CFO_RECORD_NUM		6
-#define		CFO_LIMIT_PERIOD	60 /*60 sec*/
-
-#define		SC_XO			1 /* xcap setting output value */
-#define		SC_XI			0 /* xcap setting input value */
-
-#define		STA_CFO_TOLERANCE_2G	30 /* kHz */
-#define		STA_CFO_TOLERANCE_5G	80 /* kHz */
-
-#define		CFO_HW_RPT_2_KHZ(val) (((val) << 1) + ((val) >> 1))
-#define		CFO_PERIOD_CNT	15
-#define		CFO_TP_UPPER	100 /*MHz*/
-#define		CFO_TP_LOWER	50 /*MHz*/
-#define		CFO_COMP_PERIOD	250 /*ms*/
-#define		CFO_TF_CNT_TH 300
-/*@--------------------------[Enum]------------------------------------------*/
-
-enum bb_cfo_trk_src_t {
-	CFO_SRC_FD = 0,
-	CFO_SRC_PREAMBLE = 1
-};
-
-enum bb_cfo_trk_st_t {
-	CFO_STATE_0 = 0,
-	CFO_STATE_1 = 1,
-	CFO_STATE_2 =2
-};
-
-enum bb_cfo_trk_acc_mode_t {
-	CFO_ACC_MODE_0 = 0,   /*disable ul_ofdma cfo acc after 30s acc*/
-	CFO_ACC_MODE_1 = 1,   /*enable ul_ofdma cfo acc after 30s acc*/
-};
-enum multi_sta_cfo_mode_t {
-	PKT_BASED_AVG_MODE	= 0,
-	ENTRY_BASED_AVG_MODE	= 1,
-	TP_BASED_AVG_MODE	= 2,
-};
-
-#ifdef BB_DYN_CFO_TRK_LOP
-enum bb_dctl_state_t {
-	DCTL_SNR = 0,
-	DCTL_LINK = 1,
-	DCTL_NUM
-};
-#endif
-
-/*@--------------------------[Structure]-------------------------------------*/
-
-#ifdef BB_DYN_CFO_TRK_LOP
-struct bb_cfo_trk_lop_cr_info {
-	u8 dctl_data; /*data tracking loop filter bandwidth selection for 3rd step*/
-	u8 dctl_pilot; /*pilot tracking loop filter bandwidth selection for 3rd step*/
-};
-
-struct bb_dyn_cfo_trk_lop_info {
-	bool			dyn_cfo_trk_loop_en;
-	enum bb_dctl_state_t	dyn_cfo_trk_loop_state;
-	u16			dctl_snr_th_l;
-	u16			dctl_snr_th_h;
-	u8			dctl_hold_cnt;
-	struct bb_cfo_trk_lop_cr_info  bb_cfo_trk_lop_cr_i[DCTL_NUM];
-};
-#endif
-
-struct bb_cfo_trk_cr_info {
-	u32 r_cfo_comp_seg0_312p5khz;
-	u32 r_cfo_comp_seg0_312p5khz_m;
-	u32 r_cfo_comp_seg0_vld;
-	u32 r_cfo_comp_seg0_vld_m;
-	u32 r_cfo_wgting;
-	u32 r_cfo_wgting_m;
-};
-
-struct bb_cfo_rc_info {
-	u8		step_history[CFO_RECORD_NUM];
-	u8		step_bitmap;
-	bool		damping_lock_en;
-	bool		force_damping_step;
-	u32		limit_time;
-};
-
-struct bb_cfo_diver_info {
-	bool		divergence_lock_en;
-	u32		limit_time;
-};
-
-struct bb_cfo_trk_info {
-	struct	bb_cfo_trk_cr_info	bb_cfo_trk_cr_i;
-#ifdef HALBB_CFO_DAMPING_CHK
-	struct	bb_cfo_rc_info		bb_cfo_rc_i;
-#endif
-	struct	bb_cfo_diver_info	bb_cfo_div_i;
-	bool		cfo_trig_by_timer_en;
-	bool		is_adjust;	/*@already modify crystal cap*/
-	u8		cfo_th[CFO_TRK_TH_SIZE]; /*u(8,2)*/
-	u8		step[CFO_TRK_TH_SIZE];
-	u8		cfo_th_en;
-	u8		cfo_th_stop; /*u(8,2)*/
-	s8		x_cap_ofst;
-	u8		crystal_cap;
-	u8		def_x_cap;
-	u8		x_cap_ub;
-	u8		x_cap_lb;
-	s32		cfo_avg_pre; /*S(12,2), -512~+511.75 kHz*/
-	u32		cfo_pkt_cnt;
-	u8		no_pkt_cnt;
-	u32		rvrt_val; /*all rvrt_val for pause API must set to u32*/
-	u8		tb_tx_comp_cfo_th; /*u(8,2)*/
-	u8		sw_comp_fine_tune; /*u(8,2)*/
-	u8		bb_cfo_trk_cnt;
-	u8		sta_cfo_tolerance;
-	bool		man_cfo_tol;
-	bool		cfo_dyn_acc_en;
-	bool		cfo_trk_by_data_en;
-	u8		cfo_period_cnt;
-	u32		cfo_tf_cnt_th;
-	u32		cfo_tf_cnt_pre;
-	enum bb_cfo_trk_src_t		cfo_src;
-	enum bb_cfo_trk_st_t		bb_cfo_trk_state;
-	enum bb_cfo_trk_acc_mode_t bb_cfo_trk_acc_mode;
-	enum multi_sta_cfo_mode_t	multi_sta_cfo_mode;
-	#ifdef BB_DYN_CFO_TRK_LOP
-	struct bb_dyn_cfo_trk_lop_info bb_dyn_cfo_trk_lop_i;
-	#endif
-	struct halbb_timer_info cfo_timer_i;
-};
-
-
-struct bb_info;
-/*@--------------------------[Prptotype]-------------------------------------*/
-#ifdef BB_DYN_CFO_TRK_LOP
-void halbb_dyn_cfo_trk_loop_en(struct bb_info *bb, bool en);
-void halbb_cfo_trk_loop_cr_cfg(struct bb_info *bb, enum bb_dctl_state_t state);
-void halbb_dyn_cfo_trk_loop(struct bb_info *bb);
-void halbb_dyn_cfo_trk_loop_init(struct bb_info *bb);
-#endif
-void halbb_cfo_trk_init(struct bb_info *bb);
-void halbb_set_crystal_cap(struct bb_info *bb, u8 crystal_cap);
-void halbb_set_cfo_pause_val(struct bb_info *bb, u32 *val_buf, u8 val_len);
-void halbb_cfo_acc_io_en(struct bb_info *bb);
-void halbb_cfo_acc_timer_init(struct bb_info *bb);
-void halbb_cfo_dm(struct bb_info *bb);
-void halbb_cfo_watchdog(struct bb_info *bb);
-void halbb_parsing_cfo(struct bb_info *bb, u32 physts_bitmap,
-		       struct physts_rxd *desc);
-void halbb_cfo_trk_dbg(struct bb_info *bb, char input[][16], u32 *_used,
-		       char *output, u32 *_out_len);
-void halbb_cr_cfg_cfo_trk_init(struct bb_info *bb);
-void halbb_cfo_ul_ofdma_acc_enable(struct bb_info *bb);
-void halbb_cfo_ul_ofdma_acc_disable(struct bb_info *bb);
-void halbb_cfo_diver_init(struct bb_info *bb);
-#endif
diff --git a/os/board/rtl8720e/src/component/wifi/driver/src/hal/phy_g6/bb/halbb_ch_info.h b/os/board/rtl8720e/src/component/wifi/driver/src/hal/phy_g6/bb/halbb_ch_info.h
deleted file mode 100644
index 977d7224d..000000000
--- a/os/board/rtl8720e/src/component/wifi/driver/src/hal/phy_g6/bb/halbb_ch_info.h
+++ /dev/null
@@ -1,103 +0,0 @@
-/******************************************************************************
- *
- * Copyright(c) 2007 - 2020  Realtek Corporation.
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of version 2 of the GNU General Public License as
- * published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
- * more details.
- *
- * The full GNU General Public License is included in this distribution in the
- * file called LICENSE.
- *
- * Contact Information:
- * wlanfae <wlanfae@realtek.com>
- * Realtek Corporation, No. 2, Innovation Road II, Hsinchu Science Park,
- * Hsinchu 300, Taiwan.
- *
- * Larry Finger <Larry.Finger@lwfinger.net>
- *
- *****************************************************************************/
-#ifndef __HALBB_CH_INFO_H__
-#define __HALBB_CH_INFO_H__
-
-#ifdef HALBB_CH_INFO_SUPPORT
-/*@--------------------------[Define] ---------------------------------------*/
-#define TEST_CH_INFO_MAX_SEG	4
-#define TEST_CH_SEG_LEN	(12 * 8) /*Byte*/
-/*@--------------------------[Enum]------------------------------------------*/
-enum bb_ch_info_state_type {
-	CH_RPT_START_TO_WAIT = 0,
-	CH_RPT_GETTED = 1
-};
-/*@--------------------------[Structure]-------------------------------------*/
-struct bb_ch_info_physts_info {
-	enum bb_ch_info_state_type ch_info_state;
-	bool get_ch_rpt_success;
-	u16 force_bitmap_type; /*force setting*/
-	u16 bitmap_type_rpt; /*report*/
-	bool valid_ch_info_only_en;
-	bool filter_rxsc_en;
-	u8 filter_rxsc_tgrt_idx;
-	bool bitmap_type_auto_en;
-	u8 rxsc;
-	u8 n_rx;
-	u8 n_sts;
-	u16 ch_info_len;
-	u8 evm_1_sts;
-	u8 evm_2_sts;
-	u8 avg_idle_noise_pwr;
-	bool is_ch_info_len_valid;
-	enum rtw_gi_ltf gi_ltf;
-	u16 data_rate;
-};
-
-struct bb_ch_info_raw_info {
-	s16 *octet;
-	u32 ch_info_buf_len; /*Byte*/
-};
-
-struct bb_ch_info_cr_info {
-	u32 ch_info_en_0;
-	u32 ele_bitmap;
-	u32 ch_info_type;
-	u32 ch_info_type_m;
-	u32 seg_len;
-	u32 seg_len_m;
-};
-
-struct bb_ch_rpt_info {
-	u8 seg_idx_pre;
-	u32 csi_raw_data_total_len;  /*Raw data length(Unit: byte) = total_len - 16*/
-	u32 total_len_remnant;
-	u16 ch_rpt_hdr_len;
-	u16 phy_info_len;
-	bool skip_ch_info; /*wait for seg_0*/
-	u32 raw_data_len_acc;
-	u8 *test_buf;
-	u8 *test_buf_curr;
-	bool print_en;
-	enum bb_ch_info_en_t ch_info_data_mode;
-	struct bb_ch_info_cr_cfg_info bb_ch_info_cr_cfg_i;
-	struct bb_ch_info_cr_info bb_ch_info_cr_i; /*CR callback table*/
-	struct bb_ch_rpt_size_info bb_ch_rpt_size_i;
-	struct bb_ch_info_raw_info	bb_ch_info_raw_i; /*save dumped ch-info data*/
-	struct bb_ch_info_physts_info bb_ch_info_physts_i;
-};
-
-struct bb_info;
-/*@--------------------------[Prptotype]-------------------------------------*/
-bool halbb_ch_info_valid_chk_8852a(struct bb_info *bb, struct physts_rxd *desc);
-void halbb_ch_info_buf_rls(struct bb_info *bb);
-bool halbb_ch_info_buf_alloc(struct bb_info *bb);
-void halbb_ch_info_dbg(struct bb_info *bb, char input[][16], u32 *_used,
-		       char *output, u32 *_out_len);
-void halbb_ch_info_deinit(struct bb_info *bb);
-void halbb_ch_info_init(struct bb_info *bb);
-void halbb_cr_cfg_ch_info_init(struct bb_info *bb);
-#endif
-#endif
\ No newline at end of file
diff --git a/os/board/rtl8720e/src/component/wifi/driver/src/hal/phy_g6/bb/halbb_ch_info_ex.h b/os/board/rtl8720e/src/component/wifi/driver/src/hal/phy_g6/bb/halbb_ch_info_ex.h
deleted file mode 100644
index 33076afbe..000000000
--- a/os/board/rtl8720e/src/component/wifi/driver/src/hal/phy_g6/bb/halbb_ch_info_ex.h
+++ /dev/null
@@ -1,151 +0,0 @@
-/******************************************************************************
- *
- * Copyright(c) 2007 - 2020  Realtek Corporation.
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of version 2 of the GNU General Public License as
- * published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
- * more details.
- *
- * The full GNU General Public License is included in this distribution in the
- * file called LICENSE.
- *
- * Contact Information:
- * wlanfae <wlanfae@realtek.com>
- * Realtek Corporation, No. 2, Innovation Road II, Hsinchu Science Park,
- * Hsinchu 300, Taiwan.
- *
- * Larry Finger <Larry.Finger@lwfinger.net>
- *
- *****************************************************************************/
-#ifndef __HALBB_CH_INFO_EX_H__
-#define __HALBB_CH_INFO_EX_H__
-
-/*@--------------------------[Define] ---------------------------------------*/
-#define CH_DESI_OPT_NUM 4 /*CH info decimation number 1/2/4/16 */
-#define CH_INFO_BW_NUM 4 /*20/40/80/160*/
-#define CH_INFO_RXD_LEN 8 /*len of a ch_info */
-
-/*@--------------------------[Enum]------------------------------------------*/
-enum bb_ch_info_en_t {
-	CH_INFO_DISABLE = 0,
-	CH_INFO_FROM_PHY_STS = BIT0, /*Report CH info form phy-status*/
-	CH_INFO_FROM_CH_STS = BIT1 /*Report CH info form CH_info-status*/
-};
-
-enum bb_ch_info_t {
-	BB_CH_INFO_SUCCESS = 0, /*Get ch_info segment success*/
-	BB_CH_INFO_LAST_SEG, /*Get ch_info segment success, and which is the last segment*/
-	BB_CH_INFO_FAIL, /*Get ch_info segment fail*/
-};
-
-enum bb_ch_mode_t {
-	BB_CH_LEGACY_CH = 0,
-	BB_CH_MIMO_CH = 1
-};
-
-/*@--------------------------[Structure]-------------------------------------*/
-
-struct bb_ch_rpt_size_info {
-	u8 data_byte; /* 1&2 Byte, 1Byte:S(8,4), 2Byte:S(16,12)*/
-	u8 n_c; /*column of channel matrix, RX path number*/
-	u8 n_r; /*row of channel matrix, TX path number*/
-	u16 ch_info_rpt_len[CH_INFO_BW_NUM]; /*20,40,80; Unit: Byte; ch_info rpt length calculated by current tone decimatin configuration*/
-	u16 ch_info_rpt_len_he[CH_INFO_BW_NUM]; /*HE 20,40,80; Byte; ch_info rpt length calculated by current tone decimatin configuration*/
-	u16 ch_info_tone_num[CH_INFO_BW_NUM]; /*20,40,80; Byte; current tone decimatin configuration*/
-	u16 ch_info_tone_num_he[CH_INFO_BW_NUM]; /*HE 20,40,80; Byte; current tone decimatin configuration*/
-	u16 per_tone_ch_rpt_size; /*Per tone ch_info size*/
-	u16 tone_num[CH_INFO_BW_NUM][CH_DESI_OPT_NUM]; /*look up table for tone number under different tone decimatin CR configuration*/
-	u16 tone_num_he[CH_INFO_BW_NUM][CH_DESI_OPT_NUM];/*look up table for HE tone number under different tone decimatin CR configuration*/
-};
-
-struct bb_ch_info_cr_cfg_info {
-	bool	ch_i_data_src; /*0~1: CH-estimation, CH-smoothing*/
-	bool	ch_i_cmprs; /*0~1: 8/16 bit, 0:S(8,4), 1:S(16,12)*/
-	u8	ch_i_grp_num; /*[Lgcy/HT/VHT] 0~3: decimation to 1/1, 1/2, 1/4, 1/16*/
-	u8	ch_i_grp_num_he; /*[HE]0~3: decimation to 1/1, 1/2, 1/4, 1/16*/
-	u8	ch_i_blk_start_idx; /*1~10*/
-	u8	ch_i_blk_end_idx; /*1~10*/
-	u32	ch_i_ele_bitmap; /*Channel matrix size, ex: 0x303:2X2, 0x1: 1X1*/
-	enum bb_ch_mode_t ch_i_type; /*0~1: Legacy-CH, MIMO-CH*/
-	u8	ch_i_seg_len; /*0~3: 12/28/60/124 (8byte)*/
-};
-
-struct bb_ch_info_buf_cfg_info {
-	u8	ch_i_blk_start_idx; /*1~10*/
-	u8	ch_i_blk_end_idx; /*1~10*/
-	u8	ch_i_seg_len; /*0~3: 12/28/60/124 (8byte)*/
-};
-
-struct bb_ch_rpt_hdr_info {
-	u16 total_len_l; /*header(16byte) + Raw data length(Unit: byte)*/
-	#if (PLATFOM_IS_LITTLE_ENDIAN)
-	u8 total_len_m:1;
-	u8 total_seg_num:7;
-	#else
-	u8 total_seg_num:7;
-	u8 total_len_m:1;
-	#endif
-
-	u8 avg_noise_pow;
-	#if (PLATFOM_IS_LITTLE_ENDIAN)
-	u8 is_pkt_end:1;
-	u8 set_valid:1;
-	u8 n_rx:3;
-	u8 n_sts:3;
-	#else
-	u8 n_sts:3;
-	u8 n_rx:3;
-	u8 set_valid:1;
-	u8 is_pkt_end:1;
-	#endif
-	u8 segment_size; /*unit (8Byte)*/
-	u8 sts0_evm;
-	u8 seq_num;
-};
-
-struct bb_phy_info_rpt {
-	u8	rssi[2];
-	u16	rsvd_0;
-	u8	rssi_avg;
-	#if (PLATFOM_IS_LITTLE_ENDIAN)
-	u8	rxsc:4;
-	u8	sts1_evm_l:4;
-	u8	sts1_evm_m:4;
-	u8	rsvd_1:4;
-	#else
-	u8	rsvd_1:4;
-	u8	sts1_evm_m:4;
-	u8	sts1_evm_l:4;
-	u8	rxsc:4;
-	#endif
-	u8	rsvd_2;
-};
-
-struct bb_ch_info_drv_rpt {
-	u32 raw_data_len;
-	u8 seg_idx_curr;
-	bool get_ch_rpt_success;
-};
-
-struct bb_info;
-/*@--------------------------[Prptotype]-------------------------------------*/
-bool halbb_ch_info_wait_from_physts(struct bb_info *bb, u32 dly, u32 dly_max,
-				    u16 bitmap, bool valid_rpt_only);
-void halbb_ch_info_cfg_mu_buff_cr(struct bb_info *bb, bool en);
-bool halbb_cfg_ch_info_cr(struct bb_info *bb, struct bb_ch_info_cr_cfg_info *cfg);
-void halbb_ch_info_size_query(struct bb_info *bb, struct bb_ch_rpt_size_info *exp_rpt_size, enum phl_phy_idx phy_idx);
-void halbb_ch_info_physts_en(struct bb_info *bb, bool en,
-			     u16 bitmap, enum phl_phy_idx phy_idx);
-void halbb_ch_info_status_en(struct bb_info *bb, bool en, enum phl_phy_idx phy_idx);
-enum bb_ch_info_t halbb_ch_info_parsing(struct bb_info *bb, u8 *addr, u32 len,
-					u8 *rpt_buf,
-					struct bb_ch_rpt_hdr_info *hdr,
-					struct bb_phy_info_rpt *phy_info,
-					struct bb_ch_info_drv_rpt *drv);
-
-#endif
diff --git a/os/board/rtl8720e/src/component/wifi/driver/src/hal/phy_g6/bb/halbb_cmn_rpt.h b/os/board/rtl8720e/src/component/wifi/driver/src/hal/phy_g6/bb/halbb_cmn_rpt.h
deleted file mode 100644
index c25c517a3..000000000
--- a/os/board/rtl8720e/src/component/wifi/driver/src/hal/phy_g6/bb/halbb_cmn_rpt.h
+++ /dev/null
@@ -1,148 +0,0 @@
-/******************************************************************************
- *
- * Copyright(c) 2007 - 2020  Realtek Corporation.
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of version 2 of the GNU General Public License as
- * published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
- * more details.
- *
- * The full GNU General Public License is included in this distribution in the
- * file called LICENSE.
- *
- * Contact Information:
- * wlanfae <wlanfae@realtek.com>
- * Realtek Corporation, No. 2, Innovation Road II, Hsinchu Science Park,
- * Hsinchu 300, Taiwan.
- *
- * Larry Finger <Larry.Finger@lwfinger.net>
- *
- *****************************************************************************/
-#ifndef __HALBB_CMN_RPT_H__
-#define __HALBB_CMN_RPT_H__
-
-/*@--------------------------[Define] ---------------------------------------*/
-#define RSSI_MA_H 4 /*moving average factor for RSSI: 2^4=16 */
-#define RSSI_MA_M 3
-#define RSSI_MA_L 2
-#define RSSI_MA_UL 1
-
-#define BB_HIST_SIZE		12
-#define BB_HIST_TH_SIZE	(BB_HIST_SIZE - 1)
-
-#define POP_HIST_SIZE 4
-
-/*@--------------------------[Enum]------------------------------------------*/
-
-/*@--------------------------[Structure]-------------------------------------*/
-struct bb_rssi_mu_acc_info { /*all in U(8,1)*/
-	/*acc value*/
-	u32 rssi_t_avg_acc;
-	u32 rssi_t_acc[HALBB_MAX_PATH];  /*VHT, HE*/
-};
-
-struct bb_pkt_cnt_bcn_info {
-	u8		pkt_cnt_beacon;
-	u8		beacon_cnt_in_period; /*@beacon cnt within watchdog period*/
-	u16		beacon_phy_rate;
-};
-
-struct bb_rssi_su_acc_info { /*all in U(8,1)*/
-	/*acc value*/
-	u32 rssi_cck_avg_acc;
-	u32 rssi_cck_acc[HALBB_MAX_PATH];
-	u32 rssi_ofdm_avg_acc;
-	u32 rssi_ofdm_acc[HALBB_MAX_PATH]; /*L-OFDM*/
-	u32 rssi_t_avg_acc;
-	u32 rssi_t_acc[HALBB_MAX_PATH];  /*HT, VHT, HE*/
-};
-
-struct bb_pkt_cnt_cap_info {
-	u32 pkt_cnt_ldpc; /*pkt_cnt_ofdm = pkt_cnt_ldpc + pkt_cnt_bcc*/
-	u32 pkt_cnt_bcc;
-	u32 pkt_cnt_stbc;
-	u32 pkt_cnt_subf;
-	u32 pkt_cnt_mubf;
-};
-
-struct bb_physts_hist_info {
-	u16 evm_1ss[BB_HIST_SIZE];
-	u16 evm_min_hist[BB_HIST_SIZE];
-	u16 evm_max_hist[BB_HIST_SIZE];
-	u16 snr_avg_hist[BB_HIST_SIZE];
-	u16 cn_avg_hist[BB_HIST_SIZE];
-	u16 cfo_avg_hist[BB_HIST_SIZE]; /*ABS(cfo) 0~256 Khz*/
-};
-
-struct bb_physts_hist_th_info {
-	u8 evm_hist_th[BB_HIST_TH_SIZE]; /*threshold*/
-	u8 cn_hist_th[BB_HIST_TH_SIZE]; /*threshold*/
-	u8 cfo_hist_th[BB_HIST_TH_SIZE]; /*threshold*/
-};
-
-struct bb_physts_acc_info {
-	u32 evm_1ss;	/*U(8,2)*/ /*only for 1SS & L-OFDM*/
-	u32 evm_min_acc; /*U(8,2)*/ /*only for >= 2SS*/
-	u32 evm_max_acc; /*U(8,2)*/ /*only for >= 2SS*/
-	u32 snr_avg_acc; /*U(6,0)*/
-	u32 cn_avg_acc;  /*U(7,1)*/
-	s32 cfo_avg_acc; /*U(8,2)*/
-};
-
-struct bb_physts_avg_info {
-	u8 evm_1ss; /*U(8,2) 0~63*/
-	u8 evm_min; /*U(8,2) 0~63*/
-	u8 evm_max; /*U(8,2) 0~63*/
-	u8 snr_avg; /*U(6,0) 0~63*/
-	u8 cn_avg;  /*U(7,1) 0~63*/
-	s16 cfo_avg; /*U(16,2) 0~512*/
-};
-
-struct bb_physts_pop_info {
-	u16 pop_hist_cck[POP_HIST_SIZE]; /*U(8,0) pop_idx histogram*/
-	u16 pop_hist_ofdm[POP_HIST_SIZE]; /*U(8,0) pop_idx histogram*/
-};
-
-struct bb_cmn_rpt_info {
-	bool				is_cck_rate;
-	u8				consec_idle_prd_su; /*consecutive idle period*/
-	u8				consec_idle_prd_mu;
-	struct bb_rate_info		bb_rate_i;
-	struct bb_pkt_cnt_bcn_info	bb_pkt_cnt_bcn_i; /*beacon info*/
-	struct bb_pkt_cnt_cap_info	bb_pkt_cnt_all_i; /*capibility info*/
-	struct bb_pkt_cnt_su_info	bb_pkt_cnt_su_i; /*Packet count*/
-	struct bb_rssi_su_acc_info	bb_rssi_su_acc_i; /*acc RSSI*/
-	struct bb_rssi_su_avg_info	bb_rssi_su_avg_i; /*avg RSSI*/
-	struct bb_physts_hist_th_info	bb_physts_hist_th_i;
-	struct bb_physts_hist_info	bb_physts_hist_i; /*phy-sts histogram*/
-	struct bb_physts_acc_info 	bb_physts_acc_i; /*acc phy-sts*/
-	struct bb_physts_avg_info 	bb_physts_avg_i; /*avg phy-sts*/
-	struct bb_physts_pop_info 	bb_physts_pop_i; /*pop info*/
-	/*[MU]*/
-	struct bb_pkt_cnt_mu_info	bb_pkt_cnt_mu_i; /*Packet count*/
-	struct bb_rssi_mu_acc_info	bb_rssi_mu_acc_i; /*acc RSSI*/
-	struct bb_rssi_mu_avg_info	bb_rssi_mu_avg_i; /*avg RSSI*/
-	struct bb_pkt_cnt_su_store_info bb_pkt_cnt_su_store_i;
-};
-
-struct bb_info;
-/*@--------------------------[Prptotype]-------------------------------------*/
-void halbb_print_hist_2_buf_u8(struct bb_info *bb, u8 *val, u16 len, char *buf,
-			    u16 buf_size);
-void halbb_print_hist_2_buf(struct bb_info *bb, u16 *val, u16 len, char *buf,
-			    u16 buf_size);
-u16 halbb_get_plurality_rx_rate_mu(struct bb_info *bb);
-u16 halbb_get_plurality_rx_rate_su(struct bb_info *bb);
-void halbb_basic_dbg_07_hist_su(struct bb_info *bb);
-void halbb_show_rssi_and_rate_distribution_mu(struct bb_info *bb);
-void halbb_show_rssi_and_rate_distribution_su(struct bb_info *bb);
-void halbb_rx_pkt_cnt_rpt_reset(struct bb_info *bb);
-void halbb_cmn_rpt(struct bb_info *bb, struct physts_rxd *desc, u32 physts_bitmap);
-void halbb_cmn_info_rpt_store_data(struct bb_info *bb);
-void halbb_cmn_info_rpt_reset(struct bb_info *bb);
-void halbb_cmn_rpt_init(struct bb_info *bb);
-#endif
diff --git a/os/board/rtl8720e/src/component/wifi/driver/src/hal/phy_g6/bb/halbb_cmn_rpt_ex.h b/os/board/rtl8720e/src/component/wifi/driver/src/hal/phy_g6/bb/halbb_cmn_rpt_ex.h
deleted file mode 100644
index 7b7c9174d..000000000
--- a/os/board/rtl8720e/src/component/wifi/driver/src/hal/phy_g6/bb/halbb_cmn_rpt_ex.h
+++ /dev/null
@@ -1,106 +0,0 @@
-/******************************************************************************
- *
- * Copyright(c) 2007 - 2020  Realtek Corporation.
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of version 2 of the GNU General Public License as
- * published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
- * more details.
- *
- * The full GNU General Public License is included in this distribution in the
- * file called LICENSE.
- *
- * Contact Information:
- * wlanfae <wlanfae@realtek.com>
- * Realtek Corporation, No. 2, Innovation Road II, Hsinchu Science Park,
- * Hsinchu 300, Taiwan.
- *
- * Larry Finger <Larry.Finger@lwfinger.net>
- *
- *****************************************************************************/
-#ifndef __HALBB_CMN_RPT_EX_H__
-#define __HALBB_CMN_RPT_EX_H__
-
-/*@--------------------------[Define] ---------------------------------------*/
-
-/*@--------------------------[Enum]------------------------------------------*/
-
-/*@--------------------------[Structure]-------------------------------------*/
-struct bb_rssi_mu_avg_info { /*all in U(8,1)*/
-	u8 rssi_t_avg;
-	u8 rssi_t[HALBB_MAX_PATH];  /*VHT, HE*/
-};
-
-struct bb_rssi_su_avg_info { /*all in U(8,1)*/
-	u8 rssi_cck_avg;
-	u8 rssi_cck[HALBB_MAX_PATH];
-	u8 rssi_ofdm_avg;
-	u8 rssi_ofdm[HALBB_MAX_PATH]; /*L-OFDM*/
-	u8 rssi_t_avg;
-	u8 rssi_t[HALBB_MAX_PATH];  /*HT, VHT, HE*/
-};
-
-struct bb_pkt_cnt_mu_info {
-	/*====[Phy rate counter]=============================================*/
-	u16		pkt_cnt_all; /*VHT, HE = pkt_cnt_1ss + pkt_cnt_2ss*/
-	u16		gi_ltf_cnt[RTW_GILTF_MAX];
-	u16		pkt_cnt_1ss; /*VHT, HE*/
-	u16		pkt_cnt_2ss; /*VHT, HE*/
-	u16		pkt_cnt_sc20[LOW_BW_RATE_NUM]; /*@20M SC*/
-	bool		sc20_occur;
-	/*VHT*/
-	u16		pkt_cnt_vht[VHT_RATE_NUM];
-	u16		pkt_cnt_sc40[LOW_BW_RATE_NUM]; /*@40M SC*/
-	bool		vht_pkt_not_zero;
-	bool		sc40_occur;
-	/*HE*/
-	u16		pkt_cnt_he[HE_RATE_NUM];
-	bool		he_pkt_not_zero;
-};
-
-struct bb_pkt_cnt_su_store_info {
-	bool		ht_pkt_not_zero;
-	bool		vht_pkt_not_zero;
-	bool		he_pkt_not_zero;
-};
-
-struct bb_pkt_cnt_su_info {
-	/*====[Phy rate counter]=============================================*/
-	u16		pkt_cnt_all; /*CCK + OFDM + HT, VHT, HE*/
-	u16		gi_ltf_cnt[RTW_GILTF_MAX];
-	u16		pkt_cnt_cck;
-	u16		pkt_cnt_ofdm; /*L-OFDM*/
-	u16		pkt_cnt_t; /*HT, VHT, HE = pkt_cnt_1ss + pkt_cnt_2ss*/
-	u16		pkt_cnt_1ss; /*HT, VHT, HE*/
-	u16		pkt_cnt_2ss; /*HT, VHT, HE*/
-	/*Legacy*/
-	u16		pkt_cnt_legacy[LEGACY_RATE_NUM];
-	/*HT*/
-	u16		pkt_cnt_ht[HT_RATE_NUM];
-	u16		pkt_cnt_sc20[LOW_BW_RATE_NUM]; /*@20M SC*/
-	bool		ht_pkt_not_zero;
-	bool		sc20_occur;
-	/*VHT*/
-	u16		pkt_cnt_vht[VHT_RATE_NUM];
-	u16		pkt_cnt_sc40[LOW_BW_RATE_NUM]; /*@40M SC*/
-	bool		vht_pkt_not_zero;
-	bool		sc40_occur;
-	/*HE*/
-	u16		pkt_cnt_he[HE_RATE_NUM];
-	u16		pkt_cnt_sc80[LOW_BW_RATE_NUM]; /*@80M SC*/
-	bool		he_pkt_not_zero;
-	bool		sc80_occur;
-	/*non_data packet*/
-	u16		pkt_cnt_legacy_non_data[LEGACY_RATE_NUM];
-	u16		pkt_cnt_else_non_data;
-};
-
-struct bb_info;
-/*@--------------------------[Prptotype]-------------------------------------*/
-void halbb_get_rx_pkt_cnt_rpt_su(struct bb_info *bb, struct bb_pkt_cnt_su_info *pkt_cnt_rpt, enum phl_phy_idx phy_idx);
-
-#endif
diff --git a/os/board/rtl8720e/src/component/wifi/driver/src/hal/phy_g6/bb/halbb_dbcc.h b/os/board/rtl8720e/src/component/wifi/driver/src/hal/phy_g6/bb/halbb_dbcc.h
deleted file mode 100644
index 5e86db995..000000000
--- a/os/board/rtl8720e/src/component/wifi/driver/src/hal/phy_g6/bb/halbb_dbcc.h
+++ /dev/null
@@ -1,54 +0,0 @@
-/******************************************************************************
- *
- * Copyright(c) 2007 - 2020  Realtek Corporation.
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of version 2 of the GNU General Public License as
- * published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
- * more details.
- *
- * The full GNU General Public License is included in this distribution in the
- * file called LICENSE.
- *
- * Contact Information:
- * wlanfae <wlanfae@realtek.com>
- * Realtek Corporation, No. 2, Innovation Road II, Hsinchu Science Park,
- * Hsinchu 300, Taiwan.
- *
- * Larry Finger <Larry.Finger@lwfinger.net>
- *
- *****************************************************************************/
-#ifndef __HALBB_DBCC_H__
-#define __HALBB_DBCC_H__
-#ifdef HALBB_DBCC_SUPPORT
-/*@--------------------------[Define] ---------------------------------------*/
-	#define	HALBB_GET_PHY_PTR(bb, bb_out, phy_idx)\
-	do {								\
-		if ((bb->bb_phy_hooker) && (phy_idx != bb->bb_phy_idx) && (bb->phl_com->dev_cap.dbcc_sup))	\
-				bb_out = bb->bb_phy_hooker;		\
-		else							\
-				bb_out = bb;				\
-	} while (0)
-
-/*@--------------------------[Enum]------------------------------------------*/
- 
-/*@--------------------------[Structure]-------------------------------------*/
-struct bb_dbcc_info {
-	bool ic_dbcc_support;
-};
-
-/*@--------------------------[Prptotype]-------------------------------------*/
-struct bb_info;
-enum bb_path halbb_get_cur_phy_valid_path(struct bb_info *bb);
-void halbb_dbcc_early_init(struct bb_info *bb);
-void halbb_dbcc_dbg(struct bb_info *bb, char input[][16], u32 *_used,
-		       char *output, u32 *_out_len);
-struct bb_info *halbb_get_curr_bb_pointer(struct bb_info *bb,
-					  enum phl_phy_idx phy_idx);
-u32 halbb_buffer_init_phy1(struct bb_info *bb_phy_0);
-#endif
-#endif
\ No newline at end of file
diff --git a/os/board/rtl8720e/src/component/wifi/driver/src/hal/phy_g6/bb/halbb_dbcc_ex.h b/os/board/rtl8720e/src/component/wifi/driver/src/hal/phy_g6/bb/halbb_dbcc_ex.h
deleted file mode 100644
index 4ace5866e..000000000
--- a/os/board/rtl8720e/src/component/wifi/driver/src/hal/phy_g6/bb/halbb_dbcc_ex.h
+++ /dev/null
@@ -1,43 +0,0 @@
-/******************************************************************************
- *
- * Copyright(c) 2007 - 2020  Realtek Corporation.
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of version 2 of the GNU General Public License as
- * published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
- * more details.
- *
- * The full GNU General Public License is included in this distribution in the
- * file called LICENSE.
- *
- * Contact Information:
- * wlanfae <wlanfae@realtek.com>
- * Realtek Corporation, No. 2, Innovation Road II, Hsinchu Science Park,
- * Hsinchu 300, Taiwan.
- *
- * Larry Finger <Larry.Finger@lwfinger.net>
- *
- *****************************************************************************/
-#ifndef __HALBB_DBCC_EX_H__
-#define __HALBB_DBCC_EX_H__
-
-/*@--------------------------[Define] ---------------------------------------*/
-
-/*@--------------------------[Enum]------------------------------------------*/
-
-/*@--------------------------[Structure]-------------------------------------*/
-struct bb_dbcc_cfg_info {
-	bool dbcc_en;
-	enum phl_phy_idx cck_phy_map;
-};
-
-/*@--------------------------[Prptotype]-------------------------------------*/
-struct bb_info;
-bool halbb_ctrl_dbcc(struct bb_info *bb, bool dbcc_enable);
-bool halbb_cfg_dbcc_cck_phy_map(struct bb_info *bb, enum phl_phy_idx cck_phy_map);
-bool halbb_cfg_dbcc(struct bb_info *bb, struct bb_dbcc_cfg_info *cfg);
-#endif
diff --git a/os/board/rtl8720e/src/component/wifi/driver/src/hal/phy_g6/bb/halbb_dbg.h b/os/board/rtl8720e/src/component/wifi/driver/src/hal/phy_g6/bb/halbb_dbg.h
deleted file mode 100644
index c08a17943..000000000
--- a/os/board/rtl8720e/src/component/wifi/driver/src/hal/phy_g6/bb/halbb_dbg.h
+++ /dev/null
@@ -1,300 +0,0 @@
-/******************************************************************************
- *
- * Copyright(c) 2007 - 2020  Realtek Corporation.
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of version 2 of the GNU General Public License as
- * published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
- * more details.
- *
- * The full GNU General Public License is included in this distribution in the
- * file called LICENSE.
- *
- * Contact Information:
- * wlanfae <wlanfae@realtek.com>
- * Realtek Corporation, No. 2, Innovation Road II, Hsinchu Science Park,
- * Hsinchu 300, Taiwan.
- *
- * Larry Finger <Larry.Finger@lwfinger.net>
- *
- *****************************************************************************/
-#ifndef __HALBB_DBG_H__
-#define __HALBB_DBG_H__
-
-#include "../../hal_headers_le.h"
-
-/*@--------------------------[Define] ---------------------------------------*/
-#define HALBB_WATCHDOG_PERIOD	2 /*second*/
-
-#define PHY_HIST_SIZE		12
-#define PHY_HIST_TH_SIZE	(PHY_HIST_SIZE - 1)
-
-#define LA_CLK_EN 	0x014 /*Just for dbg, will be removed*/
-#define LA_CLK_EN_M 	0x1 /*Just for dbg, will be removed*/
-
-#define FRC_PRINT_LINE 0xffffffff
-
-#ifdef HALBB_DBG_TRACE_SUPPORT
-	#ifdef HALBB_DBCC_SUPPORT
-		#define BB_DBG(bb, comp, fmt, ...)     \
-			do {\
-				if(bb->dbg_component & comp) {\
-					_os_dbgdump("[BB][%d]" fmt, bb->bb_phy_idx, ##__VA_ARGS__);\
-				} \
-			} while (0)
-
-		#define BB_TRACE1(bb, fmt, ...)     \
-			do {\
-				_os_dbgdump("[BB][%d]" fmt, bb->bb_phy_idx, ##__VA_ARGS__);\
-			} while (0)
-	#else
-		#define BB_DBG(bb, comp, fmt, ...)     \
-			do {\
-				if(bb->dbg_component & comp) {\
-					_os_dbgdump("[BB]" fmt, ##__VA_ARGS__);\
-				} \
-			} while (0)
-
-		#define BB_TRACE1(bb, fmt, ...)     \
-			do {\
-				_os_dbgdump("[BB]" fmt, ##__VA_ARGS__);\
-			} while (0)
-	#endif
-
-	#define BB_TRACE(fmt, ...)     \
-		do {\
-			_os_dbgdump("[BB]" fmt, ##__VA_ARGS__);\
-		} while (0)
-		
-	#define BB_WARNING(fmt, ...)     \
-		do {\
-			_os_dbgdump("[WARNING][BB]" fmt, ##__VA_ARGS__);\
-		} while (0)
-
-	#define	BB_DBG_CNSL2(in_cnsl, max_buff_len, used_len, buff_addr, remain_len, fmt, ...)\
-		do {								\
-			u32 *used_len_tmp = &(used_len);			\
-			u32 len_tmp = 0;					\
-			if (*used_len_tmp < max_buff_len) {			\
-				len_tmp = _os_snprintf(buff_addr, remain_len, fmt, ##__VA_ARGS__); \
-				if (in_cnsl) {					\
-					*used_len_tmp += len_tmp; 		\
-				} else {					\
-					BB_TRACE("%s\n", buff_addr); 		\
-				}						\
-			}\
-		} while (0)
-#else
-	#define BB_DBG
-	#define BB_TRACE
-	#define BB_TRACE1
-	#define BB_WARNING
-	#define	BB_DBG_CNSL2(in_cnsl, max_buff_len, used_len, buff_addr, remain_len, fmt, ...)\
-		do {								\
-			u32 *used_len_tmp = &(used_len);				\
-			if (*used_len_tmp < max_buff_len)				\
-				*used_len_tmp += _os_snprintf(buff_addr, remain_len, fmt, ##__VA_ARGS__);\
-		} while (0)
-#endif
-
-#define BB_BRIEF(fmt, ...)     \
-	do {\
-		_os_dbgdump("[BB]" fmt, ##__VA_ARGS__);\
-	} while (0)
-
-#define BB_DBG_VAST(max_buff_len, used_len, buff_addr, remain_len, fmt, ...)\
-	do {\
-		_os_dbgdump("[CNSL]" fmt, ##__VA_ARGS__);\
-	} while (0)
-
-#define	BB_DBG_CNSL(max_buff_len, used_len, buff_addr, remain_len, fmt, ...)\
-	do {									\
-		u32 *used_len_tmp = &(used_len);				\
-		if (*used_len_tmp < max_buff_len)				\
-			*used_len_tmp += _os_snprintf(buff_addr, remain_len, fmt, ##__VA_ARGS__);\
-	} while (0)
-
-#define	DBGPORT_PRI_3	3	/*@Debug function (the highest priority)*/
-#define	DBGPORT_PRI_2	2	/*@Check hang function & Strong function*/
-#define	DBGPORT_PRI_1	1	/*Watch dog function*/
-#define	DBGPORT_RELEASE	0	/*@Init value (the lowest priority)*/
-
-/*@--------------------------[Enum]------------------------------------------*/
-enum bb_dbg_devider_len_t
-{
-	BB_DEVIDER_LEN_32 = 0,
-	BB_DEVIDER_LEN_16 = 1,
-};
-
-enum bb_dbg_port_ip_t
-{
-	DBGPORT_IP_TD		= 1,
-	DBGPORT_IP_RX_INNER	= 2,
-	DBGPORT_IP_TX_INNER	= 3,
-	DBGPORT_IP_OUTER	= 4,
-	DBGPORT_IP_INTF		= 5,
-	DBGPORT_IP_CCK		= 6,
-	DBGPORT_IP_BF		= 7,
-	DBGPORT_IP_RX_OUTER	= 8,
-	DBGPORT_IP_RFC0		= 0X1B,
-	DBGPORT_IP_RFC1		= 0X1C,
-	DBGPORT_IP_RFC2		= 0X1D,
-	DBGPORT_IP_RFC3		= 0X1E,
-	DBGPORT_IP_TST		= 0X1F,
-};
-
-enum bb_frc_phy_dump_reg
-{
-	FRC_DUMP_PHY0		= 0,
-	FRC_DUMP_PHY1		= 1,
-	FRC_DUMP_ALL
-};
-
-enum bb_basic_dbg_info
-{
-	BB_BASIC_DBG_01_SYSTEM		= BIT1,
-	BB_BASIC_DBG_02_ENVMNTR		= BIT2,
-	BB_BASIC_DBG_03_PMAC		= BIT3,
-	BB_BASIC_DBG_04_TX		= BIT4,
-	BB_BASIC_DBG_05_RX		= BIT5,
-	BB_BASIC_DBG_06_RSSI_RATE	= BIT6,
-	BB_BASIC_DBG_07_HIST		= BIT7,
-	BB_BASIC_DBG_08_RSSI_RATE_MU	= BIT8,
-	BB_BASIC_DBG_09_DM_SUMMARY	= BIT9
-};
-
-/*@--------------------------[Structure]-------------------------------------*/
-struct bb_dbg_cr_info {
-	u32 dbgport_ip;
-	u32 dbgport_ip_m;
-	u32 dbgport_idx;
-	u32 dbgport_idx_m;
-	u32 dbgport_val;
-	u32 dbgport_val_m;
-	u32 clk_en;
-	u32 clk_en_m;
-	u32 dbgport_en;
-	u32 dbgport_en_m;
-	u32 bb_monitor_sel1;
-	u32 bb_monitor_sel1_m;
-	u32 bb_monitor1;
-	u32 bb_monitor1_m;
-	u32 mac_phy_intf_sel_phy1;
-	u32 mac_phy_intf_sel_phy1_m;
-	u32 mac_phy_txinfo[4];
-	u32 mac_phy_txcomct[2];
-	u32 mac_phy_txusrct[4][2];
-	u32 mac_phy_txtimct;
-	u32 mac_phy_lsig;
-	u32 mac_phy_siga_0;
-	u32 mac_phy_siga_1;
-	u32 mac_phy_vht_sigb_0;
-	u32 path_0_txpw;
-	u32 path_0_txpw_m;
-	u32 path_1_txpw;
-	u32 path_1_txpw_m;
-};
-
-struct bb_tx_info {
-	/*From reg*/
-	u8 type;
-	u8 tx_path_en;
-	u8 path_map;
-	u8 txcmd_num;
-	u8 txsc;
-	u8 bw;
-	u16 tx_pw; /*tmac*/
-	u8 n_usr;
-	u8 max_mcs;
-	bool stbc;
-	u8 gi;
-	u8 ltf;
-	u8 u_id[4];
-	u8 n_sts[4];
-	bool fec[4];
-	u8 mcs[4];
-	bool dcm[4];
-	u8 precoding[4];
-	u16 n_sym;
-	u8 pkt_ext;
-	u8 pre_fec;
-	u32 l_sig;
-	u32 sig_a1;
-	u32 sig_a2;
-	u32 sig_b;
-	u32 txinfo[4];
-	u32 txcomct[2];
-	u32 txusrct[4][2];
-	u32 txtimct;
-	u16 txpw_path0; /*bb_path0*/
-	u16 txpw_path1; /*bb_path1*/
-	/*sw variable*/
-	u16 t_data;
-	u32 psdu_length;
-};
-
-struct bb_dbg_info {
-	bool	cr_recorder_en;
-	bool	cr_recorder_rf_en; /*HALRF write BB CR*/
-	/*CR init debug control*/
-	bool	cr_dbg_mode_en;
-	u32	cut_curr_dbg;
-	u32	rfe_type_curr_dbg;
-#ifdef HALBB_TDMA_CR_SUPPORT
-	struct halbb_timer_info tdma_cr_timer_i;
-	bool		tdma_cr_en;
-	u8		tdma_cr_state;
-	u32		tdma_cr_idx;
-	u32		tdma_cr_mask;
-	u32		tdma_cr_val_0;
-	u32		tdma_cr_val_1;
-	u32		tdma_cr_period_0;
-	u32		tdma_cr_period_1;
-#endif
-	struct bb_tx_info tx_info_i;
-	struct bb_dbg_cr_info bb_dbg_cr_i;
-};
-
-/*@--------------------------[Prptotype]-------------------------------------*/
-struct bb_info;
-void halbb_print_devider(struct bb_info *bb, u8 len, bool with_space, u64 comp);
-#ifdef HALBB_TDMA_CR_SUPPORT
-void halbb_tdma_cr_sel_io_en(struct bb_info *bb);
-void halbb_tdma_cr_timer_init(struct bb_info *bb);
-void halbb_tdma_cr_sel_main(struct bb_info *bb);
-void halbb_tdma_cr_sel_init(struct bb_info *bb);
-#endif
-
-void halbb_dbg_comp_init(struct bb_info *bb);
-void halbb_bb_dbg_port_clock_en(struct bb_info *bb, u8 enable);
-u32 halbb_get_bb_dbg_port_idx(struct bb_info *bb);
-void halbb_set_bb_dbg_port(struct bb_info *bb, u32 dbg_port);
-void halbb_set_bb_dbg_port_ip(struct bb_info *bb, enum bb_dbg_port_ip_t ip);
-void halbb_release_bb_dbg_port(struct bb_info *bb);
-bool halbb_bb_dbg_port_racing(struct bb_info *bb, u8 curr_dbg_priority);
-u32 halbb_get_bb_dbg_port_val(struct bb_info *bb);
-u16 halbb_rx_utility(struct bb_info *bb, u16 avg_phy_rate, u8 rx_max_ss,
-		     enum channel_width bw);
-u16 halbb_rx_avg_phy_rate(struct bb_info *bb);
-void halbb_get_tx_dbg_reg(struct bb_info *bb);
-void halbb_basic_dbg_message(struct bb_info *bb);
-void halbb_basic_profile_dbg(struct bb_info *bb, u32 *_used, char *output, u32 *_out_len);
-void halbb_get_bb_para_pkg_ver(struct bb_info *bb, u32 *date, u32 *release_ver);
-void halbb_dump_reg_dbg(struct bb_info *bb, char input[][16], u32 *_used, char *output, u32 *_out_len);
-void halbb_dd_dump_dbg(struct bb_info *bb, char input[][16], u32 *_used, char *output, u32 *_out_len);
-void halbb_cr_table_dump(struct bb_info *bb, u32 *cr_table, u32 cr_len);
-void halbb_dump_bb_reg(struct bb_info *bb, u32 *_used, char *output,
-		       u32 *_out_len, bool dump_2_buff,
-		       enum bb_frc_phy_dump_reg frc_phy_dump);
-void halbb_show_rx_rate(struct bb_info *bb, char input[][16], u32 *_used,
-			      char *output, u32 *_out_len);
-void halbb_tx_info_dbg(struct bb_info *bb, char input[][16], u32 *_used,
-		       char *output, u32 *_out_len);
-void halbb_cmn_dbg(struct bb_info *bb, char input[][16], u32 *_used, char *output, u32 *_out_len);
-void halbb_dbg_setting_init(struct bb_info *bb);
-void halbb_cr_cfg_dbg_init(struct bb_info *bb);
-#endif
diff --git a/os/board/rtl8720e/src/component/wifi/driver/src/hal/phy_g6/bb/halbb_dbg_cmd.h b/os/board/rtl8720e/src/component/wifi/driver/src/hal/phy_g6/bb/halbb_dbg_cmd.h
deleted file mode 100644
index fcdc3ca36..000000000
--- a/os/board/rtl8720e/src/component/wifi/driver/src/hal/phy_g6/bb/halbb_dbg_cmd.h
+++ /dev/null
@@ -1,82 +0,0 @@
-/******************************************************************************
- *
- * Copyright(c) 2019 Realtek Corporation.
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of version 2 of the GNU General Public License as
- * published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
- * more details.
- *
- *****************************************************************************/
-#ifndef _HALBB_DBG_CMD_H_
-#define _HALBB_DBG_CMD_H_
-/*@--------------------------[Define] ---------------------------------------*/
-#define	MAX_ARGC		20
-#define	MAX_ARGV		16
-
-#if 1
-#define HALBB_SCAN _os_sscanf
-#define DCMD_DECIMAL	"%d"
-#define DCMD_HEX	"%x"
-#define DCMD_HEX64	"%llx"
-#define DCMD_CHAR	"%s"
-#else
-#define HALBB_SCAN halbb_scanf
-enum bb_scanf_type
-{
-	DCMD_DECIMAL	= 1,
-	DCMD_HEX	= 2,
-	DCMD_CHAR	= 3,
-};
-#endif
-
-#define DCMD_SCAN_LIMIT 10
-
-/*@--------------------------[Enum]------------------------------------------*/
- 
-enum bb_scanf_type
-{
-	DCMD2_DECIMAL	= 1,
-	DCMD2_HEX	= 2,
-	DCMD2_CHAR	= 3,
-};
-
- enum FWBB_DBG_COMP_SET {
-	FWBBDBG_H2C = BIT0,
-	FWBBDBG_RA = BIT8,
-	FWBBDBG_RUA = BIT16,
-    FWBBDBG_ULPWR_CTRL = BIT24,
-    FWBBDBG_ULRA = BIT25,
-};
-
-/*@--------------------------[Structure]-------------------------------------*/
-
-struct bb_echo_cmd_info {
-	u8 cmd_size;
-	enum phl_phy_idx echo_phy_idx;
-};
-
-struct bb_fw_dbg_cmn_info {
-	u8 fw_dbg_comp[4];
-	u8 fw_dbg_trace;
-	u8 fw_cmn_info;
-	u8 fw_rty_rpt_ctrl;
-	u8 rsvd0;
-};
-
-/*@--------------------------[Prptotype]-------------------------------------*/
-struct bb_info;
-void halbb_dbgport_dump_all(struct bb_info *bb, u32 *_used, char *output,
-			    u32 *_out_len);
-
-void halbb_dbgport_dbg(struct bb_info *bb, char input[][16], u32 *_used,
-			 char *output, u32 *_out_len);
-void halbb_scanf(char *in, enum bb_scanf_type type, u32 *out);
-void halbb_cmd_parser_init(struct bb_info *bb);
-void halbb_fw_dbg(struct bb_info *bb, char input[][16], u32 *_used,
-			 char *output, u32 *_out_len);
-#endif
diff --git a/os/board/rtl8720e/src/component/wifi/driver/src/hal/phy_g6/bb/halbb_dbg_cmd_ex.h b/os/board/rtl8720e/src/component/wifi/driver/src/hal/phy_g6/bb/halbb_dbg_cmd_ex.h
deleted file mode 100644
index 117eee243..000000000
--- a/os/board/rtl8720e/src/component/wifi/driver/src/hal/phy_g6/bb/halbb_dbg_cmd_ex.h
+++ /dev/null
@@ -1,39 +0,0 @@
-/******************************************************************************
- *
- * Copyright(c) 2007 - 2020  Realtek Corporation.
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of version 2 of the GNU General Public License as
- * published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
- * more details.
- *
- * The full GNU General Public License is included in this distribution in the
- * file called LICENSE.
- *
- * Contact Information:
- * wlanfae <wlanfae@realtek.com>
- * Realtek Corporation, No. 2, Innovation Road II, Hsinchu Science Park,
- * Hsinchu 300, Taiwan.
- *
- * Larry Finger <Larry.Finger@lwfinger.net>
- *
- *****************************************************************************/
-
-#ifndef __HALBB_DBG_CMD_EX_H__
-#define __HALBB_DBG_CMD_EX_H__
-#define	MAX_ARGV		16
-
-struct bb_info;
-
-s32 halbb_cmd(struct bb_info *bb, char *input, char *output, u32 out_len);
-
-
-void halbb_cmd_parser(struct bb_info *bb, char input[][MAX_ARGV],
-					u32 input_num, char *output, u32 out_len);
-
-
-#endif
diff --git a/os/board/rtl8720e/src/component/wifi/driver/src/hal/phy_g6/bb/halbb_dbg_cmd_table.h b/os/board/rtl8720e/src/component/wifi/driver/src/hal/phy_g6/bb/halbb_dbg_cmd_table.h
deleted file mode 100644
index d5277321d..000000000
--- a/os/board/rtl8720e/src/component/wifi/driver/src/hal/phy_g6/bb/halbb_dbg_cmd_table.h
+++ /dev/null
@@ -1,149 +0,0 @@
-/******************************************************************************
- *
- * Copyright(c) 2019 Realtek Corporation.
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of version 2 of the GNU General Public License as
- * published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
- * more details.
- *
- *****************************************************************************/
-#ifndef _HALBB_DBG_CMD_TABLE_H_
-#define _HALBB_DBG_CMD_TABLE_H_
-/*@--------------------------[Define] ---------------------------------------*/
-
-
-/*@--------------------------[Enum]------------------------------------------*/
-enum HALBB_CMD_ID {
-	HALBB_HELP,
-	HALBB_DEMO,
-	HALBB_REG_RW,
-	HALBB_CMN_DBG,
-	HALBB_RA,
-	HALBB_PROFILE,
-	HALBB_TRACE,
-	HALBB_MP_DBG,
-	HALBB_SUPPORT_ABILITY,
-	HALBB_TX_PW,
-	HALBB_IC_API,
-	HALBB_SPUR_SUPP,
-	HALBB_LA_MODE,
-	HALBB_DUMP_REG,
-	HALBB_AUTO_DBG,
-	HALBB_DD_DBG,
-	HALBB_SHOW_RXRATE,
-	HALBB_NBI_EN,
-	HALBB_CSI_MASK_EN,
-	HALBB_DFS_DBG,
-	HALBB_DIG,
-	HALBB_NHM,
-	HALBB_CLM,
-	HALBB_IFS_CLM,
-	HALBB_FAHM,
-	HALBB_EDCCA_CLM,
-	HALBB_EDCCA,
-	HALBB_ENV_MNTR,
-	HALBB_BB_INFO,
-	HALBB_H2C,
-	HALBB_STASISTICS,
-	HALBB_PSD,
-	HALBB_DBG_PORT,
-	HALBB_CFO_TRK,
-	HALBB_UL_TB,
-	HALBB_ADAPTIVITY_DBG,
-	HALBB_STA_INFO,
-	HALBB_PAUSE_FUNC,
-	HALBB_PER_TONE_EVM,
-	HALBB_DYN_TXPWR,
-	HALBB_PHY_STATUS,
-	HALBB_DCC,
-	HALBB_PMAC_TX,
-	HALBB_FW_DBG,
-	HALBB_CH_INFO,
-	HALBB_RUA_TBL,
-	HALBB_TD_CFG,
-	HALBB_FD_CFG,
-	HALBB_DBCC,
-	HALBB_ANT_DIV,
-	HALBB_DCR_DBG,
-	HALBB_RX_GAIN_TABLE,
-	HALBB_RX_OP1DB_TABLE,
-	HALBB_HW_SETTING,
-	HALBB_PATH_DIV,
-	HALBB_DTP,
-	HALBB_TX_INFO,
-	HALBB_DYN_1R_CCA,
-	HALBB_CMN_INFO
-};
-
-/*@--------------------------[Structure]-------------------------------------*/
- 
-struct halbb_cmd_info {
-	char name[16];
-	u8 id;
-};
-
-static const struct halbb_cmd_info halbb_cmd_i[] = {
-	{"-h", HALBB_HELP}, /*@do not move this element to other position*/
-	{"demo", HALBB_DEMO}, /*@do not move this element to other position*/
-	{"cr", HALBB_REG_RW},
-	{"cmn", HALBB_CMN_DBG},
-	{"ra", HALBB_RA},
-	{"profile", HALBB_PROFILE},
-	{"dbg", HALBB_TRACE},
-	{"mp_dbg", HALBB_MP_DBG},
-	{"ability", HALBB_SUPPORT_ABILITY},
-	{"tx_pw", HALBB_TX_PW},
-	{"ic_api", HALBB_IC_API},
-	{"spur", HALBB_SPUR_SUPP},
-	{"lamode", HALBB_LA_MODE},
-	{"psd", HALBB_PSD},
-	{"dumpreg", HALBB_DUMP_REG},
-	//{"auto_dbg", HALBB_AUTO_DBG},
-	{"dd_dbg", HALBB_DD_DBG},
-	{"cfo_trk", HALBB_CFO_TRK},
-	{"ul_tb", HALBB_UL_TB},
-	{"rxrate", HALBB_SHOW_RXRATE},
-	//{"nbi", HALBB_NBI_EN},
-	//{"csi_mask", HALBB_CSI_MASK_EN},
-	{"dfs", HALBB_DFS_DBG},
-	{"dig", HALBB_DIG},
-	{"nhm", HALBB_NHM},
-	{"clm", HALBB_CLM},
-	{"ifs_clm", HALBB_IFS_CLM},
-	{"fahm", HALBB_FAHM},
-	{"edcca_clm", HALBB_EDCCA_CLM},
-	{"edcca", HALBB_EDCCA},	
-	{"env_mntr", HALBB_ENV_MNTR},
-	//{"bbinfo", HALBB_BB_INFO},
-	//{"h2c", HALBB_H2C},
-	{"stat", HALBB_STASISTICS},
-	{"dbgport", HALBB_DBG_PORT},
-	{"sta_info", HALBB_STA_INFO},
-	{"pause", HALBB_PAUSE_FUNC},
-	{"physts", HALBB_PHY_STATUS},
-	{"pmac_tx", HALBB_PMAC_TX},
-	{"fw_dbg", HALBB_FW_DBG},
-	{"ch_info", HALBB_CH_INFO},
-	{"td", HALBB_TD_CFG},
-	{"fd", HALBB_FD_CFG},
-	{"dbcc", HALBB_DBCC},
-	{"rua", HALBB_RUA_TBL},
-	{"ant_div", HALBB_ANT_DIV},
-	{"dcr", HALBB_DCR_DBG},
-	{"gain_table", HALBB_RX_GAIN_TABLE},
-	{"op1db_table", HALBB_RX_OP1DB_TABLE},
-	{"hw_set", HALBB_HW_SETTING},
-	{"path_div", HALBB_PATH_DIV},
-	{"txinfo", HALBB_TX_INFO},
-	{"dyn_1r_cca", HALBB_DYN_1R_CCA},
-	{"cmn_info", HALBB_CMN_INFO}
-	};
-
-/*@--------------------------[Prptotype]-------------------------------------*/
-
-#endif
diff --git a/os/board/rtl8720e/src/component/wifi/driver/src/hal/phy_g6/bb/halbb_dbg_cnsl_out.h b/os/board/rtl8720e/src/component/wifi/driver/src/hal/phy_g6/bb/halbb_dbg_cnsl_out.h
deleted file mode 100644
index 045b64513..000000000
--- a/os/board/rtl8720e/src/component/wifi/driver/src/hal/phy_g6/bb/halbb_dbg_cnsl_out.h
+++ /dev/null
@@ -1,37 +0,0 @@
-/******************************************************************************
- *
- * Copyright(c) 2007 - 2020  Realtek Corporation.
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of version 2 of the GNU General Public License as
- * published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
- * more details.
- *
- * The full GNU General Public License is included in this distribution in the
- * file called LICENSE.
- *
- * Contact Information:
- * wlanfae <wlanfae@realtek.com>
- * Realtek Corporation, No. 2, Innovation Road II, Hsinchu Science Park,
- * Hsinchu 300, Taiwan.
- *
- * Larry Finger <Larry.Finger@lwfinger.net>
- *
- *****************************************************************************/
-#ifndef __HALBB_DBG_CNSL_OUT_H__
-#define __HALBB_DBG_CNSL_OUT_H__
-
-#include "../../hal_headers_le.h"
-
-/*@--------------------------[Define] ---------------------------------------*/
-
-
-/*@--------------------------[Prptotype]-------------------------------------*/
-struct bb_info;
-void halbb_basic_dbg_message_cnsl_dbg(struct bb_info *bb, char input[][16], u32 *_used,
-				      char *output, u32 *_out_len);
-#endif
\ No newline at end of file
diff --git a/os/board/rtl8720e/src/component/wifi/driver/src/hal/phy_g6/bb/halbb_dfs.h b/os/board/rtl8720e/src/component/wifi/driver/src/hal/phy_g6/bb/halbb_dfs.h
deleted file mode 100644
index 7ab65b158..000000000
--- a/os/board/rtl8720e/src/component/wifi/driver/src/hal/phy_g6/bb/halbb_dfs.h
+++ /dev/null
@@ -1,308 +0,0 @@
-/******************************************************************************
- *
- * Copyright(c) 2007 - 2020  Realtek Corporation.
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of version 2 of the GNU General Public License as
- * published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
- * more details.
- *
- * The full GNU General Public License is included in this distribution in the
- * file called LICENSE.
- *
- * Contact Information:
- * wlanfae <wlanfae@realtek.com>
- * Realtek Corporation, No. 2, Innovation Road II, Hsinchu Science Park,
- * Hsinchu 300, Taiwan.
- *
- * Larry Finger <Larry.Finger@lwfinger.net>
- *
- *****************************************************************************/
-#ifndef __HALBB_DFS_H__
-#define __HALBB_DFS_H__
-/*@--------------------------[Define] ---------------------------------------*/
-#define DFS_RPT_LENGTH 4
-#define DFS_RDR_TYP_NUM 8
-#define DFS_L_RDR_IDX 6
-#define DFS_SPCL_RDR_IDX_ETSI 3
-#define PW_FTR_IDLE 1
-#define PRI_FTR_IDLE 1
-#define PW_FTR 3
-#define PRI_FTR 3
-#define DFS_PPB_PRCNT 4
-#define DFS_PPB_IDLE_PRCNT 5
-
-#define DFS_CHIRP_TH 3
-#define DFS_FCC_LP_LNGTH 12	/*Real Waveform length of FCC-LP is 12 secs*/
-#define DFS_MAX_SEQ_NUM 127
-
-#define DFS_ADPTV_CNT1 1
-#define DFS_ADPTV_CNT2 1
-#define DFS_ADPTV_CNT_TH 30
-
-#define DFS_Normal_State 0
-#define DFS_Adaptive_State 1
-/*@--------------------------[Enum]------------------------------------------*/
-/*@--------------------------[Structure]-------------------------------------*/
-struct bb_dfs_cr_info {
-	u32 dfs_en;
-	u32 dfs_en_m;
-	u32 tw_dfs_en;
-	u32 tw_dfs_en_m;
-};
-
-struct bb_dfs_info {
-	struct bb_dfs_cr_info	bb_dfs_cr_i;
-	
-//============= Used by TW DFS ==============//
-	bool is_tw_en;
-//===========================================//
-
-	u8 dfs_rgn_domain;
-	u8 ppb_prcnt;
-	u16 pw_rpt[DFS_MAX_SEQ_NUM];
-	u8 pri_rpt[DFS_MAX_SEQ_NUM];
-	bool chrp_rpt[DFS_MAX_SEQ_NUM];
-//============= Used by TW DFS ==============//
-	bool seg_rpt[DFS_MAX_SEQ_NUM];
-//===========================================//
-	//u8 chrp_cnt;
-	//u8 chrp_th;
-	u32 chrp_srt_t;
-	u8 n_cnfd_lvl;
-	u8 lng_rdr_cnt;
-	u8 chrp_rdr_cnt;
-
-//============= Used by TW DFS ==============//
-	u32 chrp_srt_t_sg1;
-	u8 n_cnfd_lvl_sg1;
-	u8 chrp_rdr_cnt_sg1;
-	u8 lng_rdr_cnt_sg1;
-	u8 lng_rdr_cnt_tmp_sg1;
-//===========================================//
-
-	u8 srt_rdr_cnt[DFS_RDR_TYP_NUM];
-	u8 pw_lbd[DFS_RDR_TYP_NUM];
-	u16 pw_ubd[DFS_RDR_TYP_NUM];
-	u8 pri_lbd[DFS_RDR_TYP_NUM];
-	u8 pri_ubd[DFS_RDR_TYP_NUM];
-	u8 pw_min_tab[DFS_RDR_TYP_NUM];
-	u16 pw_max_tab[DFS_RDR_TYP_NUM];
-	u8 pri_min_tab[DFS_RDR_TYP_NUM];
-	u8 pri_max_tab[DFS_RDR_TYP_NUM];
-	u8 ppb_tab[DFS_RDR_TYP_NUM];
-	u8 ppb_typ_th[DFS_RDR_TYP_NUM];
-	u8 lst_seq_num;
-	u8 pw_factor;
-	u8 pri_factor;
-//============= Used by TW DFS ==============//
-	u8 srt_rdr_cnt_sg1[DFS_RDR_TYP_NUM];
-	u8 lst_seq_num_sg1;
-	u8 rpt_sg_history;
-//===========================================//
-	bool is_mic_w53;
-	bool is_mic_w56;
-	bool l_rdr_exst_flag;
-	bool chrp_obsrv_flag;
-	bool n_cnfd_flag;
-	bool n_seq_flag;
-//============= Used by TW DFS ==============//
-	bool chrp_obsrv_flag_sg1;
-	bool n_seq_flag_sg1;
-//===========================================//
-	bool idle_flag;
-	bool first_dyn_set_flag;
-	bool dyn_reset_flag;
-
-	bool dfs_sw_trgr_mode;
-	bool dfs_dbg_mode;
-	bool dbg_dyn_prnt_en;
-	bool dbg_hwdet_prnt_en;
-	bool dbg_swdet_prnt_en;
-	bool dbg_trivil_prnt_en;
-	bool dbg_brk_prnt_en;
-	u8 fk_dfs_num_th;
-	u8 dfs_tp_th;
-	u8 dfs_idle_prd_th;
-
-	u8 dfs_fa_th;
-	u8 dfs_nhm_th;
-	u8 dfs_n_cnfd_lvl_th;
-
-	bool dfs_dyn_setting_en;
-
-	u8 adap_detect_cnt;
-	u8 adap_detect_cnt_init;
-	u8 adap_detect_cnt_add;
-	u8 adap_detect_cnt_all;
-	u8 adap_detect_cnt_th;
-	u8 detect_state;
-	bool adap_detect_brk_en;
-
-	bool dfs_dyn_aci_en;
-	u8 dfs_aci_adaptv_th0;
-	u8 dfs_aci_adaptv_th1;
-	u8 dfs_aci_idx;
-	s8 ACI2SIG_db;
-	bool dfs_aci_is_read;
-	u8 no_aci_rpt_cnt;
-	u8 no_aci_rpt_th;
-
-	bool In_CAC_Flag;
-
-	u16 pw_diff_th;
-	u16 pw_lng_chrp_diff_th;
-	u16 pri_diff_th;
-	u16 pw_max_th;
-	u16 invalid_lng_pulse_th;
-
-	u16 min_pw_shrt[DFS_RDR_TYP_NUM];
-	u16 min_pw_lng;
-	u16 min_pw_chrp;
-	u16 min_pri_shrt[DFS_RDR_TYP_NUM];
-
-	u16 max_pw_shrt[DFS_RDR_TYP_NUM];
-	u16 max_pw_lng;
-	u16 max_pw_chrp;
-	u16 max_pri_shrt[DFS_RDR_TYP_NUM];
-
-	u16 pw_diff_shrt[DFS_RDR_TYP_NUM];
-	u16 pri_diff_shrt[DFS_RDR_TYP_NUM];
-
-//============= Used by TW DFS ==============//
-	u16 min_pw_shrt_sg1[DFS_RDR_TYP_NUM];
-	u16 min_pw_lng_sg1;
-	u16 min_pw_chrp_sg1;
-	u16 min_pri_shrt_sg1[DFS_RDR_TYP_NUM];
-
-	u16 max_pw_shrt_sg1[DFS_RDR_TYP_NUM];
-	u16 max_pw_lng_sg1;
-	u16 max_pw_chrp_sg1;
-	u16 max_pri_shrt_sg1[DFS_RDR_TYP_NUM];
-
-	u16 pw_diff_shrt_sg1[DFS_RDR_TYP_NUM];
-	u16 pw_diff_lng_sg1;
-	u16 pri_diff_shrt_sg1[DFS_RDR_TYP_NUM];
-//===========================================//
-
-};
-
-struct bb_dfs_rpt {
-	u8 *dfs_ptr;
-	u16 dfs_num;
-	u8 phy_idx; /*phy0,phy1*/
-};
-
-
-#ifdef HALBB_TW_DFS_SERIES
-
-#if (PLATFOM_IS_LITTLE_ENDIAN)
-struct bb_rdr_info {
-	u8 rdr_info_sg1_chirp_flag : 1; /*[18:9],[8:1],[0]*/
-	u8 rdr_info_sg1_pri_l : 7;
-
-	u8 rdr_info_sg1_pri_m : 1;
-	u8 rdr_info_sg1_pw_l : 7;
-
-	u8 rdr_info_sg1_pw_m : 3;
-	u8 rdr_info_sg0_chirp_flag : 1; /*[37:28],[27:20],[19]*/
-	u8 rdr_info_sg0_pri_l : 4;
-
-	u8 rdr_info_sg0_pri_m : 4;
-	u8 rdr_info_sg0_pw_l : 4;
-
-	u8 rdr_info_sg0_pw_m : 6;
-	u8 rdr_info_rsvd_l : 2;			/*[48:38]*/
-
-	u8 rdr_info_rsvd_m;
-
-	u8 rdr_info_rsvd_h : 1;
-	u8 rdr_info_sg1_seq : 7;		/*[55:49]*/
-
-	u8 rdr_info_sg0_seq : 7;		/*[62:56]*/
-	u8 rdr_info_path_opt : 1;		/*[63]*/
-
-};
-#else
-struct bb_rdr_info {
-	u8 rdr_info_sg1_pri_l : 7;
-	u8 rdr_info_sg1_chirp_flag : 1;
-
-	u8 rdr_info_sg1_pw_l : 7;
-	u8 rdr_info_sg1_pri_m : 1;
-
-	u8 rdr_info_sg0_pri_l : 4;
-	u8 rdr_info_sg0_chirp_flag : 1;
-	u8 rdr_info_sg1_pw_m : 3;
-
-	u8 rdr_info_sg0_pw_l : 4;
-	u8 rdr_info_sg0_pri_m : 4;
-
-	u8 rdr_info_rsvd_l : 2;
-	u8 rdr_info_sg0_pw_m : 6;
-
-	u8 rdr_info_rsvd_m;
-
-	u8 rdr_info_sg1_seq : 7;
-	u8 rdr_info_rsvd_h : 1;
-
-	u8 rdr_info_path_opt : 1;
-	u8 rdr_info_sg0_seq : 7;
-};
-#endif
-
-#else
-#if (PLATFOM_IS_LITTLE_ENDIAN)
-struct bb_rdr_info {
-	u8 rdr_info_sg0_chirp_flag:1;	/*[18:9],[8:1],[0]*/
-	u8 rdr_info_sg0_pri_l:7;
-
-	u8 rdr_info_sg0_pri_m:1;
-	u8 rdr_info_sg0_pw_l:7;
-
-	u8 rdr_info_sg0_pw_m:3;
-	u8 rdr_info_seq_l:5;	/*[37:28],[27:20],[19]*/
-
-	u8 rdr_info_seq_h:2;
-	u8 rdr_info_rsvd:6;
-};
-#else
-struct bb_rdr_info {
-	u8 rdr_info_sg0_pri_l:7;
-	u8 rdr_info_sg0_chirp_flag:1;
-
-	u8 rdr_info_sg0_pw_l:7;
-	u8 rdr_info_sg0_pri_m:1;
-
-	u8 rdr_info_seq_l:5;
-	u8 rdr_info_sg0_pw_m:3;
-
-	u8 rdr_info_rsvd:6;
-	u8 rdr_info_seq_h:2;
-};
-#endif
-#endif
-/*@--------------------------[Prptotype]-------------------------------------*/
-struct bb_info;
-struct hal_dfs_rpt;
-void halbb_dfs(struct bb_info *bb);
-void halbb_dfs_rgn_dmn_dflt_cnfg(struct bb_info *bb);
-void halbb_dfs_rgn_dmn_cnfg_by_ch(struct bb_info *bb, bool w53_band,
-				  bool w56_band);
-void halbb_radar_chrp_mntr(struct bb_info *bb, bool chrp_flag, bool is_sg1);
-void halbb_radar_seq_inspctn(struct bb_info *bb, u16 dfs_rpt_idx,
-			     u8 c_num, u8 p_num, bool is_sg1);
-void halbb_radar_ptrn_cmprn(struct bb_info *bb, u16 dfs_rpt_idx,
-			    u8 pri, u16 pw, bool chrp_flag, bool is_sg1);
-void halbb_radar_info_processing(struct bb_info *bb,
-				 struct hal_dfs_rpt *dfs_rpt, u16 dfs_rpt_idx);
-void halbb_parsing_aci2sig(struct bb_info* bb, u32 physts_bitmap);
-void halbb_dfs_dyn_setting(struct bb_info *bb);
-void halbb_dfs_debug(struct bb_info *bb, char input[][16], u32 *_used,
-		     char *output, u32 *_out_len);
-void halbb_cr_cfg_dfs_init(struct bb_info *bb);
-#endif
diff --git a/os/board/rtl8720e/src/component/wifi/driver/src/hal/phy_g6/bb/halbb_dfs_ex.h b/os/board/rtl8720e/src/component/wifi/driver/src/hal/phy_g6/bb/halbb_dfs_ex.h
deleted file mode 100644
index 9ce0c741f..000000000
--- a/os/board/rtl8720e/src/component/wifi/driver/src/hal/phy_g6/bb/halbb_dfs_ex.h
+++ /dev/null
@@ -1,42 +0,0 @@
-/******************************************************************************
- *
- * Copyright(c) 2007 - 2020  Realtek Corporation.
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of version 2 of the GNU General Public License as
- * published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
- * more details.
- *
- * The full GNU General Public License is included in this distribution in the
- * file called LICENSE.
- *
- * Contact Information:
- * wlanfae <wlanfae@realtek.com>
- * Realtek Corporation, No. 2, Innovation Road II, Hsinchu Science Park,
- * Hsinchu 300, Taiwan.
- *
- * Larry Finger <Larry.Finger@lwfinger.net>
- *
- *****************************************************************************/
-#ifndef __HALBB_DFS_EX_H__
-#define __HALBB_DFS_EX_H__
-/*@--------------------------[Define] ---------------------------------------*/
-/*@--------------------------[Enum]------------------------------------------*/
-/*@--------------------------[Structure]-------------------------------------*/
-struct bb_info;
-struct hal_dfs_rpt;
-/*@--------------------------[Prptotype]-------------------------------------*/
-void halbb_dfs_init(struct bb_info *bb);
-void halbb_radar_detect_reset(struct bb_info *bb);
-void halbb_radar_detect_disable(struct bb_info *bb);
-void halbb_radar_detect_enable(struct bb_info *bb);
-void halbb_dfs_enable_cac_flag(struct bb_info* bb);
-void halbb_dfs_disable_cac_flag(struct bb_info* bb);
-void halbb_dfs_change_dmn(struct bb_info *bb, u8 ch, u8 bw);
-bool halbb_is_dfs_band(struct bb_info *bb, u8 ch, u8 pri_ch);
-bool halbb_radar_detect(struct bb_info *bb, struct hal_dfs_rpt *rpt);
-#endif
\ No newline at end of file
diff --git a/os/board/rtl8720e/src/component/wifi/driver/src/hal/phy_g6/bb/halbb_dig.h b/os/board/rtl8720e/src/component/wifi/driver/src/hal/phy_g6/bb/halbb_dig.h
deleted file mode 100644
index 7c7d6ab46..000000000
--- a/os/board/rtl8720e/src/component/wifi/driver/src/hal/phy_g6/bb/halbb_dig.h
+++ /dev/null
@@ -1,365 +0,0 @@
-/******************************************************************************
- *
- * Copyright(c) 2007 - 2020  Realtek Corporation.
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of version 2 of the GNU General Public License as
- * published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
- * more details.
- *
- * The full GNU General Public License is included in this distribution in the
- * file called LICENSE.
- *
- * Contact Information:
- * wlanfae <wlanfae@realtek.com>
- * Realtek Corporation, No. 2, Innovation Road II, Hsinchu Science Park,
- * Hsinchu 300, Taiwan.
- *
- * Larry Finger <Larry.Finger@lwfinger.net>
- *
- *****************************************************************************/
-#ifndef __HALBB_DIG_H__
-#define __HALBB_DIG_H__
-
-#define DIG_VERSION "5.0"
-//#define DIG_DBCC_DEV_TMP
-/*@--------------------------[Define] ---------------------------------------*/
-#define BB_LNA_SIZE	7
-#define BB_TIA_SIZE	2
-
-#define IGI_RSSI_TH_NUM 5
-#define FA_TH_NUM 4
-#define RSSI_MAX 110
-#define RSSI_MIN 0
-#ifdef DIG_DBCC_DEV_TMP
-#define IGI_NOLINK (38 + 20)
-#else
-#define IGI_NOLINK 38
-#endif
-#define LNA_IDX_MAX 6
-#define LNA_IDX_MIN 0
-#define TIA_IDX_MAX 1
-#define TIA_IDX_MIN 0
-#define RXB_IDX_MAX 31
-#define RXB_IDX_MIN 0
-#define LNA6_GAIN 24
-#define LNA5_GAIN 16
-#define LNA4_GAIN 8
-#define LNA3_GAIN 0
-#define LNA2_GAIN (-8)
-#define LNA1_GAIN (-16)
-#define LNA0_GAIN (-24)
-#define TIA1_GAIN_A 20
-#define TIA0_GAIN_A 12
-#define TIA1_GAIN_G 24
-#define TIA0_GAIN_G 16
-#define IGI_OFFSET_MAX 25 /* IGI window size */
-#define	IGI_MAX_PERFORMANCE_MODE 0x5a
-#define	IGI_MAX_BALANCE_MODE 0x3e
-#define PD_TH_MAX_RSSI 70 /*  -40dBm */
-#define PD_TH_MIN_RSSI 8  /* -102dBm */
-#define PD_TH_BW80_CMP_VAL 6
-#define PD_TH_BW40_CMP_VAL 3
-#define PD_TH_BW20_CMP_VAL 0
-#define PD_TH_SB_FLTR_CMP_VAL 7
-#define DIG_CCX_WD_TRIGTIME 1900
-#define IGI_EDCCA_GAP_LIMIT 35
-#if defined(HALBB_DIG_TDMA_SUPPORT) || defined(HALBB_SIMPLE_TDMA_DIG_SUPPORT)
-#define IGI_MAX_AT_STATE_L	0x26
-#define WACHDOG_PERIOD_IN_MS	2000
-#define H_STATE_NUM_MAX		20
-#define L_STATE_NUM_MAX		10
-#endif
-#define DIG_RECORD_NUM		6
-#define DIG_LIMIT_PERIOD	60 /*60 sec*/
-
-#ifdef HALBB_DBG_TRACE_SUPPORT
-#define BB_DIG_DBG(bb, lv, fmt, ...)\
-	do {\
-		if(bb->dbg_component & DBG_DIG && bb->bb_dig_i.dbg_lv >= lv) {\
-			_os_dbgdump("[BB][%d]" fmt, bb->bb_phy_idx, ##__VA_ARGS__);\
-		}\
-	} while (0)
-#else
-#define BB_DIG_DBG(bb, lv, fmt, ...)
-#endif
-
-/*@--------------------------[Enum]------------------------------------------*/
-enum dig_noisy_level {
-	DIG_NOISY_LV0		= 0,	/*FA free*/
-	DIG_NOISY_LV1		= 1,
-	DIG_NOISY_LV2		= 2,
-	DIG_NOISY_LV3		= 3,
-	DIG_NOISY_LV_MAX	= 4
-};
-
-#if defined(HALBB_DIG_TDMA_SUPPORT) || defined(HALBB_SIMPLE_TDMA_DIG_SUPPORT)
-enum dig_tdma_state {
-	DIG_TDMA_LOW	= 0,
-	DIG_TDMA_HIGH	= 1
-};
-#endif
-
-enum dig_dbg_level {
-	DIG_DBG_LV0	= 0,
-	DIG_DBG_LV1	= 1,
-	DIG_DBG_LV2	= 2
-};
-/*@--------------------------[Structure]-------------------------------------*/
-struct bb_dig_cr_info {
-	u32 path0_ib_pbk;
-	u32 path0_ib_pbk_m;
-	u32 path0_ib_pkpwr;
-	u32 path0_ib_pkpwr_m;
-	u32 path1_ib_pbk;
-	u32 path1_ib_pbk_m;
-	u32 path1_ib_pkpwr;
-	u32 path1_ib_pkpwr_m;
-	u32 path0_lna_init_idx;
-	u32 path0_lna_init_idx_m;
-	u32 path1_lna_init_idx;
-	u32 path1_lna_init_idx_m;
-	u32 path0_tia_init_idx;
-	u32 path0_tia_init_idx_m;
-	u32 path1_tia_init_idx;
-	u32 path1_tia_init_idx_m;
-	u32 path0_rxb_init_idx;
-	u32 path0_rxb_init_idx_m;
-	u32 path1_rxb_init_idx;
-	u32 path1_rxb_init_idx_m;
-	u32 seg0r_pd_spatial_reuse_en_a;
-	u32 seg0r_pd_spatial_reuse_en_a_m;
-	u32 seg0r_pd_lower_bound_a;
-	u32 seg0r_pd_lower_bound_a_m;
-	u32 path0_p20_follow_by_pagcugc_en_a;
-	u32 path0_s20_follow_by_pagcugc_en_a;
-	u32 path1_p20_follow_by_pagcugc_en_a;
-	u32 path1_s20_follow_by_pagcugc_en_a;
-	u32 path0_p20_follow_by_pagcugc_en_a_m;
-	u32 path0_s20_follow_by_pagcugc_en_a_m;
-	u32 path1_p20_follow_by_pagcugc_en_a_m;
-	u32 path1_s20_follow_by_pagcugc_en_a_m;
-	u32 path0_lna_err_g0_a;
-	u32 path0_lna_err_g0_a_m;
-	u32 path0_lna_err_g0_g;
-	u32 path0_lna_err_g0_g_m;
-	u32 path0_lna_err_g1_a;
-	u32 path0_lna_err_g1_a_m;
-	u32 path0_lna_err_g1_g;
-	u32 path0_lna_err_g1_g_m;
-	u32 path0_lna_err_g2_a;
-	u32 path0_lna_err_g2_a_m;
-	u32 path0_lna_err_g2_g;
-	u32 path0_lna_err_g2_g_m;
-	u32 path0_lna_err_g3_a;
-	u32 path0_lna_err_g3_a_m;
-	u32 path0_lna_err_g3_g;
-	u32 path0_lna_err_g3_g_m;
-	u32 path0_lna_err_g4_a;
-	u32 path0_lna_err_g4_a_m;
-	u32 path0_lna_err_g4_g;
-	u32 path0_lna_err_g4_g_m;
-	u32 path0_lna_err_g5_a;
-	u32 path0_lna_err_g5_a_m;
-	u32 path0_lna_err_g5_g;
-	u32 path0_lna_err_g5_g_m;
-	u32 path0_lna_err_g6_a;
-	u32 path0_lna_err_g6_a_m;
-	u32 path0_lna_err_g6_g;
-	u32 path0_lna_err_g6_g_m;
-	u32 path0_tia_err_g0_a;
-	u32 path0_tia_err_g0_a_m;
-	u32 path0_tia_err_g0_g;
-	u32 path0_tia_err_g0_g_m;
-	u32 path0_tia_err_g1_a;
-	u32 path0_tia_err_g1_a_m;
-	u32 path0_tia_err_g1_g;
-	u32 path0_tia_err_g1_g_m;
-	u32 path1_lna_err_g0_a;
-	u32 path1_lna_err_g0_a_m;
-	u32 path1_lna_err_g0_g;
-	u32 path1_lna_err_g0_g_m;
-	u32 path1_lna_err_g1_a;
-	u32 path1_lna_err_g1_a_m;
-	u32 path1_lna_err_g1_g;
-	u32 path1_lna_err_g1_g_m;
-	u32 path1_lna_err_g2_a;
-	u32 path1_lna_err_g2_a_m;
-	u32 path1_lna_err_g2_g;
-	u32 path1_lna_err_g2_g_m;
-	u32 path1_lna_err_g3_a;
-	u32 path1_lna_err_g3_a_m;
-	u32 path1_lna_err_g3_g;
-	u32 path1_lna_err_g3_g_m;
-	u32 path1_lna_err_g4_a;
-	u32 path1_lna_err_g4_a_m;
-	u32 path1_lna_err_g4_g;
-	u32 path1_lna_err_g4_g_m;
-	u32 path1_lna_err_g5_a;
-	u32 path1_lna_err_g5_a_m;
-	u32 path1_lna_err_g5_g;
-	u32 path1_lna_err_g5_g_m;
-	u32 path1_lna_err_g6_a;
-	u32 path1_lna_err_g6_a_m;
-	u32 path1_lna_err_g6_g;
-	u32 path1_lna_err_g6_g_m;
-	u32 path1_tia_err_g0_a;
-	u32 path1_tia_err_g0_a_m;
-	u32 path1_tia_err_g0_g;
-	u32 path1_tia_err_g0_g_m;
-	u32 path1_tia_err_g1_a;
-	u32 path1_tia_err_g1_a_m;
-	u32 path1_tia_err_g1_g;
-	u32 path1_tia_err_g1_g_m;
-	u32 cca_rssi_lmt_en_a;
-	u32 cca_rssi_lmt_en_a_m;
-	u32 rssi_nocca_low_th_a;
-	u32 rssi_nocca_low_th_a_m;
-	u32 path0_dig_mode_en_a;
-	u32 path0_dig_mode_en_a_m;
-	u32 path0_igi_for_dig_a;
-	u32 path0_igi_for_dig_a_m;
-	u32 path0_backoff_wb_gain_a;
-	u32 path0_backoff_wb_gain_a_m;
-	u32 path1_dig_mode_en_a;
-	u32 path1_dig_mode_en_a_m;
-	u32 path1_igi_for_dig_a;
-	u32 path1_igi_for_dig_a_m;
-	u32 path1_backoff_wb_gain_a;
-	u32 path1_backoff_wb_gain_a_m;
-};
-
-struct agc_gaincode_set {
-	u8 lna_idx;
-	u8 tia_idx;
-	u8 rxb_idx;
-};
-
-struct bb_dig_fa_info {
-	u16 fa_r_cck_onesec;
-	u16 fa_r_ofdm_onesec;
-	u16 fa_r_onesec;	/* overall fa_ratio */
-};
-
-struct bb_dig_op_para_unit {
-	bool			dyn_pd_th_en;
-	u8			igi_rssi_th[IGI_RSSI_TH_NUM];
-	u16			fa_th[FA_TH_NUM];	/* permil */
-};
-
-#ifdef HALBB_DIG_DAMPING_CHK
-struct bb_dig_record_info {
-	u8		igi_bitmap; /*@Don't add any new parameter before this*/
-	u8		igi_history[DIG_RECORD_NUM];
-	u32		fa_history[DIG_RECORD_NUM];
-	bool		damping_lock_en;
-	u8		damping_limit_val; /*@Limit IGI_dyn_min*/
-	u32		limit_time;
-	u8		limit_rssi; /*s(8,1)*/
-};
-#endif
-
-/* struct for state unit, i.e., L/H */
-struct bb_dig_op_unit {
-#if defined(HALBB_DIG_TDMA_SUPPORT) || defined(HALBB_SIMPLE_TDMA_DIG_SUPPORT)
-	enum dig_tdma_state	state_identifier; /* L/H */
-#endif
-	struct agc_gaincode_set cur_gaincode;
-	enum dig_noisy_level	cur_noisy_lv;
-	struct agc_gaincode_set force_gaincode;
-	struct bb_dig_op_para_unit dig_op_para;
-	u16			fa_r_acc;	/* acced one shot fa_ratio */
-	u16			fa_r_avg;	/* acced one shot fa_ratio */
-	u8			fa_valid_state_cnt;
-	u8			state_num_lmt;
-	u8			passed_state_cnt;
-	u8			igi_fa_rssi; /*final IGI calaulated by FA & RSSI*/
-	u8			fa_rssi_ofst;
-	u8			abs_igi_max;
-	u8			abs_igi_min;
-	u8			dyn_igi_max;
-	u8			dyn_igi_min;
-	u8			pd_low_th_ofst;	/* pd low safe cca region */
-	bool			sdagc_follow_pagc_en;
-};
-
-struct bb_dig_info {
-	enum dig_op_mode 	dig_mode;
-	enum dig_op_mode 	pre_dig_mode;
-	struct bb_dig_cr_info	bb_dig_cr_i;
-	struct agc_gaincode_set max_gaincode;
-	u8			igi_rssi; //rssi_min
-	u8			ib_pbk;
-	s8			ib_pkpwr;
-	s8			lna_gain_a[BB_LNA_SIZE];
-	s8			lna_gain_g[BB_LNA_SIZE];
-	s8			*lna_gain;
-	s8			tia_gain_a[BB_TIA_SIZE];
-	s8			tia_gain_g[BB_TIA_SIZE];
-	s8			*tia_gain;
-	s8			le_igi_ofst; /* low end mode IGI offset */
-	struct bb_dig_op_unit	*p_cur_dig_unit;
-	struct bb_dig_op_unit 	dig_state_h_i; /* high state */
-#if defined(HALBB_DIG_TDMA_SUPPORT) || defined(HALBB_SIMPLE_TDMA_DIG_SUPPORT)
-	struct bb_dig_op_unit	dig_state_l_i; /* low state */
-	bool			gaincode_update_en;
-	u16			tdma_passed_time_acc; /* check if 1sec reach */
-	u8			tdma_timestamp_pre;
-	u8			tdma_timestamp_cur;
-	struct halbb_timer_info dig_timer_i;
-#endif
-
-#ifdef HALBB_ENV_MNTR_SUPPORT
-	u8 			fahm_timestamp;
-	struct fahm_para_info 	fahm_para_i;
-	bool			fahm_is_triggered;
-#endif
-	struct bb_dig_fa_info 	dig_fa_i;
-	enum dig_dbg_level	dbg_lv;
-	u32 rvrt_val[DIG_PAUSE_INFO_SIZE];	/*[Pause fucntion] must set to u32*/
-	u16 igi_pause_cnt; /*consective pause counter*/
-	bool			need_update;
-	u16			dig_hold_cnt;
-#ifdef HALBB_DIG_DAMPING_CHK
-	struct bb_dig_record_info bb_dig_record_i;
-	u8			rls_rssi_diff_th; /*s(8,1)*/
-	bool dig_dl_en; /*@damping limit function enable*/
-#endif
-};
-
-struct bb_info;
-/*@--------------------------[Prptotype]-------------------------------------*/
-#ifdef HALBB_DIG_TDMA_SUPPORT
-void halbb_dig_timercheck_watchdog(struct bb_info*);
-void halbb_tdmadig_io_en(struct bb_info *bb);
-void halbb_dig_timer_init(struct bb_info *bb);
-#endif
-#ifdef HALBB_SIMPLE_TDMA_DIG_SUPPORT
-void halbb_s_dig_op_unit_para_reset_l(struct bb_info *bb);
-void halbb_simple_tdma_dig_watchdog(struct bb_info *bb);
-void halbb_simple_tdma_timer_init(struct bb_info *bb);
-#endif
-void halbb_dig_lps(struct bb_info *bb);
-void halbb_dig_cfg_bbcr(struct bb_info *bb, u8 igi_new);
-u8 halbb_dig_igi_by_ofst(struct bb_info *bb, u8 igi_pre, s8 ofst);
-void halbb_dig(struct bb_info *bb);
-void halbb_dig_init(struct bb_info *bb);
-void halbb_dig_dbg(struct bb_info *bb, char input[][16], u32 *_used,
-		   char *output, u32 *_out_len);
-void halbb_cr_cfg_dig_init(struct bb_info *bb);
-
-void* halbb_get_dig_fa_statistic(struct bb_info *bb);
-void halbb_set_dig_pause_val(struct bb_info *bb, u32 *val_buf, u8 val_len);
-#ifdef HALBB_DIG_MCC_SUPPORT
-void Halbb_init_mccdm(struct bb_info *bb);
-void halbb_mccdm_switch(struct bb_info *bb);
-u32 halbb_c2h_mccdm_check(struct bb_info *bb, u16 len, u8 *c2h);
-#endif
-u8 halbb_get_lna_idx(struct bb_info *bb, enum rf_path path);
-u8 halbb_get_tia_idx(struct bb_info *bb, enum rf_path path);
-u8 halbb_get_rxb_idx(struct bb_info *bb, enum rf_path path);
-#endif
diff --git a/os/board/rtl8720e/src/component/wifi/driver/src/hal/phy_g6/bb/halbb_dig_ex.h b/os/board/rtl8720e/src/component/wifi/driver/src/hal/phy_g6/bb/halbb_dig_ex.h
deleted file mode 100644
index 23bf685e0..000000000
--- a/os/board/rtl8720e/src/component/wifi/driver/src/hal/phy_g6/bb/halbb_dig_ex.h
+++ /dev/null
@@ -1,50 +0,0 @@
-/******************************************************************************
- *
- * Copyright(c) 2007 - 2020  Realtek Corporation.
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of version 2 of the GNU General Public License as
- * published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
- * more details.
- *
- * The full GNU General Public License is included in this distribution in the
- * file called LICENSE.
- *
- * Contact Information:
- * wlanfae <wlanfae@realtek.com>
- * Realtek Corporation, No. 2, Innovation Road II, Hsinchu Science Park,
- * Hsinchu 300, Taiwan.
- *
- * Larry Finger <Larry.Finger@lwfinger.net>
- *
- *****************************************************************************/
-#ifndef __HALBB_DIG_EX_H__
-#define __HALBB_DIG_EX_H__
-
-/*@--------------------------[Define] ---------------------------------------*/
-#define DIG_PAUSE_INFO_SIZE	2
-/*@--------------------------[Enum]------------------------------------------*/
-enum dig_op_mode {
-	DIG_ORIGIN	= 0,
-#ifdef HALBB_DIG_TDMA_SUPPORT
-	DIG_TDMA	= 1,
-	DIG_TDMA_ADV	= 2,
-#endif
-	DIG_SIMPLE	= 3,
-	DIG_NONE
-};
-
-enum dig_pause_case {
-	PAUSE_OFDM = 0,
-	PAUSE_OFDM_CCK = 1
-};
-/*@--------------------------[Structure]-------------------------------------*/
-struct bb_info;
-
-/*@--------------------------[Prptotype]-------------------------------------*/
-void halbb_dig_mode_update(struct bb_info *bb, enum dig_op_mode mode, enum phl_phy_idx phy_idx);
-#endif
diff --git a/os/board/rtl8720e/src/component/wifi/driver/src/hal/phy_g6/bb/halbb_dyn_1r_cca.h b/os/board/rtl8720e/src/component/wifi/driver/src/hal/phy_g6/bb/halbb_dyn_1r_cca.h
deleted file mode 100644
index 1afaa3bc4..000000000
--- a/os/board/rtl8720e/src/component/wifi/driver/src/hal/phy_g6/bb/halbb_dyn_1r_cca.h
+++ /dev/null
@@ -1,46 +0,0 @@
-/******************************************************************************
- *
- * Copyright(c) 2007 - 2017  Realtek Corporation.
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of version 2 of the GNU General Public License as
- * published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
- * more details.
- *
- * The full GNU General Public License is included in this distribution in the
- * file called LICENSE.
- *
- * Contact Information:
- * wlanfae <wlanfae@realtek.com>
- * Realtek Corporation, No. 2, Innovation Road II, Hsinchu Science Park,
- * Hsinchu 300, Taiwan.
- *
- * Larry Finger <Larry.Finger@lwfinger.net>
- *
- *****************************************************************************/
-#ifndef __HALBB_DYN_1R_CCA_H__
-#define __HALBB_DYN_1R_CCA_H__
-#ifdef HALBB_DYN_1R_CCA_SUPPORT
-
-struct bb_dyn_1r_cca_info {
-	bool			dyn_1r_cca_en;
-	enum rf_path		dyn_1r_cca_cfg;
-	u16			dyn_1r_cca_rssi_diff_th; /*RSSI  u(16,5)*/
-	u16			dyn_1r_cca_rssi_min_th; /*RSSI  u(16,5)*/
-};
-
-
-void halbb_dyn_1r_cca_rst(struct bb_info *bb);
-void halbb_dyn_1r_cca_dbg(struct bb_info *bb, char input[][16], 
-			  u32 *_used, char *output, u32 *_out_len);
-void halbb_dyn_1r_cca(struct bb_info *bb);
-void halbb_dyn_1r_cca_init(struct bb_info *bb);
-
-
-
-#endif
-#endif
diff --git a/os/board/rtl8720e/src/component/wifi/driver/src/hal/phy_g6/bb/halbb_dyn_1r_cca_ex.h b/os/board/rtl8720e/src/component/wifi/driver/src/hal/phy_g6/bb/halbb_dyn_1r_cca_ex.h
deleted file mode 100644
index e9a6006c6..000000000
--- a/os/board/rtl8720e/src/component/wifi/driver/src/hal/phy_g6/bb/halbb_dyn_1r_cca_ex.h
+++ /dev/null
@@ -1,37 +0,0 @@
-/******************************************************************************
- *
- * Copyright(c) 2007 - 2020  Realtek Corporation.
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of version 2 of the GNU General Public License as
- * published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
- * more details.
- *
- * The full GNU General Public License is included in this distribution in the
- * file called LICENSE.
- *
- * Contact Information:
- * wlanfae <wlanfae@realtek.com>
- * Realtek Corporation, No. 2, Innovation Road II, Hsinchu Science Park,
- * Hsinchu 300, Taiwan.
- *
- * Larry Finger <Larry.Finger@lwfinger.net>
- *
- *****************************************************************************/
-#ifndef __HALBB_DYN_1R_CCA_H__EX_H__
-#define __HALBB_DYN_1R_CCA_H__EX_H__
-
-/*@--------------------------[Define] ---------------------------------------*/
-
-/*@--------------------------[Enum]------------------------------------------*/
-
-/*@--------------------------[Structure]-------------------------------------*/
-
-/*@--------------------------[Prptotype]-------------------------------------*/
-
-#endif
-
diff --git a/os/board/rtl8720e/src/component/wifi/driver/src/hal/phy_g6/bb/halbb_dyn_csi_rsp.h b/os/board/rtl8720e/src/component/wifi/driver/src/hal/phy_g6/bb/halbb_dyn_csi_rsp.h
deleted file mode 100644
index 5fb9caff1..000000000
--- a/os/board/rtl8720e/src/component/wifi/driver/src/hal/phy_g6/bb/halbb_dyn_csi_rsp.h
+++ /dev/null
@@ -1,57 +0,0 @@
-/******************************************************************************
- *
- * Copyright(c) 2007 - 2017  Realtek Corporation.
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of version 2 of the GNU General Public License as
- * published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
- * more details.
- *
- * The full GNU General Public License is included in this distribution in the
- * file called LICENSE.
- *
- * Contact Information:
- * wlanfae <wlanfae@realtek.com>
- * Realtek Corporation, No. 2, Innovation Road II, Hsinchu Science Park,
- * Hsinchu 300, Taiwan.
- *
- * Larry Finger <Larry.Finger@lwfinger.net>
- *
- *****************************************************************************/
-#ifndef __HALBB_DYN_CSI_RSP_H__
-#define __HALBB_DYN_CSI_RSP_H__
-#ifdef HALBB_DYN_CSI_RSP_SUPPORT
-
-struct bf_ch_raw_info {
-	/*result*/
-	bool 				is_csi_rsp_en;
-	/*state machine*/
-	u8				dyn_csi_rsp_dbg_en;
-	u8				dyn_csi_rsp_en;
-	u8				ch_chk_cnt;
-	/*set val*/
-	u32				ch_est_dly;
-	u32				get_phy_sts_dly;
-	u32				max_est_tone_num;
-	s32				cablelink_cnt_th;
-	enum channel_width		dcr_bw;
-};
-
-struct bb_info;
-
-/*@--------------------------[Enum]------------------------------------------*/
-enum dcr_csi_rsp {
-	dcr_csi_rsp_dis	= 0,	/*Disale*/
-	dcr_csi_rsp_en	= 1,	/*Enable*/
-};
-void halbb_dcr_init(struct bb_info *bb);
-void halbb_dcr_reset(struct bb_info *bb);
-void halbb_dyn_csi_rsp_dbg(struct bb_info *bb, char input[][16],
-			   u32 *_used, char *output, u32 *_out_len);
-void halbb_dyn_csi_rsp_main(struct bb_info *bb);
-#endif
-#endif
diff --git a/os/board/rtl8720e/src/component/wifi/driver/src/hal/phy_g6/bb/halbb_dyn_csi_rsp_ex.h b/os/board/rtl8720e/src/component/wifi/driver/src/hal/phy_g6/bb/halbb_dyn_csi_rsp_ex.h
deleted file mode 100644
index 5f2d9f7cc..000000000
--- a/os/board/rtl8720e/src/component/wifi/driver/src/hal/phy_g6/bb/halbb_dyn_csi_rsp_ex.h
+++ /dev/null
@@ -1,39 +0,0 @@
-/******************************************************************************
- *
- * Copyright(c) 2007 - 2020  Realtek Corporation.
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of version 2 of the GNU General Public License as
- * published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
- * more details.
- *
- * The full GNU General Public License is included in this distribution in the
- * file called LICENSE.
- *
- * Contact Information:
- * wlanfae <wlanfae@realtek.com>
- * Realtek Corporation, No. 2, Innovation Road II, Hsinchu Science Park,
- * Hsinchu 300, Taiwan.
- *
- * Larry Finger <Larry.Finger@lwfinger.net>
- *
- *****************************************************************************/
-#ifndef __HALBB_DYN_CSI_RSP_EX_H__
-#define __HALBB_DYN_CSI_RSP_EX_H__
-
-/*@--------------------------[Define] ---------------------------------------*/
-
-/*@--------------------------[Enum]------------------------------------------*/
-
-/*@--------------------------[Structure]-------------------------------------*/
-
-/*@--------------------------[Prptotype]-------------------------------------*/
-bool halbb_dcr_en(struct bb_info *bb, bool en);
-bool halbb_dyn_csi_rsp_rlt_get(struct bb_info *bb);
-
-#endif
-
diff --git a/os/board/rtl8720e/src/component/wifi/driver/src/hal/phy_g6/bb/halbb_edcca.h b/os/board/rtl8720e/src/component/wifi/driver/src/hal/phy_g6/bb/halbb_edcca.h
deleted file mode 100644
index ca76f4044..000000000
--- a/os/board/rtl8720e/src/component/wifi/driver/src/hal/phy_g6/bb/halbb_edcca.h
+++ /dev/null
@@ -1,184 +0,0 @@
-/******************************************************************************
- *
- * Copyright(c) 2007 - 2020  Realtek Corporation.
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of version 2 of the GNU General Public License as
- * published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
- * more details.
- *
- * The full GNU General Public License is included in this distribution in the
- * file called LICENSE.
- *
- * Contact Information:
- * wlanfae <wlanfae@realtek.com>
- * Realtek Corporation, No. 2, Innovation Road II, Hsinchu Science Park,
- * Hsinchu 300, Taiwan.
- *
- * Larry Finger <Larry.Finger@lwfinger.net>
- *
- *****************************************************************************/
-#ifndef __HALBB_EDCCA_H__
-#define __HALBB_EDCCA_H__
-
-/*@--------------------------[Define] ---------------------------------------*/
-#define EDCCA_HL_DIFF_ADPTVTY 7
-#define EDCCA_HL_DIFF_NORMAL 8
-
-// EDCCA
-#define CBP_6G                         60 /*@-68 dB to avoid filtering loss*/
-#define EDCCA_5G                         63 /*@-62 dBm -3 dB margin*/
-#define EDCCA_2G                        68 /*@-57 dBm -3 dB margin*/
-#define CARRIER_SENSE                        75 /*@-50dBm -3 dB margin*/
-#define EDCCA_MAX                        249 /*@ 127dBm for normal mode*/
-#define EDCCA_TH_L2H_LB                  66 /*@ -62 dBm from IEEE*/
-#define EDCCA_PWDB_EXCLU_TX		128 /*128 - 256 = -128dBm when Tx*/
-#define EDCCA_PWDB_TO_RSSI(pwdb)		((pwdb + 110) < 0 ? 0 : (pwdb + 110))
-
-// Collision T2R/R2T TH
-#define COLLOSION_TH_LOW                  0
-#define COLLOSION_TH_HIGH                 31
-#define COLLOSION_TH_RSSI2VAL                 50
-#define COLLOSION_TH_OFST                 0
-
-// FW EDCCA
-#define EDCCA_5G_TH                         70 // -62
-#define EDCCA_2p4G_TH                        65// -57
-#define CARRIER_SENSE_TH                        58 // -50
-
-/*@--------------------------[Enum]------------------------------------------*/
-/*@--------------------------[Structure]-------------------------------------*/
-struct bb_h2c_fw_edcca {
-	u8 mode;
-	u8 band;
-	u8 pwr_th_5g;
-	u8 pwr_th_2p4;
-	u8 pwr_th_cs;
-	u8 rsvd0;
-	u8 rsvd1;
-	u8 rsvd2;
-};
-
-struct bb_edcca_cr_info {
-	u32 r_snd_en;
-	u32 r_snd_en_m;
-	u32 r_dwn_level;
-	u32 r_dwn_level_m;
-	u32 r_edcca_level;
-	u32 r_edcca_level_m;
-	u32 r_edcca_level_p;
-	u32 r_edcca_level_p_m;
-	u32 r_edcca_rpt_a;
-	u32 r_edcca_rpt_a_m;
-	u32 r_edcca_rpt_b;
-	u32 r_edcca_rpt_b_m;
-	u32 r_edcca_rpt_a_p1;
-	u32 r_edcca_rpt_a_p1_m;
-	u32 r_edcca_rpt_b_p1;
-	u32 r_edcca_rpt_b_p1_m;
-	u32 r_edcca_rpt_sel;
-	u32 r_edcca_rpt_sel_m;
-	u32 r_edcca_rpt_sel_p1;
-	u32 r_edcca_rpt_sel_p1_m;
-	u32 r_ppdu_level;
-	u32 r_ppdu_level_m;
-	u32 r_obss_level;
-	u32 r_obss_level_m;
-	u32 collision_r2t_th;
-	u32 collision_r2t_th_m;
-	u32 collision_t2r_th_mcs0;
-	u32 collision_t2r_th_mcs0_m;
-	u32 collision_t2r_th_mcs1;
-	u32 collision_t2r_th_mcs1_m;
-	u32 collision_t2r_th_mcs2;
-	u32 collision_t2r_th_mcs2_m;
-	u32 collision_t2r_th_mcs3;
-	u32 collision_t2r_th_mcs3_m;
-	u32 collision_t2r_th_mcs4;
-	u32 collision_t2r_th_mcs4_m;
-	u32 collision_t2r_th_mcs5;
-	u32 collision_t2r_th_mcs5_m;
-	u32 collision_t2r_th_mcs6;
-	u32 collision_t2r_th_mcs6_m;
-	u32 collision_t2r_th_mcs7;
-	u32 collision_t2r_th_mcs7_m;
-	u32 collision_t2r_th_mcs8;
-	u32 collision_t2r_th_mcs8_m;
-	u32 collision_t2r_th_mcs9;
-	u32 collision_t2r_th_mcs9_m;
-	u32 collision_t2r_th_mcs10;
-	u32 collision_t2r_th_mcs10_m;
-	u32 collision_t2r_th_mcs11;
-	u32 collision_t2r_th_mcs11_m;
-	u32 collision_t2r_th_cck;
-	u32 collision_t2r_th_cck_m;
-};
-
-struct edcca_hw_rpt {
-	s8 pwdb_fb; /*52A/52B is 0 when BW=40, 92XB would fix*/
-	s8 pwdb_p20;
-	s8 pwdb_s20;
-	s8 pwdb_s40;
-	s8 pwdb_s80;
-	bool flag_fb;
-	bool flag_p20;
-	bool flag_s20;
-	bool flag_s40;
-	bool flag_s80;
-	s8 pwdb_0;
-	s8 pwdb_1;
-	s8 pwdb_2;
-	s8 pwdb_3;
-	s8 pwdb_4;
-	s8 pwdb_5;
-	s8 pwdb_6;
-	s8 pwdb_7;
-	s8 pwdb_8;
-	u8 path;
-};
-
-struct bb_edcca_info {
-	struct bb_edcca_cr_info bb_edcca_cr_i;
-	u8 th_l;
-	u8 th_h;
-	u8 th_hl_diff;
-	u8 edcca_mode;
-	u8 th_h_lb;
-	u8 th_h_6g;
-	u8 th_h_5g;
-	u8 th_h_2p4g;
-	u8 th_h_cs;
-	u8 colli_th;
-	u8 colli_ofst;
-	struct edcca_hw_rpt edcca_rpt;
-	u32 rvrt_val; /*all rvrt_val for pause API must set to u32*/
-};
-#ifdef HALBB_DYN_L2H_SUPPORT
-struct bb_dyn_l2h_info {
-	bool en_dyn_l2h;
-	u32 low_rate_rty_cnt;
-	u32 drop_cnt;
-	u8 l2h_th;
-};
-#endif
-
-struct bb_info;
-/*@--------------------------[Prptotype]-------------------------------------*/
-void halbb_edcca(struct bb_info *bb);
-void halbb_edcca_thre_calc(struct bb_info * bb);
-void halbb_set_collision_th(struct bb_info *bb);
-void halbb_set_collision_thre(struct bb_info *bb);
-void halbb_set_edcca_pause_val(struct bb_info *bb, u32 *val_buf, u8 val_len);
-void halbb_edcca_event_nofity(struct bb_info * bb, u8 pause_type);
-void halbb_edcca_dev_hw_cap(struct bb_info * bb);
-void halbb_edcca_init(struct bb_info *bb);
-void halbb_cr_cfg_edcca_init(struct bb_info *bb);
-void halbb_edcca_dbg(struct bb_info *bb, char input[][16], u32 *_used,
-			      char *output, u32 *_out_len);
-
-#endif
-
diff --git a/os/board/rtl8720e/src/component/wifi/driver/src/hal/phy_g6/bb/halbb_edcca_ex.h b/os/board/rtl8720e/src/component/wifi/driver/src/hal/phy_g6/bb/halbb_edcca_ex.h
deleted file mode 100644
index 6206c447e..000000000
--- a/os/board/rtl8720e/src/component/wifi/driver/src/hal/phy_g6/bb/halbb_edcca_ex.h
+++ /dev/null
@@ -1,42 +0,0 @@
-/******************************************************************************
- *
- * Copyright(c) 2007 - 2020  Realtek Corporation.
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of version 2 of the GNU General Public License as
- * published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
- * more details.
- *
- * The full GNU General Public License is included in this distribution in the
- * file called LICENSE.
- *
- * Contact Information:
- * wlanfae <wlanfae@realtek.com>
- * Realtek Corporation, No. 2, Innovation Road II, Hsinchu Science Park,
- * Hsinchu 300, Taiwan.
- *
- * Larry Finger <Larry.Finger@lwfinger.net>
- *
- *****************************************************************************/
-#ifndef __HALBB_EDCCA_EX_H__
-#define __HALBB_EDCCA_EX_H__
-
-/*@--------------------------[Define] ---------------------------------------*/
-
-/*@--------------------------[Enum]------------------------------------------*/
-enum bb_edcca_mode {
-	EDCCA_NORMAL_MODE = 0,
-	EDCCA_ADAPT_MODE = 1,
-	EDCCA_CARRIER_SENSE_MODE = 2,
-	EDCCA_CBP_MODE = 3,
-};
-/*@--------------------------[Structure]-------------------------------------*/
-
-struct bb_info;
-/*@--------------------------[Prptotype]-------------------------------------*/
-void halbb_fw_edcca(struct bb_info *bb);
-#endif
diff --git a/os/board/rtl8720e/src/component/wifi/driver/src/hal/phy_g6/bb/halbb_env_mntr.h b/os/board/rtl8720e/src/component/wifi/driver/src/hal/phy_g6/bb/halbb_env_mntr.h
deleted file mode 100644
index dd7f885c8..000000000
--- a/os/board/rtl8720e/src/component/wifi/driver/src/hal/phy_g6/bb/halbb_env_mntr.h
+++ /dev/null
@@ -1,509 +0,0 @@
-/******************************************************************************
- *
- * Copyright(c) 2007 - 2020  Realtek Corporation.
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of version 2 of the GNU General Public License as
- * published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
- * more details.
- *
- * The full GNU General Public License is included in this distribution in the
- * file called LICENSE.
- *
- * Contact Information:
- * wlanfae <wlanfae@realtek.com>
- * Realtek Corporation, No. 2, Innovation Road II, Hsinchu Science Park,
- * Hsinchu 300, Taiwan.
- *
- * Larry Finger <Larry.Finger@lwfinger.net>
- *
- *****************************************************************************/
-#ifndef __HALBB_ENV_MNTR_H__
-#define __HALBB_ENV_MNTR_H__
-
-/*--------------------------[Define] ---------------------------------------*/
-#define ENV_MNTR_FAIL_BYTE		0xff
-#define ENV_MNTR_FAIL_WORD		0xffff
-#define ENV_MNTR_FAIL_DWORD	0xffffffff
-#define MAX_ENV_MNTR_TIME		8	/*second*/
-#define MS_TO_4US_RATIO		250
-/*NHM*/
-#define RSSI_2_NHM_TH(rssi)	((rssi) << 1) /*NHM_threshold = u(8,1)*/
-#define NHM_TH_2_RSSI(th)		(th >> 1)
-#define NHM_PWR_OFST		20
-#define NHM_NOISE_F_TH		60	/*60/2 = 30 = -80 dBm*/
-#define NHM_WA_TH			109	/*109 = -1 dBm*/
-#define NHM_WA_PWR		26 /*26 - 110 = -84dBm, only for 52A*/
-/*FAHM*/
-#define RSSI_2_FAHM_TH(rssi)	((rssi) << 1) /*FAHM_threshold = u(8,1)*/
-#define FAHM_TH_2_RSSI(th)		(th >> 1)
-#define FAHM_PWR_OFST		20
-#define FAHM_WA_TH		109	/*109 = -1 dBm*/
-#define FAHM_INCLU_FA		BIT(0)
-#define FAHM_INCLU_CRC_OK		BIT(1)
-#define FAHM_INCLU_CRC_ERR		BIT(2)
-#define FAHM_TH_NUM		11	/*threshold number of FAHM*/
-#define FAHM_RPT_NUM		12
-/*--------------------------[Enum]------------------------------------------*/
-enum ccx_unit {
-	CCX_04_US		= 0,	/*4us*/
-	CCX_08_US		= 1,	/*8us*/
-	CCX_16_US		= 2,	/*16us*/
-	CCX_32_US		= 3	/*32us*/
-};
-
-enum ccx_edcca_opt_bw_idx {
-	CCX_EDCCA_BW20_0	= 0,	/*seg0:SC=4*/
-	CCX_EDCCA_BW20_1	= 1,	/*seg0:SC=2*/
-	CCX_EDCCA_BW20_2	= 2,	/*seg0:SC=1*/
-	CCX_EDCCA_BW20_3	= 3,	/*seg0:SC=3*/
-	CCX_EDCCA_BW20_4	= 4,	/*seg1:SC=4*/
-	CCX_EDCCA_BW20_5	= 5,	/*seg1:SC=2*/
-	CCX_EDCCA_BW20_6	= 6,	/*seg1:SC=1*/
-	CCX_EDCCA_BW20_7	= 7	/*seg2:SC=3*/
-};
-
-enum fahm_application {
-	FAHM_INIT		= 0,
-	FAHM_BACKGROUND		= 1, /*IEEE 11K for background*/
-	FAHM_DIG			= 2,
-	FAHM_TDMA_DIG		= 3,
-	FAHM_DBG_11K		= 4, /*IEEE 11K for dbg cmd*/
-	FAHM_DBG_RSSI		= 5, /*fahm_th[0]=rssi-20, th_ofst=3dB*/
-	FAHM_DBG_MANUAL		= 6 /*fahm_th[0] & th_ofst is manual*/
-};
-
-/*--------------------------[Structure]-------------------------------------*/
-
-struct bb_env_mntr_cr_info {
-	u32 ccx_en;
-	u32 ccx_en_m;
-	u32 ccx_trig_opt;
-	u32 ccx_trig_opt_m;
-	u32 ccx_trig;
-	u32 ccx_trig_m;
-	u32 ccx_edcca_opt;
-	u32 ccx_edcca_opt_m;
-	u32 ccx_txon_opt;// For IFS 0: txon = rftxen 1:txon = phytxon
-	u32 ccx_txon_opt_m;//
-	u32 ccx_source_sel;
-	u32 ccx_source_sel_m;
-	u32 clm_unit_idx;
-	u32 clm_unit_idx_m;
-	u32 clm_en;
-	u32 clm_en_m;
-	u32 clm_opt;
-	u32 clm_opt_m;
-	u32 clm_period;
-	u32 clm_period_m;
-	u32 clm_dbg_sel;
-	u32 clm_dbg_sel_m;
-	u32 clm_idmatch_en; //mac_id_match_option for clm
-	u32 clm_idmatch_en_m; 
-	u32 clm_nav_en; // enable the option to OR mac_virtual_ccawith CCA_for_clm
-	u32 clm_nav_en_m;
-	u32	clm_rssi_th_en;  //
-	u32 clm_rssi_th_en_m;
-	u32	clm_rssi_th;
-	u32	clm_rssi_th_m; //
-	u32 clm_cnt;
-	u32 clm_cnt_m;
-	u32 clm_rdy;
-	u32 clm_rdy_m;
-	u32 edcca_clm_period;
-	u32 edcca_clm_period_m;
-	u32 edcca_clm_unit_idx;
-	u32 edcca_clm_unit_idx_m;
-	u32 edcca_clm_en;
-	u32 edcca_clm_en_m;
-	u32 edcca_clm_cnt;
-	u32 edcca_clm_cnt_m;
-	u32 edcca_clm_rdy;
-	u32 edcca_clm_rdy_m;
-	u32 nhm_en;
-	u32 nhm_en_m;
-	u32 nhm_method_sel;
-	u32 nhm_method_sel_m;
-	u32 nhm_period;
-	u32 nhm_period_m;
-	u32 nhm_unit_idx;
-	u32 nhm_unit_idx_m;
-	u32 nhm_inclu_cca;
-	u32 nhm_inclu_cca_m;
-	u32 nhm_idmatch_en; // nhm mac id match
-	u32 nhm_idmatch_en_m;
-	u32 nhm_nav_en;
-	u32 nhm_nav_en_m;
-	u32 nhm_rssi_th_en;
-	u32 nhm_rssi_th_en_m;
-	u32 nhm_rssi_th;
-	u32 nhm_rssi_th_m;
-	u32 nhm_valid_zigbee_en; // nhm zigbee valid option
-	u32 nhm_valid_zigbee_en_m;
-	u32 nhm_cnt_zigbee_en; // nhm zigbee cnt option
-	u32 nhm_cnt_zigbee_en_m;
-	u32 nhm_th0;
-	u32 nhm_th0_m;
-	u32 nhm_th1;
-	u32 nhm_th1_m;
-	u32 nhm_th2;
-	u32 nhm_th2_m;
-	u32 nhm_th3;
-	u32 nhm_th3_m;
-	u32 nhm_th4;
-	u32 nhm_th4_m;
-	u32 nhm_th5;
-	u32 nhm_th5_m;
-	u32 nhm_th6;
-	u32 nhm_th6_m;
-	u32 nhm_th7;
-	u32 nhm_th7_m;
-	u32 nhm_th8;
-	u32 nhm_th8_m;
-	u32 nhm_th9;
-	u32 nhm_th9_m;
-	u32 nhm_th10;
-	u32 nhm_th10_m;
-	u32 nhm_cnt0;
-	u32 nhm_cnt0_m;
-	u32 nhm_cnt1;
-	u32 nhm_cnt1_m;
-	u32 nhm_cnt2;
-	u32 nhm_cnt2_m;
-	u32 nhm_cnt3;
-	u32 nhm_cnt3_m;
-	u32 nhm_cnt4;
-	u32 nhm_cnt4_m;
-	u32 nhm_cnt5;
-	u32 nhm_cnt5_m;
-	u32 nhm_cnt6;
-	u32 nhm_cnt6_m;
-	u32 nhm_cnt7;
-	u32 nhm_cnt7_m;
-	u32 nhm_cnt8;
-	u32 nhm_cnt8_m;
-	u32 nhm_cnt9;
-	u32 nhm_cnt9_m;
-	u32 nhm_cnt10;
-	u32 nhm_cnt10_m;
-	u32 nhm_cnt11;
-	u32 nhm_cnt11_m;
-	u32 nhm_cca_cnt;
-	u32 nhm_cca_cnt_m;
-	u32 nhm_tx_cnt;
-	u32 nhm_tx_cnt_m;
-	u32 nhm_idle_cnt;
-	u32 nhm_idle_cnt_m;
-	u32 nhm_rdy;
-	u32 nhm_rdy_m;
-	u32 fahm_en;
-	u32 fahm_en_m;
-	u32 fahm_ofdm_en;
-	u32 fahm_ofdm_en_m;
-	u32 fahm_cck_en;
-	u32 fahm_cck_en_m;
-	u32 fahm_numer_opt;
-	u32 fahm_numer_opt_m;
-	u32 fahm_denom_opt;
-	u32 fahm_denom_opt_m;
-	u32 fahm_dis_count_each_mpdu;
-	u32 fahm_dis_count_each_mpdu_m;
-	u32 fahm_period;
-	u32 fahm_period_m;
-	u32 fahm_unit_idx;
-	u32 fahm_unit_idx_m;
-	u32 fahm_method_sel;
-	u32 fahm_method_sel_m;
-	u32 fahm_th0;
-	u32 fahm_th0_m;
-	u32 fahm_th1;
-	u32 fahm_th1_m;
-	u32 fahm_th2;
-	u32 fahm_th2_m;
-	u32 fahm_th3;
-	u32 fahm_th3_m;
-	u32 fahm_th4;
-	u32 fahm_th4_m;
-	u32 fahm_th5;
-	u32 fahm_th5_m;
-	u32 fahm_th6;
-	u32 fahm_th6_m;
-	u32 fahm_th7;
-	u32 fahm_th7_m;
-	u32 fahm_th8;
-	u32 fahm_th8_m;
-	u32 fahm_th9;
-	u32 fahm_th9_m;
-	u32 fahm_th10;
-	u32 fahm_th10_m;
-	u32 fahm_cnt0;
-	u32 fahm_cnt0_m;
-	u32 fahm_cnt1;
-	u32 fahm_cnt1_m;
-	u32 fahm_cnt2;
-	u32 fahm_cnt2_m;
-	u32 fahm_cnt3;
-	u32 fahm_cnt3_m;
-	u32 fahm_cnt4;
-	u32 fahm_cnt4_m;
-	u32 fahm_cnt5;
-	u32 fahm_cnt5_m;
-	u32 fahm_cnt6;
-	u32 fahm_cnt6_m;
-	u32 fahm_cnt7;
-	u32 fahm_cnt7_m;
-	u32 fahm_cnt8;
-	u32 fahm_cnt8_m;
-	u32 fahm_cnt9;
-	u32 fahm_cnt9_m;
-	u32 fahm_cnt10;
-	u32 fahm_cnt10_m;
-	u32 fahm_cnt11;
-	u32 fahm_cnt11_m;
-	u32 fahm_denom_cnt;
-	u32 fahm_denom_cnt_m;
-	u32 fahm_rdy;
-	u32 fahm_rdy_m;
-	u32 ifs_clm_en;
-	u32 ifs_clm_en_m;
-	u32 ifs_clm_clr;
-	u32 ifs_clm_clr_m;
-	u32 ifs_clm_period;
-	u32 ifs_clm_period_m;
-	u32 ifs_clm_unit_idx;
-	u32 ifs_clm_unit_idx_m;
-	u32 ifs_t1_en;
-	u32 ifs_t1_en_m;
-	u32 ifs_t2_en;
-	u32 ifs_t2_en_m;
-	u32 ifs_t3_en;
-	u32 ifs_t3_en_m;
-	u32 ifs_t4_en;
-	u32 ifs_t4_en_m;
-	u32 ifs_t1_th_l;
-	u32 ifs_t1_th_l_m;
-	u32 ifs_t2_th_l;
-	u32 ifs_t2_th_l_m;
-	u32 ifs_t3_th_l;
-	u32 ifs_t3_th_l_m;
-	u32 ifs_t4_th_l;
-	u32 ifs_t4_th_l_m;
-	u32 ifs_t1_th_h;
-	u32 ifs_t1_th_h_m;
-	u32 ifs_t2_th_h;
-	u32 ifs_t2_th_h_m;
-	u32 ifs_t3_th_h;
-	u32 ifs_t3_th_h_m;
-	u32 ifs_t4_th_h;
-	u32 ifs_t4_th_h_m;
-	u32 ifs_clm_tx_cnt;
-	u32 ifs_clm_tx_cnt_m;
-	u32 ifs_clm_edcca_exclu_cca;
-	u32 ifs_clm_edcca_exclu_cca_m;
-	u32 ifs_clm_cckcca_exclu_fa;
-	u32 ifs_clm_cckcca_exclu_fa_m;
-	u32 ifs_clm_ofdmcca_exclu_fa;
-	u32 ifs_clm_ofdmcca_exclu_fa_m;
-	u32 ifs_clm_cck_fa;
-	u32 ifs_clm_cck_fa_m;
-	u32 ifs_clm_ofdm_fa;
-	u32 ifs_clm_ofdm_fa_m;
-	u32 ifs_clm_t1_his;
-	u32 ifs_clm_t1_his_m;
-	u32 ifs_clm_t2_his;
-	u32 ifs_clm_t2_his_m;
-	u32 ifs_clm_t3_his;
-	u32 ifs_clm_t3_his_m;
-	u32 ifs_clm_t4_his;
-	u32 ifs_clm_t4_his_m;
-	u32 ifs_clm_t1_avg;
-	u32 ifs_clm_t1_avg_m;
-	u32 ifs_clm_t2_avg;
-	u32 ifs_clm_t2_avg_m;
-	u32 ifs_clm_t3_avg;
-	u32 ifs_clm_t3_avg_m;
-	u32 ifs_clm_t4_avg;
-	u32 ifs_clm_t4_avg_m;
-	u32 ifs_clm_t1_cca;
-	u32 ifs_clm_t1_cca_m;
-	u32 ifs_clm_t2_cca;
-	u32 ifs_clm_t2_cca_m;
-	u32 ifs_clm_t3_cca;
-	u32 ifs_clm_t3_cca_m;
-	u32 ifs_clm_t4_cca;
-	u32 ifs_clm_t4_cca_m;
-	u32 ifs_total_cnt;
-	u32 ifs_total_cnt_m;
-	u32 ifs_clm_rdy;
-	u32 ifs_clm_rdy_m;
-};
-
-struct fahm_trig_report {
-	u8			fahm_rpt_stamp;
-};
-
-struct fahm_para_info {
-	enum halbb_racing_lv		fahm_rac_lv;
-	u16				fahm_mntr_time;	/*0~2097ms*/
-	enum fahm_application		fahm_app;
-	u8				fahm_manual_th_ofst;
-	u8				fahm_manual_th0; /*dbg manual mode*/
-	u8				fahm_numer_opt;
-	u8				fahm_denom_opt;
-};
-
-struct fahm_report {
-	u8			fahm_rpt_stamp;
-	bool			fahm_rpt_result;
-	u8			fahm_rpt[FAHM_RPT_NUM]; /*percent*/
-	u8			fahm_ratio; /*percent*/
-	u8			fahm_denom_ratio; /*percent*/
-	u16			fahm_permil; /*permil*/
-	u16			fahm_denom_permil; /*permil*/
-	u8			fahm_pwr; /*110+x(dBm), unit = 1dB*/
-	u8			fahm_pwr_0p5; /*110+x/2(dBm), unit = 0.5dB*/
-};
-
-struct bb_env_mntr_info {
-	struct bb_env_mntr_cr_info	bb_env_mntr_cr_i;
-	/*sw ctrl*/
-	u32				ccx_trigger_time;
-	u8				ccx_rpt_stamp;
-	u8				ccx_watchdog_result;
-	bool				ccx_ongoing;
-	u8				ccx_rac_lv;
-	bool				ccx_manual_ctrl;
-	u16				clm_mntr_time; /*0~2097 ms*/
-	enum clm_application		clm_app;
-	u16				nhm_mntr_time; /*0~2097 ms*/
-	u8				nhm_pre_rssi;
-	enum nhm_application		nhm_app;
-	u16				ifs_clm_mntr_time; /*0~2097 ms*/
-	enum ifs_clm_application	ifs_clm_app;
-	u32				fahm_trigger_time;
-	u8 				fahm_rpt_stamp;
-	bool				fahm_watchdog_result;
-	bool				fahm_ongoing;
-	u8				fahm_rac_lv;
-	bool				fahm_manual_ctrl;
-	u8				fahm_pre_rssi;
-	u16				fahm_mntr_time; /*0~2097 ms*/
-	enum fahm_application		fahm_app;
-	u16				edcca_clm_mntr_time; /*0~2097 ms*/
-	enum edcca_clm_application	edcca_clm_app;
-	/*hw ctrl*/
-	u16				ccx_period;
-	u8				ccx_unit_idx;
-	enum ccx_edcca_opt_bw_idx	ccx_edcca_opt_bw_idx;
-	enum clm_opt_input		clm_input_opt;
-	enum clm_idmatch_input  clm_input_idmatch;
-	enum nhm_option_cca_all	nhm_include_cca;
-	enum nhm_idmatch_input  nhm_input_idmatch;
-	u8				nhm_th[NHM_TH_NUM];
-	u16				ifs_clm_th_l[IFS_CLM_NUM];
-	u16				ifs_clm_th_h[IFS_CLM_NUM];
-	u16				fahm_period;
-	u8				fahm_numer_opt;
-	u8				fahm_denom_opt;
-	u8				fahm_th[FAHM_TH_NUM];
-	/*hw report*/
-	u16			clm_result; /*sample cnt*/
-	u16			nhm_result[NHM_RPT_NUM]; /*sample cnt*/
-	u16			nhm_tx_cnt; /*sample cnt*/
-	u16			nhm_cca_cnt; /*sample cnt*/
-	u16			nhm_idle_cnt; /*sample cnt*/
-	u16			ifs_clm_tx; /*sample cnt*/
-	u16			ifs_clm_edcca_excl_cca; /*sample cnt*/
-	u16			ifs_clm_ofdmfa; /*sample cnt*/
-	u16			ifs_clm_ofdmcca_excl_fa; /*sample cnt*/
-	u16			ifs_clm_cckfa; /*sample cnt*/
-	u16			ifs_clm_cckcca_excl_fa; /*sample cnt*/
-	u16			ifs_clm_total_ifs; /*cnt*/
-	u16			ifs_clm_his[IFS_CLM_NUM]; /*cnt*/
-	u16			ifs_clm_avg[IFS_CLM_NUM]; /*sample cnt*/
-	u16			ifs_clm_cca[IFS_CLM_NUM]; /*sample cnt*/
-	u16			fahm_result[FAHM_RPT_NUM]; /*sample cnt*/
-	u16			fahm_denom_result; /*sample cnt*/
-	u16			edcca_clm_result; /*sample cnt*/
-	/*sw report*/
-	u8			clm_ratio; /*percent*/
-	u16			nhm_sw_result[NHM_RPT_NUM]; /*sample cnt*/
-	u8			nhm_wgt[NHM_RPT_NUM]; /*dBm+110*/
-	u8			nhm_rpt[NHM_RPT_NUM]; /*percent*/
-	u8			nhm_tx_ratio; /*percent*/
-	u8			nhm_cca_ratio; /*percent*/
-	u8			nhm_idle_ratio; /*percent*/
-	u8			nhm_ratio; /*percent*/
-	u16			nhm_result_sum; /*sample cnt*/
-	u8			nhm_pwr; /*110+x => dBm, unit = 1dB*/
-	u8			nhm_pwr_0p5; /*110+x/2 => dBm, unit = 0.5dB*/
-	u8			ifs_clm_tx_ratio; /*percent*/
-	u8			ifs_clm_edcca_excl_cca_ratio; /*percent*/
-	u8			ifs_clm_cck_fa_ratio; /*percent*/
-	u8			ifs_clm_ofdm_fa_ratio; /*percent*/
-	u8			ifs_clm_cck_cca_excl_fa_ratio; /*percent*/
-	u8			ifs_clm_ofdm_cca_excl_fa_ratio; /*percent*/
-	u16			ifs_clm_cck_fa_permil; /*permil*/
-	u16			ifs_clm_ofdm_fa_permil; /*permil*/
-	u32			ifs_clm_ifs_avg[IFS_CLM_NUM]; /*us*/
-	u32			ifs_clm_cca_avg[IFS_CLM_NUM]; /*us*/
-	u16			fahm_sw_result[FAHM_RPT_NUM]; /*sample cnt*/
-	u8			fahm_wgt[FAHM_RPT_NUM]; /*dBm+110*/
-	u8			fahm_rpt[FAHM_RPT_NUM]; /*percent*/
-	u16			fahm_result_sum; /*sample cnt*/
-	u8			fahm_ratio; /*percent*/
-	u8			fahm_denom_ratio; /*percent*/
-	u16			fahm_permil; /*permil*/
-	u16			fahm_denom_permil; /*permil*/
-	u8			fahm_pwr; /*110+x => dBm, unit = 1dB*/
-	u8			fahm_pwr_0p5; /*110+x/2 => dBm, unit = 0.5dB*/
-	u8			edcca_clm_ratio; /*percent*/
-	u8			edcca_noise_bg; /*dBm+110, only for 52A*/
-	struct env_mntr_rpt	env_mntr_rpt_bg;
-	struct ccx_para_info	ccx_para_info_bg;
-	struct fahm_report	fahm_report_bg;
-	struct fahm_para_info	fahm_para_info_bg;
-	u16			idle_pwr_physts; /*RSSI u(16,3) Idle time pwr from physts*/
-};
-
-/*--------------------------[Prptotype]-------------------------------------*/
-struct bb_info;
-
-#ifdef CLM_SUPPORT
-void halbb_clm_dbg(struct bb_info *bb, char input[][16], u32 *_used,
-		   char *output, u32 *_out_len);
-#endif
-#ifdef NHM_SUPPORT
-void halbb_nhm_dbg(struct bb_info *bb, char input[][16], u32 *_used,
-		   char *output, u32 *_out_len);
-#endif
-#ifdef IFS_CLM_SUPPORT
-void halbb_ifs_clm_dbg(struct bb_info *bb, char input[][16], u32 *_used,
-		       char *output, u32 *_out_len);
-#endif
-#ifdef FAHM_SUPPORT
-bool halbb_fahm_trigger(struct bb_info *bb, struct fahm_para_info *para,
-			struct fahm_trig_report *trig_rpt);
-bool halbb_fahm_result(struct bb_info *bb, struct fahm_report *rpt);
-void halbb_fahm_dbg(struct bb_info *bb, char input[][16], u32 *_used,
-		    char *output, u32 *_out_len);
-#endif
-#ifdef EDCCA_CLM_SUPPORT
-void halbb_edcca_clm_dbg(struct bb_info *bb, char input[][16], u32 *_used,
-			 char *output, u32 *_out_len);
-#endif
-u32 halbb_ccx_idx_cnt_2_us(struct bb_info *bb, u16 idx_cnt);
-void halbb_env_mntr_log(struct bb_info *bb, u32 dbg_comp);
-void halbb_idle_time_pwr_physts(struct bb_info *bb, struct physts_rxd *desc,
-				bool is_cck_rate);
-void halbb_env_mntr(struct bb_info *bb);
-void halbb_env_mntr_init(struct bb_info *bb);
-void halbb_env_mntr_dbg(struct bb_info *bb, char input[][16], u32 *_used,
-			char *output, u32 *_out_len);
-void halbb_cr_cfg_env_mntr_init(struct bb_info *bb);
-
-#endif
diff --git a/os/board/rtl8720e/src/component/wifi/driver/src/hal/phy_g6/bb/halbb_env_mntr_ex.h b/os/board/rtl8720e/src/component/wifi/driver/src/hal/phy_g6/bb/halbb_env_mntr_ex.h
deleted file mode 100644
index a1b9723fb..000000000
--- a/os/board/rtl8720e/src/component/wifi/driver/src/hal/phy_g6/bb/halbb_env_mntr_ex.h
+++ /dev/null
@@ -1,196 +0,0 @@
-/******************************************************************************
- *
- * Copyright(c) 2007 - 2020  Realtek Corporation.
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of version 2 of the GNU General Public License as
- * published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
- * more details.
- *
- * The full GNU General Public License is included in this distribution in the
- * file called LICENSE.
- *
- * Contact Information:
- * wlanfae <wlanfae@realtek.com>
- * Realtek Corporation, No. 2, Innovation Road II, Hsinchu Science Park,
- * Hsinchu 300, Taiwan.
- *
- * Larry Finger <Larry.Finger@lwfinger.net>
- *
- *****************************************************************************/
-#ifndef __HALBB_ENV_MNTR_EX_H__
-#define __HALBB_ENV_MNTR_EX_H__
-
-/*--------------------------[Define] ---------------------------------------*/
-
-/*NHM*/
-#define	NHM_TH_NUM		11	/*threshold number of NHM*/
-#define	NHM_RPT_NUM		12
-/*IFS-CLM*/
-#define	IFS_CLM_NUM		4
-
-/*--------------------------[Enum]------------------------------------------*/
-enum mntr_result_lv {
-	CCX_FAIL		= 0,
-	NHM_SUCCESS		= BIT(0),
-	CLM_SUCCESS		= BIT(1),
-	IFS_CLM_SUCCESS		= BIT(2),
-	EDCCA_CLM_SUCCESS		= BIT(3),
-	CCX_SUCCESS		= 0xf, /*exclude FAHM*/
-};
-
-enum halbb_racing_lv {
-	RAC_RELEASE		= 0,
-	RAC_LV_1		= 1,	/* Low Priority function */
-	RAC_LV_2		= 2,	/* Middle Priority function */
-	RAC_LV_3		= 3,	/* High priority function (ex: Check hang function) */
-	RAC_LV_4		= 4,	/* Debug function (the highest priority) */
-	RAC_MAX_NUM		= 5
-};
-
-enum ccx_edcca_opt_sc_idx {
-	CCX_EDCCA_SEG0_P0	= 0,	/*seg0:p20*/
-	CCX_EDCCA_SEG0_S1	= 1,	/*seg0:s20*/
-	CCX_EDCCA_SEG0_S2	= 2,	/*seg0:s40, opposite of p20*/
-	CCX_EDCCA_SEG0_S3	= 3,	/*seg0:s40, opposite of s20*/
-	CCX_EDCCA_SEG1_P0	= 4,	/*seg1:p20*/
-	CCX_EDCCA_SEG1_S1	= 5,	/*seg1:s20*/
-	CCX_EDCCA_SEG1_S2	= 6,	/*seg1:s40, opposite of p20*/
-	CCX_EDCCA_SEG1_S3	= 7	/*seg1:s40, opposite of s20*/
-};
-
-enum nhm_option_cca_all {
-	NHM_EXCLUDE_CCA		= 0,
-	NHM_INCLUDE_CCA		= 1,
-	NHM_CCA_INIT
-};
-
-enum clm_opt_input {
-	CLM_CCA_P20		= 0,
-	CLM_CCA_S20		= 1,
-	CLM_CCA_S40		= 2,
-	CLM_CCA_S80		= 3,
-	CLM_FROM_DBG		= 4,
-	CLM_TXON_CCA		= 5,
-	CLM_CCA_S80_S40_S20	= 6,
-	CLM_CCA_S80_S40_S20_P20	= 7,
-	CLM_CCA_INIT
-};
-
-enum clm_idmatch_input {
-	CLM_IDMATCH_OFF		= 0,
-	CLM_IDMATCH_ON		= 1,
-	CLM_IDMATCH_INIT
-};
-	
-enum nhm_idmatch_input {
-	NHM_IDMATCH_OFF		= 0,
-	NHM_IDMATCH_ON		= 1,
-	NHM_IDMATCH_INIT
-};
-
-enum nhm_application {
-	NHM_INIT		= 0,
-	NHM_BACKGROUND		= 1, /*IEEE 11K for background*/
-	NHM_ACS			= 2,
-	NHM_DBG_11K		= 3, /*IEEE 11K for dbg cmd*/
-	NHM_DBG_RSSI		= 4, /*nhm_th[0]=rssi-20, th_ofst=3dB*/
-	NHM_DBG_MANUAL		= 5 /*nhm_th[0] & th_ofst is manual*/
-};
-
-enum clm_application {
-	CLM_INIT		= 0,
-	CLM_BACKGROUND		= 1,/*default*/
-	CLM_ACS			= 2,
-	CLM_DBG			= 3
-};
-
-enum ifs_clm_application {
-	IFS_CLM_INIT		= 0,
-	IFS_CLM_BACKGROUND	= 1,/*default*/
-	IFS_CLM_ACS		= 2,
-	IFS_CLM_DBG		= 3,
-	IFS_CLM_DBG_MANUAL	= 4
-};
-
-enum edcca_clm_application {
-	EDCCA_CLM_INIT		= 0,
-	EDCCA_CLM_BACKGROUND	= 1,/*default*/
-	EDCCA_CLM_ACS		= 2,
-	EDCCA_CLM_DBG		= 3
-};
-
-/*--------------------------[Structure]-------------------------------------*/
-struct bb_info;
-
-struct env_trig_rpt {
-	u8			ccx_rpt_stamp;
-};
-
-struct env_mntr_rpt {
-	u8			ccx_rpt_stamp;
-	u8			ccx_rpt_result;
-	u8			clm_ratio; /*percent*/
-	u16			clm_result; /*sample cnt*/
-	u8			nhm_rpt[NHM_RPT_NUM]; /*percent*/
-	u8			nhm_ratio; /*percent*/
-	u8			nhm_tx_ratio; /*percent*/
-	u8			nhm_cca_ratio; /*percent*/
-	u8			nhm_idle_ratio; /*percent*/
-	u16			nhm_tx_cnt; /*sample cnt*/
-	u16			nhm_cca_cnt; /*sample cnt*/
-	u16			nhm_idle_cnt; /*sample cnt*/
-	u8			nhm_pwr; /*110+x(dBm), unit = 1dB*/
-	u8			nhm_pwr_0p5; /*110+x/2(dBm), unit = 0.5dB*/
-	u8			ifs_clm_tx_ratio; /*percent*/
-	u8			ifs_clm_edcca_excl_cca_ratio; /*percent*/
-	u8			ifs_clm_cck_fa_ratio; /*percent*/
-	u8			ifs_clm_ofdm_fa_ratio; /*percent*/
-	u8			ifs_clm_cck_cca_excl_fa_ratio; /*percent*/
-	u8			ifs_clm_ofdm_cca_excl_fa_ratio; /*percent*/
-	u16			ifs_clm_cck_fa_permil; /*permil*/
-	u16			ifs_clm_ofdm_fa_permil; /*permil*/
-	u16			ifs_clm_total_ifs; /*cnt*/
-	u16			ifs_clm_his[IFS_CLM_NUM]; /*cnt*/
-	u32			ifs_clm_ifs_avg[IFS_CLM_NUM]; /*us*/
-	u32			ifs_clm_cca_avg[IFS_CLM_NUM]; /*us*/
-	u8			edcca_clm_ratio; /*percent*/
-};
-
-struct ccx_para_info {
-	enum halbb_racing_lv		rac_lv;
-	u16				mntr_time;	/*0~2097ms*/
-	enum ccx_edcca_opt_sc_idx	ccx_edcca_opt_sc_idx;
-	enum clm_application		clm_app;
-	enum clm_opt_input		clm_input_opt;
-	enum clm_idmatch_input  clm_input_idmatch;
-	enum nhm_application		nhm_app;
-	u8				nhm_manual_th_ofst;
-	u8				nhm_manual_th0;	/*dbg manual mode*/
-	enum nhm_option_cca_all		nhm_incld_cca; /*Include CCA*/
-	enum nhm_idmatch_input  nhm_input_idmatch; /*nhm macid match*/
-	enum ifs_clm_application	ifs_clm_app;
-	u32				ifs_clm_manual_th_times;
-	u32				ifs_clm_manual_th0;/*us*/
-	enum edcca_clm_application	edcca_clm_app;
-};
-
-/*--------------------------[Prptotype]-------------------------------------*/
-void halbb_env_mntr_get_bg_result(struct bb_info *bb,
-				  struct env_mntr_rpt *bg_rpt,
-				  enum phl_phy_idx phy_idx);
-void halbb_env_mntr_get_bg_setting(struct bb_info *bb,
-				   struct ccx_para_info *bg_para,
-				   enum phl_phy_idx phy_idx);
-u8 halbb_env_mntr_trigger(struct bb_info *bb, struct ccx_para_info *para,
-			  struct env_trig_rpt *trig_rpt, enum phl_phy_idx phy_idx);
-u8 halbb_env_mntr_result(struct bb_info *bb, struct env_mntr_rpt *rpt, enum phl_phy_idx phy_idx);
-
-u8 halbb_env_mntr_get_802_11_k_rsni(struct bb_info *bb, s8 rcpi, s8 anpi);
-
-#endif
-
diff --git a/os/board/rtl8720e/src/component/wifi/driver/src/hal/phy_g6/bb/halbb_ex.h b/os/board/rtl8720e/src/component/wifi/driver/src/hal/phy_g6/bb/halbb_ex.h
deleted file mode 100644
index 33fbd3f73..000000000
--- a/os/board/rtl8720e/src/component/wifi/driver/src/hal/phy_g6/bb/halbb_ex.h
+++ /dev/null
@@ -1,198 +0,0 @@
-/******************************************************************************
- *
- * Copyright(c) 2007 - 2020  Realtek Corporation.
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of version 2 of the GNU General Public License as
- * published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
- * more details.
- *
- * The full GNU General Public License is included in this distribution in the
- * file called LICENSE.
- *
- * Contact Information:
- * wlanfae <wlanfae@realtek.com>
- * Realtek Corporation, No. 2, Innovation Road II, Hsinchu Science Park,
- * Hsinchu 300, Taiwan.
- *
- * Larry Finger <Larry.Finger@lwfinger.net>
- *
- *****************************************************************************/
-
-#ifndef __HALBB_EX_H__
-#define __HALBB_EX_H__
-#include "halbb_ic_hw_info.h"
-
-/*@--------------------------[Define] ---------------------------------------*/
-
-/*@--------------------------[Enum]------------------------------------------*/
-
-enum halbb_pause_type {
-	HALBB_PAUSE		= 1,	/*Pause & Set new value*/
-	HALBB_PAUSE_NO_SET	= 2,	/*Pause & Stay in current value*/
-	HALBB_RESUME		= 3,
-	HALBB_RESUME_NO_RECOVERY = 4,
-};
-
-enum halbb_pause_lv_type {
-	HALBB_PAUSE_RELEASE	= -1,
-	HALBB_PAUSE_LV_0	= 0,	/* @Low Priority function */
-	HALBB_PAUSE_LV_1	= 1,	/* @Middle Priority function */
-	HALBB_PAUSE_LV_2	= 2,	/* @High priority function (ex: Check hang function) */
-	HALBB_PAUSE_LV_3	= 3,	/* @Debug function (the highest priority) */
-	HALBB_PAUSE_MAX_NUM	= 4
-};
-
-enum halbb_pause_rpt {
-	PAUSE_FAIL		= 0,
-	PAUSE_SUCCESS		= 1
-};
-
-/*---[BB Components]---*/
-enum habb_fun_t {
-	F_RA			= 0,
-	F_FA_CNT		= 1,
-	HALBB_FUN_RSVD_2	= 2,
-	F_DFS			= 3,
-	F_EDCCA			= 4,
-	F_ENV_MNTR		= 5,
-	F_CFO_TRK		= 6,
-	F_PWR_CTRL		= 7,
-	F_RUA_TBL		= 8,
-	F_AUTO_DBG		= 9,
-	F_ANT_DIV		= 10,
-	F_DIG			= 11,
-	F_PATH_DIV		= 12,
-	F_UL_TB_CTRL	= 13,
-	F_DCR			= 31,
-	F_DEFAULT		= 0xff
-};
-
-enum bb_watchdog_mode_t {
-	BB_WATCHDOG_NORMAL = 0,
-	BB_WATCHDOG_LOW_IO = 1,
-	BB_WATCHDOG_NON_IO = 2,
-};
-
-struct halbb_func_info {
-	char name[16];
-	u8 id;
-};
-
-static const struct halbb_func_info halbb_func_i[] = {
-	{"ra", F_RA}, /*@do not move this element to other position*/
-	{"fa_cnt", F_FA_CNT}, /*@do not move this element to other position*/
-	{"rsvd2", HALBB_FUN_RSVD_2},
-	{"dfs", F_DFS},
-	{"edcca", F_EDCCA},
-	{"env_mntr", F_ENV_MNTR},
-	{"cfo_trk", F_CFO_TRK},
-	{"pwr_ctrl", F_PWR_CTRL},
-	{"rua_tbl", F_RUA_TBL},
-	{"auto_dbg", F_AUTO_DBG},
-	{"ant_div", F_ANT_DIV},
-	{"dig", F_DIG},
-	{"path_div", F_PATH_DIV},
-	{"ul_tb", F_UL_TB_CTRL},
-};
-
-/*@=[HALBB supportability]=======================================*/
-enum habb_supportability_t {
-	BB_RA			= BIT(F_RA),
-	BB_FA_CNT		= BIT(F_FA_CNT),
-	BB_FUN_RSVD_2		= BIT(HALBB_FUN_RSVD_2),
-	BB_DFS			= BIT(F_DFS),
-	BB_EDCCA		= BIT(F_EDCCA),
-	BB_ENVMNTR		= BIT(F_ENV_MNTR),
-	BB_CFO_TRK		= BIT(F_CFO_TRK),
-	BB_PWR_CTRL		= BIT(F_PWR_CTRL),
-	BB_RUA_TBL		= BIT(F_RUA_TBL),
-	BB_AUTO_DBG		= BIT(F_AUTO_DBG),
-	BB_ANT_DIV		= BIT(F_ANT_DIV),
-	BB_DIG			= BIT(F_DIG),
-	BB_PATH_DIV		= BIT(F_PATH_DIV),
-	BB_UL_TB_CTRL	= BIT(F_UL_TB_CTRL),
-	BB_DCR			= BIT(F_DCR)
-};
-
-/*@=[HALBB Debug Component]=====================================*/
-enum halbb_dbg_comp_t {
-	/*=== [DM Part] ==========================*/
-	DBG_RA			= BIT(F_RA),
-	DBG_FA_CNT		= BIT(F_FA_CNT),
-	DBG_HALBB_FUN_RSVD_2	= BIT(HALBB_FUN_RSVD_2),
-	DBG_DFS			= BIT(F_DFS),
-	DBG_EDCCA		= BIT(F_EDCCA),
-	DBG_ENV_MNTR		= BIT(F_ENV_MNTR),
-	DBG_CFO_TRK		= BIT(F_CFO_TRK),
-	DBG_PWR_CTRL		= BIT(F_PWR_CTRL),
-	DBG_RUA_TBL		= BIT(F_RUA_TBL),
-	DBG_AUTO_DBG		= BIT(F_AUTO_DBG),
-	DBG_ANT_DIV		= BIT(F_ANT_DIV),
-	DBG_DIG			= BIT(F_DIG),
-	DBG_PATH_DIV		= BIT(F_PATH_DIV),
-	DBG_UL_TB_CTRL		= BIT(F_UL_TB_CTRL),
-	/*=== [Non-DM Part] ======================*/
-	DBG_BIT14		= BIT(14),
-	DBG_BIT15		= BIT(15),
-	DBG_BIT16		= BIT(16),
-	DBG_BIT17		= BIT(17),
-	DBG_BIT18		= BIT(18),
-	DBG_CH_INFO		= BIT(19),
-	DBG_PHY_STS		= BIT(20),
-	DBG_BIT21		= BIT(21),
-	DBG_FW_INFO		= BIT(22),
-	DBG_COMMON_FLOW		= BIT(23),
-	DBG_IC_API		= BIT(24),
-	DBG_DBG_API		= BIT(25),
-	DBG_DBCC		= BIT(26),
-	DBG_DM_SUMMARY		= BIT(27),
-	DBG_PHY_CONFIG		= BIT(28),
-	DBG_INIT		= BIT(29),
-	DBG_CMN			= BIT(30),
-	DBG_DCR			= BIT(F_DCR)
-};
-/*@--------------------------[Structure]-------------------------------------*/
-
-#if 0
-/*For development use only, and will move to "struct rtw_rssi_info" in near furture*/
-struct bb_rssi_info{
-	u8 rssi; /*avg RSSI among all RF path, dbm = RSSI - 110*/
-	u16 rssi_acc; /*U(16,4) version of rssi*/
-	u8 rssi_cck; /*instance value of CCK RSSI*/
-	u8 rssi_ofdm;  /*instance value of OFDM RSSI*/
-};
-#endif
-
-struct bb_sta_info {
-	u8 sta_status_tmp;
-};
-
-/*@--------------------------[Prptotype]-------------------------------------*/
-
-struct bb_info;
-bool halbb_sta_info_init(struct bb_info *bb,
-			 struct rtw_phl_stainfo_t *phl_sta_info);
-bool halbb_sta_info_deinit(struct bb_info *bb,
-			   struct rtw_phl_stainfo_t *phl_sta_info);
-bool halbb_sta_info_add_entry(struct bb_info *bb, struct rtw_phl_stainfo_t *phl_sta_info);
-bool halbb_sta_info_delete_entry(struct bb_info *bb,
-				 struct rtw_phl_stainfo_t *phl_sta_info);
-void halbb_media_status_update(struct bb_info *bb,
-			       struct rtw_phl_stainfo_t *phl_sta_info,
-			       bool is_connected);
-void halbb_watchdog_reset(struct bb_info *bb);
-void halbb_watchdog(struct bb_info *bb, enum bb_watchdog_mode_t mode,
-		    enum phl_phy_idx phy_idx);
-u8 halbb_wifi_event_notify(struct bb_info *bb, enum phl_msg_evt_id event, enum phl_phy_idx phy_idx);
-void halbb_bb_cmd_notify(struct bb_info *bb, void *bb_cmd, enum phl_phy_idx phy_idx);
-u8 halbb_pause_func(struct bb_info *bb, enum habb_fun_t pause_func,
-		    enum halbb_pause_type pause_type,
-		    enum halbb_pause_lv_type lv,
-		    u8 val_lehgth,
-		    u32 *val_buf, enum phl_phy_idx phy_idx);
-#endif
diff --git a/os/board/rtl8720e/src/component/wifi/driver/src/hal/phy_g6/bb/halbb_export_fun.h b/os/board/rtl8720e/src/component/wifi/driver/src/hal/phy_g6/bb/halbb_export_fun.h
deleted file mode 100644
index 523481275..000000000
--- a/os/board/rtl8720e/src/component/wifi/driver/src/hal/phy_g6/bb/halbb_export_fun.h
+++ /dev/null
@@ -1,65 +0,0 @@
-/******************************************************************************
- *
- * Copyright(c) 2007 - 2020  Realtek Corporation.
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of version 2 of the GNU General Public License as
- * published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
- * more details.
- *
- * The full GNU General Public License is included in this distribution in the
- * file called LICENSE.
- *
- * Contact Information:
- * wlanfae <wlanfae@realtek.com>
- * Realtek Corporation, No. 2, Innovation Road II, Hsinchu Science Park,
- * Hsinchu 300, Taiwan.
- *
- * Larry Finger <Larry.Finger@lwfinger.net>
- *
- *****************************************************************************/
-#ifndef __HALBB_EXPORT_FUN_H__
-#define __HALBB_EXPORT_FUN_H__
-#include "halbb_cfg_ic.h"
-#include "halbb_hw_cfg_ex.h"
-#include "halbb_init_ex.h"
-#include "halbb_ex.h"
-#include "halbb_dbg_cmd_ex.h"
-#include "halbb_physts_ex.h"
-#include "halbb_api_ex.h"
-#include "halbb_interface_ex.h"
-#include "halbb_dfs_ex.h"
-#include "halbb_dig_ex.h"
-#include "halbb_mp_ex.h"
-#include "halbb_plcp_tx_ex.h"
-#include "halbb_pmac_setting_ex.h"
-#include "halbb_la_mode_ex.h"
-#include "halbb_ra_ex.h"
-#include "halbb_cmn_rpt_ex.h"
-#include "halbb_ch_info_ex.h"
-#include "halbb_math_lib_ex.h"
-#include "halbb_edcca_ex.h"
-#include "halbb_dbcc_ex.h"
-#include "halbb_rua_tbl_ex.h"
-#include "halbb_env_mntr_ex.h"
-#include "halbb_pwr_ctrl_ex.h"
-#include "halbb_dyn_csi_rsp_ex.h"
-#include "halbb_dbcc_ex.h"
-#ifdef BB_8852A_2_SUPPORT
-	#include "halbb_8852a_2/halbb_8852a_2_api_ex.h"
-#endif
-#ifdef BB_8852B_SUPPORT
-	#include "halbb_8852b/halbb_8852b_api_ex.h"
-#endif
-#ifdef BB_8852C_SUPPORT
-	#include "halbb_8852c/halbb_8852c_api_ex.h"
-#endif
-#ifdef BB_8192XB_SUPPORT
-	#include "halbb_8192xb/halbb_8192xb_api_ex.h"
-#endif
-#endif
-
diff --git a/os/board/rtl8720e/src/component/wifi/driver/src/hal/phy_g6/bb/halbb_features.h b/os/board/rtl8720e/src/component/wifi/driver/src/hal/phy_g6/bb/halbb_features.h
deleted file mode 100644
index b82aebb02..000000000
--- a/os/board/rtl8720e/src/component/wifi/driver/src/hal/phy_g6/bb/halbb_features.h
+++ /dev/null
@@ -1,162 +0,0 @@
-/******************************************************************************
- *
- * Copyright(c) 2007 - 2020  Realtek Corporation.
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of version 2 of the GNU General Public License as
- * published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
- * more details.
- *
- * The full GNU General Public License is included in this distribution in the
- * file called LICENSE.
- *
- * Contact Information:
- * wlanfae <wlanfae@realtek.com>
- * Realtek Corporation, No. 2, Innovation Road II, Hsinchu Science Park,
- * Hsinchu 300, Taiwan.
- *
- * Larry Finger <Larry.Finger@lwfinger.net>
- *
- *****************************************************************************/
-
-#ifndef __HALBB_FEATURES_H__
-#define __HALBB_FEATURES_H__
-
-#include "../../hal_headers_le.h"
-#include "halbb_cfg_ic.h"
-#include "halbb_ic_hw_info.h"
-
-/*[Control by Outer Driver]--------------------------------------------------*/
-#ifndef DRV_BB_TIMER_SUPPORT_DISABLE
-	#define HALBB_TIMER_SUPPORT
-#endif
-
-#ifndef DRV_BB_DGB_SUPPORT_DISABLE
-	#define HALBB_DBG_SUPPORT
-#endif
-
-#ifndef DRV_BB_DBG_TRACE_DISABLE
-	#define HALBB_DBG_TRACE_SUPPORT
-#endif
-
-#ifndef DRV_BB_PHYSTS_PARSING_DISABLE
-	#define HALBB_PHYSTS_PARSING_SUPPORT
-#endif
-#ifndef DRV_BB_ENV_MNTR_DISABLE
-	#define HALBB_ENV_MNTR_SUPPORT
-	//#define CLM_SUPPORT
-	//#define NHM_SUPPORT
-	//#define IFS_CLM_SUPPORT
-	//#define FAHM_SUPPORT
-	//#define EDCCA_CLM_SUPPORT
-#endif
-#ifndef DRV_BB_STATISTICS_DISABLE
-	#define HALBB_STATISTICS_SUPPORT
-#endif
-#ifndef DRV_BB_RA_DISABLE
-	#define HALBB_RA_SUPPORT
-#endif
-#ifndef DRV_BB_ADPTVTY_DISABLE
-	#define HALBB_EDCCA_SUPPORT
-#endif
-#ifndef DRV_BB_DFS_DISABLE
-	#define HALBB_DFS_SUPPORT
-	#define HALBB_ENV_MNTR_SUPPORT
-#endif
-#ifndef DRV_BB_CFO_TRK_DISABLE
-	#define HALBB_CFO_TRK_SUPPORT
-	#define HALBB_CFO_DAMPING_CHK
-	//#define BB_DYN_CFO_TRK_LOP
-#endif
-#ifndef DRV_BB_DIG_DISABLE
-	#define HALBB_DIG_SUPPORT
-	#define HALBB_DIG_SIMPLE_MODE
-	#define HALBB_SIMPLE_TDMA_DIG_SUPPORT
-	#ifndef HALBB_DIG_SIMPLE_MODE
-		#define HALBB_ENV_MNTR_SUPPORT
-		#define FAHM_SUPPORT
-		#ifndef DRV_BB_TDMADIG_DISABLE
-		#define HALBB_DIG_TDMA_SUPPORT
-		#endif
-		#ifndef DRV_BB_DIG_MCC_DISABLE
-		#define HALBB_DIG_MCC_SUPPORT
-		#define HALBB_DIG_MCC_SUPPORT_IC (BB_RTL8852A | BB_RTL8852B)
-		#endif
-		#define HALBB_DIG_DAMPING_CHK
-	#endif
-#endif
-#ifndef DRV_BB_LA_MODE_DISABLE
-	#define HALBB_LA_MODE_SUPPORT
-#endif
-#ifndef DRV_BB_PSD_DISABLE
-	//#define HALBB_PSD_SUPPORT
-#endif
-#ifndef DRV_BB_PWR_CTRL_DISABLE
-	#define HALBB_PWR_CTRL_SUPPORT
-#endif
-#ifndef DRV_BB_RUA_DISABLE
-	#define HALBB_RUA_SUPPORT
-#endif
-#ifndef DRV_BB_PMAC_TX_DISABLE
-	#define HALBB_PMAC_TX_SUPPORT
-#endif
-#ifndef DRV_BB_CH_INFO_DISABLE
-	#define HALBB_CH_INFO_SUPPORT
-	#ifndef DRV_BB_DYN_CSI_RSP_DISABLE
-	//#define HALBB_DYN_CSI_RSP_SUPPORT
-	#endif
-#endif
-#ifndef DRV_BB_AUTO_DBG_DISABLE
-	#define HALBB_AUTO_DBG_SUPPORT
-#endif
-#if 0
-	#define HALBB_ANT_DIV_SUPPORT
-#endif
-#ifdef DRV_BB_PATH_DIV_ENABLE
-	#define HALBB_PATH_DIV_SUPPORT
-#endif
-#ifndef DRV_BB_DYN_L2H_DISABLE
-	#define HALBB_DYN_L2H_SUPPORT
-#endif
-#ifndef DRV_BB_PMAC_TX_SETTING_DISABLE
-	#define HALBB_PMAC_TX_SETTING_SUPPORT
-#endif
-/*[DBCC]*/
-#if (defined(CONFIG_DBCC_SUPPORT) &&  defined(HALBB_COMPILE_IC_DBCC))
-	#define HALBB_DBCC_SUPPORT
-	#define HALBB_DBCC_DVLP_FLAG
-#endif
-/*[FW OFFLOAD]*/
-#if (defined(CONFIG_FW_IO_OFLD_SUPPORT) &&  defined(HALBB_COMPILE_IC_FWOFLD))
-#define HALBB_FW_OFLD_SUPPORT
-#endif
-
-//#define HALBB_TDMA_CR_SUPPORT
-
-/*[POP resolved hang]*/
-#ifdef DRV_RESOLVED_POP_BY_BB
-	#define HALBB_RESOLVED_POP_BY_BB
-#endif
-
-#ifdef DRV_BB_ULOFDMA_CTRL_DISABLE
-	#define HALBB_UL_TB_CTRL_SUPPORT
-#endif
-
-/*[Shared crystal]*/
-#if (defined(CONFIG_SHARE_XSTAL) || defined(CONFIG_2G_25MHZ_XSTAL))
-	#define HALBB_SHARE_XSTAL_SUPPORT
-#endif
-
-#ifdef DRV_BB_CMN_RPT_DISABLE
-	#define HALBB_CMN_RPT_SIMPLE
-#endif
-//#define HALBB_DYN_1R_CCA_SUPPORT
-
-#if (defined(DRV_BB_CNSL_CMN_INFO) || !defined(HALBB_DBG_TRACE_SUPPORT))
-	#define HALBB_CNSL_CMN_INFO_SUPPORT
-#endif
-#endif
diff --git a/os/board/rtl8720e/src/component/wifi/driver/src/hal/phy_g6/bb/halbb_fwofld.h b/os/board/rtl8720e/src/component/wifi/driver/src/hal/phy_g6/bb/halbb_fwofld.h
deleted file mode 100644
index c8d8d620b..000000000
--- a/os/board/rtl8720e/src/component/wifi/driver/src/hal/phy_g6/bb/halbb_fwofld.h
+++ /dev/null
@@ -1,47 +0,0 @@
-/******************************************************************************
- *
- * Copyright(c) 2007 - 2020  Realtek Corporation.
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of version 2 of the GNU General Public License as
- * published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
- * more details.
- *
- * The full GNU General Public License is included in this distribution in the
- * file called LICENSE.
- *
- * Contact Information:
- * wlanfae <wlanfae@realtek.com>
- * Realtek Corporation, No. 2, Innovation Road II, Hsinchu Science Park,
- * Hsinchu 300, Taiwan.
- *
- * Larry Finger <Larry.Finger@lwfinger.net>
- *
- *****************************************************************************/
-#ifndef __HALBB_FWOFLD_H__
-#define __HALBB_FWOFLD_H__
-
-/*@--------------------------[Define] ---------------------------------------*/
-
-/*@--------------------------[Enum]------------------------------------------*/
-
-/*@--------------------------[Structure]-------------------------------------*/
-
-
-struct bb_info;
-/*@--------------------------[Prptotype]-------------------------------------*/
-#ifdef HALBB_FW_OFLD_SUPPORT
-bool halbb_fw_set_reg(struct bb_info *bb, u32 addr, u32 mask, u32 val, u8 lc);
-bool halbb_fwcfg_bb_phy_8852a_2(struct bb_info *bb, u32 addr, u32 data,
-			    enum phl_phy_idx phy_idx);
-bool halbb_fwofld_bw_ch_8852a_2(struct bb_info *bb, u8 pri_ch, u8 central_ch,
-			    enum channel_width bw, enum phl_phy_idx phy_idx);
-void halbb_fwofld_set_pmac_tx_8852a_2(struct bb_info *bb,
-			     struct halbb_pmac_info *tx_info,
-			     enum phl_phy_idx phy_idx);
-#endif
-#endif
\ No newline at end of file
diff --git a/os/board/rtl8720e/src/component/wifi/driver/src/hal/phy_g6/bb/halbb_fwofld_ex.h b/os/board/rtl8720e/src/component/wifi/driver/src/hal/phy_g6/bb/halbb_fwofld_ex.h
deleted file mode 100644
index 02ad4a0e5..000000000
--- a/os/board/rtl8720e/src/component/wifi/driver/src/hal/phy_g6/bb/halbb_fwofld_ex.h
+++ /dev/null
@@ -1,42 +0,0 @@
-/******************************************************************************
- *
- * Copyright(c) 2007 - 2020  Realtek Corporation.
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of version 2 of the GNU General Public License as
- * published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
- * more details.
- *
- * The full GNU General Public License is included in this distribution in the
- * file called LICENSE.
- *
- * Contact Information:
- * wlanfae <wlanfae@realtek.com>
- * Realtek Corporation, No. 2, Innovation Road II, Hsinchu Science Park,
- * Hsinchu 300, Taiwan.
- *
- * Larry Finger <Larry.Finger@lwfinger.net>
- *
- *****************************************************************************/
-#ifndef __HALBB_FWOFLD_EX_H__
-#define __HALBB_FWOFLD_EX_H__
-
-/*@--------------------------[Define] ---------------------------------------*/
-
-/*@--------------------------[Enum]------------------------------------------*/
-
-/*@--------------------------[Structure]-------------------------------------*/
-
-
-struct bb_info;
-/*@--------------------------[Prptotype]-------------------------------------*/
-#ifdef HALBB_FW_OFLD_SUPPORT
-bool halbb_check_fw_ofld(struct bb_info *bb);
-bool halbb_fw_set_reg(struct bb_info *bb, u32 addr, u32 mask, u32 val, u8 lc);
-bool halbb_fw_delay(struct bb_info *bb, u32 val);
-#endif
-#endif
\ No newline at end of file
diff --git a/os/board/rtl8720e/src/component/wifi/driver/src/hal/phy_g6/bb/halbb_hw_cfg.h b/os/board/rtl8720e/src/component/wifi/driver/src/hal/phy_g6/bb/halbb_hw_cfg.h
deleted file mode 100644
index bf56604f1..000000000
--- a/os/board/rtl8720e/src/component/wifi/driver/src/hal/phy_g6/bb/halbb_hw_cfg.h
+++ /dev/null
@@ -1,70 +0,0 @@
-/******************************************************************************
- *
- * Copyright(c) 2007 - 2020  Realtek Corporation.
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of version 2 of the GNU General Public License as
- * published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
- * more details.
- *
- * The full GNU General Public License is included in this distribution in the
- * file called LICENSE.
- *
- * Contact Information:
- * wlanfae <wlanfae@realtek.com>
- * Realtek Corporation, No. 2, Innovation Road II, Hsinchu Science Park,
- * Hsinchu 300, Taiwan.
- *
- * Larry Finger <Larry.Finger@lwfinger.net>
- *
- *****************************************************************************/
-#ifndef __HALBB_HW_CFG_H__
-#define __HALBB_HW_CFG_H__
-
-/*@--------------------------[Define] ---------------------------------------*/
-
-#define BB_RXSC_NUM_40		9 /*SC:0,1~8*/
-#define BB_RXSC_NUM_80		13 /*SC:0,1~8,9~12*/
-#define BB_RXSC_NUM_160		15 /*SC:0,1~8,9~12,13~14*/
-#define BB_RXSC_START_IDX_FULL	0
-#define BB_RXSC_START_IDX_20	1
-#define BB_RXSC_START_IDX_20_1	5
-#define BB_RXSC_START_IDX_40	9
-#define BB_RXSC_START_IDX_80	13
-
-#define BB_BAND_NUM_MAX		12 /*2G:1, 5G:3, 6G:8*/
-#define BB_HIDE_EFUSE_SIZE	55
-
-//#define BB_GAIN_BAND_NUM	4
-/*@--------------------------[Enum]------------------------------------------*/
-enum bb_band_t {
-	BB_BAND_2G	= 0,
-	BB_BAND_5G_L	= 1,
-	BB_BAND_5G_M	= 2,
-	BB_BAND_5G_H	= 3,
-	BB_BAND_2G_L_AUX	= 4,
-	BB_BAND_5G_L_AUX	= 5,
-	BB_BAND_5G_M_AUX	= 6,
-	BB_BAND_5G_H_AUX	= 7,
-	BB_BAND_2G_BBGM	= 8,
-	BB_BAND_2G_BBGM_AUX	= 9,
-	BB_GAIN_BAND_NUM	= 10
-};
-/*@--------------------------[Structure]-------------------------------------*/
-
-/*@--------------------------[Prptotype]-------------------------------------*/
-struct bb_info;
-void halbb_cfg_bb_rpl_ofst(struct bb_info *bb, enum bb_band_t band, u8 path, u32 addr, u32 data);
-bool halbb_init_cr_default(struct bb_info *bb, bool is_form_folder, u32 folder_len,
-			   u32 *folder_array, enum phl_phy_idx phy_idx);
-bool halbb_init_gain_table(struct bb_info *bb, bool is_form_folder, u32 folder_len,
-				 u32 *folder_array, enum phl_phy_idx phy_idx);
-void halbb_rx_gain_table_dbg(struct bb_info *bb, char input[][16], 
-			     u32 *_used, char *output, u32 *_out_len);
-void halbb_rx_op1db_table_dbg(struct bb_info *bb, char input[][16], 
-			      u32 *_used, char *output, u32 *_out_len);
-#endif
\ No newline at end of file
diff --git a/os/board/rtl8720e/src/component/wifi/driver/src/hal/phy_g6/bb/halbb_hw_cfg_ex.h b/os/board/rtl8720e/src/component/wifi/driver/src/hal/phy_g6/bb/halbb_hw_cfg_ex.h
deleted file mode 100644
index 1623933b7..000000000
--- a/os/board/rtl8720e/src/component/wifi/driver/src/hal/phy_g6/bb/halbb_hw_cfg_ex.h
+++ /dev/null
@@ -1,42 +0,0 @@
-/******************************************************************************
- *
- * Copyright(c) 2007 - 2020  Realtek Corporation.
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of version 2 of the GNU General Public License as
- * published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
- * more details.
- *
- * The full GNU General Public License is included in this distribution in the
- * file called LICENSE.
- *
- * Contact Information:
- * wlanfae <wlanfae@realtek.com>
- * Realtek Corporation, No. 2, Innovation Road II, Hsinchu Science Park,
- * Hsinchu 300, Taiwan.
- *
- * Larry Finger <Larry.Finger@lwfinger.net>
- *
- *****************************************************************************/
-#ifndef _HALBB_HW_CFG_EX_H_
-#define _HALBB_HW_CFG_EX_H_
-
-/*@--------------------------[Define] ---------------------------------------*/
-
-/*@--------------------------[Enum]------------------------------------------*/
-enum bb_para_init_t {
-	BB_DEFAULT_CR = 0,
-	BB_GAIN_TABLE = 1,
-};
-
-/*@--------------------------[Structure]-------------------------------------*/
-
-/*@--------------------------[Prptotype]-------------------------------------*/
-struct bb_info;
-bool halbb_init_reg(struct bb_info *bb);
-bool halbb_init_bb_cr_per_phy(struct bb_info *bb, enum phl_phy_idx phy_idx);
-#endif
diff --git a/os/board/rtl8720e/src/component/wifi/driver/src/hal/phy_g6/bb/halbb_ic_hw_info.h b/os/board/rtl8720e/src/component/wifi/driver/src/hal/phy_g6/bb/halbb_ic_hw_info.h
deleted file mode 100644
index e5d0d34a8..000000000
--- a/os/board/rtl8720e/src/component/wifi/driver/src/hal/phy_g6/bb/halbb_ic_hw_info.h
+++ /dev/null
@@ -1,369 +0,0 @@
-/******************************************************************************
- *
- * Copyright(c) 2007 - 2020  Realtek Corporation.
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of version 2 of the GNU General Public License as
- * published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
- * more details.
- *
- * The full GNU General Public License is included in this distribution in the
- * file called LICENSE.
- *
- * Contact Information:
- * wlanfae <wlanfae@realtek.com>
- * Realtek Corporation, No. 2, Innovation Road II, Hsinchu Science Park,
- * Hsinchu 300, Taiwan.
- *
- * Larry Finger <Larry.Finger@lwfinger.net>
- *
- *****************************************************************************/
-#ifndef __HALBB_IC_HW_INFO_H__
-#define __HALBB_IC_HW_INFO_H__
-
-enum bb_ic_t {
-	/*BB_RTL8852AA	=	BIT(0), 8852A Acut*/
-	BB_RTL8852A	=	BIT(1), /*8852A > Bcut*/
-	BB_RTL8852B	=	BIT(2),
-	BB_RTL8852C	=	BIT(3),
-	BB_RTL8834A	=	BIT(4),
-	BB_RTL8192XB	=	BIT(5),
-	BB_RTL8730E	=	BIT(6),
-	BB_RTL8720E= 	BIT(7)
-};
-
-enum bb_ic_sub_t {
-	BB_IC_SUB_TYPE_8852B_8852B	=	20,
-	BB_IC_SUB_TYPE_8852B_8852BP,
-	BB_IC_SUB_TYPE_8730E_8730E = 30,
-	BB_IC_SUB_TYPE_8720E_8720E = 40,
-	BB_IC_SUB_TYPE_8192XB_8192XB	=	50,
-	BB_IC_SUB_TYPE_8192XB_8832BR,
-	BB_IC_SUB_TYPE_8192XB_8832BR_VT
-};
-
-enum bb_cr_t {
-	BB_AP		=	1,
-	BB_AP2		=	2,
-	BB_CLIENT	=	3
-};
-
-#define BB_IC_N_1SS		0
-#define BB_IC_N_2SS		0
-#define BB_IC_N_3SS		0
-#define BB_IC_N_4SS		0
-
-#define BB_IC_AC_1SS		0
-#define BB_IC_AC_2SS		0
-#define BB_IC_AC_3SS		0
-#define BB_IC_AC_4SS		0
-
-#define BB_IC_AX_1SS		(BB_RTL8730E | BB_RTL8720E)
-#define BB_IC_AX_2SS		(BB_RTL8852A | BB_RTL8852B | BB_RTL8852C |\
-				 BB_RTL8192XB)
-#define BB_IC_AX_3SS		0
-#define BB_IC_AX_4SS		(BB_RTL8834A)
-
-/*@====the following macro DO NOT need to update when adding a new IC======= */
-#define BB_IC_1SS		(BB_IC_N_1SS | BB_IC_AC_1SS | BB_IC_AX_1SS)
-#define BB_IC_2SS		(BB_IC_N_2SS | BB_IC_AC_2SS | BB_IC_AX_2SS)
-#define BB_IC_3SS		(BB_IC_N_3SS | BB_IC_AC_3SS | BB_IC_AX_3SS)
-#define BB_IC_4SS		(BB_IC_N_4SS | BB_IC_AC_4SS | BB_IC_AX_4SS)
-
-#define BB_IC_ABOVE_1SS		(BB_IC_1SS | BB_IC_2SS | BB_IC_3SS |\
-				BB_IC_4SS)
-#define BB_IC_ABOVE_2SS		(BB_IC_2SS | BB_IC_3SS | BB_IC_4SS)
-#define BB_IC_ABOVE_3SS		(BB_IC_3SS | BB_IC_4SS)
-#define BB_IC_ABOVE_4SS		BB_IC_4SS
-
-#define BB_IC_N_SERIES		(BB_IC_N_1SS | BB_IC_N_2SS | BB_IC_N_3SS |\
-				 BB_IC_N_4SS)
-#define BB_IC_AC_SERIES		(BB_IC_AC_1SS | BB_IC_AC_2SS |\
-				 BB_IC_AC_3SS | BB_IC_AC_4SS)
-#define BB_IC_AX_SERIES		(BB_IC_AX_1SS | BB_IC_AX_2SS |\
-				 BB_IC_AX_3SS | BB_IC_AX_4SS)
-/*@==========================================================================*/
-
-#define BB_IC_AX_AP		(BB_RTL8852A | BB_RTL8834A)
-#define BB_IC_AX_AP2		(BB_RTL8852C | BB_RTL8192XB)
-#define BB_IC_AX_CLIENT		(BB_RTL8852B | BB_RTL8730E | BB_RTL8720E)
-
-/*@==========================================================================*/
-
-#define BB_IC_MAX_BW_80		(BB_RTL8852A | BB_RTL8852B | BB_RTL8192XB)
-#define BB_IC_MAX_BW_160	(BB_RTL8852C | BB_RTL8834A)
-/*@==========================================================================*/
-
-#define BB_IC_DBCC		(BB_RTL8852A | BB_RTL8852C)
-
-/*@==========================================================================*/
-#if defined(BB_8852A_2_SUPPORT) || defined(BB_8852C_SUPPORT)
-	#define HALBB_COMPILE_IC_DBCC
-#endif
-
-#if defined(BB_8852A_2_SUPPORT) || defined(BB_8852B_SUPPORT) || defined(BB_8852C_SUPPORT)
-	/* FW OFFLOAD will be used in non-AP-only ICs*/
-	#define HALBB_COMPILE_IC_FWOFLD
-#endif
-
-#if defined(RTL8851A_SUPPORT) || defined(BB_8720E_SUPPORT) || defined(BB_8730E_SUPPORT)
-	#define HALBB_COMPILE_IC_1SS
-#endif
-
-#if (defined(BB_8852A_2_SUPPORT) || defined(BB_8852B_SUPPORT) ||\
-     defined(BB_8852C_SUPPORT) || defined(BB_8192XB_SUPPORT))
-	#define HALBB_COMPILE_IC_2SS
-#endif
-
-#if defined(RTL8853A_SUPPORT)
-	#define HALBB_COMPILE_IC_3SS
-#endif
-
-#if defined(RTL8834A_SUPPORT)
-	#define HALBB_COMPILE_IC_4SS
-#endif
-
-/*@==========================================================================*/
-#if (defined(HALBB_COMPILE_IC_4SS))
-	#define HALBB_COMPILE_ABOVE_4SS
-#endif
-
-#if (defined(HALBB_COMPILE_IC_3SS) || defined(HALBB_COMPILE_ABOVE_4SS))
-	#define HALBB_COMPILE_ABOVE_3SS
-#endif
-
-#if (defined(HALBB_COMPILE_IC_2SS) || defined(HALBB_COMPILE_ABOVE_3SS))
-	#define HALBB_COMPILE_ABOVE_2SS
-#endif
-
-#if (defined(HALBB_COMPILE_IC_1SS) || defined(HALBB_COMPILE_ABOVE_2SS))
-	#define HALBB_COMPILE_ABOVE_1SS
-#endif
-
-#if (defined(HALBB_COMPILE_ABOVE_4SS))
-	#define HALBB_MAX_PATH	4
-#elif (defined(HALBB_COMPILE_ABOVE_3SS))
-	#define HALBB_MAX_PATH	3
-#elif (defined(HALBB_COMPILE_ABOVE_2SS))
-	#define HALBB_MAX_PATH	2
-#else
-	#define HALBB_MAX_PATH	1
-#endif
-/*@==========================================================================*/
-
-#if (defined(BB_8852A_2_SUPPORT))
-	#define HALBB_COMPILE_AP_SERIES
-#endif
-
-#if (defined(BB_8852C_SUPPORT) || defined(BB_8192XB_SUPPORT))
-	#define HALBB_COMPILE_AP2_SERIES
-#endif
-
-#if (defined(BB_8852B_SUPPORT) || defined(BB_8730E_SUPPORT) || defined(BB_8720E_SUPPORT))
-	#define HALBB_COMPILE_CLIENT_SERIES
-#endif
-
-/*@==========================================================================*/
-
-#if (defined(BB_8852C_SUPPORT))
-#define HALBB_TW_DFS_SERIES
-#endif
-
-/*@==========================================================================*/
-enum halbb_rate_type {
-	BB_1SS			= 1,	/*HE/VHT/HT 1SS*/
-	BB_2SS			= 2,	/*HE/VHT/HT 2SS*/
-	BB_3SS			= 3,	/*HE/VHT/HT 3SS*/
-	BB_4SS			= 4,	/*HE/VHT/HT 4SS*/
-	BB_CCK			= 11,	/*B mode*/
-	BB_OFDM			= 12	/*G mode*/
-};
-
-enum halbb_rate_table {
-	BB_01M			= 0,
-	BB_02M			= 1,
-	BB_05M			= 2,
-	BB_11M			= 3,
-	BB_06M			= 4,
-	BB_09M			= 5,
-	BB_12M			= 6,
-	BB_18M			= 7,
-	BB_24M			= 8,
-	BB_36M			= 9,
-	BB_48M			= 10,
-	BB_54M			= 11,
-	BB_HT_MCS0		= 128,	/*0x1000000*/
-	BB_VHT_1SS_MCS0	= 256,		/*0x2000000*/
-	BB_VHT_2SS_MCS0	= 272,
-	BB_VHT_3SS_MCS0	= 288,
-	BB_VHT_4SS_MCS0	= 304,
-	BB_VHT_5SS_MCS0	= 320,
-	BB_VHT_6SS_MCS0	= 336,
-	BB_VHT_7SS_MCS0	= 352,
-	BB_VHT_8SS_MCS0	= 368,	
-	BB_HE_1SS_MCS0		= 384,	/*0x3000000*/
-	BB_HE_2SS_MCS0		= 400,
-	BB_HE_3SS_MCS0		= 416,
-	BB_HE_4SS_MCS0		= 432,
-	BB_HE_5SS_MCS0		= 448,
-	BB_HE_6SS_MCS0		= 464,
-	BB_HE_7SS_MCS0		= 480,
-	BB_HE_8SS_MCS0		= 496	
-};
-
-enum halbb_legacy_spec_rate {
-	BB_SPEC_RATE_6M		= 0xb,
-	BB_SPEC_RATE_9M		= 0xf,
-	BB_SPEC_RATE_12M	= 0xa,
-	BB_SPEC_RATE_18M	= 0xe,
-	BB_SPEC_RATE_24M	= 0x9,
-	BB_SPEC_RATE_36M	= 0xd,
-	BB_SPEC_RATE_48M	= 0x8,
-	BB_SPEC_RATE_54M	= 0xc
-};
-
-#define GEN_HT_RATE_IDX(MCS) (0x80 | ((MCS) & 0x1f))
-#define GEN_VHT_RATE_IDX(SS, MCS) (0x100 | (((SS) & 0x3) << 4) | ((MCS) & 0xf))
-#define GEN_HE_RATE_IDX(SS, MCS) (0x180 | (((SS) & 0x3) << 4) | ((MCS) & 0xf))
-
-#define BB_HT_MCS(x) 		(BB_HT_MCS0 + x)
-#define BB_VHT_1SS_MCS(x)	(BB_VHT_1SS_MCS0 + x)
-#define BB_VHT_2SS_MCS(x)	(BB_VHT_2SS_MCS0 + x)
-#define BB_VHT_3SS_MCS(x)	(BB_VHT_3SS_MCS0 + x)
-#define BB_VHT_4SS_MCS(x)	(BB_VHT_4SS_MCS0 + x)
-#define BB_VHT_5SS_MCS(x)	(BB_VHT_5SS_MCS0 + x)
-#define BB_VHT_6SS_MCS(x)	(BB_VHT_6SS_MCS0 + x)
-#define BB_VHT_7SS_MCS(x)	(BB_VHT_7SS_MCS0 + x)
-#define BB_VHT_8SS_MCS(x)	(BB_VHT_8SS_MCS0 + x)
-#define BB_HE_1SS_MCS(x)	(BB_HE_1SS_MCS0 + x)
-#define BB_HE_2SS_MCS(x)	(BB_HE_2SS_MCS0 + x)
-#define BB_HE_3SS_MCS(x)	(BB_HE_3SS_MCS0 + x)
-#define BB_HE_4SS_MCS(x)	(BB_HE_4SS_MCS0 + x)
-#define BB_HE_5SS_MCS(x)	(BB_HE_5SS_MCS0 + x)
-#define BB_HE_6SS_MCS(x)	(BB_HE_6SS_MCS0 + x)
-#define BB_HE_7SS_MCS(x)	(BB_HE_7SS_MCS0 + x)
-#define BB_HE_8SS_MCS(x)	(BB_HE_8SS_MCS0 + x)
-
-#define BB_VHT_MCS(SS, x)	(BB_VHT_1SS_MCS0 + ((SS - 1) * 16 ) + x)
-#define BB_HE_MCS(SS, x)	(BB_HE_1SS_MCS0 + ((SS - 1) * 16 ) + x)
-
-/*[Rate Number]*/
-#define	HT_NUM_MCS		8
-#define	HE_VHT_NUM_MCS		12
-#define	LEGACY_RATE_NUM		12
-
-#define	HT_RATE_NUM_4SS		(HT_NUM_MCS * 4)
-#define	VHT_RATE_NUM_4SS	(HE_VHT_NUM_MCS * 4)
-#define	HE_RATE_NUM_4SS		(HE_VHT_NUM_MCS * 4)
-
-#define	HT_RATE_NUM_3SS		(HT_NUM_MCS * 3)
-#define	VHT_RATE_NUM_3SS	(HE_VHT_NUM_MCS * 3)
-#define	HE_RATE_NUM_3SS		(HE_VHT_NUM_MCS * 3)
-
-#define	HT_RATE_NUM_2SS		(HT_NUM_MCS * 2)
-#define	VHT_RATE_NUM_2SS	(HE_VHT_NUM_MCS * 2)
-#define	HE_RATE_NUM_2SS		(HE_VHT_NUM_MCS * 2)
-
-#define	HT_RATE_NUM_1SS		HT_NUM_MCS
-#define	VHT_RATE_NUM_1SS	HE_VHT_NUM_MCS
-#define	HE_RATE_NUM_1SS		HE_VHT_NUM_MCS
-
-#if (defined(HALBB_COMPILE_ABOVE_4SS))
-	#define	HT_RATE_NUM	HT_RATE_NUM_4SS
-	#define	VHT_RATE_NUM	VHT_RATE_NUM_4SS
-	#define	HE_RATE_NUM	HE_RATE_NUM_4SS
-#elif (defined(HALBB_COMPILE_ABOVE_3SS))
-	#define	HT_RATE_NUM	HT_RATE_NUM_3SS
-	#define	VHT_RATE_NUM	VHT_RATE_NUM_3SS
-	#define	HE_RATE_NUM	HE_RATE_NUM_3SS
-#elif (defined(HALBB_COMPILE_ABOVE_2SS))
-	#define	HT_RATE_NUM	HT_RATE_NUM_2SS
-	#define	VHT_RATE_NUM	VHT_RATE_NUM_2SS
-	#define	HE_RATE_NUM	HE_RATE_NUM_2SS
-#else
-	#define	HT_RATE_NUM	HT_RATE_NUM_1SS
-	#define	VHT_RATE_NUM	VHT_RATE_NUM_1SS
-	#define	HE_RATE_NUM	HE_RATE_NUM_1SS
-#endif
-
-#define	LOW_BW_RATE_NUM		HE_RATE_NUM
-
-/*@==========================================================================*/
-
-/****************************************************************
- * 1 ============================================================
- * 1  enumeration
- * 1 ============================================================
- ***************************************************************/
-
-enum bb_qam_type {
-	BB_QAM_CCK	= 0,
-	BB_QAM_BPSK	= 1,
-	BB_QAM_QPSK	= 2,
-	BB_QAM_16QAM	= 3,
-	BB_QAM_64QAM	= 4,
-	BB_QAM_256QAM 	= 5,
-	BB_QAM_1024QAM	= 6
-};
-
-enum bb_mode_type { /*@Fast antenna training*/
-	BB_LEGACY_MODE	= 0,
-	BB_HT_MODE	= 1,
-	BB_VHT_MODE	= 2,
-	BB_HE_MODE	= 3
-};
-
-
-/* BB_CMNINFO_CART_VER */
-enum halbb_cart_ver {
-	BB_CART_A		= 0,
-	BB_CART_B		= 1,
-	BB_CART_C		= 2,
-	BB_CART_D		= 3,
-	BB_CART_E		= 4,
-	BB_CART_F		= 5,
-	BB_CART_G		= 6,
-	BB_CART_H		= 7,
-	BB_CART_I		= 8,
-	BB_CART_J		= 9,
-	BB_CART_K		= 10,
-	BB_CART_L		= 11,
-	BB_CART_M		= 12,
-	BB_CART_N		= 13,
-	BB_CART_O		= 14,
-	BB_CART_TEST		= 15,
-};
-
-enum bb_path {
-	BB_PATH_NON	= 0,
-	BB_PATH_A	= 0x00000001,
-	BB_PATH_B	= 0x00000002,
-	BB_PATH_C	= 0x00000004,
-	BB_PATH_D	= 0x00000008,
-
-	BB_PATH_AB	= (BB_PATH_A | BB_PATH_B),
-	BB_PATH_AC	= (BB_PATH_A | BB_PATH_C),
-	BB_PATH_AD	= (BB_PATH_A | BB_PATH_D),
-	BB_PATH_BC	= (BB_PATH_B | BB_PATH_C),
-	BB_PATH_BD	= (BB_PATH_B | BB_PATH_D),
-	BB_PATH_CD	= (BB_PATH_C | BB_PATH_D),
-
-	BB_PATH_ABC	= (BB_PATH_A | BB_PATH_B | BB_PATH_C),
-	BB_PATH_ABD	= (BB_PATH_A | BB_PATH_B | BB_PATH_D),
-	BB_PATH_ACD	= (BB_PATH_A | BB_PATH_C | BB_PATH_D),
-	BB_PATH_BCD	= (BB_PATH_B | BB_PATH_C | BB_PATH_D),
-
-	BB_PATH_ABCD	= (BB_PATH_A | BB_PATH_B | BB_PATH_C | BB_PATH_D),
-	BB_PATH_AUTO	= 0xff /*for auto path selection*/
-};
-
-enum rf_syn {
-	RF_SYN0 = 0,
-	RF_SYN1 = 1,
-};
-
-#endif
diff --git a/os/board/rtl8720e/src/component/wifi/driver/src/hal/phy_g6/bb/halbb_ic_sw_info.h b/os/board/rtl8720e/src/component/wifi/driver/src/hal/phy_g6/bb/halbb_ic_sw_info.h
deleted file mode 100644
index b88de73d7..000000000
--- a/os/board/rtl8720e/src/component/wifi/driver/src/hal/phy_g6/bb/halbb_ic_sw_info.h
+++ /dev/null
@@ -1,56 +0,0 @@
-/******************************************************************************
- *
- * Copyright(c) 2007 - 2020  Realtek Corporation.
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of version 2 of the GNU General Public License as
- * published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
- * more details.
- *
- * The full GNU General Public License is included in this distribution in the
- * file called LICENSE.
- *
- * Contact Information:
- * wlanfae <wlanfae@realtek.com>
- * Realtek Corporation, No. 2, Innovation Road II, Hsinchu Science Park,
- * Hsinchu 300, Taiwan.
- *
- * Larry Finger <Larry.Finger@lwfinger.net>
- *
- *****************************************************************************/
-#ifndef __HALBB_IC_SW_INFO_H__
-#define __HALBB_IC_SW_INFO_H__
-
-#define HLABB_CODE_BASE			"HALBB_029"
-#define HALBB_RELEASE_DATE		"2022_0223"
-
-/*HALBB API status*/
-#define	HALBB_SET_FAIL			0
-#define	HALBB_SET_SUCCESS		1
-#define	HALBB_SET_NO_NEED		3
-
-/*HALBB Set/Revert*/
-#define	HALBB_SET			1
-#define	HALBB_REVERT			2
-
-/****************************************************************
- * 1 ============================================================
- * 1  enumeration
- * 1 ============================================================
- ***************************************************************/
-
-enum halbb_api_host {
-	RUN_IN_FW		= 0,
-	RUN_IN_DRIVER		= 1
-};
-
-enum halbb_backup_type {
-	HALBB_BACKUP	= 1,
-	HALBB_RESTORE	= 2
-};
-
-#endif
diff --git a/os/board/rtl8720e/src/component/wifi/driver/src/hal/phy_g6/bb/halbb_init.h b/os/board/rtl8720e/src/component/wifi/driver/src/hal/phy_g6/bb/halbb_init.h
deleted file mode 100644
index 4da513df8..000000000
--- a/os/board/rtl8720e/src/component/wifi/driver/src/hal/phy_g6/bb/halbb_init.h
+++ /dev/null
@@ -1,33 +0,0 @@
-/******************************************************************************
- *
- * Copyright(c) 2019 Realtek Corporation.
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of version 2 of the GNU General Public License as
- * published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
- * more details.
- *
- *****************************************************************************/
-#ifndef _HALBB_INIT_H_
-#define _HALBB_INIT_H_
-#include "../../hal_headers_le.h"
-
-
- /*@--------------------------[Define] ---------------------------------------*/
-
- /*@--------------------------[Enum]------------------------------------------*/
- 
- /*@--------------------------[Structure]-------------------------------------*/
- 
- /*@--------------------------[Prptotype]-------------------------------------*/
-void halbb_cmn_info_self_init_per_phy(struct bb_info *bb);
-void halbb_timer_ctrl(struct bb_info *bb, enum bb_timer_cfg_t timer_state);
-void halbb_timer_init(struct bb_info *bb);
-void halbb_cr_cfg_init(struct bb_info *bb);
-enum rtw_hal_status halbb_dm_init_per_phy(struct bb_info *bb_0, enum phl_phy_idx phy_idx);
-void halbb_hw_init(struct bb_info *bb);
-#endif
\ No newline at end of file
diff --git a/os/board/rtl8720e/src/component/wifi/driver/src/hal/phy_g6/bb/halbb_init_ex.h b/os/board/rtl8720e/src/component/wifi/driver/src/hal/phy_g6/bb/halbb_init_ex.h
deleted file mode 100644
index 44e3417b8..000000000
--- a/os/board/rtl8720e/src/component/wifi/driver/src/hal/phy_g6/bb/halbb_init_ex.h
+++ /dev/null
@@ -1,38 +0,0 @@
-/******************************************************************************
- *
- * Copyright(c) 2019 Realtek Corporation.
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of version 2 of the GNU General Public License as
- * published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
- * more details.
- *
- *****************************************************************************/
-#ifndef _HALBB_INIT_EX_H_
-#define _HALBB_INIT_EX_H_
-
- /*@--------------------------[Define] ---------------------------------------*/
-
- /*@--------------------------[Enum]------------------------------------------*/
- 
- /*@--------------------------[Structure]-------------------------------------*/
- 
- /*@--------------------------[Prptotype]-------------------------------------*/
-void halbb_dm_deinit(struct rtw_phl_com_t *phl_com, void *bb_phy_0);
-void halbb_dm_init_phy1(struct bb_info *bb_0);
-enum rtw_hal_status halbb_dm_init(struct bb_info *bb, enum phl_phy_idx phy_idx);
-
-void halbb_buffer_deinit(struct rtw_phl_com_t *phl_com,
-			 struct rtw_hal_com_t *hal_com, void *bb_phy_0);
-u32 halbb_buffer_init(struct rtw_phl_com_t *phl_com,
-		      struct rtw_hal_com_t *hal_com, void **bb_out_addr);
-
-void halbb_get_efuse_init(struct bb_info *bb);
-
-void halbb_ic_hw_setting_init(struct bb_info *bb);
-
-#endif
diff --git a/os/board/rtl8720e/src/component/wifi/driver/src/hal/phy_g6/bb/halbb_interface.h b/os/board/rtl8720e/src/component/wifi/driver/src/hal/phy_g6/bb/halbb_interface.h
deleted file mode 100644
index 50a42f244..000000000
--- a/os/board/rtl8720e/src/component/wifi/driver/src/hal/phy_g6/bb/halbb_interface.h
+++ /dev/null
@@ -1,235 +0,0 @@
-/******************************************************************************
- *
- * Copyright(c) 2007 - 2020  Realtek Corporation.
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of version 2 of the GNU General Public License as
- * published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
- * more details.
- *
- * The full GNU General Public License is included in this distribution in the
- * file called LICENSE.
- *
- * Contact Information:
- * wlanfae <wlanfae@realtek.com>
- * Realtek Corporation, No. 2, Innovation Road II, Hsinchu Science Park,
- * Hsinchu 300, Taiwan.
- *
- * Larry Finger <Larry.Finger@lwfinger.net>
- *
- *****************************************************************************/
-#ifndef __HALBB_INTERFACE_H__
-#define __HALBB_INTERFACE_H__
-
-/*@--------------------------[Define] ---------------------------------------*/
-/*[IO Reg]*/
-
-#define BB_OFST 0x10000
-
-#define HALBB_SET_CR_CMN(bb, cr, val, phy_idx) halbb_set_reg_cmn(bb, cr, cr##_M, val, phy_idx);
-#define HALBB_SET_CR(bb, cr, val) halbb_set_reg(bb, cr, cr##_M, val);
-
-#define HALBB_GET_CR_CMN(bb, cr, val, phy_idx) halbb_get_reg_cmn(bb, cr, cr##_M, phy_idx);
-#define HALBB_GET_CR(bb, cr) halbb_get_reg(bb, cr, cr##_M);
-
-#define halbb_get_32(bb, addr) hal_read32((bb)->hal_com, (addr | BB_OFST))
-#define halbb_get_16(bb, addr) hal_read16((bb)->hal_com, (addr | BB_OFST))
-#define halbb_get_8(bb, addr) hal_read8((bb)->hal_com, (addr | BB_OFST))
-#define halbb_set_32(bb, addr, val) hal_write32((bb)->hal_com, (addr | BB_OFST), val)
-#define halbb_set_16(bb, addr, val) hal_write16((bb)->hal_com, (addr | BB_OFST), val)
-#define halbb_set_8(bb, addr, val) hal_write8((bb)->hal_com, (addr | BB_OFST), val)
-
-#define halbb_read_mem(bb, addr, cnt, pmem) hal_read_mem((bb)->hal_com, addr, cnt, pmem)
-
-/*[Delay]*/
-#define halbb_delay_ms(bb, ms) _os_delay_ms(bb->hal_com->drv_priv, ms)
-#define halbb_delay_us(bb, us) _os_delay_us(bb->hal_com->drv_priv, us)
-
-/*[Memory Access]*/
-#define halbb_mem_alloc(bb, buf_sz) hal_mem_alloc(bb->hal_com, buf_sz)
-#define halbb_mem_free(bb, buf, buf_sz) hal_mem_free(bb->hal_com, (void *)buf, buf_sz)
-#define halbb_mem_set(bb, buf, value, size) _os_mem_set(bb->hal_com->drv_priv, (void *)buf, value, size)
-#define halbb_mem_cpy(bb, dest, src, size) _os_mem_cpy(bb->hal_com->drv_priv, (void *)dest, (void *)src, size)
-#define halbb_mem_cmp(bb, dest, src, size) _os_mem_cmp(bb->hal_com->drv_priv, (void *)dest, (void *)src, size)
-
-/*[Timer]*/
-#ifdef HALBB_TIMER_SUPPORT
-#define halbb_timer_list	_os_timer
-#define halbb_init_timer(bb, timer, call_back_func, context, sz_id) _os_init_timer(bb->hal_com->drv_priv, timer, call_back_func, context, sz_id)
-#define halbb_set_timer(bb, timer, ms_delay) _os_set_timer(bb->hal_com->drv_priv, timer, ms_delay)
-#define halbb_cancel_timer(bb, timer) _os_cancel_timer(bb->hal_com->drv_priv, timer)
-#define halbb_release_timer(bb, timer) _os_release_timer(bb->hal_com->drv_priv, timer)
-#else
-#define halbb_timer_list	u8
-#define halbb_init_timer(bb, timer, call_back_func, context, sz_id)
-#define halbb_set_timer(bb, timer, ms_delay)
-#define halbb_cancel_timer(bb, timer)
-#define halbb_release_timer(bb, timer)
-#endif
-
-/*[Efuse]*/
-#define halbb_phy_efuse_get_info(bb, addr, size, value) rtw_hal_mac_read_phy_efuse(bb->hal_com, addr, size, value)
-
-/*[String]*/
-#define halbb_snprintf _os_snprintf
-
-/*[PwrTable]*/
-#define PWR_TBL_NUM 32
-#define NUM_HE_MCS 12
-#define NUM_DCM_MCS 4
-
-
-/*@--------------------------[Enum]------------------------------------------*/
-enum bb_timer_cfg_t {
-	BB_INIT_TIMER		= 0,
-	BB_CANCEL_TIMER		= 1,
-	BB_RELEASE_TIMER	= 2,
-	BB_SET_TIMER		= 3
-};
-
-enum halbb_h2c_ra_cmdid {
-	RA_H2C_MACIDCFG		= 0x0,
-	RA_H2C_RSSISETTING	= 0x1,
-	RA_H2C_GET_TXSTS	= 0x2,
-	RA_H2C_RA_ADJUST	= 0x3,
-	RA_H2C_ADJUST_RA_MASK		= 0x4,
-	RA_H2C_RA_D_O_TIMER	= 0x5,
-	RA_H2C_MUCFG		= 0x10,
-	RA_MAX_H2CCMD
-};
-
-enum halbb_h2c_rua_cmdid {
-	RUA_H2C_TABLE		= 0x0,
-	RUA_H2C_SWGRP		= 0x1,
-	RUA_H2C_DL_MACID	= 0x2,
-	RUA_H2C_UL_MACID	= 0x3,
-	RUA_H2C_CSIINFO		= 0x4,
-	RUA_H2C_CQI			= 0x5,
-	RUA_H2C_BBINFO		= 0x6,
-	RUA_H2C_SEN_TBL		= 0x7,
-	RUA_H2C_PWR_TBL		= 0x8,
-	RUA_MAX_H2CCMD
-};
-
-enum halbb_h2c_classid {
-	HALBB_H2C_RUA		= 0x0,
-	HALBB_H2C_RA		= 0x1,
-	HALBB_H2C_DM		= 0x2,
-	HALBB_MAX_H2CCMD
-};
-
-enum halbb_h2c_dm_cmdid {
-	DM_H2C_FWTRACE		= 0x0,
-	DM_H2C_FW_TRIG_TX	= 0x1,
-	DM_H2C_FW_HE_SIGB	= 0x2,
-	DM_H2C_FW_H2C_TEST	= 0x3,
-	DM_H2C_FW_EDCCA		= 0x4,
-	DM_H2C_FW_CMW		= 0x5,
-	DM_H2C_FW_MCC		= 0x6,
-	DM_H2C_FW_L6M_WA	= 0x7,
-	DM_MAX_H2CCMD
-};
-
-#if (defined(BB_8720E_SUPPORT) || defined(BB_8730E_SUPPORT))
-enum halbb_h2c_cmd {
-	DM_RA_H2C_MACIDCFG			= 0x40,
-	DM_RA_H2C_RSSISETTING		= 0x42,
-	DM_AP_REQ_TXRPT				= 0x43,
-	DM_RA_H2C_RA_ADJUST			= 0x47,
-	DM_IOT_H2C_FWTRACE			= 0x49,
-	DM_RA_H2C_MACIDCFG2			= 0x54,
-	DM_RA_H2C_ADJUST_RA_MASK	= 0x55,
-	DM_RA_H2C_RA_D_O_TIMER		= 0x56,
-	DM_IOT_H2C_FW_EDCCA 		= 0x57,
-	DM_MAX_IOT_H2CCMD
-};
-
-enum halbb_c2h_cmd {
-	HALBB_IOT_C2HRA_STS_RPT		= 0x16,
-	HALBB_IOT_C2HRA_TXSTS		= 0x17,
-	HALBB_MAX_IOT_C2HCMD
-};
-#endif
-
-enum halbb_c2h_classid {
-	HALBB_C2H_RUA		= 0x0,
-	HALBB_C2H_RA		= 0x1,
-	HALBB_C2H_DM		= 0x2,
-	HALBB_MAX_C2HCMD
-};
-
-enum halbb_c2h_ra_cmdid {
-	HALBB_C2HRA_STS_RPT		= 0x0,
-	HALBB_C2HRA_MU_GPTBL_RPT	= 0x1,
-	HALBB_C2HRA_TXSTS		= 0x2,
-	HALBB_MAX_C2HRACMD
-};
-
-enum halbb_c2h_dm_cmdid {
-	DM_C2H_FW_TEST			= 0x0,
-	DM_C2H_FW_TRIG_TX_RPT		= 0x1,
-	DM_C2H_SIGB			= 0x2,
-	DM_C2H_LOWRT_RTY		= 0x3,
-	DM_C2H_MCC_DIG			= 0x4,
-	HALBB_MAX_C2HDMCMD
-};
-
-enum halbb_event_idx_t {
-	/*timer*/
-	BB_EVENT_TIMER_DIG		= 0,
-	BB_EVENT_TIMER_CFO		= 1,
-	BB_EVENT_TIMER_ANTDIV		= 2,
-	BB_EVENT_TIMER_TDMA_CR		= 3,
-	BB_EVENT_TIMER_LA		= 4
-};
-
-enum halbb_timer_state_t {
-	/*timer*/
-	BB_TIMER_IDLE			= 0,
-	BB_TIMER_RUN			= 1,
-	BB_TIMER_RELEASE		= 0xff,
-};
-
-/*@--------------------------[Structure]-------------------------------------*/
-struct halbb_timer_info {
-	halbb_timer_list timer_list;
-	u32	cb_time; /*callback time (ms)*/
-	enum halbb_event_idx_t	event_idx;
-	enum halbb_timer_state_t timer_state;
-};
-
-struct halbb_pwr_by_rate_tbl {
-	u8 pwr_by_rate[PWR_TBL_NUM*2];
-};
-
-/*@--------------------------[Prptotype]-------------------------------------*/
-struct bb_info;
-
-void halbb_cfg_timers(struct bb_info *bb, enum bb_timer_cfg_t cfg,
-		      struct halbb_timer_info *timer);
-u32 halbb_get_sys_time(struct bb_info *bb);
-u32 halbb_phy0_to_phy1_ofst(struct bb_info *bb, u32 addr);
-void halbb_set_reg_curr_phy(struct bb_info *bb, u32 addr, u32 mask, u32 val);
-void halbb_set_reg_cmn(struct bb_info *bb, u32 addr, u32 mask, u32 val,
-		       enum phl_phy_idx phy_idx);
-void halbb_set_reg_phy0_1(struct bb_info *bb, u32 addr, u32 mask, u32 val);
-u32 halbb_get_reg_curr_phy(struct bb_info *bb, u32 addr, u32 mask);
-u32 halbb_get_reg_cmn(struct bb_info *bb, u32 addr, u32 mask,
-		      enum phl_phy_idx phy_idx);
-u32 halbb_get_reg_phy0_1(struct bb_info *bb, u32 addr, u32 mask, u32 *val_1);
-bool halbb_fill_h2c_cmd(struct bb_info *bb, u16 cmdlen, u8 cmdid,
-			u8 classid, u32 *pval);
-bool halbb_test_h2c_c2h_flow(struct bb_info *bb);
-
-bool halbb_check_fw_ofld(struct bb_info *bb);
-bool halbb_fw_set_reg(struct bb_info *bb, u32 addr, u32 mask, u32 val, u8 lst_cmd);
-bool halbb_fw_set_reg_cmn(struct bb_info *bb, u32 addr, u32 mask, u32 val, 
-			            enum phl_phy_idx phy_idx, u8 lst_cmd);
-bool halbb_fw_set_rf_reg(struct bb_info *bb, enum rf_path path,
-			      u32 reg_addr, u32 bit_mask, u32 data);
-
-#endif
diff --git a/os/board/rtl8720e/src/component/wifi/driver/src/hal/phy_g6/bb/halbb_interface_ex.h b/os/board/rtl8720e/src/component/wifi/driver/src/hal/phy_g6/bb/halbb_interface_ex.h
deleted file mode 100644
index 404fc2ff4..000000000
--- a/os/board/rtl8720e/src/component/wifi/driver/src/hal/phy_g6/bb/halbb_interface_ex.h
+++ /dev/null
@@ -1,56 +0,0 @@
-/******************************************************************************
- *
- * Copyright(c) 2007 - 2020  Realtek Corporation.
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of version 2 of the GNU General Public License as
- * published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
- * more details.
- *
- * The full GNU General Public License is included in this distribution in the
- * file called LICENSE.
- *
- * Contact Information:
- * wlanfae <wlanfae@realtek.com>
- * Realtek Corporation, No. 2, Innovation Road II, Hsinchu Science Park,
- * Hsinchu 300, Taiwan.
- *
- * Larry Finger <Larry.Finger@lwfinger.net>
- *
- *****************************************************************************/
-#ifndef __HALBB_INTERFACE_EX_H__
-#define __HALBB_INTERFACE_EX_H__
-
-/*@--------------------------[Define] ---------------------------------------*/
-
-/*@--------------------------[Enum]------------------------------------------*/
-
-/*@--------------------------[Structure]-------------------------------------*/
- 
-/*@--------------------------[Prptotype]-------------------------------------*/
-struct bb_info;
-void halbb_set_reg(struct bb_info *bb, u32 addr, u32 mask, u32 val);
-u32 halbb_get_reg(struct bb_info *bb, u32 addr, u32 bit_mask);
-u32 rtw_halbb_c2h_parsing(struct bb_info *bb, u8 classid, u8 cmdid, u16 len, u8 *c2h);
-u8 halbb_set_cmac_txpwr_mode(struct bb_info *bb, struct rtw_phl_stainfo_t *phl_sta_i);
-u8 halbb_set_cmac_ntx_en(struct bb_info *bb, struct rtw_phl_stainfo_t *phl_sta_i);
-u8 halbb_set_cmac_path_map_a(struct bb_info *bb, struct rtw_phl_stainfo_t *phl_sta_i);
-u8 halbb_set_cmac_path_map_b(struct bb_info *bb, struct rtw_phl_stainfo_t *phl_sta_i);
-u8 halbb_set_cmac_path_map_c(struct bb_info *bb, struct rtw_phl_stainfo_t *phl_sta_i);
-u8 halbb_set_cmac_path_map_d(struct bb_info *bb, struct rtw_phl_stainfo_t *phl_sta_i);
-u8 halbb_set_cmac_antsel_a(struct bb_info *bb, struct rtw_phl_stainfo_t *phl_sta_i);
-u8 halbb_set_cmac_antsel_b(struct bb_info *bb, struct rtw_phl_stainfo_t *phl_sta_i);
-u8 halbb_set_cmac_antsel_c(struct bb_info *bb, struct rtw_phl_stainfo_t *phl_sta_i);
-u8 halbb_set_cmac_antsel_d(struct bb_info *bb, struct rtw_phl_stainfo_t *phl_sta_i);
-u8 halbb_set_cmac_pwr_tol(struct bb_info *bb, struct rtw_phl_stainfo_t *phl_sta_i);
-u8 halbb_set_cmac_databw_er(struct bb_info *bb, struct rtw_phl_stainfo_t *phl_sta_i);
-#if !defined(BB_8730E_SUPPORT) && !defined(BB_8720E_SUPPORT)
-enum rtw_hal_status halbb_config_cmac_tbl(struct bb_info *bb, struct rtw_phl_stainfo_t *phl_sta_i,
-			struct rtw_hal_mac_ax_cctl_info *cctrl,
-			struct rtw_hal_mac_ax_cctl_info *cctl_info_mask);
-#endif
-#endif
diff --git a/os/board/rtl8720e/src/component/wifi/driver/src/hal/phy_g6/bb/halbb_la_mode.h b/os/board/rtl8720e/src/component/wifi/driver/src/hal/phy_g6/bb/halbb_la_mode.h
deleted file mode 100644
index 4558bbeaf..000000000
--- a/os/board/rtl8720e/src/component/wifi/driver/src/hal/phy_g6/bb/halbb_la_mode.h
+++ /dev/null
@@ -1,433 +0,0 @@
-/******************************************************************************
- *
- * Copyright(c) 2007 - 2020  Realtek Corporation.
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of version 2 of the GNU General Public License as
- * published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
- * more details.
- *
- * The full GNU General Public License is included in this distribution in the
- * file called LICENSE.
- *
- * Contact Information:
- * wlanfae <wlanfae@realtek.com>
- * Realtek Corporation, No. 2, Innovation Road II, Hsinchu Science Park,
- * Hsinchu 300, Taiwan.
- *
- * Larry Finger <Larry.Finger@lwfinger.net>
- *
- *****************************************************************************/
-#ifndef __HALBB_LA_MODE_H__
-#define __HALBB_LA_MODE_H__
-
-/*@--------------------------[Define] ---------------------------------------*/
-#define LA_CHK_PTRN_NUM	4
-/*@--------------------------[Enum]------------------------------------------*/
-
-enum la_run_mode_t {
-	LA_RUN_HERITAGE		= 0,
-	LA_RUN_FAST		= 1,
-	LA_RUN_MANUAL		= 2,
-	LA_RUN_RTL_TEST		= 3,
-	LA_RUN_GET_MORE		= 4,
-};
-
-enum la_state_trig_t {
-	LA_AND_DISABLE		= 0,
-	LA_CCK_CCA		= 1,
-	LA_OFDM_CCA		= 2,
-	LA_OFDM_VBON		= 3,
-	LA_RX_STATE		= 4,
-	LA_RX_STATE_FEQ		= 5,
-	LA_RX_TD_STATE		= 6,
-	LA_MUX_STATE		= 7,
-	LA_PHYTXON		= 8,
-	LA_BFMX_NDP_STANDBY	= 9,
-	LA_BFMX_CSI_STANDBY	= 10,
-	LA_CCA_SPOOF		= 11,
-	LA_RXPKT_OK_MX		= 12,
-	LA_RXPKT_FAIL_MX	= 13,
-	LA_BRK			= 14,
-	LA_BRK_SEL		= 15,
-	LA_HE_TB_STANDBY	= 16,
-};
-
-enum la_hdr_sel_t {
-	LA_HDR_ORI		= 0,
-	LA_HDR_CCA		= 1,
-	LA_HDR_CCA_OFDM		= 2,
-	LA_HDR_CCA_CCK		= 3,
-	LA_HDR_AGC_RDY		= 4,
-	LA_HDR_AGC_RDY_HT	= 5,
-	LA_HDR_RXHT		= 6,
-	LA_HDR_RXVHT		= 7,
-	LA_HDR_RXHE_FULLBAND	= 8,
-	LA_HDR_RXHE_OFDMA	= 9,
-	LA_HDR_OFDM_VBON	= 10,
-	LA_HDR_RXPKT_OK_SYNC	= 11,
-	LA_HDR_RDRDY		= 12,
-	LA_HDR_CRC_OK		= 13,
-	LA_HDR_CRC_ERR		= 14
-};
-
-enum la_bb_trig_edge {
-	LA_P_EDGE		= 0,
-	LA_N_EDGE		= 1,
-};
-
-enum la_mac_polling_state {
-	LA_HW_IDLE		= 0,
-	LA_HW_START		= 1,
-	LA_HW_FINISH_STOP	= 2,
-	LA_HW_FINISH_TIMEOUT	= 3,
-	LA_HW_RE_START		= 4
-};
-
-enum la_mode_state_t {
-	LA_STATE_IDLE		= 0,
-	LA_STATE_MAIN		= 1,
-	LA_STATE_GET_DLE_BUF	= 2,
-	LA_STATE_WAIT_RESTART	= 3
-};
-
-enum la_buff_mode_t {
-	LA_BUFF_64K	= 0,
-	LA_BUFF_128K	= 1,
-	LA_BUFF_192K	= 2,
-	LA_BUFF_256K	= 3,
-	LA_BUFF_320K	= 4,
-	LA_BUF_DISABLE	= 0xff
-};
-
-enum la_bb_smp_clk {
-	LA_SMP_CLK_80	= 0,
-	LA_SMP_CLK_40	= 1,
-	LA_SMP_CLK_20	= 2,
-	LA_SMP_CLK_10	= 3,
-	LA_SMP_CLK_5	= 4,
-	LA_SMP_CLK_2_5	= 5,
-	LA_SMP_CLK_1_25	= 6,
-	LA_SMP_CLK_160	= 7
-};
-
-enum la_dma_data_type_t {
-	DMA00_NRML_1s_14b	= 0,
-	DMA01_NRML_2s_12b	= 1, /*Dbgport 16-bit: dbg[N, N-15]*/
-	DMA02_NRML_2s_13b	= 2, /*Dbgport 12-bit: dbg[N, N-11]*/
-	DMA03_NRML_2s_14b	= 3, /*Dbgport 08-bit: dbg[N, N-07]*/
-	DMA04_NRML_3s_08b	= 4,
-	DMA05_NRML_3s_09b	= 5,
-	DMA06_NRML_3s_10b	= 6,
-	DMA07_NRML_4s_07b	= 7,
-	DMA08_NRML_4s_08b	= 8,
-	DMA09_DUAL_4s_12b	= 9,
-	DMA10_DUAL_4s_13b	= 10,
-	DMA11_DUAL_4s_14b	= 11,
-	DMA12_MPHS_1s_2p_12b	= 12,
-	DMA13_MPHS_1s_3p_10b	= 13,
-	DMA14_MPHS_1s_4p_08b	= 14,
-	DMA15_MPHS_2s_2p_08b	= 15,
-	DMA16_DBG_BB_MNTR	= 16,
-	DMA17_DUAL_WB_1s_14b	= 17,
-	DMA18_DUAL_WB_2s_14b	= 18,
-	DMA19_DUAL_WB_3s_14b	= 19,
-	DMA20_DUAL_WB_4s_14b 	= 20,
-	DMA30_DBG_LA_SEL	= 30
-};
-
-enum la_trig_sign_t {
-	LA_UNSIGNED		= 0,
-	LA_SIGNED		= 1,
-	LA_NORM			= 2,
-};
-
-/*@--------------------------[Structure]-------------------------------------*/
-
-struct la_ptrn_chk_info {
-	u32	smp_point;
-	u32	la_ptrn_chk_mask; /*if mask=0: disable pattern chk, for MSB 32bit only*/
-	u32	la_ptrn_chk_val;
-};
-
-struct la_print_info {
-	bool	is_la_print;
-	u8	print_mode; /*0: hex, 1:unsign, 2:sign*/
-	u8	print_lsb;
-	u8	print_msb;
-	u8	print_buff_opt; /*print to 0:Debug Log, 1: CNSL Buff*/
-};
-
-struct la_dma_info {
-	u8 dma_dbgport_base_n;
-	u8 dma_a_path_sel;
-	u8 dma_b_path_sel;
-	u8 dma_c_path_sel;
-	u8 dma_d_path_sel;
-	u8 dma_a_src_sel;
-	u8 dma_b_src_sel;
-	u8 dma_c_src_sel;
-	u8 dma_d_src_sel;
-	enum la_hdr_sel_t dma_hdr_sel_63;
-	enum la_hdr_sel_t dma_hdr_sel_62;
-	enum la_hdr_sel_t dma_hdr_sel_61;
-	enum la_hdr_sel_t dma_hdr_sel_60;
-	bool dma_a_ck160_dly_en;
-	bool dma_b_ck160_dly_en;
-	bool dma_c_ck160_dly_en;
-	bool dma_d_ck160_dly_en;
-	bool dma_dbgport_phy_sel;
-	enum la_dma_data_type_t dma_data_type;
-};
-
-struct la_string_info {
-	u32			*octet;
-	u32			length;
-	u32			buffer_size;	/*Byte*/
-	u32			start_pos;
-	u32			end_pos;	/*buf addr*/
-	u32			smp_number_max; /*number of LA sample*/
-};
-
-struct la_re_trig_info {
-	bool			re_trig_en;
-	u16			re_trig_wait_cnt;
-	/*Re-trig*/
-	bool			la_re_trig_edge;
-	u8			la_re_and0_sel;
-	u8			la_re_and0_val;
-	bool			la_re_and0_inv;
-};
-
-struct la_adv_trig_info { /*AND0~AND7*/
-	bool			adv_trig_en; /*SW ctrl value*/
-	/*AND1*/
-	u32			la_and1_mask; /*sel all 0 = disable*/
-	u32			la_and1_val;
-	bool			la_and1_inv;
-	/*AND2*/
-	bool			la_and2_en;
-	bool			la_and2_inv;
-	u32			la_and2_val;
-	u32			la_and2_mask;
-	enum la_trig_sign_t	la_and2_sign; /*0: unsigned, 1:signed, 2:norm*/
-	/*AND3*/
-	bool			la_and3_en;
-	bool			la_and3_inv;
-	u32			la_and3_val;
-	u32			la_and3_mask;
-	enum la_trig_sign_t	la_and3_sign; /*0: unsigned, 1:signed, 2:norm*/
-	/*AND4*/
-	bool			la_and4_en;
-	u16			la_and4_rate; /*rate_idx*/
-	bool			la_and4_inv;
-	/*AND5*/
-	enum la_state_trig_t	la_and5_sel;
-	bool			la_and5_inv;
-	u8			la_and5_val;
-	/*AND6*/
-	enum la_state_trig_t	la_and6_sel;
-	bool			la_and6_inv;
-	u8			la_and6_val;
-	/*AND7*/
-	enum la_state_trig_t	la_and7_sel;
-	bool			la_and7_inv;
-	u8			la_and7_val;
-};
-
-struct la_trig_mac_info {
-	bool	la_mac_trig_en;  /*sw tag*/
-	bool	la_mac_and0_en;
-	u8	la_mac_and0_sel; /*0~2: cca, crc_er, crc_ok*/
-	u8	la_mac_and0_mac_sel; /*0: true mac, 1: pmac*/
-	bool	la_mac_and1_en;
-	bool	la_mac_and2_en;
-	u8	la_mac_and2_frame_sel; /*6-bit mac hdr*/
-};
-
-struct la_mac_cfg_info {
-	enum la_buff_mode_t mac_la_buf_sel;
-	bool mac_alloc_success;
-	u32 la_trigger_time; /*mu sec*/
-	u8 mac_la_en;
-	u8 mac_la_restart_en;
-	u8 mac_la_timeout_en;
-	u8 mac_la_data_loss_imr;/*Error flag mask bit for LA data loss due to pktbuffer busy */
-	u8 mac_la_timeout_val;	/*0:1s, 1:2s, 2:4s, 3:8s*/
-};
-
-struct bb_la_cr_info {
-	u32 la_clk_en;
-	u32 la_clk_en_m;
-	u32 la_en;
-	u32 la_en_m;
-	u32 dma_dbgport_base_n;
-	u32 dma_dbgport_base_n_m;
-	u32 dma_a_path_sel;
-	u32 dma_a_path_sel_m;
-	u32 dma_b_path_sel;
-	u32 dma_b_path_sel_m;
-	u32 dma_c_path_sel;
-	u32 dma_c_path_sel_m;
-	u32 dma_d_path_sel;
-	u32 dma_d_path_sel_m;
-	u32 dma_a_src_sel;
-	u32 dma_a_src_sel_m;
-	u32 dma_b_src_sel;
-	u32 dma_b_src_sel_m;
-	u32 dma_c_src_sel;
-	u32 dma_c_src_sel_m;
-	u32 dma_d_src_sel;
-	u32 dma_d_src_sel_m;
-	u32 la_smp_rate;
-	u32 la_smp_rate_m;
-	u32 rdrdy_3_phase_en;
-	u32 rdrdy_3_phase_en_m;
-	u32 la_trigger_edge;
-	u32 la_trigger_edge_m;
-	u32 dma_hdr_sel_63;
-	u32 dma_hdr_sel_63_m;
-	u32 dma_hdr_sel_62;
-	u32 dma_hdr_sel_62_m;
-	u32 dma_hdr_sel_61;
-	u32 dma_hdr_sel_61_m;
-	u32 dma_hdr_sel_60;
-	u32 dma_hdr_sel_60_m;
-	u32 dma_a_ck160_dly_en;
-	u32 dma_a_ck160_dly_en_m;
-	u32 dma_b_ck160_dly_en;
-	u32 dma_b_ck160_dly_en_m;
-	u32 dma_dbgport_phy_sel;
-	u32 dma_dbgport_phy_sel_m;
-	u32 dma_data_type;
-	u32 dma_data_type_m;
-	u32 r_dma_rdrdy;
-	u32 r_dma_rdrdy_m;
-	u32 la_and0_bit_sel;
-	u32 la_and0_bit_sel_m;
-	u32 la_trigger_cnt;
-	u32 la_trigger_cnt_m;
-	u32 and0_trig_disable;
-	u32 and0_trig_disable_m;
-	u32 la_and1_inv;
-	u32 la_and1_inv_m;
-	u32 la_and2_en;
-	u32 la_and2_en_m;
-	u32 la_and2_inv;
-	u32 la_and2_inv_m;
-	u32 la_and3_en;
-	u32 la_and3_en_m;
-	u32 la_and3_inv;
-	u32 la_and3_inv_m;
-	u32 la_and4_en;
-	u32 la_and4_en_m;
-	u32 la_and4_rate;
-	u32 la_and4_rate_m;
-	u32 la_and4_inv;
-	u32 la_and4_inv_m;
-	u32 la_and1_mask;
-	u32 la_and1_mask_m;
-	u32 la_and1_val;
-	u32 la_and1_val_m;
-	u32 la_and2_mask;
-	u32 la_and2_mask_m;
-	u32 la_and2_val;
-	u32 la_and2_val_m;
-	u32 la_and3_mask;
-	u32 la_and3_mask_m;
-	u32 la_and3_val;
-	u32 la_and3_val_m;
-	u32 la_and5_sel;
-	u32 la_and5_sel_m;
-	u32 la_and5_val;
-	u32 la_and5_val_m;
-	u32 la_and5_inv;
-	u32 la_and5_inv_m;
-	u32 la_and6_sel;
-	u32 la_and6_sel_m;
-	u32 la_and6_val;
-	u32 la_and6_val_m;
-	u32 la_and6_inv;
-	u32 la_and6_inv_m;
-	u32 la_and7_sel;
-	u32 la_and7_sel_m;
-	u32 la_and7_val;
-	u32 la_and7_val_m;
-	u32 la_and7_inv;
-	u32 la_and7_inv_m;
-	u32 la_brk_sel;
-	u32 la_brk_sel_m;
-	u32 la_mac_and1_en;
-	u32 la_mac_and1_en_m;
-	u32 la_mac_and2_en;
-	u32 la_mac_and2_en_m;
-	u32 la_mac_and2_frame_sel;
-	u32 la_mac_and2_frame_sel_m;
-	u32 la_mac_and0_sel;
-	u32 la_mac_and0_sel_m;
-	u32 la_mac_and0_en;
-	u32 la_mac_and0_en_m;
-	u32 la_mac_and0_mac_sel;
-	u32 la_mac_and0_mac_sel_m;
-	u32 la_and2_sign;
-	u32 la_and2_sign_m;
-	u32 la_and3_sign;
-	u32 la_and3_sign_m;
-	u32 la_re_trig_edge;
-	u32 la_re_trig_edge_m;
-	u32 la_re_and1_sel;
-	u32 la_re_and1_sel_m;
-	u32 la_re_and1_val;
-	u32 la_re_and1_val_m;
-	u32 la_re_and1_inv;
-	u32 la_re_and1_inv_m;
-};
-
-struct bb_la_mode_info {
-	struct bb_la_cr_info	bb_la_cr_i;
-	struct la_string_info	la_string_i;
-	enum la_mode_state_t	la_mode_state;
-	u32			la_dbg_port; /*[31:16]:DBG_IP, [15:0]:DBG_PORT*/
-	u32			la_count; /*curr value*/
-	u32			la_count_max;
-	u32			smp_number;
-	u32			txff_page;
-	bool			not_stop_trig; /*set impossible trigger condition*/
-	u8			la_basic_mode_sel; /*0:bb_mode, mac mode*/
-	/*[General setting]*/
-	u8			la_polling_cnt;
-	u8			la_trigger_cnt;
-	enum la_bb_trig_edge	la_trigger_edge;
-	enum la_bb_smp_clk	la_smp_rate;
-	/*[AND-0 sel]*/
-	bool			la_and0_disable;
-	u32			la_and0_bit_sel; /*And0 trigger bit sel*/
-	struct la_dma_info	la_dma_i;
-	struct la_re_trig_info	la_re_trig_i;
-	struct la_adv_trig_info	adv_trig_i;
-	struct la_trig_mac_info	la_trig_mac_i;
-	struct la_mac_cfg_info	la_mac_cfg_i; /*MAC CR Control*/
-	struct la_print_info	la_print_i;
-	bool la_ptrn_chk_en;
-	struct la_ptrn_chk_info la_ptrn_chk_i[LA_CHK_PTRN_NUM];
-	enum la_run_mode_t 	la_run_mode;
-	struct halbb_timer_info la_timer_i;
-};
-
-struct bb_info;
-/*@--------------------------[Prptotype]-------------------------------------*/
-void halbb_la_re_trig_watchdog(struct bb_info *bb);
-void halbb_la_run(struct bb_info *bb);
-void halbb_la_deinit(struct bb_info *bb);
-void halbb_la_init(struct bb_info *bb);
-void halbb_cr_cfg_la_init(struct bb_info *bb);
-void halbb_la_io_en(struct bb_info *bb);
-void halbb_la_timer_init(struct bb_info *bb);
-void halbb_la_callback(void *context);
-void halbb_la_cmd_dbg(struct bb_info *bb, char input[][16], u32 *_used, char *output,
-		  u32 *_out_len);
-#endif
diff --git a/os/board/rtl8720e/src/component/wifi/driver/src/hal/phy_g6/bb/halbb_la_mode_ex.h b/os/board/rtl8720e/src/component/wifi/driver/src/hal/phy_g6/bb/halbb_la_mode_ex.h
deleted file mode 100644
index c087549ef..000000000
--- a/os/board/rtl8720e/src/component/wifi/driver/src/hal/phy_g6/bb/halbb_la_mode_ex.h
+++ /dev/null
@@ -1,36 +0,0 @@
-/******************************************************************************
- *
- * Copyright(c) 2007 - 2020  Realtek Corporation.
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of version 2 of the GNU General Public License as
- * published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
- * more details.
- *
- * The full GNU General Public License is included in this distribution in the
- * file called LICENSE.
- *
- * Contact Information:
- * wlanfae <wlanfae@realtek.com>
- * Realtek Corporation, No. 2, Innovation Road II, Hsinchu Science Park,
- * Hsinchu 300, Taiwan.
- *
- * Larry Finger <Larry.Finger@lwfinger.net>
- *
- *****************************************************************************/
-#ifndef __HALBB_LA_MODE_EX_H__
-#define __HALBB_LA_MODE_EX_H__
-
-/*@--------------------------[Define] ---------------------------------------*/
-
-/*@--------------------------[Enum]------------------------------------------*/
- 
-/*@--------------------------[Structure]-------------------------------------*/
-
-/*@--------------------------[Prptotype]-------------------------------------*/
-
-#endif
diff --git a/os/board/rtl8720e/src/component/wifi/driver/src/hal/phy_g6/bb/halbb_math_lib.h b/os/board/rtl8720e/src/component/wifi/driver/src/hal/phy_g6/bb/halbb_math_lib.h
deleted file mode 100644
index 722827e26..000000000
--- a/os/board/rtl8720e/src/component/wifi/driver/src/hal/phy_g6/bb/halbb_math_lib.h
+++ /dev/null
@@ -1,123 +0,0 @@
-/******************************************************************************
- *
- * Copyright(c) 2007 - 2020  Realtek Corporation.
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of version 2 of the GNU General Public License as
- * published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
- * more details.
- *
- * The full GNU General Public License is included in this distribution in the
- * file called LICENSE.
- *
- * Contact Information:
- * wlanfae <wlanfae@realtek.com>
- * Realtek Corporation, No. 2, Innovation Road II, Hsinchu Science Park,
- * Hsinchu 300, Taiwan.
- *
- * Larry Finger <Larry.Finger@lwfinger.net>
- *
- *****************************************************************************/
-#ifndef __HALBB_MATH_LIB_H__
-#define __HALBB_MATH_LIB_H__
-
-/*@--------------------------[Define] ---------------------------------------*/
-#define	MASKBYTE0		0xff
-#define	MASKBYTE1		0xff00
-#define	MASKBYTE2		0xff0000
-#define	MASKBYTE3		0xff000000
-#define	MASKHWORD		0xffff0000
-#define	MASKLWORD		0x0000ffff
-#define	MASKDWORD		0xffffffff
-#define RFREGOFFSETMASK		0xfffff
-
-#define KB_2_MB(val) ((val) >> 10)
-
-#define MAX_2(_x_, _y_)	(((_x_) > (_y_)) ? (_x_) : (_y_))
-#define MIN_2(_x_, _y_)	(((_x_) < (_y_)) ? (_x_) : (_y_))
-#define DIFF_2(_x_, _y_)	(((_x_) >= (_y_)) ? ((_x_) - (_y_)) : ((_y_) - (_x_)))
-#define SUBTRACT_TO_0(_x_, _y_)	(((_x_) >= (_y_)) ? ((_x_) - (_y_)) : 0)
-
-#define IS_GREATER(_x_, _y_)	(((_x_) >= (_y_)) ? true : false)
-#define IS_LESS(_x_, _y_)	(((_x_) < (_y_)) ? true : false)
-#define NOT_GREATER(_x_, _y_) (((_x_) > (_y_)) ? (_y_) : (_x_))
-
-
-#define BYTE_DUPLICATE_2_DWORD(B0)	\
-	(((B0) << 24) | ((B0) << 16) | ((B0) << 8) | (B0))
-
-#define BYTE_2_DWORD(B3, B2, B1, B0)	\
-	(((B3) << 24) | ((B2) << 16) | ((B1) << 8) | (B0))
-#define BYTE_2_WORD(B1, B0)	\
-	(((B1) << 8) | (B0))
-#define BIT_2_BYTE(B3, B2, B1, B0)	\
-	(((B3) << 3) | ((B2) << 2) | ((B1) << 1) | (B0))
-
-#define NIBBLE_2_WORD(B3, B2, B1, B0)	\
-	((((B3) & 0xf) << 12) | (((B2) & 0xf) << 8) |\
-	(((B1) & 0xf) << 4) | ((B0) & 0xf))
-
-#define NIBBLE_2_DWORD(B7, B6, B5, B4, B3, B2, B1, B0)	\
-	((((B7) & 0xf) << 28) | (((B6) & 0xf) << 24) | \
-	(((B5) & 0xf) << 20) | (((B4) & 0xf) << 16) | \
-	(((B3) & 0xf) << 12) | (((B2) & 0xf) << 8) | \
-	(((B1) & 0xf) << 4) | ((B0) & 0xf))
-
-#if PLATFOM_IS_LITTLE_ENDIAN
-#define SWAP4BYTE(x) ((u32)(x))
-#else
-#define SWAP4BYTE(x)                                       \
-	((u32)((((u32)(x) & (u32)0x000000ff) << 24) |  \
-	       (((u32)(x) & (u32)0x0000ff00) << 8) |     \
-	       (((u32)(x) & (u32)0x00ff0000) >> 8) |     \
-	       (((u32)(x) & (u32)0xff000000) >> 24)))
-#endif
-
-#define HALBB_DIV(a, b) ((b) ? ((a) / (b)) : 0)
-#define HALBB_DIV_ROUND(a, b) ((b) ? (((a) + (b / 2)) / (b)) : 0)
-#define HALBB_CEIL(a, b) ((b) ? ((a) / (b) + (a > (a / b) * b)) : 0)
-#define ABS_32(X) (((X) & BIT(31)) ? (0 - (X)) : (X))
-#define ABS_16(X) (((X) & BIT(15)) ? (0 - (X)) : (X))
-#define ABS_8(X) (((X) & BIT(7)) ? (0 - (X)) : (X))
-#define DIVIDED_2(X) ((X) >> 1)
-#define DIVIDED_3(X) (((X) + ((X) << 1) + ((X) << 3)) >> 5)
-#define DIVIDED_4(X) ((X) >> 2)
-
-
-#define WEIGHTING_AVG_2(v1, w1, v2, w2) \
-	(((v1) * (w1) + (v2) * (w2)) / ((w2) + (w1)))
-#define MA_ACC(old, new_val, ma, ma_max) ((old) - ((old << (ma_max - ma)) >> (ma_max)) + (new_val << (ma_max - ma)))
-#define GET_MA_VAL(val, ma) (((val) + (1 << ((ma) - 1))) >> (ma))
-
-#define FRAC_BITS 3
-
-
-/*@--------------------------[Enum]------------------------------------------*/
- 
-/*@--------------------------[Structure]-------------------------------------*/
- 
-/*@--------------------------[Prptotype]-------------------------------------*/
-struct bb_info;
-s32 halbb_pwdb_conversion(s32 X, u32 total_bit, u32 decimal_bit);
-s32 halbb_sign_conversion(s32 val, u32 total_bit);
-u8 halbb_find_intrvl(struct bb_info *bb, u16 val, u8 *threshold, u8 len);
-void halbb_seq_sorting(struct bb_info *bb, u32 *val, u32 *idx, u32 *idx_out,
-		       u8 seq_length);
-u16 halbb_show_fraction_num(u32 frac_val, u8 bit_num);
-u16 halbb_ones_num_in_bitmap(u64 val, u8 size);
-u64 halbb_gen_mask_from_0(u8 mask_num);
-u64 halbb_gen_mask(u8 up_num, u8 low_num);
-u32 halbb_cal_bit_shift(u32 bit_mask);
-s32 halbb_cnvrt_2_sign(u32 val, u8 bit_num);
-s64 halbb_cnvrt_2_sign_64(u64 val, u8 bit_num);
-void halbb_print_sign_frac_digit(struct bb_info *bb, u32 val, u8 total_bit_num,
-				 u8 frac_bit_num, char *buf, u16 buf_size);
-char *halbb_print_sign_frac_digit2(struct bb_info *bb, u32 val, u8 total_bit_num,
-				 u8 frac_bit_num);
-void halbb_print_buff_64(struct bb_info *bb, u8 *addr, u16 length);
-void halbb_print_buff_32(struct bb_info *bb, u8 *addr, u16 length);
-#endif
diff --git a/os/board/rtl8720e/src/component/wifi/driver/src/hal/phy_g6/bb/halbb_math_lib_ex.h b/os/board/rtl8720e/src/component/wifi/driver/src/hal/phy_g6/bb/halbb_math_lib_ex.h
deleted file mode 100644
index e31c226cb..000000000
--- a/os/board/rtl8720e/src/component/wifi/driver/src/hal/phy_g6/bb/halbb_math_lib_ex.h
+++ /dev/null
@@ -1,38 +0,0 @@
-/******************************************************************************
- *
- * Copyright(c) 2007 - 2020  Realtek Corporation.
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of version 2 of the GNU General Public License as
- * published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
- * more details.
- *
- * The full GNU General Public License is included in this distribution in the
- * file called LICENSE.
- *
- * Contact Information:
- * wlanfae <wlanfae@realtek.com>
- * Realtek Corporation, No. 2, Innovation Road II, Hsinchu Science Park,
- * Hsinchu 300, Taiwan.
- *
- * Larry Finger <Larry.Finger@lwfinger.net>
- *
- *****************************************************************************/
-#ifndef __HALBB_MATH_LIB_EX_H__
-#define __HALBB_MATH_LIB_EX_H__
-
-/*@--------------------------[Define] ---------------------------------------*/
-
-/*@--------------------------[Enum]------------------------------------------*/
- 
-/*@--------------------------[Structure]-------------------------------------*/
- 
-/*@--------------------------[Prptotype]-------------------------------------*/
-struct bb_info;
-u32 halbb_convert_to_db(u64 val);
-u64 halbb_db_2_linear(u32 val);
-#endif
diff --git a/os/board/rtl8720e/src/component/wifi/driver/src/hal/phy_g6/bb/halbb_mp_ex.h b/os/board/rtl8720e/src/component/wifi/driver/src/hal/phy_g6/bb/halbb_mp_ex.h
deleted file mode 100644
index fb89d9483..000000000
--- a/os/board/rtl8720e/src/component/wifi/driver/src/hal/phy_g6/bb/halbb_mp_ex.h
+++ /dev/null
@@ -1,222 +0,0 @@
-/******************************************************************************
- *
- * Copyright(c) 2007 - 2020  Realtek Corporation.
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of version 2 of the GNU General Public License as
- * published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
- * more details.
- *
- * The full GNU General Public License is included in this distribution in the
- * file called LICENSE.
- *
- * Contact Information:
- * wlanfae <wlanfae@realtek.com>
- * Realtek Corporation, No. 2, Innovation Road II, Hsinchu Science Park,
- * Hsinchu 300, Taiwan.
- *
- * Larry Finger <Larry.Finger@lwfinger.net>
- *
- *****************************************************************************/
-#ifndef __HALBB_MP_EX_H__
-#define __HALBB_MP_EX_H__
-
-/*@--------------------------[Define] ---------------------------------------*/
-#define MAX_USER_NUM 4
-
-/*@--------------------------[Enum]------------------------------------------*/
- 
-/*@--------------------------[Structure]-------------------------------------*/
-struct bb_rpt_cr_info {
-	u32 cnt_ccktxon;
-	u32 cnt_ccktxon_m;
-	u32 cnt_ofdmtxon;
-	u32 cnt_ofdmtxon_m;
-	u32 cnt_cck_crc32ok_p0;	
-	u32 cnt_cck_crc32ok_p0_m;	
-	u32 cnt_cck_crc32ok_p1;		
-	u32 cnt_cck_crc32ok_p1_m;	
-	u32 cnt_l_crc_ok;		
-	u32 cnt_l_crc_ok_m;		
-	u32 cnt_ht_crc_ok;		
-	u32 cnt_ht_crc_ok_m; 
-	u32 cnt_vht_crc_ok;		
-	u32 cnt_vht_crc_ok_m;	
-	u32 cnt_he_crc_ok;		
-	u32 cnt_he_crc_ok_m; 
-	u32 cnt_cck_crc32fail_p0;	
-	u32 cnt_cck_crc32fail_p0_m;	
-	u32 cnt_cck_crc32fail_p1;	
-	u32 cnt_cck_crc32fail_p1_m;
-	u32 cnt_l_crc_err;	
-	u32 cnt_l_crc_err_m;
-	u32 cnt_ht_crc_err;	
-	u32 cnt_ht_crc_err_m;
-	u32 cnt_vht_crc_err;
-	u32 cnt_vht_crc_err_m;
-	u32 cnt_he_crc_err;
-	u32 cnt_he_crc_err_m;
-	u32 rst_all_cnt; 
-	u32 rst_all_cnt_m;	
-	u32 phy_sts_bitmap_he_mu;	
-	u32 phy_sts_bitmap_he_mu_m;	
-	u32 phy_sts_bitmap_vht_mu;	
-	u32 phy_sts_bitmap_vht_mu_m;
-	u32 phy_sts_bitmap_cck;		
-	u32 phy_sts_bitmap_cck_m;	
-	u32 phy_sts_bitmap_legacy;	
-	u32 phy_sts_bitmap_legacy_m;
-	u32 phy_sts_bitmap_ht;		
-	u32 phy_sts_bitmap_ht_m; 
-	u32 phy_sts_bitmap_vht;		
-	u32 phy_sts_bitmap_vht_m;	
-	u32 phy_sts_bitmap_he;		
-	u32 phy_sts_bitmap_he_m; 
-	u32 rpt_tone_evm_idx;		
-	u32 rpt_tone_evm_idx_m;		
-	u32 dbg_port_ref_clk_en; 
-	u32 dbg_port_ref_clk_en_m;	
-	u32 dbg_port_en; 		
-	u32 dbg_port_en_m;			
-	u32 dbg_port_ip_sel; 	
-	u32 dbg_port_ip_sel_m;		
-	u32 dbg_port_sel;			
-	u32 dbg_port_sel_m;			
-	u32 dbg32_d;			
-	u32 dbg32_d_m;				
-	u32 phy_sts_bitmap_trigbase;
-	u32 phy_sts_bitmap_trigbase_m;
-	u32 sts_keeper_en;			
-	u32 sts_keeper_en_m; 	
-	u32 sts_keeper_trig_cond;	
-	u32 sts_keeper_trig_cond_m;
-	u32 sts_dbg_sel; 		
-	u32 sts_dbg_sel_m;			
-	u32 sts_keeper_read;	
-	u32 sts_keeper_read_m;		
-	u32 sts_keeper_addr; 	
-	u32 sts_keeper_addr_m;		
-	u32 sts_keeper_data; 	
-	u32 sts_keeper_data_m;		
-	u32 pw_dbm_rx0;
-	u32 pw_dbm_rx0_m;
-	u32 path0_rssi_at_agc_rdy;
-	u32 path0_rssi_at_agc_rdy_m;
-	u32 path1_rssi_at_agc_rdy;
-	u32 path1_rssi_at_agc_rdy_m;
-	u32 sts_user_sel;
-	u32 sts_user_sel_m;
-};
-
-struct bb_rpt_info {
-	struct bb_rpt_cr_info bb_rpt_cr_i;
-};
-
-struct rxevm_usr {
-	u8 rxevm_ss_0;
-	u8 rxevm_ss_1;
-	u8 rxevm_ss_2;
-	u8 rxevm_ss_3;
-};
-
-struct rxevm_info {
-	struct rxevm_usr rxevm_user[MAX_USER_NUM];
-};
-
-struct rxevm_physts {
-	// Seg0/1
-	struct rxevm_info rxevm_seg[2];
-};
-
-struct rssi_i {
-	s32 rssi[4];
-};
-
-struct rssi_physts {
-	// Seg0/1
-	struct rssi_i rssi_seg[2];
-};
-
-struct mp_physts_rslt_0 {
-	u8 rx_path_en_cck;
-	u8 cfo_avg_cck;
-	u8 evm_avg_cck;
-	u8 avg_idle_noise_pwr_cck;
-	u8 pop_idx_cck;
-};
-
-struct mp_physts_rslt_1 {
-	u8 rx_path_en;
-	s16 cfo_avg; /*S(12,2), -512~+511.75 kHz*/
-	u8 evm_max;
-	u8 evm_min;
-	u8 snr_avg;
-	u8 cn_avg;
-	u8 avg_idle_noise_pwr;
-	u8 pop_idx;
-	u8 rxsc;
-	u8 ch_idx;
-	enum channel_width bw_idx;
-	bool is_su; /*if (not MU && not OFDMA), is_su = 1*/
-	bool is_ldpc;
-	bool is_ndp;
-	bool is_stbc;
-	bool grant_bt;
-	bool is_awgn;
-	bool is_bf;
-};
-
-struct mp_physts_rslt_basic {
-	struct mp_physts_rslt_0		mp_physts_rslt_basic_0_i;
-	struct mp_physts_rslt_1		mp_physts_rslt_basic_1_i;
-
-};
-
-
-struct bb_mp_psts {
-	u32 ie_bitmap;
-	struct mp_physts_rslt_basic	mp_physts_rslt_basic_i;
-	struct mp_physts_rslt_0		mp_physts_rslt_0_i;
-	struct mp_physts_rslt_1		mp_physts_rslt_1_i;
-};
-
-
-
-struct halbb_mp {
-	/*Tx ok count, statistics used in Mass Production Test.*/
-	u64 tx_phy_ok_cnt;
-	/*Rx CRC32 ok/error count, statistics used in Mass Production Test.*/
-	u64 rx_phy_crc_ok_cnt;
-	u64 rx_phy_crc_err_cnt;
-	/*The Value of IO operation is depend of MptActType.*/
-	u32 io_ok_value;
-	u32 io_err_value;
-};
-
-/*@--------------------------[Prptotype]-------------------------------------*/
-u16 halbb_mp_get_tx_ok(struct bb_info *bb, u32 rate_index,
-			enum phl_phy_idx phy_idx);
-u32 halbb_mp_get_rx_crc_ok(struct bb_info *bb, enum phl_phy_idx phy_idx);
-u32 halbb_mp_get_rx_crc_err(struct bb_info *bb, enum phl_phy_idx phy_idx);
-void halbb_mp_cnt_reset(struct bb_info *bb);
-void halbb_mp_reset_cnt(struct bb_info *bb);
-u8 halbb_mp_get_rxevm(struct bb_info *bb, u8 user, u8 strm, bool rxevm_table);
-struct rxevm_physts halbb_mp_get_rxevm_physts(struct bb_info *bb,
-					      enum phl_phy_idx phy_idx);
-//u16 halbb_mp_get_pwdb_diff(struct bb_info *bb, enum rf_path path);
-u8 halbb_mp_get_rssi(struct bb_info *bb, enum rf_path path);
-struct rssi_physts halbb_get_mp_rssi_physts(struct bb_info *bb, enum rf_path path, enum phl_phy_idx phy_idx);
-void halbb_mp_get_psts(struct bb_info *bb , struct bb_mp_psts *bb_mp_physts);
-void halbb_cvrt_2_mp(struct bb_info *bb);
-u16 halbb_mp_get_rpl(struct bb_info *bb, enum rf_path path, enum phl_phy_idx phy_idx);
-u32 halbb_mp_get_dc_lvl(struct bb_info *bb, enum rf_path path, bool i_ch, enum phl_phy_idx phy_idx);
-u16 halbb_mp_get_pwdbm(struct bb_info *bb, enum rf_path path, enum phl_phy_idx phy_idx);
-u16 halbb_mp_get_cfo(struct bb_info *bb, enum phl_phy_idx phy_idx);
-void halbb_mp_dbg(struct bb_info *bb, char input[][16], u32 *_used,
-		  char *output, u32 *_out_len);
-void halbb_cr_cfg_mp_init(struct bb_info *bb);
-#endif
diff --git a/os/board/rtl8720e/src/component/wifi/driver/src/hal/phy_g6/bb/halbb_path_div.h b/os/board/rtl8720e/src/component/wifi/driver/src/hal/phy_g6/bb/halbb_path_div.h
deleted file mode 100644
index 8b123e55f..000000000
--- a/os/board/rtl8720e/src/component/wifi/driver/src/hal/phy_g6/bb/halbb_path_div.h
+++ /dev/null
@@ -1,68 +0,0 @@
-/******************************************************************************
- *
- * Copyright(c) 2007 - 2020  Realtek Corporation.
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of version 2 of the GNU General Public License as
- * published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
- * more details.
- *
- * The full GNU General Public License is included in this distribution in the
- * file called LICENSE.
- *
- * Contact Information:
- * wlanfae <wlanfae@realtek.com>
- * Realtek Corporation, No. 2, Innovation Road II, Hsinchu Science Park,
- * Hsinchu 300, Taiwan.
- *
- * Larry Finger <Larry.Finger@lwfinger.net>
- *
- *****************************************************************************/
-#ifndef __HALBB_PATH_DIV_H__
-#define __HALBB_PATH_DIV_H__
-
-/*@--------------------------[Define] ---------------------------------------*/
-//#define	PATH_DIV_RSSI_GAP	4 /*@ 2dB*/
-
-/*@--------------------------[Structure]-------------------------------------*/
-
-struct bb_pathdiv_rssi_info { /*all in U(8,1)*/
-	/*acc value*/
-	u32 path_a_rssi_sum[PHL_MAX_STA_NUM];
-	u32 path_b_rssi_sum[PHL_MAX_STA_NUM];
-	u16 path_a_pkt_cnt[PHL_MAX_STA_NUM];
-	u16 path_b_pkt_cnt[PHL_MAX_STA_NUM];
-};
-
-//struct bb_pathdiv_cr_info {
-//};
-
-struct bb_pathdiv_info {
-	//struct bb_pathdiv_cr_info bb_pathdiv_cr_i;
-	/* For RSSI */
-	struct bb_pathdiv_rssi_info bb_rssi_i;
-	bool fix_path_en[PHL_MAX_STA_NUM]; /*@ debug mode*/
-	enum bb_path path_sel[PHL_MAX_STA_NUM];
-	enum bb_path fix_path_sel[PHL_MAX_STA_NUM];/*@ debug mode*/
-	u8 path_rssi_gap;
-};
-
-struct bb_info;
-/*@--------------------------[Prptotype]-------------------------------------*/
-void halbb_cr_cfg_pathdiv_init(struct bb_info *bb);
-void halbb_pathdiv_reg_init(struct bb_info *bb);
-void halbb_pathdiv_init(struct bb_info *bb);
-void halbb_pathdiv_reset(struct bb_info *bb);
-void halbb_pathdiv_reset_stat(struct bb_info *bb);
-void halbb_set_cctrl_tbl(struct bb_info *bb, u8 macid, u16 cfg);
-void halbb_set_tx_path_by_cmac_tbl(struct bb_info *bb, u8 macid, enum bb_path tx_path_sel_1ss);
-void halbb_path_diversity(struct bb_info *bb);
-void halbb_pathdiv_phy_sts(struct bb_info *bb, struct physts_rxd *desc);
-void halbb_pathdiv_dbg(struct bb_info *bb, char input[][16], u32 *_used,
-			      char *output, u32 *_out_len);
-#endif
-
diff --git a/os/board/rtl8720e/src/component/wifi/driver/src/hal/phy_g6/bb/halbb_physts.h b/os/board/rtl8720e/src/component/wifi/driver/src/hal/phy_g6/bb/halbb_physts.h
deleted file mode 100644
index 9a5c8aefd..000000000
--- a/os/board/rtl8720e/src/component/wifi/driver/src/hal/phy_g6/bb/halbb_physts.h
+++ /dev/null
@@ -1,764 +0,0 @@
-/******************************************************************************
- *
- * Copyright(c) 2007 - 2020  Realtek Corporation.
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of version 2 of the GNU General Public License as
- * published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
- * more details.
- *
- * The full GNU General Public License is included in this distribution in the
- * file called LICENSE.
- *
- * Contact Information:
- * wlanfae <wlanfae@realtek.com>
- * Realtek Corporation, No. 2, Innovation Road II, Hsinchu Science Park,
- * Hsinchu 300, Taiwan.
- *
- * Larry Finger <Larry.Finger@lwfinger.net>
- *
- *****************************************************************************/
-#ifndef __HALBB_PHYSTS_H__
-#define __HALBB_PHYSTS_H__
-
-#define VAR_LENGTH 0xff
-#define TRANS_2_RSSI(X) (X >> 1)
-#define PHYSTS_HDR_LEN	8
-#define TB_USER_MAX	4
-#define MU_USER_MAX	4
-#define PSTS_USR(x,y)	psts_##x_usr_##y
-
-#define IE11_PKT_INFO_LEN 10
-
-enum bb_physts_bw_info{
-	PSTS_BW5 	= 0,
-	PSTS_BW10 	= 1,
-	PSTS_BW20 	= 2,
-	PSTS_BW40 	= 3,
-	PSTS_BW80 	= 4,
-	PSTS_BW160 	= 5,
-	PSTS_BW80_80	= 6,
-	PSTS_BW_MAX
-};
-
-enum bb_physts_ie_t {
-	IE00_CMN_CCK			= 0,
-	IE01_CMN_OFDM			= 1,
-	IE02_CMN_EXT_AX			= 2,
-	IE03_CMN_EXT_SEG_1		= 3,
-	IE04_CMN_EXT_PATH_A		= 4,
-	IE05_CMN_EXT_PATH_B		= 5,
-	IE06_CMN_EXT_PATH_C		= 6,
-	IE07_CMN_EXT_PATH_D		= 7,
-	IE08_FTR_CH			= 8,
-	IE09_FTR_PLCP_0			= 9,
-	IE10_FTR_PLCP_EXT		= 10,
-	IE11_FTR_PLCP_HISTOGRAM		= 11,
-	IE12_MU_EIGEN_INFO		= 12,
-	IE13_DL_MU_DEF			= 13,
-	IE14_TB_UL_CQI			= 14,
-	IE15_TB_UL_DEF			= 15,
-	IE16_RSVD16			= 16,
-	IE17_TB_UL_CTRL			= 17,
-	IE18_DBG_OFDM_FD_CMN		= 18,
-	IE19_DBG_OFDM_TD_CMN		= 19,
-	IE20_DBG_OFDM_FD_USER_SEG_0	= 20,
-	IE21_DBG_OFDM_FD_USER_SEG_1	= 21,
-	IE22_DBG_OFDM_FD_USER_AGC	= 22,
-	IE23_RSVD23			= 23,
-	IE24_DBG_OFDM_TD_PATH_A		= 24,
-	IE25_DBG_OFDM_TD_PATH_B		= 25,
-	IE26_DBG_OFDM_TD_PATH_C		= 26,
-	IE27_DBG_OFDM_TD_PATH_D		= 27,
-	IE28_DBG_CCK_PATH_A		= 28,
-	IE29_DBG_CCK_PATH_B		= 29,
-	IE30_DBG_CCK_PATH_C		= 30,
-	IE31_DBG_CCK_PATH_D		= 31,
-	IE_PHYSTS_LEN_ALL		= 32
-};
-
-struct bb_info;
-
-static const char bb_physts_bitmap_type_t[][10] = {
-	"SRH_FAIL",
-	"BRK_BY_TX",
-	"CCA_SPF",
-	"OFDM_BRK",
-	"CCK_BRK",
-	"DLMU_SPF",
-	"HE_MU",
-	"VHT_MU",
-	"TB_SPF",
-	"N/A",
-	"TB",
-	"CCK",
-	"LEGACY",
-	"HT",
-	"VHT",
-	"HE",
-};
-
-struct bb_physts_rslt_hdr_info {
-	u8 rssi[4];
-	u8 rssi_td[4];
-	u8 rssi_avg;
-	enum bb_physts_bitmap_t ie_map_type;
-};
-
-struct bb_physts_rslt_0_info {
-	u8 *ie_00_addr;
-	u8 rx_path_en_cck;
-	s16 cfo_avg_cck; /*S(12,2), -512~+511.75 kHz*/
-	u8 evm_avg_cck;
-	u8 avg_idle_noise_pwr_cck; /*u(8,1)*/
-	u8 pop_idx_cck;
-	u16 rpl; /*U(9,2)*/
-};
-
-struct bb_physts_rslt_1_info {
-	u8 *ie_01_addr;
-	u8 rx_path_en;
-	s16 cfo_avg; /*S(12,2), -512~+511.75 kHz, FD tracking CFO*/
-	s16 cfo_pab_avg; /*S(12,2), -512~+511.75 kHz, preamble CFO*/
-	u8 evm_max;
-	u8 evm_min;
-	u8 snr_avg;
-	u8 cn_avg;
-	u8 avg_idle_noise_pwr; /*u(8,1)*/
-	u8 pop_idx;
-	u8 rxsc;
-	u8 ch_idx;
-	u8 rpl_fd; /*u(8,1)*/
-	enum channel_width bw_idx;
-	bool is_su; /*if (not MU && not OFDMA), is_su = 1*/
-	bool is_ldpc;
-	bool is_ndp;
-	bool is_stbc;
-	bool grant_bt;
-	bool is_awgn;
-	bool is_bf;
-};
-
-struct bb_physts_rslt_2_info {
-	u8 *ie_02_addr;
-	u8 max_nsts;
-	u8 ltf_type;
-	u8 gi;
-	s32 c_cfo_i;
-	u8 rx_info_1;
-	u8 rx_state_feq;
-	s32 c_cfo_q;
-	u8 est_cmped_phase;
-	u8 pkt_extension;
-	s32 f_cfo_i;
-	u8 n_ltf;
-	u16 n_sym;
-	s32 f_cfo_q;
-	bool midamble;
-	bool is_mu_mimo;
-	bool is_dl_ofdma;
-	bool is_dcm;
-	bool is_doppler;
-};
-
-struct bb_physts_rslt_3_info {
-	u8 *ie_03_addr;
-	u8 avg_cn_seg1;
-	u8 sigval_below_th_tone_cnt_seg1;
-	u8 cn_excess_th_tone_cnt_seg1;
-	u16 avg_cfo_seg1;
-	u16 avg_cfo_premb_seg1;
-	u8 est_cmped_phase_seg1;
-	u8 avg_snr_seg1;
-	u32 c_cfo_i_seg1;
-	u32 c_cfo_q_seg1;
-	u32 f_cfo_i_seg1;
-	u32 f_cfo_q_seg1;
-	u8 ch_idx_seg1;
-	u8 evm_max_seg1;
-	u8 evm_min_seg1;
-};
-
-struct bb_physts_rslt_4_to_7_info {
-	u8 *ie_04_07_addr;
-	u8 ant_idx;
-	s8 sig_val_y;
-	u8 rf_gain_idx;
-	u8 snr_lgy;
-	u8 evm_ss_y;
-	u8 td_ant_weight;
-	s8 dc_est_re;
-	s8 dc_est_im;
-	bool rf_tia_gain_idx;
-	bool tia_shrink_indicator;
-	//bool ant_idx_0_msb;
-};
-
-struct bb_physts_rslt_8_info {
-	u8 *ie_08_addr;
-	u8 rxsc;
-	u8 n_rx;
-	u8 n_sts;
-	u16 ch_info_len;
-	u8 evm_1_sts;
-	u8 evm_2_sts;
-	u8 avg_idle_noise_pwr;
-	bool is_ch_info_len_valid;
-	s16 *ch_info_addr;
-};
-
-struct bb_physts_rslt_9_info {
-	u8 *ie_09_addr;
-	u32 l_sig;
-	u32 sig_a1;
-	u16 sig_a2;
-};
-
-struct bb_physts_rslt_10_info {
-	u8 *ie_10_addr;
-	u8 tmp;
-};
-
-struct bb_physts_rslt_11_info {
-	u8 *ie_11_addr;
-	u32 l_sig;
-	u32 sig_a1;
-	u16 sig_a2;
-	u16 time_stamp;
-	u8 rx_pkt_info_idx;
-	u8 tx_pkt_info_idx;
-};
-
-struct bb_physts_user_info_ie_12{
-	u8 sig_val_ss0_seg_cr_user_i;
-	u8 sig_val_ss1_seg_cr_user_i;
-	u8 sig_val_ss2_seg_cr_user_i;
-	u8 sig_val_ss3_seg_cr_user_i;
-	u8 sig_bad_tone_cnt_seg_cr_user_i;
-	u8 cn_bad_tone_cnt_seg_cr_user_i;
-};
-
-struct bb_physts_rslt_12_info {
-	u8 *ie_12_addr;
-	u8 n_user;
-	struct bb_physts_user_info_ie_12 bb_physts_uer_info[MU_USER_MAX];
-};
-
-struct bb_physts_user_info_ie_13{
-	u8 is_bf;
-	u8 fec_type;
-	u8 mcs;
-	u8 pilot_exist;
-	u8 n_sts;
-	u8 n_sts_ru_total;
-	u8 is_awgn;
-	u8 is_mu_mimo;
-	u8 pdp_he_ltf_and_gi_type;
-	u8 start_sts;
-	u8 rx_evm_max_seg_cr;
-	u8 rx_evm_min_seg_cr;
-	s8 snr;
-	u8 ru_alloc;
-	u8 is_dcm;
-	u8 avg_cn_seg_cr;
-	u16 sta_id;
-};
-
-struct bb_physts_rslt_13_info {
-	u8 *ie_13_addr;
-	u8 n_user;
-	struct bb_physts_user_info_ie_13 bb_physts_uer_info[MU_USER_MAX];
-	u8 n_not_sup_sta;
-};
-
-struct bb_physts_user_info_ie_14{
-	u8 cqi_bitmap_ul_tb;
-	u8 cqi_raw_len_ul_tb;
-	u8 *cqi_raw_ul_tb_addr;
-};
-
-struct bb_physts_rslt_14_info {
-	u8 *ie_14_addr;
-	u8 rxinfo_ndp_en;
-	u8 n_user;
-	struct bb_physts_user_info_ie_14 bb_physts_uer_info[MU_USER_MAX];
-	
-};
-
-struct bb_physts_user_info_ie_15{
-	/* 64bit cmn_info */
-	u8 mcs;
-	u8 fec_type;
-	u8 is_bf;
-	
-	u8 n_sts_ru_total;
-	u8 n_sts;
-	u8 pilot_exist;
-
-	u8 start_sts;
-	u8 pdp_he_ltf_and_gi_type;
-	u8 is_mu_mimo;
-	u8 is_awgn;
-
-	u8 rx_evm_max_seg_cr;
-	u8 rx_evm_min_seg_cr;
-	s8 snr;
-	u8 ru_alloc;
-
-	u8 avg_cn_seg_cr;
-	u8 is_dcm;
-
-	/* others */
-	u8 uid;
-	s16 avg_cfo_seg0;
-	u16 rssi_m_ul_tb;
-};
-
-struct bb_physts_rslt_15_info {
-	u8 *ie_15_addr;
-	u8 n_user;
-	struct bb_physts_user_info_ie_15 bb_physts_uer_info[MU_USER_MAX];
-	
-};
-
-struct bb_physts_rslt_16_info {
-	u8 *ie_16_addr;
-	u8 tmp;
-};
-
-struct bb_physts_cmn_info_ie_17 {
-	bool stbc_en;
-	bool ldpc_extra;
-	bool doppler_en;
-	bool midamle_mode;
-	u8 gi_type;
-	u8 ltf_type;
-	u8 n_ltf;
-	u8 n_sym;
-	u8 pe_idx;
-	u8 pre_fec_factor;
-	u8 n_usr;
-	bool mumimo_ltf_mode_en;
-	bool ndp;
-	u8 pri_exp_rssi_dbm;
-	u8 dbw_idx;
-	
-	u8 rsvd;
-		
-	u16 rxtime;
-};
-
-struct bb_physts_user_info_ie_17 {
-	u8 u_id;	
-	u8 ru_alloc;
-	u8 n_sts_ru_tot;
-
-	u8 rsvd1;
-
-	u8 strt_sts;
-	u8 n_sts;
-	bool fec_type;
-	u8 mcs;
-
-	u8 rsvd2;
-
-	bool dcm_en;
-	
-	u8 rsvd3;
-};
-
-struct bb_physts_rslt_17_info {
-	u8 *ie_17_addr;
-	u8 n_user;
-	struct bb_physts_cmn_info_ie_17 bb_physts_cmn_info;
-	struct bb_physts_user_info_ie_17 bb_physts_uer_info[MU_USER_MAX];
-};
-
-struct bb_physts_rslt_18_info {
-	u8 *ie_18_addr;
-	u16 rx_time;
-	u8 ch_len_lgcy_seg0;
-	u8 bw_det_seg0;
-	u8 snr_idx_lgcy_seg0;
-	u8 pdp_idx_lgcy_seg0;
-	u16 pfd_flow;
-	u8 ch_len_lgcy_seg1;
-	u8 bw_det_seg1;
-	u8 snr_idx_lgcy_seg1;
-	u8 pdp_idx_lgcy_seg1;
-	bool is_seg1_exist;
-};
-
-struct bb_physts_rslt_19_info {
-	u8 *ie_19_addr;
-	u8 ppdu_inpwrdbm_p20;
-	u8 ppdu_inpwrdbm_s20;
-	u8 ppdu_inpwrdbm_s40;
-	u8 ppdu_inpwrdbm_s80;
-	u8 ppdu_inpwrdbm_per20_1;
-	u8 ppdu_inpwrdbm_per20_2;
-	u8 ppdu_inpwrdbm_per20_3;
-	u8 ppdu_inpwrdbm_per20_4;
-	u8 edcca_rpt_cnt_p20;
-	u8 edcca_rpt_p20_max;
-	u8 edcca_rpt_p20_min;
-	u8 edcca_total_smp_cnt;
-	u8 edcca_rpt_cnt_s80;
-	u8 edcca_rpt_cnt_s80_max;
-	u8 edcca_rpt_cnt_s80_min;
-	u8 pop_reg_pwr;
-	u8 pop_trig_pwr;
-	u8 early_drop_pwr;
-	bool tx_over_flow;
-};
-
-struct bb_physts_user_info_20 {
-	u8 ch_smo_n_block_lgcy_sub_0_seg_0;
-	u8 ch_smo_n_block_lgcy_sub_1_seg_0;
-	u8 ch_smo_n_block_lgcy_sub_2_seg_0;
-	u8 ch_smo_n_block_lgcy_sub_3_seg_0;
-
-	u8 ch_smo_en_lgcy_seg_0;
-	u8 ch_smo_en_non_lgcy_seg_0;
-
-	u8 ch_smo_n_block_non_lgcy_seg_0;
-
-	u8 ch_len_non_lgcy_sts_0_seg_0;
-	u8 ch_len_non_lgcy_sts_1_seg_0;
-	u8 ch_len_non_lgcy_sts_2_seg_0;
-	u8 ch_len_non_lgcy_sts_3_seg_0;
-
-	u8 snr_idx_non_lgy_sts_0_seg_0;
-	u8 snr_idx_non_lgy_sts_1_seg_0;
-	u8 snr_idx_non_lgy_sts_2_seg_0;
-	u8 snr_idx_non_lgy_sts_3_seg_0;
-	u8 pdp_idx_non_lgcy_sts_0_seg_0;
-	u8 pdp_idx_non_lgcy_sts_1_seg_0;
-	u8 pdp_idx_non_lgcy_sts_2_seg_0;
-	u8 pdp_idx_non_lgcy_sts_3_seg_0;
-
-	u8 snr_non_lgy_sts_0_seg_0;
-	u8 snr_non_lgy_sts_1_seg_0;
-	u8 snr_non_lgy_sts_2_seg_0;
-	u8 snr_non_lgy_sts_3_seg_0;
-	u8 evm_ss_0_seg_0;
-	u8 evm_ss_1_seg_0;
-	u8 evm_ss_2_seg_0;
-	u8 evm_ss_3_seg_0;
-};
-
-
-struct bb_physts_rslt_20_info {
-	u8 *ie_20_addr;
-	u8 n_user;
-	struct bb_physts_user_info_20 bb_physts_usr_info[MU_USER_MAX];
-};
-
-struct bb_physts_user_info_21 {
-	u8 ch_smo_n_block_lgcy_sub_0_seg_1;
-	u8 ch_smo_n_block_lgcy_sub_1_seg_1;
-	u8 ch_smo_n_block_lgcy_sub_2_seg_1;
-	u8 ch_smo_n_block_lgcy_sub_3_seg_1;
-
-	u8 ch_smo_en_lgcy_seg_1;
-	u8 ch_smo_en_non_lgcy_seg_1;
-
-	u8 ch_smo_n_block_non_lgcy_seg_1;
-
-	u8 ch_len_non_lgcy_sts_0_seg_1;
-	u8 ch_len_non_lgcy_sts_1_seg_1;
-	u8 ch_len_non_lgcy_sts_2_seg_1;
-	u8 ch_len_non_lgcy_sts_3_seg_1;
-
-	u8 snr_idx_non_lgy_sts_0_seg_1;
-	u8 snr_idx_non_lgy_sts_1_seg_1;
-	u8 snr_idx_non_lgy_sts_2_seg_1;
-	u8 snr_idx_non_lgy_sts_3_seg_1;
-	u8 pdp_idx_non_lgcy_sts_0_seg_1;
-	u8 pdp_idx_non_lgcy_sts_1_seg_1;
-	u8 pdp_idx_non_lgcy_sts_2_seg_1;
-	u8 pdp_idx_non_lgcy_sts_3_seg_1;
-
-	u8 snr_non_lgy_sts_0_seg_1;
-	u8 snr_non_lgy_sts_1_seg_1;
-	u8 snr_non_lgy_sts_2_seg_1;
-	u8 snr_non_lgy_sts_3_seg_1;
-	u8 evm_ss_0_seg_1;
-	u8 evm_ss_1_seg_1;
-	u8 evm_ss_2_seg_1;
-	u8 evm_ss_3_seg_1;
-};
-
-struct bb_physts_rslt_21_info {
-	u8 *ie_21_addr;
-	u8 n_user;
-	struct bb_physts_user_info_21 bb_physts_usr_info[MU_USER_MAX];
-};
-
-struct bb_physts_rslt_22_info {
-	u8 *ie_22_addr;
-	u8 tmp;
-};
-
-struct bb_physts_rslt_23_info {
-	u8 *ie_23_addr;
-	u8 tmp;
-};
-
-struct bb_physts_rslt_24_info {
-	u8 *ie_24_addr;
-	u8 pre_agc_step_a;
-	u8 l_fine_agc_step_a;
-	u8 ht_fine_agc_step_a;
-	u8 pre_gain_code_a;
-	u8 l_fine_gain_code_a;
-	u8 ht_fine_gain_code_a;
-	u8 l_dagc_a;
-	u8 ht_dagc_a;
-	u8 pre_ibpwrdbm_a;
-	u8 pre_wbpwrdbm_a;
-	u8 l_ibpwrdbm_a;
-	u8 l_wbpwrdbm_a;
-	u8 ht_ibpwrdbm_a;
-	u8 ht_wbpwrdbm_a;
-	u8 l_dig_ibpwrdbm_a;
-	u8 ht_dig_ibpwrdbm_a;
-	u8 lna_inpwrdbm_a;
-	u8 aci2sig_db;
-	u8 sb5m_ratio_0;
-	u8 sb5m_ratio_1;
-	u8 sb5m_ratio_2;
-	u8 sb5m_ratio_3;
-	bool aci_indicator_a;
-	bool tia_shrink_indicator_a;
-	bool pre_gain_code_tia_a;
-	bool l_fine_gain_code_tia_a;
-	bool ht_fine_gain_code_tia_a;
-	bool aci_det;
-	u8 physts_aci_idx;
-
-};
-
-struct bb_physts_rslt_25_info {
-	u8 *ie_25_addr;
-	u8 pre_agc_step_b;
-	u8 l_fine_agc_step_b;
-	u8 ht_fine_agc_step_b;
-	u8 pre_gain_code_b;
-	u8 l_fine_gain_code_b;
-	u8 ht_fine_gain_code_b;
-	u8 l_dagc_b;
-	u8 ht_dagc_b;
-	u8 pre_ibpwrdbm_b;
-	u8 pre_wbpwrdbm_b;
-	u8 l_ibpwrdbm_b;
-	u8 l_wbpwrdbm_b;
-	u8 ht_ibpwrdbm_b;
-	u8 ht_wbpwrdbm_b;
-	u8 l_dig_ibpwrdbm_b;
-	u8 ht_dig_ibpwrdbm_b;
-	u8 lna_inpwrdbm_b;
-	u8 aci2sig_db;
-	u8 sb5m_ratio_0;
-	u8 sb5m_ratio_1;
-	u8 sb5m_ratio_2;
-	u8 sb5m_ratio_3;
-	bool aci_indicator_b;
-	bool tia_shrink_indicator_b;
-	bool pre_gain_code_tia_b;
-	bool l_fine_gain_code_tia_b;
-	bool ht_fine_gain_code_tia_b;
-	bool aci_det;
-};
-
-struct bb_physts_rslt_26_info {
-	u8 *ie_26_addr;
-	u8 tmp;
-};
-
-struct bb_physts_rslt_27_info {
-	u8 *ie_27_addr;
-	u8 tmp;
-};
-
-struct bb_physts_rslt_28_info {
-	u8 *ie_28_addr;
-	u16 ant_weight_a;
-	u8 h3_real_a;
-	u8 h3_imag_a;
-	u8 h4_real_a;
-	u8 h4_imag_a;
-	u8 h5_real_a;
-	u8 h5_imag_a;
-	u8 h6_real_a;
-	u8 h6_imag_a;
-	u8 h7_real_a;
-	u8 h7_imag_a;
-	u8 h8_real_a;
-	u8 h8_imag_a;
-	u8 h9_real_a;
-	u8 h9_imag_a;
-	u8 h10_real_a;
-	u8 h10_imag_a;
-	u8 h11_real_a;
-	u8 h11_imag_a;
-	u8 h12_real_a;
-	u8 h12_imag_a;
-	u8 h13_real_a;
-	u8 h13_imag_a;
-	u8 h14_real_a;
-	u8 h14_imag_a;
-	u8 h15_real_a;
-	u8 h15_imag_a;
-	u8 h16_real_a;
-	u8 h16_imag_a;
-	u8 h17_real_a;
-	u8 h17_imag_a;
-};
-
-struct bb_physts_rslt_29_info {
-	u8 *ie_29_addr;
-	u16 ant_weight_b;
-	u8 h3_real_b;
-	u8 h3_imag_b;
-	u8 h4_real_b;
-	u8 h4_imag_b;
-	u8 h5_real_b;
-	u8 h5_imag_b;
-	u8 h6_real_b;
-	u8 h6_imag_b;
-	u8 h7_real_b;
-	u8 h7_imag_b;
-	u8 h8_real_b;
-	u8 h8_imag_b;
-	u8 h9_real_b;
-	u8 h9_imag_b;
-	u8 h10_real_b;
-	u8 h10_imag_b;
-	u8 h11_real_b;
-	u8 h11_imag_b;
-	u8 h12_real_b;
-	u8 h12_imag_b;
-	u8 h13_real_b;
-	u8 h13_imag_b;
-	u8 h14_real_b;
-	u8 h14_imag_b;
-	u8 h15_real_b;
-	u8 h15_imag_b;
-	u8 h16_real_b;
-	u8 h16_imag_b;
-	u8 h17_real_b;
-	u8 h17_imag_b;
-};
-
-struct bb_physts_rslt_30_info {
-	u8 *ie_30_addr;
-	u8 tmp;
-};
-
-struct bb_physts_rslt_31_info {
-	u8 *ie_31_addr;
-	u8 tmp;
-};
-
-struct bb_physts_cnt_info {
-	u16 all_cnt;
-	u16 is_2_self_cnt;
-	u16 err_ie_cnt;
-	u16 ok_ie_cnt;
-	u16 err_len_cnt;
-	bool invalid_he_occur;
-	u32 invalid_he_cnt;
-};
-
-struct bb_physts_cr_info {
-	u32 bitmap_search_fail;
-	//u32 bitmap_search_fail_m;
-	u32 plcp_hist;
-	u32 plcp_hist_m;
-	u32 period_cnt_en;
-};
-
-struct bb_physts_info {
-	u32 physts_bitmap_recv;
-	u32 bitmap_type[PHYSTS_BITMAP_NUM];
-	u8 rx_path_en;
-	bool print_more_info;
-	u8 physts_dump_mode; /*0: disable, 1:raw data, 2: msg mode, 3:raw data + msg mode*/
-	u16 physts_dump_idx;
-	bool is_valid; // used for UI parsing
-	bool show_phy_sts_all_pkt;
-	bool dfs_phy_sts_privilege;// used for CAC period in DFS channel
-	u16 show_phy_sts_cnt;
-	u16 show_phy_sts_max_cnt;
-	// long term cfo rslt
-	s32 l_ltf_cfo_i;
-	s32 l_ltf_cfo_q;
-	u16 ie_len_curr[IE_PHYSTS_LEN_ALL];
-	bool rssi_cvrt_2_rpl_en;
-	u8 rpl_path[4]; /*u(8,1)*/
-	u8 rpl_avg; /*u(8,1)*/
-	u8 frc_mu; /*force data type to SU/MU(debug mode)*/
-	u8 tmp_mcs;/*fake MCS (debug mode)*/
-	u8 tmp_sts;/*fake STS (debug mode)*/
-	struct bb_rate_info		bb_rate_i;
-	struct bb_rate_info		bb_rate_mu_i;
-	struct bb_physts_cr_info	bb_physts_cr_i;
-	struct bb_physts_cnt_info	bb_physts_cnt_i;
-	struct bb_physts_rslt_hdr_info	bb_physts_rslt_hdr_i;
-	struct bb_physts_rslt_0_info	bb_physts_rslt_0_i;
-	struct bb_physts_rslt_1_info	bb_physts_rslt_1_i;
-	struct bb_physts_rslt_2_info	bb_physts_rslt_2_i;
-	struct bb_physts_rslt_3_info	bb_physts_rslt_3_i;
-	struct bb_physts_rslt_4_to_7_info bb_physts_rslt_4_i;
-	struct bb_physts_rslt_4_to_7_info bb_physts_rslt_5_i;
-	struct bb_physts_rslt_4_to_7_info bb_physts_rslt_6_i;
-	struct bb_physts_rslt_4_to_7_info bb_physts_rslt_7_i;
-	struct bb_physts_rslt_8_info	bb_physts_rslt_8_i;
-	struct bb_physts_rslt_9_info	bb_physts_rslt_9_i;
-	struct bb_physts_rslt_10_info	bb_physts_rslt_10_i;
-	struct bb_physts_rslt_11_info	bb_physts_rslt_11_i;
-	struct bb_physts_rslt_12_info	bb_physts_rslt_12_i;
-	struct bb_physts_rslt_13_info	bb_physts_rslt_13_i;
-	struct bb_physts_rslt_14_info	bb_physts_rslt_14_i;
-	struct bb_physts_rslt_15_info	bb_physts_rslt_15_i;
-	struct bb_physts_rslt_16_info	bb_physts_rslt_16_i;
-	struct bb_physts_rslt_17_info	bb_physts_rslt_17_i;
-	struct bb_physts_rslt_18_info	bb_physts_rslt_18_i;
-	struct bb_physts_rslt_19_info	bb_physts_rslt_19_i;
-	struct bb_physts_rslt_20_info	bb_physts_rslt_20_i;
-	struct bb_physts_rslt_21_info	bb_physts_rslt_21_i;
-	struct bb_physts_rslt_22_info	bb_physts_rslt_22_i;
-	struct bb_physts_rslt_23_info	bb_physts_rslt_23_i;
-	struct bb_physts_rslt_24_info	bb_physts_rslt_24_i;
-	struct bb_physts_rslt_25_info	bb_physts_rslt_25_i;
-	struct bb_physts_rslt_26_info	bb_physts_rslt_26_i;
-	struct bb_physts_rslt_27_info	bb_physts_rslt_27_i;
-	struct bb_physts_rslt_28_info	bb_physts_rslt_28_i;
-	struct bb_physts_rslt_29_info	bb_physts_rslt_29_i;
-	struct bb_physts_rslt_30_info	bb_physts_rslt_30_i;
-	struct bb_physts_rslt_31_info	bb_physts_rslt_31_i;
-};
-
-struct bb_info;
-/*@--------------------------[Prptotype]-------------------------------------*/
-void halbb_physts_cvrt_2_mp(struct bb_info *bb);
-void halbb_physts_ie_bitmap_set(struct bb_info *bb, u32 ie_page, u32 bitmap);
-u32 halbb_physts_ie_bitmap_get(struct bb_info *bb, u32 ie_page);
-void halbb_physts_ie_bitmap_en(struct bb_info *bb, enum bb_physts_bitmap_t type,
-			       enum bb_physts_ie_t ie, bool en);
-void halbb_phy_sts_manual_trig(struct bb_info *bb, enum bb_mode_type mode, u8 ss);
-void halbb_physts_watchdog(struct bb_info *bb);
-void halbb_physts_parsing_init(struct bb_info *bb);
-
-void halbb_physts_brk_fail_rpt_en(struct bb_info* bb, bool enable, enum phl_phy_idx phy_idx);
-
-void halbb_physts_dbg(struct bb_info *bb, char input[][16], u32 *_used,
-		  char *output, u32 *_out_len);
-void halbb_cr_cfg_physts_init(struct bb_info *bb);
-
-#endif
diff --git a/os/board/rtl8720e/src/component/wifi/driver/src/hal/phy_g6/bb/halbb_physts_ex.h b/os/board/rtl8720e/src/component/wifi/driver/src/hal/phy_g6/bb/halbb_physts_ex.h
deleted file mode 100644
index 2943a6f66..000000000
--- a/os/board/rtl8720e/src/component/wifi/driver/src/hal/phy_g6/bb/halbb_physts_ex.h
+++ /dev/null
@@ -1,103 +0,0 @@
-/******************************************************************************
- *
- * Copyright(c) 2007 - 2020  Realtek Corporation.
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of version 2 of the GNU General Public License as
- * published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
- * more details.
- *
- * The full GNU General Public License is included in this distribution in the
- * file called LICENSE.
- *
- * Contact Information:
- * wlanfae <wlanfae@realtek.com>
- * Realtek Corporation, No. 2, Innovation Road II, Hsinchu Science Park,
- * Hsinchu 300, Taiwan.
- *
- * Larry Finger <Larry.Finger@lwfinger.net>
- *
- *****************************************************************************/
-
-#ifndef __HALBB_PHYSTS_EX_H__
-#define __HALBB_PHYSTS_EX_H__
-
-enum bb_physts_bitmap_t {
-	TD_SEARCH_FAIL	= 0,
-	BRK_BY_TX_PKT	= 1,
-	CCA_SPOOF	= 2,
-	OFDM_BRK	= 3,
-	CCK_BRK		= 4,
-	DL_MU_SPOOFING	= 5,
-	HE_MU		= 6,
-	VHT_MU		= 7,
-	UL_TB_SPOOFING	= 8,
-	RSVD_9		= 9,
-	TRIG_BASE_PPDU	= 10,
-	CCK_PKT		= 11,
-	LEGACY_OFDM_PKT = 12,
-	HT_PKT		= 13,
-	VHT_PKT		= 14,
-	HE_PKT		= 15,
-	PHYSTS_BITMAP_NUM
-};
-
-struct physts_rxd_user {
-	u8		macid;
-	u8		is_data: 1;
-	u8		is_ctrl:1;
-	u8		is_mgnt:1;
-	u8		is_bcn:1;
-	u8		rsvd_0:4;
-};
-
-struct physts_rxd {
-	u8		is_su:1;
-	u8		user_num:2;
-	u8		is_to_self:1;
-	u8		gi_ltf:4; /*enum rtw_gi_ltf*/
-	u16		data_rate;
-	u8		macid_su;
-	//u8		ppdu_cnt;
-	enum phl_phy_idx phy_idx;
-	struct physts_rxd_user user_i[4];
-};
-
-struct physts_result {
-	bool			physts_rpt_valid; /* @if physts_rpt_valid is false, please ignore the parsing result in this structure*/
-	u8			rssi_avg;
-	u8			rssi[4];	/* u(8,1) RSSI in 0~100 index */
-	enum bb_physts_bitmap_t ie_map_type;
-	u8			ch_idx;		/* channel number---*/
-	enum channel_width	rx_bw;
-	u8			rxsc;		/* sub-channel---*/
-	u8			is_mu_pkt;	/* is MU packet or not---bool*/
-	u8			is_bf;		/* BF packet---bool*/
-	u8			snr_fd_avg;	/* fd, u(8,0), OFDM,        fd_snr_avg(phy-sts), limited by FD DFIR output wordlength*/
-	u8			snr_fd[4];	/* fd, u(8,0), OFDM,        fd_snr_avg(phy-sts) + td_rssi_diff[i]*/
-	u8			snr_td_avg;	/* td, u(8,0), OFDM + CCK,  td_rssi_avg(phy-sts) - MA(rx_idle_pwer)*/
-	u8			snr_td[4];	/* td, u(8,0), OFDM + CCK,  td_rssi[i](phy-sts)  - MA(rx_idle_pwer), limited by DIG in 52A B-cut*/
-	u8			is_su ;
-	u8			is_ldpc;
-	u8			is_stbc;
-	s16			cfo;
-	u16			ch_info_len;
-	s16			*ch_info_addr;
-};
-
-struct bb_info;
-
-u8 halbb_drv_info_rssi_parsing(struct bb_info *bb, u16 rssi_in,
-			       enum channel_width bw);
-
-bool halbb_physts_parsing(struct bb_info *bb,
-			      u8 *addr,
-			      u16 physts_total_length,
-			      struct physts_rxd *desc,
-			      struct physts_result *bb_rpt);
-
-#endif
diff --git a/os/board/rtl8720e/src/component/wifi/driver/src/hal/phy_g6/bb/halbb_physts_ie_b_endian.h b/os/board/rtl8720e/src/component/wifi/driver/src/hal/phy_g6/bb/halbb_physts_ie_b_endian.h
deleted file mode 100644
index 791d44c79..000000000
--- a/os/board/rtl8720e/src/component/wifi/driver/src/hal/phy_g6/bb/halbb_physts_ie_b_endian.h
+++ /dev/null
@@ -1,1517 +0,0 @@
-/******************************************************************************
- *
- * Copyright(c) 2007 - 2020  Realtek Corporation.
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of version 2 of the GNU General Public License as
- * published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
- * more details.
- *
- * The full GNU General Public License is included in this distribution in the
- * file called LICENSE.
- *
- * Contact Information:
- * wlanfae <wlanfae@realtek.com>
- * Realtek Corporation, No. 2, Innovation Road II, Hsinchu Science Park,
- * Hsinchu 300, Taiwan.
- *
- * Larry Finger <Larry.Finger@lwfinger.net>
- *
- *****************************************************************************/
-#ifndef __HALBB_PHYSTS_IE_B_ENDIAN_H__
-#define __HALBB_PHYSTS_IE_B_ENDIAN_H__
-
- /*@--------------------------[Define] ---------------------------------------*/
-
- /*@--------------------------[Enum]------------------------------------------*/
- 
- /*@--------------------------[Structure]-------------------------------------*/
-
-struct physts_hdr_info {
-	u8 is_valid:1;		/*valid: total content length <= 1024 bytes*/
-	u8 null_tb_ppdu:1;
-	u8 rsvd_0:1;
-	u8 ie_bitmap_select: 5;
-	u8 physts_total_length;	/*total length(unit: 8byte)*/
-	u8 rsvd_1;
-	u8 rssi_avg_td;		/*U(8,1) RSSI=dBm+110, ex:-30dBm->RSSI:80%*/
-	u8 rssi_td[4];
-};
-
-enum bb_physts_hdr_t {
-	HDR_TYPE1 = 1, /*5bit fix length*/
-	HDR_TYPE2 = 2 /*12bit variable length*/
-};
-
-struct physts_ie_0_info {
-	/*[DW0]*/
-	u8 rpl_l:1;
-	u8 pop_idx:2;
-	u8 ie_hdr:5;
-
-	u8 rpl_m;
-	u8 cca_time;
-	u8 cck_hw_antsw_occur_c:1;
-	u8 cck_hw_antsw_occur_b:1;
-	u8 cck_hw_antsw_occur_a:1;
-	u8 antwgt_gain_diff:5;
-	/*[DW1]*/
-	u8 avg_idle_noise_pwr;
-	u8 avg_cfo_l;
-	u8 coarse_cfo_l:4;
-	u8 avg_cfo_m:4;
-	u8 coarse_cfo_m;
-	/*[DW2]*/
-	u8 rxevm_hdr;
-	u8 rxevm_pld;
-	u8 sig_len_l;
-	u8 sig_len_m;
-	/*[DW3]*/
-	u8 cck_hw_antsw_occur_d:1;
-	u8 rsvd_1_dummy_1bit:1;
-	u8 sync_mode:1;
-	u8 preamble_type:1;
-	u8 antdiv_rslt_d:1;
-	u8 antdiv_rslt_c:1;
-	u8 antdiv_rslt_b:1 ;
-	u8 antdiv_rslt_a:1;
-
-	u8 dagc_b_l:3;
-	u8 dagc_a:5;
-
-	u8 dagc_d_l:1;
-	u8 dagc_c:5;
-	u8 dagc_b_m:2;
-
-	u8 rx_path_en_bitmap:4;
-	u8 dagc_d_m:4;
-};
-
-struct physts_ie_1_info {
-	/*[DW0]*/
-	u8 rsvd_0_dummy_1bit:1;
-	u8 pop_idx:2;
-	u8 ie_hdr:5;
-	u8 rssi_avg_fd;
-	u8 ch_idx_seg0;
-	u8 rx_path_en_bitmap:4;
-	u8 rxsc:4;
-	/*[DW1]*/
-	u8 avg_idle_noise_pwr;
-	u8 avg_cfo_seg0_l;
-
-	u8 avg_cfo_premb_seg0_l:4;
-	u8 avg_cfo_seg0_m:4;
-
-	u8 avg_cfo_premb_seg0_m;
-	/*[DW2]*/
-	u8 ant_idx_b:1;
-	u8 ant_idx_a:1;
-	u8 avg_snr:6;
-	u8 evm_max;
-	u8 evm_min;
-	u8 grant_bt:1;
-	u8 is_stbc:1;
-	u8 is_ndp:1;
-	u8 is_ldpc:1;
-	u8 is_su:1;
-	u8 pdp_he_ltf_and_gi_type:3;
-	/*[DW3]*/
-	u8 is_awgn:1;
-	u8 bf_gain_max:7;
-	u8 avg_cn_seg0:7;
-	u8 is_bf:1;
-	u8 sigval_below_th_tone_cnt_seg0;
-	u8 cn_excess_th_tone_cnt_seg0;
-	/*[DW4]*/
-	u8 pwr_to_cca_l;
-	u8 pwr_to_cca_m;
-	u8 cca_to_agc;
-	u8 cca_to_sbd;
-	/*[DW5]*/
-	u8 edcca_rpt_cnt:7;
-	u8 rsvd_1_dummy_1bit:1;
-	u8 edcca_rpt_curr_bw_max_l:1;
-	u8 edcca_total_smp_cnt:7;
-	u8 edcca_rpt_curr_bw_min_l:2;
-	u8 edcca_rpt_curr_bw_max_m:6;
-	u8 bw_idx:3; /*0~6: 5, 10, 20, 40, 80, 160, 80_80*/
-	u8 edcca_rpt_curr_bw_min_m:5;
-};
-
-struct physts_ie_1_info_type1 {
-	/*[DW0]*/
-	u8 rsvd_0_dummy_1bit:1;
-	u8 pop_idx:2;
-	u8 ie_hdr:5;
-	u8 rssi_avg_fd;
-	u8 ch_idx_seg0;
-	u8 rx_path_en_bitmap:4;
-	u8 rxsc:4;
-	/*[DW1]*/
-	u8 avg_idle_noise_pwr;
-	u8 td_p_fd_tracking_cfo_seg0_l;
-	u8 avg_cfo_premb_seg0_l:4;
-	u8 td_p_fd_tracking_cfo_seg0_m:4;
-	u8 avg_cfo_premb_seg0_m;
-	/*[DW2]*/
-	u8 ant_idx_b:1;
-	u8 ant_idx_a:1;
-	u8 avg_snr:6;
-	u8 evm_max;
-	u8 evm_min;
-	u8 grant_bt:1;
-	u8 is_stbc:1;
-	u8 is_ndp:1;
-	u8 is_ldpc:1;
-	u8 is_su:1;
-	u8 pdp_he_ltf_and_gi_type:3;
-	/*[DW3]*/
-	u8 is_awgn:1;
-	u8 bf_gain_max:7;
-	u8 avg_cn_seg0:7;
-	u8 is_bf:1;
-	u8 sigval_below_th_tone_cnt_seg0;
-	u8 cn_excess_th_tone_cnt_seg0;
-	/*[DW4]*/
-	u8 pwr_to_cca_l;
-	u8 pwr_to_cca_m;
-	u8 cca_to_agc;
-	u8 cca_to_sbd;
-	/*[DW5]*/
-	u8 edcca_rpt_cnt:7;
-	u8 rsvd_1_dummy_1bit:1;
-	u8 edcca_rpt_curr_bw_max_l:1;
-	u8 edcca_total_smp_cnt:7;
-	u8 edcca_rpt_curr_bw_min_l:2;
-	u8 edcca_rpt_curr_bw_max_m:6;
-	u8 bw_idx:3; /*0~6: 5, 10, 20, 40, 80, 160, 80_80*/
-	u8 edcca_rpt_curr_bw_min_m:5;
-	/*[DW6]*/
-	u8 ftm_t_off_l;
-	u8 rsvd_2_dummy:4;
-	u8 ftm_t_off_m:4;
-	u8 brk_src_idx;
-	u8 outer_buf_2sts;
-	/*[DW7]*/
-	u8 bt_gnt_rx_cnt:3;
-	u8 bt_gnt_rx_at_cca:1;
-	u8 bt_gnt_tx_cnt:3;
-	u8 bt_gnt_tx_at_cca:1;
-	u8 rsvd_3_dummy_1;
-	u8 rsvd_3_dummy_2;
-	u8 rsvd_3_dummy_3;
-};
-
-struct physts_ie_2_info {
-	/*[DW0]*/
-	u8 max_nsts:3;
-	u8 ie_hdr:5;
-
-	u8 c_cfo_i_l:2;
-	u8 is_mu_mimo:1;
-	u8 gi:2;
-	u8 ltf_type:2 ;
-	u8 midamble:1;
-
-	u8 c_cfo_i_m2;
-	u8 c_cfo_i_m1;
-	/*[DW1]*/
-	u8 rx_info_1;
-
-	u8 c_cfo_q_l:2;
-	u8 is_dl_ofdma:1;
-	u8 rx_state_feq:5;
-
-	u8 c_cfo_q_m2;
-	u8 c_cfo_q_m1;
-	/*[DW2]*/
-	u8 est_cmped_phase;
-
-	u8 f_cfo_i_l:2;
-	u8 rsvd_0_dummy_1bit:1;
-	u8 pkt_extension:3;
-	u8 is_doppler:1;
-	u8 is_dcm:1;
-
-	u8 f_cfo_i_m2;
-	u8 f_cfo_i_m1;
-	/*[DW3]*/
-	u8 n_sym_l:5;
-	u8 n_ltf:3;
-
-	u8 f_cfo_q_l:2;
-	u8 n_sym_m:6;
-
-	u8 f_cfo_q_m2;
-	u8 f_cfo_q_m1;
-};
-
-struct physts_ie_3_info {
-	/*[DW0]*/
-	u8 rsvd_0_dummy_3bit:3;
-	u8 ie_hdr:5;
-
-	u8 rsvd_1_dummy_1bit:1;
-	u8 avg_cn_seg1:7;
-
-	u8 sigval_below_th_tone_cnt_seg1;
-	u8 cn_excess_th_tone_cnt_seg1;
-
-	/*[DW1]*/
-	u8 avg_cfo_seg1_l;
-
-	u8 rsvd_2_dummy_4bit:4;
-	u8 avg_cfo_seg1_m:4;
-
-	u8 avg_cfo_premb_seg1_l;
-
-	u8 rsvd_3_dummy_4bit:4;
-	u8 avg_cfo_premb_seg1_m:4;
-
-	/*[DW2]*/
-	u8 est_cmped_phase_seg1;
-
-	u8 c_cfo_i_seg1_l:2;
-	u8 avg_snr_seg1:6;
-
-	u8 c_cfo_i_seg1_m2;
-	u8 c_cfo_i_seg1_m1;
-
-	u8 c_cfo_q_seg1_l2;
-	u8 c_cfo_q_seg1_l1;
-
-	u8 f_cfo_i_seg1_l:6;
-	u8 c_cfo_q_seg1_m:2;
-
-	u8 f_cfo_i_seg1_lm;
-
-	u8 f_cfo_q_seg1_l:4;
-	u8 f_cfo_i_seg1_m:4;
-
-	u8 f_cfo_q_seg1_lm;
-
-	u8 rsvd_5_dummy_10bit_l:2;
-	u8 f_cfo_q_seg1_m:6;
-
-	u8 rsvd_5_dummy_10bit_m;
-	u8 ch_idx_seg1;
-	u8 evm_max_seg1;
-	u8 evm_min_seg1;
-	u8 rsvd_6_dummy_8bit;
-};
-
-/*physts_ie_4_to_7_info*/
-struct physts_ie_4_to_7_info {
-	/*[DW0]*/
-	u8 ant_idx:3;
-	u8 ie_hdr:5;
-
-	u8 sig_val_y;
-	u8 rf_gain_idx;
-
-	u8 snr_lgy:6;
-	u8 tia_shrink_indicator:1;
-	u8 rf_tia_gain_idx:1;
-
-	/*[DW0]*/
-	u8 evm_ss_y;
-
-	u8 ant_idx_msb:1;
-	u8 td_ant_weight:7;
-
-	u8 dc_est_re;
-	u8 dc_est_im;
-};
-
-struct physts_ie_8_ch_info {
-	/*[DW0]*/
-	u8 ie_hdr_l;
-
-	u8 rxsc:4;
-	u8 ie_hdr_m:4;
-
-	u8 ch_info_len_l:2;
-	u8 n_sts:3;
-	u8 n_rx:3;
-
-	u8 ch_info_len_m;
-	/*[DW1]*/
-	u8 evm_1_sts;
-	u8 evm_2_sts;
-	u8 avg_idle_noise_pwr;
-
-	u8 rsvd_0_dummy_7bit:7;
-	u8 is_ch_info_len_valid:1;
-	u8 rsvd_1[8];
-	u8 rsvd_2[8];
-};
-
-struct physts_ie_8_ch_raw_info {
-	u8 *channel_info_raw;
-};
-
-struct physts_ie_9_lgcy_info {
-	/*[DW0]*/
-	u8 l_sig_l:3;
-	u8 ie_hdr:5;
-
-	u8 l_sig_lm;
-
-	u8 rsvd_0_dummy_2bit:2;
-	u8 l_sig_m:6;
-
-	u8 rsvd_0_dummy_8bit;
-	u8 rsvd_1_dummy_8bit;
-	u8 rsvd_2_dummy_8bit;
-	u8 rsvd_3_dummy_8bit;
-	u8 rsvd_4_dummy_8bit;
-
-};
-
-struct physts_ie_9_vht_info {
-	/*[DW0]*/
-	u8 l_sig_l:3;
-	u8 ie_hdr:5;
-
-	u8 l_sig_lm;
-
-	u8 sig_a1_l:2;
-	u8 l_sig_m:6;
-
-	u8 sig_a1_lm2;
-	u8 sig_a1_lm1;
-
-	u8 sig_a2_l:2;
-	u8 sig_a1_m:6;
-
-	u8 sig_a2_m;
-
-	u8 rsvd_0_dummy_8bit;
-};
-
-struct physts_ie_9_he_info {
-	/*[DW0]*/
-	u8 l_sig_l:3;
-	u8 ie_hdr:5;
-
-	u8 l_sig_lm;
-
-	u8 sig_a1_l:2;
-	u8 l_sig_m:6;
-
-	u8 sig_a1_m3;
-	u8 sig_a1_m2;
-	u8 sig_a1_m1;
-
-	u8 sig_a2_l;
-	u8 sig_a2_m;
-};
-
-struct physts_ie_10_sigb_info {
-	u8 *sigb_raw_data_bits_addr;
-};
-
-struct physts_ie_10_cmn_info {
-	/*[DW0]*/
-	u8 ie_hdr_l;
-
-	u8 rsvd_0_dummy_4bit:4;
-	u8 ie_hdr_m:4;
-
-	u8 rsvd_0_dummy_8bit;
-	u8 rsvd_1_dummy_8bit;
-	u8 rsvd_2_dummy_8bit;
-	u8 rsvd_3_dummy_8bit;
-	u8 rsvd_4_dummy_8bit;
-	u8 rsvd_5_dummy_8bit;
-
-};
-
-struct physts_ie_11_pkt_info {
-	/*[DW0]*/
-	u8 l_length_l:3;
-	u8 l_rate:3;
-	u8 pkt_format:2;
-
-	u8 l_length_lm;
-
-	u8 info_type_0:7;
-	u8 l_length_m:1;
-
-	u8 info_type_1;
-	u8 info_type_2;
-	u8 info_type_3;
-
-	u8 time_stamp_l:5;
-	u8 info_type_4:3;
-
-	u8 state:2;
-	u8 time_stamp_m:6;
-};
-
-struct physts_ie_11_pkt_info_type1 {
-	/*[DW0/1]*/
-	u8 mac_frame_control_1:3;
-	u8 pop_idx:2;
-	u8 pkt_format:3;
-
-	u8 mac_frame_control_2;
-
-	u8 information_type_1:7;
-	u8 mac_frame_control_3:1;
-
-	u8 information_type_2;
-	u8 information_type_3;
-	u8 information_type_4;
-
-	u8 time_stamp_l:5;
-	u8 information_type_5:3;
-
-	u8 state:2;
-	u8 time_stamp_m:6;
-};
-
-struct physts_ie_11_info {
-	/*[DW0]*/
-	u8 l_sig_l:3;
-	u8 ie_hdr:5;
-
-	u8 l_sig_lm;
-
-	u8 sig_a1_l:2;
-	u8 l_sig_m:6;
-
-	u8 sig_a1_m3;
-	u8 sig_a1_m2;
-	u8 sig_a1_m1;
-
-	u8 sig_a2_l;
-	u8 sig_a2_m;
-
-	u8 time_stamp_l;
-
-	u8 tx_pkt_info_idx_l:1;
-	u8 rx_pkt_info_idx:4;
-	u8 time_stamp_m:3;
-
-	u8 rsvd_0_dummy_5bit:5;
-	u8 tx_pkt_info_idx_m:3;
-
-	u8 rsvd_0_dummy_8bit;
-	u8 rsvd_1_dummy_8bit;
-	u8 rsvd_2_dummy_8bit;
-	u8 rsvd_3_dummy_8bit;
-	u8 rsvd_4_dummy_8bit;
-
-	struct physts_ie_11_pkt_info pkt_info_rx_i[10];
-	struct physts_ie_11_pkt_info pkt_info_tx_i[10];
-};
-
-struct physts_ie_11_info_type1 {
-	/*[DW0]*/
-	u8 time_stamp_l:3;
-	u8 ie_hdr:5;
-	u8 time_stamp_m;
-	u8 tx_pktinfo_idx:4;
-	u8 rx_pktinfo_idx:4;
-	u8 rsvd_0_dummy_8bit;
-	/*[DW1]*/
-	u8 rsvd_1_dummy_8bit;
-	u8 rsvd_2_dummy_8bit;
-	u8 rsvd_3_dummy_8bit;
-	u8 rsvd_4_dummy_8bit;
-	/*[DW2/3]*/
-	struct physts_ie_11_pkt_info_type1 pkt_info_rx_i[10];
-	struct physts_ie_11_pkt_info_type1 pkt_info_tx_i[10];
-};
-
-struct physts_ie_12_user_info {
-	u8 sig_val_ss0_seg_cr_user_i;
-	u8 sig_val_ss1_seg_cr_user_i;
-	u8 sig_val_ss2_seg_cr_user_i;
-	u8 sig_val_ss3_seg_cr_user_i;
-	u8 sig_bad_tone_cnt_seg_cr_user_i;
-	u8 cn_bad_tone_cnt_seg_cr_user_i;
-};
-
-struct physts_ie_12_cmn_info {
-	u8 ie_hdr_l;
-
-	u8 rsvd_0_dummy_4bit:4;
-	u8 ie_hdr_m:4;
-
-	u8 n_user;
-};
-
-struct physts_ie_13_user_info {
-	u8 is_bf:1;
-	u8 fec_type:1;
-	u8 mcs:6;
-
-	u8 pilot_exist:2;
-	u8 n_sts:3;
-	u8 n_sts_ru_total:3;
-
-	u8 is_awgn:1;
-	u8 is_mu_mimo:1;
-	u8 pdp_he_ltf_and_gi_type:3;
-	u8 start_sts:3;
-
-	u8 rx_evm_max_seg_cr;
-	u8 rx_evm_min_seg_cr;
-	u8 snr;
-	u8 ru_alloc;
-
-	u8 is_dcm:1;
-	u8 avg_cn_seg_cr:7;
-
-	u8 sta_id_l;
-
-	u8 rsvd_0_dummy_5bit:5;
-	u8 sta_id_m:3;
-};
-
-struct physts_ie_13_cmn_info_p1 {
-	u8 ie_hdr_l;
-
-	u8 rsvd_0_dummy_4bit:4;
-	u8 ie_hdr_m:4;
-
-	u8 n_user;
-	u8 rsvd_1_dummy_8bit;
-};
-
-struct physts_ie_13_cmn_info_p2 {
-	u8 n_not_sup_sta;
-
-	u8 not_support_sta_id0_l;
-
-	u8 rsvd_0_dummy_5bit:5;
-	u8 not_support_sta_id0_m:3;
-
-	u8 not_support_sta_id1_l;
-
-	u8 rsvd_1_dummy_5bit:5;
-	u8 not_support_sta_id1_m:3;
-
-	u8 not_support_sta_id2_l;
-
-	u8 not_support_sta_id3_l:5;
-	u8 not_support_sta_id2_m:3;
-
-	u8 rsvd_2_dummy_2bit:2;
-	u8 not_support_sta_id3_m:6;
-};
-
-struct physts_ie_14_user_info {
-	u8 cqi_bitmap_ul_tb;
-	u8 cqi_raw_len_ul_tb;
-	u8 *cqi_raw_ul_tb_addr;
-};
-
-struct physts_ie_14_cmn_info {
-	u8 ie_hdr_l;
-	u8 rsvd_0_dummy_3bit:3;
-	u8 rxinfo_ndp_en:1;
-	u8 ie_hdr_m:4;
-	u8 n_user;
-	u8 rxinfo_ndp_1;
-
-	u8 rsvd_0_dummy_8bit;
-	u8 rsvd_1_dummy_8bit;
-	u8 rsvd_2_dummy_8bit;
-	u8 rsvd_3_dummy_8bit;
-};
-
-struct physts_ie_15_cmn_info {
-	u8 ie_hdr_l;
-
-	u8 rsvd_0_dummy_4bit:4;
-	u8 ie_hdr_m:4;
-
-	u8 n_user;
-};
-
-struct physts_ie_15_user_info {
-	/* 64bit cmn_info */
-	u8 is_bf:1;
-	u8 fec_type:1;
-	u8 mcs:6;
-
-	u8 pilot_exist:2;
-	u8 n_sts:3;
-	u8 n_sts_ru_total:3;
-
-	u8 is_awgn:1;
-	u8 is_mu_mimo:1;
-	u8 pdp_he_ltf_and_gi_type:3;
-	u8 start_sts:3;
-
-	u8 rx_evm_max_seg_cr;
-	u8 rx_evm_min_seg_cr;
-	u8 snr;
-	u8 ru_alloc;
-
-	u8 is_dcm:1;
-	u8 avg_cn_seg_cr:7;
-
-	/* others */
-	u8 uid;
-	u8 avg_cfo_seg0_l;
-
-	u8 rsvd_0_dummy_4bit:4;
-	u8 avg_cfo_seg0_m:4;
-
-	u8 rssi_m_ul_tb_l;
-
-	u8 rsvd_1_dummy_7bit:7;
-	u8 rssi_m_ul_tb_m:1;
-};
-
-struct physts_ie_17_cmn_info {
-	u8 ie_hdr_l;
-
-	u8 n_user_l:4;
-	u8 ie_hdr_m:4;
-
-	u8 rsvd_0_dummy_4bit:4;
-	u8 n_user_m:4;
-
-	u8 rsvd_0_dummy_8it;
-	u8 rsvd_1_dummy_8it;
-	u8 rsvd_2_dummy_8it;
-	u8 rsvd_3_dummy_8it;
-	u8 rsvd_4_dummy_8it;
-
-	/*64bit rx_tb_cmn_ctrl*/
-
-	u8 ltf_type:2;
-	u8 gi_type:2;
-	u8 midamle_mode:1;
-	u8 doppler_en:1;
-	u8 ldpc_extra:1;
-	u8 stbc_en:1;
-
-	u8 n_sym_l:5;
-	u8 n_ltf:3;
-
-	u8 pe_idx_l:2;
-	u8 n_sym_m:6;
-
-	u8 n_usr_l:5;
-	u8 pre_fec_factor:2;
-	u8 pe_idx_m:1;
-
-	u8 pri_exp_rssi_dbm_l:3;
-	u8 ndp:1;
-	u8 mumimo_ltf_mode_en:1;
-	u8 n_usr_m:3;
-
-	u8 rsvd1:2;
-	u8 dbw_idx:2;
-	u8 pri_exp_rssi_dbm_m:4;
-
-	u8 rxtime_l:8;
-
-	u8 rsvd2:2;
-	u8 rxtime_m:6;
-};
-
-struct physts_ie_17_user_info {
-	/*64bit rx_tb_user_ctrl*/
-	u8 u_id;
-
-	u8 ru_alloc;
-
-	u8 strt_sts:3;
-	u8 rsvd1:2;
-	u8 n_sts_ru_tot:3;
-
-	u8 mcs:4;
-	u8 fec_type:1;
-	u8 n_sts:3;
-
-	u8 rsvd3:5;
-	u8 dcm_en:1;
-	u8 rsvd2:2;
-
-	u8 rsvd4;
-	u8 rsvd5;
-	u8 rsvd6;
-};
-
-struct physts_ie_18_info {
-	/*[DW0]*/
-	u8 rsvd_0_dummy_2bit:2;
-	u8 is_seg1_exist:1;
-	u8 ie_hdr:5;
-
-	u8 rx_time_l;
-
-	u8 rsvd_1_dummy_2bit:2;
-	u8 rx_time_m:6;
-
-	u8 ch_len_lgcy_seg0;
-	u8 bw_det_seg0;
-
-	u8 rsvd_2_dummy_2bit:2;
-	u8 pdp_idx_lgcy_seg0:3;
-	u8 snr_idx_lgcy_seg0:3;
-
-	u8 pfd_flow_l;
-
-	u8 rsvd_3_dummy_4bit:4;
-	u8 pfd_flow_m:4;
-
-	u8 ch_len_lgcy_seg1;
-	u8 bw_det_seg1;
-
-	u8 rsvd_3_dummy_2bit:2;
-	u8 pdp_idx_lgcy_seg1:3;
-	u8 snr_idx_lgcy_seg1:3;
-
-	u8 rsvd_3_dummy_8bit;
-
-	u8 zero_padding_l2;
-	u8 zero_padding_l1;
-	u8 zero_padding_m2;
-	u8 zero_padding_m1;
-};
-
-struct physts_ie_18_info_type1 {
-	/*[DW0]*/
-	u8 rsvd_0_dummy_3bit:3;
-	u8 ie_hdr:5;
-
-	u8 rxtime_l;
-
-	u8 pfd_flow_1:2;
-	u8 rxtime_m:6;
-	/*[DW1]*/
-	u8 pfd_flow_2;
-
-	u8 ch_len_lgcy_seg0_l:6;
-	u8 pfd_flow_3:2;
-
-	u8 ch_len_lgcy_seg1_l:5;
-	u8 ch_len_lgcy_seg0_m:3;
-
-	u8 rsvd_0_dummy_4bit:4;
-	u8 ch_len_lgcy_seg1_m:4;
-
-	u8 bw_det_seg0;
-	u8 bw_det_seg1;
-	u8 snr_lgy_patha;
-	u8 snr_lgy_pathb;
-	u8 snr_lgy_pathc;
-	u8 snr_lgy_pathd;
-
-	u8 snr_idx_lgy_pathb_l:2;
-	u8 tmax_idx_lgy_patha:3;
-	u8 snr_idx_lgy_patha:3;
-
-	u8 tmax_idx_lgy_pathc_l:1;
-	u8 snr_idx_lgy_pathc:3;
-	u8 tmax_idx_lgy_pathb:3;
-	u8 snr_idx_lgy_pathb_m:1;
-
-	u8 tmax_idx_lgy_pathd:3;
-	u8 snr_idx_lgy_pathd:3;
-	u8 tmax_idx_lgy_pathc_m:2;
-
-	u8 gd_phase_lgy_sub0_patha;
-	u8 gd_phase_lgy_sub1_patha;
-	u8 gd_phase_lgy_sub2_patha;
-	u8 gd_phase_lgy_sub3_patha;
-	u8 gd_phase_lgy_sub4_patha;
-	u8 gd_phase_lgy_sub5_patha;
-	u8 gd_phase_lgy_sub6_patha;
-	u8 gd_phase_lgy_sub7_patha;
-	u8 gd_phase_lgy_sub0_pathb;
-	u8 gd_phase_lgy_sub1_pathb;
-	u8 gd_phase_lgy_sub2_pathb;
-	u8 gd_phase_lgy_sub3_pathb;
-	u8 gd_phase_lgy_sub4_pathb;
-	u8 gd_phase_lgy_sub5_pathb;
-	u8 gd_phase_lgy_sub6_pathb;
-	u8 gd_phase_lgy_sub7_pathb;
-	u8 gd_phase_lgy_sub0_pathc;
-	u8 gd_phase_lgy_sub1_pathc;
-	u8 gd_phase_lgy_sub2_pathc;
-	u8 gd_phase_lgy_sub3_pathc;
-	u8 gd_phase_lgy_sub4_pathc;
-	u8 gd_phase_lgy_sub5_pathc;
-	u8 gd_phase_lgy_sub6_pathc;
-	u8 gd_phase_lgy_sub7_pathc;
-	u8 gd_phase_lgy_sub0_pathd;
-	u8 gd_phase_lgy_sub1_pathd;
-	u8 gd_phase_lgy_sub2_pathd;
-	u8 gd_phase_lgy_sub3_pathd;
-	u8 gd_phase_lgy_sub4_pathd;
-	u8 gd_phase_lgy_sub5_pathd;
-	u8 gd_phase_lgy_sub6_pathd;
-	u8 gd_phase_lgy_sub7_pathd;
-};
-
-struct physts_ie_19_info {
-	/*[DW0]*/
-	u8 tx_over_flow:1;
-	u8 rsvd_0_dummy_2bit:2;
-	u8 ie_hdr:5;
-
-	u8 ppdu_inpwrdbm_p20;
-	u8 ppdu_inpwrdbm_s20;
-	u8 ppdu_inpwrdbm_s40;
-	u8 ppdu_inpwrdbm_s80;
-	u8 ppdu_inpwrdbm_per20_1;
-	u8 ppdu_inpwrdbm_per20_2;
-	u8 ppdu_inpwrdbm_per20_3;
-	u8 ppdu_inpwrdbm_per20_4;
-	u8 edcca_rpt_cnt_p20;
-	u8 edcca_rpt_p20_max;
-	u8 edcca_rpt_p20_min;
-	u8 edcca_total_smp_cnt;
-	u8 edcca_rpt_cnt_s80;
-	u8 edcca_rpt_cnt_s80_max;
-	u8 edcca_rpt_cnt_s80_min;
-	u8 rsvd_1_dummy_8bit;
-	u8 pop_reg_pwr;
-	u8 pop_trig_pwr;
-	u8 early_drop_pwr;
-
-	u8 rsvd_2_dummy_8bit;
-	u8 rsvd_3_dummy_8bit;
-	u8 rsvd_4_dummy_8bit;
-	u8 rsvd_5_dummy_8bit;
-};
-
-struct physts_ie_19_info_type1 {
-	/*[DW0]*/
-	u8 tx_over_flow:1;
-	u8 rsvd_0_dummy_2bit:2;
-	u8 ie_hdr:5;
-
-	u8 ppdu_inpwrdbm_p20;
-	u8 ppdu_inpwrdbm_s20;
-	u8 ppdu_inpwrdbm_s40;
-	u8 ppdu_inpwrdbm_s80;
-	u8 ppdu_inpwrdbm_per20_1;
-	u8 ppdu_inpwrdbm_per20_2;
-	u8 ppdu_inpwrdbm_per20_3;
-	u8 ppdu_inpwrdbm_per20_4;
-	u8 edcca_rpt_cnt_p20;
-	u8 edcca_rpt_p20_max;
-	u8 edcca_rpt_p20_min;
-	u8 edcca_total_smp_cnt;
-	u8 edcca_rpt_cnt_s80;
-	u8 edcca_rpt_cnt_s80_max;
-	u8 edcca_rpt_cnt_s80_min;
-	u8 rsvd_1_dummy_8bit;
-	u8 pop_ref_pwr;
-	u8 pop_trig_pwr;
-	u8 early_drop_pwr;
-
-	u8 rsvd_2_dummy_8bit;
-	u8 rsvd_3_dummy_8bit;
-
-	u8 find_eof:1;
-	u8 rsvd_4_dummy_7bit:7;
-
-	u8 mpdu_stat_len;
-};
-
-struct physts_ie_20_user_info {
-	u8 ch_smo_n_block_lgcy_sub_3_seg_0:2;
-	u8 ch_smo_n_block_lgcy_sub_2_seg_0:2;
-	u8 ch_smo_n_block_lgcy_sub_1_seg_0:2;
-	u8 ch_smo_n_block_lgcy_sub_0_seg_0:2;
-
-	u8 ch_smo_en_non_lgcy_seg_0:4;
-	u8 ch_smo_en_lgcy_seg_0:4;
-
-	u8 rsvd_0_dummy_5bit:5;
-	u8 ch_smo_n_block_non_lgcy_seg_0:3;
-
-	u8 ch_len_non_lgcy_sts_0_seg_0;
-	u8 ch_len_non_lgcy_sts_1_seg_0;
-	u8 ch_len_non_lgcy_sts_2_seg_0;
-	u8 ch_len_non_lgcy_sts_3_seg_0;
-
-	u8 snr_idx_non_lgy_sts_2_seg_0_l:2;
-	u8 snr_idx_non_lgy_sts_1_seg_0:3;
-	u8 snr_idx_non_lgy_sts_0_seg_0:3;
-
-	u8 pdp_idx_non_lgcy_sts_1_seg_0_l:1;
-	u8 pdp_idx_non_lgcy_sts_0_seg_0:3;
-	u8 snr_idx_non_lgy_sts_3_seg_0:3;
-	u8 snr_idx_non_lgy_sts_2_seg_0_m:1;
-
-	u8 pdp_idx_non_lgcy_sts_3_seg_0:3;
-	u8 pdp_idx_non_lgcy_sts_2_seg_0:3;
-	u8 pdp_idx_non_lgcy_sts_1_seg_0_m:2;
-
-	u8 snr_non_lgy_sts_0_seg_0;
-	u8 snr_non_lgy_sts_1_seg_0;
-	u8 snr_non_lgy_sts_2_seg_0;
-	u8 snr_non_lgy_sts_3_seg_0;
-	u8 evm_ss_0_seg_0;
-	u8 evm_ss_1_seg_0;
-	u8 evm_ss_2_seg_0;
-	u8 evm_ss_3_seg_0;
-};
-
-struct physts_ie_20_cmn_info {
-	u8 ie_hdr_l;
-
-	u8 rsvd_0_dummy_4bit:4;
-	u8 ie_hdr_m:4;
-
-	u8 n_user;
-};
-
-struct physts_ie_20_21_info_type1{
-	u8 ie_hdr_l;
-
-	u8 user_idx_l:4;
-	u8 ie_hdr_m:4;
-
-	u8 rcfo_data_start_1:4;
-	u8 user_idx_m:4;
-
-	u8 rcfo_data_start_2;
-
-	u8 rcfo_data_end_1:4;
-	u8 rcfo_data_start_3:4;
-
-	u8 rcfo_data_end_2;
-
-	u8 ch_len_non_lgy_l:4;
-	u8 rcfo_data_end_3:4;
-
-	u8 rsvd_0_dummy_3bit:3;
-	u8 ch_len_non_lgy_m:5;
-
-	u8 snr_non_lgy_sts0_patha;
-	u8 snr_non_lgy_sts1_patha;
-	u8 snr_non_lgy_sts2_patha;
-	u8 snr_non_lgy_sts3_patha;
-
-	u8 snr_idx_non_lgy_sts2_patha_l:2;
-	u8 snr_idx_non_lgy_sts1_patha:3;
-	u8 snr_idx_non_lgy_sts0_patha:3;
-
-	u8 tmax_idx_non_lgy_sts1_patha_l:1;
-	u8 tmax_idx_non_lgy_sts0_patha:3;
-	u8 snr_idx_non_lgy_sts3_patha:3;
-	u8 snr_idx_non_lgy_sts2_patha_m:1;
-
-	u8 tmax_idx_non_lgy_sts3_patha:3;
-	u8 tmax_idx_non_lgy_sts2_patha:3;
-	u8 tmax_idx_non_lgy_sts1_patha_m:2;
-
-	u8 gd_phase_non_lgy_sts0_patha;
-	u8 gd_phase_non_lgy_sts1_patha;
-	u8 gd_phase_non_lgy_sts2_patha;
-	u8 gd_phase_non_lgy_sts3_patha;
-	u8 evm_ss0;
-	u8 noise_var_start_patha_l;
-	u8 noise_var_start_patha_m;
-	u8 noise_var_end_patha_l;
-	u8 noise_var_end_patha_m;
-
-	u8 snr_non_lgy_sts0_pathb;
-	u8 snr_non_lgy_sts1_pathb;
-	u8 snr_non_lgy_sts2_pathb;
-	u8 snr_non_lgy_sts3_pathb;
-
-	u8 snr_idx_non_lgy_sts2_pathb_l:2;
-	u8 snr_idx_non_lgy_sts1_pathb:3;
-	u8 snr_idx_non_lgy_sts0_pathb:3;
-
-	u8 tmax_idx_non_lgy_sts1_pathb_l:1;
-	u8 tmax_idx_non_lgy_sts0_pathb:3;
-	u8 snr_idx_non_lgy_sts3_pathb:3;
-	u8 snr_idx_non_lgy_sts2_pathb_m:1;
-
-	u8 tmax_idx_non_lgy_sts3_pathb:3;
-	u8 tmax_idx_non_lgy_sts2_pathb:3;
-	u8 tmax_idx_non_lgy_sts1_pathb_m:2;
-
-	u8 gd_phase_non_lgy_sts0_pathb;
-	u8 gd_phase_non_lgy_sts1_pathb;
-	u8 gd_phase_non_lgy_sts2_pathb;
-	u8 gd_phase_non_lgy_sts3_pathb;
-	u8 evm_ss1;
-	u8 noise_var_start_pathb_l;
-	u8 noise_var_start_pathb_m;
-	u8 noise_var_end_pathb_l;
-	u8 noise_var_end_pathb_m;
-
-	u8 snr_non_lgy_sts0_pathc;
-	u8 snr_non_lgy_sts1_pathc;
-	u8 snr_non_lgy_sts2_pathc;
-	u8 snr_non_lgy_sts3_pathc;
-
-	u8 snr_idx_non_lgy_sts2_pathc_l:2;
-	u8 snr_idx_non_lgy_sts1_pathc:3;
-	u8 snr_idx_non_lgy_sts0_pathc:3;
-
-	u8 tmax_idx_non_lgy_sts1_pathc_l:1;
-	u8 tmax_idx_non_lgy_sts0_pathc:3;
-	u8 snr_idx_non_lgy_sts3_pathc:3;
-	u8 snr_idx_non_lgy_sts2_pathc_m:1;
-
-	u8 tmax_idx_non_lgy_sts3_pathc:3;
-	u8 tmax_idx_non_lgy_sts2_pathc:3;
-	u8 tmax_idx_non_lgy_sts1_pathc_m:2;
-
-	u8 gd_phase_non_lgy_sts0_pathc;
-	u8 gd_phase_non_lgy_sts1_pathc;
-	u8 gd_phase_non_lgy_sts2_pathc;
-	u8 gd_phase_non_lgy_sts3_pathc;
-	u8 evm_ss2;
-	u8 noise_var_start_pathc_l;
-	u8 noise_var_start_pathc_m;
-	u8 noise_var_end_pathc_l;
-	u8 noise_var_end_pathc_m;
-
-	u8 snr_non_lgy_sts0_pathd;
-	u8 snr_non_lgy_sts1_pathd;
-	u8 snr_non_lgy_sts2_pathd;
-	u8 snr_non_lgy_sts3_pathd;
-
-	u8 snr_idx_non_lgy_sts2_pathd_l:2;
-	u8 snr_idx_non_lgy_sts1_pathd:3;
-	u8 snr_idx_non_lgy_sts0_pathd:3;
-
-	u8 tmax_idx_non_lgy_sts1_pathd_l:1;
-	u8 tmax_idx_non_lgy_sts0_pathd:3;
-	u8 snr_idx_non_lgy_sts3_pathd:3;
-	u8 snr_idx_non_lgy_sts2_pathd_m:1;
-
-	u8 tmax_idx_non_lgy_sts3_pathd:3;
-	u8 tmax_idx_non_lgy_sts2_pathd:3;
-	u8 tmax_idx_non_lgy_sts1_pathd_m:2;
-
-	u8 gd_phase_non_lgy_sts0_pathd;
-	u8 gd_phase_non_lgy_sts1_pathd;
-	u8 gd_phase_non_lgy_sts2_pathd;
-	u8 gd_phase_non_lgy_sts3_pathd;
-	u8 evm_ss3;
-	u8 noise_var_start_pathd_l;
-	u8 noise_var_start_pathd_m;
-	u8 noise_var_end_pathd_l;
-	u8 noise_var_end_pathd_m;
-};
-
-struct physts_ie_21_user_info {
-	u8 ch_smo_n_block_lgcy_sub_3_seg_1:2;
-	u8 ch_smo_n_block_lgcy_sub_2_seg_1:2;
-	u8 ch_smo_n_block_lgcy_sub_1_seg_1:2;
-	u8 ch_smo_n_block_lgcy_sub_0_seg_1:2;
-
-	u8 ch_smo_en_non_lgcy_seg_1:4;
-	u8 ch_smo_en_lgcy_seg_1:4;
-
-	u8 rsvd_0_dummy_5bit:5;
-	u8 ch_smo_n_block_non_lgcy_seg_1:3;
-
-	u8 ch_len_non_lgcy_sts_0_seg_1;
-	u8 ch_len_non_lgcy_sts_1_seg_1;
-	u8 ch_len_non_lgcy_sts_2_seg_1;
-	u8 ch_len_non_lgcy_sts_3_seg_1;
-
-	u8 snr_idx_non_lgy_sts_2_seg_1_l:2;
-	u8 snr_idx_non_lgy_sts_1_seg_1:3;
-	u8 snr_idx_non_lgy_sts_0_seg_1:3;
-
-	u8 pdp_idx_non_lgcy_sts_1_seg_1_l:1;
-	u8 pdp_idx_non_lgcy_sts_0_seg_1:3;
-	u8 snr_idx_non_lgy_sts_3_seg_1:3;
-	u8 snr_idx_non_lgy_sts_2_seg_1_m:1;
-
-	u8 pdp_idx_non_lgcy_sts_3_seg_1:3;
-	u8 pdp_idx_non_lgcy_sts_2_seg_1:3;
-	u8 pdp_idx_non_lgcy_sts_1_seg_1_m:2;
-
-	u8 snr_non_lgy_sts_0_seg_1;
-	u8 snr_non_lgy_sts_1_seg_1;
-	u8 snr_non_lgy_sts_2_seg_1;
-	u8 snr_non_lgy_sts_3_seg_1;
-	u8 evm_ss_0_seg_1;
-	u8 evm_ss_1_seg_1;
-	u8 evm_ss_2_seg_1;
-	u8 evm_ss_3_seg_1;
-};
-
-struct physts_ie_21_cmn_info {
-	u8 ie_hdr_l;
-
-	u8 rsvd_0_dummy_4bit:4;
-	u8 ie_hdr_m:4;
-
-	u8 n_user;
-};
-
-struct physts_ie_22_user_info {
-	u8 pw_norm_lgcy_path0;
-	u8 pw_norm_lgcy_path1;
-	u8 pw_norm_lgcy_path2;
-	u8 pw_norm_lgcy_path3;
-	u8 ant_wgt_lgcy_path0;
-	u8 ant_wgt_lgcy_path1;
-	u8 ant_wgt_lgcy_path2;
-	u8 ant_wgt_lgcy_path3;
-};
-
-struct physts_ie_22_cmn_info {
-	u8 ie_hdr_l;
-
-	u8 rsvd_0_dummy_4bit:4;
-	u8 ie_hdr_m:4;
-
-	u8 n_user;
-
-	u8 rsvd_0_dummy_8bit;
-	u8 rsvd_1_dummy_8bit;
-	u8 rsvd_2_dummy_8bit;
-	u8 rsvd_3_dummy_8bit;
-	u8 rsvd_4_dummy_8bit;
-
-	u8 pw_norm_lgcy_path0;
-	u8 pw_norm_lgcy_path1;
-	u8 pw_norm_lgcy_path2;
-	u8 pw_norm_lgcy_path3;
-	u8 ant_wgt_lgcy_path0;
-	u8 ant_wgt_lgcy_path1;
-	u8 ant_wgt_lgcy_path2;
-	u8 ant_wgt_lgcy_path3;
-};
-
-struct physts_ie_24_info {
-	/*[DW0]*/
-	u8 aci_indicator_a:1;
-	u8 pre_agc_step_a:2;
-	u8 ie_hdr:5;
-
-	u8 ht_fine_gain_code_tia_a:1;
-	u8 l_fine_gain_code_tia_a:1;
-	u8 pre_gain_code_tia_a:1;
-	u8 tia_shrink_indicator_a:1;
-	u8 ht_fine_agc_step_a:2;
-	u8 l_fine_agc_step_a:2;
-
-	u8 pre_gain_code_a;
-	u8 l_fine_gain_code_a;
-	u8 ht_fine_gain_code_a;
-	u8 l_dagc_a;
-	u8 ht_dagc_a;
-	u8 pre_ibpwrdbm_a;
-	u8 pre_wbpwrdbm_a;
-	u8 l_ibpwrdbm_a;
-	u8 l_wbpwrdbm_a;
-	u8 ht_ibpwrdbm_a;
-	u8 ht_wbpwrdbm_a;
-	u8 l_dig_ibpwrdbm_a;
-	u8 ht_dig_ibpwrdbm_a;
-	u8 lna_inpwrdbm_a;
-
-	u8 aci_det:1;
-	u8 aci2sig_db:7;
-
-	u8 sb5m_ratio_0;
-	u8 sb5m_ratio_1;
-	u8 sb5m_ratio_2;
-	u8 sb5m_ratio_3;
-
-	u8 rsvd_0_dummy_8bit;
-	u8 rsvd_1_dummy_8bit;
-	u8 rsvd_2_dummy_8bit;
-};
-
-struct physts_ie_25_info {
-	/*[DW0]*/
-	u8 aci_indicator_b:1;
-	u8 pre_agc_step_b:2;
-	u8 ie_hdr:5;
-
-	u8 ht_fine_gain_code_tia_b:1;
-	u8 l_fine_gain_code_tia_b:1;
-	u8 pre_gain_code_tia_b:1;
-	u8 tia_shrink_indicator_b:1;
-	u8 ht_fine_agc_step_b:2;
-	u8 l_fine_agc_step_b:2;
-
-	u8 pre_gain_code_b;
-	u8 l_fine_gain_code_b;
-	u8 ht_fine_gain_code_b;
-	u8 l_dagc_b;
-	u8 ht_dagc_b;
-	u8 pre_ibpwrdbm_b;
-	u8 pre_wbpwrdbm_b;
-	u8 l_ibpwrdbm_b;
-	u8 l_wbpwrdbm_b;
-	u8 ht_ibpwrdbm_b;
-	u8 ht_wbpwrdbm_b;
-	u8 l_dig_ibpwrdbm_b;
-	u8 ht_dig_ibpwrdbm_b;
-	u8 lna_inpwrdbm_b;
-
-	u8 aci_det:1;
-	u8 aci2sig_db:7;
-
-	u8 sb5m_ratio_0;
-	u8 sb5m_ratio_1;
-	u8 sb5m_ratio_2;
-	u8 sb5m_ratio_3;
-
-	u8 rsvd_0_dummy_8bit;
-	u8 rsvd_1_dummy_8bit;
-	u8 rsvd_2_dummy_8bit;
-};
-
-struct physts_ie_26_info {
-	/*[DW0]*/
-	u8 aci_indicator_c:1;
-	u8 pre_agc_step_c:2;
-	u8 ie_hdr:5;
-
-	u8 ht_fine_gain_code_tia_c:1;
-	u8 l_fine_gain_code_tia_c:1;
-	u8 pre_gain_code_tia_c:1;
-	u8 tia_shrink_indicator_c:1;
-	u8 ht_fine_agc_step_c:2;
-	u8 l_fine_agc_step_c:2;
-
-	u8 pre_gain_code_c;
-	u8 l_fine_gain_code_c;
-	u8 ht_fine_gain_code_c;
-	u8 l_dagc_c;
-	u8 ht_dagc_c;
-	u8 pre_ibpwrdbm_c;
-	u8 pre_wbpwrdbm_c;
-	u8 l_ibpwrdbm_c;
-	u8 l_wbpwrdbm_c;
-	u8 ht_ibpwrdbm_c;
-	u8 ht_wbpwrdbm_c;
-	u8 l_dig_ibpwrdbm_c;
-	u8 ht_dig_ibpwrdbm_c;
-	u8 lna_inpwrdbm_c;
-
-	u8 aci_det:1;
-	u8 aci2sig_db:7;
-
-	u8 sb5m_ratio_0;
-	u8 sb5m_ratio_1;
-	u8 sb5m_ratio_2;
-	u8 sb5m_ratio_3;
-
-	u8 rsvd_0_dummy_8bit;
-	u8 rsvd_1_dummy_8bit;
-	u8 rsvd_2_dummy_8bit;
-};
-
-struct physts_ie_27_info {
-	/*[DW0]*/
-	u8 aci_indicator_d:1;
-	u8 pre_agc_step_d:2;
-	u8 ie_hdr:5;
-
-	u8 ht_fine_gain_code_tia_d:1;
-	u8 l_fine_gain_code_tia_d:1;
-	u8 pre_gain_code_tia_d:1;
-	u8 tia_shrink_indicator_d:1;
-	u8 ht_fine_agc_step_d:2;
-	u8 l_fine_agc_step_d:2;
-
-	u8 pre_gain_code_d;
-	u8 l_fine_gain_code_d;
-	u8 ht_fine_gain_code_d;
-	u8 l_dagc_d;
-	u8 ht_dagc_d;
-	u8 pre_ibpwrdbm_d;
-	u8 pre_wbpwrdbm_d;
-	u8 l_ibpwrdbm_d;
-	u8 l_wbpwrdbm_d;
-	u8 ht_ibpwrdbm_d;
-	u8 ht_wbpwrdbm_d;
-	u8 l_dig_ibpwrdbm_d;
-	u8 ht_dig_ibpwrdbm_d;
-	u8 lna_inpwrdbm_d;
-
-	u8 aci_det:1;
-	u8 aci2sig_db:7;
-
-	u8 sb5m_ratio_0;
-	u8 sb5m_ratio_1;
-	u8 sb5m_ratio_2;
-	u8 sb5m_ratio_3;
-
-	u8 rsvd_0_dummy_8bit;
-	u8 rsvd_1_dummy_8bit;
-	u8 rsvd_2_dummy_8bit;
-};
-
-struct physts_ie_28_info {
-	/*[DW0]*/
-	u8 ant_weight_a_l:1;
-	u8 rsvd_0_dummy_2bit:2;
-	u8 ie_hdr:5;
-
-	u8 ant_weight_a_m;
-	u8 h3_real_a;
-	u8 h3_imag_a;
-	u8 h4_real_a;
-	u8 h4_imag_a;
-	u8 h5_real_a;
-	u8 h5_imag_a;
-	u8 h6_real_a;
-	u8 h6_imag_a;
-	u8 h7_real_a;
-	u8 h7_imag_a;
-	u8 h8_real_a;
-	u8 h8_imag_a;
-	u8 h9_real_a;
-	u8 h9_imag_a;
-	u8 h10_real_a;
-	u8 h10_imag_a;
-	u8 h11_real_a;
-	u8 h11_imag_a;
-	u8 h12_real_a;
-	u8 h12_imag_a;
-	u8 h13_real_a;
-	u8 h13_imag_a;
-	u8 h14_real_a;
-	u8 h14_imag_a;
-	u8 h15_real_a;
-	u8 h15_imag_a;
-	u8 h16_real_a;
-	u8 h16_imag_a;
-	u8 h17_real_a;
-	u8 h17_imag_a;
-};
-
-struct physts_ie_29_info {
-	/*[DW0]*/
-	u8 ant_weight_b_l:1;
-	u8 rsvd_0_dummy_2bit:2;
-	u8 ie_hdr:5;
-
-	u8 ant_weight_b_m;
-	u8 h3_real_b;
-	u8 h3_imag_b;
-	u8 h4_real_b;
-	u8 h4_imag_b;
-	u8 h5_real_b;
-	u8 h5_imag_b;
-	u8 h6_real_b;
-	u8 h6_imag_b;
-	u8 h7_real_b;
-	u8 h7_imag_b;
-	u8 h8_real_b;
-	u8 h8_imag_b;
-	u8 h9_real_b;
-	u8 h9_imag_b;
-	u8 h10_real_b;
-	u8 h10_imag_b;
-	u8 h11_real_b;
-	u8 h11_imag_b;
-	u8 h12_real_b;
-	u8 h12_imag_b;
-	u8 h13_real_b;
-	u8 h13_imag_b;
-	u8 h14_real_b;
-	u8 h14_imag_b;
-	u8 h15_real_b;
-	u8 h15_imag_b;
-	u8 h16_real_b;
-	u8 h16_imag_b;
-	u8 h17_real_b;
-	u8 h17_imag_b;
-};
-
-struct physts_ie_30_info {
-	/*[DW0]*/
-	u8 ant_weight_c_l:1;
-	u8 rsvd_0_dummy_2bit:2;
-	u8 ie_hdr:5;
-
-	u8 ant_weight_c_m;
-	u8 h3_real_c;
-	u8 h3_imag_c;
-	u8 h4_real_c;
-	u8 h4_imag_c;
-	u8 h5_real_c;
-	u8 h5_imag_c;
-	u8 h6_real_c;
-	u8 h6_imag_c;
-	u8 h7_real_c;
-	u8 h7_imag_c;
-	u8 h8_real_c;
-	u8 h8_imag_c;
-	u8 h9_real_c;
-	u8 h9_imag_c;
-	u8 h10_real_c;
-	u8 h10_imag_c;
-	u8 h11_real_c;
-	u8 h11_imag_c;
-	u8 h12_real_c;
-	u8 h12_imag_c;
-	u8 h13_real_c;
-	u8 h13_imag_c;
-	u8 h14_real_c;
-	u8 h14_imag_c;
-	u8 h15_real_c;
-	u8 h15_imag_c;
-	u8 h16_real_c;
-	u8 h16_imag_c;
-	u8 h17_real_c;
-	u8 h17_imag_c;
-};
-
-struct physts_ie_31_info {
-	/*[DW0]*/
-	u8 ant_weight_d_l:1;
-	u8 rsvd_0_dummy_2bit:2;
-	u8 ie_hdr:5;
-
-	u8 ant_weight_d_m;
-	u8 h3_real_d;
-	u8 h3_imag_d;
-	u8 h4_real_d;
-	u8 h4_imag_d;
-	u8 h5_real_d;
-	u8 h5_imag_d;
-	u8 h6_real_d;
-	u8 h6_imag_d;
-	u8 h7_real_d;
-	u8 h7_imag_d;
-	u8 h8_real_d;
-	u8 h8_imag_d;
-	u8 h9_real_d;
-	u8 h9_imag_d;
-	u8 h10_real_d;
-	u8 h10_imag_d;
-	u8 h11_real_d;
-	u8 h11_imag_d;
-	u8 h12_real_d;
-	u8 h12_imag_d;
-	u8 h13_real_d;
-	u8 h13_imag_d;
-	u8 h14_real_d;
-	u8 h14_imag_d;
-	u8 h15_real_d;
-	u8 h15_imag_d;
-	u8 h16_real_d;
-	u8 h16_imag_d;
-	u8 h17_real_d;
-	u8 h17_imag_d;
-};
-
- /*@--------------------------[Prptotype]-------------------------------------*/
-#endif
diff --git a/os/board/rtl8720e/src/component/wifi/driver/src/hal/phy_g6/bb/halbb_physts_ie_l_endian.h b/os/board/rtl8720e/src/component/wifi/driver/src/hal/phy_g6/bb/halbb_physts_ie_l_endian.h
deleted file mode 100644
index 341c2cf22..000000000
--- a/os/board/rtl8720e/src/component/wifi/driver/src/hal/phy_g6/bb/halbb_physts_ie_l_endian.h
+++ /dev/null
@@ -1,1517 +0,0 @@
-/******************************************************************************
- *
- * Copyright(c) 2007 - 2020  Realtek Corporation.
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of version 2 of the GNU General Public License as
- * published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
- * more details.
- *
- * The full GNU General Public License is included in this distribution in the
- * file called LICENSE.
- *
- * Contact Information:
- * wlanfae <wlanfae@realtek.com>
- * Realtek Corporation, No. 2, Innovation Road II, Hsinchu Science Park,
- * Hsinchu 300, Taiwan.
- *
- * Larry Finger <Larry.Finger@lwfinger.net>
- *
- *****************************************************************************/
-#ifndef __HALBB_PHYSTS_IE_L_ENDIAN_H__
-#define __HALBB_PHYSTS_IE_L_ENDIAN_H__
-
- /*@--------------------------[Define] ---------------------------------------*/
-
- /*@--------------------------[Enum]------------------------------------------*/
- 
- /*@--------------------------[Structure]-------------------------------------*/
-
-struct physts_hdr_info {
-	u8 ie_bitmap_select: 5;
-	u8 rsvd_0:1;
-	u8 null_tb_ppdu:1;
-	u8 is_valid:1;		/*valid: total content length <= 1024 bytes*/
-	u8 physts_total_length;	/*total length(unit: 8byte)*/
-	u8 rsvd_1;
-	u8 rssi_avg_td;		/*U(8,1) RSSI=dBm+110. ex:-30dBm->RSSI:80%*/
-	u8 rssi_td[4];
-};
-
-enum bb_physts_hdr_t {
-	HDR_TYPE1 = 1, /*5bit fix length*/
-	HDR_TYPE2 = 2 /*12bit variable length*/
-};
-
-struct physts_ie_0_info {
-	/*[DW0]*/
-	u8 ie_hdr:5;
-	u8 pop_idx:2;
-	u8 rpl_l:1;
-
-	u8 rpl_m;
-	u8 cca_time;
-	u8 antwgt_gain_diff:5;
-	u8 cck_hw_antsw_occur_a:1;
-	u8 cck_hw_antsw_occur_b:1;
-	u8 cck_hw_antsw_occur_c:1;
-	/*[DW1]*/
-	u8 avg_idle_noise_pwr;
-	u8 avg_cfo_l;
-	u8 avg_cfo_m:4;
-	u8 coarse_cfo_l:4;
-	u8 coarse_cfo_m;
-	/*[DW2]*/
-	u8 rxevm_hdr;
-	u8 rxevm_pld;
-	u8 sig_len_l;
-	u8 sig_len_m;
-	/*[DW3]*/
-	u8 antdiv_rslt_a:1;
-	u8 antdiv_rslt_b:1 ;
-	u8 antdiv_rslt_c:1;
-	u8 antdiv_rslt_d:1;
-	u8 preamble_type:1;
-	u8 sync_mode:1;
-	u8 rsvd_1_dummy_1bit:1;
-	u8 cck_hw_antsw_occur_d:1;
-
-	u8 dagc_a:5;
-	u8 dagc_b_l:3;
-
-	u8 dagc_b_m:2;
-	u8 dagc_c:5;
-	u8 dagc_d_l:1;
-
-	u8 dagc_d_m:4;
-	u8 rx_path_en_bitmap:4;
-};
-
-struct physts_ie_1_info {
-	/*[DW0]*/
-	u8 ie_hdr:5;
-	u8 pop_idx:2;
-	u8 rsvd_0_dummy_1bit:1;
-	u8 rssi_avg_fd;
-	u8 ch_idx_seg0;
-	u8 rxsc:4;
-	u8 rx_path_en_bitmap:4;
-	/*[DW1]*/
-	u8 avg_idle_noise_pwr;
-	u8 avg_cfo_seg0_l;
-
-	u8 avg_cfo_seg0_m:4;
-	u8 avg_cfo_premb_seg0_l:4;
-
-	u8 avg_cfo_premb_seg0_m;
-	/*[DW2]*/
-	u8 avg_snr:6;
-	u8 ant_idx_a:1;
-	u8 ant_idx_b:1;
-	u8 evm_max;
-	u8 evm_min;
-	u8 pdp_he_ltf_and_gi_type:3;
-	u8 is_su:1;
-	u8 is_ldpc:1;
-	u8 is_ndp:1;
-	u8 is_stbc:1;
-	u8 grant_bt:1;
-	/*[DW3]*/
-	u8 bf_gain_max:7;
-	u8 is_awgn:1;
-	u8 is_bf:1;
-	u8 avg_cn_seg0:7;
-	u8 sigval_below_th_tone_cnt_seg0;
-	u8 cn_excess_th_tone_cnt_seg0;
-	/*[DW4]*/
-	u8 pwr_to_cca_l;
-	u8 pwr_to_cca_m;
-	u8 cca_to_agc;
-	u8 cca_to_sbd;
-	/*[DW5]*/
-	u8 rsvd_1_dummy_1bit:1;
-	u8 edcca_rpt_cnt:7;
-	u8 edcca_total_smp_cnt:7;
-	u8 edcca_rpt_curr_bw_max_l:1;
-	u8 edcca_rpt_curr_bw_max_m:6;
-	u8 edcca_rpt_curr_bw_min_l:2;
-	u8 edcca_rpt_curr_bw_min_m:5;
-	u8 bw_idx:3; /*0~6: 5, 10, 20, 40, 80, 160, 80_80*/
-};
-
-struct physts_ie_1_info_type1 {
-	/*[DW0]*/
-	u8 ie_hdr:5;
-	u8 pop_idx:2;
-	u8 rsvd_0_dummy_1bit:1;
-	u8 rssi_avg_fd;
-	u8 ch_idx_seg0;
-	u8 rxsc:4;
-	u8 rx_path_en_bitmap:4;
-	/*[DW1]*/
-	u8 avg_idle_noise_pwr;
-	u8 td_p_fd_tracking_cfo_seg0_l;
-	u8 td_p_fd_tracking_cfo_seg0_m:4;
-	u8 avg_cfo_premb_seg0_l:4;
-	u8 avg_cfo_premb_seg0_m;
-	/*[DW2]*/
-	u8 avg_snr:6;
-	u8 ant_idx_a:1;
-	u8 ant_idx_b:1;
-	u8 evm_max;
-	u8 evm_min;
-	u8 pdp_he_ltf_and_gi_type:3;
-	u8 is_su:1;
-	u8 is_ldpc:1;
-	u8 is_ndp:1;
-	u8 is_stbc:1;
-	u8 grant_bt:1;
-	/*[DW3]*/
-	u8 bf_gain_max:7;
-	u8 is_awgn:1;
-	u8 is_bf:1;
-	u8 avg_cn_seg0:7;
-	u8 sigval_below_th_tone_cnt_seg0;
-	u8 cn_excess_th_tone_cnt_seg0;
-	/*[DW4]*/
-	u8 pwr_to_cca_l;
-	u8 pwr_to_cca_m;
-	u8 cca_to_agc;
-	u8 cca_to_sbd;
-	/*[DW5]*/
-	u8 rsvd_1_dummy_1bit:1;
-	u8 edcca_rpt_cnt:7;
-	u8 edcca_total_smp_cnt:7;
-	u8 edcca_rpt_curr_bw_max_l:1;
-	u8 edcca_rpt_curr_bw_max_m:6;
-	u8 edcca_rpt_curr_bw_min_l:2;
-	u8 edcca_rpt_curr_bw_min_m:5;
-	u8 bw_idx:3; /*0~6: 5, 10, 20, 40, 80, 160, 80_80*/
-	/*[DW6]*/
-	u8 ftm_t_off_l;
-	u8 ftm_t_off_m:4;
-	u8 rsvd_2_dummy:4;
-	u8 brk_src_idx;
-	u8 outer_buf_2sts;
-	/*[DW7]*/
-	u8 bt_gnt_tx_at_cca:1;
-	u8 bt_gnt_tx_cnt:3;
-	u8 bt_gnt_rx_at_cca:1;
-	u8 bt_gnt_rx_cnt:3;
-	u8 rsvd_3_dummy_1;
-	u8 rsvd_3_dummy_2;
-	u8 rsvd_3_dummy_3;
-};
-
-struct physts_ie_2_info {
-	/*[DW0]*/
-	u8 ie_hdr:5;
-	u8 max_nsts:3;
-
-	u8 midamble:1;
-	u8 ltf_type:2 ;
-	u8 gi:2;
-	u8 is_mu_mimo:1;
-	u8 c_cfo_i_l:2;
-
-	u8 c_cfo_i_m2;
-	u8 c_cfo_i_m1;
-	/*[DW1]*/
-	u8 rx_info_1;
-
-	u8 rx_state_feq:5;
-	u8 is_dl_ofdma:1;
-	u8 c_cfo_q_l:2;
-
-	u8 c_cfo_q_m2;
-	u8 c_cfo_q_m1;
-	/*[DW2]*/
-	u8 est_cmped_phase;
-
-	u8 is_dcm:1;
-	u8 is_doppler:1;
-	u8 pkt_extension:3;
-	u8 rsvd_0_dummy_1bit:1;
-	u8 f_cfo_i_l:2;
-
-	u8 f_cfo_i_m2;
-	u8 f_cfo_i_m1;
-	/*[DW3]*/
-	u8 n_ltf:3;
-	u8 n_sym_l:5;
-
-	u8 n_sym_m:6;
-	u8 f_cfo_q_l:2;
-
-	u8 f_cfo_q_m2;
-	u8 f_cfo_q_m1;
-};
-
-struct physts_ie_3_info {
-	/*[DW0]*/
-	u8 ie_hdr:5;
-	u8 rsvd_0_dummy_3bit:3;
-
-	u8 avg_cn_seg1:7;
-	u8 rsvd_1_dummy_1bit:1;
-
-	u8 sigval_below_th_tone_cnt_seg1;
-	u8 cn_excess_th_tone_cnt_seg1;
-
-	/*[DW1]*/
-	u8 avg_cfo_seg1_l;
-
-	u8 avg_cfo_seg1_m:4;
-	u8 rsvd_2_dummy_4bit:4;
-
-	u8 avg_cfo_premb_seg1_l;
-
-	u8 avg_cfo_premb_seg1_m:4;
-	u8 rsvd_3_dummy_4bit:4;
-
-	/*[DW2]*/
-	u8 est_cmped_phase_seg1;
-
-	u8 avg_snr_seg1:6;
-	u8 c_cfo_i_seg1_l:2;
-
-	u8 c_cfo_i_seg1_m2;
-	u8 c_cfo_i_seg1_m1;
-
-	u8 c_cfo_q_seg1_l2;
-	u8 c_cfo_q_seg1_l1;
-
-	u8 c_cfo_q_seg1_m:2;
-	u8 f_cfo_i_seg1_l:6;
-
-	u8 f_cfo_i_seg1_lm;
-
-	u8 f_cfo_i_seg1_m:4;
-	u8 f_cfo_q_seg1_l:4;
-
-	u8 f_cfo_q_seg1_lm;
-
-	u8 f_cfo_q_seg1_m:6;
-	u8 rsvd_5_dummy_10bit_l:2;
-
-	u8 rsvd_5_dummy_10bit_m;
-	u8 ch_idx_seg1;
-	u8 evm_max_seg1;
-	u8 evm_min_seg1;
-	u8 rsvd_6_dummy_8bit;
-};
-
-/*physts_ie_4_to_7_info*/
-struct physts_ie_4_to_7_info {
-	/*[DW0]*/
-	u8 ie_hdr:5;
-	u8 ant_idx:3;
-
-	u8 sig_val_y;
-	u8 rf_gain_idx;
-
-	u8 rf_tia_gain_idx:1;
-	u8 tia_shrink_indicator:1;
-	u8 snr_lgy:6;
-
-	/*[DW0]*/
-	u8 evm_ss_y;
-
-	u8 td_ant_weight:7;
-	u8 ant_idx_msb:1;
-
-	u8 dc_est_re;
-	u8 dc_est_im;
-};
-
-struct physts_ie_8_ch_info {
-	/*[DW0]*/
-	u8 ie_hdr_l;
-
-	u8 ie_hdr_m:4;
-	u8 rxsc:4;
-
-	u8 n_rx:3;
-	u8 n_sts:3;
-	u8 ch_info_len_l:2;
-
-	u8 ch_info_len_m;
-	/*[DW1]*/
-	u8 evm_1_sts;
-	u8 evm_2_sts;
-	u8 avg_idle_noise_pwr;
-
-	u8 is_ch_info_len_valid:1;
-	u8 rsvd_0_dummy_7bit:7;
-	u8 rsvd_1[8];
-	u8 rsvd_2[8];
-};
-
-struct physts_ie_8_ch_raw_info {
-	u8 *channel_info_raw;
-};
-
-struct physts_ie_9_lgcy_info {
-	/*[DW0]*/
-	u8 ie_hdr:5;
-	u8 l_sig_l:3;
-
-	u8 l_sig_lm;
-
-	u8 l_sig_m:6;
-	u8 rsvd_0_dummy_2bit:2;
-
-	u8 rsvd_0_dummy_8bit;
-	u8 rsvd_1_dummy_8bit;
-	u8 rsvd_2_dummy_8bit;
-	u8 rsvd_3_dummy_8bit;
-	u8 rsvd_4_dummy_8bit;
-
-};
-
-struct physts_ie_9_vht_info {
-	/*[DW0]*/
-	u8 ie_hdr:5;
-	u8 l_sig_l:3;
-
-	u8 l_sig_lm;
-
-	u8 l_sig_m:6;
-	u8 sig_a1_l:2;
-
-	u8 sig_a1_lm2;
-	u8 sig_a1_lm1;
-
-	u8 sig_a1_m:6;
-	u8 sig_a2_l:2;
-
-	u8 sig_a2_m;
-
-	u8 rsvd_0_dummy_8bit;
-};
-
-struct physts_ie_9_he_info {
-	/*[DW0]*/
-	u8 ie_hdr:5;
-	u8 l_sig_l:3;
-
-	u8 l_sig_lm;
-
-	u8 l_sig_m:6;
-	u8 sig_a1_l:2;
-
-	u8 sig_a1_m3;
-	u8 sig_a1_m2;
-	u8 sig_a1_m1;
-
-	u8 sig_a2_l;
-	u8 sig_a2_m;
-};
-
-struct physts_ie_10_sigb_info {
-	u8 *sigb_raw_data_bits_addr;
-};
-
-struct physts_ie_10_cmn_info {
-	/*[DW0]*/
-	u8 ie_hdr_l;
-
-	u8 ie_hdr_m:4;
-	u8 rsvd_0_dummy_4bit:4;
-
-	u8 rsvd_0_dummy_8bit;
-	u8 rsvd_1_dummy_8bit;
-	u8 rsvd_2_dummy_8bit;
-	u8 rsvd_3_dummy_8bit;
-	u8 rsvd_4_dummy_8bit;
-	u8 rsvd_5_dummy_8bit;
-
-};
-
-struct physts_ie_11_pkt_info {
-	/*[DW0]*/
-	u8 pkt_format:2;
-	u8 l_rate:3;
-	u8 l_length_l:3;
-
-	u8 l_length_lm;
-
-	u8 l_length_m:1;
-	u8 info_type_0:7;
-
-	u8 info_type_1;
-	u8 info_type_2;
-	u8 info_type_3;
-
-	u8 info_type_4:3;
-	u8 time_stamp_l:5;
-
-	u8 time_stamp_m:6;
-	u8 state:2;
-};
-
-struct physts_ie_11_pkt_info_type1 {
-	/*[DW0/1]*/
-	u8 pkt_format:3;
-	u8 pop_idx:2;
-	u8 mac_frame_control_1:3;
-
-	u8 mac_frame_control_2;
-
-	u8 mac_frame_control_3:1;
-	u8 information_type_1:7;
-
-	u8 information_type_2;
-	u8 information_type_3;
-	u8 information_type_4;
-
-	u8 information_type_5:3;
-	u8 time_stamp_l:5;
-
-	u8 time_stamp_m:6;
-	u8 state:2;
-};
-
-struct physts_ie_11_info {
-	/*[DW0]*/
-	u8 ie_hdr:5;
-	u8 l_sig_l:3;
-
-	u8 l_sig_lm;
-
-	u8 l_sig_m:6;
-	u8 sig_a1_l:2;
-
-	u8 sig_a1_m3;
-	u8 sig_a1_m2;
-	u8 sig_a1_m1;
-
-	u8 sig_a2_l;
-	u8 sig_a2_m;
-
-	u8 time_stamp_l;
-
-	u8 time_stamp_m:3;
-	u8 rx_pkt_info_idx:4;
-	u8 tx_pkt_info_idx_l:1;
-
-	u8 tx_pkt_info_idx_m:3;
-	u8 rsvd_0_dummy_5bit:5;
-
-	u8 rsvd_0_dummy_8bit;
-	u8 rsvd_1_dummy_8bit;
-	u8 rsvd_2_dummy_8bit;
-	u8 rsvd_3_dummy_8bit;
-	u8 rsvd_4_dummy_8bit;
-
-	struct physts_ie_11_pkt_info pkt_info_rx_i[10];
-	struct physts_ie_11_pkt_info pkt_info_tx_i[10];
-};
-
-struct physts_ie_11_info_type1 {
-	/*[DW0]*/
-	u8 ie_hdr:5;
-	u8 time_stamp_l:3;
-	u8 time_stamp_m;
-	u8 rx_pktinfo_idx:4;
-	u8 tx_pktinfo_idx:4;
-	u8 rsvd_0_dummy_8bit;
-	/*[DW1]*/
-	u8 rsvd_1_dummy_8bit;
-	u8 rsvd_2_dummy_8bit;
-	u8 rsvd_3_dummy_8bit;
-	u8 rsvd_4_dummy_8bit;
-	/*[DW2/3]*/
-	struct physts_ie_11_pkt_info_type1 pkt_info_rx_i[10];
-	struct physts_ie_11_pkt_info_type1 pkt_info_tx_i[10];
-};
-
-struct physts_ie_12_user_info {
-	u8 sig_val_ss0_seg_cr_user_i;
-	u8 sig_val_ss1_seg_cr_user_i;
-	u8 sig_val_ss2_seg_cr_user_i;
-	u8 sig_val_ss3_seg_cr_user_i;
-	u8 sig_bad_tone_cnt_seg_cr_user_i;
-	u8 cn_bad_tone_cnt_seg_cr_user_i;
-};
-
-struct physts_ie_12_cmn_info {
-	u8 ie_hdr_l;
-
-	u8 ie_hdr_m:4;
-	u8 rsvd_0_dummy_4bit:4;
-
-	u8 n_user;
-};
-
-struct physts_ie_13_user_info {
-	u8 mcs:6;
-	u8 fec_type:1;
-	u8 is_bf:1;
-
-	u8 n_sts_ru_total:3;
-	u8 n_sts:3;
-	u8 pilot_exist:2;
-
-	u8 start_sts:3;
-	u8 pdp_he_ltf_and_gi_type:3;
-	u8 is_mu_mimo:1;
-	u8 is_awgn:1;
-
-	u8 rx_evm_max_seg_cr;
-	u8 rx_evm_min_seg_cr;
-	u8 snr;
-	u8 ru_alloc;
-
-	u8 avg_cn_seg_cr:7;
-	u8 is_dcm:1;
-
-	u8 sta_id_l;
-
-	u8 sta_id_m:3;
-	u8 rsvd_0_dummy_5bit:5;
-};
-
-struct physts_ie_13_cmn_info_p1 {
-	u8 ie_hdr_l;
-
-	u8 ie_hdr_m:4;
-	u8 rsvd_0_dummy_4bit:4;
-
-	u8 n_user;
-	u8 rsvd_1_dummy_8bit;
-};
-
-struct physts_ie_13_cmn_info_p2 {
-	u8 n_not_sup_sta;
-
-	u8 not_support_sta_id0_l;
-
-	u8 not_support_sta_id0_m:3;
-	u8 rsvd_0_dummy_5bit:5;
-
-	u8 not_support_sta_id1_l;
-
-	u8 not_support_sta_id1_m:3;
-	u8 rsvd_1_dummy_5bit:5;
-
-	u8 not_support_sta_id2_l;
-
-	u8 not_support_sta_id2_m:3;
-	u8 not_support_sta_id3_l:5;
-
-	u8 not_support_sta_id3_m:6;
-	u8 rsvd_2_dummy_2bit:2;
-};
-
-struct physts_ie_14_user_info {
-	u8 cqi_bitmap_ul_tb;
-	u8 cqi_raw_len_ul_tb;
-	u8 *cqi_raw_ul_tb_addr;
-};
-
-struct physts_ie_14_cmn_info {
-	u8 ie_hdr_l;
-	u8 ie_hdr_m:4;
-	u8 rxinfo_ndp_en:1;
-	u8 rsvd_0_dummy_3bit:3;
-	u8 n_user;
-	u8 rxinfo_ndp_1;
-
-	u8 rsvd_0_dummy_8bit;
-	u8 rsvd_1_dummy_8bit;
-	u8 rsvd_2_dummy_8bit;
-	u8 rsvd_3_dummy_8bit;
-};
-
-struct physts_ie_15_cmn_info {
-	u8 ie_hdr_l;
-
-	u8 ie_hdr_m:4;
-	u8 rsvd_0_dummy_4bit:4;
-
-	u8 n_user;
-};
-
-struct physts_ie_15_user_info {
-	/* 64bit cmn_info */
-	u8 mcs:6;
-	u8 fec_type:1;
-	u8 is_bf:1;
-
-	u8 n_sts_ru_total:3;
-	u8 n_sts:3;
-	u8 pilot_exist:2;
-
-	u8 start_sts:3;
-	u8 pdp_he_ltf_and_gi_type:3;
-	u8 is_mu_mimo:1;
-	u8 is_awgn:1;
-
-	u8 rx_evm_max_seg_cr;
-	u8 rx_evm_min_seg_cr;
-	u8 snr;
-	u8 ru_alloc;
-
-	u8 avg_cn_seg_cr:7;
-	u8 is_dcm:1;
-
-	/* others */
-	u8 uid;
-	u8 avg_cfo_seg0_l;
-
-	u8 avg_cfo_seg0_m:4;
-	u8 rsvd_0_dummy_4bit:4;
-
-	u8 rssi_m_ul_tb_l;
-
-	u8 rssi_m_ul_tb_m:1;
-	u8 rsvd_1_dummy_7bit:7;
-};
-
-struct physts_ie_17_cmn_info {
-	u8 ie_hdr_l;
-
-	u8 ie_hdr_m:4;
-	u8 n_user_l:4;
-
-	u8 n_user_m:4;
-	u8 rsvd_0_dummy_4bit:4;
-
-	u8 rsvd_0_dummy_8it;
-	u8 rsvd_1_dummy_8it;
-	u8 rsvd_2_dummy_8it;
-	u8 rsvd_3_dummy_8it;
-	u8 rsvd_4_dummy_8it;
-
-	/*64bit rx_tb_cmn_ctrl*/
-
-	u8 stbc_en:1;
-	u8 ldpc_extra:1;
-	u8 doppler_en:1;
-	u8 midamle_mode:1;
-	u8 gi_type:2;
-	u8 ltf_type:2;
-
-	u8 n_ltf:3;
-	u8 n_sym_l:5;
-
-	u8 n_sym_m:6;
-	u8 pe_idx_l:2;
-
-	u8 pe_idx_m:1;
-	u8 pre_fec_factor:2;
-	u8 n_usr_l:5;
-
-	u8 n_usr_m:3;
-	u8 mumimo_ltf_mode_en:1;
-	u8 ndp:1;
-	u8 pri_exp_rssi_dbm_l:3;
-
-	u8 pri_exp_rssi_dbm_m:4;
-	u8 dbw_idx:2;
-	u8 rsvd1:2;
-
-	u8 rxtime_l:8;
-
-	u8 rxtime_m:6;
-	u8 rsvd2:2;
-};
-
-struct physts_ie_17_user_info {
-	/*64bit rx_tb_user_ctrl*/
-	u8 u_id;
-
-	u8 ru_alloc;
-
-	u8 n_sts_ru_tot:3;
-	u8 rsvd1:2;
-	u8 strt_sts:3;
-
-	u8 n_sts:3;
-	u8 fec_type:1;
-	u8 mcs:4;
-
-	u8 rsvd2:2;
-	u8 dcm_en:1;
-	u8 rsvd3:5;
-
-	u8 rsvd4;
-	u8 rsvd5;
-	u8 rsvd6;
-};
-
-struct physts_ie_18_info {
-	/*[DW0]*/
-	u8 ie_hdr:5;
-	u8 is_seg1_exist:1;
-	u8 rsvd_0_dummy_2bit:2;
-
-	u8 rx_time_l;
-
-	u8 rx_time_m:6;
-	u8 rsvd_1_dummy_2bit:2;
-
-	u8 ch_len_lgcy_seg0;
-	u8 bw_det_seg0;
-
-	u8 snr_idx_lgcy_seg0:3;
-	u8 pdp_idx_lgcy_seg0:3;
-	u8 rsvd_2_dummy_2bit:2;
-
-	u8 pfd_flow_l;
-
-	u8 pfd_flow_m:4;
-	u8 rsvd_3_dummy_4bit:4;
-
-	u8 ch_len_lgcy_seg1;
-	u8 bw_det_seg1;
-
-	u8 snr_idx_lgcy_seg1:3;
-	u8 pdp_idx_lgcy_seg1:3;
-	u8 rsvd_3_dummy_2bit:2;
-
-	u8 rsvd_3_dummy_8bit;
-
-	u8 zero_padding_l2;
-	u8 zero_padding_l1;
-	u8 zero_padding_m2;
-	u8 zero_padding_m1;
-};
-
-struct physts_ie_18_info_type1 {
-	/*[DW0]*/
-	u8 ie_hdr:5;
-	u8 rsvd_0_dummy_3bit:3;
-
-	u8 rxtime_l;
-
-	u8 rxtime_m:6;
-	u8 pfd_flow_1:2;
-	/*[DW1]*/
-	u8 pfd_flow_2;
-
-	u8 pfd_flow_3:2;
-	u8 ch_len_lgcy_seg0_l:6;
-
-	u8 ch_len_lgcy_seg0_m:3;
-	u8 ch_len_lgcy_seg1_l:5;
-
-	u8 ch_len_lgcy_seg1_m:4;
-	u8 rsvd_0_dummy_4bit:4;
-
-	u8 bw_det_seg0;
-	u8 bw_det_seg1;
-	u8 snr_lgy_patha;
-	u8 snr_lgy_pathb;
-	u8 snr_lgy_pathc;
-	u8 snr_lgy_pathd;
-
-	u8 snr_idx_lgy_patha:3;
-	u8 tmax_idx_lgy_patha:3;
-	u8 snr_idx_lgy_pathb_l:2;
-
-	u8 snr_idx_lgy_pathb_m:1;
-	u8 tmax_idx_lgy_pathb:3;
-	u8 snr_idx_lgy_pathc:3;
-	u8 tmax_idx_lgy_pathc_l:1;
-
-	u8 tmax_idx_lgy_pathc_m:2;
-	u8 snr_idx_lgy_pathd:3;
-	u8 tmax_idx_lgy_pathd:3;
-
-	u8 gd_phase_lgy_sub0_patha;
-	u8 gd_phase_lgy_sub1_patha;
-	u8 gd_phase_lgy_sub2_patha;
-	u8 gd_phase_lgy_sub3_patha;
-	u8 gd_phase_lgy_sub4_patha;
-	u8 gd_phase_lgy_sub5_patha;
-	u8 gd_phase_lgy_sub6_patha;
-	u8 gd_phase_lgy_sub7_patha;
-	u8 gd_phase_lgy_sub0_pathb;
-	u8 gd_phase_lgy_sub1_pathb;
-	u8 gd_phase_lgy_sub2_pathb;
-	u8 gd_phase_lgy_sub3_pathb;
-	u8 gd_phase_lgy_sub4_pathb;
-	u8 gd_phase_lgy_sub5_pathb;
-	u8 gd_phase_lgy_sub6_pathb;
-	u8 gd_phase_lgy_sub7_pathb;
-	u8 gd_phase_lgy_sub0_pathc;
-	u8 gd_phase_lgy_sub1_pathc;
-	u8 gd_phase_lgy_sub2_pathc;
-	u8 gd_phase_lgy_sub3_pathc;
-	u8 gd_phase_lgy_sub4_pathc;
-	u8 gd_phase_lgy_sub5_pathc;
-	u8 gd_phase_lgy_sub6_pathc;
-	u8 gd_phase_lgy_sub7_pathc;
-	u8 gd_phase_lgy_sub0_pathd;
-	u8 gd_phase_lgy_sub1_pathd;
-	u8 gd_phase_lgy_sub2_pathd;
-	u8 gd_phase_lgy_sub3_pathd;
-	u8 gd_phase_lgy_sub4_pathd;
-	u8 gd_phase_lgy_sub5_pathd;
-	u8 gd_phase_lgy_sub6_pathd;
-	u8 gd_phase_lgy_sub7_pathd;
-};
-
-struct physts_ie_19_info {
-	/*[DW0]*/
-	u8 ie_hdr:5;
-	u8 rsvd_0_dummy_2bit:2;
-	u8 tx_over_flow:1;
-
-	u8 ppdu_inpwrdbm_p20;
-	u8 ppdu_inpwrdbm_s20;
-	u8 ppdu_inpwrdbm_s40;
-	u8 ppdu_inpwrdbm_s80;
-	u8 ppdu_inpwrdbm_per20_1;
-	u8 ppdu_inpwrdbm_per20_2;
-	u8 ppdu_inpwrdbm_per20_3;
-	u8 ppdu_inpwrdbm_per20_4;
-	u8 edcca_rpt_cnt_p20;
-	u8 edcca_rpt_p20_max;
-	u8 edcca_rpt_p20_min;
-	u8 edcca_total_smp_cnt;
-	u8 edcca_rpt_cnt_s80;
-	u8 edcca_rpt_cnt_s80_max;
-	u8 edcca_rpt_cnt_s80_min;
-	u8 rsvd_1_dummy_8bit;
-	u8 pop_reg_pwr;
-	u8 pop_trig_pwr;
-	u8 early_drop_pwr;
-
-	u8 rsvd_2_dummy_8bit;
-	u8 rsvd_3_dummy_8bit;
-	u8 rsvd_4_dummy_8bit;
-	u8 rsvd_5_dummy_8bit;
-};
-
-struct physts_ie_19_info_type1 {
-	/*[DW0]*/
-	u8 ie_hdr:5;
-	u8 rsvd_0_dummy_2bit:2;
-	u8 tx_over_flow:1;
-
-	u8 ppdu_inpwrdbm_p20;
-	u8 ppdu_inpwrdbm_s20;
-	u8 ppdu_inpwrdbm_s40;
-	u8 ppdu_inpwrdbm_s80;
-	u8 ppdu_inpwrdbm_per20_1;
-	u8 ppdu_inpwrdbm_per20_2;
-	u8 ppdu_inpwrdbm_per20_3;
-	u8 ppdu_inpwrdbm_per20_4;
-	u8 edcca_rpt_cnt_p20;
-	u8 edcca_rpt_p20_max;
-	u8 edcca_rpt_p20_min;
-	u8 edcca_total_smp_cnt;
-	u8 edcca_rpt_cnt_s80;
-	u8 edcca_rpt_cnt_s80_max;
-	u8 edcca_rpt_cnt_s80_min;
-	u8 rsvd_1_dummy_8bit;
-	u8 pop_ref_pwr;
-	u8 pop_trig_pwr;
-	u8 early_drop_pwr;
-
-	u8 rsvd_2_dummy_8bit;
-	u8 rsvd_3_dummy_8bit;
-
-	u8 rsvd_4_dummy_7bit:7;
-	u8 find_eof:1;
-
-	u8 mpdu_stat_len;
-};
-
-struct physts_ie_20_user_info {
-	u8 ch_smo_n_block_lgcy_sub_0_seg_0:2;
-	u8 ch_smo_n_block_lgcy_sub_1_seg_0:2;
-	u8 ch_smo_n_block_lgcy_sub_2_seg_0:2;
-	u8 ch_smo_n_block_lgcy_sub_3_seg_0:2;
-
-	u8 ch_smo_en_lgcy_seg_0:4;
-	u8 ch_smo_en_non_lgcy_seg_0:4;
-
-	u8 ch_smo_n_block_non_lgcy_seg_0:3;
-	u8 rsvd_0_dummy_5bit:5;
-
-	u8 ch_len_non_lgcy_sts_0_seg_0;
-	u8 ch_len_non_lgcy_sts_1_seg_0;
-	u8 ch_len_non_lgcy_sts_2_seg_0;
-	u8 ch_len_non_lgcy_sts_3_seg_0;
-
-	u8 snr_idx_non_lgy_sts_0_seg_0:3;
-	u8 snr_idx_non_lgy_sts_1_seg_0:3;
-	u8 snr_idx_non_lgy_sts_2_seg_0_l:2;
-
-	u8 snr_idx_non_lgy_sts_2_seg_0_m:1;
-	u8 snr_idx_non_lgy_sts_3_seg_0:3;
-	u8 pdp_idx_non_lgcy_sts_0_seg_0:3;
-	u8 pdp_idx_non_lgcy_sts_1_seg_0_l:1;
-
-	u8 pdp_idx_non_lgcy_sts_1_seg_0_m:2;
-	u8 pdp_idx_non_lgcy_sts_2_seg_0:3;
-	u8 pdp_idx_non_lgcy_sts_3_seg_0:3;
-
-	u8 snr_non_lgy_sts_0_seg_0;
-	u8 snr_non_lgy_sts_1_seg_0;
-	u8 snr_non_lgy_sts_2_seg_0;
-	u8 snr_non_lgy_sts_3_seg_0;
-	u8 evm_ss_0_seg_0;
-	u8 evm_ss_1_seg_0;
-	u8 evm_ss_2_seg_0;
-	u8 evm_ss_3_seg_0;
-};
-
-struct physts_ie_20_cmn_info {
-	u8 ie_hdr_l;
-
-	u8 ie_hdr_m:4;
-	u8 rsvd_0_dummy_4bit:4;
-
-	u8 n_user;
-};
-
-struct physts_ie_20_21_info_type1{
-	u8 ie_hdr_l;
-
-	u8 ie_hdr_m:4;
-	u8 user_idx_l:4;
-
-	u8 user_idx_m:4;
-	u8 rcfo_data_start_1:4;
-
-	u8 rcfo_data_start_2;
-
-	u8 rcfo_data_start_3:4;
-	u8 rcfo_data_end_1:4;
-
-	u8 rcfo_data_end_2;
-
-	u8 rcfo_data_end_3:4;
-	u8 ch_len_non_lgy_l:4;
-
-	u8 ch_len_non_lgy_m:5;
-	u8 rsvd_0_dummy_3bit:3;
-
-	u8 snr_non_lgy_sts0_patha;
-	u8 snr_non_lgy_sts1_patha;
-	u8 snr_non_lgy_sts2_patha;
-	u8 snr_non_lgy_sts3_patha;
-
-	u8 snr_idx_non_lgy_sts0_patha:3;
-	u8 snr_idx_non_lgy_sts1_patha:3;
-	u8 snr_idx_non_lgy_sts2_patha_l:2;
-
-	u8 snr_idx_non_lgy_sts2_patha_m:1;
-	u8 snr_idx_non_lgy_sts3_patha:3;
-	u8 tmax_idx_non_lgy_sts0_patha:3;
-	u8 tmax_idx_non_lgy_sts1_patha_l:1;
-
-	u8 tmax_idx_non_lgy_sts1_patha_m:2;
-	u8 tmax_idx_non_lgy_sts2_patha:3;
-	u8 tmax_idx_non_lgy_sts3_patha:3;
-
-	u8 gd_phase_non_lgy_sts0_patha;
-	u8 gd_phase_non_lgy_sts1_patha;
-	u8 gd_phase_non_lgy_sts2_patha;
-	u8 gd_phase_non_lgy_sts3_patha;
-	u8 evm_ss0;
-	u8 noise_var_start_patha_l;
-	u8 noise_var_start_patha_m;
-	u8 noise_var_end_patha_l;
-	u8 noise_var_end_patha_m;
-
-	u8 snr_non_lgy_sts0_pathb;
-	u8 snr_non_lgy_sts1_pathb;
-	u8 snr_non_lgy_sts2_pathb;
-	u8 snr_non_lgy_sts3_pathb;
-
-	u8 snr_idx_non_lgy_sts0_pathb:3;
-	u8 snr_idx_non_lgy_sts1_pathb:3;
-	u8 snr_idx_non_lgy_sts2_pathb_l:2;
-
-	u8 snr_idx_non_lgy_sts2_pathb_m:1;
-	u8 snr_idx_non_lgy_sts3_pathb:3;
-	u8 tmax_idx_non_lgy_sts0_pathb:3;
-	u8 tmax_idx_non_lgy_sts1_pathb_l:1;
-
-	u8 tmax_idx_non_lgy_sts1_pathb_m:2;
-	u8 tmax_idx_non_lgy_sts2_pathb:3;
-	u8 tmax_idx_non_lgy_sts3_pathb:3;
-
-	u8 gd_phase_non_lgy_sts0_pathb;
-	u8 gd_phase_non_lgy_sts1_pathb;
-	u8 gd_phase_non_lgy_sts2_pathb;
-	u8 gd_phase_non_lgy_sts3_pathb;
-	u8 evm_ss1;
-	u8 noise_var_start_pathb_l;
-	u8 noise_var_start_pathb_m;
-	u8 noise_var_end_pathb_l;
-	u8 noise_var_end_pathb_m;
-
-	u8 snr_non_lgy_sts0_pathc;
-	u8 snr_non_lgy_sts1_pathc;
-	u8 snr_non_lgy_sts2_pathc;
-	u8 snr_non_lgy_sts3_pathc;
-
-	u8 snr_idx_non_lgy_sts0_pathc:3;
-	u8 snr_idx_non_lgy_sts1_pathc:3;
-	u8 snr_idx_non_lgy_sts2_pathc_l:2;
-
-	u8 snr_idx_non_lgy_sts2_pathc_m:1;
-	u8 snr_idx_non_lgy_sts3_pathc:3;
-	u8 tmax_idx_non_lgy_sts0_pathc:3;
-	u8 tmax_idx_non_lgy_sts1_pathc_l:1;
-
-	u8 tmax_idx_non_lgy_sts1_pathc_m:2;
-	u8 tmax_idx_non_lgy_sts2_pathc:3;
-	u8 tmax_idx_non_lgy_sts3_pathc:3;
-
-	u8 gd_phase_non_lgy_sts0_pathc;
-	u8 gd_phase_non_lgy_sts1_pathc;
-	u8 gd_phase_non_lgy_sts2_pathc;
-	u8 gd_phase_non_lgy_sts3_pathc;
-	u8 evm_ss2;
-	u8 noise_var_start_pathc_l;
-	u8 noise_var_start_pathc_m;
-	u8 noise_var_end_pathc_l;
-	u8 noise_var_end_pathc_m;
-
-	u8 snr_non_lgy_sts0_pathd;
-	u8 snr_non_lgy_sts1_pathd;
-	u8 snr_non_lgy_sts2_pathd;
-	u8 snr_non_lgy_sts3_pathd;
-
-	u8 snr_idx_non_lgy_sts0_pathd:3;
-	u8 snr_idx_non_lgy_sts1_pathd:3;
-	u8 snr_idx_non_lgy_sts2_pathd_l:2;
-
-	u8 snr_idx_non_lgy_sts2_pathd_m:1;
-	u8 snr_idx_non_lgy_sts3_pathd:3;
-	u8 tmax_idx_non_lgy_sts0_pathd:3;
-	u8 tmax_idx_non_lgy_sts1_pathd_l:1;
-
-	u8 tmax_idx_non_lgy_sts1_pathd_m:2;
-	u8 tmax_idx_non_lgy_sts2_pathd:3;
-	u8 tmax_idx_non_lgy_sts3_pathd:3;
-
-	u8 gd_phase_non_lgy_sts0_pathd;
-	u8 gd_phase_non_lgy_sts1_pathd;
-	u8 gd_phase_non_lgy_sts2_pathd;
-	u8 gd_phase_non_lgy_sts3_pathd;
-	u8 evm_ss3;
-	u8 noise_var_start_pathd_l;
-	u8 noise_var_start_pathd_m;
-	u8 noise_var_end_pathd_l;
-	u8 noise_var_end_pathd_m;
-};
-
-struct physts_ie_21_user_info {
-	u8 ch_smo_n_block_lgcy_sub_0_seg_1:2;
-	u8 ch_smo_n_block_lgcy_sub_1_seg_1:2;
-	u8 ch_smo_n_block_lgcy_sub_2_seg_1:2;
-	u8 ch_smo_n_block_lgcy_sub_3_seg_1:2;
-
-	u8 ch_smo_en_lgcy_seg_1:4;
-	u8 ch_smo_en_non_lgcy_seg_1:4;
-
-	u8 ch_smo_n_block_non_lgcy_seg_1:3;
-	u8 rsvd_0_dummy_5bit:5;
-
-	u8 ch_len_non_lgcy_sts_0_seg_1;
-	u8 ch_len_non_lgcy_sts_1_seg_1;
-	u8 ch_len_non_lgcy_sts_2_seg_1;
-	u8 ch_len_non_lgcy_sts_3_seg_1;
-
-	u8 snr_idx_non_lgy_sts_0_seg_1:3;
-	u8 snr_idx_non_lgy_sts_1_seg_1:3;
-	u8 snr_idx_non_lgy_sts_2_seg_1_l:2;
-
-	u8 snr_idx_non_lgy_sts_2_seg_1_m:1;
-	u8 snr_idx_non_lgy_sts_3_seg_1:3;
-	u8 pdp_idx_non_lgcy_sts_0_seg_1:3;
-	u8 pdp_idx_non_lgcy_sts_1_seg_1_l:1;
-
-	u8 pdp_idx_non_lgcy_sts_1_seg_1_m:2;
-	u8 pdp_idx_non_lgcy_sts_2_seg_1:3;
-	u8 pdp_idx_non_lgcy_sts_3_seg_1:3;
-
-	u8 snr_non_lgy_sts_0_seg_1;
-	u8 snr_non_lgy_sts_1_seg_1;
-	u8 snr_non_lgy_sts_2_seg_1;
-	u8 snr_non_lgy_sts_3_seg_1;
-	u8 evm_ss_0_seg_1;
-	u8 evm_ss_1_seg_1;
-	u8 evm_ss_2_seg_1;
-	u8 evm_ss_3_seg_1;
-};
-
-struct physts_ie_21_cmn_info {
-	u8 ie_hdr_l;
-
-	u8 ie_hdr_m:4;
-	u8 rsvd_0_dummy_4bit:4;
-
-	u8 n_user;
-};
-
-struct physts_ie_22_user_info {
-	u8 pw_norm_lgcy_path0;
-	u8 pw_norm_lgcy_path1;
-	u8 pw_norm_lgcy_path2;
-	u8 pw_norm_lgcy_path3;
-	u8 ant_wgt_lgcy_path0;
-	u8 ant_wgt_lgcy_path1;
-	u8 ant_wgt_lgcy_path2;
-	u8 ant_wgt_lgcy_path3;
-};
-
-struct physts_ie_22_cmn_info {
-	u8 ie_hdr_l;
-
-	u8 ie_hdr_m:4;
-	u8 rsvd_0_dummy_4bit:4;
-
-	u8 n_user;
-
-	u8 rsvd_0_dummy_8bit;
-	u8 rsvd_1_dummy_8bit;
-	u8 rsvd_2_dummy_8bit;
-	u8 rsvd_3_dummy_8bit;
-	u8 rsvd_4_dummy_8bit;
-
-	u8 pw_norm_lgcy_path0;
-	u8 pw_norm_lgcy_path1;
-	u8 pw_norm_lgcy_path2;
-	u8 pw_norm_lgcy_path3;
-	u8 ant_wgt_lgcy_path0;
-	u8 ant_wgt_lgcy_path1;
-	u8 ant_wgt_lgcy_path2;
-	u8 ant_wgt_lgcy_path3;
-};
-
-struct physts_ie_24_info {
-	/*[DW0]*/
-	u8 ie_hdr:5;
-	u8 pre_agc_step_a:2;
-	u8 aci_indicator_a:1;
-
-	u8 l_fine_agc_step_a:2;
-	u8 ht_fine_agc_step_a:2;
-	u8 tia_shrink_indicator_a:1;
-	u8 pre_gain_code_tia_a:1;
-	u8 l_fine_gain_code_tia_a:1;
-	u8 ht_fine_gain_code_tia_a:1;
-
-	u8 pre_gain_code_a;
-	u8 l_fine_gain_code_a;
-	u8 ht_fine_gain_code_a;
-	u8 l_dagc_a;
-	u8 ht_dagc_a;
-	u8 pre_ibpwrdbm_a;
-	u8 pre_wbpwrdbm_a;
-	u8 l_ibpwrdbm_a;
-	u8 l_wbpwrdbm_a;
-	u8 ht_ibpwrdbm_a;
-	u8 ht_wbpwrdbm_a;
-	u8 l_dig_ibpwrdbm_a;
-	u8 ht_dig_ibpwrdbm_a;
-	u8 lna_inpwrdbm_a;
-
-	u8 aci2sig_db:7;
-	u8 aci_det:1;
-
-	u8 sb5m_ratio_0;
-	u8 sb5m_ratio_1;
-	u8 sb5m_ratio_2;
-	u8 sb5m_ratio_3;
-
-	u8 rsvd_0_dummy_8bit;
-	u8 rsvd_1_dummy_8bit;
-	u8 rsvd_2_dummy_8bit;
-};
-
-struct physts_ie_25_info {
-	/*[DW0]*/
-	u8 ie_hdr:5;
-	u8 pre_agc_step_b:2;
-	u8 aci_indicator_b:1;
-
-	u8 l_fine_agc_step_b:2;
-	u8 ht_fine_agc_step_b:2;
-	u8 tia_shrink_indicator_b:1;
-	u8 pre_gain_code_tia_b:1;
-	u8 l_fine_gain_code_tia_b:1;
-	u8 ht_fine_gain_code_tia_b:1;
-
-	u8 pre_gain_code_b;
-	u8 l_fine_gain_code_b;
-	u8 ht_fine_gain_code_b;
-	u8 l_dagc_b;
-	u8 ht_dagc_b;
-	u8 pre_ibpwrdbm_b;
-	u8 pre_wbpwrdbm_b;
-	u8 l_ibpwrdbm_b;
-	u8 l_wbpwrdbm_b;
-	u8 ht_ibpwrdbm_b;
-	u8 ht_wbpwrdbm_b;
-	u8 l_dig_ibpwrdbm_b;
-	u8 ht_dig_ibpwrdbm_b;
-	u8 lna_inpwrdbm_b;
-
-	u8 aci2sig_db:7;
-	u8 aci_det:1;
-
-	u8 sb5m_ratio_0;
-	u8 sb5m_ratio_1;
-	u8 sb5m_ratio_2;
-	u8 sb5m_ratio_3;
-
-	u8 rsvd_0_dummy_8bit;
-	u8 rsvd_1_dummy_8bit;
-	u8 rsvd_2_dummy_8bit;
-};
-
-struct physts_ie_26_info {
-	/*[DW0]*/
-	u8 ie_hdr:5;
-	u8 pre_agc_step_c:2;
-	u8 aci_indicator_c:1;
-
-	u8 l_fine_agc_step_c:2;
-	u8 ht_fine_agc_step_c:2;
-	u8 tia_shrink_indicator_c:1;
-	u8 pre_gain_code_tia_c:1;
-	u8 l_fine_gain_code_tia_c:1;
-	u8 ht_fine_gain_code_tia_c:1;
-
-	u8 pre_gain_code_c;
-	u8 l_fine_gain_code_c;
-	u8 ht_fine_gain_code_c;
-	u8 l_dagc_c;
-	u8 ht_dagc_c;
-	u8 pre_ibpwrdbm_c;
-	u8 pre_wbpwrdbm_c;
-	u8 l_ibpwrdbm_c;
-	u8 l_wbpwrdbm_c;
-	u8 ht_ibpwrdbm_c;
-	u8 ht_wbpwrdbm_c;
-	u8 l_dig_ibpwrdbm_c;
-	u8 ht_dig_ibpwrdbm_c;
-	u8 lna_inpwrdbm_c;
-
-	u8 aci2sig_db:7;
-	u8 aci_det:1;
-
-	u8 sb5m_ratio_0;
-	u8 sb5m_ratio_1;
-	u8 sb5m_ratio_2;
-	u8 sb5m_ratio_3;
-
-	u8 rsvd_0_dummy_8bit;
-	u8 rsvd_1_dummy_8bit;
-	u8 rsvd_2_dummy_8bit;
-};
-
-struct physts_ie_27_info {
-	/*[DW0]*/
-	u8 ie_hdr:5;
-	u8 pre_agc_step_d:2;
-	u8 aci_indicator_d:1;
-
-	u8 l_fine_agc_step_d:2;
-	u8 ht_fine_agc_step_d:2;
-	u8 tia_shrink_indicator_d:1;
-	u8 pre_gain_code_tia_d:1;
-	u8 l_fine_gain_code_tia_d:1;
-	u8 ht_fine_gain_code_tia_d:1;
-
-	u8 pre_gain_code_d;
-	u8 l_fine_gain_code_d;
-	u8 ht_fine_gain_code_d;
-	u8 l_dagc_d;
-	u8 ht_dagc_d;
-	u8 pre_ibpwrdbm_d;
-	u8 pre_wbpwrdbm_d;
-	u8 l_ibpwrdbm_d;
-	u8 l_wbpwrdbm_d;
-	u8 ht_ibpwrdbm_d;
-	u8 ht_wbpwrdbm_d;
-	u8 l_dig_ibpwrdbm_d;
-	u8 ht_dig_ibpwrdbm_d;
-	u8 lna_inpwrdbm_d;
-
-	u8 aci2sig_db:7;
-	u8 aci_det:1;
-
-	u8 sb5m_ratio_0;
-	u8 sb5m_ratio_1;
-	u8 sb5m_ratio_2;
-	u8 sb5m_ratio_3;
-
-	u8 rsvd_0_dummy_8bit;
-	u8 rsvd_1_dummy_8bit;
-	u8 rsvd_2_dummy_8bit;
-};
-
-struct physts_ie_28_info {
-	/*[DW0]*/
-	u8 ie_hdr:5;
-	u8 rsvd_0_dummy_2bit:2;
-	u8 ant_weight_a_l:1;
-
-	u8 ant_weight_a_m;
-	u8 h3_real_a;
-	u8 h3_imag_a;
-	u8 h4_real_a;
-	u8 h4_imag_a;
-	u8 h5_real_a;
-	u8 h5_imag_a;
-	u8 h6_real_a;
-	u8 h6_imag_a;
-	u8 h7_real_a;
-	u8 h7_imag_a;
-	u8 h8_real_a;
-	u8 h8_imag_a;
-	u8 h9_real_a;
-	u8 h9_imag_a;
-	u8 h10_real_a;
-	u8 h10_imag_a;
-	u8 h11_real_a;
-	u8 h11_imag_a;
-	u8 h12_real_a;
-	u8 h12_imag_a;
-	u8 h13_real_a;
-	u8 h13_imag_a;
-	u8 h14_real_a;
-	u8 h14_imag_a;
-	u8 h15_real_a;
-	u8 h15_imag_a;
-	u8 h16_real_a;
-	u8 h16_imag_a;
-	u8 h17_real_a;
-	u8 h17_imag_a;
-};
-
-struct physts_ie_29_info {
-	/*[DW0]*/
-	u8 ie_hdr:5;
-	u8 rsvd_0_dummy_2bit:2;
-	u8 ant_weight_b_l:1;
-
-	u8 ant_weight_b_m;
-	u8 h3_real_b;
-	u8 h3_imag_b;
-	u8 h4_real_b;
-	u8 h4_imag_b;
-	u8 h5_real_b;
-	u8 h5_imag_b;
-	u8 h6_real_b;
-	u8 h6_imag_b;
-	u8 h7_real_b;
-	u8 h7_imag_b;
-	u8 h8_real_b;
-	u8 h8_imag_b;
-	u8 h9_real_b;
-	u8 h9_imag_b;
-	u8 h10_real_b;
-	u8 h10_imag_b;
-	u8 h11_real_b;
-	u8 h11_imag_b;
-	u8 h12_real_b;
-	u8 h12_imag_b;
-	u8 h13_real_b;
-	u8 h13_imag_b;
-	u8 h14_real_b;
-	u8 h14_imag_b;
-	u8 h15_real_b;
-	u8 h15_imag_b;
-	u8 h16_real_b;
-	u8 h16_imag_b;
-	u8 h17_real_b;
-	u8 h17_imag_b;
-};
-
-struct physts_ie_30_info {
-	/*[DW0]*/
-	u8 ie_hdr:5;
-	u8 rsvd_0_dummy_2bit:2;
-	u8 ant_weight_c_l:1;
-
-	u8 ant_weight_c_m;
-	u8 h3_real_c;
-	u8 h3_imag_c;
-	u8 h4_real_c;
-	u8 h4_imag_c;
-	u8 h5_real_c;
-	u8 h5_imag_c;
-	u8 h6_real_c;
-	u8 h6_imag_c;
-	u8 h7_real_c;
-	u8 h7_imag_c;
-	u8 h8_real_c;
-	u8 h8_imag_c;
-	u8 h9_real_c;
-	u8 h9_imag_c;
-	u8 h10_real_c;
-	u8 h10_imag_c;
-	u8 h11_real_c;
-	u8 h11_imag_c;
-	u8 h12_real_c;
-	u8 h12_imag_c;
-	u8 h13_real_c;
-	u8 h13_imag_c;
-	u8 h14_real_c;
-	u8 h14_imag_c;
-	u8 h15_real_c;
-	u8 h15_imag_c;
-	u8 h16_real_c;
-	u8 h16_imag_c;
-	u8 h17_real_c;
-	u8 h17_imag_c;
-};
-
-struct physts_ie_31_info {
-	/*[DW0]*/
-	u8 ie_hdr:5;
-	u8 rsvd_0_dummy_2bit:2;
-	u8 ant_weight_d_l:1;
-
-	u8 ant_weight_d_m;
-	u8 h3_real_d;
-	u8 h3_imag_d;
-	u8 h4_real_d;
-	u8 h4_imag_d;
-	u8 h5_real_d;
-	u8 h5_imag_d;
-	u8 h6_real_d;
-	u8 h6_imag_d;
-	u8 h7_real_d;
-	u8 h7_imag_d;
-	u8 h8_real_d;
-	u8 h8_imag_d;
-	u8 h9_real_d;
-	u8 h9_imag_d;
-	u8 h10_real_d;
-	u8 h10_imag_d;
-	u8 h11_real_d;
-	u8 h11_imag_d;
-	u8 h12_real_d;
-	u8 h12_imag_d;
-	u8 h13_real_d;
-	u8 h13_imag_d;
-	u8 h14_real_d;
-	u8 h14_imag_d;
-	u8 h15_real_d;
-	u8 h15_imag_d;
-	u8 h16_real_d;
-	u8 h16_imag_d;
-	u8 h17_real_d;
-	u8 h17_imag_d;
-};
-
- /*@--------------------------[Prptotype]-------------------------------------*/
-#endif
diff --git a/os/board/rtl8720e/src/component/wifi/driver/src/hal/phy_g6/bb/halbb_plcp_gen.h b/os/board/rtl8720e/src/component/wifi/driver/src/hal/phy_g6/bb/halbb_plcp_gen.h
deleted file mode 100644
index 583fa4b26..000000000
--- a/os/board/rtl8720e/src/component/wifi/driver/src/hal/phy_g6/bb/halbb_plcp_gen.h
+++ /dev/null
@@ -1,264 +0,0 @@
-/******************************************************************************
- *
- * Copyright(c) 2007 - 2020  Realtek Corporation.
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of version 2 of the GNU General Public License as
- * published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
- * more details.
- *
- * The full GNU General Public License is included in this distribution in the
- * file called LICENSE.
- *
- * Contact Information:
- * wlanfae <wlanfae@realtek.com>
- * Realtek Corporation, No. 2, Innovation Road II, Hsinchu Science Park,
- * Hsinchu 300, Taiwan.
- *
- * Larry Finger <Larry.Finger@lwfinger.net>
- *
- *****************************************************************************/
-
-#ifndef _HALBB_PLCP_GEN_H_
-#define _HALBB_PLCP_GEN_H_
-
-/*  ============================================================
- 			   define
-    ============================================================
-*/
-#define N_USER	4
-
-/*  ============================================================
- 			   structure
-    ============================================================
-*/
-
-
-struct plcp_mcs_table_in_t {
-	u8 spec_idx : 3;
-	u8 mcs : 5;
-	u8 nss : 4;		
-	u8 bw : 2;//0:BW20, 1:BW40, 2:BW80, 3:BW160 /*enum channel_width*/
-	u8 rsvd0 : 2;
-	u8 ru_size : 3; //0:RU26, 1:RU52, 2:RU106, 3:RU242, 4:RU484, 5:RU996, 6:RU996x2, 7:hesigb
-	u8 rsvd1 : 5;
-	bool dcm;
-	bool fec;
-};
-
-struct plcp_mcs_table_out_t {
-	u32 n_dbps : 17;
-	u32 he_n_dbps_short : 15;
-	u32 n_cbps : 18;
-	u32 n_es : 4;
-	u32 valid : 1;
-	u32 code_rate : 2;
-	u32 nss : 3;
-	u32 rsvd0 : 4;	
-	u32 he_n_cbps_short : 15;
-	u32 rsvd1 : 17;
-	bool dcm;
-	bool fec;
-};
-//========== [Par] ==========//
-struct com_pre_fec_par {
-	u16 n_sym_init : 11;
-	u16 spec_idx : 3;
-	u16 pre_fec_padding_factor_init : 3;
-	u16 ndp_en : 1;
-	u16 preamble_0p4us : 16;
-	u8 m_stbc : 2;
-	u8 stbc : 1;
-	u8 doppler_mode : 2;
-	u8 gi : 2;
-	u32 t_sym_0p4us : 6;
-	u32 t_ltf_sym_0p4us : 6;
-	u32 n_ltf_sym : 4;
-	u32 n_sts_max : 4;
-	u32 n_ma : 6;
-	u32 m_ma : 5;
-	u32 tb_trig : 1;
-	u32 n_hesigb_sym : 8;	
-	u32 n_usr_refine : 8;
-	u32 tb_trig_t_pe : 3;
-	u32 tb_ldpc_extra : 1;
-	u32 rsvd1 : 12;
-};
-
-struct usr_pre_fec_par {
-	u32 n_excess : 15;
-	u32 pre_fec_padding_factor_init : 3;
-	u32 n_sym_init : 11;
-	u32 rsvd0 : 3;
-	u32 n_dbps_last_init : 17;
-	u32 n_mpdu_refine : 9;
-	u32 rsvd1 : 6;
-	u32 n_cbps_last_init : 18;
-	u32 mpdu_length_byte_refine : 14;
-	u32 apep_refine : 22;
-	u32 ru_size_refine : 3;
-	u32 rsvd3 : 7;
-};
-
-struct plcp_tx_pre_fec_padding_setting_par_t {
-	struct com_pre_fec_par com;
-	struct plcp_mcs_table_out_t usr_mcs_out[4];
-	struct usr_pre_fec_par usr[N_USER];
-};
-//========== [Input] ==========//
-struct usr_pre_fec_in {
-	u8 ru_size_idx : 3;
-	u8 nss : 4;
-	u8 rsvd0 : 1;
-	u8 mcs : 6;
-	u8 rsvd1 : 2;
-	u32 apep : 22;
-	u32 n_mpdu : 9;
-	u32 rsvd2 : 1;
-	u16 mpdu_length_byte : 14;
-	u16 rsvd3 : 2;
-	bool dcm;
-	bool fec;
-};
-
-struct plcp_tx_pre_fec_padding_setting_in_t {
-	u8 format_idx : 4;
-	u8 stbc : 1;
-	u8 he_dcm_sigb : 1;
-	u8 doppler_mode : 2; //0: diable ,1:MA10, 2:MA20
-	u16 n_hesigb_sym : 11; //per ch
-	u16 he_mcs_sigb : 3;
-	u16 nominal_t_pe : 2;
-	u8 dbw : 2;
-	u8 gi : 2; //0.4,0.8,1.6,3.2
-	u8 ltf_type : 2; //1x, 2x, 4x
-	u8 ness : 2;
-
-	u32 mode_idx : 2; //0:apep, 1:max_tx_time, 2:n_mpdu,mpdu_len, 3:tb_trigger_mode
-	u32 max_tx_time_0p4us : 14;
-	u32 n_user : 8;
-
-	u32 ndp : 1; 
-	u32 he_er_u106ru_en : 1; //done
-	u32 rsvd1 : 6;
-	u32 tb_l_len : 12;
-	u32 tb_ru_tot_sts_max : 3;
-	u32 tb_disam : 1;
-	u32 tb_ldpc_extra : 1;
-	u32 tb_pre_fec_padding_factor : 2;
-	u32 ht_l_len : 12;
-	u32 rsvd2 : 10;
-	struct usr_pre_fec_in usr[N_USER];
-};
-
-
-//========== [Output] ==========//
-struct usr_pre_fec_out {
-	u32 nss : 4;
-	u32 nsts : 4;
-	u32 mpdu_length_byte : 14;
-	u32 n_mpdu : 9;
-	u32 rsvd0 : 1;
-	u32 eof_padding_length : 32;
-	u32 apep_len : 22;
-	u32 ru_size : 3;
-	u32 mcs_valid : 1;
-	u32 rsvd1 : 6;
-	bool fec;
-	bool dcm;
-};
-struct plcp_tx_pre_fec_padding_setting_out_t {
-	u32 pre_fec_padding_factor : 2; // 0:4, 1:1, 2:2, 3:3
-	u32 n_sym : 11;
-	u32 ldpc_extra : 1;
-	u32 rsvd : 14;
-	u32 t_pe : 3; //0: 0us, 1:4us, 2:8us, 3:12us, 4:16us
-	u32 valid : 1;
-	u16 l_len : 12;
-	u16 disamb : 1;
-	u16 n_ltf : 3;
-	u32 tx_time_0p4us;
-	u32 stbc : 1;
-	u32 doppler_en : 1;
-	u32 midamble : 2;
-	u32 n_usr : 8;
-	u32 ndp : 1;
-	u32 gi : 2;
-	u32 n_sym_hesigb : 6;
-	u32 plcp_valid : 8;
-	u32 rvsd0 : 3;
-	struct usr_pre_fec_out usr[N_USER];
-};
-
-/*  ============================================================
- 			Enumeration
-    ============================================================
-*/
-enum spec_list {
-	SPEC_B_MODE	= 0,
-	SPEC_LEGACY	= 1,
-	SPEC_HT		= 2,
-	SPEC_VHT	= 3,
-	SPEC_HE		= 4
-};
-
-enum fec_t {
-	BCC 		= 0,
-	LDPC
-};
-
-enum ru_sizes_list{
-	RU26 		= 0,
-	RU52,
-	RU106,
-	RU242,
-	RU484,
-	RU996,
-	RU996X2,
-	HESIGB
-};
-
-enum packet_format_t{
-	B_MODE_FMT 	= 0, 
-	LEGACY_FMT,
-	HT_MF_FMT,
-	HT_GF_FMT,
-	VHT_FMT,
-	HE_SU_FMT,
-	HE_ER_SU_FMT,
-	HE_MU_FMT,
-	HE_TB_FMT
-};
-
-enum coding_rate_t{
-	R12 		= 0,
-	R23,
-	R34,
-	R56
-};
-
-/*  ============================================================
- 		     Function Prototype
-    ============================================================
-*/
-
-struct bb_info;
-
-u32 halbb_ceil(u32 numerator, u32 denominator);
-u32 halbb_mod(u32 numerator, u32 denominator);
-u32 halbb_min(u32 val_1, u32 val_2);
-u32 halbb_max(u32 val_1, u32 val_2);
-void halbb_set_bit(u8 strt, u8 len, u32 in, u32* out);
-void halbb_write_cr(struct bb_info *bb, struct cr_address_t cr_address, u32 val,
-		    enum phl_phy_idx phy_idx);
-enum plcp_sts halbb_tx_plcp_cal(struct bb_info *bb,
-	const struct plcp_tx_pre_fec_padding_setting_in_t *in,
-	struct plcp_tx_pre_fec_padding_setting_out_t *out);
-
-
-#endif
-
diff --git a/os/board/rtl8720e/src/component/wifi/driver/src/hal/phy_g6/bb/halbb_plcp_tx.h b/os/board/rtl8720e/src/component/wifi/driver/src/hal/phy_g6/bb/halbb_plcp_tx.h
deleted file mode 100644
index c5168dd06..000000000
--- a/os/board/rtl8720e/src/component/wifi/driver/src/hal/phy_g6/bb/halbb_plcp_tx.h
+++ /dev/null
@@ -1,378 +0,0 @@
-/******************************************************************************
- *
- * Copyright(c) 2007 - 2020  Realtek Corporation.
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of version 2 of the GNU General Public License as
- * published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
- * more details.
- *
- * The full GNU General Public License is included in this distribution in the
- * file called LICENSE.
- *
- * Contact Information:
- * wlanfae <wlanfae@realtek.com>
- * Realtek Corporation, No. 2, Innovation Road II, Hsinchu Science Park,
- * Hsinchu 300, Taiwan.
- *
- * Larry Finger <Larry.Finger@lwfinger.net>
- *
- *****************************************************************************/
-
-#ifndef _HALBB_PLCP_TX_H_
-#define _HALBB_PLCP_TX_H_
-
-/*  ============================================================
- 			   structure
-    ============================================================
-*/
-struct bb_plcp_cr_info {
-	u32 b_header_0;
-	u32 b_header_0_m;	
-	u32 b_header_1;
-	u32 b_header_1_m;	
-	u32 b_header_2;	
-	u32 b_header_2_m;	
-	u32 b_header_3;	
-	u32 b_header_3_m;	
-	u32 b_header_4;	
-	u32 b_header_4_m;	
-	u32 b_header_5;	
-	u32 b_header_5_m;	
-	u32 b_psdu_byte;	
-	u32 b_psdu_byte_m;
-	u32 b_carrier_suppress_tx;	
-	u32 b_carrier_suppress_tx_m;	
-	u32 b_ppdu_type;		
-	u32 b_ppdu_type_m;	
-	u32 b_psdu_rate;		
-	u32 b_psdu_rate_m;	
-	u32 b_service_bit2;	
-	u32 b_service_bit2_m;	
-	u32 he_sigb_ch1_0;		
-	u32 he_sigb_ch1_0_m;	
-	u32 he_sigb_ch1_1;		
-	u32 he_sigb_ch1_1_m;	
-	u32 he_sigb_ch1_10;		
-	u32 he_sigb_ch1_10_m;	
-	u32 he_sigb_ch1_11;		
-	u32 he_sigb_ch1_11_m;	
-	u32 he_sigb_ch1_12;		
-	u32 he_sigb_ch1_12_m;	
-	u32 he_sigb_ch1_13;		
-	u32 he_sigb_ch1_13_m;	
-	u32 he_sigb_ch1_14;		
-	u32 he_sigb_ch1_14_m;	
-	u32 he_sigb_ch1_15;		
-	u32 he_sigb_ch1_15_m;	
-	u32 he_sigb_ch1_2;		
-	u32 he_sigb_ch1_2_m;	
-	u32 he_sigb_ch1_3;		
-	u32 he_sigb_ch1_3_m;	
-	u32 he_sigb_ch1_4;		
-	u32 he_sigb_ch1_4_m;	
-	u32 he_sigb_ch1_5;		
-	u32 he_sigb_ch1_5_m;	
-	u32 he_sigb_ch1_6;		
-	u32 he_sigb_ch1_6_m;	
-	u32 he_sigb_ch1_7;		
-	u32 he_sigb_ch1_7_m;	
-	u32 he_sigb_ch1_8;		
-	u32 he_sigb_ch1_8_m;	
-	u32 he_sigb_ch1_9;		
-	u32 he_sigb_ch1_9_m;	
-	u32 he_sigb_ch2_0;		
-	u32 he_sigb_ch2_0_m;	
-	u32 he_sigb_ch2_1;		
-	u32 he_sigb_ch2_1_m;	
-	u32 he_sigb_ch2_10;		
-	u32 he_sigb_ch2_10_m;	
-	u32 he_sigb_ch2_11;		
-	u32 he_sigb_ch2_11_m;	
-	u32 he_sigb_ch2_12;		
-	u32 he_sigb_ch2_12_m;	
-	u32 he_sigb_ch2_13;		
-	u32 he_sigb_ch2_13_m;	
-	u32 he_sigb_ch2_14;		
-	u32 he_sigb_ch2_14_m;	
-	u32 he_sigb_ch2_15;		
-	u32 he_sigb_ch2_15_m;	
-	u32 he_sigb_ch2_2;		
-	u32 he_sigb_ch2_2_m;	
-	u32 he_sigb_ch2_3;		
-	u32 he_sigb_ch2_3_m;	
-	u32 he_sigb_ch2_4;		
-	u32 he_sigb_ch2_4_m;	
-	u32 he_sigb_ch2_5;		
-	u32 he_sigb_ch2_5_m;	
-	u32 he_sigb_ch2_6;		
-	u32 he_sigb_ch2_6_m;	
-	u32 he_sigb_ch2_7;		
-	u32 he_sigb_ch2_7_m;	
-	u32 he_sigb_ch2_8;		
-	u32 he_sigb_ch2_8_m;	
-	u32 he_sigb_ch2_9;		
-	u32 he_sigb_ch2_9_m;	
-	u32 usr0_delmter;		
-	u32 usr0_delmter_m;	
-	u32 usr0_eof_padding_len;	
-	u32 usr0_eof_padding_len_m;	
-	u32 usr0_init_seed;		
-	u32 usr0_init_seed_m;		
-	u32 usr1_delmter;		
-	u32 usr1_delmter_m;	
-	u32 usr1_eof_padding_len;	
-	u32 usr1_eof_padding_len_m;	
-	u32 usr1_init_seed;	
-	u32 usr1_init_seed_m;	
-	u32 usr2_delmter;		
-	u32 usr2_delmter_m;	
-	u32 usr2_eof_padding_len;	
-	u32 usr2_eof_padding_len_m;	
-	u32 usr2_init_seed;	
-	u32 usr2_init_seed_m;	
-	u32 usr3_delmter;		
-	u32 usr3_delmter_m;	
-	u32 usr3_eof_padding_len;	
-	u32 usr3_eof_padding_len_m;
-	u32 usr3_init_seed;	
-	u32 usr3_init_seed_m;	
-	u32 vht_sigb0;		
-	u32 vht_sigb0_m;	
-	u32 vht_sigb1;		
-	u32 vht_sigb1_m;	
-	u32 vht_sigb2;		
-	u32 vht_sigb2_m;
-	u32 he_sigb_mcs;
-	u32 he_sigb_mcs_m;	
-	u32 vht_sigb3;	
-	u32 vht_sigb3_m;
-	u32 n_ltf;	
-	u32 n_ltf_m;
-	u32 siga1;		
-	u32 siga1_m;	
-	u32 siga2;		
-	u32 siga2_m;	
-	u32 lsig;		
-	u32 lsig_m;		
-	u32 cca_pw_th;	
-	u32 cca_pw_th_m;	
-	u32 n_sym;		
-	u32 n_sym_m;	
-	u32 usr0_service;		
-	u32 usr0_service_m;	
-	u32 usr1_service;		
-	u32 usr1_service_m;	
-	u32 usr2_service;		
-	u32 usr2_service_m;	
-	u32 usr3_service;		
-	u32 usr3_service_m;	
-	u32 usr0_mdpu_len_byte;
-	u32 usr0_mdpu_len_byte_m;		
-	u32 usr1_mdpu_len_byte;		
-	u32 usr1_mdpu_len_byte_m;		
-	u32 obw_cts2self_dup_type;		
-	u32 obw_cts2self_dup_type_m;		
-	u32 usr2_mdpu_len_byte;	
-	u32 usr2_mdpu_len_byte_m;	
-	u32 usr3_mdpu_len_byte;
-	u32 usr3_mdpu_len_byte_m;	
-	u32 usr0_csi_buf_id;	
-	u32 usr0_csi_buf_id_m;	
-	u32 usr1_csi_buf_id;	
-	u32 usr1_csi_buf_id_m;	
-	u32 rf_gain_idx;	
-	u32 rf_gain_idx_m;	
-	u32 usr2_csi_buf_id;	
-	u32 usr2_csi_buf_id_m;	
-	u32 usr3_csi_buf_id;	
-	u32 usr3_csi_buf_id_m;	
-	u32 usr0_n_mpdu;	
-	u32 usr0_n_mpdu_m;		
-	u32 usr1_n_mpdu;		
-	u32 usr1_n_mpdu_m;		
-	u32 usr2_n_mpdu;		
-	u32 usr2_n_mpdu_m;		
-	u32 usr0_pw_boost_fctr_db;		
-	u32 usr0_pw_boost_fctr_db_m;	
-	u32 usr3_n_mpdu;		
-	u32 usr3_n_mpdu_m;		
-	u32 ch20_with_data;		
-	u32 ch20_with_data_m;	
-	u32 n_usr;		
-	u32 n_usr_m;		
-	u32 txcmd_txtp;
-	u32 txcmd_txtp_m;
-	u32 usr0_ru_alloc;	
-	u32 usr0_ru_alloc_m;
-	u32 usr0_u_id;		
-	u32 usr0_u_id_m;
-	u32 usr1_ru_alloc;	
-	u32 usr1_ru_alloc_m;
-	u32 usr1_u_id;		
-	u32 usr1_u_id_m;	
-	u32 usr2_ru_alloc;	
-	u32 usr2_ru_alloc_m;
-	u32 usr2_u_id;		
-	u32 usr2_u_id_m;	
-	u32 usr3_ru_alloc;	
-	u32 usr3_ru_alloc_m;
-	u32 usr3_u_id;		
-	u32 usr3_u_id_m;	
-	u32 n_sym_hesigb;		
-	u32 n_sym_hesigb_m;		
-	u32 usr0_mcs;	
-	u32 usr0_mcs_m;	
-	u32 usr1_mcs;	
-	u32 usr1_mcs_m;	
-	u32 usr2_mcs;	
-	u32 usr2_mcs_m;	
-	u32 usr3_mcs;	
-	u32 usr3_mcs_m;	
-	u32 usr1_pw_boost_fctr_db;	
-	u32 usr1_pw_boost_fctr_db_m;
-	u32 usr2_pw_boost_fctr_db;	
-	u32 usr2_pw_boost_fctr_db_m;
-	u32 usr3_pw_boost_fctr_db;	
-	u32 usr3_pw_boost_fctr_db_m;
-	u32 ppdu_type;	
-	u32 ppdu_type_m;	
-	u32 txsc;		
-	u32 txsc_m;		
-	u32 cfo_comp;	
-	u32 cfo_comp_m;	
-	u32 pkt_ext_idx;
-	u32 pkt_ext_idx_m;		
-	u32 usr0_n_sts;		
-	u32 usr0_n_sts_m;	
-	u32 usr0_n_sts_ru_tot;	
-	u32 usr0_n_sts_ru_tot_m;
-	u32 usr0_strt_sts;		
-	u32 usr0_strt_sts_m;	
-	u32 usr1_n_sts;		
-	u32 usr1_n_sts_m;	
-	u32 usr1_n_sts_ru_tot;
-	u32 usr1_n_sts_ru_tot_m;
-	u32 usr1_strt_sts;	
-	u32 usr1_strt_sts_m;
-	u32 usr2_n_sts;	
-	u32 usr2_n_sts_m;	
-	u32 usr2_n_sts_ru_tot;	
-	u32 usr2_n_sts_ru_tot_m;	
-	u32 usr2_strt_sts;	
-	u32 usr2_strt_sts_m;	
-	u32 usr3_n_sts;		
-	u32 usr3_n_sts_m;	
-	u32 usr3_n_sts_ru_tot;
-	u32 usr3_n_sts_ru_tot_m;
-	u32 usr3_strt_sts;		
-	u32 usr3_strt_sts_m;	
-	u32 source_gen_mode_idx;	
-	u32 source_gen_mode_idx_m;	
-	u32 gi_type;		
-	u32 gi_type_m;		
-	u32 ltf_type;		
-	u32 ltf_type_m;	
-	u32 dbw_idx;		
-	u32 dbw_idx_m;	
-	u32 pre_fec_fctr;	
-	u32 pre_fec_fctr_m;	
-	u32 beam_change_en;	
-	u32 beam_change_en_m;
-	u32 doppler_en;		
-	u32 doppler_en_m;	
-	u32 fb_mumimo_en;	
-	u32 fb_mumimo_en_m;	
-	u32 feedback_status;
-	u32 feedback_status_m;		
-	u32 he_sigb_dcm_en;	
-	u32 he_sigb_dcm_en_m;	
-	u32 midamble_mode;	
-	u32 midamble_mode_m;
-	u32 mumimo_ltf_mode_en;		
-	u32 mumimo_ltf_mode_en_m;	
-	u32 ndp;		
-	u32 ndp_m;		
-	u32 stbc_en;	
-	u32 stbc_en_m;	
-	u32 ant_sel_a;	
-	u32 ant_sel_a_m;	
-	u32 ant_sel_b;	
-	u32 ant_sel_b_m;	
-	u32 ant_sel_c;	
-	u32 ant_sel_c_m;	
-	u32 ant_sel_d;	
-	u32 ant_sel_d_m;	
-	u32 cca_pw_th_en;
-	u32 cca_pw_th_en_m;	
-	u32 rf_fixed_gain_en;
-	u32 rf_fixed_gain_en_m;
-	u32 ul_cqi_rpt_tri;		
-	u32 ul_cqi_rpt_tri_m;	
-	u32 ldpc_extr;		
-	u32 ldpc_extr_m;	
-	u32 usr0_dcm_en;		
-	u32 usr0_dcm_en_m;		
-	u32 usr0_fec_type;		
-	u32 usr0_fec_type_m;		
-	u32 usr0_txbf_en;		
-	u32 usr0_txbf_en_m;		
-	u32 usr1_dcm_en;	
-	u32 usr1_dcm_en_m;		
-	u32 usr1_fec_type;		
-	u32 usr1_fec_type_m;		
-	u32 usr1_txbf_en;		
-	u32 usr1_txbf_en_m;		
-	u32 usr2_dcm_en;		
-	u32 usr2_dcm_en_m;		
-	u32 usr2_fec_type;		
-	u32 usr2_fec_type_m;		
-	u32 usr2_txbf_en;		
-	u32 usr2_txbf_en_m;		
-	u32 usr3_dcm_en;		
-	u32 usr3_dcm_en_m;		
-	u32 usr3_fec_type;		
-	u32 usr3_fec_type_m;	
-	u32 usr3_txbf_en;		
-	u32 usr3_txbf_en_m;
-	u32 usr0_precoding_mode_idx;
-	u32 usr0_precoding_mode_idx_m;
-	u32 usr1_precoding_mode_idx;
-	u32 usr1_precoding_mode_idx_m;
-	u32 usr2_precoding_mode_idx;
-	u32 usr2_precoding_mode_idx_m;
-	u32 usr3_precoding_mode_idx;
-	u32 usr3_precoding_mode_idx_m;
-	u32 b_rate_idx;
-	u32 b_rate_idx_m;
-	u32 b_locked_clk_en;
-	u32 b_locked_clk_en_m;
-	u32 max_mcs;
-	u32 max_mcs_m;
-	u32 tx_tri_idx;
-	u32 tx_tri_idx_m;
-	u32 tx_tri_pw_ofst;
-	u32 tx_tri_pw_ofst_m;
-};
-
-struct bb_plcp_info {
-	struct bb_plcp_cr_info bb_plcp_cr_i;
-};
-
-
-/*  ============================================================
- 		     Function Prototype
-    ============================================================
-*/
-
-struct bb_info;
-
-void halbb_cr_cfg_plcp_init(struct bb_info *bb);
-
-void halbb_plcp_init(struct bb_info *bb);
-
-#endif
diff --git a/os/board/rtl8720e/src/component/wifi/driver/src/hal/phy_g6/bb/halbb_plcp_tx_ex.h b/os/board/rtl8720e/src/component/wifi/driver/src/hal/phy_g6/bb/halbb_plcp_tx_ex.h
deleted file mode 100644
index 12bd4f9b3..000000000
--- a/os/board/rtl8720e/src/component/wifi/driver/src/hal/phy_g6/bb/halbb_plcp_tx_ex.h
+++ /dev/null
@@ -1,231 +0,0 @@
-/******************************************************************************
- *
- * Copyright(c) 2007 - 2020  Realtek Corporation.
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of version 2 of the GNU General Public License as
- * published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
- * more details.
- *
- * The full GNU General Public License is included in this distribution in the
- * file called LICENSE.
- *
- * Contact Information:
- * wlanfae <wlanfae@realtek.com>
- * Realtek Corporation, No. 2, Innovation Road II, Hsinchu Science Park,
- * Hsinchu 300, Taiwan.
- *
- * Larry Finger <Larry.Finger@lwfinger.net>
- *
- *****************************************************************************/
-
-#ifndef _HALBB_PLCP_TX_EX_H_
-#define _HALBB_PLCP_TX_EX_H_
-/*  ============================================================
- 			   define
-    ============================================================
-*/
-#define N_USER	4
-#define DL_STA_LIST_MAX_NUM    8
-/*  ============================================================
- 			Enumeration
-    ============================================================
- */
-
-enum plcp_sts {
-	PLCP_SUCCESS = 0,
-	LENGTH_EXCEED,
-	CCK_INVALID,
-	OFDM_INVALID,
-	HT_INVALID,
-	VHT_INVALID,
-	HE_INVALID,
-	SPEC_INVALID
-};
-/*  ============================================================
- 			   structure
-    ============================================================
-*/
-struct cr_address_t {
-	u32 address;
-	u32 bitmask;
-};
-
-struct ru_rate_entry {
-    u8 dcm: 1;
-    u8 ss: 3;
-    u8 mcs: 4;
-};
-
-struct rura_report {
-    u8 rate_table_col_idx: 6;
-    u8 partial_allocation_flag: 1;
-    u8 rate_change_flag: 1;
-};
-
-struct dl_ru_output_sta_entry {
-    u8 dropping_flag: 1; //0
-    u8 txbf: 1;
-    u8 coding: 1;
-    u8 nsts: 3;
-    u8 rsvd0: 2;
-
-    u8 mac_id: 8;
-    u8 ru_position: 8;
-
-    u8 vip_flag: 1; //dont care
-    u8 pwr_boost_factor: 5; //dont care
-    u8 rsvd1: 2;
-
-    u32 tx_length;
-
-    struct ru_rate_entry ru_rate;
-    //for dl rura
-    struct rura_report ru_ra_report;
-};
-
-struct dl_rua_output {
-    u16 ru2su_flag: 1;
-    u16 ppdu_bw: 2;  //set
-    u16 group_tx_pwr: 9;
-    u16 stbc: 1;
-    u16 gi_ltf: 3;
-
-    u8 doppler: 1;
-    u8 n_ltf_and_ma: 3;
-    u8 sta_list_num: 4; //set
-
-    u8 grp_mode: 1;
-    u8 rsvd0: 6;
-    u8 fixed_mode: 1; //set 1
-
-    u8 group_id: 8;
-    u32 rsvd1:24;
-    struct dl_ru_output_sta_entry  dl_output_sta_list[DL_STA_LIST_MAX_NUM];
-};
-
-//sig-b output
-struct sigb_compute_output {
-    u32 sta_0_idx: 3;
-    u32 sta_1_idx: 3;
-    u32 sta_2_idx: 3;
-    u32 sta_3_idx: 3;
-    u32 sta_4_idx: 3;
-    u32 sta_5_idx: 3;
-    u32 sta_6_idx: 3;
-    u32 sta_7_idx: 3;
-    u32 rsvd: 8;
-    u32 hw_sigb_content_channelone_len: 8;
-    u32 hw_sigb_content_channeltwo_len: 8;
-    u32 hw_sigb_symbolnum: 6;
-    u32 hw_sigb_content_channeltwo_offset: 5; //have to +1
-    u32 ru2su_flag: 1;
-    u32 sigb_dcm: 1;
-    u32 sigb_mcs: 3;
-};
-
-struct bb_h2c_he_sigb {
-	u16 aid12[4];
-	u8 force_sigb_rate;
-	u8 force_sigb_mcs;
-	u8 force_sigb_dcm;
-	u8 rsvd;
-	struct dl_rua_output dl_rua_out;
-	struct sigb_compute_output  sigb_output;
-	struct cr_address_t n_sym_sigb_ch1[16];
-	struct cr_address_t n_sym_sigb_ch2[16];
-};
-
-//========== [Outer-Input] ==========//
-struct usr_plcp_gen_in {
-	u32 mcs : 6;
-	u32 mpdu_len : 14;
-	u32 n_mpdu : 9;
-	u32 fec : 1;
-	u32 dcm : 1;
-	u32 rsvd0 : 1;
-	u32 aid : 12;
-	u32 scrambler_seed : 8; // rand (1~255)
-	u32 random_init_seed : 8; // rand (1~255)
-	u32 rsvd1 : 4;
-	u32 apep : 22;
-	u32 ru_alloc : 8;
-	u32 rsvd2 : 2;
-	u32 nss : 4;
-	u32 txbf : 1;
-	u32 pwr_boost_db : 5;
-	u32 rsvd3 : 22;
-};
-
-struct halbb_plcp_info {
-	u32 dbw : 2; //0:BW20, 1:BW40, 2:BW80, 3:BW160/BW80+80
-	u32 source_gen_mode : 2;
-	u32 locked_clk : 1;
-	u32 dyn_bw : 1;
-	u32 ndp_en : 1;
-	u32 long_preamble_en : 1; //bmode
-	u32 stbc : 1;
-	u32 gi : 2; //0:0.4,1:0.8,2:1.6,3:3.2
-	u32 tb_l_len : 12;
-	u32 tb_ru_tot_sts_max : 3;
-	u32 vht_txop_not_allowed : 1;
-	u32 tb_disam : 1;
-	u32 doppler : 2;
-	u32 he_ltf_type : 2;//0:1x,1:2x,2:4x
-
-	u32 ht_l_len : 12;		
-	u32 preamble_puncture : 1;		
-	u32 he_mcs_sigb : 3;//0~5
-	u32 he_dcm_sigb : 1;
-	u32 he_sigb_compress_en : 1;
-	u32 max_tx_time_0p4us : 14;
-	
-
-	u32 ul_flag : 1;
-	u32 tb_ldpc_extra : 1;
-	u32 bss_color : 6;
-	u32 sr : 4;
-	u32 beamchange_en : 1;
-	u32 he_er_u106ru_en : 1;
-	u32 ul_srp1 : 4;
-	u32 ul_srp2 : 4;
-	u32 ul_srp3 : 4;
-	u32 ul_srp4 : 4;
-	u32 mode : 2;
-
-	u32 group_id : 6;	
-	u32 ppdu_type : 4;//0: bmode,1:Legacy,2:HT_MF,3:HT_GF,4:VHT,5:HE_SU,6:HE_ER_SU,7:HE_MU,8:HE_TB
-	u32 txop : 7;
-	u32 tb_strt_sts : 3;
-	u32 tb_pre_fec_padding_factor : 2;
-	u32 cbw : 2;
-	u32 txsc : 4;
-	u32 tb_mumimo_mode_en : 1;
-	u32 rsvd1 : 3;
-
-	u8 nominal_t_pe : 2; // def = 2
-	u8 ness : 2; // def = 0
-	u8 rsvd2 : 4;
-
-	u8 n_user;
-	u16 tb_rsvd : 9;//def = 0
-	u16 rsvd3 : 7;
-	
-	struct usr_plcp_gen_in usr[N_USER];
-};
-
-/*  ============================================================
- 		     Function Prototype
-    ============================================================
-*/
-
-struct bb_info;
-
-enum plcp_sts halbb_plcp_gen(struct bb_info *bb, struct halbb_plcp_info *in,
-		    struct usr_plcp_gen_in *user, enum phl_phy_idx phy_idx);
-
-#endif
diff --git a/os/board/rtl8720e/src/component/wifi/driver/src/hal/phy_g6/bb/halbb_pmac_setting.h b/os/board/rtl8720e/src/component/wifi/driver/src/hal/phy_g6/bb/halbb_pmac_setting.h
deleted file mode 100644
index 8cd350fd3..000000000
--- a/os/board/rtl8720e/src/component/wifi/driver/src/hal/phy_g6/bb/halbb_pmac_setting.h
+++ /dev/null
@@ -1,53 +0,0 @@
-/******************************************************************************
- *
- * Copyright(c) 2007 - 2020  Realtek Corporation.
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of version 2 of the GNU General Public License as
- * published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
- * more details.
- *
- * The full GNU General Public License is included in this distribution in the
- * file called LICENSE.
- *
- * Contact Information:
- * wlanfae <wlanfae@realtek.com>
- * Realtek Corporation, No. 2, Innovation Road II, Hsinchu Science Park,
- * Hsinchu 300, Taiwan.
- *
- * Larry Finger <Larry.Finger@lwfinger.net>
- *
- *****************************************************************************/
-
-#ifndef _HALBB_PMAC_SETTING_H_
-#define _HALBB_PMAC_SETTING_H_
-
-/*  ============================================================
- 			Enumeration
-    ============================================================
- */
-
-enum halbb_pmac_mode {
-	NONE_TEST,
-	PKTS_TX,
-	PKTS_RX,
-	CONT_TX,
-	FW_TRIG_TX,
-	OFDM_SINGLE_TONE_TX,
-	CCK_CARRIER_SIPPRESSION_TX
-};
-/*  ============================================================
- 		     Function Prototype
-    ============================================================
-*/
-
-struct bb_info;
-
-void halbb_pmac_tx_dbg(struct bb_info *bb, char input[][16], u32 *_used,
-		       char *output, u32 *_out_len);
-
-#endif
diff --git a/os/board/rtl8720e/src/component/wifi/driver/src/hal/phy_g6/bb/halbb_pmac_setting_ex.h b/os/board/rtl8720e/src/component/wifi/driver/src/hal/phy_g6/bb/halbb_pmac_setting_ex.h
deleted file mode 100644
index 7a825ed6a..000000000
--- a/os/board/rtl8720e/src/component/wifi/driver/src/hal/phy_g6/bb/halbb_pmac_setting_ex.h
+++ /dev/null
@@ -1,118 +0,0 @@
-/******************************************************************************
- *
- * Copyright(c) 2007 - 2020  Realtek Corporation.
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of version 2 of the GNU General Public License as
- * published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
- * more details.
- *
- * The full GNU General Public License is included in this distribution in the
- * file called LICENSE.
- *
- * Contact Information:
- * wlanfae <wlanfae@realtek.com>
- * Realtek Corporation, No. 2, Innovation Road II, Hsinchu Science Park,
- * Hsinchu 300, Taiwan.
- *
- * Larry Finger <Larry.Finger@lwfinger.net>
- *
- *****************************************************************************/
-
-#ifndef _HALBB_PMAC_SETTING_EX_H_
-#define _HALBB_PMAC_SETTING_EX_H_
-#include "halbb_ic_hw_info.h"
-#include "halbb_pmac_setting.h"
-
-/*  ============================================================
- 			   structure
-    ============================================================
-*/
-struct halbb_pmac_info {
-	u8 en_pmac_tx:1; /*0: PMAC Tx Off 1: PMAC Tx On */
-	u8 is_cck:1;
-	u8 mode:3; /*1: Packet TX 3:Continuous TX */
-	u8 rsvd:3;
-	u16 tx_cnt;
-	u16 period; // unit=50ns
-	u16 tx_time; // us
-	u8 duty_cycle; // for fw trig. tx used
-	bool cck_lbk_en;
-};
-
-struct bb_h2c_fw_tx_setting {
-	u8 pkt_cnt[2];
-	bool tx_en;
-	u8 tx_type;
-	u8 tx_period[4];
-	u8 tx_time[4];
-	u8 duty_cycle[4];
-};
-
-struct bb_c2h_fw_tx_rpt {
-	bool tx_done;
-};
-
-
-/*  ============================================================
- 		     Function Prototype
-    ============================================================
-*/
-
-struct bb_info;
-
-void halbb_set_pmac_tx(struct bb_info *bb, struct halbb_pmac_info *tx_info,
-		       enum phl_phy_idx phy_idx);
-
-void halbb_set_tmac_tx(struct bb_info *bb, enum phl_phy_idx phy_idx);
-
-bool halbb_cfg_lbk(struct bb_info *bb, bool lbk_en, bool is_dgt_lbk,
-		   enum rf_path tx_path, enum rf_path rx_path,
-		   enum channel_width bw, enum phl_phy_idx phy_idx);
-
-bool halbb_cfg_lbk_cck(struct bb_info *bb, bool lbk_en, bool is_dgt_lbk,
-		       enum rf_path tx_path, enum rf_path rx_path,
-		       enum channel_width bw, enum phl_phy_idx phy_idx);
-
-bool halbb_set_txpwr_dbm(struct bb_info *bb, s16 pwr_dbm,
-			 enum phl_phy_idx phy_idx);
-
-s16 halbb_get_txpwr_dbm(struct bb_info *bb, enum phl_phy_idx phy_idx);
-
-s16 halbb_get_txinfo_txpwr_dbm(struct bb_info *bb);
-
-bool halbb_set_cck_txpwr_idx(struct bb_info *bb, u16 pwr_idx,
-			     enum rf_path tx_path);
-
-u16 halbb_get_cck_txpwr_idx(struct bb_info *bb, enum rf_path tx_path);
-
-s16 halbb_get_cck_ref_dbm(struct bb_info *bb, enum rf_path tx_path);
-
-bool halbb_set_ofdm_txpwr_idx(struct bb_info *bb, u16 pwr_idx,
-			      enum rf_path tx_path);
-
-u16 halbb_get_ofdm_txpwr_idx(struct bb_info *bb, enum rf_path tx_path);
-
-s16 halbb_get_ofdm_ref_dbm(struct bb_info *bb, enum rf_path tx_path);
-
-bool halbb_chk_tx_idle(struct bb_info *bb, enum phl_phy_idx phy_idx);
-
-void halbb_dpd_bypass(struct bb_info *bb, bool pdp_bypass,
-		      enum phl_phy_idx phy_idx);
-
-void halbb_backup_info(struct bb_info *bb, enum phl_phy_idx phy_idx);
-
-void halbb_restore_info(struct bb_info *bb, enum phl_phy_idx phy_idx);
-
-bool halbb_set_txsc(struct bb_info *bb, u8 txsc, enum phl_phy_idx phy_idx);
-
-bool halbb_set_bss_color(struct bb_info *bb, u8 bss_color, 
-			 enum phl_phy_idx phy_idx);
-
-bool halbb_set_sta_id(struct bb_info *bb, u16 sta_id, enum phl_phy_idx phy_idx);
-
-#endif
diff --git a/os/board/rtl8720e/src/component/wifi/driver/src/hal/phy_g6/bb/halbb_precomp.h b/os/board/rtl8720e/src/component/wifi/driver/src/hal/phy_g6/bb/halbb_precomp.h
deleted file mode 100644
index 5e53af699..000000000
--- a/os/board/rtl8720e/src/component/wifi/driver/src/hal/phy_g6/bb/halbb_precomp.h
+++ /dev/null
@@ -1,170 +0,0 @@
-/******************************************************************************
- *
- * Copyright(c) 2007 - 2020  Realtek Corporation.
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of version 2 of the GNU General Public License as
- * published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
- * more details.
- *
- * The full GNU General Public License is included in this distribution in the
- * file called LICENSE.
- *
- * Contact Information:
- * wlanfae <wlanfae@realtek.com>
- * Realtek Corporation, No. 2, Innovation Road II, Hsinchu Science Park,
- * Hsinchu 300, Taiwan.
- *
- * Larry Finger <Larry.Finger@lwfinger.net>
- *
- *****************************************************************************/
-#ifndef __HALBB_PRECOMP_H__
-#define __HALBB_PRECOMP_H__
-
-#include "../../hal_headers_le.h"
-#include "halbb_cfg_ic.h"
-
-/*---[Define Only] ----------------------------------------------------------*/
-#include "halbb_types.h"
-#include "halbb_features.h"
-#include "halbb_ic_hw_info.h"
-#include "halbb_ic_sw_info.h"
-#include "halbb_interface.h"
-#include "halbb_dbg.h"
-#include "halbb_dbg_cnsl_out.h"
-#include "halbb_rua_tbl_ex.h"
-
-#if (PLATFOM_IS_LITTLE_ENDIAN)
-	#include "halbb_physts_ie_l_endian.h"
-	#include "halbb_ra_l_endian.h"
-	#include "halbb_rua_tbl_l_endian.h"
-#else
-	#include "halbb_physts_ie_b_endian.h"
-	#include "halbb_ra_b_endian.h"
-	#include "halbb_rua_tbl_b_endian.h"
-#endif
-
-/*---[Include structure & prototype] ----------------------------------------*/
-#ifdef BB_8852A_2_SUPPORT
-	#include "halbb_8852a_2/halbb_cr_info_8852a_2.h"
-	#include "halbb_8852a_2/halbb_8852a_2.h"
-	#include "halbb_8852a_2/halbb_8852a_2_api.h"
-	#include "halbb_8852a_2/halbb_8852a_2_api_ex.h"
-	#include "halbb_8852a_2/halbb_hwimg_8852a_2.h"
-	#include "halbb_8852a_2/halbb_reg_cfg_8852a_2.h"
-	#include "halbb_8852a_2/halbb_version_rtl8852a_2.h"
-#endif
-
-#ifdef BB_8852B_SUPPORT
-	#include "halbb_8852b/halbb_cr_info_8852b.h"
-	#include "halbb_8852b/halbb_8852b.h"
-	#include "halbb_8852b/halbb_8852b_api.h"
-	#include "halbb_8852b/halbb_8852b_api_ex.h"
-	#include "halbb_8852b/halbb_8852b_fwofld_api.h"
-	#include "halbb_8852b/halbb_hwimg_8852b.h"
-	#include "halbb_8852b/halbb_reg_cfg_8852b.h"
-	#include "halbb_8852b/halbb_version_rtl8852b.h"
-#endif
-
-#ifdef BB_8852C_SUPPORT
-	#include "halbb_8852c/halbb_cr_info_8852c.h"
-	#include "halbb_8852c/halbb_8852c.h"
-	#include "halbb_8852c/halbb_8852c_api.h"
-	#include "halbb_8852c/halbb_8852c_api_ex.h"
-	#include "halbb_8852c/halbb_8852c_fwofld_api.h"
-	#include "halbb_8852c/halbb_hwimg_8852c.h"
-	#include "halbb_8852c/halbb_reg_cfg_8852c.h"
-	#include "halbb_8852c/halbb_version_rtl8852c.h"
-#endif
-
-#ifdef BB_8192XB_SUPPORT
-	#include "halbb_8192xb/halbb_cr_info_8192xb.h"
-	#include "halbb_8192xb/halbb_8192xb.h"
-	#include "halbb_8192xb/halbb_8192xb_api.h"
-	#include "halbb_8192xb/halbb_8192xb_api_ex.h"
-	#include "halbb_8192xb/halbb_hwimg_8192xb.h"
-	#include "halbb_8192xb/halbb_reg_cfg_8192xb.h"
-	#include "halbb_8192xb/halbb_version_rtl8192xb.h"
-#endif
-
-#ifdef BB_8730E_SUPPORT
-#include "halbb_8730e/halbb_cr_info_8730e.h"
-#include "halbb_8730e/halbb_8730e.h"
-#include "halbb_8730e/halbb_8730e_api.h"
-#include "halbb_8730e/halbb_8730e_api_ex.h"
-#include "halbb_8730e/halbb_hwimg_8730e.h"
-#include "halbb_8730e/halbb_reg_cfg_8730e.h"
-#include "halbb_8730e/halbb_version_rtl8730e.h"
-#endif
-
-#ifdef BB_8720E_SUPPORT
-#include "halbb_8720e/halbb_cr_info_8720e.h"
-#include "halbb_8720e/halbb_8720e.h"
-#include "halbb_8720e/halbb_8720e_api.h"
-#include "halbb_8720e/halbb_8720e_api_ex.h"
-#include "halbb_8720e/halbb_hwimg_8720e.h"
-#include "halbb_8720e/halbb_reg_cfg_8720e.h"
-#include "halbb_8720e/halbb_version_rtl8720e.h"
-#endif
-
-#include "halbb_ra.h"
-#include "halbb_ra_ex.h"
-#include "halbb_hw_cfg.h"
-#include "halbb_hw_cfg_ex.h"
-#include "halbb_api.h"
-#include "halbb_api_ex.h"
-#include "halbb_interface_ex.h"
-#include "halbb_math_lib_ex.h"
-#include "halbb_math_lib.h"
-#include "halbb_dbg_cmd.h"
-#include "halbb_dbg_cmd_ex.h"
-#include "halbb_physts_ex.h"
-#include "halbb_physts.h"
-#include "halbb_cmn_rpt_ex.h"
-#include "halbb_cmn_rpt.h"
-#include "halbb_init.h"
-#include "halbb_init_ex.h"
-#include "halbb_pmac_setting.h"
-#include "halbb_pmac_setting_ex.h"
-#include "halbb_plcp_tx_ex.h"
-#include "halbb_plcp_tx.h"
-#include "halbb_plcp_gen.h"
-#include "halbb_la_mode_ex.h"
-#include "halbb_la_mode.h"
-#include "halbb_psd.h"
-#include "halbb_ul_tb_ctrl.h"
-#include "halbb_pwr_ctrl_ex.h"
-#include "halbb_pwr_ctrl.h"
-#include "halbb_mp_ex.h"
-#include "halbb_dfs.h"
-#include "halbb_dfs_ex.h"
-#include "halbb_cfo_trk.h"
-#include "halbb_edcca.h"
-#include "halbb_edcca_ex.h"
-#include "halbb_env_mntr_ex.h"
-#include "halbb_env_mntr.h"
-#include "halbb_dig_ex.h"
-#include "halbb_dig.h"
-#include "halbb_dyn_csi_rsp.h"
-#include "halbb_dyn_csi_rsp_ex.h"
-#include "halbb_ant_div.h"
-#include "halbb_path_div.h"
-#include "halbb_statistics.h"
-#include "halbb_ch_info_ex.h"
-#include "halbb_ch_info.h"
-#include "halbb_auto_dbg.h"
-#include "halbb_dbcc_ex.h"
-#include "halbb_dbcc.h"
-#include "halbb_rua_tbl.h"
-#include "halbb_spur_suppress.h"
-#include "halbb_fwofld.h"
-#include "halbb_fwofld_ex.h"
-#include "halbb_dyn_1r_cca.h"
-#include "halbb_ex.h"
-#include "halbb.h"
-
-#endif
diff --git a/os/board/rtl8720e/src/component/wifi/driver/src/hal/phy_g6/bb/halbb_psd.h b/os/board/rtl8720e/src/component/wifi/driver/src/hal/phy_g6/bb/halbb_psd.h
deleted file mode 100644
index 0b5df8f70..000000000
--- a/os/board/rtl8720e/src/component/wifi/driver/src/hal/phy_g6/bb/halbb_psd.h
+++ /dev/null
@@ -1,115 +0,0 @@
-/******************************************************************************
- *
- * Copyright(c) 2007 - 2020  Realtek Corporation.
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of version 2 of the GNU General Public License as
- * published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
- * more details.
- *
- * The full GNU General Public License is included in this distribution in the
- * file called LICENSE.
- *
- * Contact Information:
- * wlanfae <wlanfae@realtek.com>
- * Realtek Corporation, No. 2, Innovation Road II, Hsinchu Science Park,
- * Hsinchu 300, Taiwan.
- *
- * Larry Finger <Larry.Finger@lwfinger.net>
- *
- *****************************************************************************/
-#ifndef __HALBB_PSD_H__
-#define __HALBB_PSD_H__
-
-/*@--------------------------[Define] ---------------------------------------*/
-
-/*@--------------------------[Enum]------------------------------------------*/
-enum igi_lv_sel {
-	IGI_DEFAULT		= 0,/*@default value*/
-	IGI_LEVEL1		= 1,
-	IGI_LEVEL2		= 2,
-	IGI_LEVEL3		= 3,
-	IGI_LEVEL4		= 4,
-	IGI_LEVEL5		= 5,
-	IGI_LEVEL6		= 6,
-	IGI_LEVEL7		= 7
-};
-/*@--------------------------[Structure]-------------------------------------*/
-
-struct bb_psd_cr_info {
-	u32 psd_clk_en;
-	u32 psd_clk_en_m;
-	u32 psd_pw;
-	u32 psd_pw_m;
-	u32 psd_ok_flag;
-	u32 psd_ok_flag_m;
-	u32 psd_fft_idx;
-	u32 psd_fft_idx_m;
-	u32 psd_iq_sel;
-	u32 psd_iq_sel_m;
-	u32 psd_l_avg;
-	u32 psd_l_avg_m;
-	u32 psd_n_dft;
-	u32 psd_n_dft_m;
-	u32 psd_path_sel;
-	u32 psd_path_sel_m;
-	u32 psd_source_sel;
-	u32 psd_source_sel_m;
-	u32 psd_en;
-	u32 psd_en_m;
-	
-};
-
-struct bb_psd_info {
-	struct bb_psd_cr_info bb_psd_cr_i;
-	u8	psd_in_progress;
-	u8	psd_pwr_common_offset;
-	u8	hw_avg_time;
-	u16	sw_avg_time;
-	u16	fft_point;
-	u16	fft_point_pre;
-	u32	rf_0x18_bkp;
-	u32	rf_0x18_bkp_b;
-	u8	pri_ch;
-	u8	fc_ch;
-	u32	psd_bw;
-	u32	psd_result[128];
-	u8	i_q_setting;
-	u8	path;
-	u8	bw;
-	u8	input;
-	u8	noise_k_en;
-	u8	lna_bkp;
-	u8	lna_bkp_b;
-	u8	tia_bkp;
-	u8	tia_bkp_b;
-	u8	rxbb_bkp;
-	u8	rxbb_bkp_b;
-	u8	igi_pin;
-	u32	*rpt;
-	enum band_type band;
-};
-
-struct bb_info;
-/*@--------------------------[Prptotype]-------------------------------------*/
-void halbb_psd_igi_lv(struct bb_info *bb, enum igi_lv_sel igi_lv);
-u32 halbb_get_psd_data(struct bb_info *bb, u32 psd_tone_idx, u32 igi_pin);
-void halbb_psd_para_setting(struct bb_info *bb, u8 sw_avg_time, u8 hw_avg_time,
-			    u8 i_q_setting, u16 fft_point, u8 path,
-			    u8 psd_input, u8 pri_ch,u8 channel, u8 bw, enum band_type band);
-bool halbb_psd_alloc_buff(struct bb_info *bb);
-void halbb_get_gain_index(struct bb_info *bb);
-u8 halbb_psd(struct bb_info *bb, enum igi_lv_sel igi, u16 start_point,
-	     u16 stop_point);
-void halbb_psd_dbg(struct bb_info *bb, char input[][16], u32 *_used,
-		   char *output, u32 *_out_len);
-void halbb_psd_init(struct bb_info *bb);
-void halbb_psd_deinit(struct bb_info *bb);
-bool halbb_get_psd_result(struct bb_info *bb, u32 *psd_data, u16 *psd_len);
-void halbb_cr_cfg_psd_init(struct bb_info *bb);
-#endif
-
diff --git a/os/board/rtl8720e/src/component/wifi/driver/src/hal/phy_g6/bb/halbb_pwr_ctrl.h b/os/board/rtl8720e/src/component/wifi/driver/src/hal/phy_g6/bb/halbb_pwr_ctrl.h
deleted file mode 100644
index c67ff1c6b..000000000
--- a/os/board/rtl8720e/src/component/wifi/driver/src/hal/phy_g6/bb/halbb_pwr_ctrl.h
+++ /dev/null
@@ -1,114 +0,0 @@
-/******************************************************************************
- *
- * Copyright(c) 2007 - 2020  Realtek Corporation.
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of version 2 of the GNU General Public License as
- * published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
- * more details.
- *
- * The full GNU General Public License is included in this distribution in the
- * file called LICENSE.
- *
- * Contact Information:
- * wlanfae <wlanfae@realtek.com>
- * Realtek Corporation, No. 2, Innovation Road II, Hsinchu Science Park,
- * Hsinchu 300, Taiwan.
- *
- * Larry Finger <Larry.Finger@lwfinger.net>
- *
- *****************************************************************************/
-#ifndef __HALBB_PWR_CTRL_H__
-#define __HALBB_PWR_CTRL_H__
-
-/*@--------------------------[Define] ---------------------------------------*/
-#define REG_PWRMACID_OFST	0x0016c
-#define MACREG_PWRMACID_CR	0x0D36c
-#define HALBB_PWR_STATE_NUM	3
-#define DTP_FLOOR_UP_GAP 3
-#define TX_HP_LV_0 0
-#define TX_HP_LV_1 1
-#define TX_HP_LV_2 2
-#define TX_HP_LV_3 3
-#define TX_HP_LV_UNCHANGE	4
-/*#if (DM_ODM_SUPPORT_TYPE == ODM_AP)*/
-#define TX_PWR_TH_LVL3 87
-#define TX_PWR_TH_LVL2 78
-#define TX_PWR_TH_LVL1 70
-/*#elif (DM_ODM_SUPPORT_TYPE == ODM_WIN)
-#define TX_PWR_TH_LVL3 90
-#define TX_PWR_TH_LVL2 85
-#define TX_PWR_TH_LVL1 80
-#endif*/
-#define TX_PWR_LVL3 6	/*3dBm*/
-#define TX_PWR_LVL2 12	/*6dBm*/
-#define TX_PWR_LVL1 20	/*10dBm*/
-
-#define TSSI_CFG_NUM 4
-#define TSSI_SBW_NUM 15
-/*@--------------------------[Enum]------------------------------------------*/
-/*@--------------------------[Structure]-------------------------------------*/
-/* @ Dynamic CCA TH part */
-struct bb_macidcca_info {
-	bool cca_th_en;
-	s8 cca_th;
-};
-
-struct bb_dyncca_info {
-	/* [] */
-	bool dyncca_en;
-	u8 dyncca_offset;
-	u8 dyncca_offset_n;
-	/**/
-	struct bb_macidcca_info macidcca_i[PHL_MAX_STA_NUM];
-};
-
-/* @ Power Ctrl part */
-struct bb_dtp_info {
-	/*u8	dyn_tx_power;
-	u8	last_tx_power;*/
-	u8	dyn_tx_pwr_lvl:4;
-	u8	last_pwr_lvl:4;
-
-	s8	pwr_val[2]; /* S(8,1) */
-	bool	en_pwr[2];
-};
-
-struct bb_tssi_info {
-	u32 tssi_dbw_table[TSSI_CFG_NUM][TSSI_SBW_NUM];
-};
-
-struct bb_pwr_ctrl_info {
-	u8 pwr;
-
-	/* [] */
-	u8 enhance_pwr_th[HALBB_PWR_STATE_NUM];
-	u8 set_pwr_th[HALBB_PWR_STATE_NUM];
-	s8 pwr_lv_dbm[HALBB_PWR_STATE_NUM];
-	/**/
-	struct bb_dtp_info dtp_i[PHL_MAX_STA_NUM];
-	struct bb_tssi_info tssi_i;
-};
-
-struct bb_info;
-/*@--------------------------[Prptotype]-------------------------------------*/
-#ifdef HALBB_PWR_CTRL_SUPPORT
-void halbb_pwr_ctrl(struct bb_info *bb);
-void halbb_pwr_ctrl_init(struct bb_info *bb);
-void halbb_set_pwr_macid_idx(struct bb_info *bb, u16 macid, s8 pwr, bool pwr_en, u8 idx);
-void halbb_pwr_ctrl_dbg(struct bb_info *bb, char input[][16], u32 *_used,
-		   char *output, u32 *_out_len);
-#endif
-void halbb_macid_ctrl_init(struct bb_info *bb);
-void halbb_tpu_mac_cr_init(struct bb_info *bb, enum phl_phy_idx phy_idx);
-void halbb_tssi_ctrl_mac_cr_init(struct bb_info *bb, enum phl_phy_idx phy_idx);
-void halbb_tssi_ctrl_set_dbw_table(struct bb_info *bb);
-void halbb_tssi_ctrl_set_fast_mode_cfg(struct bb_info *bb, enum phl_band_idx band,
-						enum tssi_bandedge_cfg bandedge_cfg);
-void halbb_pwr_dbg(struct bb_info *bb, char input[][16], u32 *_used,
-		   char *output, u32 *_out_len);
-#endif
\ No newline at end of file
diff --git a/os/board/rtl8720e/src/component/wifi/driver/src/hal/phy_g6/bb/halbb_pwr_ctrl_ex.h b/os/board/rtl8720e/src/component/wifi/driver/src/hal/phy_g6/bb/halbb_pwr_ctrl_ex.h
deleted file mode 100644
index f1a3e60ef..000000000
--- a/os/board/rtl8720e/src/component/wifi/driver/src/hal/phy_g6/bb/halbb_pwr_ctrl_ex.h
+++ /dev/null
@@ -1,43 +0,0 @@
-/******************************************************************************
- *
- * Copyright(c) 2007 - 2020  Realtek Corporation.
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of version 2 of the GNU General Public License as
- * published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
- * more details.
- *
- * The full GNU General Public License is included in this distribution in the
- * file called LICENSE.
- *
- * Contact Information:
- * wlanfae <wlanfae@realtek.com>
- * Realtek Corporation, No. 2, Innovation Road II, Hsinchu Science Park,
- * Hsinchu 300, Taiwan.
- *
- * Larry Finger <Larry.Finger@lwfinger.net>
- *
- *****************************************************************************/
-#ifndef __HALBB_PWR_CTRL_EX_H__
-#define __HALBB_PWR_CTRL_EX_H__
-
-/*@--------------------------[Enum]------------------------------------------*/
-enum tssi_bandedge_cfg {
-	TSSI_BANDEDGE_FLAT = 0,
-	TSSI_BANDEDGE_LOW  = 1,
-	TSSI_BANDEDGE_MID  = 2,
-	TSSI_BANDEDGE_HIGH = 3
-};
-/*@--------------------------[Define] ---------------------------------------*/
-
-bool halbb_set_pwr_ul_tb_ofst(struct bb_info *bb, s16 pw_ofst,
-			      enum phl_phy_idx phy_idx);
-void halbb_pwr_ctrl_txpwr_cfg(struct bb_info *bb, s8 pwr_lv1, s8 pwr_lv2, s8 pwr_lv3);
-void halbb_pwr_ctrl_th_cfg(struct bb_info *bb, u8 th_lv1, u8 th_lv2, u8 th_lv3);
-void halbb_tssi_ctrl_set_bandedge_cfg(struct bb_info *bb, enum phl_phy_idx phy_idx,
-						enum tssi_bandedge_cfg bandedge_cfg);
-#endif
\ No newline at end of file
diff --git a/os/board/rtl8720e/src/component/wifi/driver/src/hal/phy_g6/bb/halbb_ra.h b/os/board/rtl8720e/src/component/wifi/driver/src/hal/phy_g6/bb/halbb_ra.h
deleted file mode 100644
index d1cb186ef..000000000
--- a/os/board/rtl8720e/src/component/wifi/driver/src/hal/phy_g6/bb/halbb_ra.h
+++ /dev/null
@@ -1,282 +0,0 @@
-/******************************************************************************
- *
- * Copyright(c) 2019 Realtek Corporation.
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of version 2 of the GNU General Public License as
- * published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
- * more details.
- *
- *****************************************************************************/
-#ifndef _HALBB_RA_H_
-#define _HALBB_RA_H_
-
-/*@--------------------------[extern] ---------------------------------------*/
-extern const u16 bb_phy_rate_table[LEGACY_RATE_NUM + HE_RATE_NUM_4SS];
-/*@--------------------------[Define] ---------------------------------------*/
-#define VHT_2_HE32_RATE(X) ((((X) << 3) + (X) + 4) >> 3) /*= Round(X * 1.125)*/
-#define HE32_2_HE16_RATE(X) ((((X) << 3) + (X) + 4) >> 3) /*= Round(X * 1.125)*/
-#define HE32_2_HE08_RATE(X) ((((X) << 4) + ((X) << 1) + (X) + 8) >> 4) /*= Round(X * 1.1875)*/
-
-#define RAMASK_B	0x000000000000000f
-#define RAMASK_AG	0x0000000000000ff0
-#define RAMASK_BG	0x0000000000000ff5
-#define RAMASK_HT_2G	0x00000ffffffff015
-#define RAMASK_HT_5G	0x00000ffffffff010
-#define RAMASK_VHT_2G	0x000ffffffffff015
-#define RAMASK_VHT_5G	0x000ffffffffff010
-#define RAMASK_HE_2G	0x0ffffffffffff015
-#define RAMASK_HE_5G	0x0ffffffffffff010
-
-#define RAMASK_1SS_HT	0x00000000000fffff
-#define RAMASK_2SS_HT	0x00000000ff0fffff
-#define RAMASK_3SS_HT	0x00000ff0ff0fffff
-#define RAMASK_4SS_HT	0x00ff0ff0ff0fffff
-
-#define RAMASK_1SS_VHT	0x00000000003fffff
-#define RAMASK_2SS_VHT	0x00000003ff3fffff
-#define RAMASK_3SS_VHT	0x00003ff3ff3fffff
-#define RAMASK_4SS_VHT	0x03ff3ff3ff3fffff
-
-#define RAMASK_1SS_HE	0x0000000000ffffff
-#define RAMASK_2SS_HE	0x0000000fffffffff
-#define RAMASK_3SS_HE	0x0000ffffffffffff
-#define RAMASK_4SS_HE	0x0fffffffffffffff
-
-#define MAX_ABG_RATE_NUM 12
-#define MAX_NSS_VHT 4
-#define MAX_NSS_HT 4
-#define MAX_NSS_HE 4
-
-#define STA_NUM_RSSI_CMD PHL_MAX_STA_NUM
-
-#define MASKRATE_AX	0x01ff
-#define MASKGILTF_AX	0x0e00
-
-/* WiFi Support Mode */
-#define CCK_SUPPORT 	BIT(0)
-#define OFDM_SUPPORT	BIT(1)
-#define HT_SUPPORT		BIT(2)
-#define VHT_SUPPORT_TX	BIT(3)
-#define HE_SUPPORT		BIT(4)
-
-#define	RA_FLOOR_TABLE_SIZE	7
-#define	RA_FLOOR_UP_GAP		3
-
-#define MAX_RATE_HE 24
-#define MAX_RATE_VHT 40  // 8198F is 4SS
-#define MAX_RATE_HT 32
-
-/*@--------------------------[Enum]------------------------------------------*/
-
-/* rate_idx table used in FW*/
-enum rate_table {
-    RATE_CCK_1M        = 0x00,
-    RATE_CCK_2M        = 0x01,
-    RATE_CCK_5M        = 0x02,
-    RATE_CCK_11M       = 0x03,
-    RATE_OFDM_6M       = 0x04,
-    RATE_OFDM_9M       = 0x05,
-    RATE_OFDM_12M      = 0x06,
-    RATE_OFDM_18M      = 0x07,
-    RATE_OFDM_24M      = 0x08,
-    RATE_OFDM_36M      = 0x09,
-    RATE_OFDM_48M      = 0x0A,
-    RATE_OFDM_54M      = 0x0B,
-    RATE_HT_MCS0       = 0x0C,
-    RATE_HT_MCS1       = 0x0D,
-    RATE_HT_MCS2       = 0x0E,
-    RATE_HT_MCS3       = 0x0F,
-    RATE_HT_MCS4       = 0x10,
-    RATE_HT_MCS5       = 0x11,
-    RATE_HT_MCS6       = 0x12,
-    RATE_HT_MCS7       = 0x13,
-    RATE_HT_MCS8       = 0x14,
-    RATE_HT_MCS9       = 0x15,
-    RATE_HT_MCS10      = 0x16,
-    RATE_HT_MCS11      = 0x17,
-    RATE_HT_MCS12      = 0x18,
-    RATE_HT_MCS13      = 0x19,
-    RATE_HT_MCS14      = 0x1A,
-    RATE_HT_MCS15      = 0x1B,
-    RATE_HT_MCS16      = 0x1C,
-    RATE_HT_MCS17      = 0x1D,
-    RATE_HT_MCS18      = 0x1E,
-    RATE_HT_MCS19      = 0x1F,
-    RATE_HT_MCS20      = 0x20,
-    RATE_HT_MCS21      = 0x21,
-    RATE_HT_MCS22      = 0x22,
-    RATE_HT_MCS23      = 0x23,
-    RATE_HT_MCS24      = 0x24,
-    RATE_HT_MCS25      = 0x25,
-    RATE_HT_MCS26      = 0x26,
-    RATE_HT_MCS27      = 0x27,
-    RATE_HT_MCS28      = 0x28,
-    RATE_HT_MCS29      = 0x29,
-    RATE_HT_MCS30      = 0x2A,
-    RATE_HT_MCS31      = 0x2B,
-    RATE_VHT1SS_MCS0   = 0x2C,
-    RATE_VHT1SS_MCS1   = 0x2D,
-    RATE_VHT1SS_MCS2   = 0x2E,
-    RATE_VHT1SS_MCS3   = 0x2F,
-    RATE_VHT1SS_MCS4   = 0x30,
-    RATE_VHT1SS_MCS5   = 0x31,
-    RATE_VHT1SS_MCS6   = 0x32,
-    RATE_VHT1SS_MCS7   = 0x33,
-    RATE_VHT1SS_MCS8   = 0x34,
-    RATE_VHT1SS_MCS9   = 0x35,
-    RATE_VHT2SS_MCS0   = 0x36,
-    RATE_VHT2SS_MCS1   = 0x37,
-    RATE_VHT2SS_MCS2   = 0x38,
-    RATE_VHT2SS_MCS3   = 0x39,
-    RATE_VHT2SS_MCS4   = 0x3A,
-    RATE_VHT2SS_MCS5   = 0x3B,
-    RATE_VHT2SS_MCS6   = 0x3C,
-    RATE_VHT2SS_MCS7   = 0x3D,
-    RATE_VHT2SS_MCS8   = 0x3E,
-    RATE_VHT2SS_MCS9   = 0x3F,
-    RATE_VHT3SS_MCS0   = 0x40,
-    RATE_VHT3SS_MCS1   = 0x41,
-    RATE_VHT3SS_MCS2   = 0x42,
-    RATE_VHT3SS_MCS3   = 0x43,
-    RATE_VHT3SS_MCS4   = 0x44,
-    RATE_VHT3SS_MCS5   = 0x45,
-    RATE_VHT3SS_MCS6   = 0x46,
-    RATE_VHT3SS_MCS7   = 0x47,
-    RATE_VHT3SS_MCS8   = 0x48,
-    RATE_VHT3SS_MCS9   = 0x49,
-    RATE_VHT4SS_MCS0   = 0x4A,
-    RATE_VHT4SS_MCS1   = 0x4B,
-    RATE_VHT4SS_MCS2   = 0x4C,
-    RATE_VHT4SS_MCS3   = 0x4D,
-    RATE_VHT4SS_MCS4   = 0x4E,
-    RATE_VHT4SS_MCS5   = 0x4F,
-    RATE_VHT4SS_MCS6   = 0x50,
-    RATE_VHT4SS_MCS7   = 0x51,
-    RATE_VHT4SS_MCS8   = 0x52,
-    RATE_VHT4SS_MCS9   = 0x53,
-    // HE
-    RATE_HE1SS_MCS0    = 0x54,
-    RATE_HE1SS_MCS1    = 0x55,
-    RATE_HE1SS_MCS2    = 0x56,
-    RATE_HE1SS_MCS3    = 0x57,
-    RATE_HE1SS_MCS4    = 0x58,
-    RATE_HE1SS_MCS5    = 0x59,
-    RATE_HE1SS_MCS6    = 0x5A,
-    RATE_HE1SS_MCS7    = 0x5B,
-    RATE_HE1SS_MCS8    = 0x5C,
-    RATE_HE1SS_MCS9    = 0x5D,
-    RATE_HE1SS_MCS10   = 0x5E,
-    RATE_HE1SS_MCS11   = 0x5F,
-    RATE_HE2SS_MCS0    = 0x60,
-    RATE_HE2SS_MCS1    = 0x61,
-    RATE_HE2SS_MCS2    = 0x62,
-    RATE_HE2SS_MCS3    = 0x63,
-    RATE_HE2SS_MCS4    = 0x64,
-    RATE_HE2SS_MCS5    = 0x65,
-    RATE_HE2SS_MCS6    = 0x66,
-    RATE_HE2SS_MCS7    = 0x67,
-    RATE_HE2SS_MCS8    = 0x68,
-    RATE_HE2SS_MCS9    = 0x69,
-    RATE_HE2SS_MCS10   = 0x6A,
-    RATE_HE2SS_MCS11   = 0x6B,
-};
-
-enum spatial_stream_num {
-	RA_1SS_MODE	= 0,
-	RA_2SS_MODE	= 1,
-	RA_3SS_MODE	= 2,
-	RA_4SS_MODE	= 3
-};
-
-enum wifi_mode {
-	RA_CCK		= 0,
-	RA_non_ht	= 1,
-	RA_HT		= 2,
-	RA_VHT		= 3,
-	RA_HE		= 4
-};
-
-enum mu_cmd_type {
-	MU_ADD_ENTRY	= 0,
-	MU_DEL_ENTRY	= 1,
-	MU_DBG_CTRL	=2,
-};
-
-enum  bb_opt_gi_ltf {
-	BB_OPT_GILTF_4XHE08 = 0,
-	BB_OPT_GILTF_1XHE08 = 1
-};
-
-
-/*@--------------------------[Structure]-------------------------------------*/
-
-struct bb_rate_info {
-	u16 rate_idx_all;
-	u16 rate_idx;
-	enum rtw_gi_ltf gi_ltf;
-	enum bb_mode_type mode; /*0:legacy, 1:HT, 2*/
-	enum channel_width bw;
-	u8 ss;
-	u8 idx;
-	u8 fw_rate_idx;
-};
-
-struct bb_ra_info {
-	/* Config move to phl_sta_info*/
-	struct bb_h2c_ra_cfg_info ra_cfg;
-	u8 cal_giltf;
-	/* Ctrl */
-	u8 drv_ractrl;
-	bool fixed_rate_en;
-	u8 fixed_rate; /* 7bit rate */
-	u8 fixed_rat_md; /* 2bit rate_mode */
-	u8 fixed_giltf; /*  3bit giltf */
-	u8 fixed_bw; /* 2bit bw */
-	u8 rssi; /* should not put here */
-	u8 rainfo_cfg1; /* prepare for other control*/
-	u8 rainfo_cfg2; /* prepare for other control*/
-
-	u8 rssi_lv;
-
-	/* Report */
-	u8 rpt_rate; /* 7bit rate + 2bit rat_md + 3bit giltf + 2bit bw */
-	u8 rpt_rat_md;
-	u8 rpt_giltf;
-	u8 rpt_bw;
-	u8 rpt_ratio;
-
-	u8 tmp;
-	
-};
-
-/*@--------------------------[Prptotype]-------------------------------------*/
-
-struct bb_info;
-bool halbb_is_cck_rate(struct bb_info *bb, u16 rate);
-bool halbb_is_ofdm_rate(struct bb_info *bb, u16 rate);
-bool halbb_is_ht_rate(struct bb_info *bb, u16 rate);
-bool halbb_is_vht_rate(struct bb_info *bb, u16 rate);
-bool halbb_is_he_rate(struct bb_info *bb, u16 rate);
-u8 halbb_legacy_rate_2_spec_rate(struct bb_info *bb, u16 rate);
-u8 halbb_rate_2_rate_digit(struct bb_info *bb, u16 rate);
-u8 halbb_get_rx_stream_num(struct bb_info *bb, enum rf_type type);
-u8 halbb_rate_type_2_num_ss(struct bb_info *bb, enum halbb_rate_type type);
-u8 halbb_rate_to_num_ss(struct bb_info *bb, u16 rate);
-void halbb_print_rate_2_buff(struct bb_info *bb, u16 rate_idx, enum rtw_gi_ltf gi_ltf, char *buf, u16 buf_size);
-enum bb_qam_type halbb_get_qam_order(struct bb_info *bb, u16 rate_idx);
-u8 halbb_rate_order_compute(struct bb_info *bb, u16 rate_idx);
-void halbb_ra_watchdog(struct bb_info *bb);
-
-void halbb_ra_init(struct bb_info *bb);
-void halbb_ra_dbg(struct bb_info *bb, char input[][16], u32 *_used,
-			 char *output, u32 *_out_len);
-void halbb_rate_idx_parsor(struct bb_info *bb, u16 rate_idx, enum rtw_gi_ltf gi_ltf, struct bb_rate_info *ra_i);
-u32 halbb_get_fw_ra_rpt(struct bb_info *bb, u16 len, u8 *c2h);
-u32 halbb_get_txsts_rpt(struct bb_info *bb, u16 len, u8 *c2h);
-
-#endif
diff --git a/os/board/rtl8720e/src/component/wifi/driver/src/hal/phy_g6/bb/halbb_ra_b_endian.h b/os/board/rtl8720e/src/component/wifi/driver/src/hal/phy_g6/bb/halbb_ra_b_endian.h
deleted file mode 100644
index 4bba0c1f5..000000000
--- a/os/board/rtl8720e/src/component/wifi/driver/src/hal/phy_g6/bb/halbb_ra_b_endian.h
+++ /dev/null
@@ -1,340 +0,0 @@
-/******************************************************************************
- *
- * Copyright(c) 2019 Realtek Corporation.
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of version 2 of the GNU General Public License as
- * published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
- * more details.
- *
- *****************************************************************************/
-#ifndef _HALBB_RA_B_ENDIAN_H_
-#define _HALBB_RA_B_ENDIAN_H_
-/*@--------------------------[Define] ---------------------------------------*/
-
-
-/*@--------------------------[Enum]------------------------------------------*/
-
-
-/*@--------------------------[Structure]-------------------------------------*/
-
-struct bb_fw_cmac_rpt_info { /*need to translate to big endian*/
-	/* dword 0 */
-	u32 rpt_sel: 5;
-	u32 polluted: 1;
-	u32 tx_state: 2;
-	u32 sw_define: 4;
-	u32 rsvd0: 2;
-	u32 try_rate: 1;
-	u32 fix_rate: 1;
-	u32 macid: 7;
-	u32 rsvd1: 1;
-	u32 qsel: 6;
-	u32 rsvd2: 1;
-	u32 txop_start: 1;
-	/* dword 1 */
-	u32 queue_time: 16;
-	u32 acc_tx_time: 8;
-	u32 rsvd3: 5;
-	u32 bmc: 1;
-	u32 bitmap_short: 2;
-	/* dword 2 */
-	u32 final_rate: 9;
-	u32 final_gi_ltf: 3;
-	u32 data_bw: 2;
-	u32 mu2su: 1;
-	u32 mu_lmt: 1;
-	u32 final_rts_rate: 9;
-	u32 final_rts_gi_ltf: 3;
-	u32 rts_tx_state: 2;
-	u32 collision_head: 1;
-	u32 collision_tail: 1;
-	/* dword 3 */
-	u32 total_pkt_num: 8;
-	u32 data_tx_cnt: 6;
-	u32 bpri: 1;
-	u32 bbar: 1;
-	u32 pkt_ok_num: 8;
-	u32 rts_tx_count: 6;
-	u32 rsvd4: 2;
-	/* dword 4 */
-	u32 init_rate: 9;
-	u32 init_gi_ltf: 3;
-	u32 ppdu_type: 2;
-	u32 he_tb_ppdu_flag: 1;
-	u32 ppdu_fst_rpt: 1;
-	u32 su_txpwr: 6;
-	u32 rsvd5: 2;
-	u32 diff_pkt_num: 4;
-	u32 user_define_ext_l: 4;
-	/* dword 5 */
-	u32 user_define: 8;
-	u32 fw_define: 8;
-	u32 txpwr_pd: 5;
-	u32 bsr: 1;
-	u32 rsvd6: 2;
-	u32 sr_rx_count: 4;
-	u32 user_define_ext_h: 4;
-};
-
-struct bb_h2c_ra_cfg_info {
-	
-	u8 bw_cap:2;
-	u8 mode_ctrl:5;
-	/*
-	@ Bit0 : CCK
-	@ Bit1 : OFDM
-	@ Bit2 : HT 
-	@ Bit3 : VHT
-	@ Bit4 : HE
-	*/
-	u8 is_dis_ra:1;
-	
-	u8 macid;
-	
-	u8 stbc_cap:1;
-	u8 ldpc_cap:1;
-	u8 en_sgi:1;
-	u8 upd_all:1;
-	u8 init_rate_lv:2;
-	u8 er_cap:1;
-	u8 dcm_cap:1;
-
-	u8 upd_mask:1;	
-	u8 upd_bw_nss_mask:1;
-	u8 giltf_cap:3;
-	u8 ss_num:3;
-	
-
-	u8 ramask[8]; /* ramask[7] bit 7 is for indicate bfee csi rate ctrl */
-
-	/* BFee CSI rate ctrl */
-	u8 band_num;
-
-	u8 partial_bw_su_er:1;
-	u8 fix_giltf:3;
-	u8 fix_giltf_en:1;
-	u8 cr_tbl_sel:1;
-	u8 fixed_csi_rate_en:1;
-	u8 ra_csi_rate_en:1;
-
-	u8 fixed_csi_rate_l;
-
-	u8 is_6g:1;
-#if (defined(BB_8720E_SUPPORT) || defined(BB_8730E_SUPPORT))
-	u8 csi_rate_control:1;
-	u8 rsvd0:6;
-#else	
-	u8 rsvd0:7;
-#endif
-};
-
-#if (defined(BB_8720E_SUPPORT) || defined(BB_8730E_SUPPORT))
-struct fw_h2c_ra_cfg_info_1{
-	/* data0 */
-	u8 bw_cap:2;
-	u8 upd_mask:1;
-	u8 upd_bw_nss_mask:1;
-	u8 giltf_cap:3;
-	u8 is_dis_ra:1;
-
-	/* data1 */
-	u8 macid;
-	
-	/* data2 */
-	u8 stbc_cap:1;
-	u8 ldpc_cap:1;
-	u8 en_sgi:1;
-	u8 upd_all:1;
-	u8 init_rate_lv:2;
-	u8 er_cap:1;
-	u8 dcm_cap:1;
-
-	/* data3 */
-	u8 fixed_csi_rate_l;
-	
-	/* data4 */
-	u8 is_6g:1;
-	u8 csi_rate_control:1;	
-	u8 rsvd0:6;
-	
-	/* data5 */
-	u8 partial_bw_su_er:1;
-	u8 fix_giltf:3;
-	u8 fix_giltf_en:1;
-	u8 cr_tbl_sel:1;
-	u8 fixed_csi_rate_en:1;	
-	u8 ra_csi_rate_en:1;
-	
-	/* data6 */		
-	u8 band_num;
-};
-
-struct fw_h2c_ra_cfg_info_2{
-	/* data0 */
-	u8 upd_all:1;
-	u8 upd_mask:1;
-	u8 upd_bw_nss_mask:1;
-	u8 mode_ctrl:5;
-	/*
-	@ Bit0 : CCK
-	@ Bit1 : OFDM
-	@ Bit2 : HT 
-	@ Bit3 : VHT
-	@ Bit4 : HE
-	*/
-
-	/* data1 */	
-	u8 macid;
-	
-	/* data2~5 */		
-	u8 ramask[4]; 
-};
-#endif
-
-struct bb_h2c_rssi_setting {
-	u8 macid;
-	u8 rssi_a; /* BIT(7) : parse rssi_b*/
-	u8 bcn_rssi_a; /* BIT(7) : parse bcn_rssi*/
-	u8 bcn_rssi_b;
-
-	u8 drv_ractrl;
-	/* RSVD */
-
-	u8 fixed_rate:7;
-	u8 is_fixed_rate:1;
-	
-	u8 rsvd2_M:1;
-	u8 fixed_bw:2;
-	u8 fixed_giltf:3;
-	u8 fixed_rate_md:2;
-	
-	u8 endcmd:1;
-	u8 rssi_b:7;
-};
-
-#if (defined(BB_8720E_SUPPORT) || defined(BB_8730E_SUPPORT))
-struct fw_h2c_rssi_setting{
-	u8 macid;
-	u8 rssi_a; /* BIT(7) : parse rssi_b*/
-	u8 bcn_rssi_a; /* BIT(7) : parse bcn_rssi*/
-
-	u8 fixed_rate:7;
-	u8 is_fixed_rate:1;
-
-	u8 rsvd2_M:1;
-	u8 fixed_bw:2;
-	u8 fixed_giltf:3;	
-	u8 fixed_rate_md:2;
-};
-#endif
-
-struct bb_h2c_ra_mask {
-	u8 macid;
-
-	u8 mask_rate:7;
-	u8 mask_or_reveal:1;
-
-	u8 rsvd1:5;
-	u8 is_manual_adjust_ra_mask:1;
-	u8 mask_rate_md:2;
-
-	u8 rsvd2;
-};
-
-struct bb_h2c_ra_adjust {
-	u8 macid;
-	
-	u8 drv_shift_en:1;
-	u8 drv_shift_value:7;
-};
-
-struct bb_h2c_ra_d_o_timer {
-	u8 macid;
-	
-	u8 d_o_timer_en:1;
-	u8 d_o_timer_value:7;
-};
-
-struct bb_h2c_mu_cfg {
-	u8 cmd_type;
-	u8 entry;
-	u8 macid;
-	
-	u8 rsvd3:6;
-	u8 en_1024q:1;
-	u8 en_256q:1;
-};
-
-struct halbb_ra_rpt_info {
-	u8 rpt_macid_l;
-	u8 rpt_macid_m;
-
-	u8 retry_ratio;
-
-	u8 rsvd0: 2;
-	u8 u1_muidx: 3;
-	u8 u0_muidx: 3;
-
-	u8 is_mu: 1;
-	u8 rpt_mcs_nss: 7;
-
-	u8 rsvd2: 1;
-	u8 rpt_bw: 2;
-	u8 rpt_gi_ltf: 3;
-	u8 rpt_md_sel: 2;
-
-	u8 rsvd3;
-	u8 rsvd4;
-};
-
-struct halbb_txsts_info {
-	u8 rpt_macid_l;
-	u8 rpt_macid_m;
-
-	u8 avg_agg;
-	u8 rsvd0;
-
-	u8 tx_ok_be_l;
-	u8 tx_ok_be_m;
-	u8 tx_ok_bk_l;
-	u8 tx_ok_bk_m;
-	u8 tx_ok_vi_l;
-	u8 tx_ok_vi_m;
-	u8 tx_ok_vo_l;
-	u8 tx_ok_vo_m;
-
-	u8 tx_retry_be_l;
-	u8 tx_retry_be_m;
-	u8 tx_retry_bk_l;
-	u8 tx_retry_bk_m;
-	u8 tx_retry_vi_l;
-	u8 tx_retry_vi_m;
-	u8 tx_retry_vo_l;
-	u8 tx_retry_vo_m;
-	
-
-	u8 tx_rate_l;
-	u8 tx_rate_m;
-	u8 retry_ratio;
-	u8 rsvd1;
-	
-	u8 tx_total_l;
-	u8 tx_total_m;
-	u8 rsvd2;
-	u8 rsvd3;
-	
-	u8 rsvd4;
-	u8 rsvd5;
-	u8 rsvd6;
-	u8 rsvd7;
-};
-
-/*@--------------------------[Prptotype]-------------------------------------*/
-
-
-#endif
diff --git a/os/board/rtl8720e/src/component/wifi/driver/src/hal/phy_g6/bb/halbb_ra_ex.h b/os/board/rtl8720e/src/component/wifi/driver/src/hal/phy_g6/bb/halbb_ra_ex.h
deleted file mode 100644
index b54705ec4..000000000
--- a/os/board/rtl8720e/src/component/wifi/driver/src/hal/phy_g6/bb/halbb_ra_ex.h
+++ /dev/null
@@ -1,38 +0,0 @@
-/******************************************************************************
- *
- * Copyright(c) 2019 Realtek Corporation.
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of version 2 of the GNU General Public License as
- * published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
- * more details.
- *
- *****************************************************************************/
-#ifndef _HALBB_RA_EX_H_
-#define _HALBB_RA_EX_H_
-/*@--------------------------[Define] ---------------------------------------*/
-
-
-
-/*@--------------------------[Enum]------------------------------------------*/
-
-
-
-/*@--------------------------[Structure]-------------------------------------*/
-
-
-/*@--------------------------[Prptotype]-------------------------------------*/
-
-
-extern bool rtw_halbb_raregistered(struct bb_info *bb, struct rtw_phl_stainfo_t *phl_sta_i);
-extern bool rtw_halbb_raupdate(struct bb_info *bb, struct rtw_phl_stainfo_t *phl_sta_i);
-extern bool rtw_halbb_dft_mask(struct bb_info *bb, struct rtw_phl_stainfo_t *phl_sta_i);
-extern bool rtw_halbb_ra_deregistered(struct bb_info *bb, struct rtw_phl_stainfo_t *phl_sta_i);
-extern bool rtw_halbb_query_txsts(struct bb_info *bb, u16 macid0, u16 macid1);
-void halbb_drv_cmac_rpt_parsing(struct bb_info *bb, u8 *rpt);
-bool halbb_ra_rssi_update_trigger(struct bb_info *bb, struct rtw_phl_stainfo_t *phl_sta_i);
-#endif
diff --git a/os/board/rtl8720e/src/component/wifi/driver/src/hal/phy_g6/bb/halbb_ra_l_endian.h b/os/board/rtl8720e/src/component/wifi/driver/src/hal/phy_g6/bb/halbb_ra_l_endian.h
deleted file mode 100644
index 8991397e5..000000000
--- a/os/board/rtl8720e/src/component/wifi/driver/src/hal/phy_g6/bb/halbb_ra_l_endian.h
+++ /dev/null
@@ -1,337 +0,0 @@
-/******************************************************************************
- *
- * Copyright(c) 2019 Realtek Corporation.
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of version 2 of the GNU General Public License as
- * published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
- * more details.
- *
- *****************************************************************************/
-#ifndef _HALBB_RA_L_ENDIAN_H_
-#define _HALBB_RA_L_ENDIAN_H_
-/*@--------------------------[Define] ---------------------------------------*/
-
-
-
-/*@--------------------------[Enum]------------------------------------------*/
-
-
-
-/*@--------------------------[Structure]-------------------------------------*/
-
-struct bb_fw_cmac_rpt_info {
-	/* dword 0 */
-	u32 rpt_sel: 5;
-	u32 polluted: 1;
-	u32 tx_state: 2;
-	u32 sw_define: 4;
-	u32 rsvd0: 2;
-	u32 try_rate: 1;
-	u32 fix_rate: 1;
-	u32 macid: 7;
-	u32 rsvd1: 1;
-	u32 qsel: 6;
-	u32 rsvd2: 1;
-	u32 txop_start: 1;
-	/* dword 1 */
-	u32 queue_time: 16;
-	u32 acc_tx_time: 8;
-	u32 rsvd3: 5;
-	u32 bmc: 1;
-	u32 bitmap_short: 2;
-	/* dword 2 */
-	u32 final_rate: 9;
-	u32 final_gi_ltf: 3;
-	u32 data_bw: 2;
-	u32 mu2su: 1;
-	u32 mu_lmt: 1;
-	u32 final_rts_rate: 9;
-	u32 final_rts_gi_ltf: 3;
-	u32 rts_tx_state: 2;
-	u32 collision_head: 1;
-	u32 collision_tail: 1;
-	/* dword 3 */
-	u32 total_pkt_num: 8;
-	u32 data_tx_cnt: 6;
-	u32 bpri: 1;
-	u32 bbar: 1;
-	u32 pkt_ok_num: 8;
-	u32 rts_tx_count: 6;
-	u32 rsvd4: 2;
-	/* dword 4 */
-	u32 init_rate: 9;
-	u32 init_gi_ltf: 3;
-	u32 ppdu_type: 2;
-	u32 he_tb_ppdu_flag: 1;
-	u32 ppdu_fst_rpt: 1;
-	u32 su_txpwr: 6;
-	u32 rsvd5: 2;
-	u32 diff_pkt_num: 4;
-	u32 user_define_ext_l: 4;
-	/* dword 5 */
-	u32 user_define: 8;
-	u32 fw_define: 8;
-	u32 txpwr_pd: 5;
-	u32 bsr: 1;
-	u32 rsvd6: 2;
-	u32 sr_rx_count: 4;
-	u32 user_define_ext_h: 4;
-};
-
-struct bb_h2c_ra_cfg_info {
-	u8 is_dis_ra:1;
-	u8 mode_ctrl:5;
-	/*
-	@ Bit0 : CCK
-	@ Bit1 : OFDM
-	@ Bit2 : HT 
-	@ Bit3 : VHT
-	@ Bit4 : HE
-	*/
-	u8 bw_cap:2;
-	
-	u8 macid;
-	
-	u8 dcm_cap:1;
-	u8 er_cap:1;
-	u8 init_rate_lv:2;
-	u8 upd_all:1;
-	u8 en_sgi:1;
-	u8 ldpc_cap:1;
-	u8 stbc_cap:1;
-	
-	u8 ss_num:3;
-	u8 giltf_cap:3;
-	u8 upd_bw_nss_mask:1;
-	u8 upd_mask:1;
-
-	u8 ramask[8]; /* ramask[7] bit 7 is for indicate bfee csi rate ctrl */
-
-	/* BFee CSI rate ctrl */
-	u8 band_num;
-
-	u8 ra_csi_rate_en:1;
-	u8 fixed_csi_rate_en:1;
-	u8 cr_tbl_sel:1;
-	u8 fix_giltf_en:1;
-	u8 fix_giltf:3;
-	u8 partial_bw_su_er:1;
-
-	u8 fixed_csi_rate_l;
-#if (defined(BB_8720E_SUPPORT) || defined(BB_8730E_SUPPORT))
-	u8 rsvd0:6;
-	u8 csi_rate_control:1;
-#else
-	u8 rsvd0:7;
-#endif
-	u8 is_6g:1;
-};
-
-#if (defined(BB_8720E_SUPPORT) || defined(BB_8730E_SUPPORT))
-struct fw_h2c_ra_cfg_info_1{
-	/* data0 */
-	u8 is_dis_ra:1;
-	u8 giltf_cap:3;
-	u8 upd_bw_nss_mask:1;
-	u8 upd_mask:1;
-	u8 bw_cap:2;
-	
-	/* data1 */
-	u8 macid;
-	
-	/* data2 */
-	u8 dcm_cap:1;
-	u8 er_cap:1;
-	u8 init_rate_lv:2;
-	u8 upd_all:1;
-	u8 en_sgi:1;
-	u8 ldpc_cap:1;
-	u8 stbc_cap:1;
-	
-	/* data3 */
-	u8 fixed_csi_rate_l;
-	
-	/* data4 */	
-	u8 rsvd0:6;
-	u8 csi_rate_control:1;
-	u8 is_6g:1;
-	
-	/* data5 */	
-	u8 ra_csi_rate_en:1;
-	u8 fixed_csi_rate_en:1;
-	u8 cr_tbl_sel:1;
-	u8 fix_giltf_en:1;
-	u8 fix_giltf:3;
-	u8 partial_bw_su_er:1;
-	
-	/* data6 */		
-	u8 band_num;
-};
-
-struct fw_h2c_ra_cfg_info_2{
-	/* data0 */
-	u8 mode_ctrl:5;
-	/*
-	@ Bit0 : CCK
-	@ Bit1 : OFDM
-	@ Bit2 : HT 
-	@ Bit3 : VHT
-	@ Bit4 : HE
-	*/
-	u8 upd_bw_nss_mask:1;
-	u8 upd_mask:1;
-	u8 upd_all:1;
-
-	/* data1 */	
-	u8 macid;
-	
-	/* data2~5 */		
-	u8 ramask[4]; 
-};
-#endif
-
-struct bb_h2c_rssi_setting {
-	u8 macid;
-	u8 rssi_a; /* BIT(7) : parse rssi_b*/
-	u8 bcn_rssi_a; /* BIT(7) : parse bcn_rssi*/
-	u8 bcn_rssi_b;
-
-	u8 drv_ractrl;
-	/* RSVD */
-
-	u8 is_fixed_rate:1;
-	u8 fixed_rate:7;
-
-	u8 fixed_rate_md:2;
-	u8 fixed_giltf:3;
-	u8 fixed_bw:2;
-	u8 rsvd2_M:1;
-	
-	u8 rssi_b:7;
-	u8 endcmd:1;
-};
-
-#if (defined(BB_8720E_SUPPORT) || defined(BB_8730E_SUPPORT))
-struct fw_h2c_rssi_setting {
-	u8 macid;
-	u8 rssi_a; /* BIT(7) : parse rssi_b*/
-	u8 bcn_rssi_a; /* BIT(7) : parse bcn_rssi*/
-
-	u8 is_fixed_rate:1;
-	u8 fixed_rate:7;
-
-	u8 fixed_rate_md:2;
-	u8 fixed_giltf:3;
-	u8 fixed_bw:2;
-	u8 rsvd2_M:1;
-};
-#endif
-
-struct bb_h2c_ra_mask {
-	u8 macid;
-	
-	u8 mask_or_reveal:1;
-	u8 mask_rate:7;
-
-	u8 mask_rate_md:2;
-	u8 is_manual_adjust_ra_mask:1;
-	u8 rsvd1:5;
-
-	u8 rsvd2;
-};
-
-struct bb_h2c_ra_adjust {
-	u8 macid;
-	
-	u8 drv_shift_value:7;
-	u8 drv_shift_en:1;
-};
-
-struct bb_h2c_ra_d_o_timer {
-	u8 macid;
-	
-	u8 d_o_timer_value:7;
-	u8 d_o_timer_en:1;
-};
-
-struct bb_h2c_mu_cfg {
-	u8 cmd_type;
-	u8 entry;
-	u8 macid;
-	u8 en_256q:1;
-	u8 en_1024q:1;
-	u8 rsvd3:6;
-};
-
-struct halbb_ra_rpt_info {
-	u8 rpt_macid_l;
-	u8 rpt_macid_m;
-
-	u8 retry_ratio;
-
-	u8 u0_muidx: 3;
-	u8 u1_muidx: 3;
-	u8 rsvd0: 2;
-
-	u8 rpt_mcs_nss: 7;
-	u8 is_mu: 1;
-
-	u8 rpt_md_sel: 2;
-	u8 rpt_gi_ltf: 3;
-	u8 rpt_bw: 2;
-	u8 rsvd2: 1;
-
-	u8 rsvd3;
-	u8 rsvd4;
-};
-
-struct halbb_txsts_info {
-	u8 rpt_macid_l;
-	u8 rpt_macid_m;
-
-	u8 avg_agg;
-	u8 rsvd0;
-
-	u8 tx_ok_be_l;
-	u8 tx_ok_be_m;
-	u8 tx_ok_bk_l;
-	u8 tx_ok_bk_m;
-	u8 tx_ok_vi_l;
-	u8 tx_ok_vi_m;
-	u8 tx_ok_vo_l;
-	u8 tx_ok_vo_m;
-
-	u8 tx_retry_be_l;
-	u8 tx_retry_be_m;
-	u8 tx_retry_bk_l;
-	u8 tx_retry_bk_m;
-	u8 tx_retry_vi_l;
-	u8 tx_retry_vi_m;
-	u8 tx_retry_vo_l;
-	u8 tx_retry_vo_m;
-	
-
-	u8 tx_rate_l;
-	u8 tx_rate_m;
-	u8 retry_ratio;
-	u8 rsvd1;
-	
-	u8 tx_total_l;
-	u8 tx_total_m;
-	u8 rsvd2;
-	u8 rsvd3;
-	
-	u8 rsvd4;
-	u8 rsvd5;
-	u8 rsvd6;
-	u8 rsvd7;
-};
-
-/*@--------------------------[Prptotype]-------------------------------------*/
-
-#endif
diff --git a/os/board/rtl8720e/src/component/wifi/driver/src/hal/phy_g6/bb/halbb_rua_tbl.h b/os/board/rtl8720e/src/component/wifi/driver/src/hal/phy_g6/bb/halbb_rua_tbl.h
deleted file mode 100644
index 63f45d3e8..000000000
--- a/os/board/rtl8720e/src/component/wifi/driver/src/hal/phy_g6/bb/halbb_rua_tbl.h
+++ /dev/null
@@ -1,64 +0,0 @@
-/******************************************************************************
- *
- * Copyright(c) 2007 - 2020  Realtek Corporation.
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of version 2 of the GNU General Public License as
- * published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
- * more details.
- *
- * The full GNU General Public License is included in this distribution in the
- * file called LICENSE.
- *
- * Contact Information:
- * wlanfae <wlanfae@realtek.com>
- * Realtek Corporation, No. 2, Innovation Road II, Hsinchu Science Park,
- * Hsinchu 300, Taiwan.
- *
- * Larry Finger <Larry.Finger@lwfinger.net>
- *
- *****************************************************************************/
-#ifndef __HALBB_RUA_TBL_H__
-#define __HALBB_RUA_TBL_H__
-
-#ifdef HALBB_RUA_SUPPORT
-/*@--------------------------[Define] ---------------------------------------*/
-/*[IO Reg]*/
-
-
-/*@--------------------------[Enum]------------------------------------------*/
-
-enum rua_tbl_sel {
-	DL_RU_GP_TBL		= 0x0,
-	UL_RU_GP_TBL		= 0x1,
-	RU_STA_INFO			= 0x2,
-	DL_RU_FIX_TBL	= 0x3,
-	UL_RU_FIX_TBL	= 0x4,
-	BA_INFO_TBL			= 0x5
-};
-
-enum rua_cfg_sel {
-	SW_GRP_HDL		= 0x0,
-	DL_MACID_CFG		= 0x1,
-	UL_MACID_CFG			= 0x2,
-	CSI_INFO_CFG	= 0x3,
-	CQI_CFG	= 0x4,
-	BB_INFO_CFG			= 0x5,
-	PWR_TBL_init			= 0x6
-};
-
-
-/*@--------------------------[Structure]-------------------------------------*/
- 
-/*@--------------------------[Prptotype]-------------------------------------*/
-struct bb_info;
-void halbb_rua_tbl_init(struct bb_info *bb);
-void halbb_rua_tbl_dbg(struct bb_info *bb, char input[][16], u32 *_used,
-			 char *output, u32 *_out_len);
-#endif /* HALBB_RUA_SUPPORT */
-
-#endif
diff --git a/os/board/rtl8720e/src/component/wifi/driver/src/hal/phy_g6/bb/halbb_rua_tbl_b_endian.h b/os/board/rtl8720e/src/component/wifi/driver/src/hal/phy_g6/bb/halbb_rua_tbl_b_endian.h
deleted file mode 100644
index 6b5849c0f..000000000
--- a/os/board/rtl8720e/src/component/wifi/driver/src/hal/phy_g6/bb/halbb_rua_tbl_b_endian.h
+++ /dev/null
@@ -1,489 +0,0 @@
-/******************************************************************************
- *
- * Copyright(c) 2007 - 2020  Realtek Corporation.
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of version 2 of the GNU General Public License as
- * published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
- * more details.
- *
- * The full GNU General Public License is included in this distribution in the
- * file called LICENSE.
- *
- * Contact Information:
- * wlanfae <wlanfae@realtek.com>
- * Realtek Corporation, No. 2, Innovation Road II, Hsinchu Science Park,
- * Hsinchu 300, Taiwan.
- *
- * Larry Finger <Larry.Finger@lwfinger.net>
- *
- *****************************************************************************/
-#ifndef __HALBB_RUA_TBL_B_ENDIAN_H__
-#define __HALBB_RUA_TBL_B_ENDIAN_H__
-
-#ifdef HALBB_RUA_SUPPORT
-/*@--------------------------[Define] ---------------------------------------*/
-/*[IO Reg]*/
-
-/*@--------------------------[Enum]------------------------------------------*/
-
-
-
-/*@--------------------------[Structure]-------------------------------------*/
-
-	
-struct halbb_rua_tbl_hdr_info {
-	u8 idx:7;
-	u8 rw:1;
-
-	u8 len_l:3;
-	u8 offset:5;
-
-	u8 type:1;
-	u8 len_m:7;
-
-	u8 tbl_class;
-};
-
-struct halbb_ru_rate_info {
-	u8 mcs:4;
-	u8 ss:3;
-	u8 dcm:1;
-};
-
-
-
-struct halbb_tf_ba_tbl_info {
-	u8 ru_psd_l:7;
-	u8 fix_ba:1;
-	
-	u8 tf_rate_l:6;
-	u8 ru_psd_m:2;
-
-	u8 rf_gain_idx_l:4;
-	u8 rf_gain_fix:1;
-	u8 tf_rate_m:3;
-
-	u8 tb_ppdu_bw:2;
-	u8 rf_gain_idx_m:6;
-
-	struct halbb_ru_rate_info rate_i;
-	
-	u8 tb_t_pe_nom:2;
-	u8 sta_coding:1;
-	u8 stbc:1;
-	u8 doppler:1;
-	u8 gi_ltf:3;
-
-	u8 rsvd1: 6;
-	u8 ma_type: 1;
-	u8 pr20_bw_en:1;
-
-	u8 rsvd2;
-};
-
-struct halbb_dl_ru_gp_tbl_info {
-
-	struct halbb_rua_tbl_hdr_info tbl_hdr_i;
-	
-	u8 tx_pwr_l:6;
-	u8 ppdu_bw:2;
-	
-	u8 pwr_boost_fac:5;
-	u8 tx_pwr_m:3;
-	
-	u8 rsvd1:7;
-	u8 fix_mode_flag:1;
-
-	u8 rsvd2;
-	
-	struct halbb_tf_ba_tbl_info tf;
-};
-
-
-
-struct halbb_ul_ru_gp_tbl_info {
-	
-	struct halbb_rua_tbl_hdr_info tbl_hdr_i;
-	u8 grp_psd_max_l;
-	
-	u8 grp_psd_min_l:7;
-	u8 grp_psd_max_m:1;
-
-	u8 tf_rate_l:6;
-	u8 grp_psd_min_m:2;
-	
-	u8 rsvd2:4;
-	u8 fix_tf_rate:1;
-	u8 tf_rate_m:3;
-	
-	u8 rf_gain_idx_l:5;
-	u8 rf_gain_fix:1;
-	u8 ppdu_bw:2;
-	
-	u8 rsvd1: 2;
-	u8 fix_mode_flag: 1;
-	u8 rf_gain_idx_m:5;
-
-	u8 rsvd3;
-
-	u8 rsvd4;
-};
-
-struct halbb_ru_sta_info {
-	
-	struct halbb_rua_tbl_hdr_info tbl_hdr_i;
-/* sta capability */
-	u8 rsvd0:6;
-	u8 gi_ltf_18spt:1;
-	u8 gi_ltf_48spt:1;
-
-/* dl su */
-	u8 dlsu_doppler_ctrl:2;
-	u8 dlsu_gi_ltf:3;
-	u8 dlsu_bw:2;
-	u8 dlsu_info_en:1;
-	
-	u8 dlru_ratetbl_ridx:4;
-	u8 dl_fwcqi_flag:1;
-	u8 dlsu_stbc:1;
-	u8 dlsu_txbf:1;
-	u8 dlsu_coding:1;
-
-	u8 csi_info_bitmap;
-
-	u8 dl_swgrp_bitmap[4];
-	
-	u8 dlsu_rate_l:1;
-	u8 rsvd1:6;
-	u8 dlsu_dcm:1;
-
-	u8 dlsu_rate_m;
-
-	u8 rsvd2:2;
-	u8 dlsu_pwr:6;
-
-	u8 rsvd4;
-/* ul su */
-	u8 ulsu_doppler_ctrl:2;
-	u8 ulsu_gi_ltf:3;
-	u8 ulsu_bw:2;
-	u8 ulsu_info_en:1;
-
-	u8 ulsu_mcs:4;
-	u8 ulsu_ss:3;
-	u8 ulsu_dcm:1;
-
-	u8 ulsu_rssi_m_l:1;
-	u8 ulsu_coding:1;
-	u8 ulsu_stbc:1;
-	u8 ulru_ratetbl_ridx:4;
-	u8 ul_fwcqi_flag:1;
-	
-	u8 ulsu_rssi_m_m;
-	
-	u8 ul_swgrp_bitmap[4];
-/* tb info */
-};
-	
-struct halbb_dl_fix_sta_info {
-	u8 mac_id;
-	u8 ru_pos[3];
-	
-	u8 rsvd0: 4;
-	u8 fix_pwr_fac:1;
-	u8 fix_txbf:1;
-	u8 fix_coding:1;
-	u8 fix_rate:1;
-	
-	struct halbb_ru_rate_info rate_i;
-	
-	u8 rsvd1: 1;
-	u8 pwr_boost_fac:5;
-	u8 coding:1;
-	u8 txbf:1;
-	u8 rsvd2;
-};
-
-struct halbb_dl_fix_sta_info_8ru {
-	u8 mac_id;
-	u8 ru_position[7];
-	
-	u8 rsvd0: 4;
-	u8 fix_pwr_boost_factor_flag:1;
-	u8 fix_txbf_flag:1;
-	u8 fix_coding_flag:1;
-	u8 fix_rate_flag:1;
-	
-	struct halbb_ru_rate_info rate_i;
-	
-	u8 rsvd1: 1;
-	u8 pwr_boost_factor:5;
-	u8 coding:1;
-	u8 txbf:1;
-	u8 rsvd2;
-};
-
-struct halbb_dl_ru_fix_tbl_info {
-	
-	struct halbb_rua_tbl_hdr_info tbl_hdr_i;
-	u8 rsvd0:1;
-	u8 ru_swp_flg:1;
-	u8 min_sta_num:3;
-	u8 max_sta_num:3;
-
-	u8 rupos_csht_flag:1;
-	u8 fixru_flag:1;
-	u8 ma_type:1;
-	u8 gi_ltf:3;
-	u8 stbc:1;
-	u8 doppler:1;
-
-	u8 rsvd2;
-	u8 rsvd3;
-	struct halbb_dl_fix_sta_info sta_i[HALBB_AX4RU_STA_NUM];
-
-};
-
-struct halbb_dl_ru_fix_tbl_info_8ru {
-	
-	struct halbb_rua_tbl_hdr_info tbl_hdr_i;
-	u8 min_sta_num:4;
-	u8 max_sta_num:4;
-	
-	u8 rupos_csht_flg:1;
-	u8 fix_ru_flag:1;
-	u8 ma_type:1;
-	u8 gi_ltf:3;
-	u8 stbc:1;
-	u8 doppler:1;
-	
-	u8 rsvd0:7;
-	u8 ru_swp_flg:1;
-	
-	u8 rsvd1;
-
-	struct halbb_dl_fix_sta_info_8ru sta_i[HALBB_AX8RU_STA_NUM];
-};
-
-struct halbb_ul_fix_sta_info {
-	u8 mac_id;
-	u8 ru_pos[3];
-	u8 tgt_rssi[3];
-	u8 rsvd1: 4;
-	u8 coding: 1;
-	u8 fix_coding: 1;
-	u8 fix_rate: 1;
-	u8 fix_tgt_rssi: 1;
-	struct halbb_ru_rate_info rate_i;
-};
-
-struct halbb_ul_fix_sta_info_8ru {
-	u8 mac_id;
-	u8 ru_position[7];
-	u8 rsvd1;
-	u8 target_rssi[7];
-	u8 rsvd2: 4;
-	u8 coding: 1;
-	u8 fix_coding_flag: 1;
-	u8 fix_rate_flag: 1;
-	u8 fix_target_rssi_flag: 1;
-	struct halbb_ru_rate_info rate_i;
-	u8 rsvd3;
-	u8 rsvd4;
-};
-	
-struct halbb_ul_ru_fix_tbl_info {
-
-	struct halbb_rua_tbl_hdr_info tbl_hdr_i;
-	u8 ma_type:1;
-	u8 doppler:1;
-	u8 min_sta_num:3;
-	u8 max_sta_num:3;
-	u8 fixru_flag: 1;
-	u8 tb_t_pe_nom: 2;
-	u8 fix_tb_t_pe_nom: 1;
-	u8 stbc:1;
-	u8 gi_ltf:3;
-
-	struct halbb_ul_fix_sta_info sta_i[HALBB_AX4RU_STA_NUM];
-
-};
-
-
-struct halbb_ul_ru_fix_tbl_info_8ru {
-
-	struct halbb_rua_tbl_hdr_info tbl_hdr_i;
-	u8 min_sta_num:4;
-	u8 max_sta_num:4;
-
-	u8 fix_ru_flag: 1;
-	u8 tb_t_pe_nominal:2;
-	u8 fix_tb_t_pe_nominal_flag:1;
-	u8 stbc:1;
-	u8 gi_ltf:3;
-
-	u8 rsvd1:6;
-	u8 ma_type:1;
-	u8 doppler:1;
-
-	u8 rsvd2;
-
-	struct halbb_ul_fix_sta_info_8ru sta_i[HALBB_AX8RU_STA_NUM];
-
-};
-
-struct halbb_rua_tbl {
-	struct halbb_dl_ru_gp_tbl_info dl_ru_gp_tbl_i;
-	struct halbb_ul_ru_gp_tbl_info ul_ru_gp_tbl_i;
-	struct halbb_ru_sta_info ru_sta_i;
-	struct halbb_dl_ru_fix_tbl_info dl_ru_fix_tbl_i;
-	struct halbb_ul_ru_fix_tbl_info ul_ru_fix_tbl_i;
-	struct halbb_tf_ba_tbl_info tf_ba_tbl_i;
-};
-
-struct halbb_sw_grp_bitmap {
-	u8 macid;
-
-	u8 rsvd1:5;
-	u8 cmdend:1; // add for determine whether last user or not
-	u8 en_upd_ul_swgrp:1;
-	u8 en_upd_dl_swgrp:1;
-
-	u8 rsvd2;
-	u8 rsvd3;
-	
-	u8 dl_sw_grp_bitmap[4];
-	u8 ul_sw_grp_bitmap[4];
-};
-
-struct halbb_sw_grp_set {
-	
-	struct halbb_sw_grp_bitmap swgrp_bitmap[8];
-	
-};
-
-struct dl_macid_cfg {
-	u8 macid;
-	
-	u8 dl_su_rate_l:7;
-	u8 dl_su_rate_cfg:1;
-	
-	u8 dl_su_pwr_l:3;
-	u8 dl_su_pwr_cfg:1;
-	u8 dl_su_bw:2;
-	u8 dl_su_rate_m:2;
-	
-	u8 rsvd0:5;
-	u8 dl_su_pwr_m:3;
-	
-	u8 rsvd1:6;
-	u8 gi_ltf_1x8_support:1;
-	u8 gi_ltf_4x8_support:1;
-	
-	u8 dl_su_doppler_ctrl:2;
-	u8 dl_su_gi_ltf:3;
-	u8 rsvd2:2;
-	u8 dl_su_info_en:1;
-	
-	u8 rsvd3:4;
-	u8 dl_su_dcm:1;
-	u8 dl_su_stbc:1;
-	u8 dl_su_txbf:1;
-	u8 dl_su_coding:1;
-
-	u8 rsvd4;
-};
-
-struct halbb_ul_macid_cfg {
-
-	u8 macid;
-	
-	u8 rsvd0: 7;
-	u8 endcmd: 1;
-
-	u8 rsvd1;
-	u8 rsvd2;
-
-	u8 ul_su_doppler_ctrl: 2;
-	u8 ul_su_gi_ltf: 3;
-	u8 ul_su_bw: 2;
-	u8 ul_su_info_en: 1;
-	
-	u8 ul_su_mcs: 4;
-	u8 ul_su_ss: 3;
-	u8 ul_su_dcm: 1;
-	
-	u8 ul_su_rssi_m_l: 1;
-	u8 ul_su_coding: 1;
-	u8 ul_su_stbc: 1;
-	u8 rsvd3: 5;
-
-	u8 ul_su_rssi_m_m;
-
-};
-
-struct halbb_ul_macid_set {
-	
-	struct halbb_ul_macid_cfg ul_macid_cfg[8];
-	
-};
-
-
-
-struct halbb_ba_tbl_info {
-	struct halbb_rua_tbl_hdr_info tbl_hdr_i;
-	
-	struct halbb_tf_ba_tbl_info tf_i;
-};
-
-struct csiinfo_cfg{
-	u8 macid;
-	u8 csi_info_bitmap;
-
-	u8 rsvd0;
-	u8 rsvd1;
-};
-
-struct halbb_cqi_info {
-	u8 macid;
-
-	u8 rsvd0: 1;
-	u8 endcmd: 1;
-	u8 ul_dl: 1; /*1'b0 means UL, 1'b1 means DL */
-	u8 ru_rate_table_row_idx: 4; /* UL or DL*/
-	u8 fw_cqi_flag: 1; /* UL or DL*/
-
-	u8 rsvd1;
-	u8 rsvd2;
-
-	s8 cqi_diff_table[19]; /* UL or DL*/
-	u8 rsvd3;
-};
-
-struct halbb_cqi_set{	
-	struct halbb_cqi_info cqi_info[8];
-};
-
-struct halbb_bb_info_cfg {
-	u8 p20_ch_bitmap;
-
-	u8 rsvd0;
-	u8 rsvd1;
-	u8 rsvd2;
-};
-
-struct halbb_pwr_by_rt_tbl{
-	u8 pwr_by_rt[64];
-};
-
-
-/*@--------------------------[Prptotype]-------------------------------------*/
-
-#endif /* HALBB_RUA_SUPPORT */
-
-#endif
diff --git a/os/board/rtl8720e/src/component/wifi/driver/src/hal/phy_g6/bb/halbb_rua_tbl_ex.h b/os/board/rtl8720e/src/component/wifi/driver/src/hal/phy_g6/bb/halbb_rua_tbl_ex.h
deleted file mode 100644
index 7e36a5f27..000000000
--- a/os/board/rtl8720e/src/component/wifi/driver/src/hal/phy_g6/bb/halbb_rua_tbl_ex.h
+++ /dev/null
@@ -1,538 +0,0 @@
-/******************************************************************************
- *
- * Copyright(c) 2007 - 2020  Realtek Corporation.
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of version 2 of the GNU General Public License as
- * published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
- * more details.
- *
- * The full GNU General Public License is included in this distribution in the
- * file called LICENSE.
- *
- * Contact Information:
- * wlanfae <wlanfae@realtek.com>
- * Realtek Corporation, No. 2, Innovation Road II, Hsinchu Science Park,
- * Hsinchu 300, Taiwan.
- *
- * Larry Finger <Larry.Finger@lwfinger.net>
- *
- *****************************************************************************/
-#ifndef __HALBB_RUA_TBL_EX_H__
-#define __HALBB_RUA_TBL_EX_H__
-#ifdef HALBB_RUA_SUPPORT
-/*@--------------------------[Define] ---------------------------------------*/
-#define HALBB_AX4RU_STA_NUM 4
-#define HALBB_AX8RU_STA_NUM 8
-/*@--------------------------[Enum]------------------------------------------*/
-enum rtw_rua_tbl_hdr_rw {
-        RUA_TBL_RW_READ = 0,
-        RUA_TBL_RW_WRITE = 1
-};
-enum rtw_rua_tbl_hdr_type {
-        RUA_TBL_TYPE_SW = 0,
-        RUA_TBL_TYPE_HW = 1
-};
-enum rtw_rua_tbl_hdr_class {
-        RUA_TBL_CL_DLRU_SW = 0x0,
-        RUA_TBL_CL_ULRU_SW  = 0x1,
-        RUA_TBL_CL_RU_STA = 0x2,
-        RUA_TBL_CL_DLRU_SW_FIX = 0x3,
-        RUA_TBL_CL_ULRU_SW_FIX = 0x4,
-        RUA_TBL_CL_BA_INFO = 0x5
-};
-/*@--------------------------[Structure]-------------------------------------*/
- struct rtw_rua_tbl_hdr {
-	u8 rw:1;
-	u8 idx:7;
-
-	u16 offset:5;
-	u16 len:10;
-	u16 type:1;
-
-	u8 tbl_class;
-};
-
-struct rtw_ru_rate_ent {
-	u8 dcm:1;
-	u8 ss:3;
-	u8 mcs:4;
-};
-
-struct rtw_tf_ba_tbl {
-	u32 fix_ba:1;
-	u32 ru_psd:9;
-	u32 tf_rate:9;
-	u32 rf_gain_fix:1;
-	u32 rf_gain_idx:10;
-	u32 tb_ppdu_bw:2;
-
-	struct rtw_ru_rate_ent rate;
-	
-	u8 gi_ltf:3;
-	u8 doppler:1;
-	u8 stbc:1;
-	u8 sta_coding:1;
-	u8 tb_t_pe_nom:2;
-
-	u8 pr20_bw_en:1;
-	u8 ma_type:1;
-	u8 rsvd1:6;
-	
-	u8 rsvd2;
-};
-
-struct rtw_dl_ru_gp_tbl {
-
-	struct rtw_rua_tbl_hdr tbl_hdr;
-	
-	u16 ppdu_bw:2;
-	u16 tx_pwr:9;
-	u16 pwr_boost_fac:5;
-
-	u8 fix_mode_flag:1;
-	u8 rsvd1:7;
-
-	u8 rsvd2;
-	
-	struct rtw_tf_ba_tbl tf;
-};
-
-struct rtw_ul_ru_gp_tbl {
-	
-	struct rtw_rua_tbl_hdr tbl_hdr;
-	u32 grp_psd_max:9;
-	u32 grp_psd_min:9;
-	u32 tf_rate:9;
-	u32 fix_tf_rate:1;
-	u32 rsvd2:4;
-	
-	u16 ppdu_bw:2;
-	u16 rf_gain_fix:1;
-	u16 rf_gain_idx:10;
-	u16 fix_mode_flag:1;
-	u16 rsvd1:2;
-};
-
-struct rtw_ru_sta_info {
-	
-	struct rtw_rua_tbl_hdr tbl_hdr;
-/* sta capability */
-	u8 gi_ltf_48spt:1;
-	u8 gi_ltf_18spt:1;
-	u8 rsvd0:6;
-/* dl su */
-	u8 dlsu_info_en:1;
-	u8 dlsu_bw:2;
-	u8 dlsu_gi_ltf:3;
-	u8 dlsu_doppler_ctrl:2;
-
-	u8 dlsu_coding:1;
-	u8 dlsu_txbf:1;
-	u8 dlsu_stbc:1;
-	u8 dl_fwcqi_flag:1;
-	u8 dlru_ratetbl_ridx:4;
-	u8 csi_info_bitmap;
-	u32 dl_swgrp_bitmap;
-	
-	u16 dlsu_dcm:1;
-	u16 rsvd1:6;
-	u16 dlsu_rate:9;
-	u8 dlsu_pwr:6;
-	u8 rsvd2:2;
-	u8 rsvd4;
-/* ul su */
-	u8 ulsu_info_en:1;
-	u8 ulsu_bw:2;
-	u8 ulsu_gi_ltf:3;
-	u8 ulsu_doppler_ctrl:2;
-	u8 ulsu_dcm:1;
-	u8 ulsu_ss:3;
-	u8 ulsu_mcs:4;
-	u16 ul_fwcqi_flag:1;
-	u16 ulru_ratetbl_ridx:4;
-	u16 ulsu_stbc:1;
-	u16 ulsu_coding:1;
-	u16 ulsu_rssi_m:9;
-	u32 ul_swgrp_bitmap;
-/* tb info */
-};
-
-/*
-struct rtw_dl_fix_sta_ent {
-	u8 mac_id;
-	u8 ru_pos[3];
-
-	u8 fix_rate:1;
-	u8 fix_coding:1;
-	u8 fix_txbf:1;
-	u8 fix_pwr_fac:1;
-	u8 rsvd0:4;
-	
-	struct rtw_ru_rate_ent rate;
-	
-	u8 txbf:1;
-	u8 coding:1;
-	u8 pwr_boost_fac:5;
-	u8 rsvd1: 1;
-	u8 rsvd2;
-
-};
-
-struct rtw_dl_ru_fix_tbl {
-	
-	struct rtw_rua_tbl_hdr tbl_hdr;
-	u8 max_sta_num:3;
-	u8 min_sta_num:3;
-	u8 ru_swp_flg:1;
-	u8 rsvd0:1;
-
-	u8 doppler:1;
-	u8 stbc:1;
-	u8 gi_ltf:3;
-	u8 ma_type:1;
-	u8 fixru_flag:1;
-	u8 rupos_csht_flag:1;
-
-	u8 rsvd2;
-
-	struct rtw_dl_fix_sta_ent sta[HALBB_AX4RU_STA_NUM];
-
-};
-*/
-
-struct rtw_dlfix_sta_i_ax4ru {
-	u8 mac_id;
-	u8 ru_pos[3];
-
-	u8 fix_rate:1;
-	u8 fix_coding:1;
-	u8 fix_txbf:1;
-	u8 fix_pwr_fac:1;
-	u8 rsvd0:4;
-	
-	struct rtw_ru_rate_ent rate;
-	
-	u8 txbf:1;
-	u8 coding:1;
-	u8 pwr_boost_fac:5;
-	u8 rsvd1: 1;
-	u8 rsvd2;
-
-};
-
-struct rtw_dlfix_sta_i_ax8ru {
-	u8 mac_id;
-	u8 ru_pos[7];
-
-	u8 fix_rate:1;
-	u8 fix_coding:1;
-	u8 fix_txbf:1;
-	u8 fix_pwr_fac:1;
-	u8 rsvd0:4;
-	
-	struct rtw_ru_rate_ent rate;
-	
-	u8 txbf:1;
-	u8 coding:1;
-	u8 pwr_boost_fac:5;
-	u8 rsvd1: 1;
-	u8 rsvd2;
-
-};
-
-struct rtw_dlru_fixtbl_ax4ru {
-	
-	struct rtw_rua_tbl_hdr tbl_hdr;
-	u8 max_sta_num:3;
-	u8 min_sta_num:3;
-	u8 ru_swp_flg:1;
-	u8 rsvd0:1;
-
-	u8 doppler:1;
-	u8 stbc:1;
-	u8 gi_ltf:3;
-	u8 ma_type:1;
-	u8 fixru_flag:1;
-	u8 rupos_csht_flag:1;
-
-	u8 rsvd2;
-
-	struct rtw_dlfix_sta_i_ax4ru sta[HALBB_AX4RU_STA_NUM];
-};
-struct rtw_dlru_fixtbl_ax8ru {
-	
-	struct rtw_rua_tbl_hdr tbl_hdr;
-	u8 max_sta_num:4;
-	u8 min_sta_num:4;
-	
-	u8 doppler:1;
-	u8 stbc:1;
-	u8 gi_ltf:3;
-	u8 ma_type:1;
-	u8 fixru_flag:1;
-	u8 rupos_csht_flag:1;
-	
-	u8 ru_swp_flg:1;
-	u8 rsvd1:7;
-
-	u8 rsvd2;
-
-	struct rtw_dlfix_sta_i_ax8ru sta[HALBB_AX8RU_STA_NUM];
-};
-
-union rtw_dlru_fixtbl{
-	struct rtw_dlru_fixtbl_ax4ru ax4ru;
-	struct rtw_dlru_fixtbl_ax8ru ax8ru;
-};
-
-/*
-struct rtw_ul_fix_sta_ent {
-	u8 mac_id;
-	u8 ru_pos[3];
-	u8 tgt_rssi[3];
-	u8 fix_tgt_rssi:1;
-	u8 fix_rate:1;
-	u8 fix_coding:1;
-	u8 coding:1;
-	u8 rsvd1:4;
-	struct rtw_ru_rate_ent rate;
-};
-
-struct rtw_ul_ru_fix_tbl {
-
-	struct rtw_rua_tbl_hdr tbl_hdr;
-	u8 max_sta_num:3;
-	u8 min_sta_num:3;
-	u8 doppler:1;
-	u8 ma_type:1;
-	u8 gi_ltf:3;
-	u8 stbc:1;
-	u8 fix_tb_t_pe_nom: 1;
-	u8 tb_t_pe_nom: 2;
-	u8 fixru_flag: 1;
-	struct rtw_ul_fix_sta_ent sta[HALBB_AX4RU_STA_NUM];
-
-};
-*/
-
-struct rtw_ulfix_sta_i_ax4ru {
-	u8 mac_id;
-	u8 ru_pos[3];
-	u8 tgt_rssi[3];
-	u8 fix_tgt_rssi:1;
-	u8 fix_rate:1;
-	u8 fix_coding:1;
-	u8 coding:1;
-	u8 rsvd1:4;
-	struct rtw_ru_rate_ent rate;
-};
-
-struct rtw_ulfix_sta_i_ax8ru {
-	u8 mac_id;
-	u8 ru_pos[7];
-	u8 rsvd1;
-	u8 tgt_rssi[7];
-
-	u8 fix_tgt_rssi:1;
-	u8 fix_rate:1;
-	u8 fix_coding:1;
-	u8 coding:1;
-	u8 rsvd2:4;
-	struct rtw_ru_rate_ent rate;
-	u8 rsvd3;
-	u8 rsvd4;
-};
-
-struct rtw_ulru_fixtbl_ax4ru {
-
-	struct rtw_rua_tbl_hdr tbl_hdr;
-	u8 max_sta_num:3;
-	u8 min_sta_num:3;
-	u8 doppler:1;
-	u8 ma_type:1;
-	u8 gi_ltf:3;
-	u8 stbc:1;
-	u8 fix_tb_t_pe_nom: 1;
-	u8 tb_t_pe_nom: 2;
-	u8 fixru_flag: 1;
-	struct rtw_ulfix_sta_i_ax4ru sta[HALBB_AX4RU_STA_NUM];
-
-};
-
-struct rtw_ulru_fixtbl_ax8ru {
-
-	struct rtw_rua_tbl_hdr tbl_hdr;
-	u8 max_sta_num:4;
-	u8 min_sta_num:4;
-	
-	u8 gi_ltf:3;
-	u8 stbc:1;
-	u8 fix_tb_t_pe_nom: 1;
-	u8 tb_t_pe_nom: 2;
-	u8 fixru_flag: 1;
-
-	u8 doppler:1;
-	u8 ma_type:1;
-	u8 rsvd1:6;
-	
-	u8 rsvd2;
-	struct rtw_ulfix_sta_i_ax8ru sta[HALBB_AX8RU_STA_NUM];
-
-};
-
-union rtw_ulru_fixtbl{
-	struct rtw_ulru_fixtbl_ax4ru ax4ru;
-	struct rtw_ulru_fixtbl_ax8ru ax8ru;
-};
-
-struct rtw_ba_tbl_info {
-	struct rtw_rua_tbl_hdr tbl_hdr;
-	
-	struct rtw_tf_ba_tbl tf_ba_t;
-};
-
-struct rtw_sw_grp_bitmap {
-	u8 macid;
-
-	u8 en_upd_dl_swgrp:1;
-	u8 en_upd_ul_swgrp:1;
-	u8 cmdend:1; // add for determine whether last user or not
-	u8 rsvd1:5;
-	
-	u32 dl_sw_grp_bitmap;
-	u32 ul_sw_grp_bitmap;
-};
-
-struct rtw_sw_grp_set {
-	
-	struct rtw_sw_grp_bitmap swgrp_bitmap[8];
-	
-};
-
-struct rtw_dl_macid_cfg {
-	
-    u32 macid: 8;
-    u32 dl_su_rate_cfg: 1;
-    u32 dl_su_rate: 9;
-    u32 dl_su_bw: 2;
-    u32 dl_su_pwr_cfg: 1;
-    u32 dl_su_pwr: 6;
-    u32 rsvd0: 5;
-
-    u32 gi_ltf_4x8_support: 1;
-    u32 gi_ltf_1x8_support: 1;
-    u32 rsvd1: 6;
-    u32 dl_su_info_en: 1;
-    u32 rsvd2: 2;
-    u32 dl_su_gi_ltf: 3;
-    u32 dl_su_doppler_ctrl: 2;
-    u32 dl_su_coding: 1;
-    u32 dl_su_txbf: 1;
-    u32 dl_su_stbc: 1;
-    u32 dl_su_dcm: 1;
-    u32 rsvd3: 12;
-
-};
-
-
-struct rtw_ul_macid_cfg {
-	
-    u32 macid: 8;
-    u32 endcmd: 1;
-    u32 rsvd0: 23;
-
-    u32 ul_su_info_en: 1;
-    u32 ul_su_bw: 2;
-    u32 ul_su_gi_ltf: 3;
-    u32 ul_su_doppler_ctrl: 2;
-    u32 ul_su_dcm: 1;
-    u32 ul_su_ss: 3;
-    u32 ul_su_mcs: 4;
-    u32 rsvd2: 5;
-    u32 ul_su_stbc: 1;
-    u32 ul_su_coding: 1;
-    u32 ul_su_rssi_m: 9;
-
-};
-
-struct rtw_ul_macid_set {
-	
-    struct rtw_ul_macid_cfg ul_macid_cfg[8];
-
-};
-
-struct rtw_csiinfo_cfg {
-    u32 macid: 8;
-    u32 csi_info_bitmap: 8;
-    u32 rsvd0: 16;
-};
-
-
-struct rtw_cqi_info {
-    u32 macid: 8;
-    u32 fw_cqi_flag: 1; /* UL or DL*/
-    u32 ru_rate_table_row_idx: 4; /* UL or DL*/
-    u32 ul_dl: 1; /*1'b0 means UL, 1'b1 means DL */
-    u32 endcmd: 1;
-    u32 rsvd0: 1;
-    u32 rsvd1: 16;
-
-    s8 cqi_diff_table[19]; /* UL or DL*/
-    u8 rsvd2;
-};
-
-struct rtw_cqi_set{	
-    struct rtw_cqi_info cqi_info[8];
-};
-
-struct rtw_bbinfo_cfg {
-    u32 p20_ch_bitmap: 8;
-    u32 rsvd0: 24;
-};
-
-struct rtw_pwr_by_rt_tbl{
-    s16 pwr_by_rt[32];
-};
-
- 
-/*@--------------------------[Prptotype]-------------------------------------*/
-struct bb_info;
-// u32 halbb_upd_dlru_fixtbl(struct bb_info *bb,
-// 			struct rtw_dl_ru_fix_tbl *info);
-u32 halbb_upd_dlru_fixtbl(struct bb_info *bb,
-			union rtw_dlru_fixtbl *union_info);
-u32 halbb_upd_dlru_grptbl(struct bb_info *bb,
-			struct rtw_dl_ru_gp_tbl *info);
-// u32 halbb_upd_ulru_fixtbl(struct bb_info *bb,
-// 			struct rtw_ul_ru_fix_tbl *info);
-u32 halbb_upd_ulru_fixtbl(struct bb_info *bb,
-			union rtw_ulru_fixtbl *union_info);			
-u32 halbb_upd_ulru_grptbl(struct bb_info *bb,
-			struct rtw_ul_ru_gp_tbl *info);
-u32 halbb_upd_rusta_info(struct bb_info *bb,
-		       struct rtw_ru_sta_info *info);
-u32 halbb_upd_ba_infotbl(struct bb_info *bb,
-		       struct rtw_ba_tbl_info *info);
-u32 halbb_swgrp_hdl(struct bb_info *bb,
-		       struct rtw_sw_grp_set *info);
-
-u32 halbb_dlmacid_cfg(struct bb_info *bb, struct rtw_dl_macid_cfg *cfg);
-
-u32 halbb_ulmacid_cfg(struct bb_info *bb, struct rtw_ul_macid_set *cfg);
-
-u32 halbb_csiinfo_cfg(struct bb_info *bb, struct rtw_csiinfo_cfg *cfg);
-
-u32 halbb_cqi_cfg(struct bb_info *bb, struct rtw_cqi_set *cfg);
-
-u32 halbb_bbinfo_cfg(struct bb_info *bb, struct rtw_bbinfo_cfg *cfg);
-
-u32 halbb_pbr_tbl_cfg(struct bb_info *bb, struct rtw_pwr_by_rt_tbl *cfg);
-
-/*u32 halbb_rua_tbl_init(struct bb_info *bb);*/
-#endif
-#endif
diff --git a/os/board/rtl8720e/src/component/wifi/driver/src/hal/phy_g6/bb/halbb_rua_tbl_l_endian.h b/os/board/rtl8720e/src/component/wifi/driver/src/hal/phy_g6/bb/halbb_rua_tbl_l_endian.h
deleted file mode 100644
index b7bb97f11..000000000
--- a/os/board/rtl8720e/src/component/wifi/driver/src/hal/phy_g6/bb/halbb_rua_tbl_l_endian.h
+++ /dev/null
@@ -1,489 +0,0 @@
-/******************************************************************************
- *
- * Copyright(c) 2007 - 2020  Realtek Corporation.
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of version 2 of the GNU General Public License as
- * published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
- * more details.
- *
- * The full GNU General Public License is included in this distribution in the
- * file called LICENSE.
- *
- * Contact Information:
- * wlanfae <wlanfae@realtek.com>
- * Realtek Corporation, No. 2, Innovation Road II, Hsinchu Science Park,
- * Hsinchu 300, Taiwan.
- *
- * Larry Finger <Larry.Finger@lwfinger.net>
- *
- *****************************************************************************/
-#ifndef __HALBB_RUA_TBL_L_ENDIAN_H__
-#define __HALBB_RUA_TBL_L_ENDIAN_H__
-
-#ifdef HALBB_RUA_SUPPORT
-/*@--------------------------[Define] ---------------------------------------*/
-/*[IO Reg]*/
-
-/*@--------------------------[Enum]------------------------------------------*/
-
-
-
-/*@--------------------------[Structure]-------------------------------------*/
-
-	
-struct halbb_rua_tbl_hdr_info {
-	u8 rw:1;
-	u8 idx:7;
-
-	u8 offset:5;
-	u8 len_l:3;
-
-	u8 len_m:7;
-	u8 type:1;
-
-	u8 tbl_class;
-};
-
-struct halbb_ru_rate_info {
-	u8 dcm:1;
-	u8 ss:3;
-	u8 mcs:4;
-};
-
-
-
-struct halbb_tf_ba_tbl_info {
-	u8 fix_ba:1;
-	u8 ru_psd_l:7;
-	
-	u8 ru_psd_m:2;
-	u8 tf_rate_l:6;
-
-	u8 tf_rate_m:3;
-	u8 rf_gain_fix:1;
-	u8 rf_gain_idx_l:4;
-
-	u8 rf_gain_idx_m:6;
-	u8 tb_ppdu_bw:2;
-
-	struct halbb_ru_rate_info rate_i;
-	
-	u8 gi_ltf:3;
-	u8 doppler:1;
-	u8 stbc:1;
-	u8 sta_coding:1;
-	u8 tb_t_pe_nom:2;
-
-	u8 pr20_bw_en:1;
-	u8 ma_type: 1;
-	u8 rsvd1: 6;
-
-	u8 rsvd2;
-};
-
-struct halbb_dl_ru_gp_tbl_info {
-
-	struct halbb_rua_tbl_hdr_info tbl_hdr_i;
-	
-	u8 ppdu_bw:2;
-	u8 tx_pwr_l:6;
-	
-	u8 tx_pwr_m:3;
-	u8 pwr_boost_fac:5;
-	
-	u8 fix_mode_flag:1;
-	u8 rsvd1:7;
-
-	u8 rsvd2;
-	
-	struct halbb_tf_ba_tbl_info tf;
-};
-
-
-
-struct halbb_ul_ru_gp_tbl_info {
-	
-	struct halbb_rua_tbl_hdr_info tbl_hdr_i;
-	u8 grp_psd_max_l;
-	
-	u8 grp_psd_max_m:1;
-	u8 grp_psd_min_l:7;
-
-	u8 grp_psd_min_m:2;
-	u8 tf_rate_l:6;
-	
-	u8 tf_rate_m:3;
-	u8 fix_tf_rate:1;
-	u8 rsvd2:4;
-	
-	u8 ppdu_bw:2;
-	u8 rf_gain_fix:1;
-	u8 rf_gain_idx_l:5;
-	
-	u8 rf_gain_idx_m:5;
-	u8 fix_mode_flag: 1;
-	u8 rsvd1: 2;
-
-	u8 rsvd3;
-
-	u8 rsvd4;
-};
-
-struct halbb_ru_sta_info {
-	
-	struct halbb_rua_tbl_hdr_info tbl_hdr_i;
-/* sta capability */
-	u8 gi_ltf_48spt:1;
-	u8 gi_ltf_18spt:1;
-	u8 rsvd0:6;
-
-/* dl su */
-	u8 dlsu_info_en:1;
-	u8 dlsu_bw:2;
-	u8 dlsu_gi_ltf:3;
-	u8 dlsu_doppler_ctrl:2;
-	
-	u8 dlsu_coding:1;
-	u8 dlsu_txbf:1;
-	u8 dlsu_stbc:1;
-	u8 dl_fwcqi_flag:1;
-	u8 dlru_ratetbl_ridx:4;
-
-	u8 csi_info_bitmap;
-
-	u8 dl_swgrp_bitmap[4];
-	
-	u8 dlsu_dcm:1;
-	u8 rsvd1:6;
-	u8 dlsu_rate_l:1;
-
-	u8 dlsu_rate_m;
-
-	u8 dlsu_pwr:6;
-	u8 rsvd2:2;
-
-	u8 rsvd4;
-/* ul su */
-	u8 ulsu_info_en:1;
-	u8 ulsu_bw:2;
-	u8 ulsu_gi_ltf:3;
-	u8 ulsu_doppler_ctrl:2;
-
-	u8 ulsu_dcm:1;
-	u8 ulsu_ss:3;
-	u8 ulsu_mcs:4;
-
-	u8 ul_fwcqi_flag:1;
-	u8 ulru_ratetbl_ridx:4;
-	u8 ulsu_stbc:1;
-	u8 ulsu_coding:1;
-	u8 ulsu_rssi_m_l:1;
-	
-	u8 ulsu_rssi_m_m;
-	
-	u8 ul_swgrp_bitmap[4];
-/* tb info */
-};
-	
-struct halbb_dl_fix_sta_info {
-	u8 mac_id;
-	u8 ru_pos[3];
-	
-	u8 fix_rate:1;
-	u8 fix_coding:1;
-	u8 fix_txbf:1;
-	u8 fix_pwr_fac:1;
-	u8 rsvd0: 4;
-	
-	struct halbb_ru_rate_info rate_i;
-	
-	u8 txbf:1;
-	u8 coding:1;
-	u8 pwr_boost_fac:5;
-	u8 rsvd1: 1;
-	u8 rsvd2;
-};
-
-struct halbb_dl_fix_sta_info_8ru {
-	u8 mac_id;
-	u8 ru_position[7];
-	
-	u8 fix_rate_flag:1;
-	u8 fix_coding_flag:1;
-	u8 fix_txbf_flag:1;
-	u8 fix_pwr_boost_factor_flag:1;
-	u8 rsvd0: 4;
-	
-	struct halbb_ru_rate_info rate_i;
-	
-	u8 txbf:1;
-	u8 coding:1;
-	u8 pwr_boost_factor:5;
-	u8 rsvd1: 1;
-	u8 rsvd2;
-};
-
-struct halbb_dl_ru_fix_tbl_info {
-	
-	struct halbb_rua_tbl_hdr_info tbl_hdr_i;
-	u8 max_sta_num:3;
-	u8 min_sta_num:3;
-	u8 ru_swp_flg:1;
-	u8 rsvd0:1;
-
-	u8 doppler:1;
-	u8 stbc:1;
-	u8 gi_ltf:3;
-	u8 ma_type:1;
-	u8 fixru_flag:1;
-	u8 rupos_csht_flag:1;
-
-	u8 rsvd2;
-	u8 rsvd3;
-	struct halbb_dl_fix_sta_info sta_i[HALBB_AX4RU_STA_NUM];
-
-};
-
-struct halbb_dl_ru_fix_tbl_info_8ru {
-	
-	struct halbb_rua_tbl_hdr_info tbl_hdr_i;
-	u8 max_sta_num:4;
-	u8 min_sta_num:4;
-	
-	u8 doppler:1;
-	u8 stbc:1;
-	u8 gi_ltf:3;
-	u8 ma_type:1;
-	u8 fix_ru_flag:1;
-	u8 rupos_csht_flg:1;
-	
-	u8 ru_swp_flg:1;
-	u8 rsvd0:7;
-	
-	u8 rsvd1;
-
-	struct halbb_dl_fix_sta_info_8ru sta_i[HALBB_AX8RU_STA_NUM];
-};
-
-struct halbb_ul_fix_sta_info {
-	u8 mac_id;
-	u8 ru_pos[3];
-	u8 tgt_rssi[3];
-	u8 fix_tgt_rssi: 1;
-	u8 fix_rate: 1;
-	u8 fix_coding: 1;
-	u8 coding: 1;
-	u8 rsvd1: 4;
-	struct halbb_ru_rate_info rate_i;
-};
-
-struct halbb_ul_fix_sta_info_8ru {
-	u8 mac_id;
-	u8 ru_position[7];
-	u8 rsvd1;
-	u8 target_rssi[7];
-	u8 fix_target_rssi_flag: 1;
-	u8 fix_rate_flag: 1;
-	u8 fix_coding_flag: 1;
-	u8 coding: 1;
-	u8 rsvd2: 4;
-	struct halbb_ru_rate_info rate_i;
-	u8 rsvd3;
-	u8 rsvd4;
-};
-	
-struct halbb_ul_ru_fix_tbl_info {
-
-	struct halbb_rua_tbl_hdr_info tbl_hdr_i;
-	u8 max_sta_num:3;
-	u8 min_sta_num:3;
-	u8 doppler:1;
-	u8 ma_type:1;
-	u8 gi_ltf:3;
-	u8 stbc:1;
-	u8 fix_tb_t_pe_nom: 1;
-	u8 tb_t_pe_nom: 2;
-	u8 fixru_flag: 1;
-
-	struct halbb_ul_fix_sta_info sta_i[HALBB_AX4RU_STA_NUM];
-
-};
-
-
-struct halbb_ul_ru_fix_tbl_info_8ru {
-
-	struct halbb_rua_tbl_hdr_info tbl_hdr_i;
-	u8 max_sta_num:4;
-	u8 min_sta_num:4;
-
-	u8 gi_ltf:3;
-	u8 stbc:1;
-	u8 fix_tb_t_pe_nominal_flag:1;
-	u8 tb_t_pe_nominal:2;
-	u8 fix_ru_flag: 1;
-
-	u8 doppler:1;
-	u8 ma_type:1;
-	u8 rsvd1:6;
-
-	u8 rsvd2;
-
-	struct halbb_ul_fix_sta_info_8ru sta_i[HALBB_AX8RU_STA_NUM];
-
-};
-
-struct halbb_rua_tbl {
-	struct halbb_dl_ru_gp_tbl_info dl_ru_gp_tbl_i;
-	struct halbb_ul_ru_gp_tbl_info ul_ru_gp_tbl_i;
-	struct halbb_ru_sta_info ru_sta_i;
-	struct halbb_dl_ru_fix_tbl_info dl_ru_fix_tbl_i;
-	struct halbb_ul_ru_fix_tbl_info ul_ru_fix_tbl_i;
-	struct halbb_tf_ba_tbl_info tf_ba_tbl_i;
-};
-
-struct halbb_sw_grp_bitmap {
-	u8 macid;
-
-	u8 en_upd_dl_swgrp:1;
-	u8 en_upd_ul_swgrp:1;
-	u8 cmdend:1; // add for determine whether last user or not
-	u8 rsvd1:5;
-
-	u8 rsvd2;
-	u8 rsvd3;
-	
-	u8 dl_sw_grp_bitmap[4];
-	u8 ul_sw_grp_bitmap[4];
-};
-
-struct halbb_sw_grp_set {
-	
-	struct halbb_sw_grp_bitmap swgrp_bitmap[8];
-	
-};
-
-struct dl_macid_cfg {
-	u8 macid;
-	
-	u8 dl_su_rate_cfg:1;
-	u8 dl_su_rate_l:7;
-	
-	u8 dl_su_rate_m:2;
-	u8 dl_su_bw:2;
-	u8 dl_su_pwr_cfg:1;
-	u8 dl_su_pwr_l:3;
-	
-	u8 dl_su_pwr_m:3;
-	u8 rsvd0:5;
-	
-	u8 gi_ltf_4x8_support:1;
-	u8 gi_ltf_1x8_support:1;
-	u8 rsvd1:6;
-	
-	u8 dl_su_info_en:1;
-	u8 rsvd2:2;
-	u8 dl_su_gi_ltf:3;
-	u8 dl_su_doppler_ctrl:2;
-	
-	u8 dl_su_coding:1;
-	u8 dl_su_txbf:1;
-	u8 dl_su_stbc:1;
-	u8 dl_su_dcm:1;
-	u8 rsvd3:4;
-
-	u8 rsvd4;
-};
-
-struct halbb_ul_macid_cfg {
-
-	u8 macid;
-	
-	u8 endcmd: 1;
-	u8 rsvd0: 7;
-
-	u8 rsvd1;
-	u8 rsvd2;
-
-	u8 ul_su_info_en: 1;
-	u8 ul_su_bw: 2;
-	u8 ul_su_gi_ltf: 3;
-	u8 ul_su_doppler_ctrl: 2;
-	
-	u8 ul_su_dcm: 1;
-	u8 ul_su_ss: 3;
-	u8 ul_su_mcs: 4;
-	
-	u8 rsvd3: 5;
-	u8 ul_su_stbc: 1;
-	u8 ul_su_coding: 1;
-	u8 ul_su_rssi_m_l: 1;
-
-	u8 ul_su_rssi_m_m;
-
-};
-
-struct halbb_ul_macid_set {
-	
-	struct halbb_ul_macid_cfg ul_macid_cfg[8];
-	
-};
-
-
-
-struct halbb_ba_tbl_info {
-	struct halbb_rua_tbl_hdr_info tbl_hdr_i;
-	
-	struct halbb_tf_ba_tbl_info tf_i;
-};
-
-struct csiinfo_cfg{
-	u8 macid;
-	u8 csi_info_bitmap;
-
-	u8 rsvd0;
-	u8 rsvd1;
-};
-
-struct halbb_cqi_info {
-	u8 macid;
-
-	u8 fw_cqi_flag: 1; /* UL or DL*/
-	u8 ru_rate_table_row_idx: 4; /* UL or DL*/
-	u8 ul_dl: 1; /*1'b0 means UL, 1'b1 means DL */
-	u8 endcmd: 1;
-	u8 rsvd0: 1;
-
-	u8 rsvd1;
-	u8 rsvd2;
-
-	s8 cqi_diff_table[19]; /* UL or DL*/
-	u8 rsvd3;
-};
-
-struct halbb_cqi_set{	
-	struct halbb_cqi_info cqi_info[8];
-};
-
-struct halbb_bb_info_cfg {
-	u8 p20_ch_bitmap;
-
-	u8 rsvd0;
-	u8 rsvd1;
-	u8 rsvd2;
-};
-
-struct halbb_pwr_by_rt_tbl{
-	u8 pwr_by_rt[64];
-};
-
-
-/*@--------------------------[Prptotype]-------------------------------------*/
-
-#endif /* HALBB_RUA_SUPPORT */
-
-#endif
diff --git a/os/board/rtl8720e/src/component/wifi/driver/src/hal/phy_g6/bb/halbb_spur_suppress.h b/os/board/rtl8720e/src/component/wifi/driver/src/hal/phy_g6/bb/halbb_spur_suppress.h
deleted file mode 100644
index 4ade9d1eb..000000000
--- a/os/board/rtl8720e/src/component/wifi/driver/src/hal/phy_g6/bb/halbb_spur_suppress.h
+++ /dev/null
@@ -1,78 +0,0 @@
-/******************************************************************************
- *
- * Copyright(c) 2007 - 2021 Realtek Corporation.
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of version 2 of the GNU General Public License as
- * published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
- * more details.
- *
- * The full GNU General Public License is included in this distribution in the
- * file called LICENSE.
- *
- * Contact Information:
- * wlanfae <wlanfae@realtek.com>
- * Realtek Corporation, No. 2, Innovation Road II, Hsinchu Science Park,
- * Hsinchu 300, Taiwan.
- *
- * Larry Finger <Larry.Finger@lwfinger.net>
- *
- *****************************************************************************/
-
-#ifndef _HALBB_SPUR_SUPPRESS_H_
-#define _HALBB_SPUR_SUPPRESS_H_
-
-/*@--------------------------[Define]-------------------------------------*/
-#define CARRIER_SPACING_312_5 312500 // 312.5 kHz
-#define CARRIER_SPACING_78_125 78125 // 78.125 kHz
-#define MAX_TONE_NUM 2048
-
-struct bb_spur_cr_info {
-	u32 seg0_set1_csi_tone_idx;
-	u32 seg0_set1_csi_tone_idx_m;
-	u32 seg0_set1_csi_en;
-	u32 seg0_set1_csi_en_m;
-	u32 path0_notch_nbi_idx;
-	u32 path0_notch_nbi_idx_m;
-	u32 path0_notch_nbi_frac_idx;
-	u32 path0_notch_nbi_frac_idx_m;
-	u32 path0_notch_nbi_en;
-	u32 path0_notch_nbi_en_m;
-	u32 path1_notch_nbi_idx;
-	u32 path1_notch_nbi_idx_m;
-	u32 path1_notch_nbi_frac_idx;
-	u32 path1_notch_nbi_frac_idx_m;
-	u32 path1_notch_nbi_en;
-	u32 path1_notch_nbi_en_m;
-	u32 path0_notch2_nbi_idx;
-	u32 path0_notch2_nbi_idx_m;
-	u32 path0_notch2_nbi_frac_idx;
-	u32 path0_notch2_nbi_frac_idx_m;
-	u32 path0_notch2_nbi_en;
-	u32 path0_notch2_nbi_en_m;
-	u32 path1_notch2_nbi_idx;
-	u32 path1_notch2_nbi_idx_m;
-	u32 path1_notch2_nbi_frac_idx;
-	u32 path1_notch2_nbi_frac_idx_m;
-	u32 path1_notch2_nbi_en;
-	u32 path1_notch2_nbi_en_m;
-};
-struct bb_spur_info {
-	struct bb_spur_cr_info	bb_spur_cr_i;
-};
-
-void halbb_csi_tone_idx(struct bb_info *bb, u8 central_ch,
-                        enum channel_width bw, enum band_type band,
-                        enum phl_phy_idx phy_idx);
-void halbb_nbi_tone_idx(struct bb_info *bb, u8 central_ch, u8 pri_ch,
-                        enum channel_width bw, enum band_type band,
-                        enum rf_path path);
-void halbb_cr_cfg_spur_init(struct bb_info *bb);
-void halbb_spur_dbg(struct bb_info *bb, char input[][16], u32 *_used,
-                    char *output, u32 *_out_len);
-#endif
-
diff --git a/os/board/rtl8720e/src/component/wifi/driver/src/hal/phy_g6/bb/halbb_statistics.h b/os/board/rtl8720e/src/component/wifi/driver/src/hal/phy_g6/bb/halbb_statistics.h
deleted file mode 100644
index a2a5eb719..000000000
--- a/os/board/rtl8720e/src/component/wifi/driver/src/hal/phy_g6/bb/halbb_statistics.h
+++ /dev/null
@@ -1,387 +0,0 @@
-/******************************************************************************
- *
- * Copyright(c) 2007 - 2020  Realtek Corporation.
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of version 2 of the GNU General Public License as
- * published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
- * more details.
- *
- * The full GNU General Public License is included in this distribution in the
- * file called LICENSE.
- *
- * Contact Information:
- * wlanfae <wlanfae@realtek.com>
- * Realtek Corporation, No. 2, Innovation Road II, Hsinchu Science Park,
- * Hsinchu 300, Taiwan.
- *
- * Larry Finger <Larry.Finger@lwfinger.net>
- *
- *****************************************************************************/
-#ifndef __HALBB_STATISTICS_H__
-#define __HALBB_STATISTICS_H__
-
-/*@--------------------------[Define] ---------------------------------------*/
-#define CHK_HANG_L_SIG_TH             3
-#define HANG_RECOVERY		      true // Disable auto-recovery mechanism for 52A CBV
-#define HANG_LIMIT		      1
-
-/*@--------------------------[Enum]------------------------------------------*/
-enum stat_type_sel {
-	STATE_PROBE_RESP	= 1,
-	STATE_BEACON		= 2,
-	STATE_ACTION		= 3,
-	STATE_BFRP		= 4,
-	STATE_NDPA		= 5,
-	STATE_BA		= 6,
-	STATE_RTS		= 7,
-	STATE_CTS		= 8,
-	STATE_ACK		= 9,
-	STATE_DATA		= 10,
-	STATE_NULL		= 11,
-	STATE_QOS		= 12,
-};
-
-enum stat_mac_type {
-	TYPE_PROBE_RESP		= 0x05,
-	TYPE_BEACON		= 0x08,
-	TYPE_ACTION		= 0x0d,
-	TYPE_BFRP		= 0x14,
-	TYPE_NDPA		= 0x15,
-	TYPE_BA			= 0x19,
-	TYPE_RTS		= 0x1b,
-	TYPE_CTS		= 0x1c,
-	TYPE_ACK		= 0x1d,
-	TYPE_DATA		= 0x20,
-	TYPE_NULL		= 0x24,
-	TYPE_QOS		= 0x28,
-};
-
-/*@--------------------------[Structure]-------------------------------------*/
-struct bb_usr_set_info {
-	u16		ofdm2_rate_idx;
-	u16		ht2_rate_idx;
-	u16		vht2_rate_idx;
-	u16		he2_rate_idx;
-	enum stat_mac_type stat_mac_type_i;
-	enum stat_type_sel stat_type_sel_i;
-};
-
-struct bb_cca_info {
-	u32		cnt_ofdm_cca;
-	u32		cnt_cck_cca;
-	u32		cnt_cca_all;
-	u32		cnt_cck_spoofing;
-	u32		cnt_ofdm_spoofing;
-	u32		cnt_cca_spoofing_all;
-	u32		pop_cnt;
-};
-
-struct bb_crc_info {
-	u32		cnt_ampdu_miss;
-	u32		cnt_ampdu_crc_error;
-	u32		cnt_ampdu_crc_ok;
-	u32		cnt_cck_crc32_error;
-	u32		cnt_cck_crc32_ok;
-	u32		cnt_ofdm_crc32_error;
-	u32		cnt_ofdm_crc32_ok;
-	u32		cnt_ht_crc32_error;
-	u32		cnt_ht_crc32_ok;
-	u32		cnt_vht_crc32_error;
-	u32		cnt_vht_crc32_ok;
-	u32		cnt_he_crc32_ok;
-	u32		cnt_he_crc32_error;
-	u32		cnt_crc32_error_all;
-	u32		cnt_crc32_ok_all;
-};
-
-struct bb_crc2_info {
-	u32		cnt_ofdm2_crc32_error;
-	u32		cnt_ofdm2_crc32_ok;
-	u8		ofdm2_pcr;
-	u32		cnt_ht2_crc32_error;
-	u32		cnt_ht2_crc32_ok;
-	u8		ht2_pcr;
-	u32		cnt_vht2_crc32_error;
-	u32		cnt_vht2_crc32_ok;
-	u8		vht2_pcr;
-	u32		cnt_he2_crc32_error;
-	u32		cnt_he2_crc32_ok;
-	u8		he2_pcr;
-	u32		cnt_ofdm3_crc32_error;
-	u32		cnt_ofdm3_crc32_ok;
-};
-
-struct bb_cck_fa_info {
-	u32		sfd_gg_cnt;
-	u32		sig_gg_cnt;
-	u32		cnt_cck_crc_16;
-};
-
-struct bb_legacy_fa_info {
-	u32		cnt_lsig_brk_s_th;
-	u32		cnt_lsig_brk_l_th;
-	u32		cnt_parity_fail;
-	u32		cnt_rate_illegal;	
-	u32		cnt_sb_search_fail;
-};
-
-struct bb_ht_fa_info {
-	u32		cnt_crc8_fail;
-	u32		cnt_crc8_fail_s_th;
-	u32		cnt_crc8_fail_l_th;
-	u32		cnt_mcs_fail;
-};
-
-struct bb_vht_fa_info {
-	u32		cnt_crc8_fail_vhta;
-	/*u32		cnt_crc8_fail_vhtb; removed at RXD*/
-	u32		cnt_mcs_fail_vht;
-};
-
-struct bb_he_fa_info {
-	u32		cnt_crc4_fail_hea_su;
-	u32		cnt_crc4_fail_hea_ersu;
-	u32		cnt_crc4_fail_hea_mu;
-	u32		cnt_crc4_fail_heb_ch1_mu;
-	u32		cnt_crc4_fail_heb_ch2_mu;
-	u32		cnt_mcs_fail_he_bcc;
-	u32		cnt_mcs_fail_he;
-	u32		cnt_mcs_fail_he_dcm;
-};
-
-struct bb_fa_info {
-	u32		cnt_total_brk;
-	u32		cnt_cck_fail;
-	u32		cnt_ofdm_fail;
-	u32		cnt_fail_all;
-	struct bb_cck_fa_info		bb_cck_fa_i;
-	struct bb_legacy_fa_info	bb_legacy_fa_i;
-	struct bb_ht_fa_info		bb_ht_fa_i;
-	struct bb_vht_fa_info		bb_vht_fa_i;
-	struct bb_he_fa_info		bb_he_fa_i;
-};
-
-struct bb_tx_cnt_info {
-	u32		cck_mac_txen;
-	u32		cck_phy_txon;
-	u32		ofdm_mac_txen;
-	u32		ofdm_phy_txon;
-};
-
-struct bb_stat_cr_info {
-	u32 cck_cca;	    
-	u32 cck_cca_m;		
-	u32 cck_crc16fail;	
-	u32 cck_crc16fail_m;
-	u32 cck_crc32ok;	
-	u32 cck_crc32ok_m;
-	u32 cck_crc32fail;
-	u32 cck_crc32fail_m;
-	u32 cca_spoofing;		
-	u32 cca_spoofing_m;		
-	u32 lsig_brk_s_th;		
-	u32 lsig_brk_s_th_m;	
-	u32 lsig_brk_l_th;		
-	u32 lsig_brk_l_th_m;
-	u32 htsig_crc8_err_s_th;	
-	u32 htsig_crc8_err_s_th_m;	
-	u32 htsig_crc8_err_l_th;
-	u32 htsig_crc8_err_l_th_m;	
-	u32 brk;			
-	u32 brk_m;
-	u32 brk_sel;		
-	u32 brk_sel_m;		
-	u32 rxl_err_parity;	
-	u32 rxl_err_parity_m;	
-	u32 rxl_err_rate;		
-	u32 rxl_err_rate_m;		
-	u32 ht_err_crc8;	    
-	u32 ht_err_crc8_m;		
-	u32 vht_err_siga_crc8;	
-	u32 vht_err_siga_crc8_m;	
-	u32 ht_not_support_mcs;	
-	u32 ht_not_support_mcs_m;
-	u32 vht_not_support_mcs;	
-	u32 vht_not_support_mcs_m;		
-	u32 err_during_bt_tx;	
-	u32 err_during_bt_tx_m;	
-	u32 err_during_bt_rx;	
-	u32 err_during_bt_rx_m;	
-	u32 edge_murx_nsts0;	
-	u32 edge_murx_nsts0_m;	
-	u32 search_fail;		
-	u32 search_fail_m;	
-	u32 ofdm_cca;		
-	u32 ofdm_cca_m;		
-	u32 ofdm_cca_s20;	
-	u32 ofdm_cca_s20_m;
-	u32 ofdm_cca_s40;	
-	u32 ofdm_cca_s40_m;	
-	u32 ofdm_cca_s80;	
-	u32 ofdm_cca_s80_m;
-	u32 ccktxen;
-	u32 ccktxen_m;
-	u32 ccktxon;
-	u32 ccktxon_m;
-	u32 ofdmtxon;		
-	u32 ofdmtxon_m;		
-	u32 ofdmtxen;		
-	u32 ofdmtxen_m;		
-	u32 drop_trig;		
-	u32 drop_trig_m;	
-	u32 pop_trig;		
-	u32 pop_trig_m;		
-	u32 tx_conflict;		
-	u32 tx_conflict_m;	
-	u32 wmac_rstb;		
-	u32 wmac_rstb_m;		
-	u32 en_tb_ppdu_fix_gain;
-	u32 en_tb_ppdu_fix_gain_m;
-	u32 en_tb_cca_pw_th;
-	u32 en_tb_cca_pw_th_m;
-	u32 he_crc_ok;
-	u32 he_crc_ok_m;
-	u32 he_crc_err;
-	u32 he_crc_err_m;
-	u32 vht_crc_ok;
-	u32 vht_crc_ok_m;
-	u32 vht_crc_err;
-	u32 vht_crc_err_m;
-	u32 ht_crc_ok;
-	u32 ht_crc_ok_m;
-	u32 ht_crc_err;
-	u32 ht_crc_err_m;
-	u32 l_crc_ok;
-	u32 l_crc_ok_m;
-	u32 l_crc_err;
-	u32 l_crc_err_m;
-	u32 he_crc_ok2;
-	u32 he_crc_ok2_m;
-	u32 he_crc_err2;
-	u32 he_crc_err2_m;
-	u32 vht_crc_ok2;
-	u32 vht_crc_ok2_m;
-	u32 vht_crc_err2;
-	u32 vht_crc_err2_m;
-	u32 ht_crc_ok2;
-	u32 ht_crc_ok2_m;
-	u32 ht_crc_err2;
-	u32 ht_crc_err2_m;
-	u32 l_crc_ok2;
-	u32 l_crc_ok2_m;
-	u32 l_crc_err2;
-	u32 l_crc_err2_m;
-	u32 l_crc_ok3;
-	u32 l_crc_ok3_m;
-	u32 l_crc_err3;
-	u32 l_crc_err3_m;
-	u32 ampdu_rxon;
-	u32 ampdu_rxon_m;
-	u32 ampdu_miss;
-	u32 ampdu_miss_m;
-	u32 ampdu_crc_ok;
-	u32 ampdu_crc_ok_m;
-	u32 ampdu_crc_err;
-	u32 ampdu_crc_err_m;
-	u32 hesu_err_sig_a_crc4;
-	u32 hesu_err_sig_a_crc4_m;
-	u32 heersu_err_sig_a_crc4;
-	u32 heersu_err_sig_a_crc4_m;
-	u32 hemu_err_sig_a_crc4;
-	u32 hemu_err_sig_a_crc4_m;
-	u32 hemu_err_sigb_ch1_comm_crc4;
-	u32 hemu_err_sigb_ch1_comm_crc4_m;
-	u32 hemu_err_sigb_ch2_comm_crc4;
-	u32 hemu_err_sigb_ch2_comm_crc4_m;
-	u32 he_u0_err_bcc_mcs;
-	u32 he_u0_err_bcc_mcs_m;
-	u32 he_u0_err_mcs;
-	u32 he_u0_err_mcs_m;
-	u32 he_u0_err_dcm_mcs;
-	u32 he_u0_err_dcm_mcs_m;
-	u32 r1b_rx_rpt_rst;
-	u32 r1b_rx_rpt_rst_m;
-	u32 r1b_rr_sel;
-	u32 r1b_rr_sel_m;
-	u32 rst_all_cnt;
-	u32 rst_all_cnt_m;
-	u32 enable_all_cnt;
-	u32 enable_all_cnt_m;
-	u32 enable_ofdm;
-	u32 enable_ofdm_m;
-	u32 enable_cck;
-	u32 enable_cck_m;
-	u32 r1b_rx_dis_cca;
-	u32 r1b_rx_dis_cca_m;
-	u32 intf_r_rate;
-	u32 intf_r_rate_m;
-	u32 intf_r_mcs;
-	u32 intf_r_mcs_m;
-	u32 intf_r_vht_mcs;
-	u32 intf_r_vht_mcs_m;
-	u32 intf_r_he_mcs;
-	u32 intf_r_he_mcs_m;
-	u32 intf_r_vht_nss;
-	u32 intf_r_vht_nss_m;
-	u32 intf_r_he_nss;
-	u32 intf_r_he_nss_m;
-	u32 intf_r_mac_hdr_type;
-	u32 intf_r_mac_hdr_type_m;
-	u32 intf_r_pkt_type;
-	u32 intf_r_pkt_type_m;
-	u32 dbcc;
-	u32 dbcc_m;
-	u32 dbcc_2p4g_band_sel;
-	u32 dbcc_2p4g_band_sel_m;
-	u32 cnt_pop_trig;
-	u32 cnt_pop_trig_m;
-	u32 max_cnt_pop;
-	u32 max_cnt_pop_m;
-};
-
-struct bb_stat_info {
-	struct bb_stat_cr_info bb_stat_cr_i;
-	u32		cnt_bw_usc;
-	u32		cnt_bw_lsc;
-	u32		time_fa_all;
-	u32		dbg_port0;
-	u32		chk_hang_cnt;
-	u8		chk_hang_limit;
-	bool	hang_recovery_en;
-	bool	cnt_reset_en;
-	bool		cck_block_enable;
-	bool		ofdm_block_enable;
-	struct bb_tx_cnt_info		bb_tx_cnt_i;
-	struct bb_cca_info		bb_cca_i;
-	struct bb_crc_info		bb_crc_i;
-	struct bb_crc2_info		bb_crc2_i;
-	struct bb_fa_info		bb_fa_i;
-	struct bb_usr_set_info		bb_usr_set_i;
-};
-
-struct bb_info;
-/*@--------------------------[Prptotype]-------------------------------------*/
-
-void halbb_chk_hang(struct bb_info *bb);
-void halbb_print_cnt3(struct bb_info *bb, enum phl_phy_idx phy_idx);
-void halbb_print_cnt2(struct bb_info *bb, enum phl_phy_idx phy_idx);
-void halbb_print_cnt(struct bb_info *bb, bool cck_enable, enum phl_phy_idx phy_idx, enum phl_phy_idx phy_idx_2);
-void halbb_cnt_reg_reset(struct bb_info *bb);
-void halbb_set_crc32_cnt2_rate(struct bb_info *bb, u16 rate_idx);
-void halbb_set_crc32_cnt3_format(struct bb_info *bb, u8 usr_type_sel);
-void halbb_crc32_cnt_dbg(struct bb_info *bb, char input[][16], u32 *_used, 
-			 char *output, u32 *_out_len);
-void halbb_cck_cnt_statistics(struct bb_info *bb);
-void halbb_ofdm_cnt_statistics(struct bb_info *bb, enum phl_phy_idx phy_idx);
-void halbb_statistics_reset(struct bb_info *bb);
-void halbb_statistics(struct bb_info *bb);
-void halbb_statistics_init(struct bb_info *bb);
-void halbb_cr_cfg_stat_init(struct bb_info *bb);
-void halbb_pmac_statistics(struct bb_info *bb);
-#endif
-
diff --git a/os/board/rtl8720e/src/component/wifi/driver/src/hal/phy_g6/bb/halbb_types.h b/os/board/rtl8720e/src/component/wifi/driver/src/hal/phy_g6/bb/halbb_types.h
deleted file mode 100644
index f777b1978..000000000
--- a/os/board/rtl8720e/src/component/wifi/driver/src/hal/phy_g6/bb/halbb_types.h
+++ /dev/null
@@ -1,33 +0,0 @@
-/******************************************************************************
- *
- * Copyright(c) 2007 - 2017  Realtek Corporation.
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of version 2 of the GNU General Public License as
- * published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
- * more details.
- *
- * The full GNU General Public License is included in this distribution in the
- * file called LICENSE.
- *
- * Contact Information:
- * wlanfae <wlanfae@realtek.com>
- * Realtek Corporation, No. 2, Innovation Road II, Hsinchu Science Park,
- * Hsinchu 300, Taiwan.
- *
- * Larry Finger <Larry.Finger@lwfinger.net>
- *
- *****************************************************************************/
-#ifndef __HALBB_TYPES_H__
-#define __HALBB_TYPES_H__
- /*@--------------------------[Define] ---------------------------------------*/
-#define HALBB_CONFIG_RUN_IN_DRV
-
-/*For FW API*/
-#define	__iram_func__
-
-#endif /* __HALBB_TYPES_H__ */
diff --git a/os/board/rtl8720e/src/component/wifi/driver/src/hal/phy_g6/bb/halbb_ul_tb_ctrl.h b/os/board/rtl8720e/src/component/wifi/driver/src/hal/phy_g6/bb/halbb_ul_tb_ctrl.h
deleted file mode 100644
index 9d1571098..000000000
--- a/os/board/rtl8720e/src/component/wifi/driver/src/hal/phy_g6/bb/halbb_ul_tb_ctrl.h
+++ /dev/null
@@ -1,60 +0,0 @@
-/******************************************************************************
- *
- * Copyright(c) 2007 - 2020  Realtek Corporation.
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of version 2 of the GNU General Public License as
- * published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
- * more details.
- *
- * The full GNU General Public License is included in this distribution in the
- * file called LICENSE.
- *
- * Contact Information:
- * wlanfae <wlanfae@realtek.com>
- * Realtek Corporation, No. 2, Innovation Road II, Hsinchu Science Park,
- * Hsinchu 300, Taiwan.
- *
- * Larry Finger <Larry.Finger@lwfinger.net>
- *
- *****************************************************************************/
-#ifndef __HALBB_UL_TB_CTRL_H__
-#define __HALBB_UL_TB_CTRL_H__
-
-/*@--------------------------[Define] ---------------------------------------*/
-#define		TF_CNT_L2H_TH	100
-#define		TF_CNT_H2L_TH	70
-/*@--------------------------[Enum]------------------------------------------*/
-
-/*@--------------------------[Structure]-------------------------------------*/
-
-struct bb_ul_tb_cr_info {
-	u32 if_bandedge;
-	u32 if_bandedge_m;
-};
-
-struct bb_ul_tb_info {
-	struct bb_ul_tb_cr_info bb_ul_tb_cr_i;
-	bool	dyn_tb_bedge_en;
-	bool	dyn_tb_tri_en;
-	u8	def_if_bandedge;
-	u8	def_tri_idx;
-	u32	tf_cnt_l2h_th;
-	u32	tf_cnt_h2l_th;
-};
-
-struct bb_info;
-/*@--------------------------[Prptotype]-------------------------------------*/
-void halbb_ul_tb_reset(struct bb_info *bb);
-void halbb_ul_tb_chk(struct bb_info *bb);
-void halbb_ul_tb_ctrl(struct bb_info *bb);
-void halbb_ul_tb_dbg(struct bb_info *bb, char input[][16], u32 *_used,
-			      char *output, u32 *_out_len);
-void halbb_ul_tb_ctrl_init(struct bb_info *bb);
-void halbb_cr_cfg_ul_tb_init(struct bb_info *bb);
-#endif
-
diff --git a/os/board/rtl8720e/src/component/wifi/driver/src/hal/phy_g6/bb/halbb_wpp.h b/os/board/rtl8720e/src/component/wifi/driver/src/hal/phy_g6/bb/halbb_wpp.h
deleted file mode 100644
index 42fadbebb..000000000
--- a/os/board/rtl8720e/src/component/wifi/driver/src/hal/phy_g6/bb/halbb_wpp.h
+++ /dev/null
@@ -1,64 +0,0 @@
-/******************************************************************************
- *
- * Copyright(c) 2007 - 2017  Realtek Corporation.
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of version 2 of the GNU General Public License as
- * published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
- * more details.
- *
- * The full GNU General Public License is included in this distribution in the
- * file called LICENSE.
- *
- * Contact Information:
- * wlanfae <wlanfae@realtek.com>
- * Realtek Corporation, No. 2, Innovation Road II, Hsinchu Science Park,
- * Hsinchu 300, Taiwan.
- *
- * Larry Finger <Larry.Finger@lwfinger.net>
- *
- *****************************************************************************/
-#ifndef __HALBB_WPP_H__
-#define __HALBB_WPP_H__
-
-#define HALBB_WPP_CONTROL_GUIDS \
-	WPP_DEFINE_CONTROL_GUID( \
-		HalbbGuid, (111AA0F8,4BB9,4C05,BE3E,03383B8CD916), \
-		WPP_DEFINE_BIT(DBG_RA) \
-		WPP_DEFINE_BIT(DBG_FA_CNT) \
-		WPP_DEFINE_BIT(HALBB_FUN_RSVD_2) \
-		WPP_DEFINE_BIT(DBG_DFS) \
-		WPP_DEFINE_BIT(DBG_EDCCA)\
-		WPP_DEFINE_BIT(DBG_ENV_MNTR)\
-		WPP_DEFINE_BIT(DBG_CFO_TRK)\
-		WPP_DEFINE_BIT(DBG_PWR_CTRL)\
-		WPP_DEFINE_BIT(DBG_RUA_TBL)\
-		WPP_DEFINE_BIT(DBG_AUTO_DBG)\
-		WPP_DEFINE_BIT(DBG_ANT_DIV)\
-		WPP_DEFINE_BIT(DBG_DIG)\
-		WPP_DEFINE_BIT(DBG_PATH_DIV)\
-		WPP_DEFINE_BIT(DBG_UL_TB_CTRL)\
-		WPP_DEFINE_BIT(DBG_BIT14)\
-		WPP_DEFINE_BIT(DBG_BIT15)\
-		WPP_DEFINE_BIT(DBG_BIT16)\
-		WPP_DEFINE_BIT(DBG_BIT17)\
-		WPP_DEFINE_BIT(DBG_BIT18)\
-		WPP_DEFINE_BIT(DBG_CH_INFO)\
-		WPP_DEFINE_BIT(DBG_PHY_STS)\
-		WPP_DEFINE_BIT(DBG_BIT21)\
-		WPP_DEFINE_BIT(DBG_FW_INFO)\
-		WPP_DEFINE_BIT(DBG_COMMON_FLOW)\
-		WPP_DEFINE_BIT(DBG_IC_API)\
-		WPP_DEFINE_BIT(DBG_DBG_API)\
-		WPP_DEFINE_BIT(DBG_DBCC)\
-		WPP_DEFINE_BIT(DBG_DM_SUMMARY)\
-		WPP_DEFINE_BIT(DBG_PHY_CONFIG)\
-		WPP_DEFINE_BIT(DBG_INIT)\
-		WPP_DEFINE_BIT(DBG_CMN)\
-		WPP_DEFINE_BIT(DBG_DCR)\
-		)
-#endif /* __HALBB_TYPES_H__ */
\ No newline at end of file
diff --git a/os/board/rtl8720e/src/component/wifi/driver/src/hal/rtl8720e/hci_intfs.h b/os/board/rtl8720e/src/component/wifi/driver/src/hal/rtl8720e/hci_intfs.h
deleted file mode 100644
index 76fce07a8..000000000
--- a/os/board/rtl8720e/src/component/wifi/driver/src/hal/rtl8720e/hci_intfs.h
+++ /dev/null
@@ -1,42 +0,0 @@
-/******************************************************************************
- *
- * Copyright(c) 2007 - 2012 Realtek Corporation. All rights reserved.
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of version 2 of the GNU General Public License as
- * published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
- * more details.
- *
- * You should have received a copy of the GNU General Public License along with
- * this program; if not, write to the Free Software Foundation, Inc.,
- * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
- *
- *
- ******************************************************************************/
-#ifndef _HCI_INTFS_H_
-#define _HCI_INTFS_H_
-
-#include <autoconf.h>
-
-#define 	HAL_INTERFACE_CMD_LEN			0
-#define 	HAL_INTERFACE_CMD_STATUS_LEN   	0
-#define 	HAL_INTERFACE_OVERHEAD			(HAL_INTERFACE_CMD_LEN+HAL_INTERFACE_CMD_STATUS_LEN)
-
-#define	GSPI_STATUS_LEN		0
-
-extern void hci_intf_init(_adapter *padapter);
-extern void hci_intf_deinit(_adapter *padapter);
-extern void hci_intf_request_irq(_adapter *padapter);
-extern void hci_intf_free_irq(_adapter *padapter);
-
-
-#define hci_bus_intf_type RTW_AXI
-#define hci_intf_stop	hci_axi_intf_stop
-void hci_axi_intf_stop(_adapter *padapter);
-
-#endif //_HCI_INTFS_H_
-
diff --git a/os/board/rtl8720e/src/component/wifi/driver/src/osdep/bt_intf.h b/os/board/rtl8720e/src/component/wifi/driver/src/intf/rtw_intf_bt.h
old mode 100644
new mode 100755
similarity index 98%
rename from os/board/rtl8720e/src/component/wifi/driver/src/osdep/bt_intf.h
rename to os/board/rtl8720e/src/component/wifi/driver/src/intf/rtw_intf_bt.h
index a758eee37..ca17384d2
--- a/os/board/rtl8720e/src/component/wifi/driver/src/osdep/bt_intf.h
+++ b/os/board/rtl8720e/src/component/wifi/driver/src/intf/rtw_intf_bt.h
@@ -19,7 +19,7 @@
 #ifdef	__cplusplus
 extern "C" {
 #endif
-#include <autoconf.h>
+#include <rtw_autoconf.h>
 
 
 
diff --git a/os/board/rtl8720e/src/component/wifi/driver/src/osdep/lwip_intf.h b/os/board/rtl8720e/src/component/wifi/driver/src/intf/rtw_intf_lwip.h
old mode 100644
new mode 100755
similarity index 76%
rename from os/board/rtl8720e/src/component/wifi/driver/src/osdep/lwip_intf.h
rename to os/board/rtl8720e/src/component/wifi/driver/src/intf/rtw_intf_lwip.h
index 853885a34..e953e1b4f
--- a/os/board/rtl8720e/src/component/wifi/driver/src/osdep/lwip_intf.h
+++ b/os/board/rtl8720e/src/component/wifi/driver/src/intf/rtw_intf_lwip.h
@@ -20,46 +20,30 @@
 extern "C" {
 #endif
 
-#include <wireless.h>
-#include <skbuff.h>
+#include <rtw_skbuff.h>
 
 struct netif;
 
 //----- ------------------------------------------------------------------
 // Ethernet Buffer
 //----- ------------------------------------------------------------------
-#if defined(CONFIG_MBED_ENABLED)
-struct eth_drv_sg {
-	unsigned int			buf;
-	unsigned int			len;
-};
-
-#define MAX_ETH_DRV_SG		32
-#define MAX_ETH_MSG			1540
-#else
 #if defined(CONFIG_LWIP_LAYER) && CONFIG_LWIP_LAYER
 #include "ethernetif.h"  // moved to ethernetif.h by jimmy 12/2/2015
 #endif
-#endif
 //----- ------------------------------------------------------------------
 // Wlan Interface Provided
 //----- ------------------------------------------------------------------
-void rltk_wlan_tx_inc(int idx);
-void rltk_wlan_tx_dec(int idx);
-struct sk_buff *rltk_wlan_get_recv_skb(int idx);
-struct sk_buff *rltk_wlan_alloc_skb(unsigned int total_len);
+void wifi_if_tx_inc(int idx);
+void wifi_if_tx_dec(int idx);
+struct sk_buff *wifi_if_get_recv_skb(int idx);
+struct sk_buff *wifi_if_alloc_skb(unsigned int total_len);
 void rltk_wlan_set_netif_info(int idx_wlan, void *dev, unsigned char *dev_addr);
-void wifi_send_skb(int idx, struct sk_buff *skb);	//struct sk_buff as defined above comment line
+void wifi_if_send_skb(int idx, struct sk_buff *skb);	//struct sk_buff as defined above comment line
 #if defined(CONFIG_LWIP_LAYER) && CONFIG_LWIP_LAYER
 int rltk_wlan_send(int idx, struct eth_drv_sg *sg_list, int sg_len, int total_len);
 void rltk_wlan_recv(int idx, struct eth_drv_sg *sg_list, int sg_len);
 #endif
 
-#if defined(CONFIG_MBED_ENABLED)
-typedef void (*emac_callback)(void *param, struct netif *netif, unsigned int len);
-void set_callback_func(emac_callback p, void *data);
-#endif
-
 //----- ------------------------------------------------------------------
 // Network Interface provided
 //----- ------------------------------------------------------------------
@@ -68,9 +52,7 @@ int netif_is_valid_IP(int idx, unsigned char *ip_dest);
 unsigned char *netif_get_hwaddr(int idx_wlan);
 void netif_rx(int idx, unsigned int len);
 #if defined(CONFIG_LWIP_LAYER) && CONFIG_LWIP_LAYER
-#if !defined(CONFIG_MBED_ENABLED)
 extern void ethernetif_recv(struct netif *netif, int total_len);
-#endif
 #endif //CONFIG_LWIP_LAYER == 1
 
 #ifdef CONFIG_WOWLAN
diff --git a/os/board/rtl8720e/src/component/wifi/driver/src/osdep/freertos/Make.defs b/os/board/rtl8720e/src/component/wifi/driver/src/osdep/freertos/Make.defs
deleted file mode 100644
index ec7f11e58..000000000
--- a/os/board/rtl8720e/src/component/wifi/driver/src/osdep/freertos/Make.defs
+++ /dev/null
@@ -1,55 +0,0 @@
-###########################################################################
-#
-# Copyright 2021 Samsung Electronics All Rights Reserved.
-#
-# Licensed under the Apache License, Version 2.0 (the "License");
-# you may not use this file except in compliance with the License.
-# You may obtain a copy of the License at
-#
-# http://www.apache.org/licenses/LICENSE-2.0
-#
-# Unless required by applicable law or agreed to in writing,
-# software distributed under the License is distributed on an
-# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,
-# either express or implied. See the License for the specific
-# language governing permissions and limitations under the License.
-#
-###########################################################################
-############################################################################
-#
-#   Copyright (C) 2021 Gregory Nutt. All rights reserved.
-#   Author: Gregory Nutt <gnutt@nuttx.org>
-#
-# Redistribution and use in source and binary forms, with or without
-# modification, are permitted provided that the following conditions
-# are met:
-#
-# 1. Redistributions of source code must retain the above copyright
-#    notice, this list of conditions and the following disclaimer.
-# 2. Redistributions in binary form must reproduce the above copyright
-#    notice, this list of conditions and the following disclaimer in
-#    the documentation and/or other materials provided with the
-#    distribution.
-# 3. Neither the name NuttX nor the names of its contributors may be
-#    used to endorse or promote products derived from this software
-#    without specific prior written permission.
-#
-# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
-# "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
-# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
-# FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
-# COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
-# INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
-# BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS
-# OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED
-# AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
-# LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
-# ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
-# POSSIBILITY OF SUCH DAMAGE.
-#
-############################################################################
-
-CSRCS += freertos_skbuff.c
-
-DEPPATH += --dep-path component/wifi/driver/src/osdep/freertos
-VPATH += :component/wifi/driver/src/osdep/freertos
diff --git a/os/board/rtl8720e/src/component/wifi/driver/src/osdep/freertos/freertos_intfs.h b/os/board/rtl8720e/src/component/wifi/driver/src/osdep/freertos/freertos_intfs.h
deleted file mode 100644
index 951ca22f1..000000000
--- a/os/board/rtl8720e/src/component/wifi/driver/src/osdep/freertos/freertos_intfs.h
+++ /dev/null
@@ -1,53 +0,0 @@
-/******************************************************************************
- *
- * Copyright(c) 2007 - 2012 Realtek Corporation. All rights reserved.
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of version 2 of the GNU General Public License as
- * published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
- * more details.
- *
- * You should have received a copy of the GNU General Public License along with
- * this program; if not, write to the Free Software Foundation, Inc.,
- * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
- *
- *
- ******************************************************************************/
-
-#ifndef __FREERTOS_INTFS_H_
-#define __FREERTOS_INTFS_H_
-
-struct net_device *rtw_init_netdev(_adapter *padapter);
-void rtw_os_indicate_disconnect(_adapter *adapter);
-
-extern int rtw_set_wpa_ie(_adapter *padapter, char *pie, unsigned short ielen);
-extern void rtw_os_indicate_connect(_adapter *adapter);
-extern void netdev_lwip_post_sleep_processing(void);
-extern void wireless_send_event(struct net_device *dev, unsigned int event, u8 *buf, int buf_len, int flags);
-
-#ifdef CONFIG_CONCURRENT_MODE
-_adapter *rtw_drv_if2_init(_adapter *primary_padapter);
-void rtw_if2_deinit(_adapter *padapter);
-#endif
-
-extern thread_return rtw_interrupt_thread(thread_context context);
-
-extern thread_return rtw_recv_tasklet(thread_context context);
-extern thread_return rtw_xmit_tasklet(thread_context context);
-#if defined (CONFIG_WOWLAN) && defined (CONFIG_FW_DRIVER_COEXIST) && CONFIG_FW_DRIVER_COEXIST
-extern thread_return rtw_driver_resume_thread(thread_context context);
-#endif
-extern int rtw_dev_remove(struct net_device *pnetdev);
-extern int netdev_close(struct net_device *pnetdev);
-extern void rtw_indicate_wx_assoc_event(_adapter *padapter);
-
-#if defined(CONFIG_LX_HCI)
-u32 lextra_bus_dma_Interrupt(void *data);
-#endif
-
-#endif	//__FREERTOS_INTFS_H_
-
diff --git a/os/board/rtl8720e/src/component/wifi/driver/src/osdep/freertos/freertos_skbuff.c b/os/board/rtl8720e/src/component/wifi/driver/src/osdep/freertos/freertos_skbuff.c
deleted file mode 100644
index e0c92f749..000000000
--- a/os/board/rtl8720e/src/component/wifi/driver/src/osdep/freertos/freertos_skbuff.c
+++ /dev/null
@@ -1,706 +0,0 @@
-#include <drv_types.h>
-#include <freertos/freertos_skbuff.h>
-
-//----- ------------------------------------------------------------------
-// SKB Operation
-//----- ------------------------------------------------------------------
-
-static int skb_fail_count;
-
-struct skb_buf {
-	struct list_head list;
-	struct sk_buff skb;
-#if defined(CONFIG_AS_INIC_NP)
-	u8 rsvd[10]; /* keep total size 64B alignment */
-#endif
-};
-
-_WEAK int max_local_skb_num = MAX_LOCAL_SKB_NUM;
-#if defined(CONFIG_AS_INIC_NP)
-_WEAK struct skb_buf skb_pool[MAX_LOCAL_SKB_NUM] __attribute__((aligned(64)));
-#else
-_WEAK struct skb_buf skb_pool[MAX_LOCAL_SKB_NUM];
-#endif
-static struct list_head wrapper_skbbuf_list;
-int skbbuf_used_num;
-int max_skbbuf_used_num;
-
-struct skb_data {
-	/* starting address must be aligned by 32 bytes for km4 cache. */
-	struct list_head list __attribute__((aligned(32)));
-	unsigned char buf[MAX_SKB_BUF_SIZE];
-	/* to protect ref when to invalid cache, its address must be
-	 * aligned by 32 bytes. */
-	atomic_t ref __attribute__((aligned(32)));
-};
-
-_WEAK int max_skb_buf_num = MAX_SKB_BUF_NUM;
-SRAM_BD_DATA_SECTION
-#if defined(CONFIG_AS_INIC_NP)
-_WEAK struct skb_data skb_data_pool[MAX_SKB_BUF_NUM] __attribute__((aligned(64)));
-#else
-_WEAK struct skb_data skb_data_pool[MAX_SKB_BUF_NUM];
-#endif
-SRAM_BD_DATA_SECTION
-struct list_head skbdata_list;
-
-int skbdata_used_num;
-int max_skbdata_used_num;
-
-#ifdef CONFIG_TRACE_SKB
-extern void snapshot_skb(void);
-#endif
-
-void skb_fail_inc(void)
-{
-	unsigned int irq_flags = save_and_cli();
-	skb_fail_count ++;
-	restore_flags(irq_flags);
-}
-
-int skb_fail_get_and_rst(void)
-{
-	int fail;
-
-	unsigned int irq_flags = save_and_cli();
-	fail = skb_fail_count;
-	skb_fail_count = 0;
-	restore_flags(irq_flags);
-
-	return fail;
-}
-
-static __inline__ void *get_buf_from_poll(struct list_head *phead, int *count)
-{
-	struct sk_buff *skb;
-	struct list_head *plist;
-
-	if (list_empty(phead)) {
-#ifdef CONFIG_TRACE_SKB
-		snapshot_skb();
-#endif
-		return NULL;
-	}
-
-	plist = phead->next;
-	list_del_init(plist);
-
-	skb = (struct sk_buff *)((unsigned int)plist + sizeof(struct list_head));
-
-	*count = *count + 1;
-
-	return (unsigned char *)skb;
-}
-
-static void release_buf_to_poll(unsigned char *buf, struct list_head *phead, int *count)
-{
-	struct list_head *plist;
-	plist = (struct list_head *)(((unsigned int)buf) - sizeof(struct list_head));
-
-	list_add_tail(plist, phead);
-
-	*count = *count - 1;
-}
-
-void init_skb_pool(void)
-{
-	int i;
-
-	memset(skb_pool, '\0', max_local_skb_num * sizeof(struct skb_buf));
-	INIT_LIST_HEAD(&wrapper_skbbuf_list);
-
-	for (i = 0; i < max_local_skb_num; i++) {
-		INIT_LIST_HEAD(&skb_pool[i].list);
-		list_add_tail(&skb_pool[i].list, &wrapper_skbbuf_list);
-#ifdef CONFIG_TRACE_SKB
-		set_skb_list_flag(&skb_pool[i].skb, SKBLIST_POOL);
-#endif
-	}
-	skbbuf_used_num = 0;
-	max_skbbuf_used_num = 0;
-
-}
-
-_WEAK void init_skb_data_pool(void)
-{
-	int i;
-
-	memset(skb_data_pool, '\0', max_skb_buf_num * sizeof(struct skb_data));
-	INIT_LIST_HEAD(&skbdata_list);
-
-	for (i = 0; i < max_skb_buf_num; i++) {
-		INIT_LIST_HEAD(&skb_data_pool[i].list);
-		list_add_tail(&skb_data_pool[i].list, &skbdata_list);
-	}
-	skbdata_used_num = 0;
-	max_skbdata_used_num = 0;
-}
-
-_WEAK void deinit_skb_data_pool(void)
-{
-}
-
-struct sk_buff *alloc_skb(int size)
-{
-	struct sk_buff *skb;
-	unsigned char *data;
-
-	if (size + HAL_INTERFACE_CMD_STATUS_LEN > MAX_SKB_BUF_SIZE) {
-		DBG_TRACE("no enough room(max.%d) for desired packet(%d)", MAX_SKB_BUF_SIZE, size + HAL_INTERFACE_CMD_STATUS_LEN);
-	}
-
-	unsigned int irq_flags = save_and_cli();
-	skb = (struct sk_buff *)get_buf_from_poll(&wrapper_skbbuf_list, &skbbuf_used_num);
-	restore_flags(irq_flags);
-
-	if (skb == NULL) {
-#ifdef CONFIG_TRACE_SKB
-		DBG_ERR("Wait for skbbuf, skbbuf:%d, skbdata:%d\r\n", skbbuf_used_num, skbdata_used_num);
-		show_skb();
-#else
-		DBG_ERR("Wait for skbbuf");
-#endif
-		return NULL;
-	}
-
-#ifdef CONFIG_TRACE_SKB
-	memset(skb, '\0', (unsigned int) & ((struct sk_buff *)0)->liston[0]);
-#else
-	memset(skb, '\0', sizeof(*skb));
-#endif
-
-	if (size + GSPI_STATUS_LEN > MAX_SKB_BUF_SIZE) {
-		data = rtw_zmalloc(size + GSPI_STATUS_LEN);
-	} else {
-		unsigned int irq_flags2 = save_and_cli();
-		data = (unsigned char *) get_buf_from_poll(&skbdata_list, &skbdata_used_num);
-		restore_flags(irq_flags2);
-	}
-
-	if (data == NULL) {
-#ifdef CONFIG_TRACE_SKB
-		DBG_ERR("Wait for skbdata, skbbuf:%d, skbdata:%d\r\n", skbbuf_used_num, skbdata_used_num);
-		show_skb();
-#else
-		DBG_ERR("Wait for skbdata\n");
-#endif
-		unsigned int irq_flags3 = save_and_cli();
-		release_buf_to_poll((unsigned char *)skb, &wrapper_skbbuf_list, &skbbuf_used_num);
-		restore_flags(irq_flags3);
-		return NULL;
-	}
-
-	if (size + GSPI_STATUS_LEN > MAX_SKB_BUF_SIZE) {
-		skb->dyalloc_flag = 1;
-	} else {
-		skb->dyalloc_flag = 0;
-	}
-
-	if (skbbuf_used_num > max_skbbuf_used_num) {
-		max_skbbuf_used_num = skbbuf_used_num;
-	}
-
-	if (skbdata_used_num > max_skbdata_used_num) {
-		max_skbdata_used_num = skbdata_used_num;
-	}
-
-#ifdef CONFIG_TRACE_SKB
-	clear_skb_list_flag(skb, SKBLIST_POOL);
-#endif
-
-	size = SKB_DATA_ALIGN(size);
-#ifndef CONFIG_HIGH_TP
-	skb_assign_buf(skb, (unsigned char *)data, size);
-#else
-	skb_assign_buf(skb, (unsigned char *)data, MAX_SKB_BUF_SIZE - HAL_INTERFACE_CMD_STATUS_LEN);
-#endif
-
-	atomic_set(&LIST_CONTAINOR(skb->head, struct skb_data, buf)->ref, 1);
-
-	return skb;
-}
-
-struct sk_buff *dev_alloc_skb(unsigned int length, unsigned int reserve_len)
-{
-	struct sk_buff *skb;
-
-	skb = alloc_skb(length + SKB_DATA_ALIGN(reserve_len));
-
-
-
-	if (skb) {
-		skb_reserve(skb, SKB_DATA_ALIGN(reserve_len));
-	}
-
-	return skb;
-}
-
-void kfree_skb(struct sk_buff *skb)
-{
-	unsigned int irq_flags = save_and_cli();
-#ifdef CONFIG_AS_INIC_NP
-	if (skb->busy) {
-		skb->busy = 0;
-		struct skb_buf *skb_buf = container_of(skb, struct skb_buf, skb);
-		DCache_Clean((u32)skb_buf, sizeof(struct skb_buf));
-	}
-	if (skb->no_free) {
-		restore_flags();
-		return;
-	}
-#endif
-	if (skb->dyalloc_flag == 1) {
-		skb->dyalloc_flag = 0;
-		rtw_free(skb->head);
-	} else {
-		if (ATOMIC_DEC_AND_TEST(&LIST_CONTAINOR(skb->head, struct skb_data, buf)->ref)) {
-			release_buf_to_poll(skb->head, &skbdata_list, &skbdata_used_num);
-		}
-	}
-	release_buf_to_poll((unsigned char *)skb, &wrapper_skbbuf_list, &skbbuf_used_num);
-
-	restore_flags(irq_flags);
-}
-
-void kfree_skb_chk_key(struct sk_buff *skb, struct net_device *root_dev)
-{
-	/* To avoid gcc warnings */
-	(void) root_dev;
-
-	kfree_skb(skb);
-}
-
-#ifdef CONFIG_TRACE_SKB
-int _set_skb_list_flag(struct sk_buff *skb, unsigned int queueflag)
-{
-	if (skb) {
-		unsigned int liston = skb->liston[skb->list_idx];
-		save_and_cli();
-		if (++skb->list_idx >= TRACE_SKB_DEPTH) {
-			skb->list_idx = 0;
-		}
-		skb->liston[skb->list_idx] = liston | queueflag;
-		//skb->liston[++skb->list_idx >= TRACE_SKB_DEPTH ? 0 : skb->list_idx] = skb->liston[skb->list_idx] | queueflag;
-		//skb->list_idx = skb->list_idx >= TRACE_SKB_DEPTH ? 0 : skb->list_idx;
-		restore_flags();
-
-		//do{ // for break point setting
-		//	int idx = skb->list_idx;
-		//
-		//	if(!(skb->liston[idx] & SKBLIST_POOL) &&
-		//		(skb->liston[idx] & 0x7FFFFFFF))
-		//	{
-		//		idx = --idx < 0 ? TRACE_SKB_DEPTH-1 : idx;
-		//		if(!(skb->liston[idx] & 0x7FFFFFFF) &&
-		//			((skb->liston[idx] & SKBLIST_POOL)))
-		//			break;
-		//	}
-		//}while(0);
-		return skb->list_idx;
-	}
-
-	return -1;
-}
-
-int _clear_skb_list_flag(struct sk_buff *skb, unsigned int queueflag)
-{
-	if (skb) {
-		unsigned int liston = skb->liston[skb->list_idx];
-		save_and_cli();
-		if (++skb->list_idx >= TRACE_SKB_DEPTH) {
-			skb->list_idx = 0;
-		}
-		skb->liston[skb->list_idx] = liston & ~queueflag;
-		//skb->liston[++skb->list_idx >= TRACE_SKB_DEPTH ? 0 : skb->list_idx] = skb->liston[skb->list_idx] & ~queueflag;
-		//skb->list_idx = skb->list_idx >= TRACE_SKB_DEPTH ? 0 : skb->list_idx;
-		restore_flags();
-
-		//do{ // for break point setting
-		//	int idx = skb->list_idx;
-		//
-		//	if(!(skb->liston[idx] & SKBLIST_POOL) &&
-		//		(skb->liston[idx] & 0x7FFFFFFF))
-		//	{
-		//		idx = --idx < 0 ? TRACE_SKB_DEPTH-1 : idx;
-		//		if(!(skb->liston[idx] & 0x7FFFFFFF) &&
-		//			((skb->liston[idx] & SKBLIST_POOL)))
-		//			break;
-		//	}
-		//
-		//	if(skb->liston[idx] == 0)
-		//	{
-		//		idx = --idx < 0 ? TRACE_SKB_DEPTH-1 : idx;
-		//		if(skb->liston[idx] == 0){
-		//			idx = --idx < 0 ? TRACE_SKB_DEPTH-1 : idx;
-		//			if(skb->liston[idx] == 0x00410000)
-		//				break;
-		//		}
-		//	}
-		//}while(0);
-		return skb->list_idx;
-	}
-
-	return -1;
-}
-
-static int liston_copy[MAX_LOCAL_SKB_NUM][TRACE_SKB_DEPTH];
-static const char *funcname_copy[MAX_LOCAL_SKB_NUM][TRACE_SKB_DEPTH];
-static char *liston_string[] = {
-	"TRANSIENT",
-
-	"RECVBUF",
-	"RECVBUF_FREEQUEUE",
-	"RECVBUF_PENDINGQUEUE",
-	NULL,
-
-	"RECVFRAME",
-	"RECVFRAME_FREEQUEUE",
-	"RECVFRAME_SWDECQUEUE",
-	"RECVFRAME_REORDERQUEUE",
-
-	"XMITBUF",
-	"XMITEXTBUF",
-	"XMITBUF_FREEQUEUE",
-	"XMITEXTBUF_FREEQUEUE",
-	"XMITBUF_PENDINGQUEUE",
-	"XMITBUF_PENDING0QUEUE",
-	"XMITBUF_PENDING1QUEUE",
-	"XMITBUF_PENDING2QUEUE",
-
-	"XMITFRAME",
-	"XMITFRAME_FREEQUEUE",
-	"XMITFRAME_SLEEPQUEUE",
-	NULL,
-	"XMITFRAME_VOQUEUE",
-	"XMITFRAME_VIQUEUE",
-	"XMITFRAME_BEQUEUE",
-	"XMITFRAME_BKQUEUE",
-	"XMITFRAME_BMQUEUE",
-	NULL,
-	NULL,
-	NULL,
-
-	"POOL",
-	NULL,
-	NULL,
-	NULL
-};
-
-int liston_string_getidx(int flag)
-{
-	int i, idx = -1;
-
-	for (i = 0; i < 32; i++) {
-		if (((flag >> i) & 0x1)) {
-			idx = i;
-		}
-	}
-
-	return idx == -1 ? 0 : idx + 1;
-}
-
-
-void snapshot_skb(void)
-{
-	int i, j, idx;
-
-	for (i = 0; i < MAX_LOCAL_SKB_NUM; i++) {
-		idx = skb_pool[i].skb.list_idx;
-		for (j = 0; j < TRACE_SKB_DEPTH; j++) {
-			liston_copy[i][j] = skb_pool[i].skb.liston[idx];
-			funcname_copy[i][j] = skb_pool[i].skb.funcname[idx--];
-			idx = idx < 0 ? TRACE_SKB_DEPTH - 1 : idx;
-		}
-	}
-}
-
-void show_skb(void)
-{
-	int i, j, idx;
-
-	printk("\n\n\rskbbuf_used_num:%d, skbdata_used_num:%d\r\n", skbbuf_used_num, skbdata_used_num);
-	for (i = 0; i < MAX_LOCAL_SKB_NUM; i++) {
-		printk("skbbuf[%d] is on list:", i);
-		for (j = 0; j < TRACE_SKB_DEPTH; j++) {
-			//printk(" %08x <-", liston_copy[i][j]);
-			idx = liston_string_getidx(liston_copy[i][j]);
-			if (idx == 0) {
-				continue;
-			}
-			if (liston_string[idx]) {
-				printk(" %s <-", liston_string[idx]);
-			} else {
-				printk(" oops!!!");
-			}
-		}
-		printk(" ...\r\n");
-		printk("skbbuf[%d] go through:", i);
-		for (j = 0; j < TRACE_SKB_DEPTH; j++) {
-			if (funcname_copy[i][j] > (const char *)0x08000000) {
-				printk(" %s <-", (char *)funcname_copy[i][j]);
-			} else {
-				printk(" * <-");
-			}
-		}
-		printk(" ...\r\n");
-	}
-}
-void dump_skb_list(void)
-{
-	int i, j, idx;
-
-	save_and_cli();
-	snapshot_skb();
-	restore_flags();
-
-	show_skb();
-}
-
-#endif //CONFIG_TRACE_SKB
-
-/**
- *	skb_put - add data to a buffer
- *	@skb: buffer to use
- *	@len: amount of data to add
- *
- *	This function extends the used data area of the buffer. If this would
- *	exceed the total buffer size the kernel will panic. A pointer to the
- *	first byte of the extra data is returned.
- */
-
-unsigned char *skb_put(struct sk_buff *skb, unsigned int len)
-{
-	unsigned char *tmp = skb->tail;
-	skb->tail += len;
-	skb->len += len;
-	if (skb->tail > skb->end) {
-		ASSERT(0);
-	}
-
-	return tmp;
-}
-
-static __inline__ unsigned char *__skb_pull(struct sk_buff *skb, unsigned int len)
-{
-	skb->len -= len;
-	skb->data = (unsigned char *)(((unsigned int)skb->data) + len);
-
-	return skb->data;
-}
-
-static __inline__ unsigned char *__skb_push(struct sk_buff *skb, unsigned int len)
-{
-	skb->len += len;
-	skb->data = (unsigned char *)(((unsigned int)skb->data) - len);
-
-	return skb->data;
-}
-
-/**
- *	skb_reserve - adjust headroom
- *	@skb: buffer to alter
- *	@len: bytes to move
- *
- *	Increase the headroom of an empty &sk_buff by reducing the tail
- *	room. This is only allowed for an empty buffer.
- */
-
-void skb_reserve(struct sk_buff *skb, unsigned int len)
-{
-	skb->data += len;
-	skb->tail += len;
-}
-
-#if 0
-static __inline__ void skb_queue_head_init(struct sk_buff_head *list)
-{
-	list->prev = (struct list_head *)list;
-	list->next = (struct list_head *)list;
-	list->qlen = 0;
-}
-
-/**
- *      __skb_queue_tail - queue a buffer at the list tail
- *      @list: list to use
- *      @newsk: buffer to queue
- *
- *      Queue a buffer at the end of a list. This function takes no locks
- *      and you must therefore hold required locks before calling it.
- *
- *      A buffer cannot be placed on two lists at the same time.
- */
-
-static __inline__ void __skb_queue_tail(struct sk_buff_head *list, struct sk_buff *newsk)
-{
-	struct sk_buff *prev, *next;
-
-	newsk->list = list;
-	list->qlen++;
-	next = (struct sk_buff *)list;
-	prev = next->prev;
-	newsk->next = next;
-	newsk->prev = prev;
-	next->prev = newsk;
-	prev->next = newsk;
-}
-
-/**
- *      skb_queue_tail - queue a buffer at the list tail
- *      @list: list to use
- *      @newsk: buffer to queue
- *
- *      Queue a buffer at the tail of the list. This function takes the
- *      list lock and can be used safely with other locking &sk_buff functions
- *      safely.
- *
- *      A buffer cannot be placed on two lists at the same time.
- */
-
-static __inline__ void skb_queue_tail(struct sk_buff_head *list, struct sk_buff *newsk)
-{
-	save_and_cli();
-	__skb_queue_tail(list, newsk);
-	restore_flags();
-}
-#endif
-
-void skb_assign_buf(struct sk_buff *skb, unsigned char *buf, unsigned int len)
-{
-	skb->head = buf;
-	skb->data = buf;
-	skb->tail = buf;
-	skb->end = buf + len;
-}
-
-unsigned char *skb_tail_pointer(const struct sk_buff *skb)
-{
-	return skb->tail;
-}
-#if 0
-static __inline__ void skb_reset_tail_pointer(struct sk_buff *skb)
-{
-	skb->tail = skb->data;
-}
-#endif
-
-unsigned char *skb_end_pointer(const struct sk_buff *skb)
-{
-	return skb->end;
-}
-
-void skb_set_tail_pointer(struct sk_buff *skb, const int offset)
-{
-	skb->tail = skb->data + offset;
-}
-
-unsigned char *skb_pull(struct sk_buff *skb, unsigned int len)
-{
-	if (len > skb->len) {
-		return NULL;
-	}
-
-	return __skb_pull(skb, len);
-}
-
-unsigned char *skb_push(struct sk_buff *skb, unsigned int len)
-{
-	if ((skb->data - len) < skb->head) {
-		return NULL;
-	}
-	return __skb_push(skb, len);
-}
-
-struct sk_buff *skb_copy(const struct sk_buff *skb, int gfp_mask, unsigned int reserve_len)
-{
-	/* To avoid gcc warnings */
-	(void) gfp_mask;
-
-	struct sk_buff *copy;
-
-	/*
-	 * Allocate the copy buffer
-	 */
-	copy = dev_alloc_skb(skb->len, reserve_len);
-
-	if (copy == NULL) {
-		return NULL;
-	}
-
-	/* Set the tail pointer and length */
-	skb_put(copy, skb->len);
-	memcpy(copy->data, skb->data, skb->len);
-
-	copy->dev = skb->dev;
-
-	return copy;
-}
-
-/**
- *      skb_clone       -       duplicate an sk_buff
- *      @skb: buffer to clone
- *      @gfp_mask: allocation priority
- *
- *      Duplicate an &sk_buff. The new one is not owned by a socket. Both
- *      copies share the same packet data but not structure. The new
- *      buffer has a reference count of 1. If the allocation fails the
- *      function returns %NULL otherwise the new buffer is returned.
- *
- *      If this function is called from an interrupt gfp_mask() must be
- *      %GFP_ATOMIC.
- */
-
-#define C(x) clone->x = skb->x
-
-struct sk_buff *skb_clone(struct sk_buff *skb, int gfp_mask)
-{
-	/* To avoid gcc warnings */
-	(void) gfp_mask;
-
-	struct sk_buff *clone;
-
-	unsigned int irq_flags = save_and_cli();
-	clone = (struct sk_buff *)get_buf_from_poll(&wrapper_skbbuf_list, &skbbuf_used_num);
-	restore_flags(irq_flags);
-
-	if (clone == NULL) {
-		DBG_ERR("Wait to clone skbbuf");
-		return NULL;
-	}
-
-#ifdef CONFIG_TRACE_SKB
-	clear_skb_list_flag(clone, SKBLIST_POOL);
-#endif
-
-#ifdef CONFIG_TRACE_SKB
-	memset(clone, '\0', (unsigned int) & ((struct sk_buff *)0)->liston[0]);
-#else
-	memset(clone, '\0', sizeof(*clone));
-#endif
-
-	ATOMIC_INC(&LIST_CONTAINOR(skb->head, struct skb_data, buf)->ref);
-
-	C(dev);
-	C(len);
-	C(head);
-	C(data);
-	C(tail);
-	C(end);
-
-	return clone;
-}
-
-#ifndef __LIST_H
-#warning "DLIST_NOT_DEFINE!!!!!!"
-//----- ------------------------------------------------------------------
-// Linled List
-//----- ------------------------------------------------------------------
-void list_add(struct list_head *new, struct list_head *head)
-{
-	__list_add(new, head, head->next);
-}
-
-void list_add_tail(struct list_head *new, struct list_head *head)
-{
-	__list_add(new, head->prev, head);
-}
-#endif
diff --git a/os/board/rtl8720e/src/component/wifi/driver/src/osdep/freertos/freertos_skbuff.h b/os/board/rtl8720e/src/component/wifi/driver/src/osdep/freertos/freertos_skbuff.h
deleted file mode 100644
index 189391372..000000000
--- a/os/board/rtl8720e/src/component/wifi/driver/src/osdep/freertos/freertos_skbuff.h
+++ /dev/null
@@ -1,96 +0,0 @@
-#ifndef _FREERTOS_SKBUFF_H_
-#define _FREERTOS_SKBUFF_H_
-
-#if (RTL8735B_SUPPORT == 1)
-// For Lextra(PCI-E like interface), RX buffer along with its skb is required to be
-// 	pre-allocation and set into rx buffer descriptor ring during initialization.
-#if (SKB_PRE_ALLOCATE_RX==1)
-#define MAX_SKB_BUF_NUM			(8 + 4)		//tx+rx (8 + RX_Q_DESC_NUM) Reduce rx skb number due to memory limitation
-#define MAX_LOCAL_SKB_NUM		(10 + 18)	//tx+rx
-#else
-#if WIFI_LOGO_CERTIFICATION
-#define MAX_SKB_BUF_NUM		10             //tx+rx, ping 10k test
-#else
-#define MAX_SKB_BUF_NUM		24	//8              //tx+rx
-#endif
-#define MAX_LOCAL_SKB_NUM		(MAX_SKB_BUF_NUM + 2)	//tx+rx, +2: AP mode broadcast
-#endif
-#elif (RTL8721D_SUPPORT == 1)
-#if (SKB_PRE_ALLOCATE_RX==1)
-#ifdef CONFIG_HIGH_TP_TEST
-#define MAX_SKB_BUF_NUM			(28)		//tx+rx (8 + RX_Q_DESC_NUM) Reduce rx skb number due to memory limitation
-#else
-#define MAX_SKB_BUF_NUM			(8 + 4)		//tx+rx (8 + RX_Q_DESC_NUM) Reduce rx skb number due to memory limitation
-#endif
-#define MAX_LOCAL_SKB_NUM		(10 + 18)	//tx+rx
-#else
-#if WIFI_LOGO_CERTIFICATION
-#define MAX_SKB_BUF_NUM		10             //tx+rx, ping 10k test
-#else
-#define MAX_SKB_BUF_NUM		8              //tx+rx
-#endif
-#define MAX_LOCAL_SKB_NUM		(MAX_SKB_BUF_NUM + 2)	//tx+rx, +2: AP mode broadcast
-#endif
-
-#elif (RTL8721F_SUPPORT == 1)
-#if (SKB_PRE_ALLOCATE_RX==1)
-#if defined(CONFIG_HIGH_TP_TEST)
-#define MAX_SKB_BUF_NUM			(28)		//tx+rx (8 + RX_Q_DESC_NUM) Reduce rx skb number due to memory limitation
-#else
-#define MAX_SKB_BUF_NUM			(8 + 4)		//tx+rx (8 + RX_Q_DESC_NUM) Reduce rx skb number due to memory limitation
-#endif
-#define MAX_LOCAL_SKB_NUM		(10 + 18)	//tx+rx
-#else
-#if WIFI_LOGO_CERTIFICATION
-#define MAX_SKB_BUF_NUM		10             //tx+rx, ping 10k test
-#elif defined(CONFIG_AS_INIC_NP) //For iNIC throughput request
-#define MAX_SKB_BUF_NUM			10
-#else
-#define MAX_SKB_BUF_NUM		8              //tx+rx
-#endif
-#define MAX_LOCAL_SKB_NUM		(MAX_SKB_BUF_NUM + 2)	//tx+rx, +2: AP mode broadcast
-#endif
-
-#elif (RTL8730E_SUPPORT == 1)
-#if (SKB_PRE_ALLOCATE_RX==1)
-#if defined(CONFIG_HIGH_TP_TEST)
-#define MAX_SKB_BUF_NUM			(28)		//tx+rx (8 + RX_Q_DESC_NUM) Reduce rx skb number due to memory limitation
-#else
-#define MAX_SKB_BUF_NUM			(8 + 4)		//tx+rx (8 + RX_Q_DESC_NUM) Reduce rx skb number due to memory limitation
-#endif
-#define MAX_LOCAL_SKB_NUM		(10 + 18)	//tx+rx
-#else
-#if WIFI_LOGO_CERTIFICATION
-#define MAX_SKB_BUF_NUM		10             //tx+rx, ping 10k test
-#elif defined(CONFIG_HIGH_TP_TEST)
-#define MAX_SKB_BUF_NUM			10
-#else
-#define MAX_SKB_BUF_NUM		4              //tx+rx
-#endif
-#define MAX_LOCAL_SKB_NUM		(MAX_SKB_BUF_NUM + 2)	//tx+rx, +2: AP mode broadcast
-#endif
-
-#elif (RTL8720E_SUPPORT == 1)
-#if WIFI_LOGO_CERTIFICATION
-#define MAX_SKB_BUF_NUM		10             //tx+rx, ping 10k test
-#elif defined(CONFIG_HIGH_TP_TEST)
-#define MAX_SKB_BUF_NUM		10
-#else
-#define MAX_SKB_BUF_NUM		4              //tx+rx for single core, rx for inic NP
-#endif
-#define MAX_LOCAL_SKB_NUM		(MAX_SKB_BUF_NUM + 2)	//tx+rx, +2: AP mode broadcast
-
-#else
-#ifndef CONFIG_HIGH_TP
-#define MAX_LOCAL_SKB_NUM		10
-#define MAX_SKB_BUF_NUM			7
-#else
-#define MAX_LOCAL_SKB_NUM		100
-#define MAX_SKB_BUF_NUM			100
-#endif
-#endif
-
-extern int max_local_skb_num;
-extern int max_skb_buf_num;
-
-#endif
\ No newline at end of file
diff --git a/os/board/rtl8720e/src/component/wifi/driver/src/osdep/freertos/wrapper.h b/os/board/rtl8720e/src/component/wifi/driver/src/osdep/freertos/wrapper.h
deleted file mode 100644
index 73093ed44..000000000
--- a/os/board/rtl8720e/src/component/wifi/driver/src/osdep/freertos/wrapper.h
+++ /dev/null
@@ -1,441 +0,0 @@
-/******************************************************************************
- * Copyright (c) 2013-2016 Realtek Semiconductor Corp.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- ******************************************************************************
- *  Wrapper provide a linux-like interface
- ************************************************************************/
-#ifndef __WRAPPER_H__
-#define __WRAPPER_H__
-
-//----- ------------------------------------------------------------------
-// Include Files
-//----- ------------------------------------------------------------------
-#include <stdio.h>
-#include <string.h>
-#include "wireless.h"
-#include <skbuff.h>
-#include "osdep_service.h"
-
-#ifndef __LIST_H
-#warning "DLIST_NOT_DEFINE!!!!!!"
-//----- ------------------------------------------------------------------
-// Linled List
-//----- ------------------------------------------------------------------
-/*
- * Simple doubly linked list implementation.
- *
- * Some of the internal functions ("__xxx") are useful when
- * manipulating whole lists rather than single entries, as
- * sometimes we already know the next/prev entries and we can
- * generate better code by using them directly rather than
- * using the generic single-entry routines.
- */
-// struct list_head {
-// 	struct list_head *next, *prev;
-// };
-
-#define LIST_HEAD_INIT(name) { &(name), &(name) }
-
-#define INIT_LIST_HEAD(ptr) do { \
-	(ptr)->next = (ptr); (ptr)->prev = (ptr); \
-} while (0)
-
-/*
- * Insert a new entry between two known consecutive entries.
- *
- * This is only for internal list manipulation where we know
- * the prev/next entries already!
- */
-static __inline void __list_add(struct list_head *new,
-								struct list_head *prev,
-								struct list_head *next)
-{
-	next->prev = new;
-	new->next = next;
-	new->prev = prev;
-	prev->next = new;
-}
-
-/*
- * Delete a list entry by making the prev/next entries
- * point to each other.
- *
- * This is only for internal list manipulation where we know
- * the prev/next entries already!
- */
-static __inline void __list_del(struct list_head *prev,
-								struct list_head *next)
-{
-	next->prev = prev;
-	prev->next = next;
-}
-
-/**
- * list_del - deletes entry from list.
- * @entry: the element to delete from the list.
- * Note: list_empty on entry does not return true after this, the entry is in an undefined state.
- */
-static __inline void list_del(struct list_head *entry)
-{
-	__list_del(entry->prev, entry->next);
-}
-
-/**
- * list_del_init - deletes entry from list and reinitialize it.
- * @entry: the element to delete from the list.
- */
-static __inline void list_del_init(struct list_head *entry)
-{
-	__list_del(entry->prev, entry->next);
-	INIT_LIST_HEAD(entry);
-}
-
-/**
- * list_empty - tests whether a list is empty
- * @head: the list to test.
- */
-static __inline int list_empty(struct list_head *head)
-{
-	return head->next == head;
-}
-
-/**
- * list_splice - join two lists
- * @list: the new list to add.
- * @head: the place to add it in the first list.
- */
-static __inline void list_splice(struct list_head *list, struct list_head *head)
-{
-	struct list_head *first = list->next;
-
-	if (first != list) {
-		struct list_head *last = list->prev;
-		struct list_head *at = head->next;
-
-		first->prev = head;
-		head->next = first;
-
-		last->next = at;
-		at->prev = last;
-	}
-}
-
-void list_add(struct list_head *new, struct list_head *head);
-void list_add_tail(struct list_head *new, struct list_head *head);
-#endif
-
-#if defined(CONFIG_PLATFORM_TIZENRT_OS)
-extern unsigned int save_and_cli(void);
-extern void restore_flags(unsigned int flag);
-#else
-extern void save_and_cli(void);
-extern void restore_flags(void);
-#endif
-//----- ------------------------------------------------------------------
-// SKB Operation
-//----- ------------------------------------------------------------------
-
-#define SMP_CACHE_BYTES		4
-#define SKB_DATA_ALIGN(X)	(((X) + (SMP_CACHE_BYTES - 1)) & ~(SMP_CACHE_BYTES - 1))
-
-// Consideration for SKB size
-//	Tx: [INTF_CMD][TX_DESC][WLAN_HDR][QoS][IV][SNAP][Data][MIC][ICV][INTF_STATUS]
-//			Since SKB is used to accept ethernet packet from upper layer, SKB length of WLAN_MAX_ETHFRM_LEN
-//			(= 1514) is enough. But since SKB is also used to get spi receive packet, overall buffer space
-//			should be taken into consideration.
-//	RX: [INTF_CMD][RX_DESC][Drv_Info][WLAN_HDR][QoS][IV][SNAP][Data][MIC][ICV][CRC][INTF_STATUS]
-//
-//	32: Driver_Info that carry phy related information for each packets. Required only for receive case.
-//	WLAN_MAX_ETHFRM_LEN : May not be required because WLAN_HEADER +SNAP can totally
-//			cover ethernet header. Keep in only for safety.
-//
-//     **Notes** SDIO requires 512 blocks r/w, so 512*4 = 2048 is required.
-//	2003/12/26. The value is reduced from 2048 to 1658 for GSPI
-//	2014/02/05. The value is 1650 for 8195A LX_BUS
-#define SKB_RESERVED_FOR_SAFETY	8//0
-
-#define SKB_WLAN_TX_EXTRA_LEN	(TXDESC_SIZE + WLAN_HDR_A4_QOS_LEN + WLAN_MAX_IV_LEN + WLAN_SNAP_HEADER - WLAN_ETHHDR_LEN)
-
-#define RX_DRIVER_INFO				32
-
-#if defined(CONFIG_LX_HCI) || defined(CONFIG_AXI_HCI)
-#define HAL_INTERFACE_OVERHEAD_SKB_DATA 0
-#endif
-
-#if defined(CONFIG_LX_HCI) || defined(CONFIG_AXI_HCI)
-#if defined(CONFIG_MP_INCLUDED)
-#define MAX_RX_PKT_LIMIT			((WLAN_MAX_PROTOCOL_OVERHEAD + WLAN_MAX_ETHFRM_LEN + 511) / 512) // 4, for lxbus
-#define MAX_RX_PKT_SIZE					MAX_RX_PKT_LIMIT*512	// MAX_SKB_BUF_SIZE = 0+32+40+512*4+0 = 2120
-#else
-// CONFIG_INIC_IPC_HIGH_TP : MAX_RX_PKT_SIZE = 64+1904(1890+14) = 1968
-#define MAX_RX_PKT_SIZE				WLAN_MAX_PROTOCOL_OVERHEAD + WLAN_MAX_ETHFRM_LEN	// MAX_RX_PKT_SIZE = 64+1514 = 1578
-#define MAX_RX_PKT_LIMIT				((MAX_RX_PKT_SIZE + 511) / 512)			// ((1578 + 512)  / 512) = 4
-#endif
-#define MAX_SKB_BUF_SIZE			(HAL_INTERFACE_OVERHEAD_SKB_DATA+RX_DRIVER_INFO+\
-												((TXDESC_SIZE>RXDESC_SIZE)? TXDESC_SIZE:RXDESC_SIZE) +\
-												MAX_RX_PKT_SIZE +\
-												SKB_RESERVED_FOR_SAFETY)	// 0+32+40+1578+8 = 1658
-
-#else
-#define MAX_SKB_BUF_SIZE	2048
-#endif
-
-#if 0
-struct  sk_buff_head {
-	struct list_head	*next, *prev;
-	uint32_t			qlen;
-};
-
-struct sk_buff {
-	/* These two members must be first. */
-	struct sk_buff		*next;		/* Next buffer in list */
-	struct sk_buff		*prev;		/* Previous buffer in list */
-
-	struct sk_buff_head	*list;		/* List we are on */
-	unsigned char		*head;		/* Head of buffer */
-	unsigned char		*data;		/* Data head pointer */
-	unsigned char		*tail;		/* Tail pointer	*/
-	unsigned char		*end;		/* End pointer */
-	struct net_device 	*dev;		/* Device we arrived on/are leaving by */
-	unsigned int 		len;		/* Length of actual data */
-};
-
-/**
- *	skb_put - add data to a buffer
- *	@skb: buffer to use
- *	@len: amount of data to add
- *
- *	This function extends the used data area of the buffer. If this would
- *	exceed the total buffer size the kernel will panic. A pointer to the
- *	first byte of the extra data is returned.
- */
-
-static __inline__ unsigned char *skb_put(struct sk_buff *skb, unsigned int len)
-{
-	unsigned char *tmp = skb->tail;
-	skb->tail += len;
-	skb->len += len;
-	if (skb->tail > skb->end) {
-		ASSERT(0);
-	}
-
-	return tmp;
-}
-
-static __inline__ unsigned char *__skb_pull(struct sk_buff *skb, unsigned int len)
-{
-	skb->len -= len;
-	skb->data = (unsigned char *)(((unsigned int)skb->data) + len);
-
-	return skb->data;
-}
-
-/**
- *	skb_reserve - adjust headroom
- *	@skb: buffer to alter
- *	@len: bytes to move
- *
- *	Increase the headroom of an empty &sk_buff by reducing the tail
- *	room. This is only allowed for an empty buffer.
- */
-
-static __inline__ void skb_reserve(struct sk_buff *skb, unsigned int len)
-{
-	skb->data += len;
-	skb->tail += len;
-}
-
-static __inline__ void skb_queue_head_init(struct sk_buff_head *list)
-{
-	list->prev = (struct list_head *)list;
-	list->next = (struct list_head *)list;
-	list->qlen = 0;
-}
-
-/**
- *      __skb_queue_tail - queue a buffer at the list tail
- *      @list: list to use
- *      @newsk: buffer to queue
- *
- *      Queue a buffer at the end of a list. This function takes no locks
- *      and you must therefore hold required locks before calling it.
- *
- *      A buffer cannot be placed on two lists at the same time.
- */
-
-static __inline__ void __skb_queue_tail(struct sk_buff_head *list, struct sk_buff *newsk)
-{
-	struct sk_buff *prev, *next;
-
-	newsk->list = list;
-	list->qlen++;
-	next = (struct sk_buff *)list;
-	prev = next->prev;
-	newsk->next = next;
-	newsk->prev = prev;
-	next->prev = newsk;
-	prev->next = newsk;
-}
-
-/**
- *      skb_queue_tail - queue a buffer at the list tail
- *      @list: list to use
- *      @newsk: buffer to queue
- *
- *      Queue a buffer at the tail of the list. This function takes the
- *      list lock and can be used safely with other locking &sk_buff functions
- *      safely.
- *
- *      A buffer cannot be placed on two lists at the same time.
- */
-
-static __inline__ void skb_queue_tail(struct sk_buff_head *list, struct sk_buff *newsk)
-{
-	save_and_cli();
-	__skb_queue_tail(list, newsk);
-	restore_flags();
-}
-
-static __inline__ void skb_assign_buf(struct sk_buff *skb, unsigned char *buf, unsigned int len)
-{
-	skb->head = buf;
-	skb->data = buf;
-	skb->tail = buf;
-	skb->end = buf + len;
-}
-
-static __inline__ unsigned char *skb_tail_pointer(const struct sk_buff *skb)
-{
-	return skb->tail;
-}
-
-static __inline__ void skb_reset_tail_pointer(struct sk_buff *skb)
-{
-	skb->tail = skb->data;
-}
-
-static __inline__ void skb_set_tail_pointer(struct sk_buff *skb, const int offset)
-{
-	skb->tail = skb->data + offset;
-}
-
-static __inline__ unsigned char *skb_end_pointer(const struct sk_buff *skb)
-{
-	return skb->end;
-}
-#endif
-/*
- *	External functions
- */
-struct net_device;
-
-extern void kfree_skb_chk_key(struct sk_buff *skb, struct net_device *root_dev);
-
-#define dev_kfree_skb_any(skb)	kfree_skb_chk_key(skb, skb->dev)
-
-extern struct sk_buff *dev_alloc_skb(unsigned int length, unsigned int reserve_len);
-extern struct sk_buff *skb_clone(struct sk_buff *skb, int gfp_mask);
-extern struct sk_buff *skb_copy(const struct sk_buff *skb, int gfp_mask, unsigned int reserve_len);
-extern unsigned char *skb_pull(struct sk_buff *skb, unsigned int len);
-
-//----- ------------------------------------------------------------------
-// Device structure
-//----- ------------------------------------------------------------------
-
-struct signal_stat {
-	u8	update_req;		//used to indicate
-	u8	avg_val;		//avg of valid elements
-	u8	latest_val;		//latest valid elements
-	u32	total_num;		//num of valid elements
-	u32	total_val;		//sum of valid elements
-};
-
-struct net_device_stats {
-
-	unsigned long	rx_packets;				/*!< total packets received       */
-	unsigned long	tx_packets;				/*!<total packets transmitted    */
-	unsigned long	rx_dropped;				/*!< no space in buffers    */
-	unsigned long	tx_dropped;				/*!< no space available  */
-	unsigned long	rx_bytes;				/*!< total bytes received         */
-	unsigned long	tx_bytes;				/*!< total bytes transmitted      */
-	unsigned long	rx_overflow;			/*!< rx fifo overflow count       */
-
-	u64		last_tx_bytes;
-	u64		last_tx_pkts;
-	u64		last_rx_bytes;
-	u16		rx_reorder_drop_cnt;
-	u16		rx_reorder_timeout_cnt;
-	_timer		signal_stat_timer;
-	u32		is_any_non_be_pkts;
-	struct signal_stat signal_qual_data;
-	struct signal_stat signal_strength_data;
-	struct signal_stat signal_snr_data;
-
-	/* For display the phy informatiom */
-	int RxSNRdB[2];
-	s8 rssi;
-	s8 snr;
-	u8 signal_strength;
-	u8 signal_qual;
-#if defined(CONFIG_RTL8735B)
-	u8 signal_strength_backup;
-#endif // defined(CONFIG_RTL8735B)
-};
-
-struct net_device {
-	void			*priv;		/* pointer to private data */
-	unsigned char		dev_addr[6];	/* set during bootup */
-	int	(*hard_start_xmit)(struct sk_buff *skb, struct net_device *dev);
-};
-
-typedef struct {
-	struct net_device	dev;		/* Binding wlan driver netdev */
-	void			*skb;		/* pending Rx packet */
-	unsigned int		tx_busy;
-	unsigned int		rx_busy;
-	unsigned char		enable;
-	unsigned char		mac[6];
-	_sema			netif_rx_sema;	/* prevent race condition on .skb in rltk_netif_rx() */
-} Rltk_wlan_t;
-
-extern Rltk_wlan_t rltk_wlan_info[NET_IF_NUM];
-
-#define netdev_priv(dev)		dev->priv
-#define rtw_is_netdev_enable(idx)	(rltk_wlan_info[idx].enable)
-#define rtw_get_netdev(idx)		(&(rltk_wlan_info[idx].dev))
-
-extern int netdev_open(struct net_device *pnetdev);
-extern int netdev_if2_open(struct net_device *pnetdev);
-
-//----- ------------------------------------------------------------------
-// Timer Operation
-//----- ------------------------------------------------------------------
-void init_timer(struct timer_list *timer);
-void mod_timer(struct timer_list *timer, uint32_t delay_time_ms);
-void  cancel_timer_ex(struct timer_list *timer);
-void del_timer_sync(struct timer_list *timer);
-void init_timer_wrapper(void);
-void deinit_timer_wrapper(void);
-
-void	rtw_init_timer(_timer *ptimer, void *adapter, TIMER_FUN pfunc, void *cntx, const char *name);
-void	rtw_set_timer(_timer *ptimer, uint32_t delay_time);
-uint8_t		rtw_cancel_timer(_timer *ptimer);
-void	rtw_del_timer(_timer *ptimer);
-void init_timer_pool(void);
-void deinit_timer_pool(void);
-
-#endif //__WRAPPER_H__
-
-
-
diff --git a/os/board/rtl8720e/src/component/wifi/driver/src/osdep/lwip_intf.c b/os/board/rtl8720e/src/component/wifi/driver/src/osdep/lwip_intf.c
deleted file mode 100644
index 331ec0a14..000000000
--- a/os/board/rtl8720e/src/component/wifi/driver/src/osdep/lwip_intf.c
+++ /dev/null
@@ -1,255 +0,0 @@
-/******************************************************************************
-  *
-  * This module is a confidential and proprietary property of RealTek and
-  * possession or use of this module requires written permission of RealTek.
-  *
-  * Copyright(c) 2016, Realtek Semiconductor Corporation. All rights reserved.
-  *
-******************************************************************************/
-
-//#define _LWIP_INTF_C_
-#include <autoconf.h>
-#include "ethernetif.h"
-#include <lwip_intf.h>
-#if !defined(CONFIG_MBED_ENABLED)
-#if defined(CONFIG_LWIP_LAYER) && CONFIG_LWIP_LAYER
-#include <lwip_netconf.h>
-#include "freertos/wrapper.h"
-#endif
-#endif
-#include <osdep_service.h>
-#include <wlan_intf.h>
-#ifdef WIFI_PERFORMANCE_MONITOR
-#include <wifi_performance_monitor.h>
-#else
-#define WIFI_MONITOR_TIMER_START(x)
-#define WIFI_MONITOR_TIMER_END(x, len)
-#endif
-
-#if defined(CONFIG_AS_INIC_NP)
-#include "inic_ipc_dev_trx.h"
-#include "inic_ipc_api.h"
-#endif
-
-/**
- *      rltk_wlan_set_netif_info - set netif hw address and register dev pointer to netif device
- *      @idx_wlan: netif index
- *			    0 for STA only or SoftAP only or STA in STA+SoftAP concurrent mode,
- *			    1 for SoftAP in STA+SoftAP concurrent mode
- *      @dev: register netdev pointer to LWIP. Reserved.
- *      @dev_addr: set netif hw address
- *
- *      Return Value: None
- */
-void rltk_wlan_set_netif_info(int idx_wlan, void *dev, unsigned char *dev_addr)
-{
-#if defined(CONFIG_LWIP_LAYER) && CONFIG_LWIP_LAYER
-#if defined(CONFIG_MBED_ENABLED)
-	//rtw_memcpy(xnetif[idx_wlan]->hwaddr, dev_addr, 6);
-	//set netif hwaddr later
-#else
-	LwIP_wlan_set_netif_info(idx_wlan, dev, dev_addr);
-#endif
-#else
-#if defined(CONFIG_AS_INIC_NP)
-	inic_ipc_dev_set_netif_info(idx_wlan, dev_addr);
-#endif
-#endif
-	(void)idx_wlan;
-	(void)dev;
-	(void)dev_addr;
-}
-
-/**
- *      rltk_wlan_send - send IP packets to WLAN. Called by low_level_output().
- *      @idx: netif index
- *      @sg_list: data buffer list
- *      @sg_len: size of each data buffer
- *      @total_len: total data len
- *
- *      Return Value: None
- */
-int rltk_wlan_send(int idx, struct eth_drv_sg *sg_list, int sg_len, int total_len)
-{
-#if defined(CONFIG_LWIP_LAYER) && CONFIG_LWIP_LAYER
-	struct eth_drv_sg *last_sg;
-	struct sk_buff *skb = NULL;
-	int ret = 0;
-
-	WIFI_MONITOR_TIMER_START(wlan_send_time);
-	if (idx == -1) {
-		DBG_ERR("netif is DOWN");
-		return -1;
-	}
-	DBG_TRACE("%s is called", __FUNCTION__);
-
-	save_and_cli();
-	if (rtw_is_netdev_enable(idx)) {
-		rltk_wlan_tx_inc(idx);
-	} else {
-		DBG_ERR("netif is DOWN");
-		restore_flags();
-		return -1;
-	}
-	restore_flags();
-
-	WIFI_MONITOR_TIMER_START(wlan_send_time1);
-	skb = rltk_wlan_alloc_skb(total_len);
-	WIFI_MONITOR_TIMER_END(wlan_send_time1, total_len);
-	if (skb == NULL) {
-		//DBG_ERR("rltk_wlan_alloc_skb() for data len=%d failed!", total_len);
-		ret = -1;
-		goto exit;
-	}
-	WIFI_MONITOR_TIMER_START(wlan_send_time2);
-	for (last_sg = &sg_list[sg_len]; sg_list < last_sg; ++sg_list) {
-		rtw_memcpy(skb->tail, (void *)(sg_list->buf), sg_list->len);
-		skb_put(skb,  sg_list->len);
-	}
-	WIFI_MONITOR_TIMER_END(wlan_send_time2, total_len);
-
-	WIFI_MONITOR_TIMER_START(wlan_send_skb_time);
-	wifi_send_skb(idx, skb);
-	WIFI_MONITOR_TIMER_END(wlan_send_skb_time, total_len);
-	WIFI_MONITOR_TIMER_END(wlan_send_time, total_len);
-
-exit:
-	save_and_cli();
-	rltk_wlan_tx_dec(idx);
-	restore_flags();
-	return ret;
-#else
-	(void)idx;
-	(void)sg_list;
-	(void)sg_len;
-	(void)total_len;
-#endif
-	return -1;
-}
-
-/**
- *      rltk_wlan_recv - indicate packets to LWIP. Called by ethernetif_recv().
- *      @idx: netif index
- *      @sg_list: data buffer list
- *      @sg_len: size of each data buffer
- *
- *      Return Value: None
- */
-void rltk_wlan_recv(int idx, struct eth_drv_sg *sg_list, int sg_len)
-{
-#if defined(CONFIG_LWIP_LAYER) && CONFIG_LWIP_LAYER
-	struct eth_drv_sg *last_sg;
-	struct sk_buff *skb;
-
-	DBG_TRACE("%s is called", __FUNCTION__);
-	if (idx == -1) {
-		DBG_ERR("skb is NULL");
-		return;
-	}
-	skb = rltk_wlan_get_recv_skb(idx);
-	DBG_ASSERT(skb, "No pending rx skb");
-
-	for (last_sg = &sg_list[sg_len]; sg_list < last_sg; ++sg_list) {
-		if (sg_list->buf != 0) {
-			rtw_memcpy((void *)(sg_list->buf), skb->data, sg_list->len);
-			skb_pull(skb, sg_list->len);
-		}
-	}
-#else
-	(void)idx;
-	(void)sg_list;
-	(void)sg_len;
-#endif
-}
-
-int netif_is_valid_IP(int idx, unsigned char *ip_dest)
-{
-#if defined(CONFIG_MBED_ENABLED)
-	return 1;
-#elif defined(CONFIG_LWIP_LAYER) && CONFIG_LWIP_LAYER
-	return LwIP_netif_is_valid_IP(idx, ip_dest);
-#elif defined(CONFIG_AS_INIC_NP)
-	return inic_ipc_get_lwip_info(IPC_WLAN_IS_VALID_IP, ip_dest, idx);
-#else
-	return 1;
-#endif
-}
-
-#if !defined(CONFIG_MBED_ENABLED)
-unsigned char *netif_get_hwaddr(int idx_wlan)
-{
-#if defined(CONFIG_LWIP_LAYER) && CONFIG_LWIP_LAYER
-	return LwIP_GetMAC(idx_wlan);
-#elif defined(CONFIG_AS_INIC_NP)
-	return (unsigned char *)inic_ipc_get_lwip_info(IPC_WLAN_GET_HW_ADDR, NULL, idx_wlan);
-#else
-	return NULL;
-#endif
-}
-#endif
-
-#if defined(CONFIG_MBED_ENABLED)
-emac_callback emac_callback_func = NULL;
-void *emac_callback_data = NULL;
-void set_callback_func(emac_callback p, void *data)
-{
-	emac_callback_func = p;
-	emac_callback_data = data;
-}
-#endif
-
-void netif_rx(int idx, unsigned int len)
-{
-	WIFI_MONITOR_TIMER_START(netif_rx_time);
-#if defined(CONFIG_LWIP_LAYER) && CONFIG_LWIP_LAYER
-#if defined(CONFIG_MBED_ENABLED)
-	emac_callback_func(emac_callback_data, NULL, len);
-#else
-	LwIP_ethernetif_recv(idx, len);
-#endif
-#endif
-
-
-#ifdef CONFIG_AS_INIC_NP
-	WIFI_MONITOR_TIMER_START(ethernetif_recv_time);
-	inic_ipc_dev_recv(idx);
-	WIFI_MONITOR_TIMER_END(ethernetif_recv_time, len);
-#endif
-	WIFI_MONITOR_TIMER_END(netif_rx_time, len);
-	(void)len;
-}
-
-#ifdef CONFIG_WOWLAN
-unsigned char *rltk_wlan_get_ip(int idx)
-{
-#if defined(CONFIG_LWIP_LAYER) && CONFIG_LWIP_LAYER
-	return LwIP_GetIP(idx);
-#elif defined(CONFIG_AS_INIC_NP)
-	return (unsigned char *)inic_ipc_get_lwip_info(IPC_WLAN_GET_IP, NULL, idx);
-#else
-	return NULL;
-#endif
-}
-unsigned char *rltk_wlan_get_gw(int idx)
-{
-#if defined(CONFIG_LWIP_LAYER) && CONFIG_LWIP_LAYER
-	return LwIP_GetGW(idx);
-#elif defined(CONFIG_AS_INIC_NP)
-	return (unsigned char *)inic_ipc_get_lwip_info(IPC_WLAN_GET_GW, NULL, idx);
-#else
-	return NULL;
-#endif
-}
-
-unsigned char *rltk_wlan_get_gwmask(int idx)
-{
-#if defined(CONFIG_LWIP_LAYER) && CONFIG_LWIP_LAYER
-	return LwIP_GetMASK(idx);
-#elif defined(CONFIG_AS_INIC_NP)
-	return (unsigned char *)inic_ipc_get_lwip_info(IPC_WLAN_GET_GWMSK, NULL, idx);
-#else
-	return NULL;
-#endif
-}
-#endif
-
diff --git a/os/board/rtl8720e/src/component/wifi/driver/src/osdep/net_stack_intf.h b/os/board/rtl8720e/src/component/wifi/driver/src/osdep/net_stack_intf.h
deleted file mode 100644
index 8fa741638..000000000
--- a/os/board/rtl8720e/src/component/wifi/driver/src/osdep/net_stack_intf.h
+++ /dev/null
@@ -1,69 +0,0 @@
-/* mbed Microcontroller Library
- * Copyright (c) 2013-2016 Realtek Semiconductor Corp.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-#ifndef __NET_STACK_INTF_H__
-#define __NET_STACK_INTF_H__
-
-#ifdef	__cplusplus
-extern "C" {
-#endif
-
-#include <wireless.h>
-#include <skbuff.h>
-
-struct netif;
-
-//----- ------------------------------------------------------------------
-// Ethernet Buffer
-//----- ------------------------------------------------------------------
-
-struct eth_drv_sg {
-	unsigned int	buf;
-	unsigned int 	len;
-};
-
-//----- ------------------------------------------------------------------
-// Wlan Interface Provided
-//----- ------------------------------------------------------------------
-void rltk_wlan_tx_inc(int idx);
-void rltk_wlan_tx_dec(int idx);
-struct sk_buff *rltk_wlan_get_recv_skb(int idx);
-struct sk_buff *rltk_wlan_alloc_skb(unsigned int total_len);
-void rltk_wlan_set_netif_info(int idx_wlan, void *dev, unsigned char *dev_addr);
-void wifi_send_skb(int idx, struct sk_buff *skb);	//struct sk_buff as defined above comment line
-int rltk_wlan_send(int idx, struct eth_drv_sg *sg_list, int sg_len, int total_len);
-void rltk_wlan_recv(int idx, struct eth_drv_sg *sg_list, int sg_len);
-
-//----- ------------------------------------------------------------------
-// Network Interface provided
-//----- ------------------------------------------------------------------
-
-int netif_is_valid_IP(int idx, unsigned char *ip_dest);
-int netif_get_idx(struct netif *pnetif);
-unsigned char *netif_get_hwaddr(int idx_wlan);
-void netif_rx(int idx, unsigned int len);
-#if (CONFIG_LWIP_LAYER == 1)
-extern void ethernetif_recv(struct netif *netif, int total_len);
-#endif //CONFIG_LWIP_LAYER == 1
-
-#ifdef CONFIG_WOWLAN
-extern unsigned char *rltk_wlan_get_ip(int idx);
-#endif
-
-#ifdef	__cplusplus
-}
-#endif
-
-#endif //#ifndef __NET_STACK_INTF_H__
diff --git a/os/board/rtl8720e/src/component/wifi/driver/src/osdep/netdev.h b/os/board/rtl8720e/src/component/wifi/driver/src/osdep/netdev.h
deleted file mode 100644
index 6ea1fdf4d..000000000
--- a/os/board/rtl8720e/src/component/wifi/driver/src/osdep/netdev.h
+++ /dev/null
@@ -1,86 +0,0 @@
-/******************************************************************************
- *
- * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of version 2 of the GNU General Public License as
- * published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
- * more details.
- *
- * You should have received a copy of the GNU General Public License along with
- * this program; if not, write to the Free Software Foundation, Inc.,
- * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
- *
- *
- ******************************************************************************/
-#ifndef __NETDEV_H_
-#define __NETDEV_H_
-
-/* Define compilor specific symbol */
-//
-// inline function
-//
-
-#if defined ( __ICCARM__ )
-#define __inline__                      inline
-#define __inline                        inline
-#define __inline_definition			//In dialect C99, inline means that a function's definition is provided 
-//only for inlining, and that there is another definition
-//(without inline) somewhere else in the program.
-//That means that this program is incomplete, because if
-//add isn't inlined (for example, when compiling without optimization),
-//then main will have an unresolved reference to that other definition.
-
-// Do not inline function is the function body is defined .c file and this
-// function will be called somewhere else, otherwise there is compile error
-#elif defined ( __CC_ARM   )
-#define __inline__			__inline	//__linine__ is not supported in keil compilor, use __inline instead
-#define inline				__inline
-#define __inline_definition			// for dialect C99
-#elif defined   (  __GNUC__  )
-#define __inline__                      inline
-#define __inline                        inline
-#define __inline_definition	inline
-#endif
-
-#include <stdio.h>
-#include <drv_conf.h>
-#include <osdep_service.h>
-
-
-// rtl8195a uses receive_tasklet for wps
-// 8189em uses interrupt_thread for wps
-#if defined(CONFIG_WPS)
-#define RECV_STACK_FOR_WPS 448//512//384 //Change to 512 for WPS (IAR STM32) stack overflow
-#else
-#define RECV_STACK_FOR_WPS 0
-#endif
-
-#if defined(CONFIG_PLATFORM_8721D) || defined(CONFIG_PLATFORM_AMEBAD2) || defined(CONFIG_PLATFORM_AMEBALITE) || defined(CONFIG_PLATFORM_AMEBADPLUS)
-#define LITTLE_STACKSIZE		256
-#else
-#define LITTLE_STACKSIZE		(512 + 256 + 128 + RECV_STACK_FOR_WPS)
-#endif // defined(CONFIG_PLATFORM_8721D) || defined(CONFIG_PLATFORM_AMEBAD2) || defined(CONFIG_PLATFORM_AMEBALITE)
-
-
-#define RECV_TASKLET_STACKSIZE	(1024 + RECV_STACK_FOR_WPS)
-
-#define DRIVER_RESUME_TASK_STACKSIZE 256
-
-#define rtw_netdev_priv(netdev) (netdev_priv(netdev))
-
-#define ADPT_FMT "wlan%d"
-#define ADPT_ARG(adapter) adapter->iface_type
-#define FUNC_NDEV_FMT "%s"
-#define FUNC_NDEV_ARG(ndev) __func__
-#define FUNC_ADPT_FMT "%s(%s)"
-#define FUNC_ADPT_ARG(adapter) __func__, adapter->iface_type
-
-#include "wifi_constants.h"
-#include "wifi_structures.h"
-int rtw_if_wifi_thread(char *name);
-#endif	//#ifndef __OSDEP_SERVICE_H_
diff --git a/os/board/rtl8720e/src/component/wifi/driver/src/osdep/osdep_intf.h b/os/board/rtl8720e/src/component/wifi/driver/src/osdep/osdep_intf.h
deleted file mode 100644
index b1cac59a4..000000000
--- a/os/board/rtl8720e/src/component/wifi/driver/src/osdep/osdep_intf.h
+++ /dev/null
@@ -1,44 +0,0 @@
-/******************************************************************************
- *
- * Copyright(c) 2007 - 2012 Realtek Corporation. All rights reserved.
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of version 2 of the GNU General Public License as
- * published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
- * more details.
- *
- * You should have received a copy of the GNU General Public License along with
- * this program; if not, write to the Free Software Foundation, Inc.,
- * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
- *
- *
- ******************************************************************************/
-
-#ifndef __OSDEP_INTF_H_
-#define __OSDEP_INTF_H_
-
-typedef	struct	net_device 	*_nic_hdl;
-
-struct pkt_buff {
-	_list list;
-	u32 len;
-	unsigned char *data;
-};
-
-#include "freertos/wrapper.h"
-#include "freertos/freertos_intfs.h"
-
-#ifdef CONFIG_CONCURRENT_MODE
-_adapter *rtw_drv_if2_init(_adapter *primary_padapter);
-void rtw_drv_if2_free(_adapter *pbuddy_padapter);
-#endif
-
-struct pkt_buff *rtw_alloc_pktbuf(unsigned int size);
-void rtw_free_pktbuf(struct pkt_buff *skb);
-
-extern int rtw_xmit_entry(_pkt *pkt, _nic_hdl pnetdev);
-#endif	//_OSDEP_INTF_H_
\ No newline at end of file
diff --git a/os/board/rtl8720e/src/component/wifi/driver/src/osdep/skbuff.h b/os/board/rtl8720e/src/component/wifi/driver/src/osdep/skbuff.h
deleted file mode 100644
index e0f44c054..000000000
--- a/os/board/rtl8720e/src/component/wifi/driver/src/osdep/skbuff.h
+++ /dev/null
@@ -1,58 +0,0 @@
-/******************************************************************************
- * Copyright (c) 2013-2016 Realtek Semiconductor Corp.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- ******************************************************************************/
-#ifndef __SKBUFF_H__
-#define __SKBUFF_H__
-
-struct  sk_buff_head {
-	struct list_head	*next, *prev;
-	unsigned int 		qlen;
-};
-
-struct sk_buff {
-	/* These two members must be first. */
-	struct sk_buff		*next;		/* Next buffer in list */
-	struct sk_buff		*prev;		/* Previous buffer in list */
-
-	struct sk_buff_head	*list;		/* List we are on */
-	unsigned char		*head;		/* Head of buffer */
-	unsigned char		*data;		/* Data head pointer */
-	unsigned char		*tail;		/* Tail pointer	*/
-	unsigned char		*end;		/* End pointer */
-	void	*dev;		/* Device we arrived on/are leaving by */
-	unsigned int 		len;		/* Length of actual data */
-
-	int 			dyalloc_flag;
-	unsigned char	busy;
-	unsigned char	no_free;
-};
-
-unsigned char *skb_put(struct sk_buff *skb, unsigned int len);
-unsigned char *skb_pull(struct sk_buff *skb, unsigned int len);
-void skb_reserve(struct sk_buff *skb, unsigned int len);
-void skb_assign_buf(struct sk_buff *skb, unsigned char *buf, unsigned int len);
-unsigned char *skb_tail_pointer(const struct sk_buff *skb);
-void skb_set_tail_pointer(struct sk_buff *skb, const int offset);
-unsigned char *skb_end_pointer(const struct sk_buff *skb);
-
-void init_skb_pool(void);
-void init_skb_data_pool(void);
-
-struct sk_buff *dev_alloc_skb(unsigned int length, unsigned int reserve_len);
-void kfree_skb(struct sk_buff *skb);
-
-
-#endif //__SKBUFF_H__
-
diff --git a/os/board/rtl8720e/src/component/wifi/driver/src/osdep/wireless.h b/os/board/rtl8720e/src/component/wifi/driver/src/osdep/wireless.h
deleted file mode 100644
index bca1a5338..000000000
--- a/os/board/rtl8720e/src/component/wifi/driver/src/osdep/wireless.h
+++ /dev/null
@@ -1,227 +0,0 @@
-/******************************************************************************
-  *
-  * This module is a confidential and proprietary property of RealTek and
-  * possession or use of this module requires written permission of RealTek.
-  *
-  * Copyright(c) 2016, Realtek Semiconductor Corporation. All rights reserved.
-  *
-******************************************************************************/
-
-#ifndef _WIRELESS_H
-#define _WIRELESS_H
-
-
-/***************************** INCLUDES *****************************/
-
-//#include <sockets.h>
-#undef IFNAMSIZ
-#define IFNAMSIZ	16
-#define	ARPHRD_ETHER	1	/* ethernet hardware format */
-
-/***************************** VERSION *****************************/
-/*
- * This constant is used to know the availability of the wireless
- * extensions and to know which version of wireless extensions it is
- * (there is some stuff that will be added in the future...)
- * I just plan to increment with each new version.
- */
-#define WIRELESS_EXT	22
-
-/**************************** CONSTANTS ****************************/
-#include <stdint.h>
-typedef uint8_t __u8;
-typedef int8_t __s8;
-typedef uint16_t __u16;
-typedef int16_t __s16;
-typedef uint32_t __u32;
-typedef int32_t __s32;
-typedef	uint64_t __u64;
-typedef	int64_t __i64;
-
-#define	E2BIG		 7	/* Argument list too long */
-
-#define ETH_ALEN	6		/* Octets in one ethernet addr	 */
-
-
-/* ----------------------- OTHER CONSTANTS ----------------------- */
-
-
-/* Maximum size of the ESSID and NICKN strings */
-#define RTW_ESSID_MAX_SIZE	32
-
-/* Modes of operation */
-enum RTK_IW_MODE {
-	RTW_MODE_AUTO = 0,		/* Let the driver decides */
-	RTW_MODE_INFRA,			/* Multi cell network, roaming, ... */
-	RTW_MODE_MASTER			/* Synchronisation master or Access Point */
-};
-
-/* Flags for encoding (along with the token) */
-#define RTW_ENCODE_DISABLED	0x8000	/* Encoding disabled */
-#define RTW_ENCODE_TEMP		0x0400  /* Temporary key */
-
-/* SIOCSIWAUTH/SIOCGIWAUTH struct rtw_param flags */
-#define RTW_AUTH_INDEX		0x0FFF
-
-/* RTW_AUTH_80211_AUTH_ALG values (bit field) */
-#define RTW_AUTH_ALG_OPEN_SYSTEM	0x00000001
-#define RTW_AUTH_ALG_SHARED_KEY		0x00000002
-
-/* struct iw_encode_ext ->alg */
-enum RTW_IW_ENC_ALG {
-	RTW_ENCODE_ALG_NONE = 0,
-	RTW_ENCODE_ALG_WEP,
-	RTW_ENCODE_ALG_TKIP,
-	RTW_ENCODE_ALG_CCMP,
-	RTW_ENCODE_ALG_PMK,
-	RTW_ENCODE_ALG_AES_CMAC //IGTK
-};
-
-/* struct iw_encode_ext ->ext_flags */
-#define RTW_ENCODE_EXT_RX_SEQ_VALID	0x00000002
-#define RTW_ENCODE_EXT_GROUP_KEY	0x00000004
-#define RTW_ENCODE_EXT_SET_TX_KEY	0x00000008
-
-
-/****************************** TYPES ******************************/
-
-/* --------------------------- SUBTYPES --------------------------- */
-
-struct sockaddr_t {
-	__u8 sa_len;
-	__u8 sa_family;
-	char sa_data[14];
-};
-
-/*
- *	Generic format for most parameters that fit in an int
- */
-struct	rtw_param {
-	__s32		value;		/* The value of the parameter itself */
-	__u8		fixed;		/* Hardware should not use auto select */
-	__u8		disabled;	/* Disable the feature */
-	__u16		flags;		/* Various specifc flags (if any) */
-};
-
-/*
- *	For all data larger than 16 octets, we need to use a
- *	pointer to memory allocated in user space.
- */
-struct	rtw_point {
-	void		*pointer;	/* Pointer to the data  (in user space) */
-	__u16		length;		/* number of fields or size in bytes */
-	__u16		flags;		/* Optional params */
-};
-
-/*
- *	A frequency
- *	For numbers lower than 10^9, we encode the number in 'm' and
- *	set 'e' to 0
- *	For number greater than 10^9, we divide it by the lowest power
- *	of 10 to get 'm' lower than 10^9, with 'm'= f / (10^'e')...
- *	The power of 10 is in 'e', the result of the division is in 'm'.
- */
-struct	rtw_freq {
-	__s32		m;		/* Mantissa */
-	__s16		e;		/* Exponent */
-	__u8		i;		/* List index (when in range struct) */
-	__u8		flags;		/* Flags (fixed/auto) */
-};
-
-
-
-/* ------------------------ IOCTL REQUEST ------------------------ */
-/*
- * This structure defines the payload of an ioctl, and is used
- * below.
- *
- * Note that this structure should fit on the memory footprint
- * of rtwreq (which is the same as ifreq), which mean a max size of
- * 16 octets = 128 bits. Warning, pointers might be 64 bits wide...
- * You should check this when increasing the structures defined
- * above in this file...
- */
-union	rtwreq_data {
-	/* Config - generic */
-	char		name[IFNAMSIZ];
-	/* Name : used to verify the presence of  wireless extensions.
-	 * Name of the protocol/provider... */
-
-	struct rtw_point	essid;		/* Extended network name */
-	struct rtw_param	nwid;		/* network id (or domain - the cell) */
-	struct rtw_freq	freq;		/* frequency or channel :
-					 * 0-1000 = channel
-					 * > 1000 = frequency in Hz */
-
-	struct rtw_param	sens;		/* signal level threshold */
-	struct rtw_param	snr;		/* signal noise ratio */
-	struct rtw_param	bitrate;	/* default bit rate */
-	struct rtw_param	txpower;	/* default transmit power */
-	struct rtw_param	rts;		/* RTS threshold threshold */
-	struct rtw_param	frag;		/* Fragmentation threshold */
-	__u32		mode;		/* Operation mode */
-	struct rtw_param	retry;		/* Retry limits & lifetime */
-
-	struct rtw_point	encoding;	/* Encoding stuff : tokens */
-	struct rtw_param	power;		/* PM duration/timeout */
-
-	struct sockaddr_t	ap_addr;	/* Access point address */
-	struct sockaddr_t	addr;		/* Destination address (hw/mac) */
-
-	struct rtw_param	param;		/* Other small parameters */
-	struct rtw_point	data;		/* Other large parameters */
-	struct rtw_point	passphrase;		/* Extended network name */
-};
-
-/*
- * The structure to exchange data for ioctl.
- * This structure is the same as 'struct ifreq', but (re)defined for
- * convenience...
- * Do I need to remind you about structure size (32 octets) ?
- */
-struct	rtwreq {
-#if 0
-	union {
-		char	ifrn_name[IFNAMSIZ];	/* if name, e.g. "eth0" */
-	} ifr_ifrn;
-#endif
-	char	ifr_name[IFNAMSIZ];	/* if name, e.g. "eth0" */
-
-	/* Data part (defined just above) */
-	union	rtwreq_data	u;
-};
-
-/* -------------------------- IOCTL DATA -------------------------- */
-/*
- *	For those ioctl which want to exchange mode data that what could
- *	fit in the above structure...
- */
-
-
-
-/*
- * Private ioctl interface information
- */
-
-struct	rtw_priv_args {
-	__u32		cmd;		/* Number of the ioctl to issue */
-	char		name[IFNAMSIZ];	/* Name of the extension */
-};
-
-
-/* ----------------------- WIRELESS EVENTS ----------------------- */
-/*
- * Wireless events are carried through the rtnetlink socket to user
- * space. They are encapsulated in the IFLA_WIRELESS field of
- * a RTM_NEWLINK message.
- */
-
-#define IW_EXT_STR_FOURWAY_DONE  "WPA/WPA2 handshake done"
-#define IW_EXT_STR_RECONNECTION_FAIL  "RECONNECTION FAILURE"
-#define IW_EVT_STR_STA_ASSOC	"STA Assoc"
-#define IW_EVT_STR_STA_DISASSOC	"STA Disassoc"
-#define IW_EVT_STR_SEND_ACTION_DONE	"Send Action Done"
-#define IW_EVT_STR_NO_NETWORK "No Assoc Network After Scan Done"
-#define IW_EVT_STR_ICV_ERROR "ICV Eror"
-#define IW_EVT_STR_CHALLENGE_FAIL "Auth Challenge Fail"
-#endif	/* _WIRELESS_H */
diff --git a/os/board/rtl8720e/src/component/wifi/driver/src/osdep/wlan_intf.h b/os/board/rtl8720e/src/component/wifi/driver/src/osdep/wlan_intf.h
deleted file mode 100644
index 68929e993..000000000
--- a/os/board/rtl8720e/src/component/wifi/driver/src/osdep/wlan_intf.h
+++ /dev/null
@@ -1,148 +0,0 @@
-/******************************************************************************
- * Copyright (c) 2013-2016 Realtek Semiconductor Corp.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- ******************************************************************************/
-#ifndef __WLAN_INTF_H__
-#define __WLAN_INTF_H__
-
-#ifdef	__cplusplus
-extern "C" {
-#endif
-#include <autoconf.h>
-
-#include <wireless.h>
-#include "wifi_constants.h"
-#include "wifi_structures.h"
-
-#ifndef WLAN_UNDEF
-#define WLAN_UNDEF	-1
-#endif
-
-/***********************************************************/
-/*
-struct sk_buff {
-	// These two members must be first.
-	struct sk_buff		*next;		// Next buffer in list
-	struct sk_buff		*prev;		// Previous buffer in list
-
-	struct sk_buff_head	*list;			// List we are on
-	unsigned char		*head;		// Head of buffer
-	unsigned char		*data;		// Data head pointer
-	unsigned char		*tail;		// Tail pointer
-	unsigned char		*end;		//End pointer
-	struct net_device 	*dev;		//Device we arrived on/are leaving by
-	unsigned int 		len;			// Length of actual data
-};
-*/
-/************************************************************/
-
-//----- ------------------------------------------------------------------
-// Wlan Interface opened for upper layer
-//----- ------------------------------------------------------------------
-int wifi_if1_init(void);
-int wifi_if2_init(void);
-void wifi_if1_deinit(void);
-void wifi_if2_deinit(void);
-void rltk_wlan_set_scan_chan_interval(unsigned short interval_ms);
-
-/**
- * @brief  Get scan results
- * @param[inout]  AP_num: input the pointer to the number of scanned ap info which
- * 	want to get, output the number of scanned ap info whicn can actually get.
- * @param[in]  scan_buf: pointer to the buf where scan result will be stored, the
- * 	scanned AP info will be stored one by one in form of struct rtw_scan_result_t.
- * @return  RTW_SUCCESS or RTW_ERROR.
- * @note  For synchronized scan or asynchronized scan which do not config RTW_SCAN_REPORT_EACH,
- * 	if once called wifi_scan_networks but not use this API to get scanned AP info,
- * 	driver memory for these scanned AP will not be freed until next time
- * 	wifi_scan_networks is called.
- * @note  For asynchronized scan which config RTW_SCAN_REPORT_EACH, every time a
- * 	AP is scanned, the AP info will be directly reported through scan_report_each_mode_user_callback
- * 	and freed after user callback executed, thus there is no need to use this function to get scan result.
- */
-int wifi_get_scan_records(unsigned int *AP_num, char *scan_buf);
-
-/**
- * @brief  Abort onoging wifi scan
- * @return  RTW_SUCCESS or RTW_ERROR.
- * @note  This is an asynchronized function and will return immediately, return value
- * 	only indicates whether the scan abort cmd is successfully notified to driver or not.
- * 	When scan is actually aborted, the user callback registered in wifi_scan_networks
- * 	will be executed.If there is no wifi scan in progress, this function will just return
- * 	RTW_SUCCESS and user callback won't be executed.
- */
-int wifi_scan_abort(void);
-
-int rltk_wlan_get_ccmp_key(unsigned char *uncst_key, unsigned char *group_key);
-int rltk_wlan_wireless_mode(unsigned char mode);
-extern int wifi_hal_iwpriv_command(unsigned char wlan_idx, char *cmd, int show_msg);
-#define rtw_iwpriv_command(wlan_idx, cmd,show_msg)	wifi_hal_iwpriv_command(wlan_idx, cmd,show_msg)
-
-//add temporarily
-extern int rtw_wx_set_essid(__u8 *ssid, __u16 ssid_len);
-extern int rtw_wx_set_wap(unsigned char wlan_idx, __u8 *bssid);
-extern int rtw_wx_set_auth(unsigned char wlan_idx, __u32 value);
-extern int rtw_wx_set_enc_ext(unsigned char wlan_idx, __u16 alg, __u8 *addr, int key_idx, int set_tx, __u8 *seq, __u16 seq_len, __u8 *key, __u16 key_len);
-extern int rtw_wx_set_passphrase(unsigned char wlan_idx, __u8 *passphrase, __u16 passphrase_len);
-extern int rtw_wx_connect_local(rtw_network_info_t *connect_param);
-extern int rtw_wx_set_mode(unsigned char wlan_idx, int mode);
-extern int rtw_wx_set_ap_essid(rtw_softap_info_t *softAP_config, unsigned char value);
-
-/**
- * @brief  Set the listening channel.
- * @param[in]  wlan_idx: 0 means set channel for promisc STA,
- *  1 means set channel to start Soft AP.
- * @param[in]  ch: The desired channel.
- * @return  RTW_SUCCESS: If the channel is successfully set.
- * @return  RTW_ERROR: If the channel is not successfully set.
- * @note  DO NOT call this function for STA mode wifi driver,
- * 	since driver will determine the channel from its
- * 	received beacon.
- */
-extern int wifi_set_freq(unsigned char wlan_idx, __u8 ch);
-
-/**
- * @brief  Get the current channel.
- * @param[in]  wlan_idx: 0 means get current STA channel,
- *  1 means get current Soft AP channel.
- * @param[out]  channel: A pointer to the variable where the
- * 	channel value will be written.
- * @return  RTW_SUCCESS: If the channel is successfully read.
- * @return  RTW_ERROR: If the channel is not successfully read.
- */
-extern int wifi_get_freq(unsigned char wlan_idx, __u8 *ch);
-
-extern int rtw_wx_set_scan(rtw_scan_param_t *scan_param, unsigned char block);
-#ifdef CONFIG_WOWLAN
-extern int rtw_wowlan_ctrl(unsigned char wlan_idx, rtw_wowlan_option_t type, void *param);
-#endif
-
-//promisc related
-extern int promisc_filter_retransmit_pkt(unsigned char enable, unsigned char filter_interval_ms);
-extern int promisc_set(rtw_rcr_level_t enabled, void (*callback)(unsigned char *, unsigned int, void *), unsigned char len_used);
-extern unsigned char is_promisc_enabled(void);
-extern int promisc_get_fixed_channel(void *fixed_bssid, unsigned char *ssid, int *ssid_length);
-extern void promisc_filter_by_ap_and_phone_mac(unsigned char enable, void *ap_mac, void *phone_mac);
-extern int promisc_set_mgntframe(unsigned char enable);
-extern int promisc_get_chnl_by_bssid(unsigned char *bssid);
-extern void promisc_update_candi_ap_rssi_avg(signed char rssi, unsigned char cnt);
-extern void promisc_issue_probersp(unsigned char *da);
-extern void promisc_stop_tx_beacn(void);
-extern void promisc_resume_tx_beacn(void);
-
-#ifdef	__cplusplus
-}
-#endif
-
-#endif //#ifndef __WLAN_INTF_H__
diff --git a/os/board/rtl8720e/src/component/wifi/driver/src/phl/phl.h b/os/board/rtl8720e/src/component/wifi/driver/src/phl/phl.h
deleted file mode 100644
index c9d43e171..000000000
--- a/os/board/rtl8720e/src/component/wifi/driver/src/phl/phl.h
+++ /dev/null
@@ -1,41 +0,0 @@
-#ifndef _PHL_H_
-#define _PHL_H_
-
-#define REGULATION_CHPLAN_VERSION 58
-#define REGULATION_COUNTRY_VERSION 31
-
-struct freq_plan {
-	u8 regulation;
-	u8 ch_idx;
-};
-
-struct regulatory_domain_mapping {
-	u8 domain_code;
-	struct freq_plan freq_2g;
-	struct freq_plan freq_5g;
-};
-#define MAX_RD_MAP_NUM 108
-
-
-void rtw_phl_com_init(_adapter *padapter);
-void rtw_phl_com_deinit(_adapter *padapter);
-
-#if (PHYDM_VERSION == 3)/*ax ic : AmebaSmart, AmebaLite*/
-#define rtw_phl_init_stainfo(padapter, psta)	wifi_hal_phl_stainfo_init(padapter, psta)
-#define rtw_phl_deinit_stainfo(padapter, psta)	wifi_hal_phl_stainfo_deinit(padapter, psta)
-void rtw_phl_final_cap_decision(_adapter *padapter);
-void rtw_phl_rx_count(struct rtw_stats *stats,  u8 is_bcmc, int size);
-void rtw_phl_tx_count(struct rtw_stats *stats,  u8 is_bcmc, int size);
-void rtw_phl_traffic_statistics(struct rtw_stats *stats);
-void rtw_phl_set_edcca_mode(_adapter *padapter);
-#else/*non-ax ic, not use halbb and halrf, don't need the functions below*/
-#define rtw_phl_final_cap_decision(padapter)
-#define rtw_phl_rx_count(stats, is_bcmc, size)
-#define rtw_phl_tx_count(stats, is_bcmc, size)
-#define rtw_phl_traffic_statistics(stats)
-#define rtw_phl_set_edcca_mode(padapter)
-#define rtw_phl_init_stainfo(padapter, psta)
-#define rtw_phl_deinit_stainfo(padapter, psta)
-#endif/*(PHYDM_VERSION == 3)*/
-
-#endif
diff --git a/os/board/rtl8720e/src/component/wifi/driver/src/phl/phl_def.h b/os/board/rtl8720e/src/component/wifi/driver/src/phl/phl_def.h
deleted file mode 100644
index 3c6a7f292..000000000
--- a/os/board/rtl8720e/src/component/wifi/driver/src/phl/phl_def.h
+++ /dev/null
@@ -1,463 +0,0 @@
-#ifndef _PHL_DEF_H_
-#define _PHL_DEF_H_
-/*
-* structs defined in this file are shared with halbb or halrf
-*/
-
-#define MAX_BAND_NUM 1 /*DBCC use 2 bands*/
-
-struct rtw_chan_def {
-	enum band_type band; /* protocol -2.4G,5G,6G*/
-	enum channel_width bw;
-	enum chan_offset offset;/*used as offset of 40MHz, g6 driver may also used as offset of primary channel*/
-	u8 chan; /*primary channel*/
-	u8 center_ch;
-};
-
-enum rtw_edcca_mode_t {
-	RTW_EDCCA_NORM	= 0, /* normal */
-	RTW_EDCCA_ADAPT	= 1, /* adaptivity */
-	RTW_EDCCA_CS	= 2, /* carrier sense */
-
-	RTW_EDCCA_MODE_NUM,
-	RTW_EDCCA_DEF		= RTW_EDCCA_MODE_NUM, /* default (ref to domain code), used at country chplan map's override field */
-};
-
-enum REGULATION {
-	REGULATION_WW        =  0,
-	REGULATION_ETSI      =  1,
-	REGULATION_FCC       =  2,
-	REGULATION_MKK       =  3,
-	REGULATION_KCC       =  4,
-	REGULATION_NCC       =  5,
-	REGULATION_ACMA      =  6,
-	REGULATION_NA        =  7,
-	REGULATION_IC        =  8,
-	REGULATION_CHILE     =  9,
-	REGULATION_MEX       = 10,
-	REGULATION_MAX       = 11,
-};
-
-enum rtw_drv_mode {
-	RTW_DRV_MODE_NORMAL = 0,
-	RTW_DRV_MODE_MP = 1,/*mp mode has to be 1 to be compatible with phydm code 'dm->mp_mode == 1'*/
-
-	/* Fixed Max Value*/
-	RTW_DRV_MODE_MAX = 255
-};
-
-/*==================phl_country.h of g6 driver============= ===*/
-enum TP_OVERWRITE {
-	TPO_CHILE = 0,
-	TPO_QATAR = 1,
-	TPO_UKRAINE = 2,
-	TPO_CN = 3,
-	TPO_NA = 4
-};
-
-struct rtw_regulation_info {
-	u8 domain_code;			/* just for halrf print */
-	u8 regulation_2g;		/* halrf use */
-	u8 regulation_5g;		/* halrf use */
-	u8 regulation_6g;			/* not support */
-	u8 tpo;				/* halrf use, currently set NA, TODO */
-	u8 chplan_ver;			/* just for halrf print */
-	u8 country_ver;			/* just for halrf print */
-};
-
-/*==================rtw_general_def.h of g6 driver==============*/
-#define RTW_PHL_MAX_RF_PATH 4
-
-enum wlan_mode {
-	WLAN_MD_INVALID = 0,
-	WLAN_MD_11B	= BIT0,
-	WLAN_MD_11A	= BIT1,
-	WLAN_MD_11G	= BIT2,
-	WLAN_MD_11N	= BIT3,
-	WLAN_MD_11AC	= BIT4,
-	WLAN_MD_11AX	= BIT5,
-
-	/* Type for current wireless mode */
-	WLAN_MD_11BG	= (WLAN_MD_11B | WLAN_MD_11G),
-	WLAN_MD_11GN	= (WLAN_MD_11G | WLAN_MD_11N),
-	WLAN_MD_11AN	= (WLAN_MD_11A | WLAN_MD_11N),
-	WLAN_MD_11BN	= (WLAN_MD_11B | WLAN_MD_11N),
-	WLAN_MD_11BGN	= (WLAN_MD_11B | WLAN_MD_11G | WLAN_MD_11N),
-	WLAN_MD_11BGAC = (WLAN_MD_11B | WLAN_MD_11G | WLAN_MD_11AC),
-	WLAN_MD_11BGAX = (WLAN_MD_11B | WLAN_MD_11G | WLAN_MD_11AX),
-	WLAN_MD_11GAC  = (WLAN_MD_11G | WLAN_MD_11AC),
-	WLAN_MD_11GAX  = (WLAN_MD_11G | WLAN_MD_11AX),
-	WLAN_MD_11A_AC = (WLAN_MD_11A | WLAN_MD_11AC),
-	WLAN_MD_11A_AX = (WLAN_MD_11A | WLAN_MD_11AX),
-
-	/* Capability -Type for registry default wireless mode */
-	WLAN_MD_11AGN	= (WLAN_MD_11A | WLAN_MD_11G | WLAN_MD_11N),
-	WLAN_MD_11ABGN	= (WLAN_MD_11A | WLAN_MD_11B | WLAN_MD_11G | WLAN_MD_11N),
-	WLAN_MD_11ANAC	= (WLAN_MD_11A | WLAN_MD_11N | WLAN_MD_11AC),
-	WLAN_MD_11BGNAC = (WLAN_MD_11B | WLAN_MD_11G | WLAN_MD_11N | WLAN_MD_11AC),
-	WLAN_MD_11GNAC  = (WLAN_MD_11G | WLAN_MD_11N | WLAN_MD_11AC),
-	WLAN_MD_24G_MIX = (WLAN_MD_11B | WLAN_MD_11G | WLAN_MD_11N  | WLAN_MD_11AX),
-	WLAN_MD_5G_MIX	= (WLAN_MD_11A | WLAN_MD_11N | WLAN_MD_11AC | WLAN_MD_11AX),
-	WLAN_MD_6G_MIX 	= (WLAN_MD_11A | WLAN_MD_11AX),
-	WLAN_MD_MAX	= (WLAN_MD_24G_MIX | WLAN_MD_5G_MIX),
-};
-
-enum rtw_gi_ltf {
-	RTW_GILTF_LGI_4XHE32 = 0,
-	RTW_GILTF_SGI_4XHE08 = 1,
-	RTW_GILTF_2XHE16 = 2,
-	RTW_GILTF_2XHE08 = 3,
-	RTW_GILTF_1XHE16 = 4,
-	RTW_GILTF_1XHE08 = 5,
-	RTW_GILTF_MAX
-};
-
-enum rtw_data_rate {
-	RTW_DATA_RATE_CCK1		= 0x0,
-	RTW_DATA_RATE_CCK2		= 0x1,
-	RTW_DATA_RATE_CCK5_5	= 0x2,
-	RTW_DATA_RATE_CCK11		= 0x3,
-	RTW_DATA_RATE_OFDM6		= 0x4,
-	RTW_DATA_RATE_OFDM9		= 0x5,
-	RTW_DATA_RATE_OFDM12	= 0x6,
-	RTW_DATA_RATE_OFDM18	= 0x7,
-	RTW_DATA_RATE_OFDM24	= 0x8,
-	RTW_DATA_RATE_OFDM36	= 0x9,
-	RTW_DATA_RATE_OFDM48	= 0xA,
-	RTW_DATA_RATE_OFDM54	= 0xB,
-	RTW_DATA_RATE_MCS0		= 0x80,
-	RTW_DATA_RATE_MCS1		= 0x81,
-	RTW_DATA_RATE_MCS2		= 0x82,
-	RTW_DATA_RATE_MCS3		= 0x83,
-	RTW_DATA_RATE_MCS4		= 0x84,
-	RTW_DATA_RATE_MCS5		= 0x85,
-	RTW_DATA_RATE_MCS6		= 0x86,
-	RTW_DATA_RATE_MCS7		= 0x87,
-	RTW_DATA_RATE_MCS8		= 0x88,
-	RTW_DATA_RATE_MCS9		= 0x89,
-	RTW_DATA_RATE_MCS10		= 0x8A,
-	RTW_DATA_RATE_MCS11		= 0x8B,
-	RTW_DATA_RATE_MCS12		= 0x8C,
-	RTW_DATA_RATE_MCS13		= 0x8D,
-	RTW_DATA_RATE_MCS14		= 0x8E,
-	RTW_DATA_RATE_MCS15		= 0x8F,
-	RTW_DATA_RATE_MCS16		= 0x90,
-	RTW_DATA_RATE_MCS17		= 0x91,
-	RTW_DATA_RATE_MCS18		= 0x92,
-	RTW_DATA_RATE_MCS19		= 0x93,
-	RTW_DATA_RATE_MCS20		= 0x94,
-	RTW_DATA_RATE_MCS21		= 0x95,
-	RTW_DATA_RATE_MCS22		= 0x96,
-	RTW_DATA_RATE_MCS23		= 0x97,
-	RTW_DATA_RATE_MCS24		= 0x98,
-	RTW_DATA_RATE_MCS25		= 0x99,
-	RTW_DATA_RATE_MCS26		= 0x9A,
-	RTW_DATA_RATE_MCS27		= 0x9B,
-	RTW_DATA_RATE_MCS28		= 0x9C,
-	RTW_DATA_RATE_MCS29		= 0x9D,
-	RTW_DATA_RATE_MCS30		= 0x9E,
-	RTW_DATA_RATE_MCS31		= 0x9F,
-	RTW_DATA_RATE_VHT_NSS1_MCS0	= 0x100,
-	RTW_DATA_RATE_VHT_NSS1_MCS1	= 0x101,
-	RTW_DATA_RATE_VHT_NSS1_MCS2	= 0x102,
-	RTW_DATA_RATE_VHT_NSS1_MCS3	= 0x103,
-	RTW_DATA_RATE_VHT_NSS1_MCS4	= 0x104,
-	RTW_DATA_RATE_VHT_NSS1_MCS5	= 0x105,
-	RTW_DATA_RATE_VHT_NSS1_MCS6	= 0x106,
-	RTW_DATA_RATE_VHT_NSS1_MCS7	= 0x107,
-	RTW_DATA_RATE_VHT_NSS1_MCS8	= 0x108,
-	RTW_DATA_RATE_VHT_NSS1_MCS9	= 0x109,
-	RTW_DATA_RATE_VHT_NSS2_MCS0	= 0x110,
-	RTW_DATA_RATE_VHT_NSS2_MCS1	= 0x111,
-	RTW_DATA_RATE_VHT_NSS2_MCS2	= 0x112,
-	RTW_DATA_RATE_VHT_NSS2_MCS3	= 0x113,
-	RTW_DATA_RATE_VHT_NSS2_MCS4	= 0x114,
-	RTW_DATA_RATE_VHT_NSS2_MCS5	= 0x115,
-	RTW_DATA_RATE_VHT_NSS2_MCS6	= 0x116,
-	RTW_DATA_RATE_VHT_NSS2_MCS7	= 0x117,
-	RTW_DATA_RATE_VHT_NSS2_MCS8	= 0x118,
-	RTW_DATA_RATE_VHT_NSS2_MCS9	= 0x119,
-	RTW_DATA_RATE_VHT_NSS3_MCS0	= 0x120,
-	RTW_DATA_RATE_VHT_NSS3_MCS1	= 0x121,
-	RTW_DATA_RATE_VHT_NSS3_MCS2	= 0x122,
-	RTW_DATA_RATE_VHT_NSS3_MCS3	= 0x123,
-	RTW_DATA_RATE_VHT_NSS3_MCS4	= 0x124,
-	RTW_DATA_RATE_VHT_NSS3_MCS5	= 0x125,
-	RTW_DATA_RATE_VHT_NSS3_MCS6	= 0x126,
-	RTW_DATA_RATE_VHT_NSS3_MCS7	= 0x127,
-	RTW_DATA_RATE_VHT_NSS3_MCS8	= 0x128,
-	RTW_DATA_RATE_VHT_NSS3_MCS9	= 0x129,
-	RTW_DATA_RATE_VHT_NSS4_MCS0	= 0x130,
-	RTW_DATA_RATE_VHT_NSS4_MCS1	= 0x131,
-	RTW_DATA_RATE_VHT_NSS4_MCS2	= 0x132,
-	RTW_DATA_RATE_VHT_NSS4_MCS3	= 0x133,
-	RTW_DATA_RATE_VHT_NSS4_MCS4	= 0x134,
-	RTW_DATA_RATE_VHT_NSS4_MCS5	= 0x135,
-	RTW_DATA_RATE_VHT_NSS4_MCS6	= 0x136,
-	RTW_DATA_RATE_VHT_NSS4_MCS7	= 0x137,
-	RTW_DATA_RATE_VHT_NSS4_MCS8	= 0x138,
-	RTW_DATA_RATE_VHT_NSS4_MCS9	= 0x139,
-	RTW_DATA_RATE_HE_NSS1_MCS0	= 0x180,
-	RTW_DATA_RATE_HE_NSS1_MCS1	= 0x181,
-	RTW_DATA_RATE_HE_NSS1_MCS2	= 0x182,
-	RTW_DATA_RATE_HE_NSS1_MCS3	= 0x183,
-	RTW_DATA_RATE_HE_NSS1_MCS4	= 0x184,
-	RTW_DATA_RATE_HE_NSS1_MCS5	= 0x185,
-	RTW_DATA_RATE_HE_NSS1_MCS6	= 0x186,
-	RTW_DATA_RATE_HE_NSS1_MCS7	= 0x187,
-	RTW_DATA_RATE_HE_NSS1_MCS8	= 0x188,
-	RTW_DATA_RATE_HE_NSS1_MCS9	= 0x189,
-	RTW_DATA_RATE_HE_NSS1_MCS10	= 0x18A,
-	RTW_DATA_RATE_HE_NSS1_MCS11	= 0x18B,
-	RTW_DATA_RATE_HE_NSS2_MCS0	= 0x190,
-	RTW_DATA_RATE_HE_NSS2_MCS1	= 0x191,
-	RTW_DATA_RATE_HE_NSS2_MCS2	= 0x192,
-	RTW_DATA_RATE_HE_NSS2_MCS3	= 0x193,
-	RTW_DATA_RATE_HE_NSS2_MCS4	= 0x194,
-	RTW_DATA_RATE_HE_NSS2_MCS5	= 0x195,
-	RTW_DATA_RATE_HE_NSS2_MCS6	= 0x196,
-	RTW_DATA_RATE_HE_NSS2_MCS7	= 0x197,
-	RTW_DATA_RATE_HE_NSS2_MCS8	= 0x198,
-	RTW_DATA_RATE_HE_NSS2_MCS9	= 0x199,
-	RTW_DATA_RATE_HE_NSS2_MCS10	= 0x19A,
-	RTW_DATA_RATE_HE_NSS2_MCS11	= 0x19B,
-	RTW_DATA_RATE_HE_NSS3_MCS0	= 0x1A0,
-	RTW_DATA_RATE_HE_NSS3_MCS1	= 0x1A1,
-	RTW_DATA_RATE_HE_NSS3_MCS2	= 0x1A2,
-	RTW_DATA_RATE_HE_NSS3_MCS3	= 0x1A3,
-	RTW_DATA_RATE_HE_NSS3_MCS4	= 0x1A4,
-	RTW_DATA_RATE_HE_NSS3_MCS5	= 0x1A5,
-	RTW_DATA_RATE_HE_NSS3_MCS6	= 0x1A6,
-	RTW_DATA_RATE_HE_NSS3_MCS7	= 0x1A7,
-	RTW_DATA_RATE_HE_NSS3_MCS8	= 0x1A8,
-	RTW_DATA_RATE_HE_NSS3_MCS9	= 0x1A9,
-	RTW_DATA_RATE_HE_NSS3_MCS10	= 0x1AA,
-	RTW_DATA_RATE_HE_NSS3_MCS11	= 0x1AB,
-	RTW_DATA_RATE_HE_NSS4_MCS0	= 0x1B0,
-	RTW_DATA_RATE_HE_NSS4_MCS1	= 0x1B1,
-	RTW_DATA_RATE_HE_NSS4_MCS2	= 0x1B2,
-	RTW_DATA_RATE_HE_NSS4_MCS3	= 0x1B3,
-	RTW_DATA_RATE_HE_NSS4_MCS4	= 0x1B4,
-	RTW_DATA_RATE_HE_NSS4_MCS5	= 0x1B5,
-	RTW_DATA_RATE_HE_NSS4_MCS6	= 0x1B6,
-	RTW_DATA_RATE_HE_NSS4_MCS7	= 0x1B7,
-	RTW_DATA_RATE_HE_NSS4_MCS8	= 0x1B8,
-	RTW_DATA_RATE_HE_NSS4_MCS9	= 0x1B9,
-	RTW_DATA_RATE_HE_NSS4_MCS10	= 0x1BA,
-	RTW_DATA_RATE_HE_NSS4_MCS11	= 0x1BB,
-	RTW_DATA_RATE_MAX = 0x1FF
-};
-
-/*==================phl_def.h of g6 driver====================*/
-enum dfs_regd_t {
-	DFS_REGD_UNKNOWN	= 0,
-	DFS_REGD_FCC	= 1,
-	DFS_REGD_JAP	= 2,
-	DFS_REGD_ETSI	= 3,
-	DFS_REGD_KCC	= 4,
-};
-
-struct rtw_dfs_t {
-	u8 region_domain;
-	bool dfs_enabled;
-	bool is_dfs_detectd;
-};
-
-enum role_type {
-	PHL_RTYPE_NONE,
-	PHL_RTYPE_STATION,
-	PHL_RTYPE_AP,
-	PHL_RTYPE_VAP,
-	PHL_RTYPE_ADHOC,
-	PHL_RTYPE_ADHOC_MASTER,
-	PHL_RTYPE_MESH,
-	PHL_RTYPE_MONITOR,
-	PHL_RTYPE_P2P_DEVICE,
-	PHL_RTYPE_P2P_GC,
-	PHL_RTYPE_P2P_GO,
-	PHL_RTYPE_TDLS,
-	PHL_RTYPE_NAN,
-	PHL_MLME_MAX
-};
-
-/* General phl event id shall share this common enum definition
- * if definition of private events for a specific module is required,
- * please be sure to start its enum from PRIVATE_EVT_START(0x8000)
- */
-enum phl_msg_evt_id {
-	MSG_EVT_SCAN_START 		= 0,		//core notify halbb&halrf
-	MSG_EVT_SCAN_END 			= 1,		//core notify halbb&halrf
-	MSG_EVT_CONNECT_START 	= 2,		//currenty not notify
-	MSG_EVT_CONNECT_END 		= 3,		//currenty not notify
-	MSG_EVT_SWCH_START 		= 4,		//core notidy halrf to backup tssi, AX_TODO, currently just backup, no resume
-
-	MSG_EVT_DBG_RX_DUMP 	= 5,
-	MSG_EVT_DBG_TX_DUMP 		= 6,
-
-	MSG_EVT_NOTIFY_BB 		= 7,		//halbb notify halbb, AX_TODO may delete
-
-	MSG_EVT_MAX 				= 0x7fff
-};
-
-/*
-Protocol - RX CAP from 80211 PKT,
-driver TX related function need to
-reference __rx__ of rtw_phl_stainfo_t->asoc_cap
-*/
-struct protocol_cap_t {
-	/* MAC related */
-	u8 htc_rx: 1;
-	u8 trig_padding: 2;	//hal_mac used
-	/* bit0:twt requester; bit1:twt responder; bit2:b-twt;
-	 * bit3:Flex twt schedule; bit4:psr responder; bit5:sst;
-	 */
-	u8 twt: 6;
-	u8 all_ack: 1;
-	u8 a_ctrl: 3;	/* bit0:TRS; bit1:BSR; bit2:BQR */
-	u8 ops: 1;
-	u8 ht_vht_trig_rx: 1;
-	u8 bsscolor;
-	u16 rts_th: 10;
-	u8 sgi_20: 1;		/* HT Short GI for 20 MHz */
-	u8 sgi_40: 1;		/* HT Short GI for 40 MHz */
-	u8 sgi_80: 1;		/* VHT Short GI for 80 MHz */
-	u8 sgi_160: 1;		/* VHT Short GI for 160/80+80 MHz */
-
-	/* BB related */
-	u8 ht_ldpc: 1;
-	u8 vht_ldpc: 1;
-	u8 he_ldpc: 1;	//halbb used
-
-	/*
-	 * supported_rates: Supported data rate of CCK/OFDM.
-	 * The rate definition follow Wi-Fi spec, unit is 500kb/s,
-	 * and the MSB(bit 7) represent basic rate.
-	 * ex. CCK 2Mbps not basic rate is encoded as 0x04,
-	 *     and OFDM 6M basic rate is encoded as 0x8c.
-	 * Suppose rates come from Supported Rates and Extended Supported
-	 * Rates IE.
-	 * Value 0 means it is end of array, and no more valid data rate follow.
-	 */
-	u8 supported_rates[12];
-	u8 ht_rx_mcs[4];
-	u8 ht_tx_mcs[4];
-	u8 vht_rx_mcs[2];
-	u8 vht_tx_mcs[2];
-	u8 he_rx_mcs[6];/*80,160,80+80*/
-	u8 he_tx_mcs[6];/*80,160,80+80*/
-	u8 stbc_ht_tx: 1;	//halbb used
-	u8 stbc_ht_rx: 2;	//halbb used
-	u8 stbc_vht_rx: 3;	//halbb used
-	u8 stbc_vht_tx: 1;
-	u8 stbc_he_rx: 1;	//halbb used
-	u8 stbc_he_tx: 1;
-	u8 ltf_gi;	//halbb used
-	u8 dcm_max_const_rx: 2;	//halbb used
-	u8 pkt_padding: 2;
-	u8 ppe_thr[8][4];
-	u8 er_su: 1;	//halbb used
-	u8 partial_bw_su_er: 1;
-
-	/* RF related */
-	u8 nss_tx: 3;
-	u8 nss_rx: 3;	//halbb used
-
-};
-
-/*for halbb, driver can set these or use default value in halbb*/
-struct rtw_edcca_cap_t {
-	u8 edcca_adap_th_2g;
-	u8 edcca_adap_th_5g;
-	u8 edcca_cbp_th_6g;
-	u8 edcca_carrier_sense_th;
-};
-
-struct dev_cap_t {
-#if (PHYDM_VERSION == 3)
-	struct rtw_edcca_cap_t edcca_cap;
-	u32 rfk_cap;
-	u8 pkg_type;/*todo, halbb/halrf not really used this right now*/
-	u8 pwrbyrate_off;
-	u8 pwrlmt_type;
-	u8 rf_board_opt;
-#endif
-	u8 xcap;
-	u8 rfe_type;
-};
-
-struct rtw_stats {
-	u64 tx_byte_uni;/*halbb just print for debug*/
-	u64 rx_byte_uni;/*halbb just print for debug*/
-	u64 tx_byte_total;/*halbb just print for debug*/
-	u64 rx_byte_total;/*halbb just print for debug*/
-	u32 tx_tp_kbits;/*halbb needs*/
-	u32 rx_tp_kbits;/*halbb needs*/
-	u16 tx_moving_average_tp; /*todo, g6 driver todo, halbb just print for debug*/
-	u16 rx_moving_average_tp; /*todo, g6 driver todo,halbb just print for debug*/
-	u64 last_rx_byte_uni;
-	u64 last_tx_byte_uni;
-	u32 rx_tf_cnt; /* rx trigger frame number (accumulated, only reset in disconnect) */
-};
-
-struct rtw_iot_t {
-	u32 id;
-};
-
-struct rtw_wifi_role_link_t {
-	u8 hw_band;                    /*MAC Band0 or Band1*/
-};
-
-enum rtw_dev_state {
-	RTW_DEV_WORKING = BIT0,
-	RTW_DEV_SUSPENDING = BIT1,
-	RTW_DEV_RESUMING = BIT2,
-	RTW_DEV_SURPRISE_REMOVAL = BIT3,
-	RTW_DEV_IN_DFS_CAC_PERIOD = BIT4,
-	RTW_DEV_SHUTTING_DOWN = BIT5, /* set by core */
-	RTW_DEV_MAX
-};
-
-struct rtw_hal_stainfo_t;
-struct rtw_phl_stainfo_t {
-	bool active;
-	struct rtw_hal_stainfo_t *hal_sta;
-	struct rtw_stats stats;
-	enum wlan_mode wmode;
-	struct rtw_chan_def chandef;
-	struct protocol_cap_t asoc_cap;
-	u8 macid;		/* driver & halbb */
-	u16 aid;			/* driver */
-	u8 mac_addr[6];	/* driver */
-};
-
-struct efuse_info {
-	u8 thermal_a;
-	u8 tssi_2g[11];
-	u8 rxgain_2g_cck;
-	u8 rxgain_2g_ofdm;
-#if defined(SUPPORT_5G_CHANNEL)
-	u8 tssi_5g[14];
-	u8 rxgain_5gl;
-	u8 rxgain_5gm;
-	u8 rxgain_5gh;
-#endif
-};
-
-struct rtw_phl_com_t {
-	enum rtw_hci_type hci_type;/*useless, ameba is always axi, but hallbb need this!*/
-	enum rtw_drv_mode drv_mode;/*normal or mp mode*/
-	struct dev_cap_t dev_cap;
-	enum rtw_dev_state dev_state;
-	struct rtw_dfs_t dfs_info;
-	struct rtw_iot_t id;
-	void *phl_priv; /*pointer to adapter*/
-	bool ap_mode; /*provide ap mode information to BB DIG*/
-#if (PHYDM_VERSION == 3)
-	struct rtw_stats phl_stats;
-	u8 edcca_mode;
-	struct efuse_info efuse_data;
-#endif
-	u8 bb_log;
-	u8 csa_switch_ch;/*add for bb reset rssi only when csa switch channel*/
-};
-#endif
diff --git a/os/board/rtl8720e/src/component/wifi/inic/Make.defs b/os/board/rtl8720e/src/component/wifi/inic/Make.defs
old mode 100644
new mode 100755
diff --git a/os/board/rtl8720e/src/component/wifi/inic/inic_ipc.h b/os/board/rtl8720e/src/component/wifi/inic/inic_ipc.h
old mode 100644
new mode 100755
index 2543e6bb6..f02ef0ad7
--- a/os/board/rtl8720e/src/component/wifi/inic/inic_ipc.h
+++ b/os/board/rtl8720e/src/component/wifi/inic/inic_ipc.h
@@ -17,14 +17,12 @@
 #define __INIC_IPC_H__
 
 /* -------------------------------- Includes -------------------------------- */
-#include <platform_stdlib.h>
 #include "platform_opts.h"
 
 #include "ameba_soc.h"
-#include "platform_stdlib.h"
 #include "osdep_service.h"
-#include "wifi_structures.h"
-#include "skbuff.h"
+#include "rtw_wifi_constants.h"
+#include "rtw_skbuff.h"
 
 #include "inic_ipc_cfg.h"
 
@@ -33,28 +31,20 @@
 #define rtw_memcpy			_memcpy
 #define FLAG_WLAN_IF_NOT_RUNNING		0xFFFFFFFF
 /* -------------------------------- Macros ---------------------------------- */
-#if defined (WIFI_LOGO_CERTIFICATION) && (WIFI_LOGO_CERTIFICATION)
-#define MAX_SKB_BUF_SIZE	4144
-#elif defined(CONFIG_PLATFORM_AMEBAD2)
-// customer requirement, send udp multicast frames around 1900 bytes without fragmentation
-#define MAX_SKB_BUF_SIZE	2048
-#else
-#define MAX_SKB_BUF_SIZE	1658
-#endif
+
 /* ------------------------------- Data Types ------------------------------- */
 typedef struct inic_ipc_ex_msg {
 	u32	event_num;
 	u32	msg_addr;
-	u32	msg_len;
-	u32 rsvd[13]; /* keep total size 64B aligned */
+	u32 msg_queue_status;
+	u32	wlan_idx;
+	u32 rsvd[12]; /* keep total size 64B aligned */
 } inic_ipc_ex_msg_t;
 
 enum IPC_WIFI_CTRL_TYPE {
 	IPC_WIFI_MSG_READ_DONE = 0,
 	IPC_WIFI_MSG_MEMORY_NOT_ENOUGH,
-	IPC_WIFI_MSG_ALLOC_SKB,
 	IPC_WIFI_MSG_RECV_DONE,
-	IPC_WIFI_MSG_RECV_PENDING,
 	IPC_WIFI_CMD_XIMT_PKTS,
 	IPC_WIFI_EVT_RECV_PKTS
 };
diff --git a/os/board/rtl8720e/src/component/wifi/inic/inic_ipc_api.h b/os/board/rtl8720e/src/component/wifi/inic/inic_ipc_api.h
old mode 100644
new mode 100755
index 4ff8672ae..a9259114c
--- a/os/board/rtl8720e/src/component/wifi/inic/inic_ipc_api.h
+++ b/os/board/rtl8720e/src/component/wifi/inic/inic_ipc_api.h
@@ -19,8 +19,10 @@
 #include "ameba_soc.h"
 
 #include "osdep_service.h"
-#include "wifi_structures.h"
-#include "wifi_constants.h"
+#include "rtw_wifi_constants.h"
+#include "wifi_conf.h"
+#include "rtw_skbuff.h"
+
 /* -------------------------------- Defines --------------------------------- */
 #define HOST_MSG_PARAM_NUM 9
 #define DEV_MSG_PARAM_NUM 6
@@ -101,6 +103,7 @@ enum IPC_WIFI_H2C_EVENT_TYPE {
 	IPC_API_WIFI_SET_NO_BEACON_TIMEOUT,
 	IPC_API_WIFI_CONFIG_CSI,
 	IPC_API_WIFI_GET_CSI_REPORT,
+	IPC_API_WIFI_GET_TX_POWERTABLE,
 	//inter
 	IPC_API_WIFI_COEX_SET_PTA,
 	IPC_API_WIFI_SET_WPA_MODE,
@@ -155,6 +158,7 @@ typedef struct inic_ipc_dev_request_message {
 /* -------------------------- Function declaration -------------------------- */
 /*for ipc host api*/
 void inic_ipc_api_init_host(VOID);
+void inic_ipc_host_deinit_skb(void);
 void inic_ipc_api_host_int_hdl(VOID *Data, u32 IrqStatus, u32 ChanNum);
 int inic_ipc_api_host_message_send(u32 id, u32 *param_buf, u32 buf_len);
 
diff --git a/os/board/rtl8720e/src/component/wifi/inic/inic_ipc_cfg.h b/os/board/rtl8720e/src/component/wifi/inic/inic_ipc_cfg.h
old mode 100644
new mode 100755
diff --git a/os/board/rtl8720e/src/component/wifi/inic/inic_ipc_dev_api.c b/os/board/rtl8720e/src/component/wifi/inic/inic_ipc_dev_api.c
old mode 100644
new mode 100755
index 36bfcab94..9a3d53f26
--- a/os/board/rtl8720e/src/component/wifi/inic/inic_ipc_dev_api.c
+++ b/os/board/rtl8720e/src/component/wifi/inic/inic_ipc_dev_api.c
@@ -12,10 +12,8 @@
 
 ******************************************************************************/
 #include "inic_ipc_api.h"
-#include "wifi_conf.h"
-#include "wifi_conf_inter.h"
 
-#include "wlan_intf.h"
+#include "rtw_drv_api.h"
 #include "inic_ipc_cfg.h"
 
 /* -------------------------------- Defines --------------------------------- */
@@ -86,7 +84,7 @@ void inic_ipc_api_dev_task(void)
 			if (pWifi->password_len) {
 				DCache_Invalidate((u32)pWifi->password, pWifi->password_len);
 			}
-			ret = rtw_wx_connect_local(pWifi);
+			ret = rtw_joinbss_start_api(pWifi);
 			p_ipc_msg->ret = ret;
 			break;
 		}
@@ -382,17 +380,21 @@ void inic_ipc_api_dev_task(void)
 			u16 buf_len = (u16)p_ipc_msg->param_buf[2];
 			u16 flags = (u16)p_ipc_msg->param_buf[3];
 			DCache_Invalidate((u32)buf, buf_len);
-			ret = wifi_send_eapol(wlan_idx, buf, buf_len, flags);
+			ret = wifi_if_send_eapol(wlan_idx, buf, buf_len, flags);
 			p_ipc_msg->ret = ret;
 			break;
 		}
 		case IPC_API_WIFI_CONFIG_AUTORECONNECT: {
+#if CONFIG_AUTO_RECONNECT
 			u8 mode = (u8)p_ipc_msg->param_buf[0];
 			ret = wifi_config_autoreconnect(mode);
 			if (mode != RTW_AUTORECONNECT_DISABLE) {
 				p_wlan_autoreconnect_hdl = (p_wlan_autoreconnect_hdl_t)0xFFFFFFFF;
 			}
 			p_ipc_msg->ret = ret;
+#else
+			p_ipc_msg->ret = -1;
+#endif
 			break;
 		}
 		case IPC_API_WIFI_GET_AUTORECONNECT: {
@@ -512,13 +514,13 @@ void inic_ipc_api_dev_task(void)
 			rtw_rcr_level_t enabled = (rtw_rcr_level_t)p_ipc_msg->param_buf[0];
 			inic_ipc_promisc_callback_t callback = (inic_ipc_promisc_callback_t)p_ipc_msg->param_buf[1];
 			unsigned char len_used = (unsigned char)p_ipc_msg->param_buf[2];
-			ret = promisc_set(enabled, callback, len_used);
+			ret = _promisc_set(enabled, callback, len_used);
 
 			p_ipc_msg->ret = ret;
 			break;
 		}
 		case IPC_API_PROMISC_IS_ENABLED: {
-			ret = is_promisc_enabled();
+			ret = _is_promisc_enabled();
 			p_ipc_msg->ret = ret;
 			break;
 		}
@@ -528,14 +530,14 @@ void inic_ipc_api_dev_task(void)
 			int *ssid_length = (int *)p_ipc_msg->param_buf[2];
 			DCache_Invalidate((u32)fixed_bssid, ETH_ALEN);
 			DCache_Invalidate((u32)ssid, 33);
-			ret = promisc_get_fixed_channel(fixed_bssid, ssid, ssid_length);
+			ret = _promisc_get_fixed_channel(fixed_bssid, ssid, ssid_length);
 			p_ipc_msg->ret = ret;
 			break;
 		}
 		case IPC_API_PROMISC_ISSUE_PROBERSP: {
 			unsigned char *da = (unsigned char *)p_ipc_msg->param_buf[0];
 			DCache_Invalidate((u32)da, ETH_ALEN);
-			promisc_issue_probersp(da);
+			_promisc_issue_probersp(da);
 			break;
 		}
 		case IPC_API_WIFI_GET_AUTO_CHANNEL: {
@@ -571,7 +573,7 @@ void inic_ipc_api_dev_task(void)
 		}
 		case IPC_API_PROMISC_SET_MGNTFRAME: {
 			u8 enable = (u8)p_ipc_msg->param_buf[0];
-			ret = promisc_set_mgntframe(enable);
+			ret = _promisc_set_mgntframe(enable);
 			p_ipc_msg->ret = ret;
 			break;
 		}
@@ -585,15 +587,15 @@ void inic_ipc_api_dev_task(void)
 			if (phone_mac) {
 				DCache_Invalidate((u32)phone_mac, ETH_ALEN);
 			}
-			promisc_filter_by_ap_and_phone_mac(enable, ap_mac, phone_mac);
+			_promisc_filter_by_ap_and_phone_mac(enable, ap_mac, phone_mac);
 			break;
 		}
 		case IPC_API_PROMISC_TX_BEACON_CONTROL: {
 			u32 control = p_ipc_msg->param_buf[0];
 			if (control == 1) {
-				promisc_stop_tx_beacn();
+				_promisc_stop_tx_beacn();
 			} else if (control == 2) {
-				promisc_resume_tx_beacn();
+				_promisc_resume_tx_beacn();
 			}
 			break;
 		}
@@ -642,7 +644,7 @@ void inic_ipc_api_dev_task(void)
 		case IPC_API_PROMISC_UPDATE_CANDI_AP_RSSI_AVG: {
 			s8 rssi = (s8)p_ipc_msg->param_buf[0];
 			u8 cnt = (u8)p_ipc_msg->param_buf[1];
-			promisc_update_candi_ap_rssi_avg(rssi, cnt);
+			_promisc_update_candi_ap_rssi_avg(rssi, cnt);
 			break;
 		}
 		case IPC_API_PROMISC_GET_CHANNEL_BY_BSSID: {
@@ -650,7 +652,7 @@ void inic_ipc_api_dev_task(void)
 			if (bssid) {
 				DCache_Invalidate((u32)bssid, ETH_ALEN);
 			}
-			ret = promisc_get_chnl_by_bssid(bssid);
+			ret = _promisc_get_chnl_by_bssid(bssid);
 			p_ipc_msg->ret = ret;
 			break;
 		}
@@ -924,7 +926,7 @@ void inic_ipc_api_init_dev(VOID)
 }
 
 /* ---------------------------- Global Variables ---------------------------- */
-#if defined(CONFIG_PLATFORM_AMEBALITE) || defined(CONFIG_PLATFORM_AMEBAD2)
+#if defined(CONFIG_PLATFORM_AMEBALITE) || defined(CONFIG_PLATFORM_AMEBAD2) || defined(CONFIG_PLATFORM_AMEBADPLUS)
 IPC_TABLE_DATA_SECTION
 const IPC_INIT_TABLE   ipc_api_dev_table[] = {
 	{IPC_USER_POINT,	inic_ipc_api_dev_int_hdl,	(VOID *) NULL, IPC_DIR_MSG_RX, IPC_H2D_WIFI_API_TRAN, IPC_RX_FULL},
diff --git a/os/board/rtl8720e/src/component/wifi/inic/inic_ipc_dev_trx.c b/os/board/rtl8720e/src/component/wifi/inic/inic_ipc_dev_trx.c
old mode 100644
new mode 100755
index fcf72e989..bbd693c6f
--- a/os/board/rtl8720e/src/component/wifi/inic/inic_ipc_dev_trx.c
+++ b/os/board/rtl8720e/src/component/wifi/inic/inic_ipc_dev_trx.c
@@ -23,6 +23,7 @@
 #include "inic_ipc_msg_queue.h"
 #include "wifi_conf.h"
 #include "wifi_performance_monitor.h"
+#include "rtw_core_function.h"
 #define CONFIG_ENABLE_CACHE
 
 /* -------------------------------- Defines --------------------------------- */
@@ -47,23 +48,7 @@ struct ipc_dev_priv {
 	u8 rx_pending_flag; /* host rx pending flag */
 };
 
-struct skb_data {
-	/* starting address must be aligned by 32 bytes for km4 cache. */
-	struct list_head list __attribute__((aligned(32)));
-	unsigned char buf[MAX_SKB_BUF_SIZE];
-	/* to protect ref when to invalid cache, its address must be
-	 * aligned by 32 bytes. */
-	atomic_t ref __attribute__((aligned(32)));
-};
-
-struct skb_buf {
-	struct list_head list;
-	struct sk_buff skb;
-	u8 rsvd[10];
-};
-
 /* -------------------------- Function declaration -------------------------- */
-extern void kfree_skb(struct sk_buff *skb);
 
 /* ---------------------------- Global Variables ---------------------------- */
 
@@ -132,7 +117,7 @@ static void inic_xmit_tasklet_handler(struct ipc_dev_tx_buf *p_xmit_buf)
 	case IPC_WIFI_CMD_XIMT_PKTS:
 		skb = (struct sk_buff *)(p_ipc_msg->msg_addr);
 #ifdef CONFIG_ENABLE_CACHE
-		DCache_Invalidate(((u32)skb - sizeof(struct list_head)), sizeof(struct skb_buf));
+		DCache_Invalidate(((u32)skb - sizeof(struct list_head)), sizeof(struct skb_info));
 		DCache_Invalidate(((u32)skb->head - sizeof(struct list_head)), sizeof(struct skb_data));
 
 #endif /* CONFIG_ENABLE_CACHE */
@@ -140,7 +125,7 @@ static void inic_xmit_tasklet_handler(struct ipc_dev_tx_buf *p_xmit_buf)
 		g_ipc_dev_priv.tx_bytes += skb->len;
 		g_ipc_dev_priv.tx_pkts++;
 		WIFI_MONITOR_TIMER_START(wlan_send_skb_time);
-		wifi_send_skb(p_ipc_msg->msg_len, skb);
+		wifi_if_send_skb(p_ipc_msg->wlan_idx, skb);
 		WIFI_MONITOR_TIMER_END(wlan_send_skb_time, skb->len);
 		break;
 	default:
@@ -224,12 +209,12 @@ void inic_ipc_dev_tx_handler(inic_ipc_ex_msg_t *p_ipc_msg)
 	_queue *p_xmit_queue = NULL;
 	struct ipc_dev_tx_buf *p_xmit_buf = NULL;
 
-	if (!wifi_is_running((unsigned char)p_ipc_msg->msg_len)) {
+	if (!wifi_is_running((unsigned char)p_ipc_msg->wlan_idx)) {
 		/*free skb and return*/
 		struct sk_buff *skb = (struct sk_buff *)p_ipc_msg->msg_addr;
 		skb->busy = 0;
-		struct skb_buf *skb_buf = container_of(skb, struct skb_buf, skb);
-		DCache_Clean((u32)skb_buf, sizeof(struct skb_buf));
+		struct skb_info *skb_info = container_of(skb, struct skb_info, skb);
+		DCache_Clean((u32)skb_info, sizeof(struct skb_info));
 		return;
 	}
 
@@ -247,7 +232,7 @@ void inic_ipc_dev_tx_handler(inic_ipc_ex_msg_t *p_ipc_msg)
 	/* To store the ipc message from host to queue's node. */
 	p_xmit_buf->ipc_msg.event_num = p_ipc_msg->event_num;
 	p_xmit_buf->ipc_msg.msg_addr = p_ipc_msg->msg_addr;
-	p_xmit_buf->ipc_msg.msg_len = p_ipc_msg->msg_len;
+	p_xmit_buf->ipc_msg.wlan_idx = p_ipc_msg->wlan_idx;
 
 	/* enqueue xmit buffer. */
 	inic_enqueue_xmitbuf(p_xmit_buf, p_xmit_queue);
@@ -257,44 +242,6 @@ END:
 	rtw_up_sema(&g_ipc_dev_priv.xmit_sema);
 }
 
-/**
- * @brief  to allocate the skb to store tx data from ipc host.
- * @param  len[in]: length to allocate buffer size.
- * @param  len[idx]: index of wlan interface which want to transmit.
- * @return none.
- */
-void inic_ipc_dev_alloc_tx_skb(int len, int idx)
-{
-	struct sk_buff *skb = NULL;
-	inic_ipc_ex_msg_t ipc_msg = {0};
-
-	if (!wifi_is_running((unsigned char)idx)) {
-		/* set skb to WLAN_IF_NOT_RUNNING to indicate corresponding wlan interface is not running*/
-		ipc_msg.msg_addr = FLAG_WLAN_IF_NOT_RUNNING;
-		goto send_response;
-	}
-
-	skb = rltk_wlan_alloc_skb(len);
-	if (skb == NULL) {
-		//DBG_8195A("Alloc tx buffer Err, alloc_sz %d!!\n\r", len);
-	}
-#ifdef CONFIG_ENABLE_CACHE
-	else {
-		DCache_CleanInvalidate(((u32)skb->head - sizeof(struct list_head)), sizeof(struct skb_data));
-		DCache_CleanInvalidate(((u32)skb - sizeof(struct list_head)), sizeof(struct skb_buf));
-	}
-#endif /* CONFIG_ENABLE_CACHE */
-	ipc_msg.msg_addr = (u32)skb;
-
-send_response:
-	/* response to request skb from host. */
-	ipc_msg.event_num = IPC_WIFI_MSG_ALLOC_SKB;
-	ipc_msg.msg_len = sizeof(struct sk_buff);
-	inic_ipc_ipc_send_msg(&ipc_msg);
-
-	return;
-}
-
 /**
  * @brief  receiving function to send the received data to host.
  * @param  idx_wlan[in]: which port of wifi to set.
@@ -303,16 +250,20 @@ send_response:
 void inic_ipc_dev_recv(int idx)
 {
 	struct sk_buff *skb = NULL;
+	struct skb_info *skb_info = NULL;
+	struct skb_data *skb_data = NULL;
 	inic_ipc_ex_msg_t ipc_msg = {0};
 
-	skb = rltk_wlan_get_recv_skb(idx);
+	skb = wifi_if_get_recv_skb(idx);
 
 	ipc_msg.event_num = IPC_WIFI_EVT_RECV_PKTS;
 	ipc_msg.msg_addr = (u32)skb;
-	ipc_msg.msg_len = idx;
+	ipc_msg.wlan_idx = idx;
 #ifdef CONFIG_ENABLE_CACHE
-	DCache_CleanInvalidate(((u32)skb->head - sizeof(struct list_head)), sizeof(struct skb_data));
-	DCache_CleanInvalidate(((u32)skb - sizeof(struct list_head)), sizeof(struct skb_buf));
+	skb_data =  LIST_CONTAINOR(skb->head, struct skb_data, buf);
+	skb_info =  LIST_CONTAINOR(skb, struct skb_info, skb);
+	DCache_CleanInvalidate(((u32)skb_data), sizeof(struct skb_data));
+	DCache_CleanInvalidate(((u32)skb_info), sizeof(struct skb_info));
 #endif /* CONFIG_ENABLE_CACHE */
 	inic_ipc_ipc_send_msg(&ipc_msg);
 }
@@ -328,13 +279,3 @@ void inic_ipc_dev_rx_done(inic_ipc_ex_msg_t *p_ipc_msg)
 	kfree_skb(skb);
 }
 
-/**
- * @brief  to notice dev rx pending from host.
- * @param  none.
- * @return none.
- */
-void inic_ipc_dev_rx_pending(void)
-{
-	g_ipc_dev_priv.rx_pending_flag = 1;
-	rtw_up_sema(&(g_ipc_dev_priv.rx_done_sema));
-}
diff --git a/os/board/rtl8720e/src/component/wifi/inic/inic_ipc_dev_trx.h b/os/board/rtl8720e/src/component/wifi/inic/inic_ipc_dev_trx.h
old mode 100644
new mode 100755
index d3ea7dd58..2a7c2f280
--- a/os/board/rtl8720e/src/component/wifi/inic/inic_ipc_dev_trx.h
+++ b/os/board/rtl8720e/src/component/wifi/inic/inic_ipc_dev_trx.h
@@ -7,12 +7,10 @@
 #define __INIC_IPC_DEV_TX_H__
 /* -------------------------------- Includes -------------------------------- */
 /* external head files */
-#include "freertos_service.h"
 #include "osdep_service.h"
-#include "platform_stdlib.h"
 #include "platform_opts.h"
-#include "skbuff.h"
-#include "lwip_intf.h"
+#include "rtw_skbuff.h"
+#include "rtw_intf_lwip.h"
 
 /* internal head files */
 #include "inic_ipc.h"
@@ -28,9 +26,7 @@
 /* -------------------------- Function declaration -------------------------- */
 void inic_ipc_dev_init_priv(void);
 void inic_ipc_dev_tx_handler(inic_ipc_ex_msg_t *ipc_msg);
-void inic_ipc_dev_alloc_tx_skb(int len, int idx);
 void inic_ipc_dev_recv(int idx);
-void inic_ipc_dev_scan_done(void);
 void inic_ipc_dev_rx_done(inic_ipc_ex_msg_t *p_ipc_msg);
-void inic_ipc_dev_rx_pending(void);
+
 #endif /* __INIC_IPC_DEV_TX_H__ */
diff --git a/os/board/rtl8720e/src/component/wifi/inic/inic_ipc_device.c b/os/board/rtl8720e/src/component/wifi/inic/inic_ipc_device.c
old mode 100644
new mode 100755
index 6d205bdc2..1ede966f9
--- a/os/board/rtl8720e/src/component/wifi/inic/inic_ipc_device.c
+++ b/os/board/rtl8720e/src/component/wifi/inic/inic_ipc_device.c
@@ -16,9 +16,8 @@
 
 /* -------------------------------- Includes -------------------------------- */
 #include "ameba_soc.h"
-#include "platform_stdlib.h"
 #include "osdep_service.h"
-#include "skbuff.h"
+#include "rtw_skbuff.h"
 
 #include "inic_ipc_dev_trx.h"
 #include "inic_ipc_msg_queue.h"
@@ -44,15 +43,10 @@ static void inic_ipc_dev_task_hdl(inic_ipc_ex_msg_t *p_ipc_msg)
 		 */
 		inic_ipc_dev_tx_handler(p_ipc_msg);
 		break;
-	case IPC_WIFI_MSG_ALLOC_SKB:
-		inic_ipc_dev_alloc_tx_skb(p_ipc_msg->msg_len, p_ipc_msg->msg_addr);
-		break;
 	case IPC_WIFI_MSG_RECV_DONE:
 		inic_ipc_dev_rx_done(p_ipc_msg);
 		break;
-	case IPC_WIFI_MSG_RECV_PENDING:
-		inic_ipc_dev_rx_pending();
-		break;
+
 	default:
 		DBG_8195A("Device Unknown Event(%d)!\n", \
 				  p_ipc_msg->event_num);
@@ -103,9 +97,9 @@ void inic_ipc_dev_event_int_hdl(VOID *Data, u32 IrqStatus, u32 ChanNum)
 	}
 
 	if (ret == _SUCCESS) {
-		p_ipc_msg->msg_len = 0;
+		p_ipc_msg->msg_queue_status = 0;
 	} else {
-		p_ipc_msg->msg_len = IPC_WIFI_MSG_MEMORY_NOT_ENOUGH;
+		p_ipc_msg->msg_queue_status = IPC_WIFI_MSG_MEMORY_NOT_ENOUGH;
 	}
 	/* enqueuing message is seccussful, send acknowledgement to another port*/
 	p_ipc_msg->event_num = IPC_WIFI_MSG_READ_DONE;
@@ -130,7 +124,7 @@ void inic_ipc_init(void)
 }
 
 /* ---------------------------- Global Variables ---------------------------- */
-#if defined(CONFIG_PLATFORM_AMEBALITE) || defined(CONFIG_PLATFORM_AMEBAD2)
+#if defined(CONFIG_PLATFORM_AMEBALITE) || defined(CONFIG_PLATFORM_AMEBAD2) || defined(CONFIG_PLATFORM_AMEBADPLUS)
 IPC_TABLE_DATA_SECTION
 const IPC_INIT_TABLE   ipc_dev_event_table[] = {
 	{IPC_USER_POINT,	inic_ipc_dev_event_int_hdl, (VOID *) NULL, IPC_DIR_MSG_RX, IPC_H2D_WIFI_TRX_TRAN, IPC_RX_FULL},
diff --git a/os/board/rtl8720e/src/component/wifi/inic/inic_ipc_host.c b/os/board/rtl8720e/src/component/wifi/inic/inic_ipc_host.c
old mode 100644
new mode 100755
index 4423a98be..73c8da10a
--- a/os/board/rtl8720e/src/component/wifi/inic/inic_ipc_host.c
+++ b/os/board/rtl8720e/src/component/wifi/inic/inic_ipc_host.c
@@ -44,7 +44,7 @@ static void inic_ipc_host_task_hdl(inic_ipc_ex_msg_t *p_ipc_msg)
 	switch (p_ipc_msg->event_num) {
 	/* receive the data from device */
 	case IPC_WIFI_EVT_RECV_PKTS:
-		inic_ipc_host_rx_handler(p_ipc_msg->msg_len,
+		inic_ipc_host_rx_handler(p_ipc_msg->wlan_idx,
 								 (struct sk_buff *)(p_ipc_msg->msg_addr));
 		break;
 	/* other contrl operations */
@@ -98,9 +98,9 @@ void inic_ipc_host_event_int_hdl(VOID *Data, u32 IrqStatus, u32 ChanNum)
 	}
 
 	if (ret == _SUCCESS) {
-		p_ipc_msg->msg_len = 0;
+		p_ipc_msg->msg_queue_status = 0;
 	} else {
-		p_ipc_msg->msg_len = IPC_WIFI_MSG_MEMORY_NOT_ENOUGH;
+		p_ipc_msg->msg_queue_status = IPC_WIFI_MSG_MEMORY_NOT_ENOUGH;
 	}
 	/* enqueuing message is seccussful, send acknowledgement to another port*/
 	p_ipc_msg->event_num = IPC_WIFI_MSG_READ_DONE;
@@ -123,7 +123,7 @@ void inic_ipc_init_host(VOID)
 	inic_ipc_host_init_priv();
 }
 /* ---------------------------- Global Variables ---------------------------- */
-#if defined(CONFIG_PLATFORM_AMEBALITE) || defined(CONFIG_PLATFORM_AMEBAD2)
+#if defined(CONFIG_PLATFORM_AMEBALITE) || defined(CONFIG_PLATFORM_AMEBAD2) || defined(CONFIG_PLATFORM_AMEBADPLUS)
 IPC_TABLE_DATA_SECTION
 const IPC_INIT_TABLE   ipc_host_event_table[] = {
 	{IPC_USER_POINT,	inic_ipc_host_event_int_hdl,	(VOID *) NULL, IPC_DIR_MSG_RX, IPC_D2H_WIFI_TRX_TRAN, IPC_RX_FULL},
diff --git a/os/board/rtl8720e/src/component/wifi/inic/inic_ipc_host_api.c b/os/board/rtl8720e/src/component/wifi/inic/inic_ipc_host_api.c
old mode 100644
new mode 100755
index d6687e629..9f19a9c0e
--- a/os/board/rtl8720e/src/component/wifi/inic/inic_ipc_host_api.c
+++ b/os/board/rtl8720e/src/component/wifi/inic/inic_ipc_host_api.c
@@ -12,12 +12,12 @@
 
 ******************************************************************************/
 #include "inic_ipc_api.h"
-#include "wifi_conf.h"
 #include "lwip_netconf.h"
 #include "inic_ipc_cfg.h"
+#include "wifi_ind.h"
 
 /* -------------------------------- Defines --------------------------------- */
-#define CONFIG_INIC_IPC_HOST_API_PRIO 6
+#define CONFIG_INIC_IPC_HOST_API_PRIO 3
 #if defined(CONFIG_ENABLE_WPS) && CONFIG_ENABLE_WPS
 #define HOST_STACK_SIZE 2048
 #else
@@ -76,15 +76,16 @@ static void _inic_ipc_api_host_autoreconnect_handler(inic_ipc_dev_request_messag
 	char *password = (char *)p_ipc_msg->param_buf[3];
 	int password_len = (int)p_ipc_msg->param_buf[4];
 	int key_id = (int)p_ipc_msg->param_buf[5];
+
 	DCache_Invalidate((u32)ssid, ssid_len);
 	DCache_Invalidate((u32)password, password_len);
-
+#if CONFIG_AUTO_RECONNECT
 	if (p_wlan_autoreconnect_hdl) {
 		p_wlan_autoreconnect_hdl(security_type, ssid, ssid_len, password, password_len, key_id);
 	}
+#endif
 }
 
-
 static void _inic_ipc_api_host_eap_autoreconnect_handler(inic_ipc_dev_request_message *p_ipc_msg)
 {
 #ifdef CONFIG_ENABLE_EAP
@@ -274,6 +275,7 @@ void inic_ipc_api_host_task(void)
 		p_ipc_msg->EVENT_ID = 0;
 		DCache_Clean((u32)p_ipc_msg, sizeof(inic_ipc_dev_request_message));
 	} while (1);
+	vTaskDelete(NULL);
 }
 
 /**
@@ -350,7 +352,6 @@ void inic_ipc_api_init_host(VOID)
 	rtw_init_sema(&g_host_inic_api_task_wake_sema, 0);
 	rtw_init_sema(&g_host_inic_api_message_send_sema, 0);
 	rtw_up_sema(&g_host_inic_api_message_send_sema);
-
 	/*for updating ip address before sleep*/
 	pmu_register_sleep_callback(PMU_WLAN_DEVICE, (PSM_HOOK_FUN)_inic_ipc_ip_addr_update_in_wowlan, NULL, NULL, NULL);
 
@@ -421,7 +422,7 @@ void inic_ipc_mp_command(char *token, unsigned int cmd_len, int show_msg)
 #endif
 
 /* ---------------------------- Global Variables ---------------------------- */
-#if defined(CONFIG_PLATFORM_AMEBALITE) || defined(CONFIG_PLATFORM_AMEBAD2)
+#if defined(CONFIG_PLATFORM_AMEBALITE) || defined(CONFIG_PLATFORM_AMEBAD2) || defined(CONFIG_PLATFORM_AMEBADPLUS)
 IPC_TABLE_DATA_SECTION
 const IPC_INIT_TABLE   ipc_api_host_table[] = {
 	{IPC_USER_POINT,	inic_ipc_api_host_int_hdl,	(VOID *) NULL, IPC_DIR_MSG_RX, IPC_D2H_WIFI_API_TRAN, IPC_RX_FULL},
diff --git a/os/board/rtl8720e/src/component/wifi/inic/inic_ipc_host_trx.c b/os/board/rtl8720e/src/component/wifi/inic/inic_ipc_host_trx.c
old mode 100644
new mode 100755
index 10f2e1ce2..c0274c35b
--- a/os/board/rtl8720e/src/component/wifi/inic/inic_ipc_host_trx.c
+++ b/os/board/rtl8720e/src/component/wifi/inic/inic_ipc_host_trx.c
@@ -56,21 +56,6 @@ struct host_priv {
 	u8 rsvd[16]; /* keep total size 64B alignment */
 };
 
-struct skb_data {
-	/* starting address must be aligned by 32 bytes for km4 cache. */
-	struct list_head list __attribute__((aligned(32)));
-	unsigned char buf[MAX_SKB_BUF_SIZE];
-	/* to protect ref when to invalid cache, its address must be
-	 * aligned by 32 bytes. */
-	atomic_t ref __attribute__((aligned(32)));
-};
-
-struct skb_buf {
-	struct list_head list;
-	struct sk_buff skb;
-	u8 rsvd[10];
-};
-
 /* -------------------------- Function declaration -------------------------- */
 
 /* ---------------------------- Global Variables ---------------------------- */
@@ -81,8 +66,8 @@ struct host_priv g_inic_host_priv __attribute__((aligned(64)));
 struct sk_buff *allocated_tx_skb = NULL;
 struct task_struct inic_ipc_host_rx_task;
 
-struct skb_data host_skb_data[HOST_SKB_NUM] __attribute__((aligned(64)));
-struct skb_buf host_skb_buf[HOST_SKB_NUM] __attribute__((aligned(64)));
+struct skb_data *host_skb_data;
+struct skb_info *host_skb_info;
 
 /* ---------------------------- Private Functions --------------------------- */
 /**
@@ -141,6 +126,7 @@ static void inic_ipc_host_rx_tasklet(void)
 	_queue *recv_queue = NULL;
 	struct pbuf *p_buf = NULL;
 	int index = 0;
+	err_enum_t error = ERR_OK;
 	inic_ipc_ex_msg_t ipc_msg = {0};
 
 	recv_queue = &g_inic_host_priv.recv_queue;
@@ -175,6 +161,7 @@ static void inic_ipc_host_rx_tasklet(void)
 			inic_ipc_ipc_send_msg(&ipc_msg);
 		}
 	} while (1);
+
 }
 
 /**
@@ -194,7 +181,7 @@ static int inic_ipc_host_send_skb(int idx, struct sk_buff *skb)
 
 	ipc_msg.event_num = IPC_WIFI_CMD_XIMT_PKTS;
 	ipc_msg.msg_addr = (u32)skb;
-	ipc_msg.msg_len = idx;
+	ipc_msg.wlan_idx = idx;
 	inic_ipc_ipc_send_msg(&ipc_msg);
 
 	return 0;
@@ -208,9 +195,33 @@ static int inic_ipc_host_send_skb(int idx, struct sk_buff *skb)
  */
 void inic_ipc_host_init_skb(void)
 {
-	rtw_memset(host_skb_buf, 0, HOST_SKB_NUM * sizeof(struct skb_buf));
-	rtw_memset(host_skb_data, 0, HOST_SKB_NUM * sizeof(struct skb_data));
+	if (host_skb_info || host_skb_data) {
+		DBG_8195A("host_skb_info or host_skb_data not mfree|\n");
+		return;
+	}
+
+	host_skb_info = (struct skb_info *)rtw_zmalloc(skb_num_ap * sizeof(struct skb_info));
+	host_skb_data = (struct skb_data *)rtw_zmalloc(skb_num_ap * sizeof(struct skb_data));
+	if (!host_skb_info || !host_skb_data) {
+		DBG_8195A("%s=>skb malloc fail!\n\r", __func__);
+	}
+
+	/*make sure the real memory is set to zero, or DCache_Invalidate in inic_ipc_host_send will get wrong values*/
+	DCache_Clean((u32)host_skb_info, (skb_num_ap * sizeof(struct skb_info)));
+	DCache_Clean((u32)host_skb_data, (skb_num_ap * sizeof(struct skb_data)));
+}
+
+void inic_ipc_host_deinit_skb(void)
+{
+	if (host_skb_info) {
+		rtw_mfree((u8 *)host_skb_info, skb_num_ap * sizeof(struct skb_info));
+	}
+
+	if (host_skb_data) {
+		rtw_mfree((u8 *)host_skb_data, skb_num_ap * sizeof(struct skb_data));
+	}
 }
+
 /**
  * @brief  to initialize the parameters of recv.
  * @param  none
@@ -259,7 +270,7 @@ void inic_ipc_host_rx_handler(int idx_wlan, struct sk_buff *skb)
 	recv_queue = &(g_inic_host_priv.recv_queue);
 
 #ifdef CONFIG_ENABLE_CACHE
-	DCache_Invalidate(((u32)skb - sizeof(struct list_head)), sizeof(struct skb_buf));
+	DCache_Invalidate(((u32)skb - sizeof(struct list_head)), sizeof(struct skb_info));
 	DCache_Invalidate(((u32)skb->head - sizeof(struct list_head)), sizeof(struct skb_data));
 #endif /* CONFIG_ENABLE_CACHE */
 
@@ -296,7 +307,7 @@ RSP:
 	/*need cache clean here even if NP only need free skb,
 	because AP may occur cache full issue and flush to skb to memory, but list in skb is old*/
 	DCache_CleanInvalidate(((u32)skb->head - sizeof(struct list_head)), sizeof(struct skb_data));
-	DCache_CleanInvalidate(((u32)skb - sizeof(struct list_head)), sizeof(struct skb_buf));
+	DCache_CleanInvalidate(((u32)skb - sizeof(struct list_head)), sizeof(struct skb_info));
 #endif /* CONFIG_ENABLE_CACHE */
 
 	ipc_msg.event_num = IPC_WIFI_MSG_RECV_DONE;
@@ -332,9 +343,9 @@ int inic_ipc_host_send(int idx, struct eth_drv_sg *sg_list, int sg_len,
 {
 	WIFI_MONITOR_TIMER_START(wlan_send_time);
 	struct sk_buff *skb = NULL;
-	struct skb_buf *skb_buf = NULL;
+	struct skb_info *skb_info = NULL;
 	struct eth_drv_sg *psg_list;
-	unsigned char *skb_data = NULL;
+	struct skb_data *skb_data = NULL;
 	int ret = 0, i = 0;
 	static int used_skb_num = 0;
 	int size = 0;
@@ -343,9 +354,9 @@ int inic_ipc_host_send(int idx, struct eth_drv_sg *sg_list, int sg_len,
 
 	/* allocate the skb buffer */
 
-	skb_buf = &host_skb_buf[used_skb_num];
-	skb = &host_skb_buf[used_skb_num].skb;
-	DCache_Invalidate((u32)skb_buf, sizeof(struct skb_buf));
+	skb_info = &host_skb_info[used_skb_num];
+	skb = &host_skb_info[used_skb_num].skb;
+	DCache_Invalidate((u32)skb_info, sizeof(struct skb_info));
 	if (skb->busy) {
 		/*AP doesn't have enough skb right now, taskdelay here will directly
 		block tcpip thred, so return ERR_BUF to inform upper layer*/
@@ -354,17 +365,17 @@ int inic_ipc_host_send(int idx, struct eth_drv_sg *sg_list, int sg_len,
 	}
 	memset(skb, '\0', sizeof(struct sk_buff));
 	size = SKB_DATA_ALIGN(total_len + SKB_DATA_ALIGN(SKB_WLAN_TX_EXTRA_LEN));
-	skb_data = host_skb_data[used_skb_num].buf;
-	skb->head = skb_data;
-	skb->end = skb_data + size;
-	skb->data = skb_data + SKB_DATA_ALIGN(SKB_WLAN_TX_EXTRA_LEN);
-	skb->tail = skb_data + SKB_DATA_ALIGN(SKB_WLAN_TX_EXTRA_LEN);
+	skb_data = &host_skb_data[used_skb_num];
+	skb->head = skb_data->buf;
+	skb->end = skb_data->buf + size;
+	skb->data = skb_data->buf + SKB_DATA_ALIGN(SKB_WLAN_TX_EXTRA_LEN);
+	skb->tail = skb_data->buf + SKB_DATA_ALIGN(SKB_WLAN_TX_EXTRA_LEN);
 	skb->busy = 1;
 	skb->no_free = 1;
-	atomic_set(&LIST_CONTAINOR(skb->head, struct skb_data, buf)->ref, 1);
+	atomic_set(&skb_data->ref, 1);
 
 	used_skb_num++;
-	used_skb_num = used_skb_num % HOST_SKB_NUM;
+	used_skb_num = used_skb_num % skb_num_ap;
 
 	psg_list = sg_list;
 	for (i = 0; i < sg_len; i++) {
@@ -376,9 +387,10 @@ int inic_ipc_host_send(int idx, struct eth_drv_sg *sg_list, int sg_len,
 	}
 
 #ifdef CONFIG_ENABLE_CACHE
-	DCache_CleanInvalidate(((u32)skb->head - sizeof(struct list_head)), sizeof(struct skb_data));
-	DCache_CleanInvalidate(((u32)skb - sizeof(struct list_head)), sizeof(struct skb_buf));
+	DCache_CleanInvalidate((u32)skb_data, sizeof(struct skb_data));
+	DCache_CleanInvalidate((u32)skb_info, sizeof(struct skb_info));
 #endif /* CONFIG_ENABLE_CACHE */
+
 	WIFI_MONITOR_TIMER_START(wlan_send_time3);
 	inic_ipc_host_send_skb(idx, skb);
 	WIFI_MONITOR_TIMER_END(wlan_send_time3, total_len);
diff --git a/os/board/rtl8720e/src/component/wifi/inic/inic_ipc_host_trx.h b/os/board/rtl8720e/src/component/wifi/inic/inic_ipc_host_trx.h
old mode 100644
new mode 100755
index 4671630b8..bdbf93c5c
--- a/os/board/rtl8720e/src/component/wifi/inic/inic_ipc_host_trx.h
+++ b/os/board/rtl8720e/src/component/wifi/inic/inic_ipc_host_trx.h
@@ -7,11 +7,9 @@
 #define __INIC_IPC_HOST_TRX_H__
 /* -------------------------------- Includes -------------------------------- */
 /* external head files */
-//#include "freertos_service.h"
 #include "osdep_service.h"
-#include "platform_stdlib.h"
 #include "platform_opts.h"
-#include "skbuff.h"
+#include "rtw_skbuff.h"
 //#include "ethernetif.h"
 #include "lwip_netconf.h"
 
@@ -22,16 +20,10 @@
 #define SKB_DATA_ALIGN(X)	(((X) + (4 - 1)) & ~(4 - 1))
 
 /* -------------------------------- Macros ---------------------------------- */
-#ifdef CONFIG_HIGH_TP_TEST
-#define HOST_SKB_NUM 5
-#else
-#define HOST_SKB_NUM 4
-#endif
-#define SKB_WLAN_TX_EXTRA_LEN 74
-
 /* ------------------------------- Data Types ------------------------------- */
 
 /* ---------------------------- Global Variables ---------------------------- */
+extern int skb_num_ap;
 
 /* -------------------------- Function declaration -------------------------- */
 void inic_ipc_host_init_skb(void);
diff --git a/os/board/rtl8720e/src/component/wifi/inic/inic_ipc_msg_queue.c b/os/board/rtl8720e/src/component/wifi/inic/inic_ipc_msg_queue.c
old mode 100644
new mode 100755
index 2a1eb3d22..525171319
--- a/os/board/rtl8720e/src/component/wifi/inic/inic_ipc_msg_queue.c
+++ b/os/board/rtl8720e/src/component/wifi/inic/inic_ipc_msg_queue.c
@@ -178,7 +178,6 @@ void inic_ipc_msg_q_init(void (*task_hdl)(inic_ipc_ex_msg_t *))
 
 	/* initialize queue. */
 	rtw_init_queue(&(g_ipc_msg_q_priv.msg_queue));
-
 	/* assign the haddle function for the task */
 	g_ipc_msg_q_priv.task_hdl = task_hdl;
 
@@ -186,17 +185,14 @@ void inic_ipc_msg_q_init(void (*task_hdl)(inic_ipc_ex_msg_t *))
 	rtw_init_sema(&g_ipc_msg_q_priv.msg_q_sema, 0);
 	rtw_init_sema(&g_ipc_msg_q_priv.msg_send_sema, 0);
 	rtw_up_sema(&g_ipc_msg_q_priv.msg_send_sema);
-
 	for (i = 0; i < IPC_MSG_QUEUE_DEPTH; i++) {
 		g_ipc_msg_q_priv.ipc_msg_pool[i].is_used = 0;
 	}
 	g_ipc_msg_q_priv.queue_free = IPC_MSG_QUEUE_DEPTH;
-
 	/* Initialize the queue task */
 	if (rtw_create_task(&ipc_msgQ_wlan_task, (const char *const)"inic_msg_q_task", 1024, (0 + CONFIG_INIC_IPC_MSG_Q_PRI), (void*)inic_ipc_msg_q_task, NULL) != 1) {
 		DBG_8195A("Create inic_ipc_msg_q_task Err!!\n");
 	}
-
 	/* sign the queue is working */
 	g_ipc_msg_q_priv.b_queue_working = 1;
 }
@@ -232,7 +228,8 @@ sint inic_ipc_msg_enqueue(inic_ipc_ex_msg_t *p_ipc_msg)
 	/* To store the ipc message to queue's node. */
 	p_node->ipc_msg.event_num = p_ipc_msg->event_num;
 	p_node->ipc_msg.msg_addr = p_ipc_msg->msg_addr;
-	p_node->ipc_msg.msg_len = p_ipc_msg->msg_len;
+	p_node->ipc_msg.msg_queue_status = p_ipc_msg->msg_queue_status;
+	p_node->ipc_msg.wlan_idx = p_ipc_msg->wlan_idx;
 	p_node->is_used = 1;
 
 	/* put the ipc message to the queue */
@@ -287,7 +284,7 @@ u8 inic_ipc_msg_get_queue_status(void)
  */
 void inic_ipc_ipc_send_msg(inic_ipc_ex_msg_t *p_ipc_msg)
 {
-	IPC_MSG_STRUCT g_inic_ipc_msg;
+	IPC_MSG_STRUCT g_inic_ipc_msg = {0};
 
 	u32 cnt = 100000;
 
@@ -305,14 +302,15 @@ void inic_ipc_ipc_send_msg(inic_ipc_ex_msg_t *p_ipc_msg)
 	}
 	/* Get the warning of queue's depth not enough after recv MSG_READ_DONE,
 	delay send the next message */
-	if (g_inic_ipc_ex_msg.msg_len == IPC_WIFI_MSG_MEMORY_NOT_ENOUGH) {
+	if (g_inic_ipc_ex_msg.msg_queue_status == IPC_WIFI_MSG_MEMORY_NOT_ENOUGH) {
 		rtw_mdelay_os(1);
 	}
 
 	/* Send the new message after last one acknowledgement */
 	g_inic_ipc_ex_msg.event_num = p_ipc_msg->event_num;
 	g_inic_ipc_ex_msg.msg_addr = p_ipc_msg->msg_addr;
-	g_inic_ipc_ex_msg.msg_len = p_ipc_msg->msg_len;
+	g_inic_ipc_ex_msg.msg_queue_status = p_ipc_msg->msg_queue_status;
+	g_inic_ipc_ex_msg.wlan_idx = p_ipc_msg->wlan_idx;
 	DCache_Clean((u32)&g_inic_ipc_ex_msg, sizeof(inic_ipc_ex_msg_t));
 
 #ifdef IPC_DIR_MSG_TX
diff --git a/os/board/rtl8720e/src/component/wifi/inic/inic_ipc_msg_queue.h b/os/board/rtl8720e/src/component/wifi/inic/inic_ipc_msg_queue.h
old mode 100644
new mode 100755
index e094a6293..2a8fa30c4
--- a/os/board/rtl8720e/src/component/wifi/inic/inic_ipc_msg_queue.h
+++ b/os/board/rtl8720e/src/component/wifi/inic/inic_ipc_msg_queue.h
@@ -7,11 +7,9 @@
 #define __INIC_IPC_MSG_QUEUE_H__
 /* -------------------------------- Includes -------------------------------- */
 /* external head files */
-//#include "freertos_service.h"
 #include "osdep_service.h"
-#include "platform_stdlib.h"
 #include "platform_opts.h"
-#include "skbuff.h"
+#include "rtw_skbuff.h"
 
 /* internal head files */
 #include "inic_ipc.h"
diff --git a/os/board/rtl8720e/src/component/wifi/promisc/wifi_conf_promisc.c b/os/board/rtl8720e/src/component/wifi/promisc/wifi_conf_promisc.c
old mode 100644
new mode 100755
index 6aac83347..d8c733ba4
--- a/os/board/rtl8720e/src/component/wifi/promisc/wifi_conf_promisc.c
+++ b/os/board/rtl8720e/src/component/wifi/promisc/wifi_conf_promisc.c
@@ -1,13 +1,8 @@
 //----------------------------------------------------------------------------//
-//#include <flash/stm32_flash.h>
-#if !defined(CONFIG_MBED_ENABLED) && !defined(CONFIG_PLATFOMR_CUSTOMER_RTOS)
 #include "main.h"
-#endif
 #include <platform_stdlib.h>
 #include <wifi_conf.h>
 #include <wifi_ind.h>
-#include <osdep_service.h>
-#include <device_lock.h>
 
 
 /******************************************************
diff --git a/os/board/rtl8720e/src/component/wifi/promisc/wifi_promisc.c b/os/board/rtl8720e/src/component/wifi/promisc/wifi_promisc.c
old mode 100644
new mode 100755
index b94ad06fa..d1413a7d9
--- a/os/board/rtl8720e/src/component/wifi/promisc/wifi_promisc.c
+++ b/os/board/rtl8720e/src/component/wifi/promisc/wifi_promisc.c
@@ -1,17 +1,15 @@
-#if !defined(CONFIG_MBED_ENABLED) && !defined(CONFIG_PLATFOMR_CUSTOMER_RTOS)
 #include "main.h"
 #if defined(CONFIG_LWIP_LAYER) && CONFIG_LWIP_LAYER
 #include "tcpip.h"
 #endif
-#endif
 #include <osdep_service.h>
 #include "wifi_conf.h"
+#include "rtw_drv_api.h"
 #ifndef CONFIG_WLAN
 #define CONFIG_WLAN 1
 #endif
 
 #if CONFIG_WLAN
-#include <platform_stdlib.h>
 
 #ifndef CONFIG_UNSUPPORT_PLCPHDR_RPT
 #define CONFIG_UNSUPPORT_PLCPHDR_RPT 0
@@ -19,19 +17,6 @@
 
 extern void _promisc_deinit(void *padapter);
 extern int _promisc_recv_func(void *padapter, void *rframe);
-extern int _promisc_set(rtw_rcr_level_t enabled, void (*callback)(unsigned char *, unsigned int, void *), unsigned char len_used);
-extern unsigned char _is_promisc_enabled(void);
-extern int _promisc_get_fixed_channel(void *fixed_bssid, u8 *ssid, int *ssid_length);
-extern void _promisc_filter_by_ap_and_phone_mac(u8 enable, void *ap_mac, void *phone_mac);
-extern int _promisc_recv_lens_func(void *padapter, u8 *payload, u8 plen);
-extern int _promisc_filter_with_len(u16 len);
-extern int _promisc_filter_retransmit_plcp_pkt(u8 enable, u8 filter_interval_ms);
-extern int _promisc_set_mgntframe(u8 enable);
-extern int _promisc_get_chnl_by_bssid(u8 *bssid);
-extern void _promisc_update_candi_ap_rssi_avg(s8 rssi, u8 cnt);
-extern void _promisc_stop_tx_beacn(void);
-extern void _promisc_resume_tx_beacn(void);
-extern void _promisc_issue_probersp(unsigned char *da);
 // Add extra interfaces to make release sdk able to determine promisc API linking
 void promisc_deinit(void *padapter)
 {
diff --git a/os/board/rtl8720e/src/component/wifi/promisc/wifi_promisc_inic_ipc.c b/os/board/rtl8720e/src/component/wifi/promisc/wifi_promisc_inic_ipc.c
old mode 100644
new mode 100755
index 975c7f197..44b52f860
--- a/os/board/rtl8720e/src/component/wifi/promisc/wifi_promisc_inic_ipc.c
+++ b/os/board/rtl8720e/src/component/wifi/promisc/wifi_promisc_inic_ipc.c
@@ -1,8 +1,7 @@
-#if !defined(CONFIG_MBED_ENABLED) && !defined(CONFIG_PLATFOMR_CUSTOMER_RTOS) && !defined(CONFIG_PLATFORM_TIZENRT_OS)
+
 #include "main.h"
 #if CONFIG_LWIP_LAYER
-#include "tcpip.h"
-#endif
+//#include "tcpip.h"
 #endif
 
 #include <osdep_service.h>
@@ -15,7 +14,6 @@
 #include "inic_ipc_api.h"
 #endif
 #if CONFIG_WLAN
-#include <platform_stdlib.h>
 
 #ifndef CONFIG_UNSUPPORT_PLCPHDR_RPT
 #define CONFIG_UNSUPPORT_PLCPHDR_RPT 0
@@ -25,22 +23,6 @@
 void (*ipc_promisc_callback)(unsigned char *, unsigned int, void *userdata) = NULL;
 //#endif
 
-extern void _promisc_deinit(void *padapter);
-extern int _promisc_recv_func(void *padapter, void *rframe);
-extern int _promisc_set(rtw_rcr_level_t enabled, void (*callback)(unsigned char *, unsigned int, void *), unsigned char len_used);
-extern unsigned char _is_promisc_enabled(void);
-extern int _promisc_get_fixed_channel(void *fixed_bssid, u8 *ssid, int *ssid_length);
-extern void _promisc_filter_by_ap_and_phone_mac(u8 enable, void *ap_mac, void *phone_mac);
-extern int _promisc_recv_lens_func(void *padapter, u8 *payload, u8 plen);
-extern int _promisc_filter_with_len(u16 len);
-extern int _promisc_filter_retransmit_plcp_pkt(u8 enable, u8 filter_interval_ms);
-extern int _promisc_set_mgntframe(u8 enable);
-extern int _promisc_get_chnl_by_bssid(u8 *bssid);
-extern void _promisc_update_candi_ap_rssi_avg(s8 rssi, u8 cnt);
-extern void _promisc_stop_tx_beacn(void);
-extern void _promisc_resume_tx_beacn(void);
-extern void _promisc_issue_probersp(unsigned char *da);
-// Add extra interfaces to make release sdk able to determine promisc API linking
 #if 0//only in NP,INIC_IPC_API_TODO
 void promisc_deinit(void *padapter)
 {
@@ -564,7 +546,7 @@ void cmd_promisc(int argc, char **argv)
 		//promisc_test(duration, 0);
 	{
 		promisc_test_all(duration, 0);
-	} else if ((argc == 3) && ((duration = atoi(argv[1])) > 0) && (strcmp(argv[2], "with_len") == 0) && (duration < 0x7FFFFFFF)) {
+	} else if ((argc == 3) && ((duration = atoi(argv[1])) > 0) && (strcmp(argv[2], "with_len") == 0)) {
 		promisc_test(duration, 1);
 	} else {
 		printf("\n\rUsage: %s DURATION_SECONDS [with_len]", argv[0]);
diff --git a/os/board/rtl8720e/src/component/wifi/wifi_config/wifi_simple_config.c b/os/board/rtl8720e/src/component/wifi/wifi_config/wifi_simple_config.c
old mode 100644
new mode 100755
index 77f87d1d8..50b6a33fb
--- a/os/board/rtl8720e/src/component/wifi/wifi_config/wifi_simple_config.c
+++ b/os/board/rtl8720e/src/component/wifi/wifi_config/wifi_simple_config.c
@@ -9,25 +9,17 @@
 #include <sockets.h>
 #include <lwip_netconf.h>
 #endif
-#include <osdep_service.h>
-#include "platform_stdlib.h"
+#include "rtw_adapter.h"
 #include "wifi_simple_config_parser.h"
 #include "wifi_simple_config.h"
 #include "wifi_conf.h"
-
-#if defined(CONFIG_PLATFORM_8721D) || defined(CONFIG_PLATFORM_8710C) || defined(CONFIG_PLATFORM_AMEBAD2) || defined(CONFIG_PLATFORM_8735B) || defined(CONFIG_PLATFORM_AMEBALITE) || defined(CONFIG_PLATFORM_AMEBADPLUS)
-#include "platform_opts_bt.h"
-#endif
+#include "wifi_ind.h"
 
 #if defined(CONFIG_BT_CONFIG) && CONFIG_BT_CONFIG
 #include "bt_config_wifi.h"
 #include "bt_config_app_main.h"
 #endif
 
-#if (defined(CONFIG_EXAMPLE_UART_ATCMD) && CONFIG_EXAMPLE_UART_ATCMD) || (defined(CONFIG_EXAMPLE_SPI_ATCMD) && CONFIG_EXAMPLE_SPI_ATCMD)
-#include "atcmd_wifi.h"
-#endif
-
 #define WIFI_MESH_EN	0
 #define SC_SOFTAP_EN      1 // on/off softAP mode
 #define STACKSIZE         512
@@ -56,6 +48,9 @@ extern u32 _ntohl(u32 n);
 #if CONFIG_WLAN
 #if (CONFIG_INCLUDE_SIMPLE_CONFIG)
 #include "wifi_conf.h"
+
+#define EAGAIN 11
+
 int is_promisc_callback_unlock = 0;
 int is_fixed_channel;
 int fixed_channel_num;
@@ -162,10 +157,6 @@ struct rtk_test_sc *backup_sc_ctx;
 static int pin_enable = 0;
 static int scan_start = 0;
 
-#ifdef RTW_PACK_STRUCT_USE_INCLUDES
-#include "pack_begin.h"
-#endif
-RTW_PACK_STRUCT_BEGIN
 struct ack_msg_scan {
 	u8_t flag;
 	u16_t length;
@@ -175,12 +166,7 @@ struct ack_msg_scan {
 	u32_t device_ip;
 	u8_t device_name[64];
 	u8_t pin_enabled;
-}
-RTW_PACK_STRUCT_STRUCT;
-RTW_PACK_STRUCT_END
-#ifdef RTW_PACK_STRUCT_USE_INCLUDES
-#include "pack_end.h"
-#endif
+} _PACKED_;
 
 static void set_device_name(char *device_name, int max_size)
 {
@@ -205,10 +191,6 @@ void SC_scan_thread(void *para)
 	socklen_t fromLen = sizeof(from);
 	struct ack_msg_scan ack_msg;
 
-#ifdef RTW_PACK_STRUCT_USE_INCLUDES
-#include "pack_begin.h"
-#endif
-	RTW_PACK_STRUCT_BEGIN
 	struct scan_msg {
 		unsigned char 	flag;
 		unsigned short 	length;
@@ -217,12 +199,7 @@ void SC_scan_thread(void *para)
 		unsigned char 	digest[16];
 		unsigned char 	smac[6];
 		unsigned short 	device_type;
-	};
-	RTW_PACK_STRUCT_STRUCT;
-	RTW_PACK_STRUCT_END
-#ifdef RTW_PACK_STRUCT_USE_INCLUDES
-#include "pack_end.h"
-#endif
+	} _PACKED_;
 
 	struct scan_msg *pMsg;
 
@@ -504,10 +481,8 @@ static int  SC_check_and_show_connection_info(void)
 	vTaskPrioritySet(NULL, tskIDLE_PRIORITY + 1);
 #endif
 
-#if !(defined(CONFIG_EXAMPLE_UART_ATCMD) && CONFIG_EXAMPLE_UART_ATCMD)  || (defined(CONFIG_EXAMPLE_SPI_ATCMD) && CONFIG_EXAMPLE_SPI_ATCMD)
 	wifi_get_setting(STA_WLAN_INDEX, &setting);
 	SC_show_wifi_setting(STA_WLAN_INDEX, &setting);
-#endif
 
 #if CONFIG_LWIP_LAYER
 	if (ret != DHCP_ADDRESS_ASSIGNED) {
@@ -1013,7 +988,7 @@ int sc_set_val2(rtw_network_info_t *wifi)
 			rtw_free_sema(&sc_dsoc_sema);
 			ret = -1;
 		}
-		if (rtw_down_timeout_sema(&sc_dsoc_sema, SSID_SOFTAP_TIMEOUT) == RTW_FALSE) {
+		if (rtw_down_timeout_sema(&sc_dsoc_sema, SSID_SOFTAP_TIMEOUT) == _FAIL) {
 			printf("\nsc callback failed\n");
 			wifi_set_promisc(RTW_PROMISC_DISABLE, NULL, 0);
 			rtw_free_sema(&sc_dsoc_sema);
@@ -1660,7 +1635,7 @@ static void simple_config_channel_control(void *para)
 			//move to simple_config_callback() for assoc req recved before go to here if keep auth and assoc req after promisc_recv_func.
 			//wifi_reg_event_handler(WIFI_EVENT_STA_ASSOC, sc_sta_asso_cb, NULL);
 
-			if (rtw_down_timeout_sema(&sc_sta_assoc_sema, SC_SOFTAP_TIMEOUT) == RTW_FALSE) {
+			if (rtw_down_timeout_sema(&sc_sta_assoc_sema, SC_SOFTAP_TIMEOUT) == _FAIL) {
 				//printf("no sta associated after 10s, start promisc\n");
 				simple_config_softAP_onAuth = 0;
 				wifi_set_promisc(RTW_PROMISC_ENABLE_2, simple_config_callback, 1);
@@ -2075,7 +2050,7 @@ void cmd_simple_config(int argc, char **argv)
 	simple_config_terminate = 0;
 
 #if !SC_SOFTAP_EN
-	wifi_set_mode(RTW_MODE_PROMISC);
+	//wifi_set_mode(RTW_MODE_PROMISC);
 #endif
 
 	if (init_test_data(custom_pin_code) == 0) {
@@ -2092,14 +2067,6 @@ void cmd_simple_config(int argc, char **argv)
 		print_simple_config_result(ret);
 	}
 
-#if (defined(CONFIG_EXAMPLE_UART_ATCMD) && CONFIG_EXAMPLE_UART_ATCMD) || (defined(CONFIG_EXAMPLE_SPI_ATCMD) && CONFIG_EXAMPLE_SPI_ATCMD)
-	if (ret == SC_SUCCESS) {
-		at_printf("\n\r[ATWQ] OK");
-	} else {
-		at_printf("\n\r[ATWQ] ERROR:%d", ret);
-	}
-#endif
-
 #else
 	UNUSED(argc);
 	UNUSED(argv);
diff --git a/os/board/rtl8720e/src/component/wifi/wifi_config/wifi_simple_config_parser.h b/os/board/rtl8720e/src/component/wifi/wifi_config/wifi_simple_config_parser.h
old mode 100644
new mode 100755
index 5fa1a6457..127a30928
--- a/os/board/rtl8720e/src/component/wifi/wifi_config/wifi_simple_config_parser.h
+++ b/os/board/rtl8720e/src/component/wifi/wifi_config/wifi_simple_config_parser.h
@@ -16,7 +16,7 @@ extern "C" {
 #define SIMPLE_CONFIG_PLATFORM_LIB 0
 
 #include "platform_opts.h"
-#include "autoconf.h"
+#include "rtw_wifi_constants.h"
 
 
 
diff --git a/os/board/rtl8720e/src/component/wifi/wifi_fast_connect/wifi_fast_connect.c b/os/board/rtl8720e/src/component/wifi/wifi_fast_connect/wifi_fast_connect.c
old mode 100644
new mode 100755
index 1f006493c..280e5cc43
--- a/os/board/rtl8720e/src/component/wifi/wifi_fast_connect/wifi_fast_connect.c
+++ b/os/board/rtl8720e/src/component/wifi/wifi_fast_connect/wifi_fast_connect.c
@@ -11,14 +11,11 @@ This example demonstrate how to implement wifi fast reconnection
 **/
 #include <platform_opts.h>
 #include <wifi_fast_connect.h>
-#include <wifi_conf.h>
 
 #include "FreeRTOS.h"
 #include <task.h>
-#include <platform_stdlib.h>
 #include "osdep_service.h"
 #include "flash_api.h"
-#include "device_lock.h"
 #if CONFIG_LWIP_LAYER
 #include <lwip_netconf.h>
 #include "system_data_api.h"
@@ -187,8 +184,13 @@ WIFI_RETRY_LOOP:
 		wifi.pscan_option = PSCAN_FAST_SURVEY;
 		wifi.security_type = security_type;
 		//SSID
-		strcpy((char *)wifi.ssid.val, (char *)(data->psk_essid));
 		wifi.ssid.len = strlen((char *)(data->psk_essid));
+		if (wifi.ssid.len > 32) {
+			printf("[FAST_CONNECT] SSID length can't exceed 32\n\r");
+			free(data);
+			return -1;
+		}
+		strncpy((char *)wifi.ssid.val, (char *)(data->psk_essid), sizeof(wifi.ssid.val) - 1);
 
 		switch (security_type) {
 		case RTW_SECURITY_WEP_PSK:
@@ -273,20 +275,6 @@ int check_is_the_same_ap()
 	return ret;
 }
 
-int Erase_Fastconnect_data(void)
-{
-#ifndef CONFIG_USE_FLASHCFG
-	flash_t flash;
-
-	if (p_wifi_do_fast_connect != NULL) {
-		device_mutex_lock(RT_DEV_LOCK_FLASH);
-		flash_erase_sector(&flash, FAST_RECONNECT_DATA);
-		device_mutex_unlock(RT_DEV_LOCK_FLASH);
-	}
-#endif
-	return 0;
-}
-
 /*
 * Usage:
 *       config fast connect related function.
diff --git a/os/board/rtl8720e/src/component/wifi/wifi_fast_connect/wifi_fast_connect.h b/os/board/rtl8720e/src/component/wifi/wifi_fast_connect/wifi_fast_connect.h
old mode 100644
new mode 100755
index 1bf077be7..5f86c3948
--- a/os/board/rtl8720e/src/component/wifi/wifi_fast_connect/wifi_fast_connect.h
+++ b/os/board/rtl8720e/src/component/wifi/wifi_fast_connect/wifi_fast_connect.h
@@ -8,20 +8,21 @@
  *
  *
  ******************************************************************************/
-#include "wifi_structures.h"
+#include "rtw_wifi_constants.h"
+#include "wifi_conf.h"
 #include "main.h"
 
 #ifdef CONFIG_WLAN
-#define IW_PASSPHRASE_MAX_SIZE 64
+#define RTW_PASSPHRASE_MAX_SIZE 64
 //#define FAST_RECONNECT_DATA (0x80000 - 0x1000)
-#define NDIS_802_11_LENGTH_SSID         32
+#define RTW_ESSID_MAX_SIZE         32
 #define A_SHA_DIGEST_LEN		20
 
 
 struct wlan_fast_reconnect {
 	unsigned char version;
-	unsigned char psk_essid[NDIS_802_11_LENGTH_SSID + 4];
-	unsigned char psk_passphrase[IW_PASSPHRASE_MAX_SIZE + 1];
+	unsigned char psk_essid[RTW_ESSID_MAX_SIZE + 4];
+	unsigned char psk_passphrase[RTW_PASSPHRASE_MAX_SIZE + 1];
 	unsigned char wpa_global_PSK[A_SHA_DIGEST_LEN * 2];
 	unsigned int  channel;
 	unsigned int    security_type;
diff --git a/os/board/rtl8720e/src/component/wifi/wifi_fw/amebalite/include/RTL8720E_autoconf.h b/os/board/rtl8720e/src/component/wifi/wifi_fw/amebalite/include/RTL8720E_autoconf.h
deleted file mode 100644
index 146060721..000000000
--- a/os/board/rtl8720e/src/component/wifi/wifi_fw/amebalite/include/RTL8720E_autoconf.h
+++ /dev/null
@@ -1,111 +0,0 @@
-#ifndef _AUTOCONF_H_
-#define _AUTOCONF_H_
-#define CONFIG_FPGA_TEST 1
-
-//2 Main Config
-//3 1.) Chip Select
-
-#define CONFIG_CHIP_SEL RTL8720E_A_CUT_S
-
-#define PAGESIZE_TX                 128
-#define PAGESIZE_RX                 8 // no page size concept, only for 8 byte alignment
-#define TX_PAGE_NUM		    256
-#define SIZE_RX_DESC_MAC            24
-#define SIZE_TX_DESC_MAC            40
-#define MACID_NUM                   16
-
-#define LENGTH_IEEE80211_HDR_3ADDR  24
-
-//security cam
-#define SECCAM_ENTRY_NUM        		32
-#define SECCAM_DIRECT_ENTRY_SIZE          	32
-#define SECCAM_START_ADDR        		0x800 //not used for normal
-/******************************************
-
-    ROM Code Configuration
-
-*******************************************/
-//1 ROM Version
-#if IS_CUT_TEST(CONFIG_CHIP_SEL)
-#define ROM_VERSION   1
-#elif IS_CUT_A(CONFIG_CHIP_SEL)
-#define ROM_VERSION   2
-#elif IS_CUT_B(CONFIG_CHIP_SEL)
-#define ROM_VERSION   3
-#else
-#error "Cut Error"
-#endif  //IS_CUT_TEST(CONFIG_CHIP_SEL)
-#define ROM_VERSION_VERA            0xFF
-#define CONFIG_H2C_LOGO				0
-
-//3 General
-#define CONFIG_TXBEACON_IGNORE_EDCCA	0
-#define CONFIG_TX_PAUSE_DRV_INFO		0
-#define CONFIG_RF_JAGUAR                0   //8723d no support new 3-wire
-#define CONFIG_SW_QUEUE_TX		0
-#define CONFIG_CSI_REPORT			1
-
-//3 PS Related
-#define CONFIG_SAPPS                    0
-#define CONFIG_INACTIVE_PS              0
-#define CONFIG_HW_PS_CTRL               1
-#define CONFIG_BCNEARLY_FIXED		1
-#define CONFIG_BCNEARLY_ADJUST_V1       0       //must not both enable!!
-#define CONFIG_BCNEARLY_ADJUST_V2       0
-#define CONFIG_BCNADJ_LPSOFFLOAD_V1    0   //david_liu,220419
-#define CONFIG_BCNADJ_LPSOFFLOAD_V2    0   //david_liu,220419
-#define CONFIG_BEACON_MODE		1
-#define CONFIG_LPS_Normal		1
-#define CONFIG_PERIOD_CCA		0
-#define CONFIG_S1_NULL1_IVL_PATCH       0
-#define CONFIG_LPS_Offload 		0
-#define CONFIG_LPS_I_TWT 		0
-
-//3 BT Coex Related
-#define CONFIG_BTCOEX                    1//must enable in formal FW
-#define CONFIG_BTMAILBOX                 1//should enable CONFIG_BTCOEX first
-#define CONFIG_BTSCOREBRD                0
-#define CONFIG_ZBMAILBOX                 1
-
-//3 Remote WakeUp
-#define CONFIG_NDP                  0
-#define CONFIG_DELAY_WAKEUP       1
-#define CONFIG_DIG_OFFLOAD 0
-
-//3 Dynamic Mechanism Offload
-#define CONFIG_RATE_ADAPTIVE        1//keep the macro control for some case that need to reduce FW image size
-#define CONFIG_TPBASE_RA			1
-#define CONFIG_RA_PS_MODE           0
-#define CONFIG_POWER_TRAINING_WIL   1
-#define CONFIG_11AC_1SS             0
-#define CONFIG_11AC_2SS             0
-#define CONFIG_11N_1SS				1
-#define CONFIG_11N_2SS				0
-#define CONFIG_RA_MULTI_TRY         1
-#define CONFIG_RA_NSC_CALCULATE     1
-#define CONFIG_RA_SET_RAINFO        1
-#define CONFIG_1SS_SL_GI_MULTI_TRY   1
-
-#define CONFIG_11AC 			(CONFIG_11AC_1SS | CONFIG_11AC_2SS)
-#define CONFIG_11N 				(CONFIG_11N_1SS | CONFIG_11N_2SS)
-
-#define CONFIG_1SS 				(CONFIG_11N_1SS | CONFIG_11AC_1SS)
-#define CONFIG_2SS 				(CONFIG_11N_2SS | CONFIG_11AC_2SS)
-
-//3 //1  Patch Control
-#define CONFIG_TSF_RESET_PATCH          0
-
-//3 //1  Leapy AP
-#define CONFIG_LEAPY_AP          1
-
-
-//1  Debug control
-#define CONFIG_PS_DEBUG                 1
-#define CONFIG_BTCOEX_LOG_DEBUG         0
-#define CONFIG_BTCOEX_SLOT_DEBUG        1
-
-//1 Test & verification control
-#define CONFIG_DV_SIMULATION_TEST		0
-#define CONFIG_H2C2H_LB                         0
-
-#endif  /* #ifndef _AUTOCONF_H_ */
diff --git a/os/board/rtl8720e/src/component/wifi/wifi_fw/amebalite/include/wififw_btconcurr_ram.h b/os/board/rtl8720e/src/component/wifi/wifi_fw/amebalite/include/wififw_btconcurr_ram.h
deleted file mode 100644
index b7da7bfb5..000000000
--- a/os/board/rtl8720e/src/component/wifi/wifi_fw/amebalite/include/wififw_btconcurr_ram.h
+++ /dev/null
@@ -1,494 +0,0 @@
-#ifndef __WIFIFW_BTCONCURR_RAM_H__
-#define __WIFIFW_BTCONCURR_RAM_H__
-
-#ifndef __ASSEMBLY__
-/*--------------------Define --------------------------------------------*/
-#define DefaultTBTTOnPeriod         0xB
-#define MaxTBTTOnPeriod             0x2A
-#define MinTBTTOnPeriod             0x3
-#define NULL_EARLY                  0x3
-#define BTC_BCN_EARLY               DEFAULT_PS_BCN_EARLY + 1
-#define BTC_FLEX_EXT_NUM            3
-#define BTC_IQK_WAIT_CNT            6
-#define BTC_AUTO_SLOT_TIME_THD      30
-
-//for MAILBOX 0x11A4~0x11B7, OUT->WL2BT, IN->BT2WL
-#define REG_MAILBOX_WL2BT_DATA0     0x0
-#define REG_MAILBOX_WL2BT_DATA1     0x4
-#define REG_MAILBOX_WL2BT_RDY       0x8  //bit[0] : OutReady, bit[1] : OutEmptyIntEn
-
-#define REG_MAILBOX_BT2WL_DATA0     0xC
-#define REG_MAILBOX_BT2WL_DATA1     0x10
-#define REG_MAILBOX_BT2WL_RDY       0xA  //bit[0] : InReady, bit[1] : InRdyIntEn
-
-#define BTC_PAN_DURATION_DEFAULT    50
-#define BTC_PAN_DURATION_MAX        80
-#define BTC_PAN_DURATION_MIN        30
-#define BTC_PSPOLL_RTY_TIME         1
-
-#define BTC_INTERVAL_UNDER_100      0
-//TdmaIntervalMode=0: skip n-1 beacons , TdmaInterval: n
-/*For example, BeaconInterval=40ms, we may set h2c 0x69 = 0xB 0x03,
-so we omit 40ms(bcn early) and 80ms(bcn early) but noly care 120ms(bcn early) as slot.*/
-#define BTC_INTERVAL_OVER_100       2
-//TdmaIntervalMode=2: insert n 100ms , TdmaInterval: n,
-/*For example, BeaconInterval=370ms, we may set h2c 0x69 = 0xB 0x83,
-so we use 0ms 100ms(timer) 200ms(timer) 300ms(timer) and 370ms(bcn early) as slots. */
-#define BTC_INTERVAL_SHORT          3
-//TdmaIntervalMode=3: insert n 50ms , TdmaInterval: n,
-/*For example, BeaconInterval=100ms, we may set h2c 0x69 = 0xB 0xc1,
-so we use 0ms 50ms(timer) and 100ms(bcn early) as slots. */
-#define BTC_DEFAULT_INTERVAL        102
-#define BTC_SHORT_INTERVAL          51
-#define BTC_MULTI_SLOT_TIMER        REG_TC3_CTRL
-
-#define LEAK_AP_LIMIT               5
-#define BTC_LEAK_AP_LIMIT           LEAK_AP_LIMIT
-#define BTC_LEAK_AP_EXTEND          5
-
-#define BTC_WAITBCN_TIMER           REG_TC4_CTRL
-#define BTC_RETAIN_BT_SLOT_LEN      120
-
-#define BTC_TIMER_MASK						REG_TC6_CTRL
-
-#define SLOT_WIFI								0
-#define SLOT_BT                     			1
-#define SLOT_DEFAULT                		3
-#define SEL_COEX_TABLE_1            		0x03   //0x6CC[1:0]=2'b11 -> select 0x6C0
-#define SEL_COEX_TABLE_2            		0xFC   //0x6CC[1:0]=2'b00 -> select 0x6C4
-
-#define BTC_TDMA0_3_PIN						_PB_2	//ALite MAC debugport[10]
-#define BTC_TDMA1_4_PIN						_PB_3	//ALite MAC debugport[11]
-#define BTC_TDMA2_5_PIN						_PA_15	//ALite MAC debugport[15]
-#define BTC_TBTT_PIN						_PA_16	//ALite MAC debugport[16]
-
-#define MAX_RANDOM_INDEX					50
-/*--------------------Define Enum---------------------------------------*/
-typedef enum _BTC_Mailbox_CMD_ {
-	_BT_FW_PATCH                      			= 0x0a,
-	_WL_OP_MODE                       			= 0x11,
-	_WIFI_RF_CALIBRATION_EN           		= 0x15,
-	_FORCE_BT_TXPWR                   		= 0x17,
-	_BT_IGNORE_WLAN_ACT               		= 0x1b,
-	_PSD_CONTROL                      			= 0x21,
-	_BT_INFO_REPORT                   		= 0x23,
-	_BT_PSD_REPORT                    		= 0x24,
-	_BT_INFO_REPORT_BY_ITSELF         	= 0x27,
-	_BT_INFO_REPORT_CONTROL           		= 0x28,
-	_BT_SET_TXRETRY_REPORT_PARAMETER  	= 0x29,
-	_BT_SET_PTA_TABLE                 		= 0x2A,
-	_BT_MP_REPORT                     			= 0x30,
-	_BT_PSD_MODE                      			= 0x31,
-	_BT_SET_BT_LNA_CONSTRAINT         	= 0x32,
-	_BT_LOOPBACK                      			= 0x33,
-	_BT_CALIBRATION                   		= 0x34,
-	_INTERNAL_SWITCH                  		= 0x35,
-	_BT_CHECK_WLAN_STATE              		= 0x36,
-	_CHANGE_WIFI_RF_STATE             		= 0x37,
-	_BT_PAGE_SCAN_INTERVAL            		= 0x38,
-	_BT_AUTO_SLOT                     			= 0x39,
-	_MAILBOX_EN                       			= 0x40,
-	_BT_CALIBRATION_FAIL              		= 0x41,
-	_WIFI_TDMA_IN_BT_SLOT             		= 0x42,
-	_WIFI_RPT_TDMA                    		= 0x43
-} BTC_Mailbox_CMD, *PBTC_Mailbox_CMD;
-
-typedef struct _BTC_PsTdma_Parm_ {
-	u8		WifiActive			: 1;
-	u8		TxNull1				: 1;
-	u8  	TxNull1ok 			: 1;
-	u8  	BTCalibration		: 1;
-	u8    	BTChangeType		: 1;
-	u8   	BTConnect 	 		: 1;
-	u8   	BTRptConnect		: 1;
-	u8   	AutoSlotBackup	: 1;
-
-	u8  	BTCalibrationPeriod;
-
-	u8  	BTCTCount			: 4;
-	u8  	BTCTCTh				: 4;
-
-	u32 	AutoSlotTimeBackup;
-	u8  	AutoSlotCnt;
-	u8   	AutoSlotFailCnt;
-	u8   	A2DPEmptyThd;
-	u8   	BCNIvl;
-	u8   	HalfBCNIvl;
-	u8   	WLANPeriodCount;
-	u8    	NullExtensionCount;
-	u8   	NAVTemp;
-	u8    	ValueBackup2;
-
-	u8  	WLANOnPeriod		: 1;
-	u8   	DynamicSlotState	: 2;
-	u8    	PanProtection		: 1;
-	u8   	TdmaChange			: 1;
-	u8   	WLPeriodCntIncrease	: 1;
-	u8   	UnderBCNProtection	: 1;
-	u8   	WifiWindowSlotStart : 1;
-
-	u32 	BtSlotStartTime;
-	u8   	H2cTdmaValue[7];
-	u32  	DACSwingLevel;
-	u32 	DACSwingInitValue;
-	u8   	RAOffsetEn;
-	u8   	RAOffset;
-	u8  	RAOffsetMCS7;
-	u8   	RAOffsetMCS6;
-	u8   	RAOffsetMCS5;
-	u32  	HIDPTATable;
-	u32 	HIDPTATableBackUp;
-	u8  	HIDSlotCnt;
-	u8  	HIDPTATableInterval;
-	u32 	HIDPTATableNew;
-
-	u8   	PanDurUserMode		: 1;
-	u8  	PanDuration				: 7;
-
-	u8   	TxNullCnt;
-	u8   	TxNullRtyCnt;
-	u8   	TxNullOkCnt;
-
-	u8   	TdmaLeakAPModeDisable	: 1;
-	u8   	LeakAPCount           		: 7;
-
-	u8  	LeakAPRxCount;
-	u8   	LeakAPCountForObservation;
-
-	u8   	TdmaIntervalMode		: 2;
-	u8   	TdmaInterval       	: 6;
-	u8   	TdmaIntervalCnt    	: 7;
-	u8  	TdmaTimerFlag      	: 1;
-
-	u8    	TDMASlotToggleCount;
-	u8   	TbttISRCnt;    /*Count the TBTT function called by TBTT ISR but not TDMA.*/
-	u8    	BtSlotLen[20];
-	u8    	BtSlotCnt;
-	u8   	RandomWLSlotCnt;
-} BTC_PsTdma_Parm, *PBTC_PsTdma_Parm;
-
-typedef struct _BTC_Mailbox_Parm_ {
-	u8   	pBuffer[8];
-} BTC_Mailbox_Parm, *PBTC_Mailbox_Parm;
-
-typedef struct _BTC_Scoreboard_Parm_ {
-	u32  	State;
-} BTC_Scoreboard_Parm, *PBTC_Scoreboard_Parm;
-
-/*------------------H2C Define Struct---------------------------------------*/
-/*H2C Index: 0x60*/
-typedef struct _H2C_BT_Tdma_Parm_ {
-	/* B0 */
-	u8  	Enable						: 1;
-	u8    	ValueofReg870InBT       	: 1;    /* 1:0x870 = 0x300, 0:0x870 = 0x310*/
-	u8    	HIDSlotToggle           	: 1;
-	u8   	ValueOfReg870           	: 1;    /* when disable 1:0x870 = 0x310, 0:0x870 = 0x300*/
-	/* when enable 1: 0x860 = 0x110, 0:0x860 = 0x210*/
-	u8   	AutoWakeUp              	: 1;    /* when set 1, use null(0) and null(1) packet*/
-	u8   	NoPS                    		: 1;    /* when set 1, in BT slot will pause WiFi Tx*/
-	u8   	AllowBTHighPriority		: 1;
-	u8   	ValueofReg870InWIFI		: 1;    /* 1:0x870 = 0x300, 0:0x870 = 0x310*/
-	/* B1 */
-	u8  	TBTTOnPeriod;
-	/* B2 */
-	u8  	B2Rsvd0                   		: 2;
-	u8   	PanEnable               		: 1;
-	u8   	B2Rsvd1                  		: 1;
-	u8   	WifiWindowSlot          		: 1;
-	u8   	B2Rsvd2                   		: 3;
-	/* B3 */
-	u8  	NoTxPause               		: 1;
-	u8  	Valueof778InWIFI        	: 1;
-	u8   	Valueof778InWIFIOnSCO	: 1;
-	u8   	ValueofReg778           	: 1;    /* when disable 1: 778=3, 0: 778=1 */
-	/* when enable 1:allow 32k, 0:not allow 32k */
-	u8  	SCOOption               		: 1;
-	u8   	ValueofReg860InWIFI		: 1;
-	u8   	TwoAntenna              	: 1;
-	u8  	ReduceWIFIPower         	: 1;
-	/* B4 */
-	u8 		ExtraDecisionOf778      	: 1;
-	u8   	CCKPriorityToggle       	: 1;
-	u8    	WifiAutoSlot            	: 1;
-	u8    	CTS2Self                		: 1;
-	u8  	ChangeCoexTable         	: 1;
-	u8  	LongNAV                 		: 1;    /* use large NAV to protect BT slot */
-	u8   	DynamicSlot             	: 1;
-	u8   	ValueofReg778B1InBT		: 1;    /* 1:778[1]=1, 0:778[1]=0 in bt */
-	/* B5 */
-	u8  	Rsvd5;
-	/* B6 */
-	u8 		Rsvd6;
-} H2C_BT_Tdma_Parm, *PH2C_BT_Tdma_Parm;
-
-//H2C Index: 0x61
-typedef struct _H2C_BT_Info_Parm_ {
-	u8		Trigger		: 1;
-	u8   	Rsvd0 		: 7;
-	/* B1-B6 */
-	u8   	Rsvd1[6];
-} H2C_BT_Info_Parm, *PH2C_BT_Info_Parm;
-
-/* H2C Index: 0x62 */
-typedef struct _H2C_Force_BT_TxPower_Parm_ {
-	u8 		PowerIndex;
-	//B1-B6
-	u8   	Rsvd1[6];
-} H2C_Force_BT_TxPower_Parm, *PH2C_Force_BT_TxPower_Parm;
-
-/* H2C Index: 0x63 */
-typedef struct _H2C_BT_Ignore_WLACT_Parm_ {
-	u8  	Enable		: 1;
-	u8   	Rsvd0 		: 7;
-	//B1-B6
-	u8  	Rsvd1[6];
-} H2C_BT_Ignore_WLACT_Parm, *PH2C_BT_Ignore_WLACT_Parm;
-
-/* H2C Index: 0x64 */
-typedef struct _H2C_DAC_Swing_Value_Parm_ {
-	u8		Value;
-	//B1-B6
-	u8		Rsvd1[6];
-} H2C_DAC_Swing_Value_Parm, *PH2C_DAC_Swing_Value_Parm;
-
-/* H2C Index: 0x65 */
-typedef struct _H2C_Ant_Sel_Reverse_Parm_ {
-	u8 		AntReverse;
-	u8 		SwitchOutside;
-	//B2-B6
-	u8 		Rsvd2[5];
-} H2C_Ant_Sel_Reverse_Parm, *PH2C_Ant_Sel_Reverse_Parm;
-
-/* H2C Index: 0x66 */
-typedef struct _H2C_WL_Opmode_Parm_ {
-	u8		Opmode;
-	u8  	ChannelIndex;
-	u8   	BandWidth;
-	//B3-B6
-	u8   	Rsvd3[4];
-} H2C_WL_Opmode_Parm, *PH2C_WL_Opmode_Parm;
-
-/* H2C Index: 0x6C */
-typedef struct _H2C_BT_Page_Scan_Interval_Parm_ {
-	u8  	LSB_Interval;
-	u8   	MSB_Interval;
-	//B2-B6
-	u8   	Rsvd2[5];
-} H2C_BT_Page_Scan_Interval_Parm, *PH2C_BT_Page_Scan_Interval_Parm;
-
-/* H2C Index: 0x6D */
-typedef struct _H2C_WL_Calibration_Parm_ {
-	u8   	WLCalibrationEn	: 1;
-	u8    	Rsvd0            		: 7;
-	//B1-B6
-	u8   	Rsvd1[6];
-} H2C_WL_Calibration_Parm, *PH2C_WL_Calibration_Parm;
-
-/* H2C Index: 0x6E */
-typedef struct _H2C_GNTBT_Value_Parm_ {
-	u8  	GntBtValue			: 1;
-	u8    	Rsvd0          		: 7;
-	//B1-B6
-	u8    	Rsvd1[6];
-} H2C_GNTBT_Value_Parm, *PH2C_GNTBT_Value_Parm;
-
-/* H2C Index: 0x6F */
-typedef struct _H2C_BT_OnlyTest_Parm_ {
-	u8 		BTOnlyTest      	: 1;
-	u8   	Rsvd0           		: 7;
-	//B1-B6
-	u8   	Rsvd1[6];
-} H2C_BT_OnlyTest_Parm, *PH2C_BT_OnlyTest_Parm;
-
-/* H2C Index: 0x70 */
-typedef struct _H2C_BT_Init_Parm_ {
-	u8   	Enhance3wireMode	: 1;
-	u8   	HighPowerPAMode		: 1;
-	u8   	DirectBtMode		: 1;
-	u8   	Rsvd0             	: 5;
-	//B1-B6
-	u8    	Rsvd1[6];
-} H2C_BT_Init_Parm, *PH2C_BT_Init_Parm;
-
-/* H2C Index: 0x71 */
-typedef struct _H2C_WL_PortID_Parm_ {
-	u8   	PortID         		: 3;
-	u8   	Rsvd0          		: 5;
-	//B1-B6
-	u8   	Rsvd1[6];
-} H2C_WL_PortID_Parm, *PH2C_WL_PortID_Parm;
-
-typedef enum _BTC_Mailbox_Status_ {
-	_BT_ACTIVE_OUTREADY_NOT_ZERO    = BIT0,
-	_BT_NON_ACTIVE                  = BIT1,
-	_BT_PATCH_TIMEOUT               = BIT2,
-	_BT_CONTENT_ERROR               = BIT3,
-	_BT_CONTENT_CHECKSUM_ERROR      = BIT4,
-} BTC_Mailbox_Status, *PBTC_Mailbox_Status;
-
-typedef enum _BTC_Scoreboard_CMD_ {
-	BTC_SB_BT_ENABLE        = BIT1,
-	BTC_SB_BT_A2DP_STATE    = BIT4,
-	BTC_SB_BT_UNDER_IQK     = BIT5,
-	BTC_SB_BT_IQK_REQ       = BIT6,
-	BTC_SB_BT_LPS           = BIT7,
-	BTC_SB_BT_HID_NOTIFY    = BIT8,
-	BTC_SB_BT_XTAL_WRITE    = BIT15,
-	BTC_SB_BT_EFUSE         = BIT30
-} BTC_Scoreboard_CMD, *PBTC_Scoreboard_CMD;
-
-typedef enum _BTC_BT_PMC_State_ {
-	_BT_IDLE_MODE           = 0,
-	_BT_XTAL_EN_MODE        = 1,
-	_BT_LDO_EN_MODE         = 2,
-	_BT_PLL_EN_MODE         = 3,
-	_BT_ACTIVE_MODE         = 4,
-	_BT_LDO_DIS_MODE        = 5,
-	_BT_LOW_POWER_MODE      = 6,
-	_BT_CAL_EN_MODE         = 10,
-	_BT_CALIBRATE_MODE      = 11,
-	_BT_POWER_DOWN_MODE     = 12,
-	_BT_LP2ACTIVE_MODE      = 13,
-	_BT_AFELDO_MODE         = 14
-} BTC_BT_PMC_State, *PBTC_BT_PMC_State;
-
-typedef enum _BTC_PWRBitOverWrite_State_ {
-	DisablePWRBitOverWrite   = 0,
-	EnablePWRBitOverWrite    = 1,
-	OverWritePWRBit0         = 2,
-	OverWritePWRBit1         = 3
-} BTC_PWRBitOverWrite_State, *PBTC_PWRBitOverWrite_State;
-
-typedef enum _BTC_MultiPort_Role_ {
-	PORT0      = 0,
-	PORT1      = 1,
-	PORT2      = 2,
-	PORT3      = 3,
-	PORT4      = 4
-} BTC_MultiPort_Role, *PBTC_MultiPort_Role;
-
-typedef enum _BTC_TdmaFlexibleExtension_State_ {
-	_BT_TDMA_FLEX_IDLE_STATE = 0,
-	_BT_TDMA_FLEX_NULL_STATE = 1
-} BTC_TdmaFlexibleExtension_State, *PBTC_TdmaFlexibleExtension_State;
-
-typedef enum _BTC_AOAC_Switch_State_ {
-	BTC_AOAC_RF_OFF           = 0,
-	BTC_AOAC_RF_ON            = 1,
-	BTC_AOAC_BT_START_IQK     = 2,
-	BTC_AOAC_BT_STOP_IQK      = 3
-} BTC_AOAC_Switch_State, *PBTC_AOAC_Switch_State;
-
-typedef enum _BTC_Function_Caller_ {
-	TBTT_TDMA                 = 0,
-	TBTT_ISR                  = 1,
-	BCNEARLY_TDMA             = 2,
-	BCNEARLY_ISR              = 3
-} BTC_Function_Caller, *PBTC_Function_Caller;
-
-/* C2H Index: 0x9 */
-typedef enum _C2H_BT_INFO_ {
-	RSP_WIFI_FW             = 0,
-	RSP_WIFI_REQ            = 1,
-	RSP_BT_CHANGE_STS       = 2,
-	RSP_BT_IQK              = 3,
-	RSP_BT_SB               = 4,
-	RSP_BT_RPT_TDMA         = 5,
-	RSP_BT_PSD_REPORT       = 6,
-	RSP_BT_SLOT_LENGTH      = 7
-} C2H_BT_INFO, *PC2H_BT_INFO;
-
-/* H2C Index: 0x69 */
-typedef enum _H2C_BTWIFI_CTRL_ {
-	BT_SET_TXRETRY_REPORT   = 0,
-	BT_SET_PTATABLE         = 1,
-	BT_SET_PSD_MODE         = 2,
-	BT_SET_LNA_CONSTRAINT   = 3,
-	BT_MAILBOX_LB_TEST      = 4,
-	BT_H2C2H_LB_TEST        = 5,
-	BT_RA_RETRYPENALTY      = 6,
-	BT_HID_SLOT_TABLE       = 7,
-	BT_WIFI_RQT_INFO        = 8,
-	BT_SET_PAN_DURATION     = 9,
-	BT_SET_A2DP_EMPTY_THD   = 10,
-	BT_SET_BCN_INTERVAL     = 11,
-	BT_SET_LEAK_AP_MODE     = 12,
-	BT_HID_SLOT_TABLE_2     = 13
-} H2C_BTWIFI_CTRL, *PH2C_BTWIFI_CTRL;
-
-typedef enum _GNTBT_CTRL_ {
-	GNT_HW_PTA        = 0,
-	GNT_SW_LOW        = 1,
-	GNT_SW_HIGH       = 2
-} GNTBT_CTRL, *PGNTBT_CTRL;
-
-/*--------------------Define MACRO--------------------------------------*/
-#define MAILBOX_MAX_LENGTH    7
-/* Mailbox MP Rpt OPCODE */
-#define BTMPRPT_OPCODE_WRITE_ADDR           0x0C
-#define BTMPRPT_OPCODE_WRITE_VALUE          0x0D
-
-/*--------------------Function declaration---------------------------------*/
-extern void H2CHDL_BTInfo_8720E(u8  *pbuf);
-extern void H2CHDL_ForceBTTxpwr_8720E(u8  *pbuf);
-extern void H2CHDL_BTIgnoreWlanAct_8720E(u8   *pbuf);
-extern void H2CHDL_AntSelReverse_8720E(u8   *pbuf);
-extern void H2CHDL_WLOpmode_8720E(u8   *pbuf);
-extern void H2CHDL_BTMpH2C_8720E(u8   *pbuf);
-extern void H2CHDL_BTControl_8720E(u8   *pbuf);
-extern void H2CHDL_BT_Page_Scan_Interval_8720E(u8 *pbuf);
-extern void H2CHDL_GNT_BT_Ctrl_8720E(u8 *pbuf);
-extern void H2CHDL_BT_Only_Test_8720E(u8 *pbuf);
-extern void H2CHDL_WL_Port_ID_8720E(u8 *pbuf);
-extern void C2HBTLoopback_8720E(u8  *pbuf);
-extern void C2HBTMpRpt_8720E(u8  idx, u8  status, u8  req_num);
-extern void C2HBTMailBoxStatus_8720E(u8  status);
-extern void InitBTCoexTimer_8720E(u8 duration);
-extern void Write778_8720E(u8 value);
-extern void TdmaChangeCoexTable_8720E(u8  slot);
-extern void BTNullSetting_8720E(u8  bPowerBit, u16 offset, u8  lsb, u8  msb);
-extern void InitBTMailbox_8720E(void);
-extern BOOLEAN FillMailbox_8720E(u8 cmd, u8 length, u8 *pparm);
-extern void WL2BTMailboxSend_8720E(u8 cmd, u8 length, u8 *pparm);
-extern void BT2WLMailboxINTHDL_8720E(void);
-extern void BT2WLMailboxINTCheck_8720E(void);
-extern void H2CHDL_BTPSTDMA_8720E(u8  *pbuf);
-extern void BTC_PsTdmaActionDelay_8720E(void);
-extern void BTC_PsTdmaAction_8720E(u8  *pbuf);
-extern void H2CHDL_BTWifiCtrl_8720E(u8  *pbuf);
-extern void H2CHDL_WLCalibration_8720E(u8 *pbuf);
-extern void H2CHDL_BT_Init_Param_8720E(u8 *pbuf);
-extern void C2HBTInfo_8720E(u8  option);
-extern void C2HWlanInfo_8720E(void);
-extern void InitBTCoex_8720E(void);
-extern void BT_TDMA_Slot_Operation_0and3_8720E(u8  slot_num);
-extern void BT_TDMA_Slot_Operation_1and4_8720E(u8  slot_num);
-extern void BT_TDMA_Slot_Operation_2and5_8720E(u8  slot_num);
-extern u8 DynamicSlotDecision_8720E(void);
-extern u8 BTypeTDMAMultiSlots_8720E(void);
-extern void BTypeTDMABCNEarly_8720E(u8  type);
-extern void BTypeTDMATBTThdl_8720E(u8  type);
-extern void BTypeTDMALeakAPOperation_8720E(void);
-extern void BTypeTDMATimeOuthdl_8720E(void);
-extern void BTC_RestoreDefaultCoexTable_8720E(void);
-extern void BTC_PWRBitOverWrite_8720E(u8  PortNum, u8  mode);
-extern void BTC_PsTdmaIssueNull_8720E(BOOLEAN Powerbit, u8 PortNum);
-extern void BTC_PsTdmaOnBcn_8720E(void);
-extern void BTC_BtIqkAction_8720E(u8  allow);
-extern BOOLEAN BTC_BtIqkCheck_8720E(void);
-extern void BTC_WlanInfoCounterReset_8720E(void);
-extern BOOLEAN BTC_ProceedBtSlot_8720E(void);
-extern void BTC_ProtectBCN_8720E(void);
-extern void BTC_RestoreBtSlot_8720E(void);
-extern u8 BTC_GenRandomValue_8720E(u8 range, u8 count);
-extern void BTC_WifiWindowSlot_8720E(void);
-extern void IssueBTQNull_8720E(u8  bPowerBit, u8  lsb, u8  msb);
-extern void BTC_Set_GntBt_8720E(u8 control);
-#if CONFIG_BTCOEX_SLOT_DEBUG
-extern void InitBTCoexDebugPort_8720E(void);
-extern void BTC_SlotGpioDbgCtrl_8720E(u32 GPIO_Pin, u32 Val);
-#endif
-extern void BTC_AOACSwitch_8720E(u8  state);
-
-#endif /* #ifndef __ASSEMBLY__ */
-#endif /*  __WIFIFW_BTCONCURR_RAM_H__ */
diff --git a/os/board/rtl8720e/src/component/wifi/wifi_fw/amebalite/include/wififw_cmd_ram.h b/os/board/rtl8720e/src/component/wifi/wifi_fw/amebalite/include/wififw_cmd_ram.h
deleted file mode 100644
index 45767ea8c..000000000
--- a/os/board/rtl8720e/src/component/wifi/wifi_fw/amebalite/include/wififw_cmd_ram.h
+++ /dev/null
@@ -1,526 +0,0 @@
-#ifndef __WIFIFW_CMD_RAM_H__
-#define __WIFIFW_CMD_RAM_H__
-
-/*--------------------Define --------------------------------------------*/
-#define HALBB_START_H2CID	0x40
-#define HALBB_END_H2CID		0x5f
-#define CSICLIENTNUM		0x3
-
-//==================C2H event format ====================
-// Field     SYNC       CMD_LEN     CONTENT    CMD_SEQ      CMD_ID
-// BITS  [127:120]  [119:112]      [111:16]          [15:8]        [7:0]
-typedef struct _C2H_EVT_HDR {
-	u8  cmd_id;
-	u8  cmd_seq;
-	u8  content[32];//change 12B to 32B for FTM C2H
-	u8  cmd_len;
-} C2H_EVT_HDR, *PC2H_EVT_HDR;
-
-//Register C2H Command ID here
-typedef enum _C2H_CMD_ {
-	C2HID_DEBUG								= 0,
-	C2HID_H2C2HLB							= 1,
-	C2HID_TXBF								= 2,
-	C2HID_CCX_TXRPT						= 3,
-	C2HID_AP_REQ_TXRPT					= 4,
-	C2HID_INIT_RATE_COLLECT			= 5,
-	C2HID_PSD_RPT							= 6,
-	C2HID_SCAN_COMPLETE					= 7,
-	C2HID_PSD_CONTROL					= 8,
-	C2HID_BT_INFORMATION				= 9,
-	C2HID_BT_LOOPBACK					= 0x0A,
-	C2HID_BT_MP_REPORT					= 0x0B,
-	C2HID_RA_RPT							= 0x0C,
-	C2HID_SPE_STATIS						= 0x0D,
-	C2HID_RA_PARA_RPT					= 0x0E,
-	C2HID_DTP_RPT							= 0x0F,
-	C2HID_CURRENT_CHANNEL 				= 0x10,
-	C2HID_IQK_OFFLOAD					= 0x11,
-	C2HID_BB_GAIN_REPORT				= 0x12,
-	C2HID_RateAdaptive_RPT_88E		= 0x13,	// for 88e smic RA debug
-	C2HID_GPIOWAKEUP						= 0x14,
-	C2HID_MAILBOX_STATUS				= 0x15,
-	C2HID_H2C_PKT_Response				= 0x16, //mips
-	C2HID_MCC_STATUS 						= 0x17,
-	C2HID_NAN_EVENT						= 0x18,
-	C2HID_Efuse_Hidden_REPORT			= 0x19,
-	C2HID_FTMC2H_RPT						= 0x1B,
-	C2HID_FTMSession_END				= 0x1C,
-	C2HID_DRVFTMC2H_RPT					= 0x1D,
-	C2HID_BCN_EARLY_RPT					= 0x1E,
-	C2HID_ECSA_RPT						= 0x1F,
-	C2HID_TX_PAUSE_RPT					= 0x20,
-	C2HID_MACID_PAUSE_RPT				= 0x21,
-	C2HID_Customer_String_rpt			= 0x24,
-	C2HID_Customer_String_rpt_1		= 0x25,
-	C2HID_WLAN_INFO						= 0x27,
-
-	C2HID_DEBUG_CODE						= 0xFE,
-	C2HID_EXTEND_IND						= 0xFF
-} C2H_CMD, *PC2H_CMD;
-
-/*--------------------Define MACRO--------------------------------------*/
-//3 HMETFR
-#define H2CINTBOX_BITMASK				0xF
-#define H2CINTBOX_NUMMASK				0x3
-#define BIT_PTR_NOMATCH				BIT7
-
-//RXDEC
-#define BIT_MASK_RXDEC_LENGTH		0x3FFF
-#define BIT_RXDEC_C2HINDEX    		BIT4
-
-// H2C
-#define LENGTH_H2C						8
-#define LENGTH_H2C_CMD_HDR			sizeof(H2C_CMD_HDR)
-#define LENGTH_H2C_CONTENT			(LENGTH_H2C -LENGTH_H2C_CMD_HDR)
-#define ADOPT_H2C_VALUE				BIT7
-#define LENGTH_H2C_BUFF				10
-#define H2C_Q_FULL(x, y)				(((((x) == 0) && ((y) == (LENGTH_H2C_BUFF - 1)))||((y) == ((x) - 1))) ? _TRUE : _FALSE)
-#define H2C_Q_EMPTY(x, y)				(((x) == (y)) ? _TRUE : _FALSE)
-#define H2CPTR_REACH_BOTTOM(x)		(((x) == LENGTH_H2C_BUFF) ? _TRUE : _FALSE)
-
-// C2H
-#define LENGTH_C2H						16
-#define LENGTH_C2H_EVT_HDR			2
-#define LENGTH_C2H_LEN_FIELD			1
-#define LENGTH_C2H_SYNC				1
-#define LENGTH_C2H_CONTENT 			(LENGTH_C2H - LENGTH_C2H_EVT_HDR - LENGTH_C2H_LEN_FIELD - LENGTH_C2H_SYNC)
-#define LENGTH_C2H_BUFF				8//10, modified by jackie;
-#define WAIT_C2H_CHECK_CNT 			(1000)
-#define CHECK_C2H_ONCE_TIME 			(10)
-#define C2H_DATA_RDY					0xFF
-#define C2HPTR_REACH_BOTTOM(x)		(((x) == LENGTH_C2H_BUFF) ? _TRUE : _FALSE)
-#define C2H_Q_EMPTY(x, y)				(((x) == (y)) ? _TRUE : _FALSE)
-#define C2H_Q_FULL(x, y)				(((((x) == 0) && ((y) == (LENGTH_C2H_BUFF - 1)))||((y) == ((x) - 1))) ? _TRUE : _FALSE)
-#define C2HPKT_POLL						BIT0
-
-#define MACID_NUM_NEW					(MACID_NUM/8)
-
-/*--------------------Define Struct---------------------------------------*/
-//3 Class5: WOWLAN
-
-//H2C Index: 0x80
-typedef struct _wwlan_enable_ {
-	u8		fun_En: 1;
-	u8		pattern_match_En: 1;
-	u8		magic_pkt_En: 1;
-	u8		unicast_En: 1;
-	u8		All_pkt_drop_En: 1;
-	u8		GPIO_Active_type_En: 1;
-	u8		Rekey_Wakeup_En: 1;
-	u8		Discon_Wakeup_En: 1;
-} WWlan_En, *PWWlan_En;
-
-typedef struct _wwlan_parm_ {
-	WWlan_En		enable;
-
-	u8		gpio_num: 7;
-	u8		DataPinWakeUp: 1;
-
-	u8		gpio_duration;
-	u8		gpio_pulse_en: 1;
-	u8		gpio_pulse_count: 7;
-
-	u8		usbphy_disable: 1;
-	u8		hst2dev_en: 1;
-	u8		gpio_duration_ms: 1;
-	u8		rsvd0: 5;
-	//not H2C from here
-	u8		nullpkt: 1;
-	u8		DriverRdy: 1;
-	u8		rsvd: 6;
-} WWlan_Parm, *PWWlan_Parm;
-
-//H2C Index: 0x81
-typedef struct _remote_wakeup_enable_ {
-	u8		RemoteWakeUpCtrlEn: 1;
-	u8		ArpEn: 1;
-	u8		NdpEn: 1;
-	u8		GtkEn: 1;
-	u8		NLOOffloadEn: 1;
-	u8		RealWoWLanEn: 1;
-	u8		RealWoWLanV2En: 1;
-	u8		MatchApplQQ: 1;
-
-	u8		P2POffloadEn: 1;
-	u8		Runtime_PM_En: 1;
-	u8		NetbiosDropEn: 1;
-	u8 		TkipOffloadEn: 1;
-	u8		TcpSyncDropEn: 1;
-	u8		rsvd: 3;
-
-	u8		ARP_ACTION: 1;
-	u8		rsvd2: 3;
-	u8		FWParsingUntilWakeup: 1;
-	u8		FWParsingAfterWakeup: 1;
-	u8		rsvd3: 2;
-} Remote_wakeup_enable, *PRemote_wakeup_enable;
-
-//H2C Index: 0x82
-typedef struct _AOAC_GLOBAL_INFO_ {
-	u8		PairwiseEncAlg;
-	u8		GroupEncAlg;
-	u8		rsvd[5];
-} AOAC_GLOBAL_INFO, *PAOAC_GLOBAL_INFO;
-
-//H2C Index: 0x83
-typedef struct _AOAC_RSVDPAGE1_ {
-	u8		loc_remoteCtrlInfo;
-	u8		loc_arp;
-	u8		loc_ndp;
-	u8		loc_gtkRsp;
-	u8		loc_gtkInfo;
-	u8		loc_gtkExtMem;
-	u8		loc_ndpInfo;
-} AOAC_RSVDPAGE1, *PAOAC_RSVDPAGE1;
-
-//H2C Index: 0x84
-typedef struct _AOAC_RSVDPAGE2_ {
-	u8		loc_routerSolicitation;
-	u8		loc_bubblePacket;
-	u8		loc_teredoInfo;
-	u8		loc_RealwowInfo;
-	u8		loc_KeepAlivePkt;
-	u8		loc_AckPattern;
-	u8		loc_WakeupPattern;
-} AOAC_RSVDPAGE2, *PAOAC_RSVDPAGE2;
-
-// H2C Index: 0x88
-typedef struct _AOAC_RSVDPAGE3_ {
-	u8		loc_NLOInfo;
-	u8		loc_AOACReport;
-} AOAC_RSVDPAGE3, *PAOAC_RSVDPAGE3;
-
-//H2C Index: 0x3
-typedef struct _keep_alive_parm_ {
-	u8		Enable: 1;
-	u8 		AdoptUserSetting: 1;
-	u8		PktType: 1;
-	u8		DelayKeepalive: 1;
-	u8		rsvd: 3;
-	u8		KeepAliveNullTx: 1;
-
-	u8		KeepAliveCountLimit;
-	u8		KeepAliveCount;
-	u8		SameTBTTRsvdPageCount;
-} KeepAlive_Parm, *PKeepAlive_Parm;
-
-typedef struct _remote_wakeup_ {
-	Remote_wakeup_enable	funcEn;
-	WWlan_Parm	WWlanCtrl;
-	u8		Wakeup: 1;
-	u8		delay_wake_wait: 1;
-	u8		delay_wake_flag: 1;
-	u8		rsvd: 5;
-
-	u8		MACAddr[6];
-	u8		BSSIDAddr[6];
-	u8		Debug[7];
-	u8		AntSwitchOutside;
-	u8		TwoAnt;
-	u8		AntSelReverse;
-	u8		RunTimePMFilter;
-	//for modify kr4 memory align warning
-	u8		TotalRSSIByFw_0;
-	u8		TotalRSSIByFw_1;
-	u8		TotalRSSIByFw_2;
-	u8		TotalRSSIByFw_3;
-} RemoteWakeup_Parm, *PRemoteWakeup_Parm;
-
-//H2C Index: 0x4
-typedef struct _disconnect_parm_ {
-	u8		Enable: 1;
-	u8		AdoptUserSetting: 1;
-	u8		TryOkBcnFailCountEn: 1;
-	u8 		DisconnectEN: 1;
-	u8		rsvd: 4;
-
-	u8		DisconnectCountLimit;
-	u8		TryPKTCountLimit;
-	u8		TryOkBcnFailCountLimit;
-	u8		DisconnectCount;
-	u8		TryPKTCount;
-	u8		BCNCount;
-	u8		WHCKPatchEn;
-} Disconnect_Parm, *PDisconnect_Parm;
-
-//3 Class8: Testing
-typedef struct _H2C_EVT_CONTENT {
-	u8		Content[LENGTH_H2C];
-} H2C_EVT_CONTENT, *PH2C_EVT_CONTENT;
-
-typedef struct _H2C_EVT_ {
-	H2C_EVT_CONTENT    H2CFWBuff[LENGTH_H2C_BUFF];
-	u8		H2CRPtr;
-	u8		H2CWPtr;
-} H2C_EVT, *PH2C_EVT;
-
-typedef struct _C2H_FW_EVT_ {
-	C2H_EVT_HDR        c2h_sfbuff[LENGTH_C2H_BUFF];
-	u8		c2h_r_ptr;
-	u8		c2h_w_ptr;
-} C2H_FW_EVT, *PC2H_FW_EVT;
-
-/* H2C Index: 0x06 */
-typedef struct _H2CParam_InitOffload_ {
-	u8		Cmd_Index;
-	u8		Loc_Data;
-} H2CParam_InitOffload, *PH2CParam_InitOffload;
-
-typedef struct _MEDIA_STATUS_ {
-	BOOLEAN	bConnected[MACID_NUM_NEW];
-	u8		MaxConnectedMacid;
-} MEDIA_STATUS, *PMEDIA_STATUS;
-
-/*--------------------Define --------------------------------------------*/
-/* Register H2C Command ID here */
-typedef enum _H2C_CMD_ {
-	/* 1 Class1: Common */
-	H2CID_RSVDPAGE								= 0x00,
-	H2CID_JOININFO              					= 0x01,
-	H2CID_SCAN                  					= 0x02,
-	H2CID_KEEP_ALIVE            					= 0x03,
-	H2CID_DISCONNECT_DECISION   				= 0x04,
-	H2CID_PSD_OFFLOAD           					= 0x05,
-	H2CID_Customer_string_rpt   				= 0x06,
-	rsvd3                       						= 0x07,
-	H2CID_AP_OFFLOAD            					= 0x08,
-	H2CID_BCN_RsvdPage          					= 0x09,
-	H2CID_Probersp_RsvdPage     				= 0x0A,
-	H2CID_TXPower_Index_Offlaod 				= 0x0B,
-	H2CID_AP_PS_OFFLOAD         				= 0x0C,
-	H2CID_AP_PS_OFFLOAD_CTRL    				= 0x0D,
-	H2CID_ECSA                  					= 0x0F,
-
-	H2CID_FAST_CS_RSVDPAGE     	 			= 0x10,
-	H2CID_FAST_CHANNEL_SWITCH   				= 0x11,
-	H2CID_BB_GAIN_REPORT        				= 0x12,
-	H2CID_GPIO_CTRL             					= 0x13,
-	H2CID_HW_INFO               					= 0x14,
-	H2CID_MCC_RQT_TSF      						= 0x15,
-	H2CID_MCC_MACID_BITMAP     	 			= 0x16,
-	H2CID_MCC_CTRL              					= 0x18,
-	H2CID_MCC_TIME_PARAM         				= 0x19,
-	H2CID_MCC_IQK_PARAM         				= 0x1A,
-	H2CID_NAN_CTRL              					= 0x1B,
-	H2CID_SINGLE_CHANNEL_SWITCH 				= 0x1C,
-	H2CID_SINGLE_CHANNEL_SWITCH_V2 			= 0x1D,
-	H2CID_TX_PAUSE_DRV_INFO					= 0x1E,
-	H2CID_MACID_PAUSE_DRV_INFO  				= 0x1F,
-	/* 1 Class2: Power Save */
-	H2CID_SETPWRMODE            					= 0x20,
-	H2CID_PSTURNINGPARM         				= 0x21,
-	H2CID_PSTURNINGPARM2        				= 0x22,
-	H2CID_PSLPSPARM             					= 0x23,
-	H2CID_P2PPS_OFFLOAD         				= 0x24,
-	H2CID_PS_SCAN               					= 0x25,
-	H2CID_SAPPS                 					= 0x26,
-	H2CID_INACTIVE_PS           					= 0x27,
-	H2CID_NOLINK_PS             					= 0x28,
-	H2CID_PARTIAL_OFF_CTRL   					= 0x29,
-	H2CID_PARTIAL_OFF_PARM  					= 0x2A,
-	H2CID_LPS_I_TWT_INFO1         				= 0x31,
-	H2CID_LPS_I_TWT_INFO2         				= 0x32,
-	H2CID_LPS_I_TWT_INFO3         				= 0x33,
-	H2CID_S1_NULL1_CTRL         				= 0x3F,
-	/* 1 Class3: Dynamic Mechaism */
-	H2CID_MACID_CFG             					= 0x40,
-	H2CID_TxBF                  					= 0x41,
-	H2CID_RSSI_SETTING          					= 0x42,
-	H2CID_AP_REQ_TXRPT          					= 0x43,
-	H2CID_INIT_RATE_COLLECT     				= 0x44,
-	H2CID_IQK_OFFLOAD           					= 0x45,
-	H2CID_MACID_CFG_3SS        	 				= 0x46,
-	H2CID_RA_PARA_ADJUST        				= 0x47,
-	H2CID_DYNAMIC_TX_PATH       				= 0x48,
-	H2CID_FW_TRACE_EN          		 			= 0x49,
-	H2CID_MACID_CFG2							= 0x54,
-	H2CID_ADJUST_RA_MASK						= 0x55,
-	H2CID_RA_D_O_TIMER							= 0x56,
-	H2CID_ADAPTIVITY							= 0x57,
-	H2CID_CSI_Report								= 0x58,
-	/* 1 Class4: BT Coex */
-	H2CID_B_TYPE_TDMA           					= 0x60,
-	H2CID_BT_INFO               					= 0x61,
-	H2CID_FORCE_BT_TXPWR        				= 0x62,
-	H2CID_BT_IGNORE_WLANACT     				= 0x63,
-	H2CID_DAC_SWING_VALUE       				= 0x64,
-	H2CID_ANT_SEL_REVERSE       				= 0x65,
-	H2CID_WL_OPMODE             					= 0x66,
-	H2CID_BT_MP_OPERATION       				= 0x67,
-	H2CID_BT_CONTROL           			 		= 0x68,
-	H2CID_BT_WIFICTRL           					= 0x69,
-	H2CID_BT_PATCH_DOWNLOAD     				= 0x6A,
-	H2CID_BT_SCO_eSCO_OPERATION				= 0x6B,
-	H2CID_BT_Page_Scan_Interval			 	= 0x6C,
-	H2CID_WL_Calibraion         				= 0x6D,
-	H2CID_GNT_BT_CTRL           					= 0x6E,
-	H2CID_BT_ONLY_TEST          					= 0x6F,
-	H2CID_BT_INIT_PARAM         				= 0x70,
-	H2CID_WL_PORT_ID            					= 0x71,
-	/* 1 Class5: WOWLAN */
-	H2CID_WoWLAN                					= 0x80,
-	H2CID_RemoteWakeCtrl        				= 0x81,
-	H2CID_AOAC_Global_info      				= 0x82,
-	H2CID_AOAC_Rsvdpage1        				= 0x83,
-	H2CID_AOAC_Rsvdpage2        				= 0x84,
-	H2CID_D0_Scan_offload_info  				= 0x85,
-	H2CID_D0_Scan_offload_ctrl  				= 0x86,
-	H2CID_Switch_channel        				= 0x87,
-	H2CID_AOAC_Rsvdpage3        				= 0x88,
-	H2CID_GPIO_WF_Customize     				= 0x89,
-	H2CID_P2P_RsvdPage          					= 0x8A,
-	H2CID_P2P_Offload           					= 0x8B,
-	/* 1 Class6: LTECOEX */
-	H2CID_LTECOEX_EN            					= 0xA0,
-	H2CID_WLAN_High_Priority    				= 0xA1,
-	/* 1 Class7: FTM */
-	H2CID_FTM                   						= 0xB0,
-	H2CID_FTMRPT                					= 0xB1,
-	/* 1 Class8: Patch */
-	H2CID_TSF_RESET             					= 0xC0,
-	H2CID_BB_NHM                					= 0xC1,
-	H2CID_BCN_Ignore_EDCCA      				= 0xC2,
-	H2CID_Efuse_Hidden_Request  				= 0xC3,
-	H2CID_APoffload_MultiWakeupPulse 		= 0xC4,
-	H2CID_BCN_HWSEQ	        					= 0xC5,   //8814A BCN HWSEQ issue for Seam
-	H2CID_Customer_string1      				= 0xC6,
-	H2CID_Customer_string2      				= 0xC7,
-	H2CID_Customer_string3      				= 0xC8,
-	H2CID_IOTDRV_CloseRF      					= 0xCF,
-	/* 1 Class9: Testing */
-	H2CID_H2C2HLB               					= 0xE0,
-	H2CID_FW_Verification       				= 0xE4,
-	/* 1 Class10:FW Offload */
-	CMD_ID_FW_OFFLOAD_H2C       				= 0xFF
-} H2C_CMD, *PH2C_CMD;
-
-typedef enum _C2H_CMD_SUBID_ {
-	C2HEXTID_DEBUG_PRT          = 0,
-
-
-} C2H_CMD_SUBID, *PC2H_CMD_SUBID;
-
-/*--------------------------Define MACRO--------------------------------------*/
-#define FIX_DELAY_FORWARD					BIT5
-
-//MACID Drop Action
-#define MACID_DROP_DISABLE      			0
-#define MACID_DROP_ENABLE       			1
-
-/*------------------------------Define Struct---------------------------------*/
-//================H2C command format====================
-typedef struct _H2C_CMD_HDR {
-	u8 cmd_id;
-} H2C_CMD_HDR, *PH2C_CMD_HDR;
-
-//3 Class1: Common
-/* H2C Index: 0x0 */
-typedef struct _H2CParam_RsvdPage_ {
-	RsvdPageLoc loc;
-} H2CParam_RsvdPage, *PH2CParam_RsvdPage;
-
-/* H2C Index: 0x1 */
-typedef struct _H2CParam_JoinInfo_ {
-	BOOLEAN     bConnected: 1;
-	BOOLEAN     bMacid_ind: 1;
-	u8          Miracast: 1;
-	u8          Miracast_role: 1;
-	u8          Macid_Dest_Role: 4;
-	u8          macid;
-	u8          macid_end;
-} H2CParam_JoinInfo, *PH2CParam_JoinInfo;
-
-//3 Class2: Power Save
-/* H2C Index: 0x20 */
-typedef struct _H2CParam_SetPwrMode_parm_ {
-	LEGACY_PS_PARM      PwrModeParm;
-} H2CParam_PwrMode, *PH2CParam_PwrMode;
-
-/* H2C Index: 0x21 */
-typedef struct _H2CParam_PSTuningParm_ {
-	PS_TUNING_PPARM    PSTuningParm;
-} H2CParam_PSTuningParm, *PH2CParam_PSTuningParm;
-
-/* H2C Index: 0x26 */
-typedef struct _H2CParam_SAPPSParm_ {
-	u8  Enable: 1;
-	u8  EnPS: 1;
-	u8  EnLPRx: 1;
-	u8  Manual32k: 1;   //revised by isaac on 20141202
-	u8  rsvd: 4;
-	u8  Duration;
-	u8 SegNum;
-} H2CParam_SAPPSParm, *PH2CParam_SAPPSParm;
-
-/* H2C Index: 0x27 */
-typedef struct _H2CParam_INACTIVEPSParm_ {
-	u8      Enable: 1;
-	u8      IgnorePsCondition: 1;
-	u8      rsvd: 6;
-	u8      Frequency;
-	u8      Duration;
-	u8      FrequencyCount;
-} H2CParam_INACTIVEPSParm, *PH2CParam_INACTIVEPSParm;
-
-//3 Class3: Dynamic Mechaism
-//H2C Index: 0x58
-//TX null data
-typedef struct _CSI_Txnull_Parm_ {
-	u8		Enable;
-	u16	TxNullRate;
-	u8 		Macid;
-	u8		NullPeriod;
-	u8		TxRevAddr[6];
-	u8		TxNullPowerBit;
-	//u8		TxNull0Cycle;
-	//u8		TxNull0CycleOK;
-	//u8		TxNull0retrycnt;
-	//u8		TxNull1Cycle;
-	//u8		TxNull1CycleOK;
-	//u8		TxNull1retrycnt;
-	u8		TxNullCycle;
-	u8		TxNullCycleOK;
-	u8		TxNullretrycnt;
-	u8		TxNullCycleOn;
-} CSITxnull_Parm, *PCSITxnull_Parm;
-
-typedef struct _CSI_Report_Parm_ {
-	u8 		CSIWorkEn;
-	u8 		TxNullPeriod;
-	CSITxnull_Parm CSITxnullParm[CSICLIENTNUM];
-} CSIReport_Parm, *PCSIReport_Parm;
-
-//3 Class7: Class no define
-
-//3 Class8: Testing
-
-/* H2C Index: 0xE0 */
-typedef struct _H2CParam_H2C2H_ {
-	u8                 H2C2HPara;
-} H2CParam_H2C2H, *PH2CParam_H2C2H;
-
-/*--------------------Function declaration---------------------------------*/
-//brian for function both called in isrhdl or not
-extern void SendSignalCommon_8720E(u32  event);
-extern void OSSendSignalCommon_8720E(u32  event);
-extern void H2CInQueue_8720E(void);
-extern void H2CDeQueue_8720E(void);
-extern BOOLEAN WaitC2HOk_8720E(u16 TriggerAddr);
-extern void InitC2H_8720E(void);
-extern void C2HPKTRxDESC_8720E(u16 PktLength, u16 C2HDescOffset);
-extern void FillC2HContant_8720E(u16 C2HPKTOffset, PC2H_EVT_HDR pc2h_hdr);
-extern void IssueC2HPKT_8720E(PC2H_EVT_HDR pc2h_hdr);
-extern void C2HDeQueue_8720E(void);
-extern void C2HInQueue_8720E(PC2H_EVT_HDR pc2h_hdr);
-extern u8 CheckMaxMacidNum_8720E(void);
-extern void SetMediaStatus_8720E(u8 macid, u8 status);
-extern BOOLEAN GetMediaStatus_8720E(u8 macid);
-extern void MediaConnection_8720E(u8 macid);
-extern void MediaDisconnection_8720E(u8 macid);
-extern void C2HSpeRPT_8720E(void);
-extern void H2CCmdFunc_8720E(u8  CmdID, u8  *content);
-extern void SetTxPauseDRVInfo_8720E(u8 BitMask, u8 UserValue);
-extern void MacidDropAction_8720E(u8 action, u8 macid);
-
-#endif  /* __WIFIFW_CMD_RAM_H__ */
diff --git a/os/board/rtl8720e/src/component/wifi/wifi_fw/amebalite/include/wififw_config_ram.h b/os/board/rtl8720e/src/component/wifi/wifi_fw/amebalite/include/wififw_config_ram.h
deleted file mode 100644
index 4058a680a..000000000
--- a/os/board/rtl8720e/src/component/wifi/wifi_fw/amebalite/include/wififw_config_ram.h
+++ /dev/null
@@ -1,18 +0,0 @@
-#ifndef _RTLWISOCFW_CONFIG_RAM_H
-#define _RTLWISOCFW_CONFIG_RAM_H
-
-/* AmebaD SOC */
-#include "ameba_soc.h"
-#include "wififw_rtlchip.h"
-#include "RTL8720E_autoconf.h"
-#ifndef __ASSEMBLY__
-#include "wififw_generaldef.h"
-#include "wififw_types.h"
-
-#include "wififw_hal_ram.h"
-#include "wififw_serial_io.h"
-#include "wififw_protocol_ram.h"
-#include "wififw_wlan_ram.h"
-
-#endif  /* #ifndef   __ASSEMBLY__ */
-#endif  /* _RTLWISOCFW_CONFIG_RAM_H */
diff --git a/os/board/rtl8720e/src/component/wifi/wifi_fw/amebalite/include/wififw_csireport_ram.h b/os/board/rtl8720e/src/component/wifi/wifi_fw/amebalite/include/wififw_csireport_ram.h
deleted file mode 100644
index c9338b825..000000000
--- a/os/board/rtl8720e/src/component/wifi/wifi_fw/amebalite/include/wififw_csireport_ram.h
+++ /dev/null
@@ -1,19 +0,0 @@
-#ifndef __WIFIFW_CSIREPORT_RAM_H__
-#define __WIFIFW_CSIREPORT_RAM_H__
-/*--------------------Define MACRO--------------------------------------*/
-#define RTY_LMT_SW_CSINULLDATA					3
-#define RTY_LMT_HW_CSINULLDATA					0
-
-/*------------------------------Function declaration--------------------------*/
-extern void HALBB_FW_BBReset_8720E(void);
-extern BOOLEAN CheckCSITxNullDone_8720E(void);
-extern BOOLEAN CheckNoCSIClientEnable_8720E(void);
-extern void CheckNextCSIClientTxnull_8720E(u8 clientnum, u8 powerbit);
-extern void CheckCSIClientTxnullRty_8720E(u8 clientnum, u8 powerbit);
-extern void H2CHDL_Set_CSI_TXNULL_8720E(u8 *pbuf);
-extern void CSIEnableClientParameter_8720E(u8 *pbuf, u8 clientnum);
-extern void CSIDisableClientParameter_8720E(u8 clientnum);
-extern void SetPeriodTxNullAddrRate_8720E(u8 clientnum, u16 offset);
-extern void IssueCSITXNull_8720E(u8 clientnum);
-
-#endif  /* #ifndef   __WIFIFW_TXREPORT_RAM_H__ */
diff --git a/os/board/rtl8720e/src/component/wifi/wifi_fw/amebalite/include/wififw_debug_ram.h b/os/board/rtl8720e/src/component/wifi/wifi_fw/amebalite/include/wififw_debug_ram.h
deleted file mode 100644
index 70813e1d9..000000000
--- a/os/board/rtl8720e/src/component/wifi/wifi_fw/amebalite/include/wififw_debug_ram.h
+++ /dev/null
@@ -1,294 +0,0 @@
-#ifndef __WIFIFW_DEBUG_RAM_H__
-#define __WIFIFW_DEBUG_RAM_H__
-/*--------------------------Define -------------------------------------------*/
-//
-//**Note**:
-//      If one of these register is used, we should register MACRO at RTLXXX_debug.h.
-//
-// Range List:
-//      1.) 0x1B8 ~ 0x1BF : there are no control circuit. But these register can be R/W.
-//      2.) 0x1C0 ~ 0x1C7: there are no control circuit. But these register can be R/W.
-//      3.) 0x084 ~ 0x08F: there are no control circuit. But these register can be R/W.
-//2 page 0 rsvd REG USERDEF
-
-#define REG_FW_DBG0_V1							0x0050
-#define REG_FW_DBG1_V1                         0x0054
-#define REG_FW_DBG2_V1                     	0x0058
-#define REG_FW_DBG3_V1                     	0x005C
-#define REG_FW_DBG4_V1                       	0x0060
-#define REG_FW_DBG5_V1                     	0x0064
-#define REG_FW_DBG6_V1                     	0x0068
-#define REG_FW_DBG7_V1                        	0x006C
-
-#define REG_BLK_TST                           	0x0084
-#define REG_HOST_MSG0                         	0x0088
-#define REG_HOST_MSG1                       	0x008C
-
-#define REG_SW_DEFINED_PAGE1             	0x01B8
-#define REG_SW_DEFINED_PAGE2              	0x01BC
-#define REG_MCUTST_I                        	0x01C0
-#define REG_MCUTST_II                      		0x01C4
-
-#define REG_FWLBK_DBG0			            	0x1100
-#define REG_FWLBK_DBG1				    		0x1104
-#define REG_FWLBK_DBG2				    		0x1108
-#define REG_FWLBK_DBG3				    		0x110C
-
-//3 1byte
-#define REG_DBG_BYTE_0				    		REG_MCUTST_I		//1c0
-#define REG_DBG_BYTE_1				    		REG_MCUTST_I+1		//1c1
-#define REG_DBG_BYTE_2				    		REG_MCUTST_I+2		//1c2
-#define REG_DBG_BYTE_3				    		REG_MCUTST_I+3		//1c3
-#define REG_DBG_BYTE_4				    		REG_MCUTST_II+2		//1c6
-#define REG_DBG_BYTE_5			 	    		REG_MCUTST_II+3		//1c7
-#define REG_DBG_BYTE_6				    		REG_HOST_MSG0	 	//88
-#define REG_DBG_BYTE_7				    		REG_HOST_MSG0+1		//89
-#define REG_DBG_BYTE_8				    		REG_HOST_MSG0+2		//8a
-#define REG_DBG_BYTE_9				    		REG_HOST_MSG0+3		//8b
-#define REG_DBG_BYTE_10				    	REG_HOST_MSG1		//8C
-#define REG_DBG_BYTE_11				    	REG_HOST_MSG1+1		//8D
-#define REG_DBG_BYTE_12				   		REG_HOST_MSG1+2		//8E
-#define REG_DBG_BYTE_13				    	REG_HOST_MSG1+3		//8F
-#define REG_DBG_BYTE_14				    	REG_FW_DBG6_V1		//68
-#define REG_DBG_BYTE_15				    	REG_FW_DBG6_V1+1		//69
-#define REG_DBG_BYTE_16				    	REG_FW_DBG6_V1+2		//6A
-#define REG_DBG_BYTE_17				    	REG_FW_DBG6_V1+3		//6B
-#define REG_DBG_BYTE_18				    	REG_FW_DBG7_V1		//6C
-#define REG_DBG_BYTE_19				    	REG_FW_DBG7_V1+1		//6D
-#define REG_DBG_BYTE_20				    	REG_FW_DBG7_V1+2		//6E
-#define REG_DBG_BYTE_21				    	REG_FW_DBG7_V1+3		//6F
-
-//3 4byte
-#define REG_DBG_DWORD_0         		    	REG_SW_DEFINED_PAGE1	//1b8
-#define REG_DBG_DWORD_1        			    REG_BLK_TST			//84
-#define REG_DBG_DWORD_2         		    	REG_FW_DBG0_V1   		//50
-#define REG_DBG_DWORD_3         		    	REG_FW_DBG1_V1		//54
-#define REG_DBG_DWORD_4        	 		    REG_FW_DBG2_V1		//58
-#define REG_DBG_DWORD_5         		    	REG_FW_DBG3_V1		//5A
-#define REG_DBG_DWORD_6         		    	REG_FW_DBG4_V1		//60
-#define REG_DBG_DWORD_7         		    	REG_MACID_SLEEP3		//484
-
-//3 2byte
-#define REG_DBG_WORD_0        			    	REG_MCUTST_II		//1c4
-#define REG_DBG_WORD_1        					REG_SW_DEFINED_PAGE2	//1BC
-#define REG_DBG_WORD_2        			    	REG_SW_DEFINED_PAGE2+2	//1BE
-#define REG_DBG_WORD_3        			    	REG_FW_DBG5_V1		//64
-#define REG_DBG_WORD_4        			    	REG_FW_DBG5_V1+2		//66
-#define REG_DBG_WORD_5         		    	REG_DBG_DWORD_1		//84
-#define REG_DBG_WORD_6         		   	 	REG_DBG_DWORD_1+2		//86
-
-//2 FWLBK
-#define REG_FWLBK_DBG_BYTE16					REG_FWLBK_DBG0		//0x1100
-#define REG_FWLBK_DBG_BYTE17			    	REG_FWLBK_DBG0+1		//0x1101
-#define REG_FWLBK_DBG_BYTE18			    	REG_FWLBK_DBG0+2
-#define REG_FWLBK_DBG_BYTE19			    	REG_FWLBK_DBG0+3
-#define REG_FWLBK_DBG_BYTE20			    	REG_FWLBK_DBG3		//0x110c
-#define REG_FWLBK_DBG_BYTE21			    	REG_FWLBK_DBG3+1
-#define REG_FWLBK_DBG_BYTE22			    	REG_FWLBK_DBG3+2
-#define REG_FWLBK_DBG_BYTE23			    	REG_FWLBK_DBG3+3
-
-#define REG_FWLBK_DBG_WORD0			    	REG_FWLBK_DBG1		//0x1104
-#define REG_FWLBK_DBG_WORD1		            REG_FWLBK_DBG1+2
-#define REG_FWLBK_DBG_WORD2		            REG_FWLBK_DBG2		//0x1108
-#define REG_FWLBK_DBG_WORD3			    	REG_FWLBK_DBG2+2
-
-//FWLBK
-#define FWLBK_DBG_PAYLD_OFSET           	REG_FWLBK_DBG_WORD0//The n'th byte of payload which compare error
-#define FWLBK_DBG_TXBUF_DATA           		REG_FWLBK_DBG_BYTE16//The value of TXPKTBUF compared error
-#define FWLBK_DBG_RXBUF_DATA              	REG_FWLBK_DBG_BYTE17//The value of RXPKTBUF compared error
-#define FWLBK_DBG_RX_LEN                    	REG_FWLBK_DBG_WORD1//length field of RxDESC
-#define FWLBK_DBG_RXFF_RP                  	REG_FWLBK_DBG_WORD2//RXFF Read Pointer
-#define FWLBK_DBG_PKTCNT                    	REG_FWLBK_DBG_WORD3//Tx packet count or Rx Receive packet count
-//#define FWLBK_DBG_DATARATE                  	    REG_FWLBK_DBG_BYTE18
-#define FWLBK_DBG_DATARATE                	REG_DBG_WORD_6
-#define FWLBK_DBG_RX_OK_CNT              	REG_FWLBK_DBG_BYTE19
-
-#define FWLBK_DBG_CAM_0                     	REG_FWLBK_DBG_BYTE20
-#define FWLBK_DBG_CAM_1                     	REG_FWLBK_DBG_BYTE21
-#define FWLBK_DBG_POLL_OK_CNT              	REG_FWLBK_DBG_BYTE22
-#define FWLBK_DBG_CTL                       	REG_FWLBK_DBG_BYTE23
-
-//1  Indirect define
-
-//Power saving debug
-#define REG_PS_32K             			    	REG_DBG_DWORD_0		//1b8
-#define REG_32K_MATCH_CNT			    		REG_DBG_BYTE_18		//6C
-#define REG_AntSwitchOutSide    		    	REG_DBG_BYTE_12		//8E
-#define REG_FWLBK_CTRL          		    	REG_DBG_WORD_5		//84
-#define DBGFUN_PS_STATE_EN      				BIT4 //report to 0x88[15:0]
-
-//3 Register Debug register for our purpose
-// 1.) Firmware Component Error
-#define REGDUMP_FW_ERR0         		    	REG_DBG_BYTE_0		//1c0
-#define REGDUMP_FW_ERR1         		    	REG_DBG_BYTE_1		//1c1
-#define REGDUMP_FW_ERR2         		    	REG_DBG_BYTE_2		//1c2
-
-// 2.) Hardware Component Error
-#define REGDUMP_HW_ERR0         		    	REG_DBG_BYTE_3		//1c3
-
-// 3.) Program Counter
-#define REGDUMP_CPUINST         		    	REG_DBG_DWORD_3 		//54
-
-// 4.) Unlock MCU inifinite-loop
-//  0xFF: unlock Overall MCU while(1)
-#define REG_UNLOCK_MCU          		    	REG_DBG_BYTE_4		//1C6
-
-// 5.) FWLBK
-#define REG_FTR                 		    		REG_DBG_BYTE_10 		//8C
-#define REG_FWLBK_CTRL_EXT              		REG_DBG_BYTE_9		//8b
-
-// 6.) Efuse Part Number
-//#define REG_PART_NUM            		REG_DBG_BYTE_9
-// Bit[7]: part number report enable
-// Bit[6:4]: ant num
-// Bit[3:2]: app_type
-// BIT[1:0]: interface_type
-// 7.) H2CPTR Index
-#define REGDUMP_H2CPTR_IDX      		    	REG_DBG_BYTE_8		//8A
-
-// 8.) BT-COEX
-#define WLCALIBRATION               			REG_GENTST
-//#define REG_Null1_fail_counter	REG_DBG_BYTE_15
-// 9.) BT-COEX , BT calibration indication bit for driver
-#define REG_BT_Cal_Ind		    		    	REG_DBG_BYTE_11		//8D
-
-// 10.) BT Patch code checksum report (2 Byte)
-
-// 11.) Pass Security Info to driver
-#define REG_SECURITY_INFO       		    	REG_DBG_DWORD_7		//484
-#define REG_KEY_INDEX          	 		    	REG_DBG_BYTE_14		//68
-#define REG_WOW_PATTERN_INDEX   	   	    REG_DBG_BYTE_15		//69
-
-// 12.) update PS State to Driver
-#define REG_Current_PS_STATE    		    	REG_DBG_BYTE_6		//88
-#define REG_LastRpwm            		    	REG_DBG_BYTE_7		//89
-
-// 13.) WoWlan wakeup reason
-#define REG_WoW_REASON          		    	REG_DBG_BYTE_5   		//1C7
-
-// 14.) SAPPS debug
-#define REG_SAPPS_DEBUG_DWORD1 			    REG_DBG_DWORD_2		//50
-#define REG_SAPPS_DEBUG_DWORD2 			    REG_DBG_DWORD_4		//58
-#define REG_SAPPS_DEBUG_DWORD3 			    REG_DBG_DWORD_5		//5A
-#define REG_SAPPS_DEBUG_DWORD4 			    REG_DBG_DWORD_6		//60
-
-//REG_UNLOCK_MCU0 SubComponent
-#define UNLOCK_MCU_TSF_STABLE   			BIT0
-#define UNLOCK_MCU_CPU_MGQ      				BIT1
-#define UNLOCK_MCU_RW_BB        				BIT2
-
-#define DBG_ADDR(_addr)         				WriteMACRegDWord(REGDUMP_CPUINST, _addr);
-#define ManualDbg(stop)            		 	while(ReadMACRegByte(0x01C3) <= stop) {}
-
-//definition for 0x005D    RE G_AOAC_REASON
-#define AOAC_ARP                            		BIT0
-#define AOAC_ISSUE_ARP                      	BIT1
-#define AOAC_IP_MISMATCH                    	BIT2
-#define AOAC_ON_NDP             					BIT3
-#define AOAC_ISSUE_NDP          				BIT4
-#define AOAC_IPV6_MISMATCH     				BIT5
-
-/*------------------------------Define Struct---------------------------------*/
-#ifndef __ASSEMBLY__
-//REGDUMP_FW_ERR0
-typedef enum _FW_ERR0_STATUS_ {
-	FES0_H2C_CMDID							= BIT0,
-	FES0_H2C_PTR                				= BIT1,
-	FES0_BB_RW                  				= BIT2,
-	FES0_TXPKT_TXPAUSE          				= BIT3,
-	FES0_TSF_STABLE             				= BIT4,
-	FES0_TXSM_STABLE            				= BIT5,
-	FES0_RPWM_STABLE            				= BIT6,
-	FES0_C2H_TIMEOUT_ERR        			= BIT7,
-
-} FW_ERR0_STATUS, *PFW_ERR0_STATUS;
-
-//REGDUMP_FW_ERR1
-typedef enum _FW_ERR1_STATUS_ {
-	FES1_H2C_QUEUE_FULL         			= BIT0,
-	FES1_C2H_QUEUE_FULL         			= BIT1,
-	FES1_RXDMA_NOT_IDLE_ERR     			= BIT2,
-	FES1_WOWLAN_PKT_PTR         			= BIT3,
-	FES1_FD_LOCK_ERR            				= BIT4,
-	FES1_TRY_EN_ERR             				= BIT5,
-	FES1_WOWLAN_RX_ERR          				= BIT6,
-	FES1_C2HEXT_QUEUE_FULL      			= BIT7
-} FW_ERR1_STATUS, *PFW_ERR1_STATUS;
-
-//REGDUMP_FW_ERR2
-typedef enum _FW_ERR2_STATUS_ {
-	FES2_DBGPKT_QUEUE_FULL      			= BIT0,
-	FES2_PATCH_VAR_OVERFLOW     			= BIT1,
-	FES2_PATCH_VAR_UNDERFLOW    			= BIT2,
-	FES2_DDMA_BUSY_TIMEOUT      			= BIT3
-} FW_ERR2_STATUS, *PFW_ERR2_STATUS;
-
-//REGDUMP_HW_ERR0
-typedef enum _HW_ERR0_STATUS_ {
-	HES0_USB_MDIO_INTF_ERR      			= BIT0,
-	HES0_PCIE_MDIO_INTF_ERR     			= BIT1,
-	HES0_USB_PHY_CMD_ERR        			= BIT2,
-	HES0_PCIE_PHY_CMD_ERR       			= BIT3
-
-} HW_ERR0_STATUS, *PHW_ERR0_STATUS;
-
-typedef enum _FW_ERR_POWER_STATUS_ {
-	BIT_POWER_STATUS_CHANGE      			= BIT0,
-	BIT_S2_Condition_Not_Macth         	= BIT1,
-	BIT_S4_Condition_Not_Macth			= BIT2,
-	BIT_32K_Condition_Not_Macth         	= BIT3
-} FW_ERR_POWER_STATUS, *PFW_ERR_POWER_STATUS;
-
-typedef enum _FW_ERR_POWER_REASON1_ {
-	BIT_H2CHDL0x20         					= BIT0,
-	BIT_S0ToS1_ERROR         					= BIT1,
-	BIT_TxNull0_FAIL     						= BIT2,
-	BIT_S2ToS3_ERROR         					= BIT3,
-	BIT_TxNull1_FAIL            				= BIT4
-} FW_ERR_POWER_REASON1, *PFW_ERR_POWER_REASON1;
-
-typedef enum _FW_ERR_POWER_REASON2_ {
-	BIT_S2_TXQUEUE_NOT_EMPTY  			= BIT0,
-	BIT_TRX_PERIOD        	 				= BIT1,
-	BIT_S2_RPWM_NOT_MATCH     				= BIT2,
-	BIT_RLPSRFOn       						= BIT3,
-	BIT_WIFI_ACTIVE        					= BIT4,
-	BIT_SAPPS_ACTIVE             				= BIT5
-} FW_ERR_POWER_REASON2, *PFW_ERR_POWER_REASON2;
-
-typedef enum _FW_ERR_POWER_REASON3_ {
-	BIT_S4_TXQUEUE_NOT_EMPTY       		= 1,
-	BIT_TRX_TIM_DTIM          				= 2,
-	BIT_S4_RPWM_NOT_MATCH     				= 3,
-	BIT_USP_NOT_OVER         					= 4,
-	BIT_TX_ACTIVE_INDEX 					= 5,
-	BIT_RX_ACTIVE_INDEX 					= 6,
-	BIT_BCN_DATA_OPEN            			= 7,
-	BIT_RfOffLicenseForBCNRx    			= 8,
-	BIT_WLANON_PERIOD          				= 9,
-	BIT_SCAN_EN      							= 10,
-	BIT_S4_TXCPUMGQ_NOT_EMPTY				= 11,
-	BIT_LEPAP_NOT_END						= 12,
-	BIT_TWTSP_NOT_END						= 13
-} FW_ERR_POWER_REASON3, *PFW_ERR_POWER_REASON3;
-
-typedef enum _FW_ERR_POWER_REASON4_ {
-	BIT_RXFF_NOT_EMPTY         				= 1,
-	BIT_MAC_SCHDULE_SET        				= 2,
-	BIT_C2HPKT_REQ     						= 3,
-	BIT_RXDMA_NOT_IDLE         				= 4,
-	BIT_RXPKT_REQ            					= 5,
-	BIT_WOW_WAKEUP 							= 6,
-	BIT_BT_CALIBRATION 						= 7,
-	BIT_CPUMQ_EMPTY 							= 8,
-	BIT_IOT_DELAY_WAKEUP 					= 9,
-	BIT_RCVING_TIMHIT_BCN 					= 10,
-	BIT_BB_FUNC_NOT_RST						= 11,
-	BIT_BCN_DCK_NOT_RDY 					= 12
-
-} FW_ERR_POWER_REASON4, *PFW_ERR_POWER_REASON4;
-
-/*------------------------------Funciton declaration--------------------------*/
-
-#endif  /* #ifndef   __ASSEMBLY__ */
-#endif /* __WIFIFW_DEBUG_H__ */
diff --git a/os/board/rtl8720e/src/component/wifi/wifi_fw/amebalite/include/wififw_dma_ram.h b/os/board/rtl8720e/src/component/wifi/wifi_fw/amebalite/include/wififw_dma_ram.h
deleted file mode 100644
index 15c7eb7be..000000000
--- a/os/board/rtl8720e/src/component/wifi/wifi_fw/amebalite/include/wififw_dma_ram.h
+++ /dev/null
@@ -1,27 +0,0 @@
-#ifndef __WIFIFW_DMA_RAM_H__
-#define __WIFIFW_DMA_RAM_H__
-
-#ifndef __ASSEMBLY__
-/*--------------------Define -------------------------------------------*/
-#define DDMACH0_MSK					BIT0
-#define DDMACH1_MSK					BIT1
-#define DDMACH0_ISR_CLEAR			BIT0
-#define DDMACH1_ISR_CLEAR			BIT1
-#define DDMACH0_ISR					BIT0//8 
-#define DDMACH1_ISR					BIT1//9 
-
-#define BIT_MASK_DDMA_DLEN		0x3FFFF
-#define BIT_DDMA_OWN				BIT31
-#define BIT_DDMA_CHKSUM_EN		BIT29
-#define BIT_MASK_DDMA_ADDR		0xFFFFFFFF
-#define BIT_DDMA_CHKSUM_STS		BIT3
-#define DDMACH_DEST_OFSET			0x4
-#define DDMACH_CTRL_OFSET			0x8
-
-/*--------------------Function declaration------------------------------*/
-extern BOOLEAN InitDDMA_8720E(u8  ch_num,  u32 saddr,  u32 daddr,  u32 dma_size, BOOLEAN chksum_en);
-extern BOOLEAN WaitDDMARDY_8720E(u8 ch_num);
-extern BOOLEAN ChkDDMAChksum_8720E(u8 ch_num);
-extern BOOLEAN CheckDDMADone_8720E(u8 ch_num, u8 chk_chksum);
-#endif  /* #ifndef __ASSEMBLY__ */
-#endif /* __WIFIFW_DMA_H__ */
diff --git a/os/board/rtl8720e/src/component/wifi/wifi_fw/amebalite/include/wififw_generaldef.h b/os/board/rtl8720e/src/component/wifi/wifi_fw/amebalite/include/wififw_generaldef.h
deleted file mode 100644
index dc9d3236e..000000000
--- a/os/board/rtl8720e/src/component/wifi/wifi_fw/amebalite/include/wififw_generaldef.h
+++ /dev/null
@@ -1,47 +0,0 @@
-#ifndef __INC_GENERALDEF_H
-#define __INC_GENERALDEF_H
-/*
- *  Note:   1.Only pure value definition can be put here.
- *          2.The definition here should be hardware and platform independent.
- *
-*/
-#define VOID			void
-#define SUCCESS    	0
-#define FAIL        	(-1)
-#define _SUCCESS   	1
-#define _FAIL       	0
-//Filen:
-//  true, false, TRUE, FALSE  are not used as possible.
-#ifndef true
-#define true        	1
-#endif
-
-#ifndef false
-#define false       	0
-#endif
-
-#ifndef TRUE
-#define TRUE        	true
-#endif
-
-#ifndef FALSE
-#define FALSE       	false
-#endif
-
-#ifndef BIT
-/* Below's Macro is necessary to take care for 8051 Keil-C */
-/* Ex. BIT(16) is eqaul to zero in 8051 Keil-C */
-#define BIT(x)  		(1 << (x))
-#endif
-
-#define ON          		1
-#define OFF         	0
-
-#define Alignment_64byte(len)   (((len + (((len&0x3F)==0)?0:64))>>6)<<6)
-#define Alignment_128byte(len)  (((len + (((len&0x7F)==0)?0:128))>>7)<<7)
-/*   TODO: [Dangerous] It is necessary to be checked Correctness if below's Macros are used in 8051. */
-#define Alignment_256byte(len)  (((len + (((len&0xFF)==0)?0:256))>>8)<<8)
-#define Alignment_512byte(len)  (((len + (((len&0x01FF)==0)?0:512))>>9)<<9)
-#define Alignment_1024byte(len) (((len + (((len&0x03FF)==0)?0:1024))>>10)<<10)
-
-#endif /* #ifndef __INC_GENERALDEF_H */
diff --git a/os/board/rtl8720e/src/component/wifi/wifi_fw/amebalite/include/wififw_hal_ram.h b/os/board/rtl8720e/src/component/wifi/wifi_fw/amebalite/include/wififw_hal_ram.h
deleted file mode 100644
index dc60769ff..000000000
--- a/os/board/rtl8720e/src/component/wifi/wifi_fw/amebalite/include/wififw_hal_ram.h
+++ /dev/null
@@ -1,692 +0,0 @@
-#ifndef __WIFIFW_HAL_RAM_H__
-#define __WIFIFW_HAL_RAM_H__
-
-#ifndef __ASSEMBLY__
-/*--------------------------Define -------------------------------------------*/
-//2 TaskBitMap0
-#define RATEADAPTIVE        						BIT0
-#define H2CEVENT            							BIT1
-#define C2HEVENT            							BIT2
-#define RLPSEVENT           							BIT3
-#define REMOTEWAKEEVENT     						BIT4
-#define APOFFLOADEVENT      						BIT5
-#define SWTIMEREVENT        						BIT7
-#define BTMAILBOXEVENT      						BIT8
-
-//2 Common Interface for each HAL
-//OS
-#define OSSendSignalCommon      			OSSendSignalCommon_8720E
-#define SendSignalCommon					SendSignalCommon_8720E
-#define ISRSendSignalCommon     			ISRSendSignalCommon_8720E
-/* Func Init */
-#define HALInit								HALInit_8720E
-#define InitInterrupt           			InitInterrupt_8720E
-#define InitCommon              				InitCommon_8720E
-//GTimer
-#define InitGTimer32us              		InitGTimer32us_8720E
-#define InitGTimer1ms               		InitGTimer1ms_8720E
-
-/* Interrupt handle function */
-#define WLAN_INT_HDL        				WLAN_INT_HDL_8720E
-#define FT_INT_HDL          					FT_INT_HDL_8720E
-#define InitWlanIMR             				InitWlanIMR_8720E
-#define InitFTIMR               				InitFTIMR_8720E
-#define InitMAC2LPIntByps					InitMAC2LPIntByps_8720E
-/* 2 1.) WLAN ISR */
-#define ISR_TXCCX               				ISR_TXCCX_8720E
-#define ISR_RxDone              				ISR_RxDone_8720E
-#define ISR_H2CCMD              				ISR_H2CCMD_8720E
-#define ISR_BcnEarly            			ISR_BcnEarly_8720E
-#define ISR_TBTT                				ISR_TBTT_8720E
-#define ISR_P0_TBTT_AGG					ISR_P0_TBTT_AGG_8720E
-#define ISR_TIM_NO_HIT						ISR_TIM_NO_HIT_8720E
-#define ISR_TIM_HIT							ISR_TIM_HIT_8720E
-#define ISR_HIOE_CHN0						ISR_HIOE_CHN0_8720E
-#define ISR_HIOE_CHN1						ISR_HIOE_CHN1_8720E
-#define ISR_HIOE_CHN_ON					ISR_HIOE_CHN_ON_8720E
-#define ISR_HIOE_CHN_OFF					ISR_HIOE_CHN_OFF_8720E
-#define ISR_BCNRx               				ISR_BCNRx_8720E
-#define ISR_BCNRxErr						ISR_BCNRxErr_8720E
-#define ISR_RxBMC_MD1           			ISR_RxBMC_MD1_8720E
-#define ISR_RxBMC_MD0           			ISR_RxBMC_MD0_8720E
-#define ISR_RxUnicast_MD1       			ISR_RxUnicast_MD1_8720E
-#define ISR_RxUnicast_MD0       			ISR_RxUnicast_MD0_8720E
-#define ISR_TXBCNERR            			ISR_TXBCNERR_8720E
-#define ISR_TXBCNOK             				ISR_TXBCNOK_8720E
-#define ISR_TSF_GT_THRES					ISR_TSF_GT_THRES_8720E
-#define ISR_RXBCN_TIMEUP					ISR_RXBCN_TIMEUP_8720E
-#define ISR_RXBCN_TIMEOUT_CNT			ISR_RXBCN_TIMEOUT_CNT_8720E
-#define ISR_TxPKTIn             				ISR_TxPKTIn_8720E
-#define ISR_WlanActOn           			ISR_WlanActOn_8720E
-#define ISR_WlanActOff          			ISR_WlanActOff_8720E
-#define ISR_TxrptCntFull        			ISR_TxrptCntFull_8720E
-/* 2 1.) WLAN2 ISR */
-#define ISR_TBTT1               				ISR_TBTT1_8720E
-/* 2 3.) WLAN4 ISR */
-#define ISR_BTScoreboard        			ISR_BTScoreboard_8720E
-#define ISR_ZBMailbox           			ISR_ZBMailbox_8720E
-#define ISR_GNT_BT_Rise        	 		ISR_GNT_BT_Rise_8720E
-#define ISR_GNT_BT_Fall         			ISR_GNT_BT_Fall_8720E
-/* 2 4.) FT ISR */
-#define ISR_GTimer0           				ISR_GTimer0_8720E
-#define ISR_GTimer1             				ISR_GTimer1_8720E
-#define ISR_GTimer2             				ISR_GTimer2_8720E
-#define ISR_GTimer3             				ISR_GTimer3_8720E
-#define ISR_GTimer4             				ISR_GTimer4_8720E
-#define ISR_GTimer5             				ISR_GTimer5_8720E
-#define ISR_GTimer6             				ISR_GTimer6_8720E
-#if CONFIG_LPS_I_TWT
-#define ISR_PSTIMERA             			ISR_PSTIMERA_8720E
-#define ISR_PSTIMERAEarly					ISR_PSTIMERAEarly_8720E
-#define ISR_PSTIMERB             			ISR_PSTIMERB_8720E
-#define ISR_PSTIMERBEarly					ISR_PSTIMERBEarly_8720E
-#define ISR_PSTIMERC             			ISR_PSTIMERC_8720E
-#define ISR_PSTIMERCEarly					ISR_PSTIMERCEarly_8720E
-#define ISR_PSTIMERD             			ISR_PSTIMERD_8720E
-#define ISR_PSTIMERDEarly					ISR_PSTIMERDEarly_8720E
-#define ISR_PSTIMERE             			ISR_PSTIMERE_8720E
-#define ISR_PSTIMEOUT0						ISR_PSTIMEOUT0_8720E
-#define ISR_PSTIMEOUT1						ISR_PSTIMEOUT1_8720E
-#define ISR_PSTIMEOUT2						ISR_PSTIMEOUT2_8720E
-#define CHECKTWTClientNULL				CHECKTWTClientNULL_8720E
-#define CHECKTWTClientSPEND				CHECKTWTClientSPEND_8720E
-#define PSTWTEarlyProcess					PSTWTEarlyProcess_8720E
-#define PSTWTBcnToProcess					PSTWTBcnToProcess_8720E
-#define PSTWTBcnRxProcess					PSTWTBcnRxProcess_8720E
-#define LPS_ITWTTimeUpdate				LPS_ITWTTimeUpdate_8720E
-#define LPS_ITWTDurationUpdate			LPS_ITWTDurationUpdate_8720E
-#define LPS_ITWTTIMERSetting				LPS_ITWTTIMERSetting_8720E
-#define LPS_ITWTStatusSet					LPS_ITWTStatusSet_8720E
-#define LPS_ITWTIMRSetting				LPS_ITWTIMRSetting_8720E
-#define LPS_ITWTByPassLsysWakeInt		LPS_ITWTByPassLsysWakeInt_8720E
-#define LPS_ITWTSPWORK						LPS_ITWTSPWORK_8720E
-#define LPS_ITWT_PortSet 					LPS_ITWT_PortSet_8720E
-#define LPS_ITWT_ClientSPSet				LPS_ITWT_ClientSPSet_8720E
-#define LPS_ITWT_ClientSPEarlySet		LPS_ITWT_ClientSPEarlySet_8720E
-#endif
-#define ISR_RPWM                				ISR_RPWM_8720E
-#define ISR_BCNERLY1            			ISR_BCNERLY1_8720E
-#define ISR_BcnEarlyAGG         			ISR_BcnEarlyAGG_8720E
-#define ISR_TxNull0             				ISR_TxNull0_8720E
-#define ISR_TxNull1             				ISR_TxNull1_8720E
-//Basic ISR
-#define UpdateISRWlan           			UpdateISRWlan_8720E
-#define UpdateISRFT             				UpdateISRFT_8720E
-#define ClrAllFWUsedIMR         			ClrAllFWUsedIMR_8720E
-#define ClrAllFWUsedISR         			ClrAllFWUsedISR_8720E
-#define setfwimr 								setfwimr_8720E
-#define clrfwimr 								clrfwimr_8720E
-#define setwlanimr 							setwlanimr_8720E
-#define clrwlanimr 							clrwlanimr_8720E
-#define setftimr					  			setftimr_8720E
-#define clrftimr                     			clrftimr_8720E
-
-/* 3 4.) RAM func */
-#define MacidDropAction         			MacidDropAction_8720E
-#define MediaConnection         			MediaConnection_8720E
-#define GetRPWMValue                    	GetRPWMValue_8720E
-#define WaitHWStateReady                	WaitHWStateReady_8720E
-#define SysClkDown                      		SysClkDown_8720E
-#define SysClkUp                          	SysClkUp_8720E
-#define SetTxPauseFWInfo            		SetTxPauseFWInfo_8720E
-#define C2HSpeRPT								C2HSpeRPT_8720E
-#define SetTxPauseDRVInfo					SetTxPauseDRVInfo_8720E
-//CMD
-#define H2CCmdFunc              				H2CCmdFunc_8720E
-#define H2CInQueue              				H2CInQueue_8720E
-#define H2CDeQueue              				H2CDeQueue_8720E
-#define InitC2H                     			InitC2H_8720E
-#define WaitC2HOk               				WaitC2HOk_8720E
-#define C2HPKTRxDESC                		C2HPKTRxDESC_8720E
-#define FillC2HContant                  	FillC2HContant_8720E
-#define IssueC2HPKT                     		IssueC2HPKT_8720E
-#define C2HDeQueue             	 			C2HDeQueue_8720E
-#define C2HInQueue              				C2HInQueue_8720E
-#define CheckMaxMacidNum        			CheckMaxMacidNum_8720E
-#define SetMediaStatus          			SetMediaStatus_8720E
-#define GetMediaStatus          			GetMediaStatus_8720E
-#define MediaDisconnection				MediaDisconnection_8720E
-#define MediaConnection					MediaConnection_8720E
-
-// hioe
-#define HIOESetSingleCmdValWM 			HIOESetSingleCmdValWM_8720E
-#define HIOESetSingleCmdValBM 			HIOESetSingleCmdValBM_8720E
-#define HIOECmdInitValTypeChk			HIOECmdInitValTypeChk_8720E
-#define HIOEChkChanelIdle					HIOEChkChanelIdle_8720E
-#define HIOEInitCmdFileToTXFF 			HIOEInitCmdFileToTXFF_8720E
-
-#define HIOESetConfigFile 				HIOESetConfigFile_8720E
-#define HIOEBackupRestore 				HIOEBackupRestore_8720E
-#define HIOECHKHigh8kTXFFPGUseOverlap 		HIOECHKHigh8kTXFFPGUseOverlap_8720E
-//ddma
-#define InitDDMA					  			InitDDMA_8720E
-#define WaitDDMARDY                			WaitDDMARDY_8720E
-#define ChkDDMAChksum               		ChkDDMAChksum_8720E
-#define CheckDDMADone               		CheckDDMADone_8720E
-
-//lps
-#define PwrGatedInitLLTAndPageAlloc PwrGatedInitLLTAndPageAlloc_8720E
-#define Change_PS_State             		Change_PS_State_8720E
-#define PS_S2_Condition_Match   		PS_S2_Condition_Match_8720E
-#define PS_S4_Condition_Match   		PS_S4_Condition_Match_8720E
-#define WriteTxPauseWithMask				WriteTxPauseWithMask_8720E
-#define WaitTxStateMachineOk       		WaitTxStateMachineOk_8720E
-#define WriteTxPause				     	WriteTxPause_8720E
-#define PsOpenRF                         		PsOpenRF_8720E
-#define PsCloseRF                        		PsCloseRF_8720E
-#define IssueNullData                     	IssueNullData_8720E
-
-#define PS_32K_Condition_Match  		PS_32K_Condition_Match_8720E
-#define InitPS  								InitPS_8720E
-#define ChangePSStateByRPWM  			ChangePSStateByRPWM_8720E
-#define PSBcnEarlyProcess 				PSBcnEarlyProcess_8720E
-#define PSBcnAggEarlyProcess 			PSBcnAggEarlyProcess_8720E
-#define PsDtimToProcess				PsDtimToProcess_8720E
-#define PsBcnToProcess 					PsBcnToProcess_8720E
-#define TxPktInPSOn 							TxPktInPSOn_8720E
-#define PSSleepTo32K 						PSSleepTo32K_8720E
-#define PSRxBcnProcess 					PSRxBcnProcess_8720E
-#define LowPowerRxBeacon 					LowPowerRxBeacon_8720E
-#define PSPeriodCCA							PSPeriodCCA_8720E
-#define BeaconModeBBAGCtableUpdate 	BeaconModeBBAGCtableUpdate_8720E
-#define BeaconModeDCKbackup 				BeaconModeDCKbackup_8720E
-#define PwrGatedBKRSTxReg					PwrGatedBKRSTxReg_8720E
-#define PwrGatedBKRSCtrlInfo				PwrGatedBKRSCtrlInfo_8720E
-#define PwrGatedBKRSMACTXPower			PwrGatedBKRSMACTXPower_8720E
-#define PwrGatedInitDRFC 					PwrGatedInitDRFC_8720E
-#define PwrGatedBKRSBBTSSIREG			PwrGatedBKRSBBTSSIREG_8720E
-#define PwrGatedInitBBTRX					PwrGatedInitBBTRX_8720E
-#define PwrGatedWifiParmBkRs				PwrGatedWifiParmBkRs_8720E
-#define Set32KLpsOption 					Set32KLpsOption_8720E
-#define InitBcnEarlyAdjustStat 			InitBcnEarlyAdjustStat_8720E
-#define InitBcnEarlyAdjustPID 			InitBcnEarlyAdjustPID_8720E
-#if CONFIG_BCNADJ_LPSOFFLOAD_V2
-#define BcnEarlyADJPIDSearchBaseValue BcnEarlyADJPIDSearchBaseValue_8720E
-#define BcnEarlyADJPIDCheckBaseValue	BcnEarlyADJPIDCheckBaseValue_8720E
-#endif
-#if CONFIG_BCNADJ_LPSOFFLOAD_V1
-#define BcnEarlyADJSTSSearchBaseValue BcnEarlyADJSTSSearchBaseValue_8720E
-#define BcnEarlyADJSTSCheckBaseValue	BcnEarlyADJSTSCheckBaseValue_8720E
-#endif
-#define SetSmartPSTimer					SetSmartPSTimer_8720E
-#define SetPwrStateReg						SetPwrStateReg_8720E
-#define ResetPSParm							ResetPSParm_8720E
-#define ChkTxQueueIsEmpty					ChkTxQueueIsEmpty_8720E
-#define Legacy_PS_Setting					Legacy_PS_Setting_8720E
-#define PSModeSetting						PSModeSetting_8720E
-#define ConfigListenBeaconPeriod		ConfigListenBeaconPeriod_8720E
-#define PSSetMode								PSSetMode_8720E
-#define PS_S2ToS3State						PS_S2ToS3State_8720E
-#define PS_S2ToS0State						PS_S2ToS0State_8720E
-#define PS_S3ToS2orS0State				PS_S3ToS2orS0State_8720E
-#define PS_S0ToS1State						PS_S0ToS1State_8720E
-#define PS_S1ToS0orS2State				PS_S1ToS0orS2State_8720E
-#define PS_S2ToS4State						PS_S2ToS4State_8720E
-#define PS_S2ToS5State		        		PS_S2ToS5State_8720E
-#define PS_S5ToS2State		        		PS_S5ToS2State_8720E
-#define PS_S4ToS2State						PS_S4ToS2State_8720E
-#define SmartPS2InitTimerAndToGetRxPkt	SmartPS2InitTimerAndToGetRxPkt_8720E
-#define SetBcnEarlyAndTimeout			SetBcnEarlyAndTimeout_8720E
-#define EnlargeBcnEarlyAndTimeout		EnlargeBcnEarlyAndTimeout_8720E
-#define PS_S0ToS6State						PS_S0ToS6State_8720E
-#define PS_S6ToS0State						PS_S6ToS0State_8720E
-//LPS offload
-#define LPSOfld_HIOECmdFileInit 		LPSOfld_HIOECmdFileInit_8720E
-#define LPSOfld_RxbcnModeCmdFileValInit	LPSOfld_RxbcnModeCmdFileValInit_8720E
-#define LPSOfld_ExitRxbcnModeCmdFileValInit LPSOfld_ExitRxbcnModeCmdFileValInit_8720E
-#define LPSOfld_SwtHIOECmdFile 			LPSOfld_SwtHIOECmdFile_8720E
-#define LPSOfld_IMRSetting 				LPSOfld_IMRSetting_8720E
-#define LPSOfld_SetBcnErlyandTimeout	LPSOfld_SetBcnErlyandTimeout_8720E
-#define LPSOfld_FuncInit 					LPSOfld_FuncInit_8720E
-#define LPSOfld_PGResume 			LPSOfld_PGResume_8720E
-#define LPSOfld_HWCtrlTRXOnOff 			LPSOfld_HWCtrlTRXOnOff_8720E
-#define LPSOfld_PSRxBcnProcess			LPSOfld_PSRxBcnProcess_8720E
-
-//Sapps
-#define InitSAPPS 							InitSAPPS_8720E
-#define SAPPSTBTTHDL 						SAPPSTBTTHDL_8720E
-#define SAPPSTimeOutHDL 					SAPPSTimeOutHDL_8720E
-#define SAPPSEarlyHDL 						SAPPSEarlyHDL_8720E
-#define SAPLPS 								SAPLPS_8720E
-//IPS
-#define InitInactivePS  					InitInactivePS_8720E
-#define InactivePSTBTTHDL 				InactivePSTBTTHDL_8720E
-#define InactivePSBCNAggEarlyHDL 		InactivePSBCNAggEarlyHDL_8720E
-#define InactivePSEnableHEL 				InactivePSEnableHEL_8720E
-//RA
-#define InitCtrlInfo 						InitCtrlInfo_8720E
-#if CONFIG_CSI_REPORT
-#define HALBB_FW_BBReset					HALBB_FW_BBReset_8720E
-#define CheckCSITxNullDone				CheckCSITxNullDone_8720E
-#define CheckNoCSIClientEnable			CheckNoCSIClientEnable_8720E
-#define CheckNextCSIClientTxnull		CheckNextCSIClientTxnull_8720E
-#define CheckCSIClientTxnullRty			CheckCSIClientTxnullRty_8720E
-#define IssueCSITXNull						IssueCSITXNull_8720E
-#define SetPeriodTxNullAddrRate			SetPeriodTxNullAddrRate_8720E
-#define H2CHDL_Set_CSI_TXNULL 			H2CHDL_Set_CSI_TXNULL_8720E
-#define CSIEnableClientParameter		CSIEnableClientParameter_8720E
-#define CSIDisableClientParameter		CSIDisableClientParameter_8720E
-#endif
-#define halbb_fw_read_rf_reg				halbb_fw_read_rf_reg_8720e
-#define halbb_fw_write_rf_reg			halbb_fw_write_rf_reg_8720e
-#define halbb_fw_set_bb_reg 				halbb_fw_set_bb_reg_8720e
-#define halbb_fw_get_bb_reg				halbb_fw_get_bb_reg_8720e
-
-//Wolwan
-#define InitRemoteWakeUp 					InitRemoteWakeUp_8720E
-#define RemoteWakeUp 						RemoteWakeUp_8720E
-#define ClearRxBuff 							ClearRxBuff_8720E
-#define H2CHDL_RemoteWakeUp 				H2CHDL_RemoteWakeUp_8720E
-#define KeepAliveChk 						KeepAliveChk_8720E
-#define TryPKT 								TryPKT_8720E
-#define GetCheckSum 							GetCheckSum_8720E
-#define GetSumValue 							GetSumValue_8720E
-#define UpdateCheckSumVer2 				UpdateCheckSumVer2_8720E
-#define FillIpv6PseudoHeader 			FillIpv6PseudoHeader_8720E
-#define InitKeepAlive						InitKeepAlive_8720E
-#define H2CHDL_KeepAlive					H2CHDL_KeepAlive_8720E
-#define UpdateRxFFReadPtr_DropPkt		UpdateRxFFReadPtr_DropPkt_8720E
-#define WaitRXDMAIdle						WaitRXDMAIdle_8720E
-#define CHECKRXPKTNULL						CHECKRXPKTNULL_8720E
-#define UpdateChInfoReadPtr_DropPkt	UpdateChInfoReadPtr_DropPkt_8720E
-#define UpdatePhyStsReadPtr_DropPkt	UpdatePhyStsReadPtr_DropPkt_8720E
-#define RxPHYSTSRelease 					RxPHYSTSRelease_8720E
-#define RxCHInfoRelease 					RxCHInfoRelease_8720E
-#define PageOffsetAlignment				PageOffsetAlignment_8720E
-#define DropCHK								DropCHK_8720E
-#define DIGByRSSILps  					DIGByRSSILps_8720E
-#define EnableWoWLAN 						EnableWoWLAN_8720E
-#define DisWoWLAN 							DisWoWLAN_8720E
-#define H2CHDL_WoWLAN 						H2CHDL_WoWLAN_8720E
-#define DropDecision 						DropDecision_8720E
-#define FwDisConnectWakeUpHost			FwDisConnectWakeUpHost_8720E
-#define DestinationMatch					DestinationMatch_8720E
-#define PassSecurityInfoToDriver		PassSecurityInfoToDriver_8720E
-#define GetRemoteControlInfo 			GetRemoteControlInfo_8720E
-#define GetARPInfo 							GetARPInfo_8720E
-#define OnARP									OnARP_8720E
-#define GetNDPInfo 							GetNDPInfo_8720E
-#define IsIPV6 								IsIPV6_8720E
-#define OnNS									OnNS_8720E
-#define Ipv4Match 							Ipv4Match_8720E
-#define MatchUnicastFilter 				MatchUnicastFilter_8720E
-#define WakeUpHostDecision				WakeUpHostDecision_8720E
-#define CheckIV 								CheckIV_8720E
-#define H2CHDL_AOACGlobalInfo			H2CHDL_AOACGlobalInfo_8720E
-#define H2CHDL_AOACRsvdpage1				H2CHDL_AOACRsvdpage1_8720E
-#define H2CHDL_AOACRsvdpage2 			H2CHDL_AOACRsvdpage2_8720E
-#define H2CHDL_AOACRsvdpage3 			H2CHDL_AOACRsvdpage3_8720E
-#define GetAddr 								GetAddr_8720E
-#define ARP_hdl 								ARP_hdl_8720E
-#define NDP_hdl 								NDP_hdl_8720E
-#define InitDisconnectDecision 			InitDisconnectDecision_8720E
-#define DisconnectChk						DisconnectChk_8720E
-#define DisconnectTxNullChk 				DisconnectTxNullChk_8720E
-#define H2CHDL_DisconnectDecision 		H2CHDL_DisconnectDecision_8720E
-#define WakeUpHost              				WakeUpHost_8720E
-#define issue_ARP								issue_ARP_8720E
-#define IssueNA								IssueNA_8720E
-#define GetIV                					GetIV_8720E
-#define GetIVLenAndSecurityType 		GetIVLenAndSecurityType_8720E
-#define GetMACHeaderLen         			GetMACHeaderLen_8720E
-#define UpdateIV								UpdateIV_8720E
-//GTK
-#define AesTkipIvFun            			AesTkipIvFun_8720E
-#define WepIvFun                				WepIvFun_8720E
-#define RTmemcmpBackward       			RTmemcmpBackward_8720E
-#define AssignIvToKeyRsc       			AssignIvToKeyRsc_8720E
-#define AssignKeyRscToIV       			AssignKeyRscToIV_8720E
-#define AesTkipIvCheck       				AesTkipIvCheck_8720E
-#define WepIvCheck       					WepIvCheck_8720E
-
-//Packet
-#define ChangeTransmiteRate         		ChangeTransmiteRate_8720E
-#define PowerBitSetting                 	PowerBitSetting_8720E
-#define IssuePSPoll                       	IssuePSPoll_8720E
-#define ChkandChangePS              		ChkandChangePS_8720E
-#define IssueQNull                          	IssueQNull_8720E
-#define CTS2SelfSetting 					CTS2SelfSetting_8720E
-#define IssueCTS2Self                   	IssueCTS2Self_8720E
-#define IssueRsvdPagePacketSetting 	IssueRsvdPagePacketSetting_8720E
-#define ReadRxBuff                      		ReadRxBuff_8720E
-#define WaitCPUMGQEmpty					WaitCPUMGQEmpty_8720E
-#define PollingReg							PollingReg_8720E
-
-//BTCoex
-#define InitBTMailbox                  		InitBTMailbox_8720E
-#define FillMailbox                    		FillMailbox_8720E
-#define BT2WLMailboxINTHDL             	BT2WLMailboxINTHDL_8720E
-#define BT2WLMailboxINTCheck           	BT2WLMailboxINTCheck_8720E
-#define H2CHDL_BTPSTDMA                	H2CHDL_BTPSTDMA_8720E
-#define BTC_PsTdmaActionDelay          	BTC_PsTdmaActionDelay_8720E
-#define BTC_PsTdmaAction               	BTC_PsTdmaAction_8720E
-#define H2CHDL_BTWifiCtrl              	H2CHDL_BTWifiCtrl_8720E
-#define H2CHDL_WLCalibration           	H2CHDL_WLCalibration_8720E
-#define H2CHDL_BT_Init_Param           	H2CHDL_BT_Init_Param_8720E
-#define C2HWlanInfo                    		C2HWlanInfo_8720E
-#define InitBTCoex                     		InitBTCoex_8720E
-#define BT_TDMA_Slot_Operation_0and3	BT_TDMA_Slot_Operation_0and3_8720E
-#define BT_TDMA_Slot_Operation_1and4	BT_TDMA_Slot_Operation_1and4_8720E
-#define BT_TDMA_Slot_Operation_2and5	BT_TDMA_Slot_Operation_2and5_8720E
-#define DynamicSlotDecision            	DynamicSlotDecision_8720E
-#define BTypeTDMAMultiSlots            	BTypeTDMAMultiSlots_8720E
-#define BTypeTDMABCNEarly              	BTypeTDMABCNEarly_8720E
-#define BTypeTDMATBTThdl               	BTypeTDMATBTThdl_8720E
-#define BTypeTDMALeakAPOperation		BTypeTDMALeakAPOperation_8720E
-#define BTypeTDMATimeOuthdl				BTypeTDMATimeOuthdl_8720E
-#define BTC_RestoreDefaultCoexTable	BTC_RestoreDefaultCoexTable_8720E
-#define BTC_PWRBitOverWrite				BTC_PWRBitOverWrite_8720E
-#define BTC_PsTdmaIssueNull            	BTC_PsTdmaIssueNull_8720E
-#define BTC_PsTdmaOnBcn					BTC_PsTdmaOnBcn_8720E
-#define BTC_BtIqkAction                	BTC_BtIqkAction_8720E
-#define BTC_BtIqkCheck                 	BTC_BtIqkCheck_8720E
-#define BTC_WlanInfoCounterReset		BTC_WlanInfoCounterReset_8720E
-#define BTC_ProceedBtSlot              	BTC_ProceedBtSlot_8720E
-#define BTC_ProtectBCN                 	BTC_ProtectBCN_8720E
-#define BTC_RestoreBtSlot              	BTC_RestoreBtSlot_8720E
-#define BTC_GenRandomValue             	BTC_GenRandomValue_8720E
-#define BTC_WifiWindowSlot             	BTC_WifiWindowSlot_8720E
-#define BTC_Set_GntBt             		BTC_Set_GntBt_8720E
-#if CONFIG_BTCOEX_SLOT_DEBUG
-#define InitBTCoexDebugPort            	InitBTCoexDebugPort_8720E
-#define BTC_SlotGpioDbgCtrl            	BTC_SlotGpioDbgCtrl_8720E
-#endif
-#define BTC_AOACSwitch                 	BTC_AOACSwitch_8720E
-//BTCoex
-#define H2CHDL_BTInfo						H2CHDL_BTInfo_8720E
-#define H2CHDL_ForceBTTxpwr				H2CHDL_ForceBTTxpwr_8720E
-#define H2CHDL_BTIgnoreWlanAct			H2CHDL_BTIgnoreWlanAct_8720E
-#define H2CHDL_AntSelReverse				H2CHDL_AntSelReverse_8720E
-#define H2CHDL_WLOpmode					H2CHDL_WLOpmode_8720E
-#define H2CHDL_BTMpH2C						H2CHDL_BTMpH2C_8720E
-#define H2CHDL_BTControl					H2CHDL_BTControl_8720E
-#define H2CHDL_BT_Page_Scan_Interval	H2CHDL_BT_Page_Scan_Interval_8720E
-#define H2CHDL_GNT_BT_Ctrl				H2CHDL_GNT_BT_Ctrl_8720E
-#define H2CHDL_BT_Only_Test				H2CHDL_BT_Only_Test_8720E
-#define H2CHDL_WL_Port_ID					H2CHDL_WL_Port_ID_8720E
-#define C2HBTLoopback						C2HBTLoopback_8720E
-#define C2HBTMpRpt							C2HBTMpRpt_8720E
-#define C2HBTMailBoxStatus				C2HBTMailBoxStatus_8720E
-#define InitBTCoexTimer					InitBTCoexTimer_8720E
-#define Write778								Write778_8720E
-#define TdmaChangeCoexTable				TdmaChangeCoexTable_8720E
-#define BTNullSetting						BTNullSetting_8720E
-#define IssueBTQNull						IssueBTQNull_8720E
-#define C2HBTInfo								C2HBTInfo_8720E
-#define WL2BTMailboxSend					WL2BTMailboxSend_8720E
-
-//other
-#define TSF_After(a,b)  					((s32)(b)-(s32)(a)<0)
-#define CheckCPUMGQEmpty					CheckCPUMGQEmpty_8720E
-
-//sw tx queue
-#if CONFIG_SW_QUEUE_TX
-#define InitFreeRunTSF						InitFreeRunTSF_8720E
-#define GetFreeRunCnt						GetFreeRunCnt_8720E
-#define GetFreeRunCntU32					GetFreeRunCntU32_8720E
-#define TxPktPollMgntQ						TxPktPollMgntQ_8720E
-#define CPUMGQCancelTx						CPUMGQCancelTx_8720E
-#define SWQTXCheckBusyQState				SWQTXCheckBusyQState_8720E
-#define IsSWQTXAllQEmpty					IsSWQTXAllQEmpty_8720E
-#define PS_PreTxNull						PS_PreTxNull_8720E
-#define PS_PostTxNull1						PS_PostTxNull1_8720E
-#define PS_PostTxNull0						PS_PostTxNull0_8720E
-#define PostTxNull							PostTxNull_8720E
-#define CheckTxNullResult					CheckTxNullResult_8720E
-#define SWQTXTxFeedBack					SWQTXTxFeedBack_8720E
-#define SWQTXEnqueueWaitQ					SWQTXEnqueueWaitQ_8720E
-#define ISR_CPUMGN_POLLED_PKT_DONE	ISR_CPUMGN_POLLED_PKT_DONE_8720E
-#endif
-
-//2 KM4/KR4/DDMA access base
-//3 MAC base address
-#define RTL8720E_IOREG_AHB_BASE					0x40000000
-//3 BB base address
-#define RTL8720E_BBREG_AHB_BASE             	0x40010000
-//3 RF base address
-#define RTL8720E_ARFCREG_AHB_BASE             	0x40017000
-#define RTL8720E_DRFCREG_AHB_BASE             	0x4001E000
-//3 DDMA control base address
-#define RTL8720E_DDMA_CTRL_AHB_BASE         	0x40000000 //0x4000_1200- 0x4000_12FF
-//3 BT mailbox base address
-#define RTL8720E_BT_MAILBOX_AHB_BASE        	0x400011A4
-//3 LLT Table base
-#define RTL8720E_LLT_AHB_BASE					0x40050000//256 byte/entry
-//3 TxReport Buffer base address
-#define RTL8720E_RPTBUF_AHB_BASE            	0x40040000
-#define RTL8720E_CtrlInfo_AHB_BASE          	(RTL8720E_RPTBUF_AHB_BASE)
-#define RTL8720E_TRXRPT_AHB_BASE            	(RTL8720E_RPTBUF_AHB_BASE + 0x280)
-#define RTL8720E_CRC5_AHB_BASE              	(RTL8720E_RPTBUF_AHB_BASE + 0xA80)
-#define RTL8720E_NANRPT_AHB_BASE             	(RTL8720E_RPTBUF_AHB_BASE + 0xA90)
-//3 Rx packet buffer base address
-#define RTL8720E_RXFF_AHB_BASE              	0x40030000
-//3 Tx packet buffer base address
-#define RTL8720E_TXFF_AHB_BASE              	0x40020000
-//3 CAM base address
-#define RTL8720E_SECCAM_AHB_BASE            	0x40050800
-#define RTL8720E_BACAM_AHB_BASE             	0x40051000
-#define RTL8720E_MBIDCAM_AHB_BASE 				0x40051800
-//3 PHYSTS/CHANINFO
-#define RTL8720E_PHYSTS_AHB_BASE            	0x40054000
-#define RTL8720E_CHINFO_AHB_BASE            	0x40052000
-//2 sysreg access
-#define SYSTEM_CTRL_BASE_LPSYS_OFFSET		0x200
-//3 retention access
-#define RETENTION_RAM_AHB_FW_BASE			  	0x000C0130
-
-//offset:
-#define rtl_inb(offset)             				(*(volatile u8 *)((u32)(offset)))
-#define rtl_inw(offset)             				(*(volatile u16 *)((u32)(offset)))
-#define rtl_inl(offset)             				(*(volatile u32 *)((u32)(offset)))
-
-#define rtl_outb(offset,val)        				do { (*(volatile u8 *)((u32)(offset)) = (val));    } while(0)
-#define rtl_outw(offset,val)        				do { (*(volatile u16 *)((u32)(offset)) = (val));    } while(0)
-#define rtl_outl(offset,val)        				do { (*(volatile u32 *)((u32)(offset)) = (val));    } while(0)
-
-//3 MACREG
-//offset :
-#define WritePONRegDWord(offset, value)		rtl_outl((offset)+RTL8720E_IOREG_AHB_BASE, value)
-#define WritePONRegWord(offset, value)		rtl_outw((offset)+RTL8720E_IOREG_AHB_BASE, value)
-#define WritePONRegByte(offset, value) 		rtl_outb((offset)+RTL8720E_IOREG_AHB_BASE, value)
-
-#define ReadPONRegDWord(offset)             	(rtl_inl((offset)+RTL8720E_IOREG_AHB_BASE))
-#define ReadPONRegWord(offset)              	(rtl_inw((offset)+RTL8720E_IOREG_AHB_BASE))
-#define ReadPONRegByte(offset)              	(rtl_inb((offset)+RTL8720E_IOREG_AHB_BASE))
-
-//offset :
-#define WriteMACRegDWord(offset, value)		rtl_outl((offset)+RTL8720E_IOREG_AHB_BASE, value)
-#define WriteMACRegWord(offset, value)      	rtl_outw((offset)+RTL8720E_IOREG_AHB_BASE, value)
-#define WriteMACRegByte(offset, value)      	rtl_outb((offset)+RTL8720E_IOREG_AHB_BASE, value)
-
-#define ReadMACRegDWord(offset)             	(rtl_inl((offset)+RTL8720E_IOREG_AHB_BASE))
-#define ReadMACRegWord(offset)              	(rtl_inw((offset)+RTL8720E_IOREG_AHB_BASE))
-#define ReadMACRegByte(offset)              	(rtl_inb((offset)+RTL8720E_IOREG_AHB_BASE))
-
-//3 LLT TABLE
-#define WriteLLTTableDWord(offset, value)   rtl_outl((offset)+RTL8720E_LLT_AHB_BASE, value)
-#define WriteLLTTableWord(offset, value)   	rtl_outw((offset)+RTL8720E_LLT_AHB_BASE, value)
-#define WriteLLTTableByte(offset, value)   	rtl_outb((offset)+RTL8720E_LLT_AHB_BASE, value)
-
-#define ReadLLTTableDWord(offset)           	(rtl_inl((offset)+RTL8720E_LLT_AHB_BASE))
-#define ReadLLTTableWord(offset)            	(rtl_inw((offset)+RTL8720E_LLT_AHB_BASE))
-#define ReadLLTTableByte(offset)            	(rtl_inb((offset)+RTL8720E_LLT_AHB_BASE))
-
-//3 BB Reg
-#define WritePortBBUlong(offset, value)		rtl_outl((offset)+RTL8720E_BBREG_AHB_BASE, value)
-#define WritePortBBUshort(offset, value)  	rtl_outw((offset)+RTL8720E_BBREG_AHB_BASE, value)
-#define WritePortBBUchar(offset, value)     rtl_outb((offset)+RTL8720E_BBREG_AHB_BASE, value)
-
-#define ReadPortBBUlong(offset)             	(rtl_inl((offset)+RTL8720E_BBREG_AHB_BASE))
-#define ReadPortBBUshort(offset)            	(rtl_inw((offset)+RTL8720E_BBREG_AHB_BASE))
-#define ReadPortBBUchar(offset)             	(rtl_inb((offset)+RTL8720E_BBREG_AHB_BASE))
-
-//3 SEC CAM
-#define WriteSECCAMDWord(offset, value)  	rtl_outl((offset)+RTL8720E_SECCAM_AHB_BASE, value)
-#define WriteSECCAMWord(offset, value)   	rtl_outw((offset)+RTL8720E_SECCAM_AHB_BASE, value)
-#define WriteSECCAMByte(offset, value)   	rtl_outb((offset)+RTL8720E_SECCAM_AHB_BASE, value)
-
-#define ReadSECCAMDWord(offset)          		(rtl_inl((offset)+RTL8720E_SECCAM_AHB_BASE))
-#define ReadSECCAMWord(offset)           		(rtl_inw((offset)+RTL8720E_SECCAM_AHB_BASE))
-#define ReadSECCAMByte(offset)           		(rtl_inb((offset)+RTL8720E_SECCAM_AHB_BASE))
-
-//3 MBID CAM
-#define WriteMBIDCAMDWord(offset, value)  	rtl_outl((offset)+RTL8720E_MBIDCAM_AHB_BASE, value)
-#define WriteMBIDCAMWord(offset, value)   	rtl_outw((offset)+RTL8720E_MBIDCAM_AHB_BASE, value)
-#define WriteMBIDCAMByte(offset, value)   	rtl_outb((offset)+RTL8720E_MBIDCAM_AHB_BASE, value)
-
-#define ReadMBIDCAMDWord(offset)          		(rtl_inl((offset)+RTL8720E_MBIDCAM_AHB_BASE))
-#define ReadMBIDCAMWord(offset)           		(rtl_inw((offset)+RTL8720E_MBIDCAM_AHB_BASE))
-#define ReadMBIDCAMByte(offset)           		(rtl_inb((offset)+RTL8720E_MBIDCAM_AHB_BASE))
-
-//3 BA CAM
-#define WriteBACAMDWord(offset, value)  		rtl_outl((offset)+RTL8720E_BACAM_AHB_BASE, value)
-#define WriteBACAMWord(offset, value)   		rtl_outw((offset)+RTL8720E_BACAM_AHB_BASE, value)
-#define WriteBACAMByte(offset, value)   		rtl_outb((offset)+RTL8720E_BACAM_AHB_BASE, value)
-
-#define ReadBACAMDWord(offset)          		(rtl_inl((offset)+RTL8720E_BACAM_AHB_BASE))
-#define ReadBACAMWord(offset)           		(rtl_inw((offset)+RTL8720E_BACAM_AHB_BASE))
-#define ReadBACAMByte(offset)           		(rtl_inb((offset)+RTL8720E_BACAM_AHB_BASE))
-
-//3 ReportBUFF
-#define WriteRPTBUFDWord(offset, value)  	rtl_outl((offset)+RTL8720E_RPTBUF_AHB_BASE, value)
-#define WriteRPTBUFWord(offset, value)   	rtl_outw((offset)+RTL8720E_RPTBUF_AHB_BASE, value)
-#define WriteRPTBUFByte(offset, value)   	rtl_outb((offset)+RTL8720E_RPTBUF_AHB_BASE, value)
-
-#define ReadRPTBUFDWord(offset)          		(rtl_inl((offset)+RTL8720E_RPTBUF_AHB_BASE))
-#define ReadRPTBUFWord(offset)           		(rtl_inw((offset)+RTL8720E_RPTBUF_AHB_BASE))
-#define ReadRPTBUFByte(offset)           		(rtl_inb((offset)+RTL8720E_RPTBUF_AHB_BASE))
-
-//3 RXFF
-#define WriteRXFFDWord(offset, value)   		rtl_outl((offset)+RTL8720E_RXFF_AHB_BASE, value)
-#define WriteRXFFWord(offset, value)    		rtl_outw((offset)+RTL8720E_RXFF_AHB_BASE, value)
-#define WriteRXFFByte(offset, value)    		rtl_outb((offset)+RTL8720E_RXFF_AHB_BASE, value)
-
-#define ReadRXFFDWord(offset)           		(rtl_inl((offset)+RTL8720E_RXFF_AHB_BASE))
-#define ReadRXFFWord(offset)            			(rtl_inw((offset)+RTL8720E_RXFF_AHB_BASE))
-#define ReadRXFFByte(offset)            			(rtl_inb((offset)+RTL8720E_RXFF_AHB_BASE))
-
-//3 TXFF
-#define WriteTXFFDWord(offset, value)     	rtl_outl((offset)+RTL8720E_TXFF_AHB_BASE, value)
-#define WriteTXFFWord(offset, value)      	rtl_outw((offset)+RTL8720E_TXFF_AHB_BASE, value)
-#define WriteTXFFByte(offset, value)      	rtl_outb((offset)+RTL8720E_TXFF_AHB_BASE, value)
-
-#define ReadTXFFDWord(offset)             		(rtl_inl((offset)+RTL8720E_TXFF_AHB_BASE))
-#define ReadTXFFWord(offset)              		(rtl_inw((offset)+RTL8720E_TXFF_AHB_BASE))
-#define ReadTXFFByte(offset)              		(rtl_inb((offset)+RTL8720E_TXFF_AHB_BASE))
-
-//3 Retention RAM
-#define WriteRRamDWord(offset, value)     	rtl_outl((offset)+RETENTION_RAM_AHB_FW_BASE, value)
-#define WriteRRamWord(offset, value)      	rtl_outw((offset)+RETENTION_RAM_AHB_FW_BASE, value)
-#define WriteRRamByte(offset, value)     	 	rtl_outb((offset)+RETENTION_RAM_AHB_FW_BASE, value)
-
-#define ReadRRamDWord(offset)             		(rtl_inl((offset)+RETENTION_RAM_AHB_FW_BASE))
-#define ReadRRamWord(offset)              		(rtl_inw((offset)+RETENTION_RAM_AHB_FW_BASE))
-#define ReadRRamByte(offset)              		(rtl_inb((offset)+RETENTION_RAM_AHB_FW_BASE))
-
-//3 TX report buffer access
-
-#define ReadCtrlInfoByte(macid, offset) 		rtl_inb(RTL8720E_CtrlInfo_AHB_BASE + (macid*40) + (offset))    //macid range: 0~16; offset range: 0~40
-#define ReadCtrlInfoDWord(macid, offset) 	rtl_inl(RTL8720E_CtrlInfo_AHB_BASE + (macid*40) + (offset))    //macid range: 0~16; offset range: 0~40
-#define WriteCtrlInfoByte(macid, offset, val)		rtl_outb(RTL8720E_CtrlInfo_AHB_BASE + (macid*40) + (offset), val)
-#define WriteCtrlInfoDWord(macid, offset, val)	rtl_outl(RTL8720E_CtrlInfo_AHB_BASE + (macid*40) + (offset), val)
-
-
-#define WriteTxrptByte(macid,offset,val)	rtl_outb(RTL8720E_TRXRPT_AHB_BASE + (macid<<4) + (offset), val) //macid range: 0~16; offset range: 0~15
-#define WriteTxrptDWord(macid,offset,val)	rtl_outl(RTL8720E_TRXRPT_AHB_BASE + (macid<<4) + (offset), val)
-#define ReadTxrptByte(macid,offset)   		rtl_inb(RTL8720E_TRXRPT_AHB_BASE + (macid<<4) + (offset))
-#define ReadTxrptDWord(macid,offset)  		rtl_inl(RTL8720E_TRXRPT_AHB_BASE + (macid<<4) + (offset))
-
-#define ReadCRC5Byte(macid, offset)  			rtl_inb(RTL8720E_CRC5_AHB_BASE + (macid) + (offset))       //rpt_idx range: 0~15; offset range: 0~1
-#define WriteCRC5Byte(macid, offset, val)  	rtl_outb(RTL8720E_CRC5_AHB_BASE + (macid) + (offset), val)
-
-#define ReadNANrptByte(offset)         			rtl_inb(RTL8720E_NANRPT_AHB_BASE  + (offset))
-#define ReadNANrptDWORD(offset)        			rtl_inl(RTL8720E_NANRPT_AHB_BASE  + (offset))
-#define WriteNANrptByte(offset, val)      	rtl_outb(RTL8720E_NANRPT_AHB_BASE + (offset), val)
-#define WriteNANrptDWORD(offset, val)      	rtl_outl(RTL8720E_NANRPT_AHB_BASE + (offset), val)
-
-//3 BT mailbox
-#define WriteBTMailboxDWord(offset, value)	rtl_outl((offset)+RTL8720E_BT_MAILBOX_AHB_BASE, value)
-#define WriteBTMailboxWord(offset, value)	rtl_outw((offset)+RTL8720E_BT_MAILBOX_AHB_BASE, value)
-#define WriteBTmailboxByte(offset, value)	rtl_outb((offset)+RTL8720E_BT_MAILBOX_AHB_BASE, value)
-
-#define ReadBTMailboxDWord(offset)        	(rtl_inl((offset)+RTL8720E_BT_MAILBOX_AHB_BASE))
-#define ReadBTMailboxWord(offset)          	(rtl_inw((offset)+RTL8720E_BT_MAILBOX_AHB_BASE))
-#define ReadBTMailboxByte(offset)        		(rtl_inb((offset)+RTL8720E_BT_MAILBOX_AHB_BASE))
-
-//3 DDMA
-#define WriteDDMADWord(offset, value)     	rtl_outl((offset)+RTL8720E_DDMA_CTRL_AHB_BASE, value)
-#define WriteDDMAWord(offset, value)      	rtl_outw((offset)+RTL8720E_DDMA_CTRL_AHB_BASE, value)
-#define WriteDDMAByte(offset, value)      	rtl_outb((offset)+RTL8720E_DDMA_CTRL_AHB_BASE, value)
-
-#define ReadDDMADWord(offset)             		(rtl_inl((offset)+RTL8720E_DDMA_CTRL_AHB_BASE))
-#define ReadDDMAWord(offset)                		(rtl_inw((offset)+RTL8720E_DDMA_CTRL_AHB_BASE))
-#define ReadDDMAByte(offset)               		(rtl_inb((offset)+RTL8720E_DDMA_CTRL_AHB_BASE))
-
-//3 physts
-#define WritePHYSTSDWord(offset, value)     	rtl_outl((offset+RTL8720E_PHYSTS_AHB_BASE), value)
-#define WritePHYSTWord(offset, value)      	rtl_outw((offset+RTL8720E_PHYSTS_AHB_BASE), value)
-#define WritePHYSTByte(offset, value)      	rtl_outb((offset+RTL8720E_PHYSTS_AHB_BASE), value)
-
-#define ReadPHYSTDWord(offset)             		(rtl_inl((offset+RTL8720E_PHYSTS_AHB_BASE)))
-#define ReadPHYSTWord(offset)                	(rtl_inw((offset+RTL8720E_PHYSTS_AHB_BASE)))
-#define ReadPHYSTByte(offset)               	(rtl_inb((offset+RTL8720E_PHYSTS_AHB_BASE)))
-
-//3 channel info
-#define WriteCHINFODWord(offset, value)     	rtl_outl((offset+RTL8720E_CHINFO_AHB_BASE), value)
-#define WriteCHINFOWord(offset, value)      	rtl_outw((offset+RTL8720E_CHINFO_AHB_BASE), value)
-#define WriteCHINFOByte(offset, value)      	rtl_outb((offset+RTL8720E_CHINFO_AHB_BASE), value)
-
-#define ReadCHINFODWord(offset)             	(rtl_inl((offset+RTL8720E_CHINFO_AHB_BASE)))
-#define ReadCHINFOWord(offset)                	(rtl_inw((offset+RTL8720E_CHINFO_AHB_BASE)))
-#define ReadCHINFOByte(offset)               	(rtl_inb((offset+RTL8720E_CHINFO_AHB_BASE)))
-
-//3 lpssyson
-#define WriteLSONDWord(offset, value)        rtl_outl((offset)+SYSTEM_CTRL_BASE, value)
-#define WriteLSONWord(offset, value)         	rtl_outw((offset)+SYSTEM_CTRL_BASE, value)
-#define WriteLSONByte(offset, value)         	rtl_outb((offset)+SYSTEM_CTRL_BASE, value)
-
-#define ReadLSONDWord(offset)                	(rtl_inl((offset)+SYSTEM_CTRL_BASE))
-#define ReadLSONWord(offset)                 	(rtl_inw((offset)+SYSTEM_CTRL_BASE))
-#define ReadLSONByte(offset)                 	(rtl_inb((offset)+SYSTEM_CTRL_BASE))
-
-#define RFCRegToByteAddr(x)		((x)<<2)
-
-//============================================================================
-//       8720E Regsiter Bit and Content definition
-//============================================================================
-//WLAN PHY EN        0x0006
-#define BIT_FEN_BB_GLB_RST     			BIT0
-#define BIT_FEN_BB_RSTB              		BIT1
-//MCUFWDL     0x0080
-#define WINTINI_RDY                 			BIT6
-#define RAM_DL_SEL                  			BIT7
-//TXPAUSE 0x522
-#define MAC_STOPBK                  			BIT0
-#define MAC_STOPBE                  			BIT1
-#define MAC_STOPVI                  			BIT2
-#define MAC_STOPVO                  			BIT3
-#define MAC_STOPMGQ                 			BIT4
-#define MAC_STOPHIQ                 			BIT5
-#define MAC_STOPBCNQ                		BIT6
-#define MAC_STOPCPUMGQ			        	BIT7
-
-/*------------------------Export global variable------------------------------*/
-typedef struct _HAL_DATA_COMMON {
-	u8  HCISel;
-} HAL_DATA_COMMON, *PHAL_DATA_COMMON;
-
-typedef struct _HAL_DATA_8720E {
-
-	u32 fwimr[2];
-	u32 fwisr[2];
-
-	u32 wlanimr[6];
-	u32 wlanisr[6];
-
-	u32 ftimr[3];
-	u32 ftisr[3];
-
-} HAL_DATA_8720E, *PHAL_DATA_8720E;
-
-#endif  /* __ASSEMBLY__ */
-#endif  /* __WIFIFW_HAL_RAM_H__ */
diff --git a/os/board/rtl8720e/src/component/wifi/wifi_fw/amebalite/include/wififw_halbb_cmd_ram.h b/os/board/rtl8720e/src/component/wifi/wifi_fw/amebalite/include/wififw_halbb_cmd_ram.h
deleted file mode 100644
index b3b34dc9f..000000000
--- a/os/board/rtl8720e/src/component/wifi/wifi_fw/amebalite/include/wififw_halbb_cmd_ram.h
+++ /dev/null
@@ -1,297 +0,0 @@
-
-#ifndef __WIFIFW_HALBB_CMD_RAM_H__
-#define __WIFIFW_HALBB_CMD_RAM_H__
-
-/*--------------------Define -------------------------------------------*/
-#define STA_NUM_RSSI_CMD    8
-#define SIZE_RSSI_CMD  8
-#define H2C_CLASS_HALBB_MAX 7
-#define C2H_CAT_HALBB   0x2
-#define STA_NUM_CQI_CMD 8
-#define SIZE_CQI_CMD  24
-#define STA_NUM_SWGRP_CMD 8
-#define SIZE_SWGRP_CMD  12
-#define STA_NUM_ULMACIDCFG_CMD 8
-#define SIZE_ULMACIDCFG_CMD  8
-#define UPDATE_DL_CQI 0
-#define UPDATE_UL_CQI 1
-#define CSI_CONTENT_START 12
-
-/*TestMode*/
-//#define TEST_MACID  0x0
-#define TEST_BW_NUUPDATE    0x0
-#define TEST_DISABLERA  0x0
-#define TEST_MODE_SEL_BG  BIT(0)|BIT(1)
-#define TEST_MODE_SEL_HT  BIT(0)|BIT(1)|BIT(2)
-#define TEST_MODE_SEL_VHT  BIT(0)|BIT(1)|BIT(3)
-#define TEST_MODE_SEL_HE  BIT(0)|BIT(1)|BIT(4)
-#define TEST_MODE_SEL TEST_MODE_SEL_HT
-#define TEST_BW_20 0x0
-#define TEST_BW_40 0x1
-#define TEST_BW TEST_BW_20
-#define TEST_SS_NUM 0x0 /*1SS*/
-#define TEST_GI_LTF 0x0
-#define TEST_INIT_LV    0x0
-#define TEST_SGI_EN 0
-
-
-#define CLASSID_RUA 0x0
-#define CLASSID_RA 0x1
-#define CLASSID_HALBB 0x2
-
-#define     TBL_DLRU_GRPTBL 0x0
-#define     TBL_ULRU_GRPTBL 0x1
-#define     TBL_RU_STAINFO 0x2
-#define     TBL_DL_RU_FIXTBL 0x3
-#define     TBL_UL_RU_FIXTBL 0x4
-#define     TBL_BA_INFOTBL 0x5
-#define     TBL_MU_FIXINFO 0x6
-#define     TBL_UL_FIXINFO 0x7
-#define     TBL_TESTMODE 0x8
-
-
-/*--------------------Define Enum---------------------------------------*/
-
-
-
-/**
- * @enum HALBB_BAND_TYPE_
- *
- * @brief HALBB_BAND_TYPE_
- *
- * @var HALBB_BAND_TYPE_::BAND_ON_24G
- * Please Place Description here.
- * @var HALBB_BAND_TYPE_::BAND_ON_5G
- * Please Place Description here.
- * @var HALBB_BAND_TYPE_::BAND_ON_6G
- * Please Place Description here.
- * @var HALBB_BAND_TYPE_::BAND_MAX
- * Please Place Description here.
- */
-enum HALBB_BAND_TYPE_ {
-	BAND_ON_24G = 0,
-	BAND_ON_5G  = 1,
-	BAND_ON_6G  = 2,
-	BAND_MAX,
-};
-
-
-/**
- * @enum HALBB_EDCCA_MODE_
- *
- * @brief HALBB_EDCCA_MODE_
- *
- * @var HALBB_EDCCA_MODE_::EDCCA_NORMAL_MODE
- * Please Place Description here.
- * @var HALBB_EDCCA_MODE_::EDCCA_ADAPT_MODE
- * Please Place Description here.
- * @var HALBB_EDCCA_MODE_::EDCCA_CARRIER_SENSE_MODE
- * Please Place Description here.
- */
-enum HALBB_EDCCA_MODE_ {
-	EDCCA_NORMAL_MODE = 0,
-	EDCCA_ADAPT_MODE = 1,
-	EDCCA_CARRIER_SENSE_MODE = 2,
-};
-
-
-
-/**
- * @enum HALBB_C2H_RA_CMDID
- *
- * @brief HALBB_C2H_RA_CMDID
- *
- * @var HALBB_C2H_RA_CMDID::C2HRA_STS_RPT
- * Please Place Description here.
- * @var HALBB_C2H_RA_CMDID::C2HRA_MU_GPTBL_RPT
- * Please Place Description here.
- * @var HALBB_C2H_RA_CMDID::C2HRA_TXSTS
- * Please Place Description here.
- * @var HALBB_C2H_RA_CMDID::MAX_C2HRACMD
- * Please Place Description here.
- */
-enum HALBB_C2H_RA_CMDID {
-	C2HRA_STS_RPT       = 0x16,
-	//C2HRA_MU_GPTBL_RPT      = 0x1,
-	C2HRA_TXSTS             = 0x17,
-	MAX_C2HRACMD
-};
-
-/*--------------------Define MACRO--------------------------------------*/
-
-/*--------------------Define Struct-------------------------------------*/
-
-
-/**
- * @struct halbb_c2h_hdr
- * @brief halbb_c2h_hdr
- *
- * @var halbb_c2h_hdr::func
- * Please Place Description here.
- * @var halbb_c2h_hdr::cat
- * Please Place Description here.
- * @var halbb_c2h_hdr::total_len
- * Please Place Description here.
- */
-struct halbb_c2h_hdr {
-	u8 func;
-	u8 class;
-	u8 cat;
-	u16 total_len;
-};
-
-
-/**
- * @struct _h2c_fwtrace_
- * @brief _h2c_fwtrace_
- *
- * @var _h2c_fwtrace_::halbb_dbg_comp
- * Please Place Description here.
- * @var _h2c_fwtrace_::halbb_fwtrace
- * Please Place Description here.
- */
-typedef struct _h2c_fwtrace_ {
-	//for modify kr4 memory align warning
-	u8 halbb_dbg_comp_0;
-	u8 halbb_dbg_comp_1;
-	u8 halbb_dbg_comp_2;
-	u8 halbb_dbg_comp_3;
-	u8 halbb_fwtrace;
-} H2C_FWTRACE, *PH2C_FWTRACE;
-
-
-/**
- * @struct _h2c_fw_edcca_
- * @brief _h2c_fw_edcca_
- *
- * @var _h2c_fw_edcca_::mode
- * Please Place Description here.
- * @var _h2c_fw_edcca_::band
- * Please Place Description here.
- * @var _h2c_fw_edcca_::pwr_th_5g
- * Please Place Description here.
- * @var _h2c_fw_edcca_::pwr_th_2p4
- * Please Place Description here.
- * @var _h2c_fw_edcca_::pwr_th_cs
- * Please Place Description here.
- */
-struct _h2c_fw_edcca_ {
-	u8 mode;
-	u8 band;
-	u8 pwr_th_5g;
-	u8 pwr_th_2p4;
-	u8 pwr_th_cs;
-};
-
-
-/**
- * @struct _c2h_rpt_txsts_
- * @brief _c2h_rpt_txsts_
- *
- * @var _c2h_rpt_txsts_::macid
- * Please Place Description here.
- * @var _c2h_rpt_txsts_::avg_agg
- * Please Place Description here.
- * @var _c2h_rpt_txsts_::rsvd
- * Please Place Description here.
- * @var _c2h_rpt_txsts_::tx_ok
- * Please Place Description here.
- * @var _c2h_rpt_txsts_::tx_retry
- * Please Place Description here.
- * @var _c2h_rpt_txsts_::tx_rate
- * Please Place Description here.
- * @var _c2h_rpt_txsts_::retry_ratio
- * Please Place Description here.
- * @var _c2h_rpt_txsts_::rsvd2
- * Please Place Description here.
- * @var _c2h_rpt_txsts_::tx_total
- * Please Place Description here.
- * @var _c2h_rpt_txsts_::rsvd3
- * Please Place Description here.
- * @var _c2h_rpt_txsts_::rsvd4
- * Please Place Description here.
- * @var _c2h_rpt_txsts_::rsvd5
- * Please Place Description here.
- */
-struct _c2h_rpt_txsts_ {
-	u8 macid;
-	u8 avg_agg;
-	u16 rsvd;
-
-	u16 tx_ok[4];
-
-	u16 tx_retry[4];
-
-	u16 tx_rate;
-	u8 retry_ratio;
-	u8 rsvd2;
-
-	u16 tx_total;
-	u16 rsvd3;
-
-	u16 rsvd4;
-	u16 rsvd5;
-};
-
-
-/**
- * @struct _H2C_CMD_RSSI_CONTENT_
- * @brief _H2C_CMD_RSSI_CONTENT_
- *
- * @var _H2C_CMD_RSSI_CONTENT_::macid
- * Please Place Description here.
- * @var _H2C_CMD_RSSI_CONTENT_::rssi
- * Please Place Description here.
- * @var _H2C_CMD_RSSI_CONTENT_::rainfo
- * Please Place Description here.
- * @var _H2C_CMD_RSSI_CONTENT_::drv_ra_ctrl
- * Please Place Description here.
- * @var _H2C_CMD_RSSI_CONTENT_::is_fixed_rate
- * Please Place Description here.
- * @var _H2C_CMD_RSSI_CONTENT_::fixed_rate
- * Please Place Description here.
- * @var _H2C_CMD_RSSI_CONTENT_::fixed_gi_ltf
- * Please Place Description here.
- * @var _H2C_CMD_RSSI_CONTENT_::fixed_bw
- * Please Place Description here.
- * @var _H2C_CMD_RSSI_CONTENT_::rsvd4
- * Please Place Description here.
- */
-typedef struct _H2C_CMD_RSSI_CONTENT_ {
-	// DWORD 0
-	u32 macid: 8;
-	u32 rssi: 8;
-	u32 rainfo: 16;
-
-	//DWORD 1
-	u32 drv_ra_ctrl: 8;
-	u32 is_fixed_rate: 1;
-	u32 fixed_rate: 9;
-	u32 fixed_gi_ltf: 3;
-	u32 fixed_bw: 2;
-	u32 rsvd4: 9;
-
-} H2C_CMD_RSSI_CONTENT, *PH2C_CMD_RSSI_CONTENT;
-
-#if 0
-extern void
-halbb_fw_l6m_wa(
-	u8 *content
-);
-#endif
-
-
-
-extern void Halbb_h2chdl(
-	u8  CmdID,
-	u8  *content
-);
-
-
-extern void
-Halbb_c2hhdl(
-	u8  cmdid,
-	u16 len,
-	u8  *content);
-
-#endif //HALBBCOMM_CMD_RAM_H__
diff --git a/os/board/rtl8720e/src/component/wifi/wifi_fw/amebalite/include/wififw_hioe_ram.h b/os/board/rtl8720e/src/component/wifi/wifi_fw/amebalite/include/wififw_hioe_ram.h
deleted file mode 100644
index 45b57afb4..000000000
--- a/os/board/rtl8720e/src/component/wifi/wifi_fw/amebalite/include/wififw_hioe_ram.h
+++ /dev/null
@@ -1,56 +0,0 @@
-#ifndef __WIFIFW_HIOE_RAM_H__
-#define __WIFIFW_HIOE_RAM_H__
-/*--------------------Define --------------------------------------------*/
-
-#define HIOE_BACKUP		1
-#define HIOE_RESTORE	0
-#define HIOECmdFileEndFlg	(0x00000000)
-#define HIOECmdFileRsValEndFlg	(0xFF)
-#define HIOE_ACCESS_BYTE_MODE	(0x00000000)
-#define HIOE_ACCESS_DWORD_MODE	(0x00000001)
-#define HIOE_DELAY_MODE	(0x00000003)
-#define HIOE_MODE_MASK	(0x00000003)
-#define HIOE_BYTE_SEL_MASK	(0x0000000F)
-#define HIOE_BYTE_SEL_MASK_SHT	(24)
-#define HIOE_REG_ADDR_MASK	(0x003FFFFF)
-#define HIOE_REG_ADDR_MASK_SHT	(2)
-#define HIOE_DATA_BYTE0_MASK	(0xFF000000) //bit 24~31
-#define HIOE_DATA_BYTE123_MASK	(0x00FFFFFF) //bit 32~55
-#define HIOECMD_SIZE_WM		(8)
-#define HIOECMD_SIZE_BM		(4)
-#define HIOECMD_SIZE_DM		(4)
-#define HIOECMD_ARfcRegBaseAddr		(0x17000)
-#define HIOECMD_DRfcRegBaseAddr		(0x1E000)
-
-#define HIOE_DM_INITVALTAB_TYPE(x) 	((x)|BIT(4))
-#define HIOE_CMDFILE_SIZE(x)		((sizeof(x) - 4)*2)
-
-#define HIOECMD_WM0(reg_addr)		\
-	(HIOE_ACCESS_DWORD_MODE | ((((u32)(reg_addr)) & HIOE_REG_ADDR_MASK)<<HIOE_REG_ADDR_MASK_SHT))
-
-#define HIOECMD_WM1(byte_sel)		(((u32)(byte_sel) & HIOE_BYTE_SEL_MASK)<<HIOE_BYTE_SEL_MASK_SHT)
-
-
-#define HIOECMD_BM(reg_addr)		\
-	(HIOE_ACCESS_BYTE_MODE | ((((u32)(reg_addr)) & HIOE_REG_ADDR_MASK)<<HIOE_REG_ADDR_MASK_SHT))
-
-#define HIOECMD_DM(delay_time)		\
-	(HIOE_DELAY_MODE | ((((u32)(delay_time)) & HIOE_REG_ADDR_MASK)<<HIOE_REG_ADDR_MASK_SHT))
-#define HIOECMD_GetMode(x)	((x)&HIOE_MODE_MASK)
-
-typedef struct HIOECmdFileRSValue {
-	/*bytemak 0: byte cmd mode, else value mean the real dword cmd mode byte mask*/
-	u8 bytemask;
-	u32 RSValue;
-} HIOECmdFileRSVal;
-/*--------------------Function declaration---------------------------------*/
-extern u32 PG_BackupRestoreREGTable[];
-extern void HIOESetSingleCmdValWM_8720E(u32 CmdAddrIn8byte, u32 value);
-extern void HIOESetSingleCmdValBM_8720E(u32 cmdaddrIn4byte, u8 value);
-extern BOOLEAN HIOECmdInitValTypeChk_8720E(u8 HIOECmdType, u8 InitValByteMask);
-extern BOOLEAN HIOEChkChanelIdle_8720E(u32 chn_ctrl_reg, u32 backup_req_bit, u32 restore_reg_bit);
-extern void HIOEInitCmdFileToTXFF_8720E(u32 *HIOECmdFileTab, HIOECmdFileRSVal *HIOECmdFileRsValTab, u32 TXFF_Offset);
-extern void HIOESetHIOEConfigFile_8720E(void);
-extern void HIOEBackupRestore_8720E(bool mode);
-extern void HIOECHKHigh8kTXFFPGUseOverlap_8720E(void);
-#endif
diff --git a/os/board/rtl8720e/src/component/wifi/wifi_fw/amebalite/include/wififw_init_ram.h b/os/board/rtl8720e/src/component/wifi/wifi_fw/amebalite/include/wififw_init_ram.h
deleted file mode 100644
index 87ff80bc8..000000000
--- a/os/board/rtl8720e/src/component/wifi/wifi_fw/amebalite/include/wififw_init_ram.h
+++ /dev/null
@@ -1,41 +0,0 @@
-#ifndef __WIFIFW_INIT_RAM_H__
-#define __WIFIFW_INIT_RAM_H__
-
-
-/* REG_CLKDIV 0x0008 */
-#define MAC_CLK_20M				(0x2 << BIT_SHIFT_MAC_CLK_SEL)
-#define MAC_CLK_40M				(0x1 << BIT_SHIFT_MAC_CLK_SEL)
-#define BIT_SHIFT_PRETX_AGGR_TIME_MAX                8
-#define BIT_SHIFT_MAC_CLK_SEL                        18
-
-/* REG_FWHW_TXQ_HWSSN_CTRL[31:24] */
-#define BIT_HWSEQ_VO_EN		BIT0
-#define BIT_HWSEQ_VI_EN		BIT1
-#define BIT_HWSEQ_BE_EN		BIT2
-#define BIT_HWSEQ_BK_EN		BIT3
-#define BIT_HWSEQ_MGT_EN		BIT4
-#define BIT_HWSEQ_HI_EN		BIT5
-#define BIT_HWSEQ_BCN_EN		BIT6
-#define BIT_HWSEQ_CPUM_EN		BIT7
-/* General Purpose Timer (Offset: 0x0150 - 0x016Fh) */
-#define MODE_TIMER					1
-#define MODE_COUNTER				0
-
-#define TC_ENABLE						BIT0
-#define TC_TIMER_MODE				BIT1
-#define TC_INT_ENABLE				BIT2
-/*--------------------Function declaration---------------------------------*/
-extern void InitGTimer32us_8720E(u16 timer_addr, u8 _mode, u8 Unit2s, u8 Unit8ms, u8 Unit32us);
-extern void InitGTimer1ms_8720E(u16 timer_addr, u8 _mode, u8 Unit65s, u8 Unit256ms, u8 Unit1ms);
-extern void driver_fw_flow_ipc_int(VOID *Data, u32 IrqStatus, u32 ChanNum);
-extern void wifi_FW_Vera_test(void);
-extern void wifi_FW_init_ram(void);
-extern void TaskCommon_8720E(void);
-extern void TaskInit_8720E(void);
-extern void Wifi_FW_TaskIdle(void);
-extern void Fw_test_main(void);
-extern void FwIntInit(void);
-extern void TimerTest(void);
-extern void SOCZB_test_main(void);
-
-#endif /* __WIFIFW_INIT_RAM_H__ */
diff --git a/os/board/rtl8720e/src/component/wifi/wifi_fw/amebalite/include/wififw_interrupt_ram.h b/os/board/rtl8720e/src/component/wifi/wifi_fw/amebalite/include/wififw_interrupt_ram.h
deleted file mode 100644
index 7776fbb30..000000000
--- a/os/board/rtl8720e/src/component/wifi/wifi_fw/amebalite/include/wififw_interrupt_ram.h
+++ /dev/null
@@ -1,82 +0,0 @@
-#ifndef __WIFIFW_INT_RAM_H__
-#define __WIFIFW_INT_RAM_H__
-
-/*--------------------Define --------------------------------------------*/
-#define CLKIs32K  1
-#define CLKIs40M  0
-
-/*--------------------Function declaration---------------------------------*/
-extern void WLAN_INT_HDL_8720E(void);
-extern void FT_INT_HDL_8720E(void);
-extern void ISRSendSignalCommon_8720E(u32  event);
-extern void ISR_TBTT_8720E(void);
-extern void ISR_BCNRx_8720E(void);
-extern void ISR_BCNRxErr_8720E(void);
-extern void ISR_P0_TBTT_AGG_8720E(void);
-extern void ISR_TIM_NO_HIT_8720E(void);
-extern void ISR_TIM_HIT_8720E(void);
-extern void ISR_HIOE_CHN0_8720E(void);
-extern void ISR_HIOE_CHN1_8720E(void);
-extern void ISR_HIOE_CHN_ON_8720E(void);
-extern void ISR_HIOE_CHN_OFF_8720E(void);
-extern void ISR_TSF_GT_THRES_8720E(void);
-extern void ISR_RXBCN_TIMEUP_8720E(void);
-extern void ISR_RXBCN_TIMEOUT_CNT_8720E(void);
-extern void ISR_RxBMC_MD0_8720E(void);
-extern void ISR_RxBMC_MD1_8720E(void);
-extern void ISR_RxUnicast_MD1_8720E(void);
-extern void ISR_RxUnicast_MD0_8720E(void);
-extern void ISR_TxPKTIn_8720E(void);
-extern void ISR_GTimer0_8720E(void);
-extern void ISR_GTimer1_8720E(void);
-extern void ISR_GTimer2_8720E(void);
-extern void ISR_RPWM_8720E(void);
-extern void ISR_GTimer5_8720E(void);
-extern void ISR_BcnEarlyAGG_8720E(void);
-extern void ISR_GTimer6_8720E(void);
-extern void ISR_WlanActOn_8720E(void);
-extern void ISR_WlanActOff_8720E(void);
-extern void ISR_TxNull0_8720E(void);
-extern void ISR_TxNull1_8720E(void);
-extern void ISR_PSTIMERA_8720E(void);
-extern void ISR_PSTIMERAEarly_8720E(void);
-extern void ISR_PSTIMEOUT0_8720E(void);
-extern void ISR_PSTIMERB_8720E(void);
-extern void ISR_PSTIMERBEarly_8720E(void);
-extern void ISR_PSTIMEOUT1_8720E(void);
-extern void ISR_PSTIMERC_8720E(void);
-extern void ISR_PSTIMERCEarly_8720E(void);
-extern void ISR_PSTIMEOUT2_8720E(void);
-extern void ISR_PSTIMERD_8720E(void);
-extern void ISR_PSTIMERDEarly_8720E(void);
-extern void ISR_PSTIMERE_8720E(void);
-extern void ISR_TBTT1_8720E(void);
-extern void ISR_TXCCX_8720E(void);
-extern void ISR_RxDone_8720E(void);
-extern void ISR_H2CCMD_8720E(void);
-extern void ISR_HRCV_8720E(void);
-extern void ISR_BcnEarly_8720E(void);
-extern void ISR_GTimer3_8720E(void);
-extern void ISR_GTimer4_8720E(void);
-extern void ISR_BCNERLY1_8720E(void);
-extern void ISR_BTScoreboard_8720E(void);
-extern void ISR_ZBMailbox_8720E(void);
-extern void ISR_GNT_BT_Rise_8720E(void);
-extern void ISR_GNT_BT_Fall_8720E(void);
-extern void ISR_CPUMGN_POLLED_PKT_DONE_8720E(void);
-extern void ClrAllFWUsedIMR_8720E(void);
-extern void ClrAllFWUsedISR_8720E(void);
-extern void UpdateISRWlan_8720E(void);
-extern void UpdateISRFT_8720E(void);
-extern void setfwimr_8720E(u32 index, u32 bitmask);
-extern void clrfwimr_8720E(u32 index, u32 bitmask);
-extern void setwlanimr_8720E(u32 index, u32 bitmask);
-extern void clrwlanimr_8720E(u32 index, u32 bitmask);
-extern void setftimr_8720E(u32 index, u32 bitmask);
-extern void clrftimr_8720E(u32 index, u32 bitmask);
-#if CONFIG_RATE_ADAPTIVE
-extern void ISR_TxrptCntFull_8720E(void);
-#endif
-
-
-#endif  /* __WIFIFW_INT_RAM_H__ */
diff --git a/os/board/rtl8720e/src/component/wifi/wifi_fw/amebalite/include/wififw_lps_offload_ram.h b/os/board/rtl8720e/src/component/wifi/wifi_fw/amebalite/include/wififw_lps_offload_ram.h
deleted file mode 100644
index b1a26f625..000000000
--- a/os/board/rtl8720e/src/component/wifi/wifi_fw/amebalite/include/wififw_lps_offload_ram.h
+++ /dev/null
@@ -1,26 +0,0 @@
-#ifndef _WIFIFW_LPS_OFFLOAD_RAM_H_
-#define _WIFIFW_LPS_OFFLOAD_RAM_H_
-
-/*--------------------Define --------------------------------------------*/
-#define CmdFileType_Delay	0
-#define CmdFileType_RealOnOff	1
-#define LPSOfld_KeepCurrentVal	(0xFF)
-#define LPSOfld_WaitFCSToms	(10)
-#define LPSOfld_HIOEOnClrIntCmdNum	(2) //unit 8 bytes
-#define LPSOfld_BCNTO	(10000)//us
-#define LPSOfld_TSFT_DIFF_THRES	(1000)//us
-#define KeyCAMHIOEEntrySize (16)
-
-/*------------------------------Function declaration--------------------------*/
-extern void LPSOfld_HIOECmdFileInit_8720E(void);
-extern void LPSOfld_RxbcnModeCmdFileValInit_8720E(void);
-extern void LPSOfld_ExitRxbcnModeCmdFileValInit_8720E(void);
-extern void LPSOfld_SwtHIOECmdFile_8720E(BOOLEAN OnHIOECmdFileType, BOOLEAN OffHIOECmdFileType);
-extern void LPSOfld_IMRSetting_8720E(BOOLEAN HWCtrlTRXOnOff);
-extern void LPSOfld_SetBcnErlyandTimeout_8720E(u8 bcnearlyitvlms, u8 bcnearlyitvl128us, u8 bcnearlyitvl32us, u32 bcntimeout);
-extern void LPSOfld_FuncInit_8720E(void);
-extern void LPSOfld_PGResume_8720E(void);
-extern void LPSOfld_HWCtrlTRXOnOff_8720E(BOOLEAN HWCtrlTRXOnOff);
-extern void LPSOfld_PSRxBcnProcess_8720E(void);
-
-#endif
diff --git a/os/board/rtl8720e/src/component/wifi/wifi_fw/amebalite/include/wififw_packet_ram.h b/os/board/rtl8720e/src/component/wifi/wifi_fw/amebalite/include/wififw_packet_ram.h
deleted file mode 100644
index 59837c720..000000000
--- a/os/board/rtl8720e/src/component/wifi/wifi_fw/amebalite/include/wififw_packet_ram.h
+++ /dev/null
@@ -1,289 +0,0 @@
-#ifndef __WIFIFW_PACKET_RAM_H__
-#define __WIFIFW_PACKET_RAM_H__
-
-/*--------------------------Define -------------------------------------------*/
-// retry limit
-#define RTY_LMT_NULLDATA			8
-#define RTY_LMT_QNULL				8
-#define RTY_LMT_BTQNULL			8
-#define RTY_LMT_ARP					24
-#define RTY_LMT_PSPOLL				24
-#define RTY_LMT_NDP					24
-#define RTY_LMT_CTS2SELF			0	//Alan ,use 0 is correct, suggest by Ausin-Lo
-
-//issue rsvdpage marco
-#define _ISSUE_BTQNULL				1
-#define _ISSUE_DBGPKT_				2
-#define _ISSUE_FCSNULL_			3
-#define _ISSUE_LTEQNULL_      		4
-#define _ISSUE_NDPA_           		5
-#define _ISSUE_PROBERSP_			6
-#define _ISSUE_PROBEREQ_			7
-#define _ISSUE_GTKRSP_            	8
-#define _ISSUE_PSPOLL_            	9
-#define _ISSUE_NULL_             	10
-#define _ISSUE_QNULL_           	11
-#define _ISSUE_CTS2SELF_        	12
-#define _ISSUE_REALWOW_KA_     	13
-#define _ISSUE_RS_          			14
-#define _ISSUE_BUBBLE_        		15
-#define _ISSUE_ARP_         			16
-#define _ISSUE_NA_            		17
-
-//CPU_MGT_INFORMATION
-#define CPUMGT_POLL					BIT5
-#define P0BCN_POLL					BIT4
-#define P1BCN_POLL					BIT6
-#define NANBCN_POLL					BIT7//used for port2
-/*--------------------------Define MACRO--------------------------------------*/
-
-#define RATE_CCK_1M					0x00
-#define RATE_CCK_2M					0x01
-#define RATE_CCK_5M					0x02
-#define RATE_CCK_11M				0x03
-#define RATE_OFDM_6M        		0x04
-#define RATE_OFDM_9M        		0x05
-#define RATE_OFDM_12M       		0x06
-#define RATE_OFDM_18M       		0x07
-#define RATE_OFDM_24M       		0x08
-#define RATE_OFDM_36M       		0x09
-#define RATE_OFDM_48M       		0x0A
-#define RATE_OFDM_54M       		0x0B
-#define RATE_HT_MCS0        		0x0C
-#define RATE_HT_MCS1        		0x0D
-#define RATE_HT_MCS2        		0x0E
-#define RATE_HT_MCS3        		0x0F
-#define RATE_HT_MCS4        		0x10
-#define RATE_HT_MCS5        		0x11
-#define RATE_HT_MCS6        		0x12
-#define RATE_HT_MCS7        		0x13
-#define RATE_HT_MCS8        		0x14
-#define RATE_HT_MCS9        		0x15
-#define RATE_HT_MCS10       		0x16
-#define RATE_HT_MCS11       		0x17
-#define RATE_HT_MCS12       		0x18
-#define RATE_HT_MCS13				0x19
-#define RATE_HT_MCS14       		0x1A
-#define RATE_HT_MCS15       		0x1B
-#define RATE_HT_MCS16       		0x1C
-#define RATE_HT_MCS17				0x1D
-#define RATE_HT_MCS18       		0x1E
-#define RATE_HT_MCS19       		0x1F
-#define RATE_HT_MCS20       		0x20
-#define RATE_HT_MCS21       		0x21
-#define RATE_HT_MCS22       		0x22
-#define RATE_HT_MCS23       		0x23
-#define RATE_HT_MCS24       		0x24
-#define RATE_HT_MCS25       		0x25
-#define RATE_HT_MCS26       		0x26
-#define RATE_HT_MCS27       		0x27
-#define RATE_HT_MCS28       		0x28
-#define RATE_HT_MCS29       		0x29
-#define RATE_HT_MCS30       		0x2A
-#define RATE_HT_MCS31       		0x2B
-#define RATE_VHT1SS_MCS0    		0x2C
-#define RATE_VHT1SS_MCS1    		0x2D
-#define RATE_VHT1SS_MCS2    		0x2E
-#define RATE_VHT1SS_MCS3    		0x2F
-#define RATE_VHT1SS_MCS4    		0x30
-#define RATE_VHT1SS_MCS5    		0x31
-#define RATE_VHT1SS_MCS6    		0x32
-#define RATE_VHT1SS_MCS7    		0x33
-#define RATE_VHT1SS_MCS8    		0x34
-#define RATE_VHT1SS_MCS9    		0x35
-#define RATE_VHT2SS_MCS0    		0x36
-#define RATE_VHT2SS_MCS1    		0x37
-#define RATE_VHT2SS_MCS2    		0x38
-#define RATE_VHT2SS_MCS3    		0x39
-#define RATE_VHT2SS_MCS4    		0x3A
-#define RATE_VHT2SS_MCS5    		0x3B
-#define RATE_VHT2SS_MCS6    		0x3C
-#define RATE_VHT2SS_MCS7    		0x3D
-#define RATE_VHT2SS_MCS8    		0x3E
-#define RATE_VHT2SS_MCS9    		0x3F
-#define RATE_VHT3SS_MCS0    		0x40
-#define RATE_VHT3SS_MCS1    		0x41
-#define RATE_VHT3SS_MCS2    		0x42
-#define RATE_VHT3SS_MCS3    		0x43
-#define RATE_VHT3SS_MCS4    		0x44
-#define RATE_VHT3SS_MCS5    		0x45
-#define RATE_VHT3SS_MCS6    		0x46
-#define RATE_VHT3SS_MCS7    		0x47
-#define RATE_VHT3SS_MCS8    		0x48
-#define RATE_VHT3SS_MCS9    		0x49
-#define RATE_VHT4SS_MCS0    		0x4A
-#define RATE_VHT4SS_MCS1    		0x4B
-#define RATE_VHT4SS_MCS2    		0x4C
-#define RATE_VHT4SS_MCS3    		0x4D
-#define RATE_VHT4SS_MCS4    		0x4E
-#define RATE_VHT4SS_MCS5    		0x4F
-#define RATE_VHT4SS_MCS6    		0x50
-#define RATE_VHT4SS_MCS7    		0x51
-#define RATE_VHT4SS_MCS8    		0x52
-#define RATE_VHT4SS_MCS9    		0x53
-//add HE rate here
-#define RATE_HE1SS_MCS0				0x54
-#define RATE_HE1SS_MCS1				0x55
-#define RATE_HE1SS_MCS2				0x56
-#define RATE_HE1SS_MCS3				0x57
-#define RATE_HE1SS_MCS4				0x58
-#define RATE_HE1SS_MCS5				0x59
-#define RATE_HE1SS_MCS6				0x5A
-#define RATE_HE1SS_MCS7				0x5B
-#define RATE_HE1SS_MCS8				0x5C
-#define RATE_HE1SS_MCS9				0x5D
-#define RATE_HE1SS_MCS10			0x5E
-#define RATE_HE1SS_MCS11			0x5F
-#define RATE_HE2SS_MCS0				0x60
-#define RATE_HE2SS_MCS1				0x61
-#define RATE_HE2SS_MCS2				0x62
-#define RATE_HE2SS_MCS3				0x63
-#define RATE_HE2SS_MCS4				0x64
-#define RATE_HE2SS_MCS5				0x65
-#define RATE_HE2SS_MCS6				0x66
-#define RATE_HE2SS_MCS7				0x67
-#define RATE_HE2SS_MCS8				0x68
-#define RATE_HE2SS_MCS9				0x69
-#define RATE_HE2SS_MCS10			0x6A
-#define RATE_HE2SS_MCS11			0x6B
-
-#if 0
-#define RATE_HE_NSS1_MCS0			0x60
-#define RATE_HE_NSS1_MCS1			0x61
-#define RATE_HE_NSS1_MCS2			0x62
-#define RATE_HE_NSS1_MCS3			0x63
-#define RATE_HE_NSS1_MCS4			0x64
-#define RATE_HE_NSS1_MCS5			0x65
-#define RATE_HE_NSS1_MCS6			0x66
-#define RATE_HE_NSS1_MCS7			0x67
-#define RATE_HE_NSS1_MCS8			0x68
-#define RATE_HE_NSS1_MCS9			0x69
-#define RATE_HE_NSS1_MCS10		0x6A
-#define RATE_HE_NSS1_MCS11		0x6B
-#endif
-/*------------------------------Define Struct---------------------------------*/
-typedef struct  _RsvdPageLoc_ {
-	u8      loc_probersp;
-	u8      loc_pspoll;
-	u8      loc_nulldata;
-	u8      loc_QosNull;
-	u8      loc_BT_QoSNull;
-	u8      loc_CTS2Self;
-	u8      loc_LTECOEX_QoSNull;
-} RsvdPageLoc, *PRsvdPageLoc;
-
-/*----------------------------Define-------------------------------------*/
-#define TX_PKT_WAIT_Q_SIZE			16
-#define TX_PKT_BUSY_Q_SIZE			1
-#define IS_CPUMGQ_TXING()				(!CheckCPUMGQEmpty())
-#define CPUMGQ_TX_TIMEOUT_US			5000
-
-enum TSF_HIGH_LOW_VALUE {
-	TSF_LOW         = 0,
-	TSF_HIGH        = 1
-};
-
-typedef enum _TX_RESULT_ {
-	TXRESULT_TX_DONE 				= 0,
-	TXRESULT_TX_TIMEOUT 		= 1,
-	TXRESULT_TX_PREEMPTED 		= 2,
-	TXRESULT_CANCELED 			= 3,
-	TXRESULT_TX_ACKED 			= 4,
-	TXRESULT_TX_DROPPED 		= 5,
-	TXRESULT_MAX
-} TX_RESULT, *PTX_RESULT;
-//TX PS Poll
-typedef struct {
-	u16 		RsvPageLoc;
-	u8			RtyLmt;
-} TX_PSPOLL_PKT_CONTEXT, *PTX_PSPOLL_PKT_CONTEXT;
-
-//TX null data
-typedef struct {
-	u16 		u2RsvPageLoc;
-	BOOLEAN 	bPowerBit;
-	u8			RtyLmt;
-} TX_NULL_PKT_CONTEXT, *PTX_NULL_PKT_CONTEXT;
-//CTS2Self
-typedef struct {
-	u8 			location;
-	u16 		NAV;
-} TX_CTS_TO_SELF_PKT_CONTEXT, *PTX_CTS_TO_SELF_PKT_CONTEXT;
-//Arp
-typedef struct {
-	u8  		TargetIP[4];
-	u8  		TargetMAC[6];
-	u8  		retry_bit;
-	u8  		arpsel;
-} TX_ARP, *PTX_ARP;
-//NA
-typedef struct {
-	u8    		TargetIP[4];
-	u8    		TargetMAC[6];
-	u8    		OurIP[4];
-	u8    		OurMAC[6];
-	u8    		retry_bit;
-	u8    		ndpsel;
-} TX_NA, *PTX_NA;
-
-typedef union _TX_PKT_CONTEXT_ {
-	TX_NULL_PKT_CONTEXT			Null;
-	TX_PSPOLL_PKT_CONTEXT		PSPOLL;
-	TX_CTS_TO_SELF_PKT_CONTEXT	CTS2Self;
-	TX_ARP	ARP;
-	TX_NA		NA;
-} TX_PKT_CONTEXT, *PTX_PKT_CONTEXT;
-
-typedef BOOLEAN(*PRE_TX_CALLBACK)(PTX_PKT_CONTEXT, u32);
-typedef void (*POST_TX_CALLBACK)(TX_RESULT, u32);
-
-typedef struct _TX_PKT_ENTRY_ {
-	PRE_TX_CALLBACK		PreTxCallback;
-	POST_TX_CALLBACK		PostTxCallback;
-	u32 		IssueTxTime;
-	u32 		HWTxTime;
-	TX_PKT_CONTEXT		TxPktCxt;
-	u8 			id;
-	u8 			canceled;
-	u16 		timeout;
-	u8 			has_txfb;
-} TX_PKT_ENTRY, *PTX_PKT_ENTRY;
-
-/*--------------------Function declaration---------------------------------*/
-extern void InitFreeRunTSF_8720E(void);
-extern u64 GetFreeRunCnt_8720E(void);
-extern u32 GetFreeRunCntU32_8720E(BOOLEAN u1HighLowValue);
-extern u8 TxPktPollMgntQ_8720E(void);
-extern BOOLEAN CPUMGQCancelTx_8720E(void);
-extern void SWQTXCheckBusyQState_8720E(void);
-extern BOOLEAN IsSWQTXAllQEmpty_8720E(void);
-extern BOOLEAN PS_PreTxNull_8720E(PTX_PKT_CONTEXT  pcontext, u32 queue_time);
-extern void PS_PostTxNull1_8720E(IN  TX_RESULT result, IN  u32 tx_time);
-extern void PS_PostTxNull0_8720E(IN  TX_RESULT result, IN  u32 tx_time);
-extern void PostTxNull_8720E(IN  TX_RESULT result, IN  u32 tx_time);
-extern u8 CheckTxNullResult_8720E(u8 PORT_ID, u8 Null_Type);
-extern void SWQTXTxFeedBack_8720E(u8 acked/*, void* context*/);
-extern u8 SWQTXEnqueueWaitQ_8720E(TX_PKT_ENTRY txpkt_entry);
-#if 0
-extern BOOLEAN PreTxPSPoll_8720E(PTX_PKT_CONTEXT  pcontext, u32 queue_time);
-extern void PostTxPSPoll_8720E(IN  TX_RESULT result, IN  u32 tx_time);
-extern BOOLEAN PreTxNA_8720E(PTX_PKT_CONTEXT  pcontext, u32 queue_time);
-extern void PostTxNA_8720E(IN	TX_RESULT result, IN  u32 tx_time);
-extern BOOLEAN PreTxARP_8720E(PTX_PKT_CONTEXT	pcontext, u32 queue_time);
-extern void PostTxARP_8720E(IN  TX_RESULT result, IN  u32 tx_time);
-#endif
-extern void ChangeTransmiteRate_8720E(u16 offset) ;
-extern void PowerBitSetting_8720E(u8 bPowerBit, u16 offset);
-extern void IssuePSPoll_8720E(void);
-extern void ChkandChangePS_8720E(u8 bPowerBit);
-extern void IssueQNull_8720E(u8 bPowerBit);
-extern void CTS2SelfSetting_8720E(u16 offset, u16 NAV);
-extern void IssueCTS2Self_8720E(u8 location, u16 NAV);
-extern u16 IssueRsvdPagePacketSetting_8720E(u8 PageNum,  BOOLEAN bHwSEQEn,  u8 RtyLmt,  u8 TxInd);
-extern u8 ReadRxBuff_8720E(u16 headaddr, u8  offset);
-extern BOOLEAN WaitCPUMGQEmpty_8720E(void);
-extern u8 PollingReg_8720E(u16 RegOffset, u8 PollingBit, u8 PollingResult, u16 PollingLimit, u16 *PollingCount);
-extern BOOLEAN IssueNullData_8720E(u8 bPowerBit, u8 RtyLmt);
-extern BOOLEAN CheckCPUMGQEmpty_8720E(void);
-
-#endif  /* __WIFIFW_PACKET_RAM_H__ */
diff --git a/os/board/rtl8720e/src/component/wifi/wifi_fw/amebalite/include/wififw_phydm_offload_ram.h b/os/board/rtl8720e/src/component/wifi/wifi_fw/amebalite/include/wififw_phydm_offload_ram.h
deleted file mode 100644
index 62178f341..000000000
--- a/os/board/rtl8720e/src/component/wifi/wifi_fw/amebalite/include/wififw_phydm_offload_ram.h
+++ /dev/null
@@ -1,49 +0,0 @@
-#ifndef __WIFIFW_PHYDM_OFLOAD_RAM_H__
-#define __WIFIFW_PHYDM_OFLOAD_RAM_H__
-
-#define	DIG_MAX_LPS			0x3e
-#define	DIG_MIN_LPS			0x20
-
-#define	RSSI_TABLE_SIZE			4
-#define	RSSI_DIFF_THRESHOLD			30
-
-#define RFREG_MASK		0xfffff
-#define INVALID_RF_DATA 0xffffffff
-
-/*--------------------Define Enum---------------------------------------*/
-enum rtw_dv_sel {
-	DAV,
-	DDV,
-};
-
-enum rf_path {
-	RF_PATH_A = 0,
-	RF_PATH_B = 1,
-	RF_PATH_C = 2,
-	RF_PATH_D = 3,
-	RF_PATH_AB,
-	RF_PATH_AC,
-	RF_PATH_AD,
-	RF_PATH_BC,
-	RF_PATH_BD,
-	RF_PATH_CD,
-	RF_PATH_ABC,
-	RF_PATH_ABD,
-	RF_PATH_ACD,
-	RF_PATH_BCD,
-	RF_PATH_ABCD,
-};
-
-typedef struct _RSSI_PARM_ {
-	u8		abs_rssi_temp[RSSI_TABLE_SIZE];
-	u8		abs_rssi_average;
-	u16		abs_rssi_sum;
-} RSSI_PARM;
-
-extern void DIGByRSSILps_8720E(u16 phystsofst);
-extern u32 halbb_fw_read_rf_reg_8720e(enum rf_path path, u32 reg_addr, u32 bit_mask);
-extern bool halbb_fw_write_rf_reg_8720e(enum rf_path path, u32 reg_addr, u32 bit_mask, u32 data);
-extern u32 halbb_fw_get_bb_reg_8720e(u32 addr, u32 mask);
-extern void halbb_fw_set_bb_reg_8720e(u32 addr, u32 mask, u32 val);
-
-#endif
diff --git a/os/board/rtl8720e/src/component/wifi/wifi_fw/amebalite/include/wififw_phydm_ram.h b/os/board/rtl8720e/src/component/wifi/wifi_fw/amebalite/include/wififw_phydm_ram.h
deleted file mode 100644
index d6e8dc623..000000000
--- a/os/board/rtl8720e/src/component/wifi/wifi_fw/amebalite/include/wififw_phydm_ram.h
+++ /dev/null
@@ -1,423 +0,0 @@
-#ifndef __WIFIFW_PHYDM_RAM_H__
-#define __WIFIFW_PHYDM_RAM_H__
-#if CONFIG_RATE_ADAPTIVE
-
-//Ctrl Info access
-//#define ODM_ReadCtrlInfo(macid, offset)                      ReadCtrlInfoByte(macid, offset)
-//#define ODM_WriteCtrlInfo(macid, offset, val)                WriteCtrlInfoByte(macid, offset, val)
-
-//4  TxCtrlInfo
-// offset0
-#define TXCTRLINFO_DATA_RATE            (BIT6|BIT5|BIT4|BIT3|BIT2|BIT1|BIT0)
-#define TXCTRLINFO_SGI                  (BIT7)
-// offset1
-#define TXCTRLINFO_PWR_STS              (BIT2|BIT1|BIT0)
-#define TXCTRLINFO_DATA_BW              (BIT4|BIT3)
-#define TXCTRLINFO_TRY_RATE             (BIT6)
-
-#define TXCTRLINFO_DATA_BW_BITS TXCTRLINFO_DATA_BW
-#define TXCTRLINFO_DATA_BW_OFFSET         10
-
-//RA_MASK access
-//#define ODM_ReadRAMASKByte(macid, offset)                    ReadRAMASKByte(macid, offset)
-//#define ODM_ReadRAMASKDWORD(macid, offset)                   ReadRAMASKDWORD(macid, offset)
-//#define ODM_WriteRAMASKByte(macid, offset, val)              WriteRAMASKByte(macid, offset, val)
-//#define ODM_WriteRAMASKDWORD(macid, offset, val)             WriteRAMASKDWORD(macid, offset, val)
-
-#define BWSIZE                          3 // BW20M ~ BW80M
-#define MULTI_RATE_NUM          2
-#define RETRY_RATIO_VAR_SIZE    10
-#define LIMIT_RATE_SIZE         2
-
-
-#define RATESIZE                        108
-#define NUM_HE_RATE                     24
-#define NUM_VHT_RATE                    40  // 8198F is 4SS
-#define NUM_HT_RATE                     32
-#define NUM_MULTI_TRY                   2   // 4
-#define BW_SWITCH_DISABLE_2SS_ALL       0
-
-//---New Band Switch Mode
-#define COMMON_RATE_DOWN_OFFSET 3
-#define LIMIT_RATE_SIZE         2
-#define GILTF_TRAINING 1
-
-//#define PHYRATE_LGI2SGI(rate) (rate + (rate >> 4) + (rate >> 5) + (rate >> 7)) //1+0.0625+0.03125+0.0078125 ~= 0.102
-//#define PHYDM_IS_LEGACY_RATE(rate) ((rate <= RATE_OFDM_54M) ? true : false)
-
-#define RATE_UNUSED                     0xff
-#define BW_NO_UPDATE                    0xff
-#define GI_NO_UPDATE                    0xff
-#define RAMASK_SIZE                     2
-
-#define TRYING_DISABLE   0
-#define TRYING_ENABLE    1
-
-#define TRY_SUCCESS      1
-#define TRY_FAIL         0
-
-//#define DIFF(A,B) ((A>=B) ? (A-B):(B-A))
-#define SHIFT_ROUND(A, SHIFT)  ((A + (1 << (SHIFT-1)))>>SHIFT)
-#define MA_ADD(NEW, OLD, SHIFT) (NEW + OLD - (OLD>>SHIFT))
-#define MINUS(A,B) ((A > B) ? (A-B) : 0)
-#define PHYRATE_LGI2SGI(rate) (rate + (rate >> 4) + (rate >> 5) + (rate >> 7)) //1+0.0625+0.03125+0.0078125 ~= 0.102
-// For HE GI_LTF, add 04/32
-#define PHYRATE_GI3P2_TO_GI0P8(rate) (rate + (rate>>3) + (rate>>5) + (rate>>6)) // + (rate>>8)) ~= 1.17
-#define PHYRATE_GI3P2_TO_GI1P6(rate) (rate + (rate>>4) + (rate>>5) + (rate>>6)) // + (rate>>9)) ~= 1.11
-//
-#define PHYDM_IS_LEGACY_RATE(rate) ((rate <= RATE_OFDM_54M) ? true : false)
-#define PHYDM_IS_CCK_RATE(rate) ((rate <= RATE_CCK_11M) ? true : false)
-#define DIFF(a,b)                   ((a>=b)? a-b: b-a)
-
-#define RATE_DEFAULT    0
-#define RATE_UP         1
-#define RATE_DOWN       2
-
-// packet based RA
-#define RATIO_CNT_TH            3
-#define RATIO_SHIFT_SGI         1
-#define TRY_SUCCESS_RATIO_SHIFT 5
-#define RATE_UP_P_OFST          3
-#define RATE_UP_CNT             3
-#define RATE_UP_FAIL_CNT_LMT    200  // 50
-#define RATE_DOWN_CNT           2
-#define RATE_DOWN_RATIO_TH      30
-#define FORCE_RATE_DOWN_TH      80 //
-#define RSSI_TOLERANCE          2
-#define MULTI_RATE_NUM          2 /*MULTI_TRY_NUM after first try rate, will try 1+2 times */
-#define SMOOTHING_FACTOR        3
-#define RETRY_RATIO_VAR_SIZE    10
-#define DIFF2VAR_SHIFT          10
-#define RETRY_RATIO_VAR_MAX     30
-
-//Eric add for RA fine tune
-#define RATE_UP_FAIL_CNT_LMT_1024QAM 5
-#define RATE_UP_FAIL_CNT_LMT_256QAM 5
-#define RATE_UP_FAIL_CNT_LMT_64QAM 5
-#define RATE_UP_FAIL_CNT_LMT_16QAM 5
-#define RATE_UP_FAIL_CNT_LMT_QPSK 5
-#define RATE_UP_FAIL_CNT_LMT_BPSK 5
-
-#define FAST_DECISION_TRUE  1
-#define FAST_DECISION_FALSE 0
-
-//offset 3
-#define TXRPTFIELD_DATA_RATE            (BIT6|BIT5|BIT4|BIT3|BIT2|BIT1|BIT0)
-#define TXRPTFIELD_SGI                  BIT7
-
-#define DROP_TH             3
-
-#define CLEAN_ENV_VAR_TH    3 // 2
-#define GOOD_PER_TH         10
-#define DEC_OFFSET_MAX_N    40
-
-//#define NUM_MULTI_TRY                   3
-
-#define RAMSK_HT_VHT_OFFSET     32
-#define RAMSK_HT_HE_OFFSET      (RAMSK_HT_VHT_OFFSET+40)
-
-/*-------------------- Define logic and bitwise operation  ---------------*/
-typedef struct phydm_rate_adaptive {
-	u8 RATE_UP_RTY_RATIO[RATESIZE];
-	u8 RATE_DOWN_RTY_RATIO[RATESIZE];
-	//u8 first_rate_down; /*ARFB first rate down number ex: Reg0x430=00000001, first_try_rate_down = 4*/
-	//u8 first_try_rate_down; /*ARFB first rate down number ex: Reg0x430=01020304, first_try_rate_down = 2*/
-	u16 retry_ratio_per_rate_ma[RATESIZE];
-	u16 variance_per_rate[RATESIZE];
-	u8 DIFF2VAR_TABLE[RETRY_RATIO_VAR_SIZE];
-	//u8 rpt_per_macid[3];
-} PHYDM_RA_T, *PPHYDM_RA_T;
-
-
-
-typedef struct _CCTRL_INFO_ {
-	//offset:0
-	u16 DATARATE: 9;
-	u16 DIS_SR: 1;
-	u16 DATA_BW: 2;
-	u16 GI_LTF: 3;
-	u16 DARF_TC_INDEX: 1;
-	u16 ARFR_CTRL: 4;
-	u16 rsvd0: 1;
-	u16 PROTECTION_EN: 1;
-	u16 RTS_EN: 1;
-	u16 CTS2SELF: 1;
-	u16 HW_RTS_EN: 1;
-	u16 rsvd1: 6;
-	u16 RTY_LOW_RATE_EN: 1;
-	//offset:4
-	u16 DATA_RTY_LOWEST_RATE: 9;
-	u16 AMPDU_TIME_EN: 1;
-	u16 AMPDU_MAX_TIME: 4;
-	u16 rsvd2: 2;
-	u16 rsvd3: 2;
-	u16 LSIG_TXOP_EN: 1;
-	u16 FORCE_TXOP: 1;
-	u16 TRYRATE: 1;
-	u16 FARA_BW_EN: 1;
-	u16 PKT_TX_ONE_SEL: 1;
-	u16 RTS_RTY_LOWEST_RATE: 9;
-	//offset:8
-	u32 RTY_CNT_LMT_EN: 1;
-	u32 RTY_CNT_LMT: 6;
-	u32 MAX_AGG_NUM_EN: 1;
-	u32 MAX_AGG_NUM: 5;
-	u32 AMPDU_LEN_EN: 1;
-	u32 AMPDU_MAX_LEN: 11;
-	u32 rsvd4: 7;
-	//offset 12
-	u32 TXPWR_TOLERANCE: 6;
-	u32 DCM: 1;
-	u32 EXTEND_RANGE: 1;
-	u32 DATA_BW_ER: 1;
-	u32 DATA_LDPC: 1;
-	u32 DATA_STBC: 1;
-	u32 UL_DL: 1;
-	u32 DOPPLER_CTL: 2;
-	u32 NOMI_PAD20: 2;
-	u32 A_CTRL: 4;
-	u32 BSR_QUE_SIZE: 1;
-	u32 SMOOTH_CTRL: 1;
-	u32 rsvd5: 1;
-	u32 CTRL_WRAPPER_EN: 1;
-	u32 RXID_MATCH_EN: 1;
-	u32 BSR_OM_UPD_EN: 1;
-	u32 rsvd6: 6;
-	//offset 16
-	u32 rsvd7: 10;
-	u32 PAID: 9;
-	u32 NC: 3;
-	u32 NR: 3;
-	u32 NG: 2;
-	u32 CB: 2;
-	u32 COEFFOC_SIZE: 2;
-	u32 CSI_TXBF_EN: 1;
-	//offset 20
-	u32 CSI_LDPC_EN: 1;
-	u32 CSI_STBC_EN: 1;
-	u32 CSI_PARA_EN: 1;
-	u32 CSI_FIX_RATE: 9;
-	u32 CSI_BW: 2;
-	u32 CTRLPKT_CHK_EN: 1;
-	u32 ALL_ACK_SUPPORT: 1;
-	u32 RESP_REF_RATE: 9;
-	u32 MFB: 7;
-
-} CCTRL_INFO, *PCCTRL_INFO;
-
-
-typedef struct _bb_sta_info {
-	//downlink su
-	u8 dl_su_bw: 2;
-	u8 dl_su_gi_ltf: 3;
-	u8 dl_su_coding: 1;
-	u8 dl_su_txbf: 1;
-	u8 dl_su_stbc: 1;
-
-	u8 sgi_pending_cnt: 3; // For modified SGI try rate flow
-	u8 rsvd1: 5; //for alignment
-
-	u16 dl_su_dcm: 1;
-	u16 rsvd2: 6;
-	u16 dl_su_rate: 9;
-
-	/*RA report*/
-	u16 TOTAL;   /* TOTAL = 1*R[0]+2*R[1]+...+(N+1)*R[N]:rate down*/
-	//u16 DROP;
-	u16 OK;      /* OK = R[0]+R[1]+R[2]+R[3]: Initial rate, no rate down*/
-	u16 OK_ALL;  /* OK_ALL = R[0]+R[1]+...+R[N]:rate down*/
-	u8 TOTAL_PKT; /*Total Packet*/
-	u8  TXCLS_PKT; /*Tx Collision Packet*/
-
-	/*RA report for Beacon Cnt*/
-	u16 BCN_TOTAL;    /* TOTAL = 1*R[0]+2*R[1]+...+(N+1)*R[N]:rate down*/
-	u16 BCN_OK;       /* OK = R[0]+R[1]+R[2]+R[3]: Initial rate, no rate down*/
-	u8  BCN_CNT;
-	u8 	rsvd3;
-	/*RA report for try rate*/
-
-	u16 TRY_TOTAL;
-	u16 TRY_OK;
-	u16 TRY_OK_ALL;
-	u8 TRY_TOTAL_PKT; /*Total Packet*/
-
-	u8 disable_bw_switch;
-
-	/*for H2C_AP_Req_Txrpt*/
-	u8 avg_agg;
-	u16 acq_rpt[2][4]; /*0: ok, 1: retry =1*/ /* BE BK VI VO */
-	u16 TOTAL_CNT_C2H;
-	// ra report info -- End
-
-	u32 ra_mask;
-	u32 backup_mask;
-	// su-ra info
-	u8 highest_rate;
-	u8 lowest_rate;
-	u8 rate;         /*curretn rate*/
-	u8 pre_mode;
-	u8 pre_rate;     /*pre rate*/
-	u8 pre_gi_ltf;   // v
-	u8 multi_rate[MULTI_RATE_NUM]; /*multi_rate[0]: 2nd rate, multi_rate[1]: 3rd rate*/
-	u8 max_start_rate;
-
-	u8 Initial_BW: 2; /*max support bw*/
-	u8 BW_setting: 2; /*current bw */
-	u8 pre_bw: 2;    /*pre bw */
-	u8 rsvd4: 2;
-
-	//u8 RateID: 5;
-	u8 mode_sel: 5;
-	/*en_cck, en_legofdm, en_ht, en_vht, en_he*/
-	u8 DISPT: 1;
-	u8 DISRA: 1;
-	u8 rsvd5: 1;
-
-	//u8 multi_rate_state_idx: 2;
-	u8 updown_bitmap: 4;
-	u8 rsvd6: 4;
-
-	u8 rate_down_cnt;
-	u8 rate_up_cnt;
-	u8 rate_up_pending;
-
-	u8 try_fail_cnt: 4; /*Just for debug*/
-	u8 rate_up_down: 4;
-
-	u8 VHT_EN: 2;
-	u8 SGI: 1;
-	u8 multi_rate_state: 2;
-	u8 try_fail_count: 2;
-	u8 trying_enable: 1;
-
-	u8 rsvd7: 1; /*for power training*/
-	u8 gi_ltf_cap: 3; /* bit(0)=4x0.8, bit(1)=1x0.8*/
-	u8 max_ss_support: 3;
-	u8 bForcePktRA: 1;
-
-	u16 ra_ratio;       /*MA vlaue of ra_ratio*/
-	u16 ra_down_ratio;  /*MA vlaue of ra_down_ratio*/
-
-	u8 ldpc_cap: 1;
-	u8 fix_giltf_en: 1;
-	u8 fix_giltf: 3;
-	u8 rsvd8: 3;
-
-	u8 try_ness;
-	u8 try_ness_max;
-
-	u8 RSSI; /* It is also means RSSI_A when we send per path RSSI to FW */
-	u8 bcn_rssi_a;
-
-	// ============= RA ctrl info ============== //
-	u8 RAINFO_STBC_STATE: 1;
-	u8 ra_info_rsvd6: 2; // instead of SHORT_CUT
-	u8 TxBF_STATE: 1;
-	u8 ra_info_rsvd7: 4;
-	// ======================================== //
-
-#ifdef HALBB_CSI_RATE
-	// ============= CSI rate ctrl info ============== //
-	u8 ra_csi_rate_en: 1;
-	u8 fixed_csi_rate_en: 1;
-	u8 cr_tbl_sel: 1;
-	u8 rsvd_csi_rate: 5;
-	u8 band_num;
-	u16 fixed_csi_rate;
-	// ======================================== //
-#endif
-	// ============= FW fixed rate (H2C) ============== /
-	u8 bfixed_rate: 1;
-	u8 fixed_gi_ltf: 3;
-	u8 fixed_bw: 2;
-	u8 fixed_mode: 2;
-
-	u8 fixed_rate: 7;
-	u8 fixed_rsvd0: 1;
-
-	// ============= Driver shift RU/RD threshold (H2C) ============== //
-	u8 drv_shift_value: 7;
-	u8 drv_shift_en: 1;
-	// =============================================================== //
-
-	// ============= Driver adjust RA mask (H2C) ============== //
-	u8 mask_or_reveal: 1;
-	u8 mask_rate: 7;
-
-	u8 mask_rate_md: 2;
-	u8 is_manual_adjust_ra_mask: 1;
-	u8 backup_num: 1;
-	u8 ra_mask_rsvd0: 4;
-	// ======================================================== //
-
-
-	u8 up_fail_limit_rate[LIMIT_RATE_SIZE]; /*for 1SS & 2ss rate*/
-	u16 up_fail_limit_cnt[LIMIT_RATE_SIZE];
-#if 0 // CONFIG_PKT_BASED_RA
-	u8 ra_decision_occur_num;
-	u8 trig_ra_pkt_num; /*make ra decision when collect enough(trig_ra_pkt_num) pachets*/
-	u8 trigger_mode; /*0: default pkt based RA, 1: TBTT based RA*/
-#endif
-	// su-ra info -- END
-
-	//
-	u8 ser_try_cnt;
-
-	u8 wd_not_release;
-	//
-	u16 rate_up_fail_cnt_lmt_val;
-	u8    multi_try_times: 4;
-	u8    consective_rate_up_fail_cnt: 4;
-	// Multi Try RA
-	u8    rate_up_waiting;
-	//u8    ra_up_fail_rssi;
-	u8    ra_candidate_rate1;
-	u8    ra_candidate_rate2;
-	u8    no_rate_up_cnt;
-
-	u16 decision_offset_n;
-	u16 decision_offset_p;
-#ifdef CONFIG_RA_DEBUG
-	u8 d_o_timer_max;
-	u8 d_o_timer_cnt;
-	u8 d_o_timer_state;
-	BOOLEAN d_o_timer_en;
-#endif
-} BB_STA_INFO, *PBB_STA_INFO;
-
-
-typedef  struct _RA_ADP_FUNC_ { /*the 4-th layer*/
-
-	//PHYDM_RA_T             RA;
-	//PHY_FWDBG_PARM    Phy_fwdbgParm;
-	//TXRPT_INFO                 TxRptInfo;
-	TxRpt_Cfg              TxRptCfg;
-	CCTRL_INFO			   CtrlInfo;
-	u8		RaMask[MACID_NUM][4];
-
-} RA_ADP_FUNC, *PRA_ADP_FUNC;
-
-struct _PPHYDM {
-
-	//PHYDM_FUNC            Phydm;
-	BB_STA_INFO sta_info_list[MACID_NUM];
-	//PHYDM_RA_T phydm_ra;
-#if CONFIG_RATE_ADAPTIVE
-	RA_ADP_FUNC           Ra_adp;
-#endif
-
-	u8 en_th_adapt;
-	u8 max_ser_try_cnt;
-	//u32 RTY_C2H;
-	PHYDM_RA_T phydm_ra;
-	//BB_COM		com;
-#ifdef CONFIG_RA_DEBUG
-	u32 halbb_fwdbg_comp;
-	/* Debug com for all bb features */
-	u8 halbb_fwdbg_trace;
-#endif
-};
-
-#endif
-#endif //#ifndef __ODM_RAM_H__
-
diff --git a/os/board/rtl8720e/src/component/wifi/wifi_fw/amebalite/include/wififw_powerctrl_ram.h b/os/board/rtl8720e/src/component/wifi/wifi_fw/amebalite/include/wififw_powerctrl_ram.h
deleted file mode 100644
index 4c7c490bb..000000000
--- a/os/board/rtl8720e/src/component/wifi/wifi_fw/amebalite/include/wififw_powerctrl_ram.h
+++ /dev/null
@@ -1,167 +0,0 @@
-#ifndef __WIFIFW_POWERCTRL_RAM_H__
-#define __WIFIFW_POWERCTRL_RAM_H__
-
-/*--------------------Define --------------------------------------------*/
-#define CLK_DOWN_RDY            BIT4
-#define WAIT_TXSM_STABLE_CNT            (1000)
-#define WAIT_TXSM_STABLE_ONCE_TIME      (50)
-#define WAIT_RPWM_STABLE_BREAK_CNT      (100)
-#define BACKUP 			FALSE
-#define RESTORE 			TRUE
-
-/*--------------------Define Enum---------------------------------------*/
-/* TxPauseReasonCode */
-typedef enum _TPRC_ {
-	TPRC_ISSUEBTQNull_1             = 0x1,
-	TPRC_ISSUEBTQNull_2             = 0x2,
-	TPRC_FLEXIBLEEXTENDECISION_1    = 0x3,
-	TPRC_BTTDMA03_1                 = 0x4,
-	TPRC_BTTDMABCN_1                = 0x4,
-	TPRC_BTTDMATBTT_1               = 0x5,
-	TPRC_BTTDMA14_1                 = 0x6,
-	TPRC_BTTDMATIMEOUT_1            = 0x6,
-	TPRC_BTTDMA25_1                 = 0x7,
-	TPRC_BTTDMATIMEOUT_2            = 0x7,
-	TPRC_BTTDMA25_3                 = 0x8,
-	TPRC_BTTDMATIMEOUT_3            = 0x8,
-	TPRC_BTTDMA25_5                 = 0x9,
-	TPRC_BTTDMATIMEOUT_4            = 0x9,
-	TPRC_BTTDMA25_7                 = 0xA,
-	TPRC_BTTDMATIMEOUT_5            = 0xA,
-	TPRC_BTTDMA03_2                 = 0xB,
-	TPRC_BTTDMATIMEOUT_6            = 0xB,
-	TPRC_BTTDMA14_2                 = 0xC,
-	TPRC_BTTDMATIMEOUT_7            = 0xC,
-	TPRC_BTTDMA25_2                 = 0xD,
-	TPRC_BTTDMATIMEOUT_8            = 0xD,
-	TPRC_BTTDMA25_4                 = 0xE,
-	TPRC_BTTDMATIMEOUT_9            = 0xE,
-	TPRC_BTTDMA25_6                 = 0xF,
-	TPRC_BTTDMATIMEOUT_10           = 0xF,
-	TPRC_BTTDMA25_8                 = 0x10,
-	TPRC_BTTDMATIMEOUT_11           = 0x10,
-	TPRC_BACKUPANTENNA_1            = 0x11,
-	TPRC_BTROLECHANGETIMER          = 0x12,
-	TPRC_H2CSCAN                    = 0x13,
-	TPRC_ISSUEFCSNULLDATA_1         = 0x14,
-	TPRC_ISSUEFCSNULLDATA_2         = 0x15,
-	TPRC_FASTCHSWITCH               = 0x16,
-	TPRC_FCSDEFAULT                 = 0x17,
-	TPRC_ISSUENDPA_1                = 0x18,
-	TPRC_ISSUENDPA_2                = 0x19,
-	TPRC_BACKUPCURRENT              = 0x1A,
-	TPRC_SETPROBERATE_1             = 0x1B,
-	TPRC_SETPROBERATE_2             = 0x1C,
-	TPRC_WPA22_1                    = 0x1D,
-	TPRC_WPA22_2                    = 0x1E,
-	TPRC_P2PPSAONTS                 = 0x1F,
-	TPRC_P2PPSAONTAOFF              = 0x20,
-	TPRC_P2PPSAONTRF                = 0x21,
-	TPRC_P2PPSSTRF                  = 0x22,
-	TPRC_P2PPSSTAOFF                = 0x23,
-	TPRC_P2PPSAOFFTS                = 0x24,
-	TPRC_P2PPSRFTS                  = 0x25,
-	TPRC_ISSUENULLDATA_1            = 0x26,
-	TPRC_ISSUENULLDATA_2            = 0x27,
-	TPRC_ISSUENULLDATA_3            = 0x28,
-	TPRC_ISSUEQNULL_1               = 0x29,
-	TPRC_ISSUEQNULL_2               = 0x2A,
-	TPRC_PSS2TS3                    = 0x2B,
-	TPRC_PSS0TS1                    = 0x2C,
-	TPRC_PSS2TS4                    = 0x2D,
-	TPRC_PSS2TS5                    = 0x2E,
-	TPRC_PSS0TS6                    = 0x2F,
-	TPRC_SAPPSTIMEOUT               = 0x31,
-	TPRC_RLPSTBTT                   = 0x32,
-	TPRC_ISSUEARP_1                 = 0x33,
-	TPRC_ISSUEARP_2                 = 0x34,
-	TPRC_REMOTEWAKEUPCTRL           = 0x35,
-	TPRC_SCOESCO_1                  = 0x36,
-	TPRC_ISSUECTS2SELF_1            = 0x36,
-	TPRC_ISSUECTS2SELF_2            = 0x37,
-	TPRC_ISSUECTS2SELF_3            = 0x38,
-	TPRC_ISSUEPROBERSQ              = 0x38,
-	TPRC_ISSUENA_1                  = 0x39,
-	TPRC_ISSUENA_2                  = 0x3A,
-
-	TPRC_ISSUENEGORSP_1             = 0x3B,
-	TPRC_ISSUENEGORSP_2             = 0x3C,
-	TPRC_ISSUEINVITRSP_1            = 0x3D,
-	TPRC_ISSUEINVITRSP_2            = 0x3E,
-	TPRC_ISSUEPDRSP_1               = 0x3F,
-	TPRC_ISSUEPDRSP_2               = 0x40,
-	TPRC_ISSUEDBGPKT_1              = 0x41,
-	TPRC_ISSUEDBGPKT_2              = 0x42,
-	TPRC_AP_OFFLOAD_MBSSID          = 0x43,
-	TPRC_MACID_DROP_ACTION          = 0x44,
-	TPRC_FASTCHSWITCH_2             = 0x45,
-	TPRC_MACID_DROP_ACTION_2        = 0x46,
-	TPRC_WAITTXSMOK_1               = 0x47,
-	TPRC_WAITTXSMOK_2               = 0x48,
-	TPRC_FCSDEFAULT_2               = 0x49,
-	TPRC_MCCMacidAction             = 0x4A,
-	TPRC_MCCMacidAction_2           = 0x4B,
-	TPRC_MCCSWITCHCHANNEL_1         = 0x4C,
-	TPRC_MCCSWITCHCHANNEL_2         = 0x4D,
-	TPRC_MCCStateHDL_1              = 0x4E,
-	TPRC_MCCStateHDL_2              = 0x4F,
-	TPRC_MCCStateHDL_3              = 0x50,
-	TPRC_MCCStateHDL_4              = 0x51,
-	TPRC_MACID_DROP_ACTION_3        = 0x52,
-	TPRC_MCCTSFSyncHDL_1			= 0x53,
-	TPRC_MCCTSFSyncHDL_2			= 0x54,
-	TPRC_ISSUENDPA_3				= 0x55,
-	TPRC_InitPS					    = 0x56,
-	TPRC_H2CHDL_TX_PAUSE_DRV_INFO	= 0x57,
-	TPRC_MCCBcnEarlyHDL_1           = 0x58,
-	TPRC_MCCBcnEarlyHDL_2           = 0x59,
-	TPRC_WAITTXSMOK_3               = 0x5A,
-	TPRC_WAITTXSMOK_4               = 0x5B,
-	TPRC_WAITTRIGEERSPEND         = 0x5C,
-} TPRC, *PTPRC;
-
-/* RxPauseReasonCode */
-typedef enum _RRPC_ {
-	RPRC_SLEEPTO32K_1               = 0x1,
-	RPRC_SLEEPTO32K_2               = 0x2,
-	RPRC_REMOTE_WAKEUP              = 0x3,
-} RRPC, *PRRPC;
-
-/* SetBeaconEarlyAndTimeoutReasonCode */
-typedef enum _SBEATPC_ {
-	SBEATPC_H2C                     = 0x1,
-	SBEATPC_RPWM                    = 0x2,
-	SBEATPC_BCNADUST                = 0x3,
-	SBEATPC_ENLARGE                 = 0x4,
-	SBEATPC_TBTT                    = 0x5,
-	SBEATPC_SAPPS                   = 0x6,
-} SBEATPC, *PSBEATPC;
-
-/*--------------------Function declaration---------------------------------*/
-extern u8 wifi_is_enable;
-extern u8 GetRPWMValue_8720E(void);
-extern void WaitHWStateReady_8720E(void);
-extern void PsOpenRF_8720E(void);
-extern void PsCloseRF_8720E(void);
-extern void PsOpenRFHIOE_8720E(void);
-extern void PsCloseRFHIOE_8720E(void);
-extern void SysClkDown_8720E(void);
-extern void SysClkUp_8720E(void);
-extern BOOLEAN WaitTxStateMachineOk_8720E(void);
-extern void LowPowerRxBeacon_8720E(BOOLEAN on);
-extern void PSPeriodCCA_8720E(BOOLEAN on);
-extern void WriteTxPause_8720E(u8 value, u8 rcode);
-extern void SetTxPauseFWInfo_8720E(u8 BitMask, u8 UserValue);
-extern void WriteTxPauseWithMask_8720E(u8 mask, u8 value, u8 rcode);
-extern void PwrGatedBKRSTxReg_8720E(BOOLEAN on);
-extern void PwrGatedBKRSCtrlInfo_8720E(BOOLEAN on);
-extern void PwrGatedBKRSMACTXPower_8720E(BOOLEAN on);
-extern void PwrGatedInitBBTRX_8720E(BOOLEAN on);
-extern void BeaconModeBBAGCtableUpdate_8720E(BOOLEAN on);
-extern void BeaconModeDCKbackup_8720E(void);
-extern void PwrGatedInitDRFC_8720E(BOOLEAN on);
-extern void PwrGatedBKRSBBTSSIREG_8720E(BOOLEAN on);
-extern void PwrGatedWifiParmBkRs_8720E(BOOLEAN on);
-extern void PwrGatedInitBB(void);
-extern void PwrGatedInitLLTAndPageAlloc_8720E(void);
-#endif  /* __WIFIFW_POWERCTRL_RAM_H__ */
diff --git a/os/board/rtl8720e/src/component/wifi/wifi_fw/amebalite/include/wififw_powersave_ram.h b/os/board/rtl8720e/src/component/wifi/wifi_fw/amebalite/include/wififw_powersave_ram.h
deleted file mode 100644
index 4b7d11d7c..000000000
--- a/os/board/rtl8720e/src/component/wifi/wifi_fw/amebalite/include/wififw_powersave_ram.h
+++ /dev/null
@@ -1,556 +0,0 @@
-#ifndef __WLAN_POWERSAVE_RAM_H__
-#define __WLAN_POWERSAVE_RAM_H__
-
-/*--------------------Define --------------------------------------------*/
-#define MACID_CLIENT						0
-#define MAX_LEAKAGE_LIMIT   				3
-#define LEAKAGE_DELAY_TIME					5
-#define MAC_RS_TXREG_NUM 	20
-#define MAC_RS_TXPWRREG_NUM 	102
-
-/*TIMER allcation*/
-#define TIMER_TC0_CTRL						REG_TC0_CTRL    //instead of PowerTranning
-#define TIMER_TC1_CTRL						REG_TC1_CTRL    //by PS or APOffload(AP mode)
-#define TIMER_TC2_CTRL						REG_TC2_CTRL    //by PS
-#define TIMER_TC3_CTRL						REG_TC3_CTRL    //by BT Multi-slot TDMA
-#define TIMER_TC4_CTRL						REG_TC4_CTRL    //Rsvd for driver
-#define TIMER_TCUNIT						REG_TCUNIT_BASE
-#define TIMER_TC5_CTRL						REG_TC5_CTRL    //by BT i2c timeout ( 92e only)
-#define TIMER_TC6_CTRL						REG_TC6_CTRL    //by BT TDMA
-
-#define COUNTER_WAITFCS					TIMER_TC0_CTRL //start a protect timer for MAC not receive FCS after lps offload tim hit
-#define COUNTER_BCNTO						TIMER_TC1_CTRL  // counter used by BCNTO is the same with DTIM
-#define COUNTER_DTIM						TIMER_TC1_CTRL
-#define COUNTER_PSTRX 						TIMER_TC2_CTRL
-#define COUNTER_WAITHOST					TIMER_TC3_CTRL
-#define COUNTER_DELAYKEEPALIVE			TIMER_TC5_CTRL
-#define COUNTER_CSITXNULL					TIMER_TC5_CTRL
-#define REG_PGRSStateInd					REG_FWLBK_DBG0
-#define MACPGResumeDone					(0x12345678)
-/*
-    PS_RX_INFO[7:0]: Power Save RX Information Register
-    initial value: 0x00
-    REG III.220 (Offset 0x 0692h) PS_RX_INFO Register Definition
-*/
-#define RXDATAIN0								BIT0  //PSTX
-#define RXDATAIN1								BIT1  //PSRX
-#define RXDATAIN2								BIT2
-#define RXMGTIN0								BIT3
-#define RXCTRLIN0								BIT4
-
-//Power Save Tuning Parameter
-#define BCN_RX_ON_DELAY         			2        //Beacons are transmitted in 1MHz, then 1bit per 1microsecond. If 2ms are added, it prevents from losing approximately 250bytes in worst case.
-#define BCN_EARLY_32K_MARGIN    			2        // 1ms would be enough, but 2ms is better for multicast receiving in open space
-#define BCN_EARLY_DRV_MARGIN    			1        // 1ms would be better in open space
-
-#define BCN_RECEIVE_32K_BUFFER  		(BCN_RX_ON_DELAY+BCN_EARLY_32K_MARGIN)
-#define BCN_RECEIVE_DRV_BUFFER  		(BCN_RX_ON_DELAY+BCN_EARLY_DRV_MARGIN)
-
-#define BCN_DISTRIBUTION        			8  //5ms ,generally is 5 ms
-#define DEFAULT_BCN_TO_PERIOD   		(BCN_RECEIVE_32K_BUFFER+BCN_DISTRIBUTION)  //choose the bigger one
-#define DEFAULT_BCN_TO_LIMIT    			2  // 1
-
-#define DEFAULT_BCN_TO_TIMES_LIMIT  	2
-#define DEFAULT_DTIM_TIMEOUT    			15  // 7         // 7 ms
-#define DEFAULT_PS_TIMEOUT      			20  // 20       // 20 ms
-#define DEFAULT_PS_DTIM_PERIOD  		7
-
-#define DEFAULT_PS_BCN_EARLY_MIN     	1
-#define DEFAULT_PS_BCN_EARLY   	     	3
-#define DEFAULT_PS_BCN_EARLY_128US   	0
-#define DEFAULT_PS_BCN_EARLY_32US    	0
-#define DEFAULT_PS_BCN_EARLY_32K   	 	5
-#define DEFAULT_PS_BCN_EARLY_128US_32K	0
-#define DEFAULT_PS_BCN_EARLY_32US_32K	0
-#define DEFAULT_BCN_TO_PERIOD_32K			15
-
-#define DEFAULT_PS_BCN_EARLY_V_32K   	 5
-#define DEFAULT_PS_BCN_EARLY_V_128US_32K   0
-#define DEFAULT_PS_BCN_EARLY_V_32US_32K    0
-
-#define DEFAULT_PS_32K_EARLY(x)       	(((DEFAULT_PS_BCN_EARLY_V_32K+(x)) << 5)+(DEFAULT_PS_BCN_EARLY_V_128US_32K<< 2)+(DEFAULT_PS_BCN_EARLY_V_32US_32K))
-#define BCN_PS_32K_SHIFT_MAX(x)        	(((DEFAULT_PS_BCN_EARLY_V_32K+(x)) << 5)+(DEFAULT_PS_BCN_EARLY_V_128US_32K<< 2)+(DEFAULT_PS_BCN_EARLY_V_32US_32K))
-#define DEFAULT_PS_EARLY(x)       		(((DEFAULT_PS_BCN_EARLY+(x)) << 5)+(DEFAULT_PS_BCN_EARLY_128US<< 2)+(DEFAULT_PS_BCN_EARLY_32US))
-#define BCN_PS_SHIFT_MAX(x)        		(((DEFAULT_PS_BCN_EARLY+(x)) << 5)+(DEFAULT_PS_BCN_EARLY_128US<< 2)+(DEFAULT_PS_BCN_EARLY_32US))
-
-#define BCN_ADVANCE_MAX         			10
-#define BCN_EARLY_MARGIN        			1       //unit 256us
-#define RF_ON_COMPENSATION          		50//70   1030        //unit 1us
-#define BCN_RX_INT_DELAY              		90//  70   1030   //unit 1us
-#define BCN_DELAY_MAX           			15
-#define BCN_CALCULATION_MAX     			(BCN_ADVANCE_MAX+BCN_DELAY_MAX)
-
-#define BCN_ADJUST_COUNT        			100
-#define BCN_EXCLUDED_NUM        			(BCN_ADJUST_COUNT/20)
-#define BCN_ENLARGE_NUM         			5
-#define SHIFT_COMPENSATION      			1
-#define BCN_DRIFT_COMPENSATION  		2
-
-#define NULL_DATA0_ALLOW        			1
-#define NULL_DATA0_DENY         			0
-
-#define PS_RF_OFF               				0
-#define PS_GO_ON                				BIT0
-#define PS_TX_NULL              				BIT1
-#define PS_RF_ON               	 			BIT2
-#define PS_REGISTER_ACTIVE      			BIT3
-
-//0x009C
-#define PS_32K_IN               				BIT0
-#define PS_32K_PG               				BIT4
-#define PS_ACK                  				BIT6
-#define PS_TOGGLE              			 	BIT7
-
-#define PS_STATE_MASK           			(0x0F)
-#define PS_IS_TX_NULL(x)        			((x) & PS_TX_NULL )
-#define PS_IS_CLK_ON(x)         			((x) & (PS_RF_OFF |PS_ALL_ON ))
-#define PS_IS_RF_OFF(x)         			((x)|PS_RF_OFF)
-#define PS_IS_RF_ON(x)          			((x) & (PS_RF_ON))
-#define PS_IS_ACTIVE(x)         			((x) & (PS_REGISTER_ACTIVE))
-
-#define PS_STATUS_S0            			(PS_REGISTER_ACTIVE | PS_RF_ON)                    //(1,1,0) all on = register active + rf on
-#define PS_STATUS_S1            			(PS_REGISTER_ACTIVE | PS_RF_ON | PS_TX_NULL)        //(1,1,1) all on + tx null(1)
-#define PS_STATUS_S2            			(PS_RF_ON)                                         //(0,1,0) register sleep + rf on
-#define PS_STATUS_S3            			(PS_RF_ON | PS_TX_NULL)                            //(0,1,1) register sleep + rf on + tx null(0)
-#define PS_STATUS_S4            			0                                                 //(0,0,0) all OFF
-#define PS_STATUS_S5            			(PS_TX_NULL )                                      //(0,0,1) SCAN = register sleep + rf on + scan enable
-#define PS_STATUS_S6            			(PS_REGISTER_ACTIVE)                               //(1,0,0) NoA off = register active + rf off
-
-/* DATA FIN Condition Flags */
-#define STA_DATA_OPEN           			BIT0  // indicate that FW open due to TIM = 1 condition. (PS-POLL as trigger frame)
-#define BC_DATA_OPEN            			BIT1   // indicate that FW open due to DTIM = 1 condition.  (BC & MC)
-#define QOS_DATA_OPEN           			BIT2 // indicate that FW open due to UAPSD trigger condition. (QNULL)
-#define C2H_DATA_OPEN          				BIT3   // indicate that FW open due to C2H event 
-#define BCN_DATA_OPEN           			BIT4
-#define APP_DATA_OPEN           			BIT5
-
-#define ALL_80211_DATA_OPEN     			(STA_DATA_OPEN | BC_DATA_OPEN | QOS_DATA_OPEN)
-#define IS_80211_DATA_OPEN(x)			((x) & ALL_80211_DATA_OPEN)
-#define IS_C2H_DATA_OPEN(x)     			((x) & C2H_DATA_OPEN)
-
-#define SET_DATA_OPEN(x, type)  		((x) |= (type))
-#define CLR_DATA_OPEN(x, type)  		((x) &= (~type))
-#define IS_DATA_OPEN(x, type)   			((x) & (type))
-
-/* pwr state */
-#define PS_TYPE_32KPERMISSION       	0
-#define PS_TYPE_CURRENT_PS_STATE    	1
-#define PS_TYPE_LASTRPWM            		2
-
-#if CONFIG_PS_DEBUG
-#define DBG_LPS_WRITE(x,y)		(x = y)
-#define DBG_LPS_INCREASE(x)		(++x)
-#define DBG_LPS_SM(x,y) 			(SysMib.PSDbgParm.DbgLpsSM[x] = y)
-#else
-#define DBG_LPS_WRITE(x,y)
-#define DBG_LPS_INCREASE(x)
-#define DBG_LPS_SM(x,y)
-#endif
-
-/*--------------------Define Enum---------------------------------------*/
-typedef enum _RxListenBeaconMode_ {
-	RLBM_MIN                = 0,
-	RLBM_MAX,
-	RLBM_SELF_DEFINED
-} RxListenBeaconMode, *PRxListenBeaconMode;
-
-typedef enum _RT_MEDIA_STATUS {
-	RT_MEDIA_DISCONNECT     = 0,
-	RT_MEDIA_CONNECT        = 1
-} RT_MEDIA_STATUS;
-
-typedef enum _PS_MODE_SETTING_SELECTION_ {
-	MODE_SETTING_ACTIVE     = 0,
-	MODE_SETTING_LEGACY     = 1,
-	MODE_SETTING_WMMPS      = 2
-
-} PS_MODE_SETTING_SELECTION, *PPS_MODE_SETTING_SELECTION;
-
-typedef struct _LEGACY_PS_PPARM_ {
-	u8		ps_mode: 7;
-	u8		ClkRequestEnable: 1;
-	u8   	RLBM: 4;            //RX Listen BCN Mode
-	u8 		smart_ps: 4;
-	u8		AwakeInterval;      //Unit: beacon interval, this field is only valid in PS Self-Defined mode
-	u8		bAllQueueUAPSD: 1;    // 1: all queue are uapsd 0: not all queue are uapsd
-	u8		bMaxTrackingBcnMode: 1;
-	u8		bBCNEarlyReport: 1;
-	u8		XtalSel: 1;
-	u8 		rsvd0: 4;
-	u8		PwrState;
-	u8		lpsofldEn: 1;
-	u8		waitbcnfcsEn: 1;
-	u8		rsvd1: 6;
-	u8		BcnRecevingTime : 5;
-	u8		BcnListenInterval : 2;
-	u8		AdoptUserSetting: 1;
-} LEGACY_PS_PARM, *PLEGACY_PS_PARM;
-
-typedef struct _PS_TUNING_PPARM_ {
-	u8		BCNTOLimit;
-	u8		DTIMTimeOut;
-	u8		Adopt: 1;
-	u8		PSTimeOut: 7;
-	u8		PS_DTIMPeriod;
-	u8		rsvd1;
-} PS_TUNING_PPARM, *PPS_TUNING_PPARM;
-
-/*--------------------Define Struct---------------------------------------*/
-typedef struct _BEACON_ADJUST_PARM_ {
-	u8		BcnReceive32KBuffer;          //unit 128us
-	u8		BcnReceiveDrvBuffer;          //unit 128us
-	u16   	BcnAdjustCount;
-	u8    	BcnExcludedNum;
-	u8    	BcnEnlargeNum;
-} BEACON_ADJUST_PARM, *PBEACON_ADJUST_PARM;
-
-typedef struct _PS_PARM_ {
-	u8		Enter32KHzPermission: 1;
-	u8		bAllQueueUAPSD: 1;
-	u8		ps_dtim_flag: 1;            // indicate dtim of current beacon.
-	u8		pstrx_rxcnt_period: 1;
-	u8 		NoConnect32k: 1;
-	u8		TxNull0: 1;
-	u8		TxNull1: 1;
-	u8		rsvd0: 1;
-
-	u8 		TxNull0ok: 1;
-	u8		TxNull1ok: 1;
-	u8		RfOffLicenseForBCNRx: 1;    //filen: After we received ps_bcn_cnt beacons, we can sleep(rf off).
-	u8		BCNAggEn: 1;
-	u8		IsGoingTo32K: 1;
-	u8		bMaxTrackingBcnMode: 1;
-	u8		BcnTraceDone: 1;
-	u8		BcnEarlyPeriodFlag: 1;
-
-	u8		BcnEarlySettingFlag: 1;
-	u8		bBCNEarlyReport: 1;
-	u8		BcnEnter32kMode: 1;
-	u8		XtalSel: 1;
-	u8		rsvd: 4;
-	/*
-	    filen: to indicate whether it is smart power saving or not
-	    0: Legacy PS
-	    1: Smart PS(RX use ps_poll)
-	    2: Smart PS (RX use null_data(0))
-	*/
-	u8		smart_ps: 4;                //enum SMART_PS_MODE
-	u8		RLBM: 4;                    // RX BCN MODE (min, max, active, ...)
-	u8		AwakeInterval;
-	u8		ps_mode;                    // ps type (avtive, legacy, wmmps)
-	u8		ClkRequestEnable;
-	u8		last_rpwm;
-	u8		current_ps_state;
-	u8 		ps_data_open;
-	u8		ps_dtim_period;
-	u8		ps_dtim_cnt;
-	u8		ps_bcn_to;                  //unit 128us        // beacon timeout (ms).
-	u8		bcn_to_cnt;                 // indicate the total number of contnuous BCN_TO we have received.
-	u8		bcn_to_times_cnt;        //20140806
-	u8		ps_drv_early_itv;       // 32us
-	u8		BcnAheadShift;          //unit 32us
-	u8		BcnEarlyShift;          //unit 32us
-	u8		BcnEarlyShiftMax;           //unit 32us
-	u8		DefaultBcnEarly;            //unit 32us
-	u8 		RxBcnCount;
-	u8		TBTTCount;
-	u8		CurrentEarly;           //unit 32us
-	u8 		CurrentTimeOut;         //unit 128us
-	u8		ReachBcnLimitCount;
-	u8		XtalDelay;
-	union {
-		u8		BcnDurationArray[2];
-		u16	BcnDuration;
-	} BcnDurationUnion;
-	u32	TSFOnTBTT;              //unit in TU
-	//ben modify for open/close RF speedup.
-	union {
-		u8		TSFOnRxBcnArray[4];
-		u32	TSFOnRxBcn;
-	} TSFOnRxBcnUnion;
-	union {
-		u8		TSFOnBcnEarlyArray[4];
-		u32	TSFOnBcnEarly;
-	} TSFOnBcnEarlyUnion;
-	BEACON_ADJUST_PARM BeaconAdjustParm;
-	u8		rcv_action;
-	u8		AckNull0;
-	u8 		Fix_Delay_forward;
-	u8 		bTIM_Flag;
-	u8		Null0_rty_cnt;
-	u8 		Null0_rty_lmt;
-	u8 		BCNNumForDRV;//driver deric
-	u8 		ScanEn;
-#if CONFIG_LEAPY_AP
-	u8 TrafficLeakageCnt;
-	BOOLEAN waiting_leakage_check;
-#endif
-#if CONFIG_BEACON_MODE
-	u32 BCN_G7_DCK;
-	u32 BCN_DCKG0;
-	u32 BCN_DCKG1;
-	u32 BCN_DCKG2;
-	u32 BCN_DCKG3;
-	u32 BCN_DCKG4;
-	u32 BCN_DCKG5;
-	u32 BCN_DCKG6;
-	u32 BCN_DCKG7;
-	u32 BB4454;
-	u32 BCNModeCH;
-#endif
-
-} PS_PARM, *PPS_PARM;
-
-typedef enum _SMART_PS_MODE_FOR_LEGACY_ {
-	SMART_PS_MODE_LEGACY_PWR1           = 0,        // TX: pwr bit = 1, RX: PS_POLL
-	SMART_PS_MODE_TX_PWR0               = 1,        // TX: pwr bit = 0, RX: PS_POLL
-	SMART_PS_MODE_TRX_PWR0              = 2,         // TX: pwr bit = 0, RX: NULL(0)
-	SMART_PS_MODE_TX_PWR1				= 3 		// TX: pwr bit = 1, RX: NULL(0)
-} SMART_PS_MODE_FOR_LEGACY, *PSMART_PS_MODE_FOR_LEGACY;
-
-typedef struct _SAPPS_PARM_ {
-	u8      Enable: 1;
-	u8      EnPS: 1;
-	u8      EnLPRx: 1;
-	u8      Manual32k: 1;
-	u8      Active: 1;
-	u8      FlagToWaitHostCutPower: 1;
-	u8      RF2Path: 1;
-	u8      rsvd: 1;
-	u8      Duration;
-	u8      Duration_On;
-	u8      Duration_Off;
-	u8      AntSwitchOutside;
-	u8      TwoAnt;
-	u8      AntSelReverse;
-	u8      TxPathCtrl;
-} SAPPSParm, *PSAPPSParm;
-
-typedef struct _INACTIVEPS_Parm_ {
-	u8      Enable: 1;
-	u8      IgnorePsCondition: 1;
-	u8      rsvd: 6;
-	u8      Frequency;
-	u8      Duration;
-	u8      FrequencyCount;
-} INACTIVEPSParm, *PINACTIVEPSParm;
-
-typedef struct _LPSOFFLOAD_Parm_ {
-	u8	MACRXBCNOfldEn: 1;
-	u8	HWCtrlTRXOnOff: 1;
-	u8	ByPassLsysWakeEn: 1;
-	u8	WaitFCSOptionEn: 1;
-	u8	RcvingTimhitBcn: 1;
-	u8	ReceiveTimhit: 1;
-	u8	BKForPGResDone: 1;
-	u8	InHWCtrlOnOffPeriod: 1;
-	u16 RxbcnModeCmdFileStartAddr;
-	u16 RxbcnModeCmdFileEndAddr;
-	u16 ExitRxbcnModeCmdFileStartAddr;
-	u16 ExitRxbcnModeCmdFileEndAddr;
-	u16 TRXOnCmdFileHWStartAddr;
-	u16 TRXOnCmdFileFWStartAddr;
-	u16 TRXOnCmdFileEndAddr;
-	u16 TRXOffCmdFileStartAddr;
-	u16 TRXOffCmdFileEndAddr;
-	u16 BBBkRsCmdFileStartAddr;
-	u16 BBBkRsCmdFileEndAddr;
-	u16 RF0x18RSCmdFileStartAddr;
-	u16 RF0x18RSCmdFileEndAddr;
-	u16 Delay2USCmdFileStartAddr;
-	u16 Delay2USCmdFileEndAddr;
-	u16 PGHIOECH1BKStartAddr;
-	u16 PGHIOECH1BKEndAddr;
-	u16 PGRSCmdFileStartAddr;
-	u16 PGRSCmdFileEndAddr;
-	u16 PGRSStartDelayStartAddr;
-	u16 PGRSStartDelayEndAddr;
-	u16 BcnIntervalBackup;
-} LPSOFFLOADParm, *PLPSOFFLOADParm;
-
-typedef struct _Bcnearly_adjust_PID_ {
-	u32 	PerDeltaTSF;  //unit us
-	u32 	DeltaTSF;
-	u32 	PerError;
-	u32 	Error;
-	u32 	Per1_TSFOnRxBcn;
-	u32 	Per2_TSFOnRxBcn;
-	u32 	PbaseMinDeltaTSF;
-	u8		PbaseGetTime;
-	u8		PbaseGetting;
-	u16 	Pinc;
-	u8  	LimitOutput;  //unit 32us
-	u8		MaxOutput;	 //unit 32us
-	u8		PITOOutput;	 //unit 32us
-	u8		BaseOutput;	 //unit 32us
-	u8		IBaseMinOutput;
-	u8		Phase1Output;	 //unit 32us
-	u8		Phase2Output;	 //unit 32us
-	u8		Phase3StbAdd;
-	u8		BaseOPGetTime;
-	u8		BaseOutputSetDown;
-	u8		BcnLossCount;
-	u32 	DeltaTSFSum;  //unit us
-} BCNEARLY_ADJUST_PID, *PBCNEARLY_ADJUST_PID;
-
-typedef struct _Bcnearly_adjust_Stat_ {
-	u32 	DeltaTSF;
-	u32 	DeltaTSFMax;
-	u32 	Per1_TSFOnRxBcn;
-	u32 	Per2_TSFOnRxBcn;
-	//u8      BcnMissMinRadio;
-	u8      BcnDelay64us[128];
-	u8      DelayCnt[128];
-	u8 		Phase1MinSet;
-	u8		Phase2CntFull;
-	//u8	Phase3StbCK;
-	u8		BcnLossCount;
-	u32 	DeltaTSFSum;  //unit us
-	u8		Phase1Cnt;
-	u8		Phase1Output;	 //unit 32us
-	u8		Phase2Cnt;
-	u8		Phase2Output;	 //unit32us
-	u8		Phase3Stbflag;
-	u8		Phase3StbAdd;
-	u8		LimitOutput;
-} BCNEARLY_ADJUST_Stat, *PBCNEARLY_ADJUST_Stat;
-
-typedef struct _LPSPG_PARM_ {
-	u8      LpsPG_En;
-	u32   	LPS_Option;
-	u16 HIOE_STR_ADDR;
-	u16 HIOE_END_ADDR;
-	u8     	HioeRestoreDone: 1;
-	u8     	HioeBackupDone: 1;
-	u8	rsvd: 6;
-	u32	ARFC18;
-	u32	DRFC18;
-	u32 	ARFC0;
-	u32 	DRFC0;
-	u32 BB8038;
-	u32 BB803C;
-	u8 RxBcnMode_status;
-	u8 BKBcnMode_status;
-	u32 mactxreg[MAC_RS_TXREG_NUM];
-	u32 macid0ctrlinfo[10];
-	u32 mactxpower[MAC_RS_TXPWRREG_NUM];
-	u32 tssi_bbpage56[64];
-	u32 tssi_bbpage58[64];
-} LPSPG_PARM, *PLPSPG_PARM;
-
-typedef enum _ITWTCLT_ {
-	ITWTCLIENTA               = 0x0,
-	ITWTCLIENTB               = 0x1,
-	ITWTCLIENTC               = 0x2,
-	ITWTCLIENTD               = 0x3,
-} ITWTCLT, *PITWTCLT;
-
-typedef struct _ITWTCLIENT_PARM_ {
-	u8		TWT_En;
-	u8		TRIGGER_En;
-	u8		TXPAUSE;
-	u8		ANNOUNCED;
-	u16	DURATION;
-	u32	INTERVAL;
-	u32	TWTIME_H;
-	u32	TWTIME_L;
-	u8		SPSTARTFLAG;
-	u8		TWTEarly;
-} ITWTCLIENT_PARM, *PITWTCLIENT_PARM;
-
-typedef struct _LPS_ITWT_PARM_ {
-	u8		FLOW_ID;//client number
-	u8		TWTVALID;
-	u8		TWTBCNTo;
-	u32	TWTTSFRxBcn;
-	u32	TWTTSFKeepAlive;
-	ITWTCLIENT_PARM ITWTCLIENT1;
-	ITWTCLIENT_PARM ITWTCLIENT2;
-	ITWTCLIENT_PARM ITWTCLIENT3;
-	ITWTCLIENT_PARM ITWTCLIENT4;
-} LPS_ITWT_PARM, *PLPS_ITWT_PARM;
-
-typedef struct _PS_DBGPARM_ {
-	//DW
-	u8		DbgLpsSM[4];//state machine
-	u16	IssueTxNull0;
-	u16	TxNull0OK;
-	u16	TxNull0Timeout;
-	u16 	TxNull0Preempted;
-	u16	IssueTxNull1;
-	u16 	TxNull1OK;
-	u16	TxNull1Timeout;
-	u16	TxNull1Preempted;
-} PS_DBGPARM, *PPS_DBGPARM;
-/*--------------------Function declaration---------------------------------*/
-extern void SetPwrStateReg_8720E(u8 PwrStateType, u8 value);
-extern void ResetPSParm_8720E(void);
-extern BOOLEAN ChkTxQueueIsEmpty_8720E(void);
-extern void Legacy_PS_Setting_8720E(void);
-extern void PSModeSetting_8720E(u8 on) ;
-extern void ConfigListenBeaconPeriod_8720E(u8  RLBM, u8 AwakeInterval);
-extern void PSSetMode_8720E(PLEGACY_PS_PARM pparm);
-extern void PS_S2ToS0State_8720E(void);
-extern void PS_S3ToS2orS0State_8720E(void);
-extern void PS_S1ToS0orS2State_8720E(void);
-extern void PS_S2ToS4State_8720E(void);
-extern void PS_S2ToS5State_8720E(void);
-extern void PS_S5ToS2State_8720E(void);
-extern void PS_S4ToS2State_8720E(u8  ReleaseTxPause);
-extern void SetBcnEarlyAndTimeout_8720E(u8 BcnAheadShift, u8 BcnEarlyShift, u8 BcnTimeout, u8 ReasonCode);
-extern void EnlargeBcnEarlyAndTimeout_8720E(void);
-extern void PS_S6ToS0State_8720E(void);
-extern void PS_S0ToS6State_8720E(void);
-extern void Change_PS_State_8720E(u8, u8);
-extern u8 PS_S4_Condition_Match_8720E(void);
-extern BOOLEAN PS_S2_Condition_Match_8720E(void);
-extern BOOLEAN PS_32K_Condition_Match_8720E(void);
-extern void PS_S2ToS3State_8720E(u8 nulldata0Allow);
-extern void PS_S0ToS1State_8720E(void);
-extern void SmartPS2InitTimerAndToGetRxPkt_8720E(void);
-extern void InitPS_8720E(void);
-extern void SetSmartPSTimer_8720E(void);
-extern void ChangePSStateByRPWM_8720E(void);
-extern void PSBcnEarlyProcess_8720E(void);
-extern void PSBcnAggEarlyProcess_8720E(void);
-extern void PsDtimToProcess_8720E(void);
-extern void PsBcnToProcess_8720E(void);
-extern void TxPktInPSOn_8720E(void);
-extern void PSSleepTo32K_8720E(void);
-extern void PSRxBcnProcess_8720E(void);
-extern void InitSAPPS_8720E(void);
-extern void SAPPSTBTTHDL_8720E(void);
-extern void SAPPSTimeOutHDL_8720E(void);
-extern void SAPPSEarlyHDL_8720E(void);
-extern void SAPLPS_8720E(void);
-extern BOOLEAN CHECKTWTClientNULL_8720E(void);
-extern BOOLEAN CHECKTWTClientSPEND_8720E(void);
-extern void PSTWTEarlyProcess_8720E(void);
-extern void PSTWTBcnToProcess_8720E(void);
-extern void PSTWTBcnRxProcess_8720E(void);
-extern void LPS_ITWTTimeUpdate_8720E(u8 clientnum);
-extern void LPS_ITWTDurationUpdate_8720E(u8 clientnum);
-extern void LPS_ITWTTIMERSetting_8720E(u8 portnum, u8 clientnum);
-extern void LPS_ITWTStatusSet_8720E(u8 clientnum);
-extern void LPS_ITWTIMRSetting_8720E(u8 clientnum);
-extern void LPS_ITWTByPassLsysWakeInt_8720E(BOOLEAN ByPassLsysWakeEn);
-extern void LPS_ITWTSPWORK_8720E(BOOLEAN ITWTSTART);
-extern void LPS_ITWT_PortSet_8720E(u8 portnum, u8 clientnum);
-extern void LPS_ITWT_ClientSPSet_8720E(u8 clientnum, u32 TWTH, u32 TWTL);
-extern void LPS_ITWT_ClientSPEarlySet_8720E(u8 clientnum, u8 TWTEarly);
-extern void InitInactivePS_8720E(void);
-extern void InactivePSTBTTHDL_8720E(void);
-extern void InactivePSBCNAggEarlyHDL_8720E(void);
-extern void InactivePSEnableHEL_8720E(u8 op);
-extern void InitBcnEarlyAdjustStat_8720E(void);
-extern void BcnEarlyAdjustByDeltaTSFStat_8720E(void);
-extern void InitBcnEarlyAdjustPID_8720E(void);
-extern void BcnEarlyAdjustByDeltaTSFPID_8720E(void);
-extern void BcnEarlyADJSTSSearchBaseValue_8720E(void);
-extern void BcnEarlyADJSTSCheckBaseValue_8720E(void);
-extern void BcnEarlyADJPIDSearchBaseValue_8720E(void);
-extern void BcnEarlyADJPIDCheckBaseValue_8720E(void);
-extern void Set32KLpsOption_8720E(u32 *LpsControl, u8 CutPower);
-extern void CheckTrafficLeakage(void);
-
-#endif  //__WLAN_POWERSAVE_RAM_H__
diff --git a/os/board/rtl8720e/src/component/wifi/wifi_fw/amebalite/include/wififw_protocol_ram.h b/os/board/rtl8720e/src/component/wifi/wifi_fw/amebalite/include/wififw_protocol_ram.h
deleted file mode 100644
index 5d25c81ab..000000000
--- a/os/board/rtl8720e/src/component/wifi/wifi_fw/amebalite/include/wififw_protocol_ram.h
+++ /dev/null
@@ -1,268 +0,0 @@
-#ifndef _WIFI_PROTOCOL_RAM_H_
-#define _WIFI_PROTOCOL_RAM_H_
-
-#define LENGTH_IEEE80211_HDR_3ADDR  24
-#define _FIX_IE_LENGTH_             12
-#define WLAN_HDR_A3_QOS_LEN         26
-#define WLAN_LLC_HEADER_SIZE        6
-
-#define _ASOCREQ_IE_OFFSET_         4   // excluding wlan_hdr
-#define _ASOCRSP_IE_OFFSET_         6
-#define _REASOCREQ_IE_OFFSET_       10
-#define _REASOCRSP_IE_OFFSET_       6
-#define _PROBEREQ_IE_OFFSET_        0
-#define _PROBERSP_IE_OFFSET_        12
-#define _AUTH_IE_OFFSET_            6
-#define _DEAUTH_IE_OFFSET_          0
-#define _BEACON_IE_OFFSET_          12
-
-#define _SSID_IE_                   0
-#define _SUPPORTEDRATES_IE_         1
-#define _DSSET_IE_                  3
-#define _TIM_IE_                    5
-#define _IBSS_PARA_IE_              6
-#define _COUNTRY_IE_                7
-#define _QBSSLOAD_IE_               11
-#define _EDCASETS_IE_               12
-#define _TS_IE_                     13
-#define _TCLASS_IE_                 14
-#define _SCHEDULE_IE_               15
-#define _TSDELAY_IE_                43
-#define _TCLASSPROCESSING_IE_       44
-#define _QOS_CAPABILITY_IE_         46
-
-#define _CHLGETXT_IE_               16
-#define _RSN_IE_2_                  48
-#define _ERPINFO_IE_                42
-#define _EXT_SUPPORTEDRATES_IE_     50
-#define _RSN_IE_1_                  221
-#define _RESERVED47_                47
-#define _HT_CAPS_IE_                45
-#define _HT_INFO_IE_                61
-#define _HT_BSSCOEXIT_IE_           72  // 20/40 BSS Coexistence
-#define _HT_40INTOLERANT_IE_        73
-#define _HT_OBSS_SCAN_IE_           74  // Overlapping BSS Scan Parameters
-#define _HT_EXTCAP_IE_              127
-
-/*  below is MAC Header offset */
-#define MAC_ADRESS1_OFFSET  4
-#define MAC_ADRESS2_OFFSET 10
-#define MAC_ADRESS3_OFFSET 16
-#define MAC_SEQ_OFFSET         22
-#define ETH_ALEN           6
-#define IPv4_ALEN          4
-
-/* below is IPv4 header offset */
-#define IP_VERSION_IHL 1
-#define TOS            1
-#define IP_LENGTH      2
-#define IPID           2
-#define FLAG_OFFSET    2
-#define TTL            1
-#define PROTOCOL       1
-#define IPCHECKSUM     2
-#define IP_ID_OFFSET   4
-#define IP_CHECKSUM_OFFSET  10
-#define IP_SRC_ADDR_OFFSET  12
-#define IP_DES_ADDR_OFFSET  16
-#define IP_HEADER      20
-
-/*  below is LLC offset */
-#define LLC_LEN        8
-
-/**
- *  @brief  REASON CODE
- *  16 bit field, See textbook Table.4-5.
- */
-enum WIFI_REASON_CODE   {
-	_RSON_RESERVED_                 = 0,    // Reserved.
-	_RSON_UNSPECIFIED_              = 1,    // Unspecified.
-	_RSON_AUTH_NO_LONGER_VALID_     = 2,    // Auth invalid.
-	_RSON_DEAUTH_STA_LEAVING_       = 3,    // STA leave BSS or ESS, DeAuth.
-	_RSON_INACTIVITY_               = 4,    // Exceed idle timer, Disconnect.
-	_RSON_UNABLE_HANDLE_            = 5,    // BS resoruce insufficient.
-	_RSON_CLS2_                     = 6,    // UnAuth STA frame or SubType incorrect.
-	_RSON_CLS3_                     = 7,    // UnAuth STA frame or SubType incorrect.
-	_RSON_DISAOC_STA_LEAVING_       = 8,    // STA leave BSS or ESS, DeAssoc.
-	_RSON_ASOC_NOT_AUTH_            = 9,    // Request assiciate or reassociate, before authenticate
-	// 10,11,12 for 802.11h
-	// WPA reason
-	_RSON_INVALID_IE_               = 13,
-	_RSON_MIC_FAILURE_              = 14,
-	_RSON_4WAY_HNDSHK_TIMEOUT_      = 15,
-	_RSON_GROUP_KEY_UPDATE_TIMEOUT_ = 16,
-	_RSON_DIFF_IE_                  = 17,
-	_RSON_MLTCST_CIPHER_NOT_VALID_  = 18,
-	_RSON_UNICST_CIPHER_NOT_VALID_  = 19,
-	_RSON_AKMP_NOT_VALID_           = 20,
-	_RSON_UNSUPPORT_RSNE_VER_       = 21,
-	_RSON_INVALID_RSNE_CAP_         = 22,
-	_RSON_IEEE_802DOT1X_AUTH_FAIL_  = 23,
-
-	//belowing are Realtek definition
-	_RSON_PMK_NOT_AVAILABLE_        = 24,
-
-	_RSON_USK_HANDSHAKE_TIMEOUT_    = 25,   /* handshake timeout for unicast session key*/
-	_RSON_MSK_HANDSHAKE_TIMEOUT_    = 26,   /* handshake timeout for multicast session key*/
-	_RSON_IE_NOT_CONSISTENT_            = 27,   /* IE was different between USK handshake & assocReq/probeReq/Beacon */
-	_RSON_INVALID_USK_              = 28,   /* Invalid unicast key set */
-	_RSON_INVALID_MSK_              = 29,   /* Invalid multicast key set */
-	_RSON_INVALID_WAPI_VERSION_     = 30,   /* Invalid wapi version */
-	_RSON_INVALID_WAPI_CAPABILITY_  = 31,   /* Wapi capability not support */
-
-};
-
-enum WIFI_STATUS_CODE {
-	_STATS_SUCCESSFUL_              = 0,    // Success.
-	_STATS_FAILURE_                 = 1,    // Failure.
-	_STATS_CAP_FAIL_                = 10,   // Capability too wide, can't support
-	_STATS_NO_ASOC_                 = 11,   // Denial reassociate
-	_STATS_OTHER_                   = 12,   // Denial connect, not 802.11 standard.
-	_STATS_NO_SUPP_ALG_             = 13,   // Authenticate algorithm not support .
-	_STATS_OUT_OF_AUTH_SEQ_         = 14,   // Out of authenticate sequence number.
-	_STATS_CHALLENGE_FAIL_          = 15,   // Denial authenticate, Response message fail.
-	_STATS_AUTH_TIMEOUT_            = 16,   // Denial authenticate, timeout.
-	_STATS_UNABLE_HANDLE_STA_       = 17,   // Denial authenticate, BS resoruce insufficient.
-	_STATS_RATE_FAIL_               = 18,   // Denial authenticate, STA not support BSS request datarate.
-	_STATS_REQ_DECLINED_        = 37,
-
-	__STATS_INVALID_IE_ = 40,
-	__STATS_INVALID_AKMP_ = 43,
-	__STATS_CIPER_REJECT_ = 46,
-	__STATS_INVALID_USK_ = 47,
-	__STATS_INVALID_MSK_ = 48,
-	__STATS_INVALID_WAPI_VERSION_ = 49,
-	__STATS_INVALID_WAPI_CAPABILITY_ = 50,
-
-};
-
-/* ---------------------------------------------------------------------------
-                    Below is the fixed elements...
------------------------------------------------------------------------------*/
-#define _AUTH_ALGM_NUM_         2
-#define _AUTH_SEQ_NUM_          2
-#define _BEACON_ITERVAL_        2
-#define _CAPABILITY_            2
-#define _CURRENT_APADDR_        6
-#define _LISTEN_INTERVAL_       2
-#define _RSON_CODE_             2
-#define _ASOC_ID_               2
-#define _STATUS_CODE_           2
-#define _TIMESTAMP_             8
-
-#define AUTH_ODD_TO             0
-#define AUTH_EVEN_TO            1
-
-#define WLAN_ETHCONV_ENCAP      1
-#define WLAN_ETHCONV_RFC1042    2
-#define WLAN_ETHCONV_8021h      3
-
-/*-----------------------------------------------------------------------------
-                Below is the definition for 802.11i / 802.1x
-------------------------------------------------------------------------------*/
-#define _IEEE8021X_MGT_         1       // WPA
-#define _IEEE8021X_PSK_         2       // WPA with pre-shared key
-
-#define _NO_PRIVACY_            0
-#define _WEP_40_PRIVACY_        1
-#define _TKIP_PRIVACY_          2
-#define _WRAP_PRIVACY_          3
-#define _CCMP_PRIVACY_          4
-#define _WEP_104_PRIVACY_       5
-#define _WEP_WPA_MIXED_PRIVACY_ 6   // WEP + WPA
-#define _WAPI_SMS4_             7
-
-/*-----------------------------------------------------------------------------
-            Below is for QoS related definition
-------------------------------------------------------------------------------*/
-#define _WMM_IE_Length_             7
-#define _WMM_Para_Element_Length_   24
-#define _ADDBA_Req_Frame_Length_    9
-#define _ADDBA_Rsp_Frame_Length_    9
-#define _DELBA_Frame_Length         6
-#define _ADDBA_Maximum_Buffer_Size_ 64
-
-#define _BLOCK_ACK_CATEGORY_ID_     3
-#define _ADDBA_Req_ACTION_ID_       0
-#define _ADDBA_Rsp_ACTION_ID_       1
-#define _DELBA_ACTION_ID_           2
-
-/*-----------------------------------------------------------------------------
-            Below is for HT related definition
-------------------------------------------------------------------------------*/
-#define _HT_CAP_                    45
-#define _HT_IE_                     61
-
-#define _HT_MIMO_PS_STATIC_         BIT(0)
-#define _HT_MIMO_PS_DYNAMIC_        BIT(1)
-
-#define _HT_MIMO_PS_Frame_Length_   3
-
-#ifdef WIFI_11N_2040_COEXIST
-#define _PUBLIC_CATEGORY_ID_        4
-#define _2040_COEXIST_ACTION_ID_    0
-
-#define _2040_BSS_COEXIST_IE_       72
-#define _40M_INTOLERANT_            BIT(1)
-#define _20M_BSS_WIDTH_REQ_     BIT(2)
-
-#define _2040_Intolerant_ChRpt_IE_  73
-#define _OBSS_SCAN_PARA_IE_     74
-
-#define _EXTENDED_CAP_IE_           127
-#define _2040_COEXIST_SUPPORT_  BIT(0)
-#endif
-#define _HT_CATEGORY_ID_            7
-#define _HT_MIMO_PS_ACTION_ID_      1
-
-/*-----------------------------------------------------------------------------
-            Below is the bit definition for HT Capabilities element
-------------------------------------------------------------------------------*/
-#define _HTCAP_SUPPORT_CH_WDTH_     BIT(1)
-#define _HTCAP_SMPWR_STATIC_        0
-#define _HTCAP_SMPWR_DYNAMIC_       BIT(2)
-#define _HTCAP_STATIC_SMPWR_        0
-#define _HTCAP_SMPWR_DISABLE_       (BIT(2) | BIT(3))
-#define _HTCAP_SHORTGI_20M_         BIT(5)
-#define _HTCAP_SHORTGI_40M_         BIT(6)
-#define _HTCAP_TX_STBC_             BIT(7)
-#define _HTCAP_RX_STBC_1S_          BIT(8)
-#define _HTCAP_RX_STBC_2S_          BIT(9)
-#define _HTCAP_RX_STBC_3S_          (BIT(8) | BIT(9))
-#define _HTCAP_RX_STBC_CAP_         (BIT(8) | BIT(9))
-#define _HTCAP_AMSDU_LEN_8K_        BIT(11)
-#define _HTCAP_CCK_IN_40M_          BIT(12)
-#ifdef WIFI_11N_2040_COEXIST
-#define _HTCAP_40M_INTOLERANT_      BIT(14)
-#endif
-#define _HTCAP_AMPDU_FAC_8K_        0
-#define _HTCAP_AMPDU_FAC_16K_       BIT(0)
-#define _HTCAP_AMPDU_FAC_32K_       BIT(1)
-#define _HTCAP_AMPDU_FAC_64K_       (BIT(0) | BIT(1))
-#define _HTCAP_AMPDU_SPC_SHIFT_     2
-#define _HTCAP_AMPDU_SPC_MASK_      0x1c
-#define _HTCAP_AMPDU_SPC_NORES_     0
-#define _HTCAP_AMPDU_SPC_QUAR_US_   1
-#define _HTCAP_AMPDU_SPC_HALF_US_   2
-#define _HTCAP_AMPDU_SPC_1_US_      3
-#define _HTCAP_AMPDU_SPC_2_US_      4
-#define _HTCAP_AMPDU_SPC_4_US_      5
-#define _HTCAP_AMPDU_SPC_8_US_      6
-#define _HTCAP_AMPDU_SPC_16_US_     7
-
-/*-----------------------------------------------------------------------------
-            Below is the bit definition for HT Information element
-------------------------------------------------------------------------------*/
-#define _HTIE_2NDCH_OFFSET_NO_      0
-#define _HTIE_2NDCH_OFFSET_AB_      BIT(0)
-#define _HTIE_2NDCH_OFFSET_BL_      (BIT(0) | BIT(1))
-#define _HTIE_STA_CH_WDTH_          BIT(2)
-#define _HTIE_OP_MODE0_             0
-#define _HTIE_OP_MODE1_             BIT(0)
-#define _HTIE_OP_MODE2_             BIT(1)
-#define _HTIE_OP_MODE3_             (BIT(0) | BIT(1))
-#define _HTIE_NGF_STA_              BIT(2)
-#define _HTIE_TXBURST_LIMIT_        BIT(3)
-#define _HTIE_OBSS_NHT_STA_         BIT(4)
-
-#endif  /* _WIFI_H_ */
diff --git a/os/board/rtl8720e/src/component/wifi/wifi_fw/amebalite/include/wififw_rate_adaptive_ram.h b/os/board/rtl8720e/src/component/wifi/wifi_fw/amebalite/include/wififw_rate_adaptive_ram.h
deleted file mode 100644
index b842c79d3..000000000
--- a/os/board/rtl8720e/src/component/wifi/wifi_fw/amebalite/include/wififw_rate_adaptive_ram.h
+++ /dev/null
@@ -1,1052 +0,0 @@
-
-#ifndef __WIFIFW_RATE_ADAPTIVE_RAM__
-#define __WIFIFW_RATE_ADAPTIVE_RAM__
-
-#if CONFIG_RATE_ADAPTIVE
-
-
-//#define RA_TIMER_PERIOD 100 // 100 milli-second
-//#define nonMU_MACIDNUM 128
-//#define nonRU_MACIDNUM nonMU_MACIDNUM+30
-
-
-#define BW20M   0x0
-#define BW40M   0x100
-#define BW80M   0x200
-#define BW160M  0x300
-
-#define START_RATE_RSSI_LV1 55
-#define START_RATE_RSSI_LV2 35
-#define START_RATE_RSSI_LV3 20
-
-#define HE_RA_MASK_DWORD_OFFSET_0 0x8
-#define HE_RA_MASK_DWORD_OFFSET_1 0xC
-
-#define VHT_RA_MASK_DWORD_OFFSET_0 0x0
-#define VHT_RA_MASK_DWORD_OFFSET_1 0x4
-
-#define SGI_PENDING_CNT 3
-
-#define MU_SU_rate_diff_TH 2
-
-// decision offset timer mechanism
-#define DECISION_OFFSET_CNT 20
-
-#define PHYSTS_TYPE_NUM 32
-
-#define CONFIG_RA_DBG_LOG       0
-#if CONFIG_RA_DBG_LOG
-#define DBG_RA_LOG   DBG_8195A
-#else
-#define DBG_RA_LOG(...)
-#endif
-
-#define RA_Pending_Code 	0
-/*@--------------------------[Enum]------------------------------------------*/
-
-
-
-enum DECISION_OFFSET_STATE {
-	D_O_INIT = 0, //init and not lowest rate => ready to rate_down
-	D_O_RATE_DOWN_UPDATE = 1, //timer=0 => ready to rate_down
-	D_O_RATE_RESTORE = 2, // already rate_down => rate_restore, timer=default
-	D_O_COUNTING_DOWN = 3, // env is noisy => timer--
-	D_O_FORCE_UPDATE = 4 // env is clean || lowest_rate => update d_o, timer=default
-};
-
-/**
- * @enum ASSOC_MD
- *
- * @brief ASSOC_MD
- *
- * @var ASSOC_MD::TYPE_CCK
- * Please Place Description here.
- * @var ASSOC_MD::TYPE_LEGOFDM
- * Please Place Description here.
- * @var ASSOC_MD::TYPE_HT
- * Please Place Description here.
- * @var ASSOC_MD::TYPE_VHT
- * Please Place Description here.
- * @var ASSOC_MD::TYPE_HE
- * Please Place Description here.
- */
-enum ASSOC_MD {
-	TYPE_CCK             = BIT0,
-	TYPE_LEGOFDM            = BIT1,
-	TYPE_HT           = BIT2,
-	TYPE_VHT           = BIT3,
-	TYPE_HE           = BIT4
-};
-
-#if 0
-enum ENABLE_MODE {
-	TYPE_EN_CCK  = 0x1,
-	TYPE_EN_OFDM = 0x2,
-	TYPE_EN_HT = 0x4,
-	TYPE_EN_VHT = 0x8,
-	TYPE_EN_HE = 0x16,
-
-};
-#else
-
-/**
- * @enum ENABLE_MODE
- *
- * @brief ENABLE_MODE
- *
- * @var ENABLE_MODE::TYPE_EN_CCK
- * Please Place Description here.
- * @var ENABLE_MODE::TYPE_EN_OFDM
- * Please Place Description here.
- * @var ENABLE_MODE::TYPE_EN_HT
- * Please Place Description here.
- * @var ENABLE_MODE::TYPE_EN_VHT
- * Please Place Description here.
- * @var ENABLE_MODE::TYPE_EN_HE
- * Please Place Description here.
- */
-enum ENABLE_MODE {
-	TYPE_EN_CCK  = 0x1,
-	TYPE_EN_OFDM = 0x2,
-	TYPE_EN_HT = 0x4,
-	TYPE_EN_VHT = 0x8,
-	TYPE_EN_HE = 0x10,
-
-};
-#endif
-
-
-/**
- * @enum MASK_MD
- *
- * @brief MASK_MD
- *
- * @var MASK_MD::TYPE_MASK_CCK
- * Please Place Description here.
- * @var MASK_MD::TYPE_MASK_LEGOFDM
- * Please Place Description here.
- * @var MASK_MD::TYPE_MASK_HT
- * Please Place Description here.
- * @var MASK_MD::TYPE_MASK_VHT
- * Please Place Description here.
- * @var MASK_MD::TYPE_MASK_HE
- * Please Place Description here.
- */
-enum MASK_MD {
-	TYPE_MASK_CCK   = 0xf,
-	TYPE_MASK_LEGOFDM   = 0xff0,
-	TYPE_MASK_HT    = 0x00ff0ff0ff0ff000,
-	TYPE_MASK_VHT   = 0x03ff3ff3ff3ff000,
-	TYPE_MASK_HE   = 0x0ffffffffffff000
-};
-
-
-/**
- * @enum MASK_SS
- *
- * @brief MASK_SS
- *
- * @var MASK_SS::TYPE_MASK_1SS
- * Please Place Description here.
- * @var MASK_SS::TYPE_MASK_2SS
- * Please Place Description here.
- * @var MASK_SS::TYPE_MASK_3SS
- * Please Place Description here.
- * @var MASK_SS::TYPE_MASK_4SS
- * Please Place Description here.
- */
-enum MASK_SS {
-	TYPE_MASK_1SS   = 0xffffff,
-	TYPE_MASK_2SS   = 0x0000000fffffffff,
-	TYPE_MASK_3SS    = 0x0000ffffffffffff,
-	TYPE_MASK_4SS   = 0x0fffffffffffffff
-};
-
-
-/**
- * @enum MAX_SS
- *
- * @brief MAX_SS
- *
- * @var MAX_SS::TYPE_1SS
- * Please Place Description here.
- * @var MAX_SS::TYPE_2SS
- * Please Place Description here.
- * @var MAX_SS::TYPE_3SS
- * Please Place Description here.
- * @var MAX_SS::TYPE_4SS
- * Please Place Description here.
- */
-enum MAX_SS {
-	TYPE_1SS   = 0,
-	TYPE_2SS   = 1,
-	TYPE_3SS    = 2,
-	TYPE_4SS   = 3
-};
-
-
-/**
- * @enum WIFI_MODE
- *
- * @brief WIFI_MODE
- *
- * @var WIFI_MODE::TYPE_B
- * Please Place Description here.
- * @var WIFI_MODE::TYPE_AG
- * Please Place Description here.
- * @var WIFI_MODE::TYPE_BG
- * Please Place Description here.
- * @var WIFI_MODE::TYPE_N
- * Please Place Description here.
- * @var WIFI_MODE::TYPE_BN
- * Please Place Description here.
- * @var WIFI_MODE::TYPE_GN
- * Please Place Description here.
- * @var WIFI_MODE::TYPE_BGN
- * Please Place Description here.
- * @var WIFI_MODE::TYPE_AC
- * Please Place Description here.
- * @var WIFI_MODE::TYPE_5G_AC
- * Please Place Description here.
- * @var WIFI_MODE::TYPE_2G_AC
- * Please Place Description here.
- * @var WIFI_MODE::TYPE_5G_AX
- * Please Place Description here.
- * @var WIFI_MODE::TYPE_2G_AX
- * Please Place Description here.
- */
-enum WIFI_MODE {
-	TYPE_B   = 1,
-	TYPE_AG   = 2,
-	TYPE_BG    = 3,
-	TYPE_N   = 4,
-	TYPE_BN     = 5,
-	TYPE_GN     = 6,
-	TYPE_BGN    = 7,
-	TYPE_AC     = 8,
-	TYPE_5G_AC   = 10,
-	TYPE_2G_AC  = 11,
-	TYPE_5G_AX  = 18,
-	TYPE_2G_AX  = 19
-};
-
-/*typedef enum _VHT_HT_SWITCH_ {
-    TYPE_HT             = 0,
-    TYPE_VHT            = 1,
-    TYPE_MIX1           = 2,
-    TYPE_MIX2           = 3
-} VHT_SEL_SWITCH, *PVHT_SEL_SWITCH;*/
-
-
-/**
- * @enum _BW_TYPE_
- *
- * @brief _BW_TYPE_
- *
- * @var _BW_TYPE_::TYPE_BW_20M
- * Please Place Description here.
- * @var _BW_TYPE_::TYPE_BW_40M
- * Please Place Description here.
- * @var _BW_TYPE_::TYPE_BW_80M
- * Please Place Description here.
- * @var _BW_TYPE_::TYPE_BW_160M
- * Please Place Description here.
- */
-typedef enum _BW_TYPE_ {
-	TYPE_BW_20M         = 0,
-	TYPE_BW_40M         = 1,
-	TYPE_BW_80M         = 2,
-	TYPE_BW_160M        = 3
-} BW_TYPE, *PBW_TYPE;
-
-
-/**
- * @enum phydm_ctrl_info_rate
- *
- * @brief phydm_ctrl_info_rate
- *
- * @var phydm_ctrl_info_rate::ODM_RATE1M
- * Please Place Description here.
- * @var phydm_ctrl_info_rate::ODM_RATE2M
- * Please Place Description here.
- * @var phydm_ctrl_info_rate::ODM_RATE5_5M
- * Please Place Description here.
- * @var phydm_ctrl_info_rate::ODM_RATE11M
- * Please Place Description here.
- * @var phydm_ctrl_info_rate::ODM_RATE6M
- * Please Place Description here.
- * @var phydm_ctrl_info_rate::ODM_RATE9M
- * Please Place Description here.
- * @var phydm_ctrl_info_rate::ODM_RATE12M
- * Please Place Description here.
- * @var phydm_ctrl_info_rate::ODM_RATE18M
- * Please Place Description here.
- * @var phydm_ctrl_info_rate::ODM_RATE24M
- * Please Place Description here.
- * @var phydm_ctrl_info_rate::ODM_RATE36M
- * Please Place Description here.
- * @var phydm_ctrl_info_rate::ODM_RATE48M
- * Please Place Description here.
- * @var phydm_ctrl_info_rate::ODM_RATE54M
- * Please Place Description here.
- * @var phydm_ctrl_info_rate::ODM_RATEMCS0
- * Please Place Description here.
- * @var phydm_ctrl_info_rate::ODM_RATEMCS1
- * Please Place Description here.
- * @var phydm_ctrl_info_rate::ODM_RATEMCS2
- * Please Place Description here.
- * @var phydm_ctrl_info_rate::ODM_RATEMCS3
- * Please Place Description here.
- * @var phydm_ctrl_info_rate::ODM_RATEMCS4
- * Please Place Description here.
- * @var phydm_ctrl_info_rate::ODM_RATEMCS5
- * Please Place Description here.
- * @var phydm_ctrl_info_rate::ODM_RATEMCS6
- * Please Place Description here.
- * @var phydm_ctrl_info_rate::ODM_RATEMCS7
- * Please Place Description here.
- * @var phydm_ctrl_info_rate::ODM_RATEMCS8
- * Please Place Description here.
- * @var phydm_ctrl_info_rate::ODM_RATEMCS9
- * Please Place Description here.
- * @var phydm_ctrl_info_rate::ODM_RATEMCS10
- * Please Place Description here.
- * @var phydm_ctrl_info_rate::ODM_RATEMCS11
- * Please Place Description here.
- * @var phydm_ctrl_info_rate::ODM_RATEMCS12
- * Please Place Description here.
- * @var phydm_ctrl_info_rate::ODM_RATEMCS13
- * Please Place Description here.
- * @var phydm_ctrl_info_rate::ODM_RATEMCS14
- * Please Place Description here.
- * @var phydm_ctrl_info_rate::ODM_RATEMCS15
- * Please Place Description here.
- * @var phydm_ctrl_info_rate::ODM_RATEMCS16
- * Please Place Description here.
- * @var phydm_ctrl_info_rate::ODM_RATEMCS17
- * Please Place Description here.
- * @var phydm_ctrl_info_rate::ODM_RATEMCS18
- * Please Place Description here.
- * @var phydm_ctrl_info_rate::ODM_RATEMCS19
- * Please Place Description here.
- * @var phydm_ctrl_info_rate::ODM_RATEMCS20
- * Please Place Description here.
- * @var phydm_ctrl_info_rate::ODM_RATEMCS21
- * Please Place Description here.
- * @var phydm_ctrl_info_rate::ODM_RATEMCS22
- * Please Place Description here.
- * @var phydm_ctrl_info_rate::ODM_RATEMCS23
- * Please Place Description here.
- * @var phydm_ctrl_info_rate::ODM_RATEMCS24
- * Please Place Description here.
- * @var phydm_ctrl_info_rate::ODM_RATEMCS25
- * Please Place Description here.
- * @var phydm_ctrl_info_rate::ODM_RATEMCS26
- * Please Place Description here.
- * @var phydm_ctrl_info_rate::ODM_RATEMCS27
- * Please Place Description here.
- * @var phydm_ctrl_info_rate::ODM_RATEMCS28
- * Please Place Description here.
- * @var phydm_ctrl_info_rate::ODM_RATEMCS29
- * Please Place Description here.
- * @var phydm_ctrl_info_rate::ODM_RATEMCS30
- * Please Place Description here.
- * @var phydm_ctrl_info_rate::ODM_RATEMCS31
- * Please Place Description here.
- * @var phydm_ctrl_info_rate::ODM_RATEVHTSS1MCS0
- * Please Place Description here.
- * @var phydm_ctrl_info_rate::ODM_RATEVHTSS1MCS1
- * Please Place Description here.
- * @var phydm_ctrl_info_rate::ODM_RATEVHTSS1MCS2
- * Please Place Description here.
- * @var phydm_ctrl_info_rate::ODM_RATEVHTSS1MCS3
- * Please Place Description here.
- * @var phydm_ctrl_info_rate::ODM_RATEVHTSS1MCS4
- * Please Place Description here.
- * @var phydm_ctrl_info_rate::ODM_RATEVHTSS1MCS5
- * Please Place Description here.
- * @var phydm_ctrl_info_rate::ODM_RATEVHTSS1MCS6
- * Please Place Description here.
- * @var phydm_ctrl_info_rate::ODM_RATEVHTSS1MCS7
- * Please Place Description here.
- * @var phydm_ctrl_info_rate::ODM_RATEVHTSS1MCS8
- * Please Place Description here.
- * @var phydm_ctrl_info_rate::ODM_RATEVHTSS1MCS9
- * Please Place Description here.
- * @var phydm_ctrl_info_rate::ODM_RATEVHTSS2MCS0
- * Please Place Description here.
- * @var phydm_ctrl_info_rate::ODM_RATEVHTSS2MCS1
- * Please Place Description here.
- * @var phydm_ctrl_info_rate::ODM_RATEVHTSS2MCS2
- * Please Place Description here.
- * @var phydm_ctrl_info_rate::ODM_RATEVHTSS2MCS3
- * Please Place Description here.
- * @var phydm_ctrl_info_rate::ODM_RATEVHTSS2MCS4
- * Please Place Description here.
- * @var phydm_ctrl_info_rate::ODM_RATEVHTSS2MCS5
- * Please Place Description here.
- * @var phydm_ctrl_info_rate::ODM_RATEVHTSS2MCS6
- * Please Place Description here.
- * @var phydm_ctrl_info_rate::ODM_RATEVHTSS2MCS7
- * Please Place Description here.
- * @var phydm_ctrl_info_rate::ODM_RATEVHTSS2MCS8
- * Please Place Description here.
- * @var phydm_ctrl_info_rate::ODM_RATEVHTSS2MCS9
- * Please Place Description here.
- * @var phydm_ctrl_info_rate::ODM_RATEVHTSS3MCS0
- * Please Place Description here.
- * @var phydm_ctrl_info_rate::ODM_RATEVHTSS3MCS1
- * Please Place Description here.
- * @var phydm_ctrl_info_rate::ODM_RATEVHTSS3MCS2
- * Please Place Description here.
- * @var phydm_ctrl_info_rate::ODM_RATEVHTSS3MCS3
- * Please Place Description here.
- * @var phydm_ctrl_info_rate::ODM_RATEVHTSS3MCS4
- * Please Place Description here.
- * @var phydm_ctrl_info_rate::ODM_RATEVHTSS3MCS5
- * Please Place Description here.
- * @var phydm_ctrl_info_rate::ODM_RATEVHTSS3MCS6
- * Please Place Description here.
- * @var phydm_ctrl_info_rate::ODM_RATEVHTSS3MCS7
- * Please Place Description here.
- * @var phydm_ctrl_info_rate::ODM_RATEVHTSS3MCS8
- * Please Place Description here.
- * @var phydm_ctrl_info_rate::ODM_RATEVHTSS3MCS9
- * Please Place Description here.
- * @var phydm_ctrl_info_rate::ODM_RATEVHTSS4MCS0
- * Please Place Description here.
- * @var phydm_ctrl_info_rate::ODM_RATEVHTSS4MCS1
- * Please Place Description here.
- * @var phydm_ctrl_info_rate::ODM_RATEVHTSS4MCS2
- * Please Place Description here.
- * @var phydm_ctrl_info_rate::ODM_RATEVHTSS4MCS3
- * Please Place Description here.
- * @var phydm_ctrl_info_rate::ODM_RATEVHTSS4MCS4
- * Please Place Description here.
- * @var phydm_ctrl_info_rate::ODM_RATEVHTSS4MCS5
- * Please Place Description here.
- * @var phydm_ctrl_info_rate::ODM_RATEVHTSS4MCS6
- * Please Place Description here.
- * @var phydm_ctrl_info_rate::ODM_RATEVHTSS4MCS7
- * Please Place Description here.
- * @var phydm_ctrl_info_rate::ODM_RATEVHTSS4MCS8
- * Please Place Description here.
- * @var phydm_ctrl_info_rate::ODM_RATEVHTSS4MCS9
- * Please Place Description here.
- */
-enum phydm_ctrl_info_rate {
-	ODM_RATE1M      = 0x00,
-	ODM_RATE2M      = 0x01,
-	ODM_RATE5_5M        = 0x02,
-	ODM_RATE11M     = 0x03,
-	/* OFDM Rates, TxHT = 0 */
-	ODM_RATE6M      = 0x04,
-	ODM_RATE9M      = 0x05,
-	ODM_RATE12M     = 0x06,
-	ODM_RATE18M     = 0x07,
-	ODM_RATE24M     = 0x08,
-	ODM_RATE36M     = 0x09,
-	ODM_RATE48M     = 0x0A,
-	ODM_RATE54M     = 0x0B,
-	/* @MCS Rates, TxHT = 1 */
-	ODM_RATEMCS0        = 0x0C,
-	ODM_RATEMCS1        = 0x0D,
-	ODM_RATEMCS2        = 0x0E,
-	ODM_RATEMCS3        = 0x0F,
-	ODM_RATEMCS4        = 0x10,
-	ODM_RATEMCS5        = 0x11,
-	ODM_RATEMCS6        = 0x12,
-	ODM_RATEMCS7        = 0x13,
-	ODM_RATEMCS8        = 0x14,
-	ODM_RATEMCS9        = 0x15,
-	ODM_RATEMCS10       = 0x16,
-	ODM_RATEMCS11       = 0x17,
-	ODM_RATEMCS12       = 0x18,
-	ODM_RATEMCS13       = 0x19,
-	ODM_RATEMCS14       = 0x1A,
-	ODM_RATEMCS15       = 0x1B,
-	ODM_RATEMCS16       = 0x1C,
-	ODM_RATEMCS17       = 0x1D,
-	ODM_RATEMCS18       = 0x1E,
-	ODM_RATEMCS19       = 0x1F,
-	ODM_RATEMCS20       = 0x20,
-	ODM_RATEMCS21       = 0x21,
-	ODM_RATEMCS22       = 0x22,
-	ODM_RATEMCS23       = 0x23,
-	ODM_RATEMCS24       = 0x24,
-	ODM_RATEMCS25       = 0x25,
-	ODM_RATEMCS26       = 0x26,
-	ODM_RATEMCS27       = 0x27,
-	ODM_RATEMCS28       = 0x28,
-	ODM_RATEMCS29       = 0x29,
-	ODM_RATEMCS30       = 0x2A,
-	ODM_RATEMCS31       = 0x2B,
-	ODM_RATEVHTSS1MCS0  = 0x2C,
-	ODM_RATEVHTSS1MCS1  = 0x2D,
-	ODM_RATEVHTSS1MCS2  = 0x2E,
-	ODM_RATEVHTSS1MCS3  = 0x2F,
-	ODM_RATEVHTSS1MCS4  = 0x30,
-	ODM_RATEVHTSS1MCS5  = 0x31,
-	ODM_RATEVHTSS1MCS6  = 0x32,
-	ODM_RATEVHTSS1MCS7  = 0x33,
-	ODM_RATEVHTSS1MCS8  = 0x34,
-	ODM_RATEVHTSS1MCS9  = 0x35,
-	ODM_RATEVHTSS2MCS0  = 0x36,
-	ODM_RATEVHTSS2MCS1  = 0x37,
-	ODM_RATEVHTSS2MCS2  = 0x38,
-	ODM_RATEVHTSS2MCS3  = 0x39,
-	ODM_RATEVHTSS2MCS4  = 0x3A,
-	ODM_RATEVHTSS2MCS5  = 0x3B,
-	ODM_RATEVHTSS2MCS6  = 0x3C,
-	ODM_RATEVHTSS2MCS7  = 0x3D,
-	ODM_RATEVHTSS2MCS8  = 0x3E,
-	ODM_RATEVHTSS2MCS9  = 0x3F,
-	ODM_RATEVHTSS3MCS0  = 0x40,
-	ODM_RATEVHTSS3MCS1  = 0x41,
-	ODM_RATEVHTSS3MCS2  = 0x42,
-	ODM_RATEVHTSS3MCS3  = 0x43,
-	ODM_RATEVHTSS3MCS4  = 0x44,
-	ODM_RATEVHTSS3MCS5  = 0x45,
-	ODM_RATEVHTSS3MCS6  = 0x46,
-	ODM_RATEVHTSS3MCS7  = 0x47,
-	ODM_RATEVHTSS3MCS8  = 0x48,
-	ODM_RATEVHTSS3MCS9  = 0x49,
-	ODM_RATEVHTSS4MCS0  = 0x4A,
-	ODM_RATEVHTSS4MCS1  = 0x4B,
-	ODM_RATEVHTSS4MCS2  = 0x4C,
-	ODM_RATEVHTSS4MCS3  = 0x4D,
-	ODM_RATEVHTSS4MCS4  = 0x4E,
-	ODM_RATEVHTSS4MCS5  = 0x4F,
-	ODM_RATEVHTSS4MCS6  = 0x50,
-	ODM_RATEVHTSS4MCS7  = 0x51,
-	ODM_RATEVHTSS4MCS8  = 0x52,
-	ODM_RATEVHTSS4MCS9  = 0x53,
-};
-
-enum rtw_gi_ltf {
-	GILTF_LGI_4XHE32 = 0,
-	GILTF_SGI_4XHE08 = 1,
-	GILTF_2XHE16 = 2,
-	GILTF_2XHE08 = 3,
-	GILTF_1XHE16 = 4,
-	GILTF_1XHE08 = 5,
-	GILTF_MAX
-};
-
-enum  bb_opt_gi_ltf {
-	BB_OPT_GILTF_4XHE08 = 0,
-	BB_OPT_GILTF_1XHE08 = 1
-};
-
-
-
-
-// Ben add for code size reduction. 11AX is TBTT RA not pkt based
-//#define CONFIG_PKT_BASED_RA 0
-/**
- * @enum FWBB_DBG_COMP
- *
- * @brief FWBB_DBG_COMP
- *
- * @var FWBB_DBG_COMP::FWBBDBG_H2C
- * Please Place Description here.
- * @var FWBB_DBG_COMP::FWBBDBG_TRIG_TX
- * Please Place Description here.
- * @var FWBB_DBG_COMP::FWBBDBG_EDCCA
- * Please Place Description here.
- * @var FWBB_DBG_COMP::FWBBDBG_RA
- * Please Place Description here.
- * @var FWBB_DBG_COMP::FWBBDBG_RUA
- * Please Place Description here.
- * @var FWBB_DBG_COMP::FWBBDBG_ULPWR_CTRL
- * Please Place Description here.
- * @var FWBB_DBG_COMP::FWBBDBG_ULRA
- * Please Place Description here.
- */
-enum FWBB_DBG_COMP {
-	FWBBDBG_H2C = BIT0,
-	//==========RA==========//
-	FWBBDBG_RA = BIT1, // ra main debug log: rty ratio,
-	FWBBDBG_RA_SEARCH_RATE = BIT2,
-	FWBBDBG_RA_TXRPT = BIT4,
-	FWBBDBG_RA_TRY_RATE = BIT5,
-	FWBBDBG_MU = BIT6,
-	//====================//
-	FWBBDBG_MCC = BIT3,
-	FWBBDBG_HALBB = BIT8,
-	FWBBDBG_RUA = BIT16,
-	FWBBDBG_ULPWR_CTRL = BIT24,
-	FWBBDBG_ULRA = BIT25,
-	FWBBDBG_TRIG_TX = BIT26,
-	FWBBDBG_EDCCA = BIT27,
-};
-
-
-/**
- * @struct cctrl_info_dword_0
- * @brief cctrl_info_dword_0
- *
- * @var cctrl_info_dword_0::DATARATE
- * Please Place Description here.
- * @var cctrl_info_dword_0::rsvd0
- * Please Place Description here.
- * @var cctrl_info_dword_0::DATA_BW
- * Please Place Description here.
- * @var cctrl_info_dword_0::DATA_GI_LTF
- * Please Place Description here.
- * @var cctrl_info_dword_0::DARF_TC_index
- * Please Place Description here.
- * @var cctrl_info_dword_0::rsvd1
- * Please Place Description here.
- * @var cctrl_info_dword_0::TRYRATE
- * Please Place Description here.
- * @var cctrl_info_dword_0::rsvd2
- * Please Place Description here.
- */
-typedef struct cctrl_info_dword_0 {
-	//offset:0
-	u32 DATARATE: 9;
-	u32 DIS_SR: 1;
-	u32 DATA_BW: 2;
-	u32 GI_LTF: 3;
-	u32 DARF_TC_INDEX: 1;
-	u32 ARFR_CTRL: 4;
-	u32 rsvd0: 1;
-	u32 PROTECTION_EN: 1;
-	u32 RTS_EN: 1;
-	u32 CTS2SELF: 1;
-	u32 HW_RTS_EN: 1;
-	u32 rsvd1: 6;
-	u32 RTY_LOW_RATE_EN: 1;
-} CCTRL_INFO_DWORD0, *PCCTRL_INFO_DWORD0;
-
-
-/**
- * @struct ra_rate_tuple
- * @brief ra_rate_tuple
- *
- * @var ra_rate_tuple::bw_idx
- * Please Place Description here.
- * @var ra_rate_tuple::mode
- * Please Place Description here.
- * @var ra_rate_tuple::gi_ltf
- * Please Place Description here.
- * @var ra_rate_tuple::rsvd0
- * Please Place Description here.
- * @var ra_rate_tuple::rate_idx
- * Please Place Description here.
- */
-typedef struct ra_rate_tuple {
-	u8 bw_idx: 2;
-	u8 mode: 2;
-	u8 gi_ltf: 3;
-	u8 rsvd0: 1;
-	u8 rate_idx;
-} RA_RATE_T, *PRA_RATE_T;
-
-
-/**
- * @struct _ra_mask_he
- * @brief _ra_mask_he
- *
- * @var _ra_mask_he::cck
- * Please Place Description here.
- * @var _ra_mask_he::legacy_ofdm
- * Please Place Description here.
- * @var _ra_mask_he::he_1ss
- * Please Place Description here.
- * @var _ra_mask_he::he_2ss
- * Please Place Description here.
- * @var _ra_mask_he::he_3ss
- * Please Place Description here.
- * @var _ra_mask_he::he_4ss
- * Please Place Description here.
- * @var _ra_mask_he::rsvd
- * Please Place Description here.
- * @var _ra_mask_he::mode_ctrl
- * Please Place Description here.
- */
-typedef struct _ra_mask_he {
-	u64 cck: 4;
-	u64 legacy_ofdm: 8;
-	u64 he_1ss: 12;
-	u64 he_2ss: 12;
-	u64 he_3ss: 12;
-	u64 he_4ss: 12;
-	u64 rsvd: 2;
-	u64 mode_ctrl: 2;
-} RA_MASK_HE, *PRA_MASK_HE;
-
-
-/**
- * @struct _ra_mask_vht
- * @brief _ra_mask_vht
- *
- * @var _ra_mask_vht::cck
- * Please Place Description here.
- * @var _ra_mask_vht::legacy_ofdm
- * Please Place Description here.
- * @var _ra_mask_vht::vht_1ss
- * Please Place Description here.
- * @var _ra_mask_vht::rsvd0
- * Please Place Description here.
- * @var _ra_mask_vht::vht_2ss
- * Please Place Description here.
- * @var _ra_mask_vht::rsvd1
- * Please Place Description here.
- * @var _ra_mask_vht::vht_3ss
- * Please Place Description here.
- * @var _ra_mask_vht::rsvd2
- * Please Place Description here.
- * @var _ra_mask_vht::vht_4ss
- * Please Place Description here.
- * @var _ra_mask_vht::rsvd3
- * Please Place Description here.
- * @var _ra_mask_vht::mode_ctrl
- * Please Place Description here.
- */
-typedef struct _ra_mask_vht {
-	u64 cck: 4;
-	u64 legacy_ofdm: 8;
-	u64 vht_1ss: 10;
-	u64 rsvd0: 2;
-	u64 vht_2ss: 10;
-	u64 rsvd1: 2;
-	u64 vht_3ss: 10;
-	u64 rsvd2: 2;
-	u64 vht_4ss: 10;
-	u64 rsvd3: 4;
-	u64 mode_ctrl: 2;
-} RA_MASK_VHT, *PRA_MASK_VHT;
-
-
-/**
- * @struct _ra_mask_ht
- * @brief _ra_mask_ht
- *
- * @var _ra_mask_ht::cck
- * Please Place Description here.
- * @var _ra_mask_ht::legacy_ofdm
- * Please Place Description here.
- * @var _ra_mask_ht::ht_1
- * Please Place Description here.
- * @var _ra_mask_ht::rsvd0
- * Please Place Description here.
- * @var _ra_mask_ht::ht_2
- * Please Place Description here.
- * @var _ra_mask_ht::rsvd1
- * Please Place Description here.
- * @var _ra_mask_ht::ht_3
- * Please Place Description here.
- * @var _ra_mask_ht::rsvd2
- * Please Place Description here.
- * @var _ra_mask_ht::ht_4
- * Please Place Description here.
- * @var _ra_mask_ht::rsvd3
- * Please Place Description here.
- * @var _ra_mask_ht::mode_ctrl
- * Please Place Description here.
- */
-typedef struct _ra_mask_ht {
-	u64 cck: 4;
-	u64 legacy_ofdm: 8;
-	u64 ht_1: 8;
-	u64 rsvd0: 4;
-	u64 ht_2: 8;
-	u64 rsvd1: 4;
-	u64 ht_3: 8;
-	u64 rsvd2: 4;
-	u64 ht_4: 8;
-	u64 rsvd3: 6;
-	u64 mode_ctrl: 2;
-} RA_MASK_HT, *PRA_MASK_HT;
-
-
-/**
- * @struct _ra_c2h_rpt
- * @brief _ra_c2h_rpt
- *
- * @var _ra_c2h_rpt::rpt_macid
- * Please Place Description here.
- * @var _ra_c2h_rpt::retry_ratio
- * Please Place Description here.
- * @var _ra_c2h_rpt::rsvd0
- * Please Place Description here.
- * @var _ra_c2h_rpt::rpt_mcs_nss
- * Please Place Description here.
- * @var _ra_c2h_rpt::rsvd1
- * Please Place Description here.
- * @var _ra_c2h_rpt::rpt_md_sel
- * Please Place Description here.
- * @var _ra_c2h_rpt::rpt_gi_ltf
- * Please Place Description here.
- * @var _ra_c2h_rpt::rpt_bw
- * Please Place Description here.
- * @var _ra_c2h_rpt::rsvd2
- * Please Place Description here.
- * @var _ra_c2h_rpt::rsvd3
- * Please Place Description here.
- * @var _ra_c2h_rpt::rsvd4
- * Please Place Description here.
- */
-struct _ra_c2h_rpt {
-	u16 rpt_macid;
-	u8 retry_ratio;
-	u8 rsvd0;
-
-	u8 rpt_rate: 7;
-	u8 rsvd1: 1;
-
-	u8 rpt_md_sel: 2;
-	u8 rpt_gi_ltf: 3;
-	u8 rpt_bw: 2;
-	u8 rsvd2: 1;
-	u8 rsvd3;
-	u8 rsvd4;
-};
-
-typedef struct TPBASE_RA_PARM {
-	u8 high_cadidante_rate;
-	u8 low_cadidante_rate;
-	u8 badpcr_trystate_bitmap;//BIT0:low rate BIT1:high rate
-	u8 goodpcr_trystate_bitmap;//BIT0:high rate1 BIT1:high rate2
-	u8 base_rate;
-	u8 base_gi_ltf;
-	u32 BaseTP;
-	u32 CurrentTP;
-	u8  try_down_gi_ltf[3];
-	u8  try_up_gi_ltf[2];
-	u8 trydown_rateidxtable[3];
-	u8 tryup_rateidxtable[2];
-	u32 trydown_rateidxTPtable[3];
-	u32 tryup_rateidxTPtable[2];
-	u8 fewpacket_trydec_cnt;
-	u8 fewpacket_cnt;
-	u8 rateupkeepgiltf;
-	u8 rateupkeeprate;
-	u8 rateupkeepcnt;
-	u8 rateuplock;
-} TPBASE_RA_PARM, *PTPBASE_RA_PARM;
-
-
-/*--------------------Define MACRO--------------------------------------*/
-
-
-/**
- * @brief RATimerCallback
- *
- * @param xTimer
- * @return Please Place Description here.
- * @retval extern
- */
-
-extern void
-RateDecision(
-	void
-);
-
-
-
-
-/**
- * @brief write_rate_tab
- *
- * @param macid
- * @param prate_t
- * @param tryrate
- * @param darfc_index
- * @return Please Place Description here.
- * @retval extern
- */
-extern void
-write_rate_tab(
-	u8 macid,
-	PRA_RATE_T prate_t,
-	u8 tryrate,
-	u8 darfc_index
-);
-
-/**
- * @brief read_ctrl_info_rate
- *
- * @param macid
- * @return Please Place Description here.
- * @retval extern
- */
-
-extern RA_RATE_T
-read_ctrl_info_rate(
-	u8 macid
-);
-
-/**
- * @brief fw_fixed_ctrl_info_rate
- *
- * @param macid
- * @param fixed_gi_ltf
- * @param fixed_bw
- * @param fixed_mode
- * @param fixed_rate
- * @return Please Place Description here.
- * @retval extern
- */
-
-extern void
-fw_fixed_ctrl_info_rate(
-	u8 macid,
-	u8 fixed_gi_ltf,
-	u8 fixed_bw,
-	u8 fixed_mode,
-	u8 fixed_rate
-);
-
-/**
- * @brief Halbb_start_rate
- *
- * @param macid
- * @param start_rssi
- * @return Please Place Description here.
- * @retval extern
- */
-
-// ---- Main functions ----
-extern void
-Halbb_start_rate(
-	u8 macid,
-	u8 start_rssi
-);
-#if 0
-/**
- * @brief init_ra_rty_c2h
- *
- * @param void
- * @return Please Place Description here.
- * @retval extern
- */
-
-extern void
-init_ra_rty_c2h(
-	void
-);
-#endif
-/**
- * @brief init_ra_rpt
- *
- * @return Please Place Description here.
- * @retval extern
- */
-
-extern void
-init_ra_rpt(
-	u8 macid
-);
-
-/**
- * @brief Halbb_arfrrefresh
- *
- * @param macid
- * @param mask0
- * @param mask1
- * @return Please Place Description here.
- * @retval extern
- */
-
-//---------------------------------------------------------------------
-// ARFR
-//---------------------------------------------------------------------
-extern void
-Halbb_arfrrefresh(
-	u8 macid,
-	u32 mask0
-);
-
-
-/**
- * @brief get_tx_statistics
- *
- * @param *reportContent
- * @return Please Place Description here.
- * @retval extern
- */
-
-extern void
-get_tx_statistics(
-	u8 rpt_idx
-);
-
-//---------------------------------------------------------------------
-// Others
-//---------------------------------------------------------------------
-
-extern void
-rate_idx_to_mcs_ss(
-	u8 mode,
-	u8 rate_idx,
-	u8 *mcs,
-	u8 *ss //Nss minus one
-);
-
-extern void
-manual_adjust_ra_mask(
-	u8 rate_idx,
-	u8 mode,
-	u8 macid
-);
-
-extern u8
-mcs_ss_to_rate_idx(
-	u8 mode,
-	u8 mcs,
-	u8 ss //Nss minus one
-);
-
-//---------------------------------------------------------------------
-// Helper functions end
-//---------------------------------------------------------------------
-/**
- * @brief reset_ra_rpt_c2h
- *
- * @param macid
- * @return Please Place Description here.
- * @retval extern
- */
-
-extern void
-reset_ra_rpt_c2h(
-	u8 macid
-);
-
-/**
- * @brief reset_ra_rpt_try
- *
- * @param macid
- * @return Please Place Description here.
- * @retval extern
- */
-
-extern void
-reset_ra_rpt_normal(
-	u8 macid
-);
-
-/**
- * @brief reset_ra_rpt_try
- *
- * @param macid
- * @return Please Place Description here.
- * @retval extern
- */
-
-extern void
-reset_ra_rpt_try(
-	u8 macid
-);
-
-extern void
-InitRAInfo(
-	void
-);
-
-
-#endif
-#endif
diff --git a/os/board/rtl8720e/src/component/wifi/wifi_fw/amebalite/include/wififw_reg_mac_sram.h b/os/board/rtl8720e/src/component/wifi/wifi_fw/amebalite/include/wififw_reg_mac_sram.h
deleted file mode 100644
index ee6c71404..000000000
--- a/os/board/rtl8720e/src/component/wifi/wifi_fw/amebalite/include/wififw_reg_mac_sram.h
+++ /dev/null
@@ -1,591 +0,0 @@
-#ifndef _WIFIFW_REG_MAC_SRAM_H_
-#define _WIFIFW_REG_MAC_SRAM_H_
-
-/* AUTO_GEN_START */
-
-/**************************************************************************//**
- * @defgroup REG_KEYCAM0_ENTRYx
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_MASK_KEYCAM0_ENTRYx_ADDR0          ((u32)0x0000FFFF << 16)          /*!<R/W 0  address[15:0] */
-#define BIT_KEYCAM0_ENTRYx_ADDR0(x)            ((u32)(((x) & 0x0000FFFF) << 16))
-#define BIT_GET_KEYCAM0_ENTRYx_ADDR0(x)        ((u32)(((x >> 16) & 0x0000FFFF)))
-#define BIT_KEYCAM0_ENTRYx_VALID               ((u32)0x00000001 << 15)          /*!<R/W 0   */
-#define BIT_KEYCAM0_ENTRYx_EXTTYPE             ((u32)0x00000001 << 9)          /*!<R/W 0   */
-#define BIT_KEYCAM0_ENTRYx_REPEATER_MODE       ((u32)0x00000001 << 8)          /*!<R/W 0   */
-#define BIT_KEYCAM0_ENTRYx_MGNT                ((u32)0x00000001 << 7)          /*!<R/W 0   */
-#define BIT_KEYCAM0_ENTRYx_GRPKEY_BIT          ((u32)0x00000001 << 6)          /*!<R/W 0   */
-#define BIT_KEYCAM0_ENTRYx_MICKEY_BIT          ((u32)0x00000001 << 5)          /*!<R/W 0   */
-#define BIT_MASK_KEYCAM0_ENTRYx_TYPE           ((u32)0x00000007 << 2)          /*!<R/W 0   */
-#define BIT_KEYCAM0_ENTRYx_TYPE(x)             ((u32)(((x) & 0x00000007) << 2))
-#define BIT_GET_KEYCAM0_ENTRYx_TYPE(x)         ((u32)(((x >> 2) & 0x00000007)))
-#define BIT_MASK_KEYCAM0_ENTRYx_KEYID_BIT      ((u32)0x00000003 << 0)          /*!<R/W 0   */
-#define BIT_KEYCAM0_ENTRYx_KEYID_BIT(x)        ((u32)(((x) & 0x00000003) << 0))
-#define BIT_GET_KEYCAM0_ENTRYx_KEYID_BIT(x)    ((u32)(((x >> 0) & 0x00000003)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_KEYCAM1_ENTRYx
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_MASK_KEYCAM1_ENTRYx_ADDR1          ((u32)0xFFFFFFFF << 0)          /*!<R/W 0  address[47:16] */
-#define BIT_KEYCAM1_ENTRYx_ADDR1(x)            ((u32)(((x) & 0xFFFFFFFF) << 0))
-#define BIT_GET_KEYCAM1_ENTRYx_ADDR1(x)        ((u32)(((x >> 0) & 0xFFFFFFFF)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_KEYCAM2_ENTRYx
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_MASK_KEYCAM2_ENTRYx_KEY0           ((u32)0xFFFFFFFF << 0)          /*!<R/W 0  key[31:0] */
-#define BIT_KEYCAM2_ENTRYx_KEY0(x)             ((u32)(((x) & 0xFFFFFFFF) << 0))
-#define BIT_GET_KEYCAM2_ENTRYx_KEY0(x)         ((u32)(((x >> 0) & 0xFFFFFFFF)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_KEYCAM3_ENTRYx
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_MASK_KEYCAM3_ENTRYx_KEY1           ((u32)0xFFFFFFFF << 0)          /*!<R/W 0  key[63:32] */
-#define BIT_KEYCAM3_ENTRYx_KEY1(x)             ((u32)(((x) & 0xFFFFFFFF) << 0))
-#define BIT_GET_KEYCAM3_ENTRYx_KEY1(x)         ((u32)(((x >> 0) & 0xFFFFFFFF)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_KEYCAM4_ENTRYx
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_MASK_KEYCAM4_ENTRYx_KEY2           ((u32)0xFFFFFFFF << 0)          /*!<R/W 0  key[95:64] */
-#define BIT_KEYCAM4_ENTRYx_KEY2(x)             ((u32)(((x) & 0xFFFFFFFF) << 0))
-#define BIT_GET_KEYCAM4_ENTRYx_KEY2(x)         ((u32)(((x >> 0) & 0xFFFFFFFF)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_KEYCAM5_ENTRYx
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_MASK_KEYCAM5_ENTRYx_KEY3           ((u32)0xFFFFFFFF << 0)          /*!<R/W 0  key[127:96] */
-#define BIT_KEYCAM5_ENTRYx_KEY3(x)             ((u32)(((x) & 0xFFFFFFFF) << 0))
-#define BIT_GET_KEYCAM5_ENTRYx_KEY3(x)         ((u32)(((x >> 0) & 0xFFFFFFFF)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_KEYCAM6_ENTRYx
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_MASK_KEYCAM6_ENTRYx_MFB            ((u32)0x0000007F << 25)          /*!<R/W 0   */
-#define BIT_KEYCAM6_ENTRYx_MFB(x)              ((u32)(((x) & 0x0000007F) << 25))
-#define BIT_GET_KEYCAM6_ENTRYx_MFB(x)          ((u32)(((x >> 25) & 0x0000007F)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_BACAM0_ENTRYx
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_MASK_BACAM0_ENTRYx_INFO_TA0        ((u32)0xFFFFFFFF << 0)          /*!<R/W 0   */
-#define BIT_BACAM0_ENTRYx_INFO_TA0(x)          ((u32)(((x) & 0xFFFFFFFF) << 0))
-#define BIT_GET_BACAM0_ENTRYx_INFO_TA0(x)      ((u32)(((x >> 0) & 0xFFFFFFFF)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_BACAM1_ENTRYx
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_MASK_BACAM1_ENTRYx_INFO_SSN        ((u32)0x00000FFF << 20)          /*!<R/W 0   */
-#define BIT_BACAM1_ENTRYx_INFO_SSN(x)          ((u32)(((x) & 0x00000FFF) << 20))
-#define BIT_GET_BACAM1_ENTRYx_INFO_SSN(x)      ((u32)(((x >> 20) & 0x00000FFF)))
-#define BIT_MASK_BACAM1_ENTRYx_INFO_TID        ((u32)0x0000000F << 16)          /*!<R/W 0   */
-#define BIT_BACAM1_ENTRYx_INFO_TID(x)          ((u32)(((x) & 0x0000000F) << 16))
-#define BIT_GET_BACAM1_ENTRYx_INFO_TID(x)      ((u32)(((x >> 16) & 0x0000000F)))
-#define BIT_MASK_BACAM1_ENTRYx_INFO_TA1        ((u32)0x0000FFFF << 0)          /*!<R/W 0   */
-#define BIT_BACAM1_ENTRYx_INFO_TA1(x)          ((u32)(((x) & 0x0000FFFF) << 0))
-#define BIT_GET_BACAM1_ENTRYx_INFO_TA1(x)      ((u32)(((x >> 0) & 0x0000FFFF)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_BACAM2_ENTRYx
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_MASK_BACAM2_ENTRYx_BITMAP0         ((u32)0xFFFFFFFF << 0)          /*!<R/W 0   */
-#define BIT_BACAM2_ENTRYx_BITMAP0(x)           ((u32)(((x) & 0xFFFFFFFF) << 0))
-#define BIT_GET_BACAM2_ENTRYx_BITMAP0(x)       ((u32)(((x >> 0) & 0xFFFFFFFF)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_BACAM3_ENTRYx
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_MASK_BACAM3_ENTRYx_BITMAP1         ((u32)0xFFFFFFFF << 0)          /*!<R/W 0   */
-#define BIT_BACAM3_ENTRYx_BITMAP1(x)           ((u32)(((x) & 0xFFFFFFFF) << 0))
-#define BIT_GET_BACAM3_ENTRYx_BITMAP1(x)       ((u32)(((x >> 0) & 0xFFFFFFFF)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_MBIDCAM0_ENTRYx
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_MASK_MBIDCAM0_ENTRYx_BSSID_MACID0  ((u32)0xFFFFFFFF << 0)          /*!<R/W 0   */
-#define BIT_MBIDCAM0_ENTRYx_BSSID_MACID0(x)    ((u32)(((x) & 0xFFFFFFFF) << 0))
-#define BIT_GET_MBIDCAM0_ENTRYx_BSSID_MACID0(x) ((u32)(((x >> 0) & 0xFFFFFFFF)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_MBIDCAM1_ENTRYx
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_MBIDCAM1_ENTRYx_VALID              ((u32)0x00000001 << 23)          /*!<R/W 0   */
-#define BIT_MBIDCAM1_ENTRYx_LSIG_TXOP_EN       ((u32)0x00000001 << 17)          /*!<R/W 0   */
-#define BIT_MBIDCAM1_ENTRYx_DUA_CTS_EN         ((u32)0x00000001 << 16)          /*!<R/W 0   */
-#define BIT_MASK_MBIDCAM1_ENTRYx_BSSID_MACID1  ((u32)0x0000FFFF << 0)          /*!<R/W 0   */
-#define BIT_MBIDCAM1_ENTRYx_BSSID_MACID1(x)    ((u32)(((x) & 0x0000FFFF) << 0))
-#define BIT_GET_MBIDCAM1_ENTRYx_BSSID_MACID1(x) ((u32)(((x >> 0) & 0x0000FFFF)))
-/** @} */
-
-
-/*==========MAC_SRAM Register Address Definition==========*/
-#define REG_TXPKTBUF                                 0x20000
-#define REG_RXPKTBUF                                 0x30000
-#define REG_TXRPTBUF                                 0x40000
-#define REG_LLT                                      0x50000
-#define REG_KEYCAM0_ENTRY00                          0x50800
-#define REG_KEYCAM1_ENTRY00                          0x50804
-#define REG_KEYCAM2_ENTRY00                          0x50808
-#define REG_KEYCAM3_ENTRY00                          0x5080C
-#define REG_KEYCAM4_ENTRY00                          0x50810
-#define REG_KEYCAM5_ENTRY00                          0x50814
-#define REG_KEYCAM6_ENTRY00                          0x50818
-#define REG_KEYCAM7_ENTRY00                          0x5081C
-#define REG_KEYCAM0_ENTRY01                          0x50820
-#define REG_KEYCAM1_ENTRY01                          0x50824
-#define REG_KEYCAM2_ENTRY01                          0x50828
-#define REG_KEYCAM3_ENTRY01                          0x5082C
-#define REG_KEYCAM4_ENTRY01                          0x50830
-#define REG_KEYCAM5_ENTRY01                          0x50834
-#define REG_KEYCAM6_ENTRY01                          0x50838
-#define REG_KEYCAM7_ENTRY01                          0x5083C
-#define REG_KEYCAM0_ENTRY02                          0x50840
-#define REG_KEYCAM1_ENTRY02                          0x50844
-#define REG_KEYCAM2_ENTRY02                          0x50848
-#define REG_KEYCAM3_ENTRY02                          0x5084C
-#define REG_KEYCAM4_ENTRY02                          0x50850
-#define REG_KEYCAM5_ENTRY02                          0x50854
-#define REG_KEYCAM6_ENTRY02                          0x50858
-#define REG_KEYCAM7_ENTRY02                          0x5085C
-#define REG_KEYCAM0_ENTRY03                          0x50860
-#define REG_KEYCAM1_ENTRY03                          0x50864
-#define REG_KEYCAM2_ENTRY03                          0x50868
-#define REG_KEYCAM3_ENTRY03                          0x5086C
-#define REG_KEYCAM4_ENTRY03                          0x50870
-#define REG_KEYCAM5_ENTRY03                          0x50874
-#define REG_KEYCAM6_ENTRY03                          0x50878
-#define REG_KEYCAM7_ENTRY03                          0x5087C
-#define REG_KEYCAM0_ENTRY04                          0x50880
-#define REG_KEYCAM1_ENTRY04                          0x50884
-#define REG_KEYCAM2_ENTRY04                          0x50888
-#define REG_KEYCAM3_ENTRY04                          0x5088C
-#define REG_KEYCAM4_ENTRY04                          0x50890
-#define REG_KEYCAM5_ENTRY04                          0x50894
-#define REG_KEYCAM6_ENTRY04                          0x50898
-#define REG_KEYCAM7_ENTRY04                          0x5089C
-#define REG_KEYCAM0_ENTRY05                          0x508A0
-#define REG_KEYCAM1_ENTRY05                          0x508A4
-#define REG_KEYCAM2_ENTRY05                          0x508A8
-#define REG_KEYCAM3_ENTRY05                          0x508AC
-#define REG_KEYCAM4_ENTRY05                          0x508B0
-#define REG_KEYCAM5_ENTRY05                          0x508B4
-#define REG_KEYCAM6_ENTRY05                          0x508B8
-#define REG_KEYCAM7_ENTRY05                          0x508BC
-#define REG_KEYCAM0_ENTRY06                          0x508C0
-#define REG_KEYCAM1_ENTRY06                          0x508C4
-#define REG_KEYCAM2_ENTRY06                          0x508C8
-#define REG_KEYCAM3_ENTRY06                          0x508CC
-#define REG_KEYCAM4_ENTRY06                          0x508D0
-#define REG_KEYCAM5_ENTRY06                          0x508D4
-#define REG_KEYCAM6_ENTRY06                          0x508D8
-#define REG_KEYCAM7_ENTRY06                          0x508DC
-#define REG_KEYCAM0_ENTRY07                          0x508E0
-#define REG_KEYCAM1_ENTRY07                          0x508E4
-#define REG_KEYCAM2_ENTRY07                          0x508E8
-#define REG_KEYCAM3_ENTRY07                          0x508EC
-#define REG_KEYCAM4_ENTRY07                          0x508F0
-#define REG_KEYCAM5_ENTRY07                          0x508F4
-#define REG_KEYCAM6_ENTRY07                          0x508F8
-#define REG_KEYCAM7_ENTRY07                          0x508FC
-#define REG_KEYCAM0_ENTRY08                          0x50900
-#define REG_KEYCAM1_ENTRY08                          0x50904
-#define REG_KEYCAM2_ENTRY08                          0x50908
-#define REG_KEYCAM3_ENTRY08                          0x5090C
-#define REG_KEYCAM4_ENTRY08                          0x50910
-#define REG_KEYCAM5_ENTRY08                          0x50914
-#define REG_KEYCAM6_ENTRY08                          0x50918
-#define REG_KEYCAM7_ENTRY08                          0x5091C
-#define REG_KEYCAM0_ENTRY09                          0x50920
-#define REG_KEYCAM1_ENTRY09                          0x50924
-#define REG_KEYCAM2_ENTRY09                          0x50928
-#define REG_KEYCAM3_ENTRY09                          0x5092C
-#define REG_KEYCAM4_ENTRY09                          0x50930
-#define REG_KEYCAM5_ENTRY09                          0x50934
-#define REG_KEYCAM6_ENTRY09                          0x50938
-#define REG_KEYCAM7_ENTRY09                          0x5093C
-#define REG_KEYCAM0_ENTRY10                          0x50940
-#define REG_KEYCAM1_ENTRY10                          0x50944
-#define REG_KEYCAM2_ENTRY10                          0x50948
-#define REG_KEYCAM3_ENTRY10                          0x5094C
-#define REG_KEYCAM4_ENTRY10                          0x50950
-#define REG_KEYCAM5_ENTRY10                          0x50954
-#define REG_KEYCAM6_ENTRY10                          0x50958
-#define REG_KEYCAM7_ENTRY10                          0x5095C
-#define REG_KEYCAM0_ENTRY11                          0x50960
-#define REG_KEYCAM1_ENTRY11                          0x50964
-#define REG_KEYCAM2_ENTRY11                          0x50968
-#define REG_KEYCAM3_ENTRY11                          0x5096C
-#define REG_KEYCAM4_ENTRY11                          0x50970
-#define REG_KEYCAM5_ENTRY11                          0x50974
-#define REG_KEYCAM6_ENTRY11                          0x50978
-#define REG_KEYCAM7_ENTRY11                          0x5097C
-#define REG_KEYCAM0_ENTRY12                          0x50980
-#define REG_KEYCAM1_ENTRY12                          0x50984
-#define REG_KEYCAM2_ENTRY12                          0x50988
-#define REG_KEYCAM3_ENTRY12                          0x5098C
-#define REG_KEYCAM4_ENTRY12                          0x50990
-#define REG_KEYCAM5_ENTRY12                          0x50994
-#define REG_KEYCAM6_ENTRY12                          0x50998
-#define REG_KEYCAM7_ENTRY12                          0x5099C
-#define REG_KEYCAM0_ENTRY13                          0x509A0
-#define REG_KEYCAM1_ENTRY13                          0x509A4
-#define REG_KEYCAM2_ENTRY13                          0x509A8
-#define REG_KEYCAM3_ENTRY13                          0x509AC
-#define REG_KEYCAM4_ENTRY13                          0x509B0
-#define REG_KEYCAM5_ENTRY13                          0x509B4
-#define REG_KEYCAM6_ENTRY13                          0x509B8
-#define REG_KEYCAM7_ENTRY13                          0x509BC
-#define REG_KEYCAM0_ENTRY14                          0x509C0
-#define REG_KEYCAM1_ENTRY14                          0x509C4
-#define REG_KEYCAM2_ENTRY14                          0x509C8
-#define REG_KEYCAM3_ENTRY14                          0x509CC
-#define REG_KEYCAM4_ENTRY14                          0x509D0
-#define REG_KEYCAM5_ENTRY14                          0x509D4
-#define REG_KEYCAM6_ENTRY14                          0x509D8
-#define REG_KEYCAM7_ENTRY14                          0x509DC
-#define REG_KEYCAM0_ENTRY15                          0x509E0
-#define REG_KEYCAM1_ENTRY15                          0x509E4
-#define REG_KEYCAM2_ENTRY15                          0x509E8
-#define REG_KEYCAM3_ENTRY15                          0x509EC
-#define REG_KEYCAM4_ENTRY15                          0x509F0
-#define REG_KEYCAM5_ENTRY15                          0x509F4
-#define REG_KEYCAM6_ENTRY15                          0x509F8
-#define REG_KEYCAM7_ENTRY15                          0x509FC
-#define REG_KEYCAM0_ENTRY16                          0x50A00
-#define REG_KEYCAM1_ENTRY16                          0x50A04
-#define REG_KEYCAM2_ENTRY16                          0x50A08
-#define REG_KEYCAM3_ENTRY16                          0x50A0C
-#define REG_KEYCAM4_ENTRY16                          0x50A10
-#define REG_KEYCAM5_ENTRY16                          0x50A14
-#define REG_KEYCAM6_ENTRY16                          0x50A18
-#define REG_KEYCAM7_ENTRY16                          0x50A1C
-#define REG_KEYCAM0_ENTRY17                          0x50A20
-#define REG_KEYCAM1_ENTRY17                          0x50A24
-#define REG_KEYCAM2_ENTRY17                          0x50A28
-#define REG_KEYCAM3_ENTRY17                          0x50A2C
-#define REG_KEYCAM4_ENTRY17                          0x50A30
-#define REG_KEYCAM5_ENTRY17                          0x50A34
-#define REG_KEYCAM6_ENTRY17                          0x50A38
-#define REG_KEYCAM7_ENTRY17                          0x50A3C
-#define REG_KEYCAM0_ENTRY18                          0x50A40
-#define REG_KEYCAM1_ENTRY18                          0x50A44
-#define REG_KEYCAM2_ENTRY18                          0x50A48
-#define REG_KEYCAM3_ENTRY18                          0x50A4C
-#define REG_KEYCAM4_ENTRY18                          0x50A50
-#define REG_KEYCAM5_ENTRY18                          0x50A54
-#define REG_KEYCAM6_ENTRY18                          0x50A58
-#define REG_KEYCAM7_ENTRY18                          0x50A5C
-#define REG_KEYCAM0_ENTRY19                          0x50A60
-#define REG_KEYCAM1_ENTRY19                          0x50A64
-#define REG_KEYCAM2_ENTRY19                          0x50A68
-#define REG_KEYCAM3_ENTRY19                          0x50A6C
-#define REG_KEYCAM4_ENTRY19                          0x50A70
-#define REG_KEYCAM5_ENTRY19                          0x50A74
-#define REG_KEYCAM6_ENTRY19                          0x50A78
-#define REG_KEYCAM7_ENTRY19                          0x50A7C
-#define REG_KEYCAM0_ENTRY20                          0x50A80
-#define REG_KEYCAM1_ENTRY20                          0x50A84
-#define REG_KEYCAM2_ENTRY20                          0x50A88
-#define REG_KEYCAM3_ENTRY20                          0x50A8C
-#define REG_KEYCAM4_ENTRY20                          0x50A90
-#define REG_KEYCAM5_ENTRY20                          0x50A94
-#define REG_KEYCAM6_ENTRY20                          0x50A98
-#define REG_KEYCAM7_ENTRY20                          0x50A9C
-#define REG_KEYCAM0_ENTRY21                          0x50AA0
-#define REG_KEYCAM1_ENTRY21                          0x50AA4
-#define REG_KEYCAM2_ENTRY21                          0x50AA8
-#define REG_KEYCAM3_ENTRY21                          0x50AAC
-#define REG_KEYCAM4_ENTRY21                          0x50AB0
-#define REG_KEYCAM5_ENTRY21                          0x50AB4
-#define REG_KEYCAM6_ENTRY21                          0x50AB8
-#define REG_KEYCAM7_ENTRY21                          0x50ABC
-#define REG_KEYCAM0_ENTRY22                          0x50AC0
-#define REG_KEYCAM1_ENTRY22                          0x50AC4
-#define REG_KEYCAM2_ENTRY22                          0x50AC8
-#define REG_KEYCAM3_ENTRY22                          0x50ACC
-#define REG_KEYCAM4_ENTRY22                          0x50AD0
-#define REG_KEYCAM5_ENTRY22                          0x50AD4
-#define REG_KEYCAM6_ENTRY22                          0x50AD8
-#define REG_KEYCAM7_ENTRY22                          0x50ADC
-#define REG_KEYCAM0_ENTRY23                          0x50AE0
-#define REG_KEYCAM1_ENTRY23                          0x50AE4
-#define REG_KEYCAM2_ENTRY23                          0x50AE8
-#define REG_KEYCAM3_ENTRY23                          0x50AEC
-#define REG_KEYCAM4_ENTRY23                          0x50AF0
-#define REG_KEYCAM5_ENTRY23                          0x50AF4
-#define REG_KEYCAM6_ENTRY23                          0x50AF8
-#define REG_KEYCAM7_ENTRY23                          0x50AFC
-#define REG_KEYCAM0_ENTRY24                          0x50B00
-#define REG_KEYCAM1_ENTRY24                          0x50B04
-#define REG_KEYCAM2_ENTRY24                          0x50B08
-#define REG_KEYCAM3_ENTRY24                          0x50B0C
-#define REG_KEYCAM4_ENTRY24                          0x50B10
-#define REG_KEYCAM5_ENTRY24                          0x50B14
-#define REG_KEYCAM6_ENTRY24                          0x50B18
-#define REG_KEYCAM7_ENTRY24                          0x50B1C
-#define REG_KEYCAM0_ENTRY25                          0x50B20
-#define REG_KEYCAM1_ENTRY25                          0x50B24
-#define REG_KEYCAM2_ENTRY25                          0x50B28
-#define REG_KEYCAM3_ENTRY25                          0x50B2C
-#define REG_KEYCAM4_ENTRY25                          0x50B30
-#define REG_KEYCAM5_ENTRY25                          0x50B34
-#define REG_KEYCAM6_ENTRY25                          0x50B38
-#define REG_KEYCAM7_ENTRY25                          0x50B3C
-#define REG_KEYCAM0_ENTRY26                          0x50B40
-#define REG_KEYCAM1_ENTRY26                          0x50B44
-#define REG_KEYCAM2_ENTRY26                          0x50B48
-#define REG_KEYCAM3_ENTRY26                          0x50B4C
-#define REG_KEYCAM4_ENTRY26                          0x50B50
-#define REG_KEYCAM5_ENTRY26                          0x50B54
-#define REG_KEYCAM6_ENTRY26                          0x50B58
-#define REG_KEYCAM7_ENTRY26                          0x50B5C
-#define REG_KEYCAM0_ENTRY27                          0x50B60
-#define REG_KEYCAM1_ENTRY27                          0x50B64
-#define REG_KEYCAM2_ENTRY27                          0x50B68
-#define REG_KEYCAM3_ENTRY27                          0x50B6C
-#define REG_KEYCAM4_ENTRY27                          0x50B70
-#define REG_KEYCAM5_ENTRY27                          0x50B74
-#define REG_KEYCAM6_ENTRY27                          0x50B78
-#define REG_KEYCAM7_ENTRY27                          0x50B7C
-#define REG_KEYCAM0_ENTRY28                          0x50B80
-#define REG_KEYCAM1_ENTRY28                          0x50B84
-#define REG_KEYCAM2_ENTRY28                          0x50B88
-#define REG_KEYCAM3_ENTRY28                          0x50B8C
-#define REG_KEYCAM4_ENTRY28                          0x50B90
-#define REG_KEYCAM5_ENTRY28                          0x50B94
-#define REG_KEYCAM6_ENTRY28                          0x50B98
-#define REG_KEYCAM7_ENTRY28                          0x50B9C
-#define REG_KEYCAM0_ENTRY29                          0x50BA0
-#define REG_KEYCAM1_ENTRY29                          0x50BA4
-#define REG_KEYCAM2_ENTRY29                          0x50BA8
-#define REG_KEYCAM3_ENTRY29                          0x50BAC
-#define REG_KEYCAM4_ENTRY29                          0x50BB0
-#define REG_KEYCAM5_ENTRY29                          0x50BB4
-#define REG_KEYCAM6_ENTRY29                          0x50BB8
-#define REG_KEYCAM7_ENTRY29                          0x50BBC
-#define REG_KEYCAM0_ENTRY30                          0x50BC0
-#define REG_KEYCAM1_ENTRY30                          0x50BC4
-#define REG_KEYCAM2_ENTRY30                          0x50BC8
-#define REG_KEYCAM3_ENTRY30                          0x50BCC
-#define REG_KEYCAM4_ENTRY30                          0x50BD0
-#define REG_KEYCAM5_ENTRY30                          0x50BD4
-#define REG_KEYCAM6_ENTRY30                          0x50BD8
-#define REG_KEYCAM7_ENTRY30                          0x50BDC
-#define REG_KEYCAM0_ENTRY31                          0x50BE0
-#define REG_KEYCAM1_ENTRY31                          0x50BE4
-#define REG_KEYCAM2_ENTRY31                          0x50BE8
-#define REG_KEYCAM3_ENTRY31                          0x50BEC
-#define REG_KEYCAM4_ENTRY31                          0x50BF0
-#define REG_KEYCAM5_ENTRY31                          0x50BF4
-#define REG_KEYCAM6_ENTRY31                          0x50BF8
-#define REG_KEYCAM7_ENTRY31                          0x50BFC
-#define REG_BACAM0_ENTRY00                           0x51000
-#define REG_BACAM1_ENTRY00                           0x51004
-#define REG_BACAM2_ENTRY00                           0x51008
-#define REG_BACAM3_ENTRY00                           0x5100C
-#define REG_BACAM0_ENTRY01                           0x51010
-#define REG_BACAM1_ENTRY01                           0x51014
-#define REG_BACAM2_ENTRY01                           0x51018
-#define REG_BACAM3_ENTRY01                           0x5101C
-#define REG_BACAM0_ENTRY02                           0x51020
-#define REG_BACAM1_ENTRY02                           0x51024
-#define REG_BACAM2_ENTRY02                           0x51028
-#define REG_BACAM3_ENTRY02                           0x5102C
-#define REG_BACAM0_ENTRY03                           0x51030
-#define REG_BACAM1_ENTRY03                           0x51034
-#define REG_BACAM2_ENTRY03                           0x51038
-#define REG_BACAM3_ENTRY03                           0x5103C
-#define REG_BACAM0_ENTRY04                           0x51040
-#define REG_BACAM1_ENTRY04                           0x51044
-#define REG_BACAM2_ENTRY04                           0x51048
-#define REG_BACAM3_ENTRY04                           0x5104C
-#define REG_BACAM0_ENTRY05                           0x51050
-#define REG_BACAM1_ENTRY05                           0x51054
-#define REG_BACAM2_ENTRY05                           0x51058
-#define REG_BACAM3_ENTRY05                           0x5105C
-#define REG_BACAM0_ENTRY06                           0x51060
-#define REG_BACAM1_ENTRY06                           0x51064
-#define REG_BACAM2_ENTRY06                           0x51068
-#define REG_BACAM3_ENTRY06                           0x5106C
-#define REG_BACAM0_ENTRY07                           0x51070
-#define REG_BACAM1_ENTRY07                           0x51074
-#define REG_BACAM2_ENTRY07                           0x51078
-#define REG_BACAM3_ENTRY07                           0x5107C
-#define REG_BACAM0_ENTRY08                           0x51080
-#define REG_BACAM1_ENTRY08                           0x51084
-#define REG_BACAM2_ENTRY08                           0x51088
-#define REG_BACAM3_ENTRY08                           0x5108C
-#define REG_BACAM0_ENTRY09                           0x51090
-#define REG_BACAM1_ENTRY09                           0x51094
-#define REG_BACAM2_ENTRY09                           0x51098
-#define REG_BACAM3_ENTRY09                           0x5109C
-#define REG_BACAM0_ENTRY10                           0x510A0
-#define REG_BACAM1_ENTRY10                           0x510A4
-#define REG_BACAM2_ENTRY10                           0x510A8
-#define REG_BACAM3_ENTRY10                           0x510AC
-#define REG_BACAM0_ENTRY11                           0x510B0
-#define REG_BACAM1_ENTRY11                           0x510B4
-#define REG_BACAM2_ENTRY11                           0x510B8
-#define REG_BACAM3_ENTRY11                           0x510BC
-#define REG_BACAM0_ENTRY12                           0x510C0
-#define REG_BACAM1_ENTRY12                           0x510C4
-#define REG_BACAM2_ENTRY12                           0x510C8
-#define REG_BACAM3_ENTRY12                           0x510CC
-#define REG_BACAM0_ENTRY13                           0x510D0
-#define REG_BACAM1_ENTRY13                           0x510D4
-#define REG_BACAM2_ENTRY13                           0x510D8
-#define REG_BACAM3_ENTRY13                           0x510DC
-#define REG_BACAM0_ENTRY14                           0x510E0
-#define REG_BACAM1_ENTRY14                           0x510E4
-#define REG_BACAM2_ENTRY14                           0x510E8
-#define REG_BACAM3_ENTRY14                           0x510EC
-#define REG_BACAM0_ENTRY15                           0x510F0
-#define REG_BACAM1_ENTRY15                           0x510F4
-#define REG_BACAM2_ENTRY15                           0x510F8
-#define REG_BACAM3_ENTRY15                           0x510FC
-#define REG_BACAM0_ENTRY16                           0x51100
-#define REG_BACAM1_ENTRY16                           0x51104
-#define REG_BACAM2_ENTRY16                           0x51108
-#define REG_BACAM3_ENTRY16                           0x5110C
-#define REG_BACAM0_ENTRY17                           0x51110
-#define REG_BACAM1_ENTRY17                           0x51114
-#define REG_BACAM2_ENTRY17                           0x51118
-#define REG_BACAM3_ENTRY17                           0x5111C
-#define REG_BACAM0_ENTRY18                           0x51120
-#define REG_BACAM1_ENTRY18                           0x51124
-#define REG_BACAM2_ENTRY18                           0x51128
-#define REG_BACAM3_ENTRY18                           0x5112C
-#define REG_BACAM0_ENTRY19                           0x51130
-#define REG_BACAM1_ENTRY19                           0x51134
-#define REG_BACAM2_ENTRY19                           0x51138
-#define REG_BACAM3_ENTRY19                           0x5113C
-#define REG_BACAM0_ENTRY20                           0x51140
-#define REG_BACAM1_ENTRY20                           0x51144
-#define REG_BACAM2_ENTRY20                           0x51148
-#define REG_BACAM3_ENTRY20                           0x5114C
-#define REG_BACAM0_ENTRY21                           0x51150
-#define REG_BACAM1_ENTRY21                           0x51154
-#define REG_BACAM2_ENTRY21                           0x51158
-#define REG_BACAM3_ENTRY21                           0x5115C
-#define REG_BACAM0_ENTRY22                           0x51160
-#define REG_BACAM1_ENTRY22                           0x51164
-#define REG_BACAM2_ENTRY22                           0x51168
-#define REG_BACAM3_ENTRY22                           0x5116C
-#define REG_BACAM0_ENTRY23                           0x51170
-#define REG_BACAM1_ENTRY23                           0x51174
-#define REG_BACAM2_ENTRY23                           0x51178
-#define REG_BACAM3_ENTRY23                           0x5117C
-#define REG_BACAM0_ENTRY24                           0x51180
-#define REG_BACAM1_ENTRY24                           0x51184
-#define REG_BACAM2_ENTRY24                           0x51188
-#define REG_BACAM3_ENTRY24                           0x5118C
-#define REG_BACAM0_ENTRY25                           0x51190
-#define REG_BACAM1_ENTRY25                           0x51194
-#define REG_BACAM2_ENTRY25                           0x51198
-#define REG_BACAM3_ENTRY25                           0x5119C
-#define REG_BACAM0_ENTRY26                           0x511A0
-#define REG_BACAM1_ENTRY26                           0x511A4
-#define REG_BACAM2_ENTRY26                           0x511A8
-#define REG_BACAM3_ENTRY26                           0x511AC
-#define REG_BACAM0_ENTRY27                           0x511B0
-#define REG_BACAM1_ENTRY27                           0x511B4
-#define REG_BACAM2_ENTRY27                           0x511B8
-#define REG_BACAM3_ENTRY27                           0x511BC
-#define REG_BACAM0_ENTRY28                           0x511C0
-#define REG_BACAM1_ENTRY28                           0x511C4
-#define REG_BACAM2_ENTRY28                           0x511C8
-#define REG_BACAM3_ENTRY28                           0x511CC
-#define REG_BACAM0_ENTRY29                           0x511D0
-#define REG_BACAM1_ENTRY29                           0x511D4
-#define REG_BACAM2_ENTRY29                           0x511D8
-#define REG_BACAM3_ENTRY29                           0x511DC
-#define REG_BACAM0_ENTRY30                           0x511E0
-#define REG_BACAM1_ENTRY30                           0x511E4
-#define REG_BACAM2_ENTRY30                           0x511E8
-#define REG_BACAM3_ENTRY30                           0x511EC
-#define REG_BACAM0_ENTRY31                           0x511F0
-#define REG_BACAM1_ENTRY31                           0x511F4
-#define REG_BACAM2_ENTRY31                           0x511F8
-#define REG_BACAM3_ENTRY31                           0x511FC
-#define REG_MBIDCAM0_ENTRY00                         0x51800
-#define REG_MBIDCAM1_ENTRY00                         0x51804
-#define REG_MBIDCAM0_ENTRY01                         0x51808
-#define REG_MBIDCAM1_ENTRY01                         0x5180C
-#define REG_MBIDCAM0_ENTRY02                         0x51810
-#define REG_MBIDCAM1_ENTRY02                         0x51814
-#define REG_MBIDCAM0_ENTRY03                         0x51818
-#define REG_MBIDCAM1_ENTRY03                         0x5181C
-#define REG_MBIDCAM0_ENTRY04                         0x51820
-#define REG_MBIDCAM1_ENTRY04                         0x51824
-#define REG_MBIDCAM0_ENTRY05                         0x51828
-#define REG_MBIDCAM1_ENTRY05                         0x5182C
-#define REG_MBIDCAM0_ENTRY06                         0x51830
-#define REG_MBIDCAM1_ENTRY06                         0x51834
-#define REG_MBIDCAM0_ENTRY07                         0x51838
-#define REG_MBIDCAM1_ENTRY07                         0x5183C
-#define REG_MBIDCAM0_ENTRY08                         0x51840
-#define REG_MBIDCAM1_ENTRY08                         0x51844
-#define REG_MBIDCAM0_ENTRY09                         0x51848
-#define REG_MBIDCAM1_ENTRY09                         0x5184C
-#define REG_MBIDCAM0_ENTRY10                         0x51850
-#define REG_MBIDCAM1_ENTRY10                         0x51854
-#define REG_MBIDCAM0_ENTRY11                         0x51858
-#define REG_MBIDCAM1_ENTRY11                         0x5185C
-#define REG_MBIDCAM0_ENTRY12                         0x51860
-#define REG_MBIDCAM1_ENTRY12                         0x51864
-#define REG_MBIDCAM0_ENTRY13                         0x51868
-#define REG_MBIDCAM1_ENTRY13                         0x5186C
-#define REG_MBIDCAM0_ENTRY14                         0x51870
-#define REG_MBIDCAM1_ENTRY14                         0x51874
-#define REG_MBIDCAM0_ENTRY15                         0x51878
-#define REG_MBIDCAM1_ENTRY15                         0x5187C
-//#define REG_DUMMY                                    0x51880
-#define REG_CSI_BUFFER                               0x52000
-#define REG_PHSTS_BUFFER                             0x54000
-
-/* AUTO_GEN_END */
-
-/* MANUAL_GEN_START */
-
-//Please add your defination here
-
-/* MANUAL_GEN_END */
-
-#endif
diff --git a/os/board/rtl8720e/src/component/wifi/wifi_fw/amebalite/include/wififw_reg_page0.h b/os/board/rtl8720e/src/component/wifi/wifi_fw/amebalite/include/wififw_reg_page0.h
deleted file mode 100644
index 8b351bec0..000000000
--- a/os/board/rtl8720e/src/component/wifi/wifi_fw/amebalite/include/wififw_reg_page0.h
+++ /dev/null
@@ -1,801 +0,0 @@
-#ifndef __WIFIFW_REG_PAGE0_H__
-#define __WIFIFW_REG_PAGE0_H__
-
-/* AUTO_GEN_START */
-
-/**************************************************************************//**
- * @defgroup REG_SYS_PWC_ISO_CTRL
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_WL_SWR_REQ_1P1V                    ((u32)0x00000001 << 4)          /*!<R/W 0  1: wl request switch SWR vlotage to 1.1V 0: wl request switch SWR vlotage to 0.9V */
-#define BIT_WL_PWM_EN                          ((u32)0x00000001 << 3)          /*!<R/W 0  1:WL request switch to PWM mode 0：WL request switch to PFM mode */
-#define BIT_WL_SAVE_EN                         ((u32)0x00000001 << 2)          /*!<R/W 0  1 to 0:gen req to restore register in power on flow 1:gen req to backup register in power on flow */
-#define BIT_SPC_MAC_EN                         ((u32)0x00000001 << 0)          /*!<R/W 0  1: Enable WLOFF power cut */
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_WL_CLK_CTRL
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_WLON_SWITCH_TSF_EN                 ((u32)0x00000001 << 12)          /*!<R/W 0  enable wlpmc switch TSF clock to MAC clock */
-#define BIT_WLOFF_SWITCH_TSF_EN                ((u32)0x00000001 << 11)          /*!<R/W 0  enable wlpmc switch TSF clock to 32K clock */
-#define BIT_WL_CKEN_IQDUMP                     ((u32)0x00000001 << 10)          /*!<R/W 0  0: disable clock for iqdump (LA MODE) 1: enable clock for iqdump (LA MODE) same clock source as security clock */
-#define BIT_IS_SCH_CLK_INSLP_V2                ((u32)0x00000001 << 9)          /*!<RO 0  WL TSF clock status: 0: MAC clock 1: 32K clock */
-#define BIT_TSF_CKSLP_SEL                      ((u32)0x00000001 << 8)          /*!<R/W 0  1: TSF clock switch to 32.768KHz; 0: TSF clock switch to MAC clock */
-#define BIT_WL_CKTSF_EN                        ((u32)0x00000001 << 6)          /*!<R/W 0  1: enable tsf clock; 0: gated */
-#define BIT_WL_FQSEL_CK32K                     ((u32)0x00000001 << 5)          /*!<R/W 0  1:32K frequency select 32.768KHz 0:32K frequency select 32KHz */
-#define BIT_CKSL_CK32K                         ((u32)0x00000001 << 4)          /*!<R/W 0  1:select MAC internal 32K clk, 0:select MAC external 32K clk */
-#define BIT_WL_CK32K_EN                        ((u32)0x00000001 << 3)          /*!<R/W 0  1: enable 32k clock; 0: gated */
-#define BIT_WL_CKMCU_EN                        ((u32)0x00000001 << 2)          /*!<R/W 0  1: enable MCU engine clock; 0: gated */
-#define BIT_WL_CKSEC_EN                        ((u32)0x00000001 << 1)          /*!<R/W 0  1: enable MAC security engine clock; 0: gated */
-#define BIT_WL_CKMAC_EN                        ((u32)0x00000001 << 0)          /*!<R/W 0  1: enable MAC clock; 0: gated */
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_WL_FUNC_EN
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_WL_SEL_SW_SI                       ((u32)0x00000001 << 24)          /*!<R/W 0  indicate SW use indirect path to access WLRFC register */
-#define BIT_BB_SAVE_EN                         ((u32)0x00000001 << 18)          /*!<R/W 0  1 to 0:gen req to restore register in power on flow 1:gen req to backup register in power on flow */
-#define BIT_FEN_BBRSTB_V2                      ((u32)0x00000001 << 17)          /*!<R/W 0  When this bit is set to “0”, CCK and OFDM are disabled, and clock are gated. Otherwise, CCK and OFDM are enabled. */
-#define BIT_FEN_BB_GLB_RSTN_V2                 ((u32)0x00000001 << 16)          /*!<R/W 0  When this bit is set to “0”, whole BB is reset. When this bit is set, BB is enabled. */
-#define BIT_SEC_ACCESS                         ((u32)0x00000001 << 12)          /*!<R/W 0  enable security access wifi register, no use this bit only access by secutiry */
-#define BIT_FEN_MLPLT                          ((u32)0x00000001 << 9)          /*!<R/W 0   */
-#define BIT_RFAFE_HW33PDB                      ((u32)0x00000001 << 8)          /*!<R/W 0   */
-#define BIT_FEN_WLON                           ((u32)0x00000001 << 4)          /*!<R/W 0  1: enable WL partial ON; 0: reset */
-#define BIT_FEN_WLMCU                          ((u32)0x00000001 << 3)          /*!<R/W 0  1: enable WLMCU; 0: reset */
-#define BIT_FEN_MACREG                         ((u32)0x00000001 << 2)          /*!<R/W 0  1: enable MAC REG; 0: reset */
-#define BIT_FEN_WLOFF                          ((u32)0x00000001 << 1)          /*!<R/W 0  1: enable WLOFF; 0: reset */
-#define BIT_FEN_MAC_PMC                        ((u32)0x00000001 << 0)          /*!<R/W 0  1: enable MAC PMC; 0: reset */
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_CLKDIV_CKSEL
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_WL_CKRFC_EN                        ((u32)0x00000001 << 24)          /*!<R/W 0  1: enable WLRFC clock; 0: gated */
-#define BIT_MASK_RFC_CLK_SEL                   ((u32)0x00000003 << 22)          /*!<R/W 2'b01  11/10:40M 01:80M 00:160M */
-#define BIT_RFC_CLK_SEL(x)                     ((u32)(((x) & 0x00000003) << 22))
-#define BIT_GET_RFC_CLK_SEL(x)                 ((u32)(((x >> 22) & 0x00000003)))
-#define BIT_MASK_SEC_CLK_SEL                   ((u32)0x00000003 << 20)          /*!<R/W 2'b01  11/10:40M 01:80M 00:160M */
-#define BIT_SEC_CLK_SEL(x)                     ((u32)(((x) & 0x00000003) << 20))
-#define BIT_GET_SEC_CLK_SEL(x)                 ((u32)(((x >> 20) & 0x00000003)))
-#define BIT_MASK_MAC_CLK_SEL                   ((u32)0x00000003 << 18)          /*!<R/W 2'b01  11/10:20M 01:40M 00:80M */
-#define BIT_MAC_CLK_SEL(x)                     ((u32)(((x) & 0x00000003) << 18))
-#define BIT_GET_MAC_CLK_SEL(x)                 ((u32)(((x >> 18) & 0x00000003)))
-#define BIT_MASK_CPU_CLK_SEL                   ((u32)0x00000003 << 16)          /*!<R/W 0   */
-#define BIT_CPU_CLK_SEL(x)                     ((u32)(((x) & 0x00000003) << 16))
-#define BIT_GET_CPU_CLK_SEL(x)                 ((u32)(((x >> 16) & 0x00000003)))
-#define BIT_WL_CLK_SYNC                        ((u32)0x00000001 << 15)          /*!<R/W 0  1: sync 40M/80M clock phase with PLL */
-#define BIT_MASK_WL_RFC_PHASE                  ((u32)0x0000000F << 8)          /*!<R/W 0  80M WLRFC clock phase control */
-#define BIT_WL_RFC_PHASE(x)                    ((u32)(((x) & 0x0000000F) << 8))
-#define BIT_GET_WL_RFC_PHASE(x)                ((u32)(((x >> 8) & 0x0000000F)))
-#define BIT_MASK_WL_40M_PHASE                  ((u32)0x0000000F << 4)          /*!<R/W 0  40M MAC clock phase control */
-#define BIT_WL_40M_PHASE(x)                    ((u32)(((x) & 0x0000000F) << 4))
-#define BIT_GET_WL_40M_PHASE(x)                ((u32)(((x >> 4) & 0x0000000F)))
-#define BIT_MASK_WL_80M_PHASE                  ((u32)0x0000000F << 0)          /*!<R/W 0  80M security clock phase control */
-#define BIT_WL_80M_PHASE(x)                    ((u32)(((x) & 0x0000000F) << 0))
-#define BIT_GET_WL_80M_PHASE(x)                ((u32)(((x >> 0) & 0x0000000F)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_CPWM
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_CPWM_TOGGLING                      ((u32)0x00000001 << 15)          /*!<R/W 0  Toggling bit : one bit sequence number bit. When this bit is toggled, interrupt is send to HISR.CPWMINT. */
-#define BIT_MASK_CPWM_MOD                      ((u32)0x00007FFF << 0)          /*!<R/W 0  The current power mode index. */
-#define BIT_CPWM_MOD(x)                        ((u32)(((x) & 0x00007FFF) << 0))
-#define BIT_GET_CPWM_MOD(x)                    ((u32)(((x >> 0) & 0x00007FFF)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_RPWM
- * @brief register for hrpwm
- * @{
- *****************************************************************************/
-#define BIT_RPWM_TOGGLING                      ((u32)0x00000001 << 15)          /*!<R/W 0  Toggling bit : one bit sequence number bit. When this bit is toggled, interrupt is send to FISR.RPWMINT. */
-#define BIT_MASK_RPWM_MOD                      ((u32)0x00007FFF << 0)          /*!<R/W 0  The current power mode index. */
-#define BIT_RPWM_MOD(x)                        ((u32)(((x) & 0x00007FFF) << 0))
-#define BIT_GET_RPWM_MOD(x)                    ((u32)(((x >> 0) & 0x00007FFF)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_RSV_CTRL
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_MASK_HREG_DBG                      ((u32)0x00000FFF << 12)          /*!<RO 0  HREG Access Debug information */
-#define BIT_HREG_DBG(x)                        ((u32)(((x) & 0x00000FFF) << 12))
-#define BIT_GET_HREG_DBG(x)                    ((u32)(((x >> 12) & 0x00000FFF)))
-#define BIT_LOCK_REGALL_EN                     ((u32)0x00000001 << 7)          /*!<R/W 0  1:Enable ‘Locked All’ setting by Hardware, 0: Hardware Enable ‘Locked All’ denied. */
-#define BIT_PRST_WLMAC                         ((u32)0x00000001 << 6)          /*!<R/W 0   */
-#define BIT_WLOCK_1C_B6                        ((u32)0x00000001 << 5)          /*!<R/W 0  1:Register Write Locked, 0: Register Accessible by SW/FW (offset:0x001C[6]) */
-#define BIT_WLOCK_40                           ((u32)0x00000001 << 4)          /*!<R/W 0  1:Register Write Locked, 0: Register Accessible by SW/FW (offset:0x0040h~0x0043h) */
-#define BIT_WLOCK_08                           ((u32)0x00000001 << 3)          /*!<R/W 0  1:Register Write Locked, 0: Register Accessible by SW/FW (offset:0x0008h~0x000Bh) */
-#define BIT_WLOCK_04                           ((u32)0x00000001 << 2)          /*!<R/W 0  1:Register Write Locked, 0: Register Accessible by SW/FW (offset:0x0004h~0x0007h) */
-#define BIT_WLOCK_00                           ((u32)0x00000001 << 1)          /*!<R/W 0  1:Register Write Locked, 0: Register Accessible by SW/FW (offset:0x0000h~0x0003h) */
-#define BIT_WLOCK_ALL                          ((u32)0x00000001 << 0)          /*!<R/W 0  1:Register Write Locked, 0: Register Accessible by SW/FW (offset:0x0000h~0x00FFh) */
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_WL_PMC_CTRL
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_WLPON_OPT_EXCKN2A                  ((u32)0x00000001 << 25)          /*!<R/W 1   */
-#define BIT_WLPON_OPT_EXCKP2A                  ((u32)0x00000001 << 24)          /*!<R/W 1  PON option to enable AFE clock */
-#define BIT_MASK_WL_PMC_CNT_PAR                ((u32)0x0000003F << 8)          /*!<R/W 0x1F  WL PMC FSM counting unit. */
-#define BIT_WL_PMC_CNT_PAR(x)                  ((u32)(((x) & 0x0000003F) << 8))
-#define BIT_GET_WL_PMC_CNT_PAR(x)              ((u32)(((x >> 8) & 0x0000003F)))
-#define BIT_CUR_PST_IS_LPS                     ((u32)0x00000001 << 4)          /*!<RO   indicate current WL power status is LPS mode */
-#define BIT_WL_PMC_LPS_EN                      ((u32)0x00000001 << 2)          /*!<R/W 0  Inform WLAN PMC FSM to enter LPS mode. (auto clear when ready) */
-#ifndef BIT_WL_PMC_OFFMAC
-#define BIT_WL_PMC_OFFMAC                      ((u32)0x00000001 << 1)          /*!<R/W 0  Inform WLAN PMC FSM to power OFF mode, include clock, isolation, power control for MAC only (clear when Power Ready) */
-#endif
-#define BIT_WL_PMC_ONMAC                       ((u32)0x00000001 << 0)          /*!<R/W 0  Inform WLAN PMC FSM to power On mode, include clock, isolation, power control for MAC only (clear when Power Ready) */
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_WL_SYSCONFIG
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_DIS_TIMEOUT_IO                     ((u32)0x00000001 << 24)          /*!<R/W 0  Disabled timeout of IO wrapper */
-#define BIT_MCU_WDT_MODE                       ((u32)0x00000001 << 21)          /*!<R/W 0   */
-#define BIT_WLCPU_ANA_PORT_IDLE                ((u32)0x00000001 << 17)          /*!<R 0   */
-#define BIT_WLCPU_MAC_PORT_IDLE                ((u32)0x00000001 << 16)          /*!<R 0   */
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_P0_TBTT_TIMER
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_MASK_P0_ELY_BCNINT_CNT             ((u32)0x0000007F << 24)          /*!<R 0  Unit: bcn_space the total time to next specified TBTT is (new_ely_agg_cnt - 1) * r_bcn_space(0x554) + (beacon_cnt_down - 1)* 1ms + (cnt_128us + 1)* 128us */
-#define BIT_P0_ELY_BCNINT_CNT(x)               ((u32)(((x) & 0x0000007F) << 24))
-#define BIT_GET_P0_ELY_BCNINT_CNT(x)           ((u32)(((x >> 24) & 0x0000007F)))
-#define BIT_MASK_P0_BCN_CNT_DOWN               ((u32)0x0000FFFF << 3)          /*!<R 0  Unit: 1ms beacon_cnt_down - 1 */
-#define BIT_P0_BCN_CNT_DOWN(x)                 ((u32)(((x) & 0x0000FFFF) << 3))
-#define BIT_GET_P0_BCN_CNT_DOWN(x)             ((u32)(((x >> 3) & 0x0000FFFF)))
-#define BIT_MASK_P0_128US_CNT                  ((u32)0x00000007 << 0)          /*!<R 0  Unit: 128us */
-#define BIT_P0_128US_CNT(x)                    ((u32)(((x) & 0x00000007) << 0))
-#define BIT_GET_P0_128US_CNT(x)                ((u32)(((x >> 0) & 0x00000007)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_AFC_CTRL0
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_POW_AFE_REQ                        ((u32)0x00000001 << 13)          /*!<R/W 0  AFE power on request to afe_ctrl 1:request to turn on AFE pwr 0:turn off AFE pwr */
-#define BIT_WL_XTAL_ACTIVE_MODE                ((u32)0x00000001 << 7)          /*!<R/W 1  1:WL request XTAL to enter active mode 0:WL request XTAL to enter LPS mode */
-#define BIT_WL_XTAL_EN                         ((u32)0x00000001 << 6)          /*!<R/W 0  1:WL enable XTAL 0:WL disable XTAL */
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_FSIMR_V1
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_FS_PWMERR_INT_EN_V1                ((u32)0x00000001 << 1)          /*!<R/W 0  Enable MCU Access Error interrupt source(TIE0) */
-#define BIT_FS_BTON_STS_UPDATE_INT_EN          ((u32)0x00000001 << 0)          /*!<R/W 0  BTON status update interrupt When 0x78[31] toggled, this interrupt is issue to indicate the status updated. */
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_FSISR_V1
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_FS_PWMERR_INT_V1                   ((u32)0x00000001 << 1)          /*!<RW1C 0  MCU Access Error interrupt source Write 1 clear */
-#define BIT_FS_BTON_STS_UPDATE_INT             ((u32)0x00000001 << 0)          /*!<RW1C 0  BTON status update interrupt When 0x78[31] toggled, this interrupt is issue to indicate the status updated. */
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_TXDMA_H2C_RD_POINTER
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_MASK_TDE_H2C_RD_ADDR               ((u32)0x0003FFFF << 0)          /*!<R 0  not used in amd2 */
-#define BIT_TDE_H2C_RD_ADDR(x)                 ((u32)(((x) & 0x0003FFFF) << 0))
-#define BIT_GET_TDE_H2C_RD_ADDR(x)             ((u32)(((x >> 0) & 0x0003FFFF)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_TXDMA_H2C_WR_POINTER
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_MASK_TDE_H2C_WR_ADDR               ((u32)0x0003FFFF << 0)          /*!<R 0  not used in amd2 */
-#define BIT_TDE_H2C_WR_ADDR(x)                 ((u32)(((x) & 0x0003FFFF) << 0))
-#define BIT_GET_TDE_H2C_WR_ADDR(x)             ((u32)(((x >> 0) & 0x0003FFFF)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_FW_DBG0_V1
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_MASK_FW_DBG0                       ((u32)0xFFFFFFFF << 0)          /*!<R/W 0  fw debug0 */
-#define BIT_FW_DBG0(x)                         ((u32)(((x) & 0xFFFFFFFF) << 0))
-#define BIT_GET_FW_DBG0(x)                     ((u32)(((x >> 0) & 0xFFFFFFFF)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_FW_DBG1_V1
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_MASK_FW_DBG1                       ((u32)0xFFFFFFFF << 0)          /*!<R/W 0  fw debug1 */
-#define BIT_FW_DBG1(x)                         ((u32)(((x) & 0xFFFFFFFF) << 0))
-#define BIT_GET_FW_DBG1(x)                     ((u32)(((x >> 0) & 0xFFFFFFFF)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_FW_DBG2_V1
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_MASK_FW_DBG2                       ((u32)0xFFFFFFFF << 0)          /*!<R/W 0  fw debug2 */
-#define BIT_FW_DBG2(x)                         ((u32)(((x) & 0xFFFFFFFF) << 0))
-#define BIT_GET_FW_DBG2(x)                     ((u32)(((x >> 0) & 0xFFFFFFFF)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_FW_DBG3_V1
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_MASK_FW_DBG3                       ((u32)0xFFFFFFFF << 0)          /*!<R/W 0  fw debug3 */
-#define BIT_FW_DBG3(x)                         ((u32)(((x) & 0xFFFFFFFF) << 0))
-#define BIT_GET_FW_DBG3(x)                     ((u32)(((x >> 0) & 0xFFFFFFFF)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_FW_DBG4_V1
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_MASK_FW_DBG4                       ((u32)0xFFFFFFFF << 0)          /*!<R/W 0  fw debug4 */
-#define BIT_FW_DBG4(x)                         ((u32)(((x) & 0xFFFFFFFF) << 0))
-#define BIT_GET_FW_DBG4(x)                     ((u32)(((x >> 0) & 0xFFFFFFFF)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_FW_DBG5_V1
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_MASK_FW_DBG5                       ((u32)0xFFFFFFFF << 0)          /*!<R/W 0  fw debug5 */
-#define BIT_FW_DBG5(x)                         ((u32)(((x) & 0xFFFFFFFF) << 0))
-#define BIT_GET_FW_DBG5(x)                     ((u32)(((x >> 0) & 0xFFFFFFFF)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_FW_DBG6_V1
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_MASK_FW_DBG6                       ((u32)0xFFFFFFFF << 0)          /*!<R/W 0  fw debug6 */
-#define BIT_FW_DBG6(x)                         ((u32)(((x) & 0xFFFFFFFF) << 0))
-#define BIT_GET_FW_DBG6(x)                     ((u32)(((x >> 0) & 0xFFFFFFFF)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_FW_DBG7_V1
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_MASK_FW_DBG7                       ((u32)0xFFFFFFFF << 0)          /*!<R/W 0  fw debug7 */
-#define BIT_FW_DBG7(x)                         ((u32)(((x) & 0xFFFFFFFF) << 0))
-#define BIT_GET_FW_DBG7(x)                     ((u32)(((x >> 0) & 0xFFFFFFFF)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_WL_PIN_FUNC_CTRL0
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_MASK_WL_DBG_SEL                    ((u32)0x000000FF << 24)          /*!<R/W 0  WL debug select */
-#define BIT_WL_DBG_SEL(x)                      ((u32)(((x) & 0x000000FF) << 24))
-#define BIT_GET_WL_DBG_SEL(x)                  ((u32)(((x >> 24) & 0x000000FF)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_WL_BTCOEX_CTRL
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_LTECOEX_DBGEN                      ((u32)0x00000001 << 20)          /*!<R/W 0   */
-#define BIT_MASK_BTMODE_V1                     ((u32)0x00000003 << 17)          /*!<R/W 0  Bluetooth Mode */
-#define BIT_BTMODE_V1(x)                       ((u32)(((x) & 0x00000003) << 17))
-#define BIT_GET_BTMODE_V1(x)                   ((u32)(((x >> 17) & 0x00000003)))
-#define BIT_ENBT_V1                            ((u32)0x00000001 << 16)          /*!<R/W 0  Enable PTA ( from BT side) */
-#define BIT_WL_DPDT1_IDV                       ((u32)0x00000001 << 3)          /*!<R/W 1   */
-#define BIT_WL_DPDT1_MUX                       ((u32)0x00000001 << 2)          /*!<R/W 0   */
-#define BIT_WL_DPDT0_IDV                       ((u32)0x00000001 << 1)          /*!<R/W 1   */
-#define BIT_WL_DPDT0_MUX                       ((u32)0x00000001 << 0)          /*!<R/W 0   */
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_SCOREBOARD_RD_BT2WL
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_MASK_RD_BT2WL_INFO                 ((u32)0x7FFFFFFF << 0)          /*!<R 0  Read Data : WL TO BT INFO, WLON Status Report */
-#define BIT_RD_BT2WL_INFO(x)                   ((u32)(((x) & 0x7FFFFFFF) << 0))
-#define BIT_GET_RD_BT2WL_INFO(x)               ((u32)(((x >> 0) & 0x7FFFFFFF)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_DBG_PORT_REG
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_MASK_DEBUG_ST                      ((u32)0xFFFFFFFF << 0)          /*!<RO 0  Debug signals, sel by 70[31:24] */
-#define BIT_DEBUG_ST(x)                        ((u32)(((x) & 0xFFFFFFFF) << 0))
-#define BIT_GET_DEBUG_ST(x)                    ((u32)(((x >> 0) & 0xFFFFFFFF)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_WL_MCUFW_CTRL
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_FW_INIT_RDY                        ((u32)0x00000001 << 15)          /*!<R/W 0  CPU fw initialize ready, set by CPU */
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_BLK_TST
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_MASK_BLK_TST                       ((u32)0xFFFFFFFF << 0)          /*!<R/W 0  fw debug8 */
-#define BIT_BLK_TST(x)                         ((u32)(((x) & 0xFFFFFFFF) << 0))
-#define BIT_GET_BLK_TST(x)                     ((u32)(((x >> 0) & 0xFFFFFFFF)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_HOST_MSG0
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_MASK_HOST_MSG_E1                   ((u32)0x0000FFFF << 16)          /*!<R/W 0  User Defined Message */
-#define BIT_HOST_MSG_E1(x)                     ((u32)(((x) & 0x0000FFFF) << 16))
-#define BIT_GET_HOST_MSG_E1(x)                 ((u32)(((x >> 16) & 0x0000FFFF)))
-#define BIT_MASK_HOST_MSG_E0                   ((u32)0x0000FFFF << 0)          /*!<R/W 0  User Defined Message */
-#define BIT_HOST_MSG_E0(x)                     ((u32)(((x) & 0x0000FFFF) << 0))
-#define BIT_GET_HOST_MSG_E0(x)                 ((u32)(((x >> 0) & 0x0000FFFF)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_HOST_MSG1
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_MASK_HOST_MSG_E3                   ((u32)0x0000FFFF << 16)          /*!<R/W 0  User Defined Message */
-#define BIT_HOST_MSG_E3(x)                     ((u32)(((x) & 0x0000FFFF) << 16))
-#define BIT_GET_HOST_MSG_E3(x)                 ((u32)(((x >> 16) & 0x0000FFFF)))
-#define BIT_MASK_HOST_MSG_E2                   ((u32)0x0000FFFF << 0)          /*!<R/W 0  User Defined Message */
-#define BIT_HOST_MSG_E2(x)                     ((u32)(((x) & 0x0000FFFF) << 0))
-#define BIT_GET_HOST_MSG_E2(x)                 ((u32)(((x >> 0) & 0x0000FFFF)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_LPS_CTRL
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_WL_LPS_OPT_SAVE_REG                ((u32)0x00000001 << 29)          /*!<R/W 0  LPS option to save retention FF 1: enable request to save retention FF 0: disable request to save retention FF */
-#define BIT_LPS_MEMPM_PHYON                    ((u32)0x00000001 << 28)          /*!<R/W 0   */
-#define BIT_MASK_LPS_MEMPM_MACOFF_FTC_ZGB      ((u32)0x00000003 << 25)          /*!<R/W 2'b11  MAC OFF FTC memory power mode when enable LPS memory power mode(for zgb_txbuf/zgb_rxbuf) 00 : normal 01 : NAP 10 : RET 11 : SLP */
-#define BIT_LPS_MEMPM_MACOFF_FTC_ZGB(x)        ((u32)(((x) & 0x00000003) << 25))
-#define BIT_GET_LPS_MEMPM_MACOFF_FTC_ZGB(x)    ((u32)(((x >> 25) & 0x00000003)))
-#define BIT_MASK_LPS_MEMPM_MACOFF_FTC_SHR      ((u32)0x00000003 << 23)          /*!<R/W 2'b11  MAC OFF FTC memory power mode when enable LPS memory power mode(for rxpktbuf/ txpktbuf low 24k[SHARE with system]) 00 : normal 01 : NAP 10 : RET 11 : SLP */
-#define BIT_LPS_MEMPM_MACOFF_FTC_SHR(x)        ((u32)(((x) & 0x00000003) << 23))
-#define BIT_GET_LPS_MEMPM_MACOFF_FTC_SHR(x)    ((u32)(((x >> 23) & 0x00000003)))
-#define BIT_MASK_LPS_MEMPM_MACOFF_SNPS_TXRPT   ((u32)0x00000003 << 21)          /*!<R/W 2'b11  MAC OFF SNPS memory power mode when enable LPS memory power mode (for txrptbuf) 00 : normal 01 : LS 10 : DS 11 : SD */
-#define BIT_LPS_MEMPM_MACOFF_SNPS_TXRPT(x)     ((u32)(((x) & 0x00000003) << 21))
-#define BIT_GET_LPS_MEMPM_MACOFF_SNPS_TXRPT(x) ((u32)(((x >> 21) & 0x00000003)))
-#define BIT_MASK_LPS_MEMPM_MACON_FTC_TXPKT     ((u32)0x00000003 << 19)          /*!<R/W 2'b10  MAC ON FTC memory power mode when enable LPS memory power mode (for txpktbuf high 8k) 00 : normal 01 : NAP 10 : RET 11 : SLP */
-#define BIT_LPS_MEMPM_MACON_FTC_TXPKT(x)       ((u32)(((x) & 0x00000003) << 19))
-#define BIT_GET_LPS_MEMPM_MACON_FTC_TXPKT(x)   ((u32)(((x >> 19) & 0x00000003)))
-#define BIT_LPS_MEMPM_MACOFF_FTC_TRXFIFO       ((u32)0x00000001 << 18)          /*!<R/W 0x1  MAC OFF FTC memory power mode when enable LPS memory power mode (for rxfifo/txfifo) 0 : normal 1 : NAP */
-#define BIT_LPS_MEMPM_MACOFF_SNPS              ((u32)0x00000001 << 17)          /*!<R/W 0x1  MAC OFF SNPS memory power mode when enable LPS memory power mode (for txllt/rc4/txoqt/keysrch/rxbacam/dmafifo/txpwr_rate/txpwr_macid/txpwr_usrlist/txpwr_srpwr/txpwr_rulim) 0 : normal 1 : LS */
-#define BIT_MASK_LPS_MEMPM_MACOFF_FTC          ((u32)0x00000003 << 15)          /*!<R/W 2'b11  MAC OFF FTC memory power mode when enable LPS memory power mode(for rxcsibuf/phystsbuf) 00 : normal 01 : NAP 10 : RET 11 : SLP */
-#define BIT_LPS_MEMPM_MACOFF_FTC(x)            ((u32)(((x) & 0x00000003) << 15))
-#define BIT_GET_LPS_MEMPM_MACOFF_FTC(x)        ((u32)(((x >> 15) & 0x00000003)))
-#define BIT_WL_LPS_OPT_PFM_EN                  ((u32)0x00000001 << 14)          /*!<R/W 0  LPS option to switch to PFM mode 1: set to PFM mode 0: stay in PWM mode */
-#define BIT_WL_LPS_OPT_SWR_0P9                 ((u32)0x00000001 << 13)          /*!<R/W 0  LPS option to set SWR voltage 0.9V 1: set SWR voltage 0.9V 0: set SWR voltage 1.1V */
-#define BIT_WL_LPS_OPT_LP_XTAL                 ((u32)0x00000001 << 12)          /*!<R/W 0  LPS option to set XTAL low power mode when enable XTAL 1: set XTAL low power mode 0: set XTAL active mode */
-#define BIT_WL_LPS_OPT_DIS_XTAL                ((u32)0x00000001 << 11)          /*!<R/W 0  LPS option to disable XTAL 1: disable XTAL 0: enable XTAL */
-#define BIT_WL_LPS_OPT_EMACFUN                 ((u32)0x00000001 << 10)          /*!<R/W 0  LPS option to reset WL MAC OFF block when enable WL MAC OFF power 1: not reset WL MAC OFF block 0: reset WL MAC OFF block */
-#define BIT_WL_LPS_OPT_EPHYPWR                 ((u32)0x00000001 << 9)          /*!<R/W 0  LPS option to enable WL BB block power 1: Enable WL BB block power 0: Disable WL BB block power */
-#define BIT_WL_LPS_OPT_EMACPWR                 ((u32)0x00000001 << 8)          /*!<R/W 0  LPS option to enable WL MAC OFF block power 1: Enable WL MAC OFF block power 0: Disable WL MAC OFF block power */
-#define BIT_WL_LPS_MEMPM_EN                    ((u32)0x00000001 << 1)          /*!<R/W 0  enable LPS memory power mode control */
-#define BIT_WL_NRM_MEMPM_SL                    ((u32)0x00000001 << 0)          /*!<R/W 0  MAC memory power mode when BIT_WL_LPS_MEMPM_EN is 0, 0 : Normal 1 : SD */
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_boot_reason
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_WL_WDT_PLFM                        ((u32)0x00000001 << 1)          /*!<R/W 0   */
-#define BIT_WL_WDT_MCU                         ((u32)0x00000001 << 0)          /*!<R/W 0   */
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_SCOREBOARD_CTRL
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_BT_INT_EN                          ((u32)0x00000001 << 31)          /*!<W 0  For WL, write 1 to issue interrupt 1 : Issue one INT to BT 0 : Don't care */
-#define BIT_MASK_WL2BT_INFO                    ((u32)0x7FFFFFFF << 0)          /*!<R/W 0  WLON Status Report TO BTON */
-#define BIT_WL2BT_INFO(x)                      ((u32)(((x) & 0x7FFFFFFF) << 0))
-#define BIT_GET_WL2BT_INFO(x)                  ((u32)(((x >> 0) & 0x7FFFFFFF)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_SYSON_FSM_MON_V1
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_MASK_WLPMC_DEBUG_SEL               ((u32)0x0000000F << 24)          /*!<R/W 0  debug select signal for WL PMC */
-#define BIT_WLPMC_DEBUG_SEL(x)                 ((u32)(((x) & 0x0000000F) << 24))
-#define BIT_GET_WLPMC_DEBUG_SEL(x)             ((u32)(((x >> 24) & 0x0000000F)))
-#define BIT_MASK_WLPMC_DEBUG                   ((u32)0x0000FFFF << 0)          /*!<RO 0  debug signal of WL PMC */
-#define BIT_WLPMC_DEBUG(x)                     ((u32)(((x) & 0x0000FFFF) << 0))
-#define BIT_GET_WLPMC_DEBUG(x)                 ((u32)(((x >> 0) & 0x0000FFFF)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_PMC_DBG_CTRL1
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_PMC_WR_OVF                         ((u32)0x00000001 << 8)          /*!<RW1C 0  PMC Write Access Timer Overflow */
-#define BIT_MASK_WLPMC_ERRINT                  ((u32)0x000000FF << 0)          /*!<RW1C 0  WLPMC Error interrupt */
-#define BIT_WLPMC_ERRINT(x)                    ((u32)(((x) & 0x000000FF) << 0))
-#define BIT_GET_WLPMC_ERRINT(x)                ((u32)(((x >> 0) & 0x000000FF)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_PMC_DBG_CTRL2_V1
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_MASK_SYSON_REG_ARB                 ((u32)0x00000003 << 0)          /*!<R/W 0  HW PMC Access Register Time Out Control */
-#define BIT_SYSON_REG_ARB(x)                   ((u32)(((x) & 0x00000003) << 0))
-#define BIT_GET_SYSON_REG_ARB(x)               ((u32)(((x >> 0) & 0x00000003)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_HIMR0
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_HISR1_INT_EN                       ((u32)0x00000001 << 31)          /*!<R/W 0  HISR1 Indicator (HIISR1 andHIMR1 are true, this bit is set to 1) */
-#define BIT_RXDES_UNAVAIL_INT_EN               ((u32)0x00000001 << 30)          /*!<R/W 0  Rx Descriptor Unavailable */
-#define BIT_HISR2_INT_EN                       ((u32)0x00000001 << 29)          /*!<R/W 0  HISR2 Indicator (HIISR2 andHIMR2 are true, this bit is set to 1) */
-#define BIT_EVTQ_DONE_INT_EN                   ((u32)0x00000001 << 28)          /*!<R/W 0  event queue done interrupt for NAN */
-#define BIT_EVTQ_START_INT_EN_V1               ((u32)0x00000001 << 27)          /*!<R/W 0  event queue start interrupt for NAN */
-#define BIT_FWMSG_INT_EN                       ((u32)0x00000001 << 26)          /*!<R/W 0  FW message interrupt,CPU to Host Command INT Status, Write 1 clear */
-#define BIT_HCPWM_INT_EN                       ((u32)0x00000001 << 24)          /*!<R/W 0  CPWM interrupt,CPU power Mode exchange INT Status, Write 1 clear */
-#define BIT_RXFF_FULL_INT_EN                   ((u32)0x00000001 << 23)          /*!<R/W 0  Rxpktbuffer full interrupt */
-#define BIT_RDE_ERR_INT_EN                     ((u32)0x00000001 << 22)          /*!<R/W 0  Rxdma error interrupt */
-#define BIT_TDE_ERR_INT_EN                     ((u32)0x00000001 << 21)          /*!<R/W 0  Txdma error interrupt */
-#define BIT_TXFF_FIFO_INT_EN                   ((u32)0x00000001 << 20)          /*!<R/W 0  txpktbuffer full interrupt */
-#define BIT_TXBCN8_ERR_INT_EN                  ((u32)0x00000001 << 19)          /*!<R/W 0  port0 BSSID7 TX beacon error interrupt */
-#define BIT_TXBCN7_ERR_INT_EN                  ((u32)0x00000001 << 18)          /*!<R/W 0  port0 BSSID6 TX beacon error interrupt */
-#define BIT_TXBCN6_ERR_INT_EN                  ((u32)0x00000001 << 17)          /*!<R/W 0  port0 BSSID5 TX beacon error interrupt */
-#define BIT_TXBCN5_ERR_INT_EN                  ((u32)0x00000001 << 16)          /*!<R/W 0  port0 BSSID4 TX beacon error interrupt */
-#define BIT_TXBCN4_ERR_INT_EN                  ((u32)0x00000001 << 15)          /*!<R/W 0  port0 BSSID3 TX beacon error interrupt */
-#define BIT_TXBCN3_ERR_INT_EN                  ((u32)0x00000001 << 14)          /*!<R/W 0  port0 BSSID2 TX beacon error interrupt */
-#define BIT_TXBCN2_ERR_INT_EN                  ((u32)0x00000001 << 13)          /*!<R/W 0  port0 BSSID1 TX beacon error interrupt */
-#define BIT_TXBCN1_ERR_INT_EN                  ((u32)0x00000001 << 12)          /*!<R/W 0  port0 BSSID0 TX beacon error interrupt */
-#define BIT_TXBCN8_OK_INT_EN                   ((u32)0x00000001 << 11)          /*!<R/W 0  port0 BSSID7 TX beacon ok interrupt */
-#define BIT_TXBCN7_OK_INT_EN                   ((u32)0x00000001 << 10)          /*!<R/W 0  port0 BSSID6 TX beacon ok interrupt */
-#define BIT_TXBCN6_OK_INT_EN                   ((u32)0x00000001 << 9)          /*!<R/W 0  port0 BSSID5 TX beacon ok interrupt */
-#define BIT_TXBCN5_OK_INT_EN                   ((u32)0x00000001 << 8)          /*!<R/W 0  port0 BSSID4 TX beacon ok interrupt */
-#define BIT_TXBCN4_OK_INT_EN                   ((u32)0x00000001 << 7)          /*!<R/W 0  port0 BSSID3 TX beacon ok interrupt */
-#define BIT_TXBCN3_OK_INT_EN                   ((u32)0x00000001 << 6)          /*!<R/W 0  port0 BSSID2 TX beacon ok interrupt */
-#define BIT_TXBCN2_OK_INT_EN                   ((u32)0x00000001 << 5)          /*!<R/W 0  port0 BSSID1 TX beacon ok interrupt */
-#define BIT_TXBCN1_OK_INT_EN                   ((u32)0x00000001 << 4)          /*!<R/W 0  port0 BSSID0 TX beacon ok interrupt */
-#define BIT_TSF_BIT32_TOGGLE_INT_EN            ((u32)0x00000001 << 3)          /*!<R/W 0  TSF Timer BIT32 toggle indication interrupt */
-#define BIT_TIMEOUT2_INT_EN                    ((u32)0x00000001 << 2)          /*!<R/W 0  tsf Timer2 interrupt */
-#define BIT_TIMEOUT1_V1_INT_EN                 ((u32)0x00000001 << 1)          /*!<R/W 0  tsf Timer1 interrupt */
-#define BIT_TIMEOUT0_V1_INT_EN                 ((u32)0x00000001 << 0)          /*!<R/W 0  tsf Timer0 interrupt */
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_HISR0
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_HISR1_INT                          ((u32)0x00000001 << 31)          /*!<RW1C 0  HISR1 Indicator (HIISR1 andHIMR1 are true, this bit is set to 1) */
-#define BIT_RXDES_UNAVAIL_INT                  ((u32)0x00000001 << 30)          /*!<RW1C 0  Rx Descriptor Unavailable */
-#define BIT_HISR2_INT                          ((u32)0x00000001 << 29)          /*!<RW1C 0  HISR2 Indicator (HIISR2 andHIMR2 are true, this bit is set to 1) */
-#define BIT_EVTQ_DONE_INT                      ((u32)0x00000001 << 28)          /*!<RW1C 0  event queue done interrupt for NAN */
-#define BIT_EVTQ_START_INT_V1                  ((u32)0x00000001 << 27)          /*!<RW1C 0  event queue start interrupt for NAN */
-#define BIT_FWMSG_INT                          ((u32)0x00000001 << 26)          /*!<RW1C 0  FW message interrupt,CPU to Host Command INT Status, Write 1 clear */
-#define BIT_HCPWM_INT                          ((u32)0x00000001 << 24)          /*!<RW1C 0  CPWM interrupt,CPU power Mode exchange INT Status, Write 1 clear */
-#define BIT_RXFF_FULL_INT                      ((u32)0x00000001 << 23)          /*!<RW1C 0  Rxpktbuffer full interrupt */
-#define BIT_RDE_ERR_INT                        ((u32)0x00000001 << 22)          /*!<RW1C 0  Rxdma error interrupt */
-#define BIT_TDE_ERR_INT                        ((u32)0x00000001 << 21)          /*!<RW1C 0  Txdma error interrupt */
-#define BIT_TXFF_FIFO_INT                      ((u32)0x00000001 << 20)          /*!<RW1C 0  txpktbuffer full interrupt */
-#define BIT_TXBCN8_ERR_INT                     ((u32)0x00000001 << 19)          /*!<RW1C 0  port0 BSSID7 TX beacon error interrupt */
-#define BIT_TXBCN7_ERR_INT                     ((u32)0x00000001 << 18)          /*!<RW1C 0  port0 BSSID6 TX beacon error interrupt */
-#define BIT_TXBCN6_ERR_INT                     ((u32)0x00000001 << 17)          /*!<RW1C 0  port0 BSSID5 TX beacon error interrupt */
-#define BIT_TXBCN5_ERR_INT                     ((u32)0x00000001 << 16)          /*!<RW1C 0  port0 BSSID4 TX beacon error interrupt */
-#define BIT_TXBCN4_ERR_INT                     ((u32)0x00000001 << 15)          /*!<RW1C 0  port0 BSSID3 TX beacon error interrupt */
-#define BIT_TXBCN3_ERR_INT                     ((u32)0x00000001 << 14)          /*!<RW1C 0  port0 BSSID2 TX beacon error interrupt */
-#define BIT_TXBCN2_ERR_INT                     ((u32)0x00000001 << 13)          /*!<RW1C 0  port0 BSSID1 TX beacon error interrupt */
-#define BIT_TXBCN1_ERR_INT                     ((u32)0x00000001 << 12)          /*!<RW1C 0  port0 BSSID0 TX beacon error interrupt */
-#define BIT_TXBCN8_OK_INT                      ((u32)0x00000001 << 11)          /*!<RW1C 0  port0 BSSID7 TX beacon ok interrupt */
-#define BIT_TXBCN7_OK_INT                      ((u32)0x00000001 << 10)          /*!<RW1C 0  port0 BSSID6 TX beacon ok interrupt */
-#define BIT_TXBCN6_OK_INT                      ((u32)0x00000001 << 9)          /*!<RW1C 0  port0 BSSID5 TX beacon ok interrupt */
-#define BIT_TXBCN5_OK_INT                      ((u32)0x00000001 << 8)          /*!<RW1C 0  port0 BSSID4 TX beacon ok interrupt */
-#define BIT_TXBCN4_OK_INT                      ((u32)0x00000001 << 7)          /*!<RW1C 0  port0 BSSID3 TX beacon ok interrupt */
-#define BIT_TXBCN3_OK_INT                      ((u32)0x00000001 << 6)          /*!<RW1C 0  port0 BSSID2 TX beacon ok interrupt */
-#define BIT_TXBCN2_OK_INT                      ((u32)0x00000001 << 5)          /*!<RW1C 0  port0 BSSID1 TX beacon ok interrupt */
-#define BIT_TXBCN1_OK_INT                      ((u32)0x00000001 << 4)          /*!<RW1C 0  port0 BSSID0 TX beacon ok interrupt */
-#define BIT_TSF_BIT32_TOGGLE_INT               ((u32)0x00000001 << 3)          /*!<RW1C 0  TSF Timer BIT32 toggle indication interrupt */
-#define BIT_TIMEOUT2_INT                       ((u32)0x00000001 << 2)          /*!<RW1C 0  tsf Timer2 interrupt */
-#define BIT_TIMEOUT1_INT_V1                    ((u32)0x00000001 << 1)          /*!<RW1C 0  tsf Timer1 interrupt */
-#define BIT_TIMEOUT0_INT_V1                    ((u32)0x00000001 << 0)          /*!<RW1C 0  tsf Timer0 interrupt */
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_HEMR
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_CTWEND1_INT_EN                     ((u32)0x00000001 << 31)          /*!<R/W 0  Client1 traffic window end interrupt for P2P */
-#define BIT_CTWEND0_INT_EN                     ((u32)0x00000001 << 30)          /*!<R/W 0  Client0 traffic window end interrupt for P2P */
-#define BIT_DWWIN_END_INT_EN_V1                ((u32)0x00000001 << 29)          /*!<R/W 0  discovery window end interrupt for NAN */
-#define BIT_ATIMEND8_INT_EN                    ((u32)0x00000001 << 28)          /*!<R/W 0  port1 atimend interrupt */
-#define BIT_ATIMEND7_INT_EN                    ((u32)0x00000001 << 27)          /*!<R/W 0  port0 BSSID7 atimend interrupt */
-#define BIT_ATIMEND6_INT_EN                    ((u32)0x00000001 << 26)          /*!<R/W 0  port0 BSSID6 atimend interrupt */
-#define BIT_ATIMEND5_INT_EN                    ((u32)0x00000001 << 25)          /*!<R/W 0  port0 BSSID5 atimend interrupt */
-#define BIT_ATIMEND4_INT_EN                    ((u32)0x00000001 << 24)          /*!<R/W 0  port0 BSSID4 atimend interrupt */
-#define BIT_ATIMEND3_INT_EN                    ((u32)0x00000001 << 23)          /*!<R/W 0  port0 BSSID3 atimend interrupt */
-#define BIT_ATIMEND2_INT_EN                    ((u32)0x00000001 << 22)          /*!<R/W 0  port0 BSSID2 atimend interrupt */
-#define BIT_ATIMEND1_INT_EN                    ((u32)0x00000001 << 21)          /*!<R/W 0  port0 BSSID1 atimend interrupt */
-#define BIT_ATIMEND0_INT_EN                    ((u32)0x00000001 << 20)          /*!<R/W 0  port0 BSSID0 atimend interrupt */
-#define BIT_BCNERLY8_INT_EN                    ((u32)0x00000001 << 19)          /*!<R/W 0  port1 beacon early interrupt */
-#define BIT_BCNERLY7_INT_EN                    ((u32)0x00000001 << 18)          /*!<R/W 0  port0 BSSID7 beacon early interrupt , only valid under MBSSID mode */
-#define BIT_BCNERLY6_INT_EN                    ((u32)0x00000001 << 17)          /*!<R/W 0  port0 BSSID6 beacon early interrupt , only valid under MBSSID mode */
-#define BIT_BCNERLY5_INT_EN                    ((u32)0x00000001 << 16)          /*!<R/W 0  port0 BSSID5 beacon early interrupt , only valid under MBSSID mode */
-#define BIT_BCNERLY4_INT_EN                    ((u32)0x00000001 << 15)          /*!<R/W 0  port0 BSSID4 beacon early interrupt, only valid under MBSSID mode */
-#define BIT_BCNERLY3_INT_EN                    ((u32)0x00000001 << 14)          /*!<R/W 0  port0 BSSID3 beacon early interrupt , only valid under MBSSID mode */
-#define BIT_BCNERLY2_INT_EN                    ((u32)0x00000001 << 13)          /*!<R/W 0  port0 BSSID2 beacon early interrupt, only valid under MBSSID mode */
-#define BIT_BCNERLY1_INT_EN                    ((u32)0x00000001 << 12)          /*!<R/W 0  port0 BSSID1 beacon early interrupt , only valid under MBSSID mode */
-#define BIT_BCNERLY0_INT_EN                    ((u32)0x00000001 << 11)          /*!<R/W 0  This interrupt is issued at the time set by DRVERLYINT register before TBTT time for port 0 root bssid */
-#define BIT_HS_BCNELY1_AGGR_INT_EN             ((u32)0x00000001 << 10)          /*!<R/W 0  port 1 Beacon early aggregation interrupt */
-#define BIT_CPU_MGQ_TXDONE_INT_EN              ((u32)0x00000001 << 9)          /*!<R/W 0  CPU_MQG_TXDONE ineterrupt source when HW TX CPUMGQ packet success, it issue interrupt to host */
-#define BIT_PS_TIMER_C_INT_EN                  ((u32)0x00000001 << 8)          /*!<R/W 0  PS_Timer_C interrupt source When the lower 4 bytes of TSF(that select by reg 0x1510[18:16]) matches the content of this register, the PS_Timer_C_INT interrupt is issued */
-#define BIT_PS_TIMER_B_INT_EN                  ((u32)0x00000001 << 7)          /*!<R/W 0  PS_Timer_B interrupt source When the lower 4 bytes of TSF(that select by reg 0x1510[10:8]) matches the content of this register, the PS_Timer_B_INT interrupt is issued */
-#define BIT_PS_TIMER_A_INT_EN                  ((u32)0x00000001 << 6)          /*!<R/W 0  PS_Timer_A interrupt source When the lower 4 bytes of TSF(that select by reg 0x1510[2:0]) matches the content of this register, the PS_Timer_A_INT interrupt is issued */
-#define BIT_HS_BCNELY0_AGGR_INT_EN             ((u32)0x00000001 << 5)          /*!<R/W 0  port 0 Beacon early aggregation interrupt */
-#define BIT_GTINT4_EN                          ((u32)0x00000001 << 4)          /*!<R/W 0  When GTIMER4 expires, this bit is set to 1 */
-#define BIT_GTINT3_EN                          ((u32)0x00000001 << 3)          /*!<R/W 0  When GTIMER3 expires, this bit is set to 1 */
-#define BIT_TXBCNOK9_INT_EN                    ((u32)0x00000001 << 2)          /*!<R/W 0  PORT1 TX beacon OK interrupt */
-#define BIT_TXBCNERE9_INT_EN                   ((u32)0x00000001 << 1)          /*!<R/W 0  PORT1 TX beacon Error interrupt */
-#define BIT_RXBCN_NAN_RPT_OK_EN                ((u32)0x00000001 << 0)          /*!<R/W 0  port2 rxbcn rpt and write to txrptbuf ok */
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_HESR
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_CTWEND1_INT                        ((u32)0x00000001 << 31)          /*!<RW1C 0  Client1 traffic window end interrupt for P2P */
-#define BIT_CTWEND0_INT                        ((u32)0x00000001 << 30)          /*!<RW1C 0  Client0 traffic window end interrupt for P2P */
-#define BIT_DWWIN_END_INT_V1                   ((u32)0x00000001 << 29)          /*!<RW1C 0  discovery window end interrupt for NAN */
-#define BIT_ATIMEND8_INT                       ((u32)0x00000001 << 28)          /*!<RW1C 0  port1 atimend interrupt */
-#define BIT_ATIMEND7_INT                       ((u32)0x00000001 << 27)          /*!<RW1C 0  port0 BSSID7 atimend interrupt */
-#define BIT_ATIMEND6_INT                       ((u32)0x00000001 << 26)          /*!<RW1C 0  port0 BSSID6 atimend interrupt */
-#define BIT_ATIMEND5_INT                       ((u32)0x00000001 << 25)          /*!<RW1C 0  port0 BSSID5 atimend interrupt */
-#define BIT_ATIMEND4_INT                       ((u32)0x00000001 << 24)          /*!<RW1C 0  port0 BSSID4 atimend interrupt */
-#define BIT_ATIMEND3_INT                       ((u32)0x00000001 << 23)          /*!<RW1C 0  port0 BSSID3 atimend interrupt */
-#define BIT_ATIMEND2_INT                       ((u32)0x00000001 << 22)          /*!<RW1C 0  port0 BSSID2 atimend interrupt */
-#define BIT_ATIMEND1_INT                       ((u32)0x00000001 << 21)          /*!<RW1C 0  port0 BSSID1 atimend interrupt */
-#define BIT_ATIMEND0_INT                       ((u32)0x00000001 << 20)          /*!<RW1C 0  port0 BSSID0 atimend interrupt */
-#define BIT_BCNERLY8_INT                       ((u32)0x00000001 << 19)          /*!<RW1C 0  port1 beacon early interrupt */
-#define BIT_BCNERLY7_INT                       ((u32)0x00000001 << 18)          /*!<RW1C 0  port0 BSSID7 beacon early interrupt , only valid under MBSSID mode */
-#define BIT_BCNERLY6_INT                       ((u32)0x00000001 << 17)          /*!<RW1C 0  port0 BSSID6 beacon early interrupt , only valid under MBSSID mode */
-#define BIT_BCNERLY5_INT                       ((u32)0x00000001 << 16)          /*!<RW1C 0  port0 BSSID5 beacon early interrupt , only valid under MBSSID mode */
-#define BIT_BCNERLY4_INT                       ((u32)0x00000001 << 15)          /*!<RW1C 0  port0 BSSID4 beacon early interrupt, only valid under MBSSID mode */
-#define BIT_BCNERLY3_INT                       ((u32)0x00000001 << 14)          /*!<RW1C 0  port0 BSSID3 beacon early interrupt , only valid under MBSSID mode */
-#define BIT_BCNERLY2_INT                       ((u32)0x00000001 << 13)          /*!<RW1C 0  port0 BSSID2 beacon early interrupt, only valid under MBSSID mode */
-#define BIT_BCNERLY1_INT                       ((u32)0x00000001 << 12)          /*!<RW1C 0  port0 BSSID1 beacon early interrupt , only valid under MBSSID mode */
-#define BIT_BCNERLY0_INT                       ((u32)0x00000001 << 11)          /*!<RW1C 0  This interrupt is issued at the time set by DRVERLYINT register before TBTT time for port 0 root bssid */
-#define BIT_HS_BCNELY1_AGGR_INT                ((u32)0x00000001 << 10)          /*!<RW1C 0  port 1 Beacon early aggregation interrupt */
-#define BIT_CPU_MGQ_TXDONE_INT                 ((u32)0x00000001 << 9)          /*!<RW1C 0  CPU_MQG_TXDONE ineterrupt source when HW TX CPUMGQ packet success, it issue interrupt to host */
-#define BIT_PS_TIMER_C_INT                     ((u32)0x00000001 << 8)          /*!<RW1C 0  PS_Timer_C interrupt source When the lower 4 bytes of TSF(that select by reg 0x1510[18:16]) matches the content of this register, the PS_Timer_C_INT interrupt is issued */
-#define BIT_PS_TIMER_B_INT                     ((u32)0x00000001 << 7)          /*!<RW1C 0  PS_Timer_B interrupt source When the lower 4 bytes of TSF(that select by reg 0x1510[10:8]) matches the content of this register, the PS_Timer_B_INT interrupt is issued */
-#define BIT_PS_TIMER_A_INT                     ((u32)0x00000001 << 6)          /*!<RW1C 0  PS_Timer_A interrupt source When the lower 4 bytes of TSF(that select by reg 0x1510[2:0]) matches the content of this register, the PS_Timer_A_INT interrupt is issued */
-#define BIT_HS_BCNELY0_AGGR_INT                ((u32)0x00000001 << 5)          /*!<RW1C 0  port 0 Beacon early aggregation interrupt */
-#define BIT_GTINT4                             ((u32)0x00000001 << 4)          /*!<RW1C 0  When GTIMER4 expires, this bit is set to 1 */
-#define BIT_GTINT3                             ((u32)0x00000001 << 3)          /*!<RW1C 0  When GTIMER3 expires, this bit is set to 1 */
-#define BIT_TXBCNOK9_INT                       ((u32)0x00000001 << 2)          /*!<RW1C 0  PORT1 TX beacon OK interrupt */
-#define BIT_TXBCNERR9_INT                      ((u32)0x00000001 << 1)          /*!<RW1C 0  PORT1 TX beacon Error interrupt */
-#define BIT_RXBCN_NAN_RPT_OK                   ((u32)0x00000001 << 0)          /*!<RW1C 0  port2 rxbcn rpt and write to txrptbuf ok */
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_HIMR2
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_KM0_INT_EN                         ((u32)0x00000001 << 31)          /*!<R/W 0  The gathering of interrupts of KM0 */
-#define BIT_PS_TIMER_E_INT_EN                  ((u32)0x00000001 << 25)          /*!<R/W 0  PS_Timer_E interrupt When the TSF(that select by reg 0x1520[13:12]) matches the content of this register, the PS_Timer_E_INT interrupt is issued */
-#define BIT_PS_TIMER_D_INT_EN                  ((u32)0x00000001 << 24)          /*!<R/W 0  PS_Timer_D interrupt When the lower 4 bytes of TSF(that select by reg 0x1520[17:16]) matches the content of this register, the PS_Timer_D_INT interrupt is issued */
-#define BIT_PS_TIMER_E_EARLY_INT_EN            ((u32)0x00000001 << 23)          /*!<R/W 0  This interrupt is issued at the time set by PS_Timer_E_Early register before PS_Timer_E time. */
-#define BIT_PS_TIMER_D_EARLY_INT_EN            ((u32)0x00000001 << 22)          /*!<R/W 0  This interrupt is issued at the time set by PS_Timer_D_Early register before PS_Timer_D time. */
-#define BIT_PS_TIMER_C_EARLY_INT_EN            ((u32)0x00000001 << 21)          /*!<R/W 0  This interrupt is issued at the time set by PS_Timer_C_Early register before PS_Timer_C time. */
-#define BIT_PS_TIMER_B_EARLY_INT_EN            ((u32)0x00000001 << 20)          /*!<R/W 0  This interrupt is issued at the time set by PS_Timer_B_Early register before PS_Timer_B time. */
-#define BIT_PS_TIMER_A_EARLY_INT_EN            ((u32)0x00000001 << 19)          /*!<R/W 0  This interrupt is issued at the time set by PS_Timer_A_Early register before PS_Timer_A time. */
-#define BIT_TXBCNOK_NAN_INT_EN                 ((u32)0x00000001 << 18)          /*!<R/W 0  PORT2 TX beacon OK interrupt */
-#define BIT_TXBCNERR_NAN_INT_EN                ((u32)0x00000001 << 17)          /*!<R/W 0  PORT2 TX beacon Error interrupt */
-#define BIT_RXTMREQ_INT_EN                     ((u32)0x00000001 << 16)          /*!<R/W 0  If BIT_RXTMREQ_INT_EN =1. When HW receive TMREQ packet, it will generate interrupt to firmware. */
-#define BIT_RXTM_INT_EN                        ((u32)0x00000001 << 15)          /*!<R/W 0  If BIT_RXTM_INT_EN =1. When HW receive TM and transmit ACK frame successfully. It will generate interrupt to firmware. */
-#define BIT_TXTM_INT_EN                        ((u32)0x00000001 << 14)          /*!<R/W 0  If BIT_TXTM_INT_EN =1. When HW transmit TM and receive ACK frame successfully. It will generate interrupt to firmware. */
-#define BIT_RX_PAYLOAD_MATCH_INT_EN            ((u32)0x00000001 << 13)          /*!<R/W 0  indicate rx payload content match */
-#define BIT_CHINFO_SEG_DONE_INT_EN             ((u32)0x00000001 << 12)          /*!<R/W 0  indicate one channel info segment is received ok */
-#define BIT_CSI_BUF_FULL_INT_EN                ((u32)0x00000001 << 11)          /*!<R/W 0  indicate channel info rxcsibuffer is full */
-#define BIT_HS_RX_PHYSTS_DONE_INT_EN           ((u32)0x00000001 << 6)          /*!<R/W 0  indicate physts is successfully write into physts_mem */
-#define BIT_HS_TIM_HIT_INT_EN                  ((u32)0x00000001 << 5)          /*!<R/W 0  when my aid or aid is 0 (0x16DC[8]) or my bssid is in tim element,generate this interrupt */
-#define BIT_HS_DFS_PKT_INT_EN                  ((u32)0x00000001 << 4)          /*!<R/W 0  enable interrupt when receiving dfs pkt and about to reach threshold of given pkt number or timeout */
-#define BIT_HS_BC_TWT_PARA_CHG_INT_EN          ((u32)0x00000001 << 3)          /*!<R/W 0  RX broadcast twt with parameter changing,notify fw to read twt report */
-#define BIT_HS_BCN_IE_0_HIT_INT_EN             ((u32)0x00000001 << 2)          /*!<R/W 0  rx bcn with ie0 hit */
-#define BIT_HS_BCN_IE_1_HIT_INT_EN             ((u32)0x00000001 << 1)          /*!<R/W 0  rx bcn with ie1 hit */
-#define BIT_HS_TIM_NO_HIT_INT_EN               ((u32)0x00000001 << 0)          /*!<R/W 0  when no my aid or aid is 0(0x16DC[8]) or my bssid is not in tim element(0x16DB[31]),generate this interrupt */
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_HISR2
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_KM0_INT                            ((u32)0x00000001 << 31)          /*!<RW1C 0  The gathering of interrupts of KM0 */
-#define BIT_PS_TIMER_E_INT                     ((u32)0x00000001 << 25)          /*!<RW1C 0  PS_Timer_E interrupt When the TSF(that select by reg 0x1520[13:12]) matches the content of this register, the PS_Timer_E_INT interrupt is issued */
-#define BIT_PS_TIMER_D_INT                     ((u32)0x00000001 << 24)          /*!<RW1C 0  PS_Timer_D interrupt When the lower 4 bytes of TSF(that select by reg 0x1520[17:16]) matches the content of this register, the PS_Timer_D_INT interrupt is issued */
-#define BIT_PS_TIMER_E_EARLY_INT               ((u32)0x00000001 << 23)          /*!<RW1C 0  This interrupt is issued at the time set by PS_Timer_E_Early register before PS_Timer_E time. */
-#define BIT_PS_TIMER_D_EARLY_INT               ((u32)0x00000001 << 22)          /*!<RW1C 0  This interrupt is issued at the time set by PS_Timer_D_Early register before PS_Timer_D time. */
-#define BIT_PS_TIMER_C_EARLY_INT               ((u32)0x00000001 << 21)          /*!<RW1C 0  This interrupt is issued at the time set by PS_Timer_C_Early register before PS_Timer_C time. */
-#define BIT_PS_TIMER_B_EARLY_INT               ((u32)0x00000001 << 20)          /*!<RW1C 0  This interrupt is issued at the time set by PS_Timer_B_Early register before PS_Timer_B time. */
-#define BIT_PS_TIMER_A_EARLY_INT               ((u32)0x00000001 << 19)          /*!<RW1C 0  This interrupt is issued at the time set by PS_Timer_A_Early register before PS_Timer_A time. */
-#define BIT_TXBCNOK_NAN_INT                    ((u32)0x00000001 << 18)          /*!<RW1C 0  PORT2 TX beacon OK interrupt */
-#define BIT_TXBCNERR_NAN_INT                   ((u32)0x00000001 << 17)          /*!<RW1C 0  PORT2 TX beacon Error interrupt */
-#define BIT_RXTMREQ_INT                        ((u32)0x00000001 << 16)          /*!<RW1C 0  If BIT_RXTMREQ_INT_EN =1. When HW receive TMREQ packet, it will generate interrupt to firmware. */
-#define BIT_RXTM_INT                           ((u32)0x00000001 << 15)          /*!<RW1C 0  If BIT_RXTM_INT_EN =1. When HW receive TM and transmit ACK frame successfully. It will generate interrupt to firmware. */
-#define BIT_TXTM_INT                           ((u32)0x00000001 << 14)          /*!<RW1C 0  If BIT_TXTM_INT_EN =1. When HW transmit TM and receive ACK frame successfully. It will generate interrupt to firmware. */
-#define BIT_RX_PAYLOAD_MATCH_INT               ((u32)0x00000001 << 13)          /*!<RW1C 0  indicate rx payload content match */
-#define BIT_CHINFO_SEG_DONE_INT                ((u32)0x00000001 << 12)          /*!<RW1C 0  indicate one channel info segment is received ok */
-#define BIT_CSI_BUF_FULL_INT                   ((u32)0x00000001 << 11)          /*!<RW1C 0  indicate channel info rxcsibuffer is full */
-#define BIT_HS_RX_PHYSTS_DONE_INT              ((u32)0x00000001 << 6)          /*!<RW1C 0  indicate physts is successfully write into physts_mem */
-#define BIT_HS_TIM_HIT_INT                     ((u32)0x00000001 << 5)          /*!<RW1C 0  when my aid or aid is 0 (0x16DC[8]) or my bssid is in tim element,generate this interrupt */
-#define BIT_HS_DFS_PKT_INT                     ((u32)0x00000001 << 4)          /*!<RW1C 0  enable interrupt when receiving dfs pkt and about to reach threshold of given pkt number or timeout */
-#define BIT_HS_BC_TWT_PARA_CHG_INT             ((u32)0x00000001 << 3)          /*!<RW1C 0  RX broadcast twt with parameter changing,notify fw to read twt report */
-#define BIT_HS_BCN_IE_0_HIT_INT                ((u32)0x00000001 << 2)          /*!<RW1C 0  rx bcn with ie0 hit */
-#define BIT_HS_BCN_IE_1_HIT_INT                ((u32)0x00000001 << 1)          /*!<RW1C 0  rx bcn with ie1 hit */
-#define BIT_HS_TIM_NO_HIT_INT                  ((u32)0x00000001 << 0)          /*!<RW1C 0  when no my aid or aid is 0(0x16DC[8]) or my bssid is not in tim element(0x16DB[31]),generate this interrupt */
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_SDM_IDR_CTRL0
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_MASK_SDM_ADDR                      ((u32)0x0000003F << 0)          /*!<R/W 0  SDM register offset */
-#define BIT_SDM_ADDR(x)                        ((u32)(((x) & 0x0000003F) << 0))
-#define BIT_GET_SDM_ADDR(x)                    ((u32)(((x >> 0) & 0x0000003F)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_WL_CK32KGEN_RWD
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_MASK_CK32GEN_RD                    ((u32)0xFFFFFFFF << 0)          /*!<RO 0   */
-#define BIT_CK32GEN_RD(x)                      ((u32)(((x) & 0xFFFFFFFF) << 0))
-#define BIT_GET_CK32GEN_RD(x)                  ((u32)(((x >> 0) & 0xFFFFFFFF)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_SYS_CONFIG0
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_AUX_IS_32K                         ((u32)0x00000001 << 9)          /*!<RO 0   */
-#define BIT_IS_SCH_CLK_INSLP_V1                ((u32)0x00000001 << 8)          /*!<RO 0  WL TSF clock status: 0: MAC clock 1: 32K clock */
-#define BIT_MASK_VENDOR_ID_V1                  ((u32)0x0000000F << 4)          /*!<RO 4'b1000  Vendor ID [7:6] : Download FW version ; 00: TSMC , 01: SMIC, 10: UMC [5] ; 0 : Download FW , init BB and RF registers 1 : Do not download FW and do not init BB and RF registers [4] ; 0 : BT do not exist in IC 1 : BT exist in IC */
-#define BIT_VENDOR_ID_V1(x)                    ((u32)(((x) & 0x0000000F) << 4))
-#define BIT_GET_VENDOR_ID_V1(x)                ((u32)(((x >> 4) & 0x0000000F)))
-#define BIT_PLL_CK_RDY                         ((u32)0x00000001 << 0)          /*!<RO 0  indicate AFE PLL clock is ready */
-/** @} */
-
-
-/*==========PAGE0 Register Address Definition==========*/
-#define REG_SYS_PWC_ISO_CTRL                         0x0000
-#define REG_WL_CLK_CTRL                              0x0002
-#define REG_WL_FUNC_EN                               0x0004
-#define REG_CLKDIV_CKSEL                             0x0008
-#define REG_CPWM                                     0x000C
-//#define REG_                                    	   0x0010
-#define REG_RPWM                                     0x0014
-//#define REG_                                    	   0x0018
-#define REG_RSV_CTRL                                 0x001C
-#define REG_WL_PMC_CTRL                              0x0020
-#define REG_WL_SYSCONFIG                             0x0024
-#define REG_P0_TBTT_TIMER                            0x0028
-//#define REG_                                         0x002C
-#define REG_AFC_CTRL0                                0x0030
-#define REG_AFE_CTRL1_V1                             0x0034
-#define REG_AFE_CTRL2_V1                             0x0038
-#define REG_AFE_CTRL3_V1                             0x003C
-#define REG_FSIMR_V1                                 0x0040
-#define REG_FSISR_V1                                 0x0044
-#define REG_TXDMA_H2C_RD_POINTER                     0x0048
-#define REG_TXDMA_H2C_WR_POINTER                     0x004C
-//#define REG_FW_DBG0_V1                               0x0050
-//#define REG_FW_DBG1_V1                               0x0054
-//#define REG_FW_DBG2_V1                               0x0058
-//#define REG_FW_DBG3_V1                               0x005C
-//#define REG_FW_DBG4_V1                               0x0060
-//#define REG_FW_DBG5_V1                               0x0064
-//#define REG_FW_DBG6_V1                               0x0068
-//#define REG_FW_DBG7_V1                               0x006C//move debugrom
-#define REG_WL_PIN_FUNC_CTRL0                        0x0070
-#define REG_WL_BTCOEX_CTRL                           0x0074
-#define REG_SCOREBOARD_RD_BT2WL                      0x0078
-#define REG_DBG_PORT_REG                             0x007C
-#define REG_WL_MCUFW_CTRL                            0x0080
-//#define REG_BLK_TST                                  0x0084
-//#define REG_HOST_MSG0                                0x0088
-//#define REG_HOST_MSG1                                0x008C
-#define REG_LPS_CTRL                                 0x0090
-//#define REG_                                         0x0094
-#define REG_BOOT_REASON                              0x0098
-//#define REG_		                                   0x009C
-#define REG_SCOREBOARD_CTRL                          0x00A0
-#define REG_SYSON_FSM_MON_V1                         0x00A4
-#define REG_PMC_DBG_CTRL1                            0x00A8
-#define REG_PMC_DBG_CTRL2_V1                         0x00AC
-#define REG_HIMR0                                    0x00B0
-#define REG_HISR0                                    0x00B4
-#define REG_HEMR                                     0x00B8
-#define REG_HESR                                     0x00BC
-#define REG_HIMR2                                    0x00C0
-#define REG_HISR2                                    0x00C4
-//#define REG_                                         0x00C8
-//#define REG_                                         0x00CC
-//#define REG_                                         0x00D0
-//#define REG_                                         0x00D4
-//#define REG_                                         0x00D8
-//#define REG_                                         0x00DA
-//#define REG_                                         0x00DC
-//#define REG_                                         0x00E0
-//#define REG_                                         0x00E4
-#define REG_SDM_IDR_CTRL0                            0x00E8
-#define REG_WL_CK32KGEN_RWD                          0x00EC
-#define REG_SYS_CONFIG0                              0x00F0
-//#define REG_                                         0x00F4
-//#define REG_                                         0x00F8
-//#define REG_                                         0x00FC
-
-/* AUTO_GEN_END */
-
-/* MANUAL_GEN_START */
-
-//Please add your defination here
-
-/* MANUAL_GEN_END */
-
-#endif
diff --git a/os/board/rtl8720e/src/component/wifi/wifi_fw/amebalite/include/wififw_reg_page1.h b/os/board/rtl8720e/src/component/wifi/wifi_fw/amebalite/include/wififw_reg_page1.h
deleted file mode 100644
index 9fb373657..000000000
--- a/os/board/rtl8720e/src/component/wifi/wifi_fw/amebalite/include/wififw_reg_page1.h
+++ /dev/null
@@ -1,1494 +0,0 @@
-#ifndef __WIFIFW_REG_PAGE1_H__
-#define __WIFIFW_REG_PAGE1_H__
-
-/* AUTO_GEN_START */
-
-/**************************************************************************//**
- * @defgroup REG_CR
- * @brief MAC TOP Function enable
- * @{
- *****************************************************************************/
-#define BIT_DMACLBK                                ((u32)0x00000001 << 28)          /*!<R/W 0  [28:24] LBMODE [4]dual-mac lbk, [3] no buffer, 1: no delay, 0: delay; [2] dmalbk, [1] no_txphy, [0] diglbk. 00000: Normal 01011: Single MAC Direct loopback (no HW encryption/decryption) 00011: Single MAC Delay Loopback (with HW encryption/decryption) */
-#define BIT_NO_TBUF                                ((u32)0x00000001 << 27)          /*!<R/W 0   */
-#define BIT_DMALBK                                 ((u32)0x00000001 << 26)          /*!<R/W 0   */
-#define BIT_NO_TXPHY                               ((u32)0x00000001 << 25)          /*!<R/W 0   */
-#define BIT_DIGLBK                                 ((u32)0x00000001 << 24)          /*!<R/W 0   */
-#define BIT_MASK_NETYPE1                           ((u32)0x00000003 << 18)          /*!<R/W 0  Network Type for Port 1 00: No link 01: Link in ad hoc network 10: Link in infrastructure network 11 : AP mode Default: 00b. */
-#define BIT_NETYPE1(x)                             ((u32)(((x) & 0x00000003) << 18))
-#define BIT_GET_NETYPE1(x)                         ((u32)(((x >> 18) & 0x00000003)))
-#define BIT_MASK_NETYPE0                           ((u32)0x00000003 << 16)          /*!<R/W 0  Network Type for port 0 00: No link 01: Link in ad hoc network 10: Link in infrastructure network 11 : AP mode Default: 00b. */
-#define BIT_NETYPE0(x)                             ((u32)(((x) & 0x00000003) << 16))
-#define BIT_GET_NETYPE0(x)                         ((u32)(((x >> 16) & 0x00000003)))
-#define BIT_I2C_MAILBOX_EN                         ((u32)0x00000001 << 12)          /*!<R/W 0  Enable I2C mailbox */
-#define BIT_MAC_SEC_EN                             ((u32)0x00000001 << 9)          /*!<R/W 0  Enable MAC security engine When this bit is clear, security engine is reset */
-#define BIT_ENSWBCN                                ((u32)0x00000001 << 8)          /*!<R/W 0  Enable SW TX beacon 0 : disable, beacon is DMAed from host memory by HW at BCNDMAINT 1 : enable, beacon is polled to DMA to TXBUF. In both case, as long as a beacon frame is set in BCN page, MAC will automatically sent beacon frame automatically. */
-#define BIT_MACRXEN                                ((u32)0x00000001 << 7)          /*!<R/W 0  MAC Receiver Enable. When set to 1, and the receive state machine is idle, the receive machine becomes active. This bit will read back as 1 whenever the receive state machine is active. After initial power-up, software must ensure that the receiver has completely reset before setting this bit. 1: Enable 0: Disable Default: 0b. */
-#define BIT_MACTXEN                                ((u32)0x00000001 << 6)          /*!<R/W 0  MAC Transmitter Enable. When set to 1, and the transmit state machine is idle, the transmit state machine becomes active. This bit will read back as 1 whenever the transmit state machine is active. After initial power-up, software must ensure that the transmitter has completely reset before setting this bit. 1: Enable 0: Disable Default: 0b. */
-#define BIT_SCHEDULE_EN                            ((u32)0x00000001 << 5)          /*!<R/W 0  Schedule Enable. */
-#define BIT_PROTOCOL_EN                            ((u32)0x00000001 << 4)          /*!<R/W 0  protocol Block Function Enable.（FW2HW) */
-#define BIT_RXDMA_EN                               ((u32)0x00000001 << 3)          /*!<R/W 0  RXDMA Function Enable */
-#define BIT_TXDMA_EN                               ((u32)0x00000001 << 2)          /*!<R/W 0  TXDMA Function Enable */
-#define BIT_HCI_RXDMA_EN                           ((u32)0x00000001 << 1)          /*!<R/W 0  HCI to RXDMA Interface Enable */
-#define BIT_HCI_TXDMA_EN                           ((u32)0x00000001 << 0)          /*!<R/W 0  HCI to TXDMA Interface Enable */
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_TSF_CLK_STATE
- * @brief Beacon time reset value
- * @{
- *****************************************************************************/
-#define BIT_CLK_TSF_IS32K                          ((u32)0x00000001 << 15)          /*!<R 0  Which Clock is Used by TSF Clock 1: 32K Clock 0: MAC Clock */
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_TXDMA_PQ_MAP
- * @brief RX DMA Fuction enable
- * @{
- *****************************************************************************/
-#define BIT_MASK_TXDMA_CMQ_MAP                     ((u32)0x00000003 << 16)          /*!<R/W 0  00: Extra priority queue 01: Low priority queue 10: Normal priority queue 11: High priority queue */
-#define BIT_TXDMA_CMQ_MAP(x)                       ((u32)(((x) & 0x00000003) << 16))
-#define BIT_GET_TXDMA_CMQ_MAP(x)                   ((u32)(((x >> 16) & 0x00000003)))
-#define BIT_MASK_TXDMA_HIQ_MAP                     ((u32)0x00000003 << 14)          /*!<R/W 0  00: Extra priority queue 01: Low priority queue 10: Normal priority queue 11: High priority queue */
-#define BIT_TXDMA_HIQ_MAP(x)                       ((u32)(((x) & 0x00000003) << 14))
-#define BIT_GET_TXDMA_HIQ_MAP(x)                   ((u32)(((x >> 14) & 0x00000003)))
-#define BIT_MASK_TXDMA_MGQ_MAP                     ((u32)0x00000003 << 12)          /*!<R/W 0  00: Extra priority queue 01: Low priority queue 10: Normal priority queue 11: High priority queue */
-#define BIT_TXDMA_MGQ_MAP(x)                       ((u32)(((x) & 0x00000003) << 12))
-#define BIT_GET_TXDMA_MGQ_MAP(x)                   ((u32)(((x >> 12) & 0x00000003)))
-#define BIT_MASK_TXDMA_BKQ_MAP                     ((u32)0x00000003 << 10)          /*!<R/W 0  00: Extra priority queue 01: Low priority queue 10: Normal priority queue 11: High priority queue */
-#define BIT_TXDMA_BKQ_MAP(x)                       ((u32)(((x) & 0x00000003) << 10))
-#define BIT_GET_TXDMA_BKQ_MAP(x)                   ((u32)(((x >> 10) & 0x00000003)))
-#define BIT_MASK_TXDMA_BEQ_MAP                     ((u32)0x00000003 << 8)          /*!<R/W 0  00: Extra priority queue 01: Low priority queue 10: Normal priority queue 11: High priority queue */
-#define BIT_TXDMA_BEQ_MAP(x)                       ((u32)(((x) & 0x00000003) << 8))
-#define BIT_GET_TXDMA_BEQ_MAP(x)                   ((u32)(((x >> 8) & 0x00000003)))
-#define BIT_MASK_TXDMA_VIQ_MAP                     ((u32)0x00000003 << 6)          /*!<R/W 0  00: Extra priority queue 01: Low priority queue 10: Normal priority queue 11: High priority queue */
-#define BIT_TXDMA_VIQ_MAP(x)                       ((u32)(((x) & 0x00000003) << 6))
-#define BIT_GET_TXDMA_VIQ_MAP(x)                   ((u32)(((x >> 6) & 0x00000003)))
-#define BIT_MASK_TXDMA_VOQ_MAP                     ((u32)0x00000003 << 4)          /*!<R/W 0  00: Extra priority queue 01: Low priority queue 10: Normal priority queue 11: High priority queue */
-#define BIT_TXDMA_VOQ_MAP(x)                       ((u32)(((x) & 0x00000003) << 4))
-#define BIT_GET_TXDMA_VOQ_MAP(x)                   ((u32)(((x >> 4) & 0x00000003)))
-#define BIT_RXDMA_AGG_EN                           ((u32)0x00000001 << 2)          /*!<R/W 0  When this bit is set, then RXDMA will inform host to receive RX packets, when packet page number in RXFF exceeds the threshold set in RXDMA_AGG_PG_TH register. When this bit is set, then page size of receive packet buffer shall be set larger than 64 bytes/page */
-#define BIT_ENSHFT                                 ((u32)0x00000001 << 1)          /*!<R/W 0  When this bit is set, RX shift to fit alignment is enabled. */
-#define BIT_RXDMA_BW_EN                            ((u32)0x00000001 << 0)          /*!<R/W 0  Enable RXDMA Arbitrator priority for Host interface. */
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_TRXFF_BNDY
- * @brief FIFO Boundary control register
- * @{
- *****************************************************************************/
-#define BIT_MASK_RXPKT0ENDADDR                     ((u32)0x0000FFFF << 16)          /*!<R/W 0x3FFF  This register sets the upper boundary of RXFF0. The unit is 1 byte. The available memory space in RXPKTBUF for RXFF0 is configurable. The value is set to the physical LX bus address. */
-#define BIT_RXPKT0ENDADDR(x)                       ((u32)(((x) & 0x0000FFFF) << 16))
-#define BIT_GET_RXPKT0ENDADDR(x)                   ((u32)(((x >> 16) & 0x0000FFFF)))
-#define BIT_MASK_RXFFOVFL_RSV                      ((u32)0x0000000F << 8)          /*!<R/W 0xF  Use this register to set reserved entries number of rxpktbuffer for overflow judgment. The rxpktbuffer overflow will be pre-asserted if the left entries count meets the value set here. */
-#define BIT_RXFFOVFL_RSV(x)                        ((u32)(((x) & 0x0000000F) << 8))
-#define BIT_GET_RXFFOVFL_RSV(x)                    ((u32)(((x >> 8) & 0x0000000F)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_PTA_I2C_MBOX
- * @brief Status register
- * @{
- *****************************************************************************/
-#define BIT_MASK_I2C_M_STATUS                      ((u32)0x0000000F << 8)          /*!<R 0  Read these can get the I2C_M_STATUS of PTA_I2C's OUTPUT. */
-#define BIT_I2C_M_STATUS(x)                        ((u32)(((x) & 0x0000000F) << 8))
-#define BIT_GET_I2C_M_STATUS(x)                    ((u32)(((x >> 8) & 0x0000000F)))
-#define BIT_MASK_I2C_M_BUS_GNT_FW                  ((u32)0x00000007 << 4)          /*!<R/W 0  Use this bit to control PTA_I2C's BUS_GNT. 100 for gnt_txdata, 010 for gnt_txack, 001 for gnt_rxstatus. */
-#define BIT_I2C_M_BUS_GNT_FW(x)                    ((u32)(((x) & 0x00000007) << 4))
-#define BIT_GET_I2C_M_BUS_GNT_FW(x)                ((u32)(((x >> 4) & 0x00000007)))
-#define BIT_I2C_GNT_FW                             ((u32)0x00000001 << 3)          /*!<R/W 0  Use this bit to control PTA_I2C_GNT_FW input. 1 for FW I2C bus arbiter, 0 for HW as I2C bus arbiter. */
-#define BIT_MASK_I2C_M_SPEED                       ((u32)0x00000003 << 1)          /*!<R/W 0  Use these bit to control PTA_I2C I2C interface data rate. SCL = clk / 2^(3 + I2C_DATA_RATE) */
-#define BIT_I2C_M_SPEED(x)                         ((u32)(((x) & 0x00000003) << 1))
-#define BIT_GET_I2C_M_SPEED(x)                     ((u32)(((x >> 1) & 0x00000003)))
-#define BIT_I2C_M_UNLOCK                           ((u32)0x00000001 << 0)          /*!<R/W 0  If this bit is set, PTA_I2C use 118H and 119H to control PTA_I2C */
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_RXFF_PTR
- * @brief RX  FIFO Read/write pointer
- * @{
- *****************************************************************************/
-#define BIT_MASK_RXFF0_RDPTR                       ((u32)0x0000FFFF << 16)          /*!<R 0  The read pointer address of RXFF0. The value is set to the physical LX bus address. */
-#define BIT_RXFF0_RDPTR(x)                         ((u32)(((x) & 0x0000FFFF) << 16))
-#define BIT_GET_RXFF0_RDPTR(x)                     ((u32)(((x >> 16) & 0x0000FFFF)))
-#define BIT_MASK_RXFF0_WTPTR                       ((u32)0x0000FFFF << 0)          /*!<R 0  The write pointer address of RXFF0. The value is set to the physical LX bus address. */
-#define BIT_RXFF0_WTPTR(x)                         ((u32)(((x) & 0x0000FFFF) << 0))
-#define BIT_GET_RXFF0_WTPTR(x)                     ((u32)(((x >> 0) & 0x0000FFFF)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_FE1IMR
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_FS_NOT_BEACON_INT_EN                   ((u32)0x00000001 << 31)          /*!<R/W 0  not beacon packet interrupt */
-#define BIT_FS_BB_STOP_RX_INT_EN                   ((u32)0x00000001 << 29)          /*!<R/W 0  BB STOP RX interrupt */
-#define BIT_FS_TSF_GT_THRES_INT_EN                 ((u32)0x00000001 << 28)          /*!<R/W 0  The interrupt is issued when difference of tsft in beacon frame of port0 is greater than threshold */
-#define BIT_FS_RXPLCP_CHKOK_INT_EN                 ((u32)0x00000001 << 27)          /*!<R/W 0  RXPCLP check ok interrupt */
-#define BIT_FS_RXBCN_TIMEOUT_CNT_INT_EN            ((u32)0x00000001 << 26)          /*!<R/W 0  When this bit is enable, the interrupt is issued when RX beacon frame timeout occurs specified times in port0.specified by 0x17C[23:20] */
-#define BIT_FS_RXBCN_TIMEUP_INT_EN                 ((u32)0x00000001 << 25)          /*!<R/W 0  When this bit is enable, the interrupt is issued when RX beacon frame timeout occurs in port0. */
-#define BIT_FS_RX_BCN_ERR_P1_INT_EN                ((u32)0x00000001 << 24)          /*!<R/W 0  When this bit is enable, the interrupt is issued when RX beacon frame with fcs error occurs in port1. */
-#define BIT_FS_RX_BCN_ERR_P0_INT_EN                ((u32)0x00000001 << 23)          /*!<R/W 0  When this bit is enable, the interrupt is issued when RX beacon frame with fcs error occurs in port0. */
-#define BIT_FS_RX_BCN_P1_INT_EN                    ((u32)0x00000001 << 22)          /*!<R/W 0  When this bit is enable, the interrupt is issued when RX beacon frame occurs in port1. */
-#define BIT_FS_RX_BCN_P0_INT_EN                    ((u32)0x00000001 << 21)          /*!<R/W 0  When this bit is enable, the interrupt is issued when RX beacon frame occurs in port0. */
-#define BIT_FS_RX_UMD0_INT_EN                      ((u32)0x00000001 << 20)          /*!<R/W 0  The interrupt is issued while receiving unicast data frame with More Data=0 */
-#define BIT_FS_RX_UMD1_INT_EN                      ((u32)0x00000001 << 19)          /*!<R/W 0  The interrupt is issued while receiving unicast data frame with More Data=1 */
-#define BIT_FS_RX_BMD0_INT_EN                      ((u32)0x00000001 << 18)          /*!<R/W 0  The interrupt is issued while receiving broadcast data frame with More Data=0 */
-#define BIT_FS_RX_BMD1_INT_EN                      ((u32)0x00000001 << 17)          /*!<R/W 0  The interrupt is issued while receiving broadcast data frame with More Data=1 */
-#define BIT_FS_RXDONE0_INT_EN                      ((u32)0x00000001 << 16)          /*!<R/W 0  Rx Packet 0 done interrupt (for WOL release packet) */
-#define BIT_FS_WWLAN_INT_EN                        ((u32)0x00000001 << 15)          /*!<R/W 0  HW detect rxpkt Wol WLAN event interrupt */
-#define BIT_FS_SOUND_DONE_INT_EN                   ((u32)0x00000001 << 14)          /*!<R/W 0  Be a beamformer, this interrupt is issued at the time after sounding finish */
-#define BIT_FS_LP_STBY_INT_EN                      ((u32)0x00000001 << 13)          /*!<R/W 0  Lower Power Standby Interrupt */
-#define BIT_FS_BF1_PRETO_INT_EN                    ((u32)0x00000001 << 11)          /*!<R/W 0  BF1 pretimeout interrupt */
-#define BIT_FS_BF0_PRETO_INT_EN                    ((u32)0x00000001 << 10)          /*!<R/W 0  BF0 pretimeout interrupt */
-#define BIT_FS_PTCL_RELEASE_MACID_INT_EN           ((u32)0x00000001 << 9)          /*!<R/W 0  PTCL release macid interrupt */
-#define BIT_FS_PRETXERR_HANDLE_FSISR_INT_EN        ((u32)0x00000001 << 8)          /*!<R/W 0  PRETXERR_HANDLE FW Flag Interrupt register. */
-#define BIT_FS_WLBB_LOW_PRI_INT_EN                 ((u32)0x00000001 << 7)          /*!<R/W 0  ERROR happened in bb,not fatal */
-#define BIT_FS_WLBB_HIGH_PRI_INT_EN                ((u32)0x00000001 << 6)          /*!<R/W 0  fatal error happened in bb */
-#define BIT_FS_WLACTOFF_INT_EN                     ((u32)0x00000001 << 5)          /*!<R/W 0  WL_ACT_MASK_ON de-assertion for bt coexistence function interrupt */
-#define BIT_FS_WLACTON_INT_EN                      ((u32)0x00000001 << 4)          /*!<R/W 0  WL_ACT_MASK_ON assertion for bt coexistence function interrupt */
-#define BIT_FS_BTCMD_INT_EN                        ((u32)0x00000001 << 3)          /*!<R/W 0  the interrupt is issued when btcmd occurs. */
-#define BIT_FS_REG_MAILBOX_TO_I2C_INT_EN           ((u32)0x00000001 << 2)          /*!<R/W 0  Mailbox_TO_I2C_INT (BT bridge) */
-#define BIT_FS_TRPC_TO_INT_EN                      ((u32)0x00000001 << 1)          /*!<R/W 0  TRPC time out Interrupt */
-#define BIT_FS_RPC_O_T_INT_EN                      ((u32)0x00000001 << 0)          /*!<R/W 0  RPC over threshold Interrupt */
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_FE1ISR
- * @brief Firmware Extend Interrupt Status Register
- * @{
- *****************************************************************************/
-#define BIT_NOT_BEACON_INT                         ((u32)0x00000001 << 31)          /*!<RW1C 0  not beacon packet interrupt */
-#define BIT_FS_BB_STOP_RX_INT                      ((u32)0x00000001 << 29)          /*!<RW1C 0  BB STOP RX interrupt */
-#define BIT_FS_TSF_GT_THRES_INT                    ((u32)0x00000001 << 28)          /*!<RW1C 0  The interrupt is issued when difference of tsft in beacon frame is greater than threshold */
-#define BIT_FS_RXPLCP_CHKOK_INT                    ((u32)0x00000001 << 27)          /*!<RW1C 0  RXPCLP check ok interrupt */
-#define BIT_FS_RXBCN_TIMEOUT_CNT_INT               ((u32)0x00000001 << 26)          /*!<RW1C 0  When this bit is enable, the interrupt is issued when RX beacon frame timeout occurs specified times in port0.specified by 0x17C[23:20] */
-#define BIT_FS_RXBCN_TIMEUP_INT                    ((u32)0x00000001 << 25)          /*!<RW1C 0  When this bit is enable, the interrupt is issued when RX beacon frame timeout occurs in port0. */
-#define BIT_FS_RX_BCN_ERR_P1_INT                   ((u32)0x00000001 << 24)          /*!<RW1C 0  When this bit is enable, the interrupt is issued when RX beacon frame with fcs error occurs in port1. */
-#define BIT_FS_RX_BCN_ERR_P0_INT                   ((u32)0x00000001 << 23)          /*!<RW1C 0  When this bit is enable, the interrupt is issued when RX beacon frame with fcs error occurs in port0. */
-#define BIT_FS_RX_BCN_P1_INT                       ((u32)0x00000001 << 22)          /*!<RW1C 0  When this bit is enable, the interrupt is issued when RX beacon frame occurs in port1. */
-#define BIT_FS_RX_BCN_P0_INT                       ((u32)0x00000001 << 21)          /*!<RW1C 0  When this bit is enable, the interrupt is issued when RX beacon frame occurs in port0. */
-#define BIT_FS_RX_UMD0_INT                         ((u32)0x00000001 << 20)          /*!<RW1C 0  The interrupt is issued while receiving unicast data frame with More Data=0 */
-#define BIT_FS_RX_UMD1_INT                         ((u32)0x00000001 << 19)          /*!<RW1C 0  The interrupt is issued while receiving unicast data frame with More Data=1 */
-#define BIT_FS_RX_BMD0_INT                         ((u32)0x00000001 << 18)          /*!<RW1C 0  The interrupt is issued while receiving broadcast data frame with More Data=0 */
-#define BIT_FS_RX_BMD1_INT                         ((u32)0x00000001 << 17)          /*!<RW1C 0  The interrupt is issued while receiving broadcast data frame with More Data=1 */
-#define BIT_FS_RXDONE0_INT                         ((u32)0x00000001 << 16)          /*!<RW1C 0  Rx Packet 0 done interrupt (for WOL release packet) */
-#define BIT_FS_WWLAN_INT                           ((u32)0x00000001 << 15)          /*!<RW1C 0  HW detect rxpkt Wol WLAN event interrupt */
-#define BIT_FS_SOUND_DONE_INT                      ((u32)0x00000001 << 14)          /*!<RW1C 0  Be a beamformer, this interrupt is issued at the time after sounding finish */
-#define BIT_FS_LP_STBY_INT                         ((u32)0x00000001 << 13)          /*!<RW1C 0  Lower Power Standby Interrupt */
-#define BIT_FS_BF1_PRETO_INT                       ((u32)0x00000001 << 11)          /*!<RW1C 0  BF1 pretimeout interrupt */
-#define BIT_FS_BF0_PRETO_INT                       ((u32)0x00000001 << 10)          /*!<RW1C 0  BF0 pretimeout interrupt */
-#define BIT_FS_PTCL_RELEASE_MACID_INT              ((u32)0x00000001 << 9)          /*!<RW1C 0  PTCL release macid interrupt */
-#define BIT_FS_PRETXERR_HANDLE_FSISR_INT           ((u32)0x00000001 << 8)          /*!<RW1C 0  PRETXERR_HANDLE FW Flag Interrupt register. */
-#define BIT_FS_WLBB_LOW_PRI_INT                    ((u32)0x00000001 << 7)          /*!<RW1C 0  ERROR happened in bb,not fatal */
-#define BIT_FS_WLBB_HIGH_PRI_INT                   ((u32)0x00000001 << 6)          /*!<RW1C 0  fatal error happened in bb */
-#define BIT_FS_WLACTOFF_INT                        ((u32)0x00000001 << 5)          /*!<RW1C 0  WL_ACT_MASK_ON de-assertion for bt coexistence function interrupt */
-#define BIT_FS_WLACTON_INT                         ((u32)0x00000001 << 4)          /*!<RW1C 0  WL_ACT_MASK_ON assertion for bt coexistence function interrupt */
-#define BIT_FS_BTCMD_INT                           ((u32)0x00000001 << 3)          /*!<RW1C 0  the interrupt is issued when btcmd occurs. */
-#define BIT_FS_REG_MAILBOX_TO_I2C_INT              ((u32)0x00000001 << 2)          /*!<RW1C 0  Mailbox_TO_I2C_INT (BT bridge) */
-#define BIT_FS_TRPC_TO_INT                         ((u32)0x00000001 << 1)          /*!<RW1C 0  tx/rx pkt time out Interrupt */
-#define BIT_FS_RPC_O_T_INT                         ((u32)0x00000001 << 0)          /*!<RW1C 0  RXPKT counter over threshold Interrupt */
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_FWIMR
- * @brief Firmware Interrupt Mask Register
- * @{
- *****************************************************************************/
-#define BIT_FS_TXBCNOK_MB7_INT_EN                  ((u32)0x00000001 << 31)          /*!<R/W 0  MBSSID7 TX beacon OK interrupt */
-#define BIT_FS_TXBCNOK_MB6_INT_EN                  ((u32)0x00000001 << 30)          /*!<R/W 0  MBSSID6 TX beacon OK interrupt */
-#define BIT_FS_TXBCNOK_MB5_INT_EN                  ((u32)0x00000001 << 29)          /*!<R/W 0  MBSSID5 TX beacon OK interrupt */
-#define BIT_FS_TXBCNOK_MB4_INT_EN                  ((u32)0x00000001 << 28)          /*!<R/W 0  MBSSID4 TX beacon OK interrupt */
-#define BIT_FS_TXBCNOK_MB3_INT_EN                  ((u32)0x00000001 << 27)          /*!<R/W 0  MBSSID3 TX beacon OK interrupt */
-#define BIT_FS_TXBCNOK_MB2_INT_EN                  ((u32)0x00000001 << 26)          /*!<R/W 0  MBSSID2 TX beacon OK interrupt */
-#define BIT_FS_TXBCNOK_MB1_INT_EN                  ((u32)0x00000001 << 25)          /*!<R/W 0  MBSSID1 TX beacon OK interrupt */
-#define BIT_FS_TXBCNOK_MB0_INT_EN                  ((u32)0x00000001 << 24)          /*!<R/W 0  MBSSID0 TX beacon OK interrupt */
-#define BIT_FS_TXBCNERR_MB7_INT_EN                 ((u32)0x00000001 << 23)          /*!<R/W 0  MBSSID7 TX beacon Error interrupt */
-#define BIT_FS_TXBCNERR_MB6_INT_EN                 ((u32)0x00000001 << 22)          /*!<R/W 0  MBSSID6 TX beacon Error interrupt */
-#define BIT_FS_TXBCNERR_MB5_INT_EN                 ((u32)0x00000001 << 21)          /*!<R/W 0  MBSSID5 TX beacon Error interrupt */
-#define BIT_FS_TXBCNERR_MB4_INT_EN                 ((u32)0x00000001 << 20)          /*!<R/W 0  MBSSID4 TX beacon Error interrupt */
-#define BIT_FS_TXBCNERR_MB3_INT_EN                 ((u32)0x00000001 << 19)          /*!<R/W 0  MBSSID3 TX beacon Error interrupt */
-#define BIT_FS_TXBCNERR_MB2_INT_EN                 ((u32)0x00000001 << 18)          /*!<R/W 0  MBSSID2 TX beacon Error interrupt */
-#define BIT_FS_TXBCNERR_MB1_INT_EN                 ((u32)0x00000001 << 17)          /*!<R/W 0  MBSSID1 TX beacon Error interrupt */
-#define BIT_FS_TXBCNERR_MB0_INT_EN                 ((u32)0x00000001 << 16)          /*!<R/W 0  MBSSID0 TX beacon Error interrupt */
-#define BIT_FS_CPUMGN_POLLED_PKT_DONE_INT_EN       ((u32)0x00000001 << 15)          /*!<R/W 0  CPU management queue polled packet released done interrupt enable (check cpu management queue current flow) */
-#define BIT_FS_MGNTQ_FF_RELEASE_INT_EN             ((u32)0x00000001 << 13)          /*!<R/W 0  MgntQ ReadPtr FIFO release interrupt (for 8822B) */
-#define BIT_FS_CPUMGQ_ERR_INT_EN                   ((u32)0x00000001 << 11)          /*!<R/W 0  CPU management queue polled packet not TX OK while new packet comes in, enable to issue interrupt or not */
-#define BIT_FS_DDMA0_LP_INT_EN                     ((u32)0x00000001 << 9)          /*!<R/W 0  Low priority ddma0 down interrupt . */
-#define BIT_FS_DDMA0_HP_INT_EN                     ((u32)0x00000001 << 8)          /*!<R/W 0  High priority ddma0 down interrupt */
-#define BIT_FS_TXRPT_INT_EN                        ((u32)0x00000001 << 7)          /*!<R/W 0  TX report interrupt */
-#define BIT_FS_C2H_W_READY_INT_EN                  ((u32)0x00000001 << 6)          /*!<R/W 0  C2H register ready for write interrupt */
-#define BIT_FS_HRCV_INT_EN                         ((u32)0x00000001 << 5)          /*!<R/W 0  Host to CPU Message Interrupt, generated on writing to 0x1CF */
-#define BIT_FS_H2CCMD_INT_EN                       ((u32)0x00000001 << 4)          /*!<R/W 0  Host To CPU Message Interrupt */
-#define BIT_FS_TX_CLOSE_INT_EN                     ((u32)0x00000001 << 3)          /*!<R/W 0  TX DONE INTERRUPT */
-#define BIT_FS_ERRORHDL_INT_EN                     ((u32)0x00000001 << 2)          /*!<R/W 0  FWHW/ TXDMA/ RXDMA/ WMAC error status interrupt(0x210[31:0], 0x288[31:0], 0x4E2[15:0], 0x6B8[31:0]). WMAC error state will be recovered by HW, the others won't. */
-#define BIT_FS_TXCCX_INT_EN                        ((u32)0x00000001 << 1)          /*!<R/W 0  CCX PKT TX Report Interrupt */
-#define BIT_FS_PTCL_HANDLE_OK_INT_EN               ((u32)0x00000001 << 0)          /*!<R/W 0  TX Finish (Ack/BA process Finish) Interrupt. */
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_FWISR
- * @brief Firmware Interrupt Status Register
- * @{
- *****************************************************************************/
-#define BIT_FS_TXBCNOK_MB7_INT                     ((u32)0x00000001 << 31)          /*!<RW1C 0  MBSSID7 TX beacon OK interrupt */
-#define BIT_FS_TXBCNOK_MB6_INT                     ((u32)0x00000001 << 30)          /*!<RW1C 0  MBSSID6 TX beacon OK interrupt */
-#define BIT_FS_TXBCNOK_MB5_INT                     ((u32)0x00000001 << 29)          /*!<RW1C 0  MBSSID5 TX beacon OK interrupt */
-#define BIT_FS_TXBCNOK_MB4_INT                     ((u32)0x00000001 << 28)          /*!<RW1C 0  MBSSID4 TX beacon OK interrupt */
-#define BIT_FS_TXBCNOK_MB3_INT                     ((u32)0x00000001 << 27)          /*!<RW1C 0  MBSSID3 TX beacon OK interrupt */
-#define BIT_FS_TXBCNOK_MB2_INT                     ((u32)0x00000001 << 26)          /*!<RW1C 0  MBSSID2 TX beacon OK interrupt */
-#define BIT_FS_TXBCNOK_MB1_INT                     ((u32)0x00000001 << 25)          /*!<RW1C 0  MBSSID1 TX beacon OK interrupt */
-#define BIT_FS_TXBCNOK_MB0_INT                     ((u32)0x00000001 << 24)          /*!<RW1C 0  MBSSID0 TX beacon OK interrupt */
-#define BIT_FS_TXBCNERR_MB7_INT                    ((u32)0x00000001 << 23)          /*!<RW1C 0  MBSSID7 TX beacon Error interrupt */
-#define BIT_FS_TXBCNERR_MB6_INT                    ((u32)0x00000001 << 22)          /*!<RW1C 0  MBSSID6 TX beacon Error interrupt */
-#define BIT_FS_TXBCNERR_MB5_INT                    ((u32)0x00000001 << 21)          /*!<RW1C 0  MBSSID5 TX beacon Error interrupt */
-#define BIT_FS_TXBCNERR_MB4_INT                    ((u32)0x00000001 << 20)          /*!<RW1C 0  MBSSID4 TX beacon Error interrupt */
-#define BIT_FS_TXBCNERR_MB3_INT                    ((u32)0x00000001 << 19)          /*!<RW1C 0  MBSSID3 TX beacon Error interrupt */
-#define BIT_FS_TXBCNERR_MB2_INT                    ((u32)0x00000001 << 18)          /*!<RW1C 0  MBSSID2 TX beacon Error interrupt */
-#define BIT_FS_TXBCNERR_MB1_INT                    ((u32)0x00000001 << 17)          /*!<RW1C 0  MBSSID1 TX beacon Error interrupt */
-#define BIT_FS_TXBCNERR_MB0_INT                    ((u32)0x00000001 << 16)          /*!<RW1C 0  MBSSID0 TX beacon Error interrupt */
-#define BIT_FS_CPUMGN_POLLED_PKT_DONE_INT          ((u32)0x00000001 << 15)          /*!<RW1C 0  CPU management queue polled packet released done interrupt enable (check cpu management queue current flow) */
-#define BIT_FS_MGNTQ_FF_RELEASE_INT                ((u32)0x00000001 << 13)          /*!<RW1C 0  MgntQ ReadPtr FIFO release interrupt (for 8822B) */
-#define BIT_FS_CPUMGQ_ERR_INT                      ((u32)0x00000001 << 11)          /*!<RW1C 0  CPU management queue polled packet not TX OK while new packet comes in, enable to issue interrupt or not */
-#define BIT_FS_DDMA0_LP_INT                        ((u32)0x00000001 << 9)          /*!<RW1C 0  Low priority ddma0 down interrupt . */
-#define BIT_FS_DDMA0_HP_INT                        ((u32)0x00000001 << 8)          /*!<RW1C 0  High priority ddma0 down interrupt */
-#define BIT_FS_TXRPT_INT                           ((u32)0x00000001 << 7)          /*!<RW1C 0  TX report interrupt */
-#define BIT_FS_C2H_W_READY_INT                     ((u32)0x00000001 << 6)          /*!<RW1C 0  C2H register ready for write interrupt */
-#define BIT_FS_HRCV_INT                            ((u32)0x00000001 << 5)          /*!<RW1C 0  Host to CPU Message Interrupt, generated on writing to 0x1CF */
-#define BIT_FS_H2CCMD_INT                          ((u32)0x00000001 << 4)          /*!<RW1C 0  Host To CPU Message Interrupt */
-#define BIT_FS_TX_CLOSE_INT                        ((u32)0x00000001 << 3)          /*!<RW1C 0  TX DONE INTERRUPT */
-#define BIT_FS_ERRORHDL_INT                        ((u32)0x00000001 << 2)          /*!<RW1C 0  FWHW/ TXDMA/ RXDMA/ WMAC error status interrupt(0x210[31:0], 0x288[31:0], 0x4E2[15:0], 0x6B8[31:0]). WMAC error state will be recovered by HW, the others won't. */
-#define BIT_FS_TXCCX_INT                           ((u32)0x00000001 << 1)          /*!<RW1C 0  CCX PKT TX Report Interrupt */
-#define BIT_FS_PTCL_HANDLE_OK_INT                  ((u32)0x00000001 << 0)          /*!<RW1C 0  TX Finish (Ack/BA process Finish) Interrupt. */
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_FTIMR
- * @brief Firmware  Timer Interrupt Mask Register
- * @{
- *****************************************************************************/
-#define BIT_FTSR1_INT_EN                           ((u32)0x00000001 << 31)          /*!<R/W 0  FTMR1 Indicator (FTMR1 and FTMR1 are true, this bit is set to 1) */
-#define BIT_FTSR2_INT_EN                           ((u32)0x00000001 << 30)          /*!<R/W 0  FTMR2 Indicator (FTMR2 and FTMR2 are true, this bit is set to 1) */
-#define BIT_FS_RPWM_INT_EN                         ((u32)0x00000001 << 28)          /*!<R/W 0  RPWM interrupt */
-#define BIT_FS_PS_TIMER_E_INT_EN                   ((u32)0x00000001 << 27)          /*!<R/W 0  PS_Timer_E interrupt When the TSF(that select by reg 0x1520[13:12]) matches the content of this register, the PS_Timer_E_INT interrupt is issued */
-#define BIT_FS_PS_TIMER_D_INT_EN                   ((u32)0x00000001 << 26)          /*!<R/W 0  PS_Timer_D interrupt When the lower 4 bytes of TSF(that select by reg 0x1520[17:16]) matches the content of this register, the PS_Timer_D_INT interrupt is issued */
-#define BIT_FS_PS_TIMER_E_EARLY_INT_EN             ((u32)0x00000001 << 25)          /*!<R/W 0  This interrupt is issued at the time set by PS_Timer_E_Early register before PS_Timer_E time. */
-#define BIT_FS_PS_TIMER_D_EARLY_INT_EN             ((u32)0x00000001 << 24)          /*!<R/W 0  This interrupt is issued at the time set by PS_Timer_D_Early register before PS_Timer_D time. */
-#define BIT_FS_PS_TIMER_C_EARLY_INT_EN             ((u32)0x00000001 << 23)          /*!<R/W 0  This interrupt is issued at the time set by PS_Timer_C_Early register before PS_Timer_C time. */
-#define BIT_FS_PS_TIMER_B_EARLY_INT_EN             ((u32)0x00000001 << 22)          /*!<R/W 0  This interrupt is issued at the time set by PS_Timer_B_Early register before PS_Timer_B time. */
-#define BIT_FS_PS_TIMER_A_EARLY_INT_EN             ((u32)0x00000001 << 21)          /*!<R/W 0  This interrupt is issued at the time set by PS_Timer_A_Early register before PS_Timer_A time. */
-#define BIT_FS_PS_TIMER_C_INT_EN                   ((u32)0x00000001 << 19)          /*!<R/W 0  PS_Timer_C interrupt When the lower 4 bytes of TSF(that select by reg 0x1510[18:16]) matches the content of this register, the PS_Timer_C_INT interrupt is issued */
-#define BIT_FS_PS_TIMER_B_INT_EN                   ((u32)0x00000001 << 18)          /*!<R/W 0  PS_Timer_B interrupt When the lower 4 bytes of TSF(that select by reg 0x1510[10:8]) matches the content of this register, the PS_Timer_B_INT interrupt is issued */
-#define BIT_FS_PS_TIMER_A_INT_EN                   ((u32)0x00000001 << 17)          /*!<R/W 0  PS_Timer_A interrupt When the lower 4 bytes of TSF(that select by reg 0x1510[2:0]) matches the content of this register, the PS_Timer_A_INT interrupt is issued */
-#define BIT_FS_PS_TIMEOUT2_INT_EN                  ((u32)0x00000001 << 15)          /*!<R/W 0  PS_TimeOut2 interrupt . When the lower 4 bytes of FREERUN CNT matches the content of this register(0x588), the FW PS_TimeOut2 interrupt is issued. */
-#define BIT_FS_PS_TIMEOUT1_INT_EN                  ((u32)0x00000001 << 14)          /*!<R/W 0  PS_TimeOut1 interrupt . When the lower 4 bytes of TSFTR(that select by 0x5b1[5:3]) matches the content of this register(0x584), the FW PS_TimeOut1 interrupt is issued. */
-#define BIT_FS_PS_TIMEOUT0_INT_EN                  ((u32)0x00000001 << 13)          /*!<R/W 0  PS_TimeOut0 interrupt . When the lower 4 bytes of TSFTR(that select by 0x5b4[2:0]) matches the content of this register(0x580), the FW PS_TimeOut0 interrupt is issued. */
-#define BIT_FS_FTM_PTT_INT_EN                      ((u32)0x00000001 << 7)          /*!<R/W 0  Partial tsf timer */
-#define BIT_FS_GTINT6_INT_EN                       ((u32)0x00000001 << 6)          /*!<R/W 0  General Timer[6] interrupt */
-#define BIT_FS_GTINT5_INT_EN                       ((u32)0x00000001 << 5)          /*!<R/W 0  General Timer[5] interrupt */
-#define BIT_FS_GTINT4_INT_EN                       ((u32)0x00000001 << 4)          /*!<R/W 0  General Timer[4] interrupt */
-#define BIT_FS_GTINT3_INT_EN                       ((u32)0x00000001 << 3)          /*!<R/W 0  General Timer[3] interrupt */
-#define BIT_FS_GTINT2_INT_EN                       ((u32)0x00000001 << 2)          /*!<R/W 0  General Timer[2] interrupt */
-#define BIT_FS_GTINT1_INT_EN                       ((u32)0x00000001 << 1)          /*!<R/W 0  General Timer[1] interrupt */
-#define BIT_FS_GTINT0_INT_EN                       ((u32)0x00000001 << 0)          /*!<R/W 0  General Timer[0] interrupt */
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_FTISR
- * @brief Firmware Timer Interrupt Status Register
- * @{
- *****************************************************************************/
-#define BIT_FTSR1_INT                              ((u32)0x00000001 << 31)          /*!<RW1C 0  FTMR1 Indicator (FTMR1 and FTMR1 are true, this bit is set to 1) */
-#define BIT_FTSR2_INT                              ((u32)0x00000001 << 30)          /*!<RW1C 0  FTMR2 Indicator (FTMR2 and FTMR2 are true, this bit is set to 1) */
-#define BIT_FS_RPWM_INT                            ((u32)0x00000001 << 28)          /*!<RW1C 0  RPWM interrupt */
-#define BIT_FS_PS_TIMER_E_INT                      ((u32)0x00000001 << 27)          /*!<RW1C 0  PS_Timer_E interrupt When the TSF(that select by reg 0x1520[13:12]) matches the content of this register, the PS_Timer_E_INT interrupt is issued */
-#define BIT_FS_PS_TIMER_D_INT                      ((u32)0x00000001 << 26)          /*!<RW1C 0  PS_Timer_D interrupt When the lower 4 bytes of TSF(that select by reg 0x1520[17:16]) matches the content of this register, the PS_Timer_D_INT interrupt is issued */
-#define BIT_FS_PS_TIMER_E_EARLY_INT                ((u32)0x00000001 << 25)          /*!<RW1C 0  This interrupt is issued at the time set by PS_Timer_E_Early register before PS_Timer_E time. */
-#define BIT_FS_PS_TIMER_D_EARLY_INT                ((u32)0x00000001 << 24)          /*!<RW1C 0  This interrupt is issued at the time set by PS_Timer_D_Early register before PS_Timer_D time. */
-#define BIT_FS_PS_TIMER_C_EARLY_INT                ((u32)0x00000001 << 23)          /*!<RW1C 0  This interrupt is issued at the time set by PS_Timer_C_Early register before PS_Timer_C time. */
-#define BIT_FS_PS_TIMER_B_EARLY_INT                ((u32)0x00000001 << 22)          /*!<RW1C 0  This interrupt is issued at the time set by PS_Timer_B_Early register before PS_Timer_B time. */
-#define BIT_FS_PS_TIMER_A_EARLY_INT                ((u32)0x00000001 << 21)          /*!<RW1C 0  This interrupt is issued at the time set by PS_Timer_A_Early register before PS_Timer_A time. */
-#define BIT_FS_PS_TIMER_C_INT                      ((u32)0x00000001 << 19)          /*!<RW1C 0  PS_Timer_C interrupt When the lower 4 bytes of TSF(that select by reg 0x1510[18:16]) matches the content of this register, the PS_Timer_C_INT interrupt is issued */
-#define BIT_FS_PS_TIMER_B_INT                      ((u32)0x00000001 << 18)          /*!<RW1C 0  PS_Timer_B interrupt When the lower 4 bytes of TSF(that select by reg 0x1510[10:8]) matches the content of this register, the PS_Timer_B_INT interrupt is issued */
-#define BIT_FS_PS_TIMER_A_INT                      ((u32)0x00000001 << 17)          /*!<RW1C 0  PS_Timer_A interrupt When the lower 4 bytes of TSF(that select by reg 0x1510[2:0]) matches the content of this register, the PS_Timer_A_INT interrupt is issued */
-#define BIT_FS_PS_TIMEOUT2_INT                     ((u32)0x00000001 << 15)          /*!<RW1C 0  PS_TimeOut2 interrupt . When the lower 4 bytes of FREERUN CNT matches the content of this register(0x588), the FW PS_TimeOut2 interrupt is issued. */
-#define BIT_FS_PS_TIMEOUT1_INT                     ((u32)0x00000001 << 14)          /*!<RW1C 0  PS_TimeOut1 interrupt . When the lower 4 bytes of TSFTR(that select by 0x5b1[5:3]) matches the content of this register(0x584), the FW PS_TimeOut1 interrupt is issued. */
-#define BIT_FS_PS_TIMEOUT0_INT                     ((u32)0x00000001 << 13)          /*!<RW1C 0  PS_TimeOut0 interrupt . When the lower 4 bytes of TSFTR(that select by 0x5b4[2:0]) matches the content of this register(0x580), the FW PS_TimeOut0 interrupt is issued. */
-#define BIT_FS_FTM_PTT_INT                         ((u32)0x00000001 << 7)          /*!<RW1C 0  Partial tsf timer */
-#define BIT_FS_GTINT6_INT                          ((u32)0x00000001 << 6)          /*!<RW1C 0  General Timer[6] interrupt */
-#define BIT_FS_GTINT5_INT                          ((u32)0x00000001 << 5)          /*!<RW1C 0  General Timer[5] interrupt */
-#define BIT_FS_GTINT4_INT                          ((u32)0x00000001 << 4)          /*!<RW1C 0  General Timer[4] interrupt */
-#define BIT_FS_GTINT3_INT                          ((u32)0x00000001 << 3)          /*!<RW1C 0  General Timer[3] interrupt */
-#define BIT_FS_GTINT2_INT                          ((u32)0x00000001 << 2)          /*!<RW1C 0  General Timer[2] interrupt */
-#define BIT_FS_GTINT1_INT                          ((u32)0x00000001 << 1)          /*!<RW1C 0  General Timer[1] interrupt */
-#define BIT_FS_GTINT0_INT                          ((u32)0x00000001 << 0)          /*!<RW1C 0  General Timer[0] interrupt */
-/** @} */
-
-/** @defgroup REG_PHYSTS_REL
- * @brief PHYSTS REALSE
- * @{
- **/
-#define BIT_MASK_PHY_STS_STR                       ((u32)0x000000FF << 24)          /*!<R/W 0  physts start read address,8 bytes unit */
-#define BIT_PHY_STS_STR(x)                         ((u32)(((x) & 0x000000FF) << 24))
-#define BIT_GET_PHY_STS_STR(x)                     ((u32)(((x >> 24) & 0x000000FF)))
-#define BIT_MASK_PHY_STS_NUM                       ((u32)0x000000FF << 16)          /*!<R/W 0  physts packet number in physts buffer */
-#define BIT_PHY_STS_NUM(x)                         ((u32)(((x) & 0x000000FF) << 16))
-#define BIT_GET_PHY_STS_NUM(x)                     ((u32)(((x >> 16) & 0x000000FF)))
-#define BIT_PHY_SYS_POLL                           ((u32)0x00000001 << 0)          /*!<R/W 0  physts release polling,when polling done,write the bit to 0 */
-/** @} */
-
-/** @defgroup REG_CHANNEL_INFO_REL
- * @brief CHANNEL INFO REALSE
- * @{
- **/
-#define BIT_MASK_CHINFO_STR                        ((u32)0x000000FF << 24)          /*!<R/W 0  channel info start read address,8 bytes unit */
-#define BIT_CHINFO_STR(x)                          ((u32)(((x) & 0x000000FF) << 24))
-#define BIT_GET_CHINFO_STR(x)                      ((u32)(((x >> 24) & 0x000000FF)))
-#define BIT_MASK_CHINFO_NUM                        ((u32)0x000000FF << 16)          /*!<R/W 0  channel info packet number in csi buffer */
-#define BIT_CHINFO_NUM(x)                          ((u32)(((x) & 0x000000FF) << 16))
-#define BIT_GET_CHINFO_NUM(x)                      ((u32)(((x >> 16) & 0x000000FF)))
-#define BIT_CHINFO_POLL                            ((u32)0x00000001 << 0)          /*!<R/W 0  channel info release polling,when polling done,write the bit to 0 */
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_TC0_CTRL
- * @brief Counter 0 data
- * @{
- *****************************************************************************/
-#define BIT_TC0INT_EN                              ((u32)0x00000001 << 26)          /*!<R/W 0  When write “1” to this bit, Counter 0 starts counting down. This is a one-bit pulse. */
-#define BIT_TC0MODE                                ((u32)0x00000001 << 25)          /*!<R/W 0  Timer/Counter 0 mode 0=counter mode 1=timer mode */
-#define BIT_TC0EN                                  ((u32)0x00000001 << 24)          /*!<R/W 0  Timer/Counter 0 enable */
-#define BIT_MASK_TC0DATA                           ((u32)0x00FFFFFF << 0)          /*!<R/W 0  Timer/Counter 0 data register. It specifies the time-out duration. */
-#define BIT_TC0DATA(x)                             ((u32)(((x) & 0x00FFFFFF) << 0))
-#define BIT_GET_TC0DATA(x)                         ((u32)(((x >> 0) & 0x00FFFFFF)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_TC1_CTRL
- * @brief Counter 1 data
- * @{
- *****************************************************************************/
-#define BIT_TC1INT_EN                              ((u32)0x00000001 << 26)          /*!<R/W 0  When write “1” to this bit, Counter 1 starts counting down. This is a one-bit pulse. */
-#define BIT_TC1MODE                                ((u32)0x00000001 << 25)          /*!<R/W 0  Timer/Counter 1 mode 0=counter mode 1=timer mode */
-#define BIT_TC1EN                                  ((u32)0x00000001 << 24)          /*!<R/W 0  Timer/Counter 1 enable */
-#define BIT_MASK_TC1DATA                           ((u32)0x00FFFFFF << 0)          /*!<R/W 0  Timer/Counter 1 data register. It specifies the time-out duration. */
-#define BIT_TC1DATA(x)                             ((u32)(((x) & 0x00FFFFFF) << 0))
-#define BIT_GET_TC1DATA(x)                         ((u32)(((x >> 0) & 0x00FFFFFF)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_TC2_CTRL
- * @brief Counter 2 data
- * @{
- *****************************************************************************/
-#define BIT_TC2INT_EN                              ((u32)0x00000001 << 26)          /*!<R/W 0  When write “1” to this bit, Counter 2 starts counting down. This is a one-bit pulse. */
-#define BIT_TC2MODE                                ((u32)0x00000001 << 25)          /*!<R/W 0  Timer/Counter 2 mode 0=counter mode 1=timer mode */
-#define BIT_TC2EN                                  ((u32)0x00000001 << 24)          /*!<R/W 0  Timer/Counter 2 enable */
-#define BIT_MASK_TC2DATA                           ((u32)0x00FFFFFF << 0)          /*!<R/W 0  Timer/Counter 2 data register. It specifies the time-out duration. */
-#define BIT_TC2DATA(x)                             ((u32)(((x) & 0x00FFFFFF) << 0))
-#define BIT_GET_TC2DATA(x)                         ((u32)(((x >> 0) & 0x00FFFFFF)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_TC3_CTRL
- * @brief Counter 3 data
- * @{
- *****************************************************************************/
-#define BIT_TC3INT_EN                              ((u32)0x00000001 << 26)          /*!<R/W 0  When write “1” to this bit, Counter 3 starts counting down. This is a one-bit pulse. */
-#define BIT_TC3MODE                                ((u32)0x00000001 << 25)          /*!<R/W 0  Timer/Counter 3 mode 0=counter mode 1=timer mode */
-#define BIT_TC3EN                                  ((u32)0x00000001 << 24)          /*!<R/W 0  Timer/Counter 3 enable */
-#define BIT_MASK_TC3DATA                           ((u32)0x00FFFFFF << 0)          /*!<R/W 0  Timer/Counter 3 data register. It specifies the time-out duration. */
-#define BIT_TC3DATA(x)                             ((u32)(((x) & 0x00FFFFFF) << 0))
-#define BIT_GET_TC3DATA(x)                         ((u32)(((x >> 0) & 0x00FFFFFF)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_TC4_CTRL
- * @brief Counter 4 data
- * @{
- *****************************************************************************/
-#define BIT_TC4INT_EN                              ((u32)0x00000001 << 26)          /*!<R/W 0  When write “1” to this bit, Counter 4 starts counting down. This is a one-bit pulse. */
-#define BIT_TC4MODE                                ((u32)0x00000001 << 25)          /*!<R/W 0  Timer/Counter 4mode 0=counter mode 1=timer mode */
-#define BIT_TC4EN                                  ((u32)0x00000001 << 24)          /*!<R/W 0  Timer/Counter 4 enable */
-#define BIT_MASK_TC4DATA                           ((u32)0x00FFFFFF << 0)          /*!<R/W 0  Timer/Counter 4 data register. It specifies the time-out duration. */
-#define BIT_TC4DATA(x)                             ((u32)(((x) & 0x00FFFFFF) << 0))
-#define BIT_GET_TC4DATA(x)                         ((u32)(((x >> 0) & 0x00FFFFFF)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_TCUNIT_BASE
- * @brief Control Register
- * @{
- *****************************************************************************/
-#define BIT_MASK_TC_UNIT_BASE                      ((u32)0x00003FFF << 0)          /*!<R/W 0  The register set the number of clocks that equals to the base time unit of timer/counter. The clock domain is 32k clock domain. */
-#define BIT_TC_UNIT_BASE(x)                        ((u32)(((x) & 0x00003FFF) << 0))
-#define BIT_GET_TC_UNIT_BASE(x)                    ((u32)(((x >> 0) & 0x00003FFF)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_TC5_CTRL
- * @brief Counter 5 data
- * @{
- *****************************************************************************/
-#define BIT_TC50INT_EN                             ((u32)0x00000001 << 26)          /*!<R/W 0  When write “1” to this bit, Counter 5 starts counting down. This is a one-bit pulse. */
-#define BIT_TC5MODE                                ((u32)0x00000001 << 25)          /*!<R/W 0  Timer/Counter 5 mode 0=counter mode 1=timer mode */
-#define BIT_TC5EN                                  ((u32)0x00000001 << 24)          /*!<R/W 0  Timer/Counter5 enable */
-#define BIT_MASK_TC5DATA                           ((u32)0x00FFFFFF << 0)          /*!<R/W 0  Timer/Counter 5 data register. It specifies the time-out duration. */
-#define BIT_TC5DATA(x)                             ((u32)(((x) & 0x00FFFFFF) << 0))
-#define BIT_GET_TC5DATA(x)                         ((u32)(((x >> 0) & 0x00FFFFFF)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_TC6_CTRL
- * @brief Counter 6 data
- * @{
- *****************************************************************************/
-#define BIT_TC60INT_EN                             ((u32)0x00000001 << 26)          /*!<R/W 0  When write “1” to this bit, Counter 6 starts counting down. This is a one-bit pulse. */
-#define BIT_TC6MODE                                ((u32)0x00000001 << 25)          /*!<R/W 0  Timer/Counter 6 mode 0=counter mode 1=timer mode */
-#define BIT_TC6EN                                  ((u32)0x00000001 << 24)          /*!<R/W 0  Timer/Counter6 enable */
-#define BIT_MASK_TC6DATA                           ((u32)0x00FFFFFF << 0)          /*!<R/W 0  Timer/Counter 6 data register. It specifies the time-out duration. */
-#define BIT_TC6DATA(x)                             ((u32)(((x) & 0x00FFFFFF) << 0))
-#define BIT_GET_TC6DATA(x)                         ((u32)(((x >> 0) & 0x00FFFFFF)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_HW_IOE_CR_CHN1
- * @brief HW IO Engine Configure Register_CHN1
- * @{
- *****************************************************************************/
-#define BIT_HIOE_ACTIVE_CHN1                       ((u32)0x00000001 << 31)          /*!<R 0  indicate HIOE engine is active */
-#define BIT_HIOE_RESTORE_REQ_CHN1                  ((u32)0x00000001 << 25)          /*!<R/W 0  WLOFF REG restore request, clear by hw */
-#define BIT_HIOE_BACKUP_REQ_CHN1                   ((u32)0x00000001 << 24)          /*!<R/W 0  WLOFF REG backup request, clear by hw */
-#define BIT_MASK_HIOE_END_ADDR_CHN1                ((u32)0x00000FFF << 12)          /*!<R/W 0  HIOE command end address in txpktbuffer, unit:8byte */
-#define BIT_HIOE_END_ADDR_CHN1(x)                  ((u32)(((x) & 0x00000FFF) << 12))
-#define BIT_GET_HIOE_END_ADDR_CHN1(x)              ((u32)(((x >> 12) & 0x00000FFF)))
-#define BIT_MASK_HIOE_STR_ADDR_CHN1                ((u32)0x00000FFF << 0)          /*!<R/W 0  HIOE command start address in txpktbuffer, unit:8byte */
-#define BIT_HIOE_STR_ADDR_CHN1(x)                  ((u32)(((x) & 0x00000FFF) << 0))
-#define BIT_GET_HIOE_STR_ADDR_CHN1(x)              ((u32)(((x >> 0) & 0x00000FFF)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_HW_IOE_CR_CHN_ON
- * @brief HW IO Engine Configure Register_CHN_ON
- * @{
- *****************************************************************************/
-#define BIT_HIOE_ACTIVE_CHN_ON                     ((u32)0x00000001 << 31)          /*!<R 0  indicate HIOE engine is active, used for wlan power on flow */
-#define BIT_HIOE_BYPASS_CHN_ON                     ((u32)0x00000001 << 26)          /*!<R/W 1  BYPASS HW trig hioe to do rf on flow */
-#define BIT_HIOE_RESTORE_REQ_CHN_ON                ((u32)0x00000001 << 25)          /*!<R 0  WLOFF REG restore request, clear by hw */
-#define BIT_MASK_HIOE_END_ADDR_CHN_ON              ((u32)0x00000FFF << 12)          /*!<R/W 0  HIOE command end address in txpktbuffer, unit:8byte */
-#define BIT_HIOE_END_ADDR_CHN_ON(x)                ((u32)(((x) & 0x00000FFF) << 12))
-#define BIT_GET_HIOE_END_ADDR_CHN_ON(x)            ((u32)(((x >> 12) & 0x00000FFF)))
-#define BIT_MASK_HIOE_STR_ADDR_CHN_ON              ((u32)0x00000FFF << 0)          /*!<R/W 0  HIOE command start address in txpktbuffer, unit:8byte */
-#define BIT_HIOE_STR_ADDR_CHN_ON(x)                ((u32)(((x) & 0x00000FFF) << 0))
-#define BIT_GET_HIOE_STR_ADDR_CHN_ON(x)            ((u32)(((x >> 0) & 0x00000FFF)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_HW_IOE_CR_CHN_OFF
- * @brief HW IO Engine Configure Register_CHN_OFF
- * @{
- *****************************************************************************/
-#define BIT_HIOE_ACTIVE_CHN_OFF                    ((u32)0x00000001 << 31)          /*!<R 0  indicate HIOE engine is active, used for wlan power off flow */
-#define BIT_HIOE_BYPASS_CHN_OFF                    ((u32)0x00000001 << 26)          /*!<R/W 1  BYPASS HW trig hioe to do rf off flow */
-#define BIT_HIOE_RESTORE_REQ_CHN_OFF               ((u32)0x00000001 << 25)          /*!<R 0  WLOFF REG restore request, clear by hw */
-#define BIT_MASK_HIOE_END_ADDR_CHN_OFF             ((u32)0x00000FFF << 12)          /*!<R/W 0  HIOE command end address in txpktbuffer, unit:8byte */
-#define BIT_HIOE_END_ADDR_CHN_OFF(x)               ((u32)(((x) & 0x00000FFF) << 12))
-#define BIT_GET_HIOE_END_ADDR_CHN_OFF(x)           ((u32)(((x >> 12) & 0x00000FFF)))
-#define BIT_MASK_HIOE_STR_ADDR_CHN_OFF             ((u32)0x00000FFF << 0)          /*!<R/W 0  HIOE command start address in txpktbuffer, unit:8byte */
-#define BIT_HIOE_STR_ADDR_CHN_OFF(x)               ((u32)(((x) & 0x00000FFF) << 0))
-#define BIT_GET_HIOE_STR_ADDR_CHN_OFF(x)           ((u32)(((x >> 0) & 0x00000FFF)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_RXBCN_TIMER
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_FS_HW_LPS_EN                           ((u32)0x00000001 << 31)          /*!<R/W 0  enable HW enter lps after hioe_off_int rise when BIT_FS_RXBCN_LPS_EN=1 */
-#define BIT_MASK_RXBCN_TIMEOUT_COUNT               ((u32)0x0000000F << 27)          /*!<R 0  rxbcn timeout counter */
-#define BIT_RXBCN_TIMEOUT_COUNT(x)                 ((u32)(((x) & 0x0000000F) << 27))
-#define BIT_GET_RXBCN_TIMEOUT_COUNT(x)             ((u32)(((x >> 27) & 0x0000000F)))
-#define BIT_FS_RXBCN_LPS_EN                        ((u32)0x00000001 << 26)          /*!<R/W 0  enable lps offload flow when rxbcn frame in port0 acting as a non-AP STA. */
-#define BIT_FS_WAIT_RXBCN_FINISH                   ((u32)0x00000001 << 25)          /*!<R/W 0  when rxbcn frame, turn off rf or generate interrupt ablout rxbcn after beacon fcs is parsered */
-#define BIT_RXBCN_TIMEOUT_COUNT_CLR                ((u32)0x00000001 << 24)          /*!<R/W 0  clear rxbcn timeout counter */
-#define BIT_MASK_RXBCN_TIMEOUT_COUNT_THRES         ((u32)0x0000000F << 20)          /*!<R/W 0x3  threshold for rxbcn timeout counter,when 0x17C[30:27] equals to this value,generate interrupt */
-#define BIT_RXBCN_TIMEOUT_COUNT_THRES(x)           ((u32)(((x) & 0x0000000F) << 20))
-#define BIT_GET_RXBCN_TIMEOUT_COUNT_THRES(x)       ((u32)(((x >> 20) & 0x0000000F)))
-#define BIT_MASK_RXBCN_TIMEOUT_THRES               ((u32)0x000FFFFF << 0)          /*!<R/W 0x1F40  threshold for rxbcn timeout,UNIT:us default：8ms */
-#define BIT_RXBCN_TIMEOUT_THRES(x)                 ((u32)(((x) & 0x000FFFFF) << 0))
-#define BIT_GET_RXBCN_TIMEOUT_THRES(x)             ((u32)(((x >> 0) & 0x000FFFFF)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_HW_IOE_CR_CH0
- * @brief HW IO Engine Configure Register_CH0
- * @{
- *****************************************************************************/
-#define BIT_HIOE_ACTIVE_CH0                        ((u32)0x00000001 << 31)          /*!<R 0  indicate HIOE engine is active */
-#define BIT_HIOE_RESTORE_REQ_CH0                   ((u32)0x00000001 << 25)          /*!<R/W 0  WLOFF REG restore request, clear by hw */
-#define BIT_HIOE_BACKUP_REQ_CH0                    ((u32)0x00000001 << 24)          /*!<R/W 0  WLOFF REG backup request, clear by hw */
-#define BIT_MASK_HIOE_END_ADDR_CH0                 ((u32)0x00000FFF << 12)          /*!<R/W 0  HIOE command end address in txpktbuffer, unit:8byte */
-#define BIT_HIOE_END_ADDR_CH0(x)                   ((u32)(((x) & 0x00000FFF) << 12))
-#define BIT_GET_HIOE_END_ADDR_CH0(x)               ((u32)(((x >> 12) & 0x00000FFF)))
-#define BIT_MASK_HIOE_STR_ADDR_CH0                 ((u32)0x00000FFF << 0)          /*!<R/W 0  HIOE command start address in txpktbuffer, unit:8byte */
-#define BIT_HIOE_STR_ADDR_CH0(x)                   ((u32)(((x) & 0x00000FFF) << 0))
-#define BIT_GET_HIOE_STR_ADDR_CH0(x)               ((u32)(((x >> 0) & 0x00000FFF)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_BB_RFC_ATR
- * @brief BB/RFC REG Access Time Register
- * @{
- *****************************************************************************/
-#define BIT_MASK_PHYRE_CNT                         ((u32)0x000000FF << 24)          /*!<R/W 0x07  the timing after RE for host/cpu access BB/RFC REG */
-#define BIT_PHYRE_CNT(x)                           ((u32)(((x) & 0x000000FF) << 24))
-#define BIT_GET_PHYRE_CNT(x)                       ((u32)(((x >> 24) & 0x000000FF)))
-#define BIT_MASK_PHYWR_SETUP_CNT                   ((u32)0x000000FF << 16)          /*!<R/W 0x05  the timing WDATA stable before WE for host/cpu access BB/RFC REG */
-#define BIT_PHYWR_SETUP_CNT(x)                     ((u32)(((x) & 0x000000FF) << 16))
-#define BIT_GET_PHYWR_SETUP_CNT(x)                 ((u32)(((x >> 16) & 0x000000FF)))
-#define BIT_MASK_PHYWR_HOLD_CNT                    ((u32)0x000000FF << 8)          /*!<R/W 0x04  the timing WDATA stable after WE for host/cpu access BB/RFC REG */
-#define BIT_PHYWR_HOLD_CNT(x)                      ((u32)(((x) & 0x000000FF) << 8))
-#define BIT_GET_PHYWR_HOLD_CNT(x)                  ((u32)(((x >> 8) & 0x000000FF)))
-#define BIT_MASK_PHYRD_WAIT_CNT                    ((u32)0x000000FF << 0)          /*!<R/W 0x06  the timing RDATA stable after ADDR for host/cpu access BB/RFC REG */
-#define BIT_PHYRD_WAIT_CNT(x)                      ((u32)(((x) & 0x000000FF) << 0))
-#define BIT_GET_PHYRD_WAIT_CNT(x)                  ((u32)(((x >> 0) & 0x000000FF)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_SW_DEFINED_PAGE1
- * @brief SD Reserved register for 8051 information
- * @{
- *****************************************************************************/
-#define BIT_MASK_SW_DEFINED_PAGE1_V1               ((u32)0xFFFFFFFF << 0)          /*!<R/W 0  User Defined Message */
-#define BIT_SW_DEFINED_PAGE1_V1(x)                 ((u32)(((x) & 0xFFFFFFFF) << 0))
-#define BIT_GET_SW_DEFINED_PAGE1_V1(x)             ((u32)(((x >> 0) & 0xFFFFFFFF)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_SW_DEFINED_PAGE2
- * @brief SD Reserved register for 8051 information
- * @{
- *****************************************************************************/
-#define BIT_MASK_SW_DEFINED_PAGE2                  ((u32)0xFFFFFFFF << 0)          /*!<R/W 0  User Defined Message */
-#define BIT_SW_DEFINED_PAGE2(x)                    ((u32)(((x) & 0xFFFFFFFF) << 0))
-#define BIT_GET_SW_DEFINED_PAGE2(x)                ((u32)(((x >> 0) & 0xFFFFFFFF)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_MCUTST_I
- * @brief Test register
- * @{
- *****************************************************************************/
-#define BIT_MASK_MCUDMSG_I                         ((u32)0xFFFFFFFF << 0)          /*!<R/W 0  User Defined Message */
-#define BIT_MCUDMSG_I(x)                           ((u32)(((x) & 0xFFFFFFFF) << 0))
-#define BIT_GET_MCUDMSG_I(x)                       ((u32)(((x >> 0) & 0xFFFFFFFF)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_MCUTST_II
- * @brief Test register
- * @{
- *****************************************************************************/
-#define BIT_MASK_MCUDMSG_II                        ((u32)0xFFFFFFFF << 0)          /*!<R/W 0  User Defined Message */
-#define BIT_MCUDMSG_II(x)                          ((u32)(((x) & 0xFFFFFFFF) << 0))
-#define BIT_GET_MCUDMSG_II(x)                      ((u32)(((x >> 0) & 0xFFFFFFFF)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_FMETHR
- * @brief Firmware Message Mail Box Register
- * @{
- *****************************************************************************/
-#define BIT_FWMSG_INTPS                            ((u32)0x00000001 << 31)          /*!<R/W 0  Toggle this bit will generate C2H interrupt to Host */
-#define BIT_MASK_FW_MSG                            ((u32)0x7FFFFFFF << 0)          /*!<R/W 0  User Defined Message */
-#define BIT_FW_MSG(x)                              ((u32)(((x) & 0x7FFFFFFF) << 0))
-#define BIT_GET_FW_MSG(x)                          ((u32)(((x >> 0) & 0x7FFFFFFF)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_HMETFR
- * @brief Host Message Mail Box Status register
- * @{
- *****************************************************************************/
-#define BIT_MASK_HRCV_MSG                          ((u32)0x000000FF << 24)          /*!<R/W 0  Host Recover Message, Host Write This Byte will generate interrupt to 8051 (0x0134h[5]) */
-#define BIT_HRCV_MSG(x)                            ((u32)(((x) & 0x000000FF) << 24))
-#define BIT_GET_HRCV_MSG(x)                        ((u32)(((x >> 24) & 0x000000FF)))
-#define BIT_H3MSG_VLD                              ((u32)0x00000001 << 3)          /*!<R/W 0  MSG_BOX_3 Valid. Enable when the Entry is write, Clear when the Entry is Read by 8051. */
-#define BIT_H2MSG_VLD                              ((u32)0x00000001 << 2)          /*!<R/W 0  MSG_BOX_2 Valid. Enable when the Entry is write, Clear when the Entry is Read by 8051. */
-#define BIT_H1MSG_VLD                              ((u32)0x00000001 << 1)          /*!<R/W 0  MSG_BOX_1 Valid. Enable when the Entry is write, Clear when the Entry is Read by 8051. */
-#define BIT_H0MSG_VLD                              ((u32)0x00000001 << 0)          /*!<R/W 0  MSG_BOX_0 Valid. Enable when the Entry is write, Clear when the Entry is Read by 8051. */
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_HMEBOX0
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_MASK_HOST_MSG_0                        ((u32)0xFFFFFFFF << 0)          /*!<R/W 0  User Defined Message */
-#define BIT_HOST_MSG_0(x)                          ((u32)(((x) & 0xFFFFFFFF) << 0))
-#define BIT_GET_HOST_MSG_0(x)                      ((u32)(((x >> 0) & 0xFFFFFFFF)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_HMEBOX1
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_MASK_HOST_MSG_1                        ((u32)0xFFFFFFFF << 0)          /*!<R/W 0  User Defined Message */
-#define BIT_HOST_MSG_1(x)                          ((u32)(((x) & 0xFFFFFFFF) << 0))
-#define BIT_GET_HOST_MSG_1(x)                      ((u32)(((x >> 0) & 0xFFFFFFFF)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_HMEBOX2
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_MASK_HOST_MSG_2                        ((u32)0xFFFFFFFF << 0)          /*!<R/W 0  User Defined Message */
-#define BIT_HOST_MSG_2(x)                          ((u32)(((x) & 0xFFFFFFFF) << 0))
-#define BIT_GET_HOST_MSG_2(x)                      ((u32)(((x >> 0) & 0xFFFFFFFF)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_HMEBOX3
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_MASK_HOST_MSG_3                        ((u32)0xFFFFFFFF << 0)          /*!<R/W 0  User Defined Message */
-#define BIT_HOST_MSG_3(x)                          ((u32)(((x) & 0xFFFFFFFF) << 0))
-#define BIT_GET_HOST_MSG_3(x)                      ((u32)(((x >> 0) & 0xFFFFFFFF)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_GENTST
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_MASK_GENTST                            ((u32)0xFFFFFFFF << 0)          /*!<R/W 0  Dummy register for MAC I/O REG Read/Write Access TEST */
-#define BIT_GENTST(x)                              ((u32)(((x) & 0xFFFFFFFF) << 0))
-#define BIT_GET_GENTST(x)                          ((u32)(((x >> 0) & 0xFFFFFFFF)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_BB_ACCESS_CTRL
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_MASK_BB_WRITE_READ                     ((u32)0x00000003 << 30)          /*!<R/W 0  00 : No Active Baseband cycle 01 : Baseband Write Access (auto return to 00 when access finished) 1X : Baseband Read Access (auto return to 00 when access finished) */
-#define BIT_BB_WRITE_READ(x)                       ((u32)(((x) & 0x00000003) << 30))
-#define BIT_GET_BB_WRITE_READ(x)                   ((u32)(((x >> 30) & 0x00000003)))
-#define BIT_MASK_BB_WRITE_EN_V1                    ((u32)0x0000000F << 16)          /*!<R/W 0  Byte Write Enable */
-#define BIT_BB_WRITE_EN_V1(x)                      ((u32)(((x) & 0x0000000F) << 16))
-#define BIT_GET_BB_WRITE_EN_V1(x)                  ((u32)(((x >> 16) & 0x0000000F)))
-#define BIT_MASK_BB_ADDR_V1                        ((u32)0x00003FFF << 2)          /*!<R/W 0  Baseband Access Write/Read Address (in DW unit) */
-#define BIT_BB_ADDR_V1(x)                          ((u32)(((x) & 0x00003FFF) << 2))
-#define BIT_GET_BB_ADDR_V1(x)                      ((u32)(((x >> 2) & 0x00003FFF)))
-#define BIT_BB_ERRACC                              ((u32)0x00000001 << 0)          /*!<R/W 0  Duplicate Access when previous cycle pending (write one clear) */
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_BB_ACCESS_DATA
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_MASK_BB_DATA                           ((u32)0xFFFFFFFF << 0)          /*!<R/W 0  Baseband Access Write/Read Data (in DW unit) */
-#define BIT_BB_DATA(x)                             ((u32)(((x) & 0xFFFFFFFF) << 0))
-#define BIT_GET_BB_DATA(x)                         ((u32)(((x >> 0) & 0xFFFFFFFF)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_HMEBOX_E0
- * @brief Host Message Mail Box 4 Register
- * @{
- *****************************************************************************/
-#define BIT_MASK_HMEBOX_E0                         ((u32)0xFFFFFFFF << 0)          /*!<R/W 0  User Defined Message */
-#define BIT_HMEBOX_E0(x)                           ((u32)(((x) & 0xFFFFFFFF) << 0))
-#define BIT_GET_HMEBOX_E0(x)                       ((u32)(((x >> 0) & 0xFFFFFFFF)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_HMEBOX_E1
- * @brief Host Message Mail Box 5 Register
- * @{
- *****************************************************************************/
-#define BIT_MASK_HMEBOX_E1                         ((u32)0xFFFFFFFF << 0)          /*!<R/W 0  User Defined Message */
-#define BIT_HMEBOX_E1(x)                           ((u32)(((x) & 0xFFFFFFFF) << 0))
-#define BIT_GET_HMEBOX_E1(x)                       ((u32)(((x >> 0) & 0xFFFFFFFF)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_HMEBOX_E2
- * @brief Host Message Mail Box 6 Register
- * @{
- *****************************************************************************/
-#define BIT_MASK_HMEBOX_E2                         ((u32)0xFFFFFFFF << 0)          /*!<R/W 0  User Defined Message */
-#define BIT_HMEBOX_E2(x)                           ((u32)(((x) & 0xFFFFFFFF) << 0))
-#define BIT_GET_HMEBOX_E2(x)                       ((u32)(((x >> 0) & 0xFFFFFFFF)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_HMEBOX_E3
- * @brief Host Message Mail Box 7 Register
- * @{
- *****************************************************************************/
-#define BIT_MASK_HMEBOX_E3                         ((u32)0xFFFFFFFF << 0)          /*!<R/W 0  User Defined Message */
-#define BIT_HMEBOX_E3(x)                           ((u32)(((x) & 0xFFFFFFFF) << 0))
-#define BIT_GET_HMEBOX_E3(x)                       ((u32)(((x >> 0) & 0xFFFFFFFF)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_FS_FW_DEBUG_0
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_MASK_FS_FW_DEBUG_0                     ((u32)0xFFFFFFFF << 0)          /*!<R/W 0  User Defined Message */
-#define BIT_FS_FW_DEBUG_0(x)                       ((u32)(((x) & 0xFFFFFFFF) << 0))
-#define BIT_GET_FS_FW_DEBUG_0(x)                   ((u32)(((x >> 0) & 0xFFFFFFFF)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_FS_FW_DEBUG_1
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_MASK_FS_FW_DEBUG_1                     ((u32)0xFFFFFFFF << 0)          /*!<R/W 0  User Defined Message */
-#define BIT_FS_FW_DEBUG_1(x)                       ((u32)(((x) & 0xFFFFFFFF) << 0))
-#define BIT_GET_FS_FW_DEBUG_1(x)                   ((u32)(((x >> 0) & 0xFFFFFFFF)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_FS_FW_DEBUG_2
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_MASK_FS_FW_DEBUG_2                     ((u32)0xFFFFFFFF << 0)          /*!<R/W 0  User Defined Message */
-#define BIT_FS_FW_DEBUG_2(x)                       ((u32)(((x) & 0xFFFFFFFF) << 0))
-#define BIT_GET_FS_FW_DEBUG_2(x)                   ((u32)(((x >> 0) & 0xFFFFFFFF)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_FS_FW_DEBUG_3
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_MASK_FS_FW_DEBUG_3                     ((u32)0xFFFFFFFF << 0)          /*!<R/W 0  User Defined Message */
-#define BIT_FS_FW_DEBUG_3(x)                       ((u32)(((x) & 0xFFFFFFFF) << 0))
-#define BIT_GET_FS_FW_DEBUG_3(x)                   ((u32)(((x >> 0) & 0xFFFFFFFF)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_ZB2WL_MAILBOX
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_MASK_ZB2WL_MAILBOX                     ((u32)0xFFFFFFFF << 0)          /*!<R/W 0  Write to generate interrupt (0x116C [31]) */
-#define BIT_ZB2WL_MAILBOX(x)                       ((u32)(((x) & 0xFFFFFFFF) << 0))
-#define BIT_GET_ZB2WL_MAILBOX(x)                   ((u32)(((x >> 0) & 0xFFFFFFFF)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_WL2ZB_MAILBOX
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_MASK_WL2ZB_MAILBOX                     ((u32)0xFFFFFFFF << 0)          /*!<R/W 0  Write to generate interrupt (0x0C4 [10]) */
-#define BIT_WL2ZB_MAILBOX(x)                       ((u32)(((x) & 0xFFFFFFFF) << 0))
-#define BIT_GET_WL2ZB_MAILBOX(x)                   ((u32)(((x >> 0) & 0xFFFFFFFF)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_FE2IMR
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_FS_ATIM_PORT1_INT_EN                   ((u32)0x00000001 << 24)          /*!<R/W 0  PORT1 ATIM end window interrupt . */
-#define BIT_FS_ATIM_MB7_INT_EN                     ((u32)0x00000001 << 23)          /*!<R/W 0  MBSSID7 ATIM end window interrupt . */
-#define BIT_FS_ATIM_MB6_INT_EN                     ((u32)0x00000001 << 22)          /*!<R/W 0  MBSSID6 ATIM end window interrupt . */
-#define BIT_FS_ATIM_MB5_INT_EN                     ((u32)0x00000001 << 21)          /*!<R/W 0  MBSSID5 ATIM end window interrupt . */
-#define BIT_FS_ATIM_MB4_INT_EN                     ((u32)0x00000001 << 20)          /*!<R/W 0  MBSSID4 ATIM end window interrupt . */
-#define BIT_FS_ATIM_MB3_INT_EN                     ((u32)0x00000001 << 19)          /*!<R/W 0  MBSSID3 ATIM end window interrupt . */
-#define BIT_FS_ATIM_MB2_INT_EN                     ((u32)0x00000001 << 18)          /*!<R/W 0  MBSSID2 ATIM end window interrupt . */
-#define BIT_FS_ATIM_MB1_INT_EN                     ((u32)0x00000001 << 17)          /*!<R/W 0  MBSSID1 ATIM end window interrupt . */
-#define BIT_FS_ATIM_MB0_INT_EN                     ((u32)0x00000001 << 16)          /*!<R/W 0  MBSSID0 ATIM end window interrupt . */
-#define BIT_FS_CTWE_INT2_EN                        ((u32)0x00000001 << 15)          /*!<R/W 0  port2 CTWindow end interrupt for p2p. */
-#define BIT_FS_CTWE_INT_EN0                        ((u32)0x00000001 << 14)          /*!<R/W 0  port0 CTWindow end interrupt for p2p. */
-#define BIT_FS_CTWE_INT_EN1                        ((u32)0x00000001 << 13)          /*!<R/W 0  port1 CTWindow end interrupt for p2p. */
-#define BIT_FS_TBTTALL_INT_EN                      ((u32)0x00000001 << 12)          /*!<R/W 0  the interrupt from the exact TBTT time for all port. */
-#define BIT_FS_PO_TBTT_AGG_INT_EN                  ((u32)0x00000001 << 10)          /*!<R/W 0  the interrupt from the multiplt TBTT times for P0. */
-#define BIT_FS_TBTT2INT_EN                         ((u32)0x00000001 << 9)          /*!<R/W 0  the interrupt from the exact TBTT time for P2. */
-#define BIT_FS_TBTT1INT_EN                         ((u32)0x00000001 << 8)          /*!<R/W 0  the interrupt from the exact TBTT time for P1. */
-#define BIT_FS_TBTT0_MB7INT_EN                     ((u32)0x00000001 << 7)          /*!<R/W 0  the interrupt from the exact TBTT time for P0 MBSSID7. */
-#define BIT_FS_TBTT0_MB6INT_EN                     ((u32)0x00000001 << 6)          /*!<R/W 0  the interrupt from the exact TBTT time for P0 MBSSID6. */
-#define BIT_FS_TBTT0_MB5INT_EN                     ((u32)0x00000001 << 5)          /*!<R/W 0  the interrupt from the exact TBTT time for P0 MBSSID5. */
-#define BIT_FS_TBTT0_MB4INT_EN                     ((u32)0x00000001 << 4)          /*!<R/W 0  the interrupt from the exact TBTT time for P0 MBSSID4. */
-#define BIT_FS_TBTT0_MB3INT_EN                     ((u32)0x00000001 << 3)          /*!<R/W 0  the interrupt from the exact TBTT time for P0 MBSSID3. */
-#define BIT_FS_TBTT0_MB2INT_EN                     ((u32)0x00000001 << 2)          /*!<R/W 0  the interrupt from the exact TBTT time for P0 MBSSID2. */
-#define BIT_FS_TBTT0_MB1INT_EN                     ((u32)0x00000001 << 1)          /*!<R/W 0  the interrupt from the exact TBTT time for P0 MBSSID1. */
-#define BIT_FS_TBTT0_INT_EN                        ((u32)0x00000001 << 0)          /*!<R/W 0  the interrupt from the exact TBTT time for P0 MBSSID0. */
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_FE2ISR
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_FS_ATIM_PORT1_INT                      ((u32)0x00000001 << 24)          /*!<RW1C 0  PORT1 ATIM end window interrupt . */
-#define BIT_FS_ATIM_MB7_INT                        ((u32)0x00000001 << 23)          /*!<RW1C 0  MBSSID7 ATIM end window interrupt . */
-#define BIT_FS_ATIM_MB6_INT                        ((u32)0x00000001 << 22)          /*!<RW1C 0  MBSSID6 ATIM end window interrupt . */
-#define BIT_FS_ATIM_MB5_INT                        ((u32)0x00000001 << 21)          /*!<RW1C 0  MBSSID5 ATIM end window interrupt . */
-#define BIT_FS_ATIM_MB4_INT                        ((u32)0x00000001 << 20)          /*!<RW1C 0  MBSSID4 ATIM end window interrupt . */
-#define BIT_FS_ATIM_MB3_INT                        ((u32)0x00000001 << 19)          /*!<RW1C 0  MBSSID3 ATIM end window interrupt . */
-#define BIT_FS_ATIM_MB2_INT                        ((u32)0x00000001 << 18)          /*!<RW1C 0  MBSSID2 ATIM end window interrupt . */
-#define BIT_FS_ATIM_MB1_INT                        ((u32)0x00000001 << 17)          /*!<RW1C 0  MBSSID1 ATIM end window interrupt . */
-#define BIT_FS_ATIM_MB0_INT                        ((u32)0x00000001 << 16)          /*!<RW1C 0  MBSSID0 ATIM end window interrupt . */
-#define BIT_FS_CTWE_INT2                           ((u32)0x00000001 << 15)          /*!<RW1C 0  port2 CTWindow end interrupt for p2p. */
-#define BIT_FS_CTWE_INT0                           ((u32)0x00000001 << 14)          /*!<RW1C 0  port0 CTWindow end interrupt for p2p. */
-#define BIT_FS_CTWE_INT1                           ((u32)0x00000001 << 13)          /*!<RW1C 0  port1 CTWindow end interrupt for p2p. */
-#define BIT_FS_TBTTALL_INT                         ((u32)0x00000001 << 12)          /*!<RW1C 0  the interrupt from the exact TBTT time for all port. */
-#define BIT_FS_PO_TBTT_AGG_INT                     ((u32)0x00000001 << 10)          /*!<RW1C 0  the interrupt from the multiplt TBTT times for P0. */
-#define BIT_FS_TBTT2INT                            ((u32)0x00000001 << 9)          /*!<RW1C 0  the interrupt from the exact TBTT time for P2. */
-#define BIT_FS_TBTT1INT                            ((u32)0x00000001 << 8)          /*!<RW1C 0  the interrupt from the exact TBTT time for P1. */
-#define BIT_FS_TBTT0_MB7INT                        ((u32)0x00000001 << 7)          /*!<RW1C 0  the interrupt from the exact TBTT time for P0 MBSSID7. */
-#define BIT_FS_TBTT0_MB6INT                        ((u32)0x00000001 << 6)          /*!<RW1C 0  the interrupt from the exact TBTT time for P0 MBSSID6. */
-#define BIT_FS_TBTT0_MB5INT                        ((u32)0x00000001 << 5)          /*!<RW1C 0  the interrupt from the exact TBTT time for P0 MBSSID5. */
-#define BIT_FS_TBTT0_MB4INT                        ((u32)0x00000001 << 4)          /*!<RW1C 0  the interrupt from the exact TBTT time for P0 MBSSID4. */
-#define BIT_FS_TBTT0_MB3INT                        ((u32)0x00000001 << 3)          /*!<RW1C 0  the interrupt from the exact TBTT time for P0 MBSSID3. */
-#define BIT_FS_TBTT0_MB2INT                        ((u32)0x00000001 << 2)          /*!<RW1C 0  the interrupt from the exact TBTT time for P0 MBSSID2. */
-#define BIT_FS_TBTT0_MB1INT                        ((u32)0x00000001 << 1)          /*!<RW1C 0  the interrupt from the exact TBTT time for P0 MBSSID1. */
-#define BIT_FS_TBTT0_INT                           ((u32)0x00000001 << 0)          /*!<RW1C 0  the interrupt from the exact TBTT time for P0 MBSSID0. */
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_FE3IMR
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_FE1ISR_INT_EN                          ((u32)0x00000001 << 31)          /*!<R/W 0  FE1ISR Indicator (FE1ISR and FE1IMR are true, this bit is set to 1) */
-#define BIT_FE2ISR_INT_EN                          ((u32)0x00000001 << 30)          /*!<R/W 0  FE2ISR Indicator (FE2ISR and FE2IMR are true, this bit is set to 1) */
-#define BIT_FE4ISR_INT_EN                          ((u32)0x00000001 << 29)          /*!<R/W 0  FE4ISR Indicator (FE4ISR and FE4IMR are true, this bit is set to 1) */
-#define BIT_FE5ISR_INT_EN                          ((u32)0x00000001 << 28)          /*!<R/W 0  FE5ISR Indicator (FE5ISR and FE5IMR are true, this bit is set to 1) */
-#define BIT_FE6ISR_INT_EN                          ((u32)0x00000001 << 27)          /*!<R/W 0  FE6ISR Indicator (FE6ISR and FE6IMR are true, this bit is set to 1) */
-#define BIT_FISR_INT_EN                            ((u32)0x00000001 << 26)          /*!<R/W 0  FISR Indicator (FISR and FIMR are true, this bit is set to 1) */
-#define BIT_FISR1_INT_EN                           ((u32)0x00000001 << 25)          /*!<R/W 0  FISR1 Indicator (FISR1 and FIMR1 are true, this bit is set to 1) */
-#define BIT_FS_BCNELY2_AGGR_INT_EN                 ((u32)0x00000001 << 17)          /*!<R/W 0  port 2 Beacon early aggregation interrupt */
-#define BIT_FS_BCNELY1_AGGR_INT_EN                 ((u32)0x00000001 << 16)          /*!<R/W 0  port 1 Beacon early aggregation interrupt */
-#define BIT_FS_BCNELY0_AGGR_INT_EN                 ((u32)0x00000001 << 15)          /*!<R/W 0  port 0 Beacon early aggregation interrupt */
-#define BIT_FS_ON_SCK_INT_EN                       ((u32)0x00000001 << 14)          /*!<R/W 0  This interrupt is issued at the time set by ALL DRVERLYINT register before TBTT time. */
-#define BIT_FS_BCNERLY2_INT_EN                     ((u32)0x00000001 << 9)          /*!<R/W 0  This interrupt is issued at the time set by DRVERLYINT register before TBTT2 time. */
-#define BIT_FS_BCNERLY1_INT_EN                     ((u32)0x00000001 << 8)          /*!<R/W 0  This interrupt is issued at the time set by DRVERLYINT register before TBTT1 time. */
-#define BIT_FS_BCNERLY0_MB7INT_EN                  ((u32)0x00000001 << 7)          /*!<R/W 0  This interrupt is issued at the time set by DRVERLYINTregister before TBTT0_MB7 time. */
-#define BIT_FS_BCNERLY0_MB6INT_EN                  ((u32)0x00000001 << 6)          /*!<R/W 0  This interrupt is issued at the time set by DRVERLYINT register before TBTT0_MB6 time. */
-#define BIT_FS_BCNERLY0_MB5INT_EN                  ((u32)0x00000001 << 5)          /*!<R/W 0  This interrupt is issued at the time set by DRVERLYINT register before TBTT0_MB5 time. */
-#define BIT_FS_BCNERLY0_MB4INT_EN                  ((u32)0x00000001 << 4)          /*!<R/W 0  This interrupt is issued at the time set by DRVERLYINTregister before TBTT0_MB4 time. */
-#define BIT_FS_BCNERLY0_MB3INT_EN                  ((u32)0x00000001 << 3)          /*!<R/W 0  This interrupt is issued at the time set by DRVERLYINT register before TBTT0_MB3 time. */
-#define BIT_FS_BCNERLY0_MB2INT_EN                  ((u32)0x00000001 << 2)          /*!<R/W 0  This interrupt is issued at the time set by DRVERLYINT register before TBTT0_MB2 time. */
-#define BIT_FS_BCNERLY0_MB1INT_EN                  ((u32)0x00000001 << 1)          /*!<R/W 0  This interrupt is issued at the time set by DRVERLYINTregister before TBTT0_MB1 time. */
-#define BIT_FS_BCNERLY0_INT_EN                     ((u32)0x00000001 << 0)          /*!<R/W 0  This interrupt is issued at the time set by DRVERLYINT register before TBTT0_MB0 time. */
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_FE3ISR
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_FE1ISR_INT                             ((u32)0x00000001 << 31)          /*!<RW1C 0  FE1ISR Indicator (FE1ISR and FE1IMR are true, this bit is set to 1) */
-#define BIT_FE2ISR_INT                             ((u32)0x00000001 << 30)          /*!<RW1C 0  FE2ISR Indicator (FE2ISR and FE2IMR are true, this bit is set to 1) */
-#define BIT_FE4ISR_INT                             ((u32)0x00000001 << 29)          /*!<RW1C 0  FE4ISR Indicator (FE4ISR and FE4IMR are true, this bit is set to 1) */
-#define BIT_FE5ISR_INT                             ((u32)0x00000001 << 28)          /*!<RW1C 0  FE5ISR Indicator (FE5ISR and FE5IMR are true, this bit is set to 1) */
-#define BIT_FE6ISR_INT                             ((u32)0x00000001 << 27)          /*!<RW1C 0  FE6ISR Indicator (FE6ISR and FE6IMR are true, this bit is set to 1) */
-#define BIT_FISR_INT                               ((u32)0x00000001 << 26)          /*!<RW1C 0  FISR Indicator (FISR and FIMR are true, this bit is set to 1) */
-#define BIT_FISR1_INT                              ((u32)0x00000001 << 25)          /*!<RW1C 0  FISR1 Indicator (FISR1 and FIMR1 are true, this bit is set to 1) */
-#define BIT_FS_BCNELY2_AGGR_INT                    ((u32)0x00000001 << 17)          /*!<RW1C 0  port 2 Beacon early aggregation interrupt */
-#define BIT_FS_BCNELY1_AGGR_INT                    ((u32)0x00000001 << 16)          /*!<RW1C 0  port 1 Beacon early aggregation interrupt */
-#define BIT_FS_BCNELY0_AGGR_INT                    ((u32)0x00000001 << 15)          /*!<RW1C 0  port 0 Beacon early aggregation interrupt */
-#define BIT_FS_ON_SCK_INT                          ((u32)0x00000001 << 14)          /*!<RW1C 0  This interrupt is issued at the time set by ALL DRVERLYINT register before TBTT time. */
-#define BIT_FS_BCNERLY2_INT                        ((u32)0x00000001 << 9)          /*!<RW1C 0  This interrupt is issued at the time set by DRVERLYINT register before TBTT2 time. */
-#define BIT_FS_BCNERLY1_INT                        ((u32)0x00000001 << 8)          /*!<RW1C 0  This interrupt is issued at the time set by DRVERLYINT register before TBTT1 time. */
-#define BIT_FS_BCNERLY0_MB7INT                     ((u32)0x00000001 << 7)          /*!<RW1C 0  This interrupt is issued at the time set by DRVERLYINTregister before TBTT0_MB7 time. */
-#define BIT_FS_BCNERLY0_MB6INT                     ((u32)0x00000001 << 6)          /*!<RW1C 0  This interrupt is issued at the time set by DRVERLYINT register before TBTT0_MB6 time. */
-#define BIT_FS_BCNERLY0_MB5INT                     ((u32)0x00000001 << 5)          /*!<RW1C 0  This interrupt is issued at the time set by DRVERLYINT register before TBTT0_MB5 time. */
-#define BIT_FS_BCNERLY0_MB4INT                     ((u32)0x00000001 << 4)          /*!<RW1C 0  This interrupt is issued at the time set by DRVERLYINTregister before TBTT0_MB4 time. */
-#define BIT_FS_BCNERLY0_MB3INT                     ((u32)0x00000001 << 3)          /*!<RW1C 0  This interrupt is issued at the time set by DRVERLYINT register before TBTT0_MB3 time. */
-#define BIT_FS_BCNERLY0_MB2INT                     ((u32)0x00000001 << 2)          /*!<RW1C 0  This interrupt is issued at the time set by DRVERLYINT register before TBTT0_MB2 time. */
-#define BIT_FS_BCNERLY0_MB1INT                     ((u32)0x00000001 << 1)          /*!<RW1C 0  This interrupt is issued at the time set by DRVERLYINTregister before TBTT0_MB1 time. */
-#define BIT_FS_BCNERLY0_INT                        ((u32)0x00000001 << 0)          /*!<RW1C 0  This interrupt is issued at the time set by DRVERLYINT register before TBTT0_MB0 time. */
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_FE4IMR
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_FS_PCIE_BCNDMAERR_INT_EN               ((u32)0x00000001 << 31)          /*!<R/W 0  PCIE BCN DMA error interrupt */
-#define BIT_FS_BCNDMA1_INT_EN                      ((u32)0x00000001 << 30)          /*!<R/W 0  When BCNDMA interval arrives before TBTT1, this interrupt informs MCU to prepare related beacon tasks. */
-#define BIT_FS_BCNDMA0_MB7_INT_EN                  ((u32)0x00000001 << 29)          /*!<R/W 0  When BCNDMA interval arrives before TBTT0_MB7, this interrupt informs MCU to prepare related beacon tasks. */
-#define BIT_FS_BCNDMA0_MB6_INT_EN                  ((u32)0x00000001 << 28)          /*!<R/W 0  When BCNDMA interval arrives before TBTT0_MB6, this interrupt informs MCU to prepare related beacon tasks. */
-#define BIT_FS_BCNDMA0_MB5_INT_EN                  ((u32)0x00000001 << 27)          /*!<R/W 0  When BCNDMA interval arrives before TBTT0_MB5, this interrupt informs MCU to prepare related beacon tasks. */
-#define BIT_FS_BCNDMA0_MB4_INT_EN                  ((u32)0x00000001 << 26)          /*!<R/W 0  When BCNDMA interval arrives before TBTT0_MB4, this interrupt informs MCU to prepare related beacon tasks. */
-#define BIT_FS_BCNDMA0_MB3_INT_EN                  ((u32)0x00000001 << 25)          /*!<R/W 0  When BCNDMA interval arrives before TBTT0_MB3, this interrupt informs MCU to prepare related beacon tasks. */
-#define BIT_FS_BCNDMA0_MB2_INT_EN                  ((u32)0x00000001 << 24)          /*!<R/W 0  When BCNDMA interval arrives before TBTT0_MB2, this interrupt informs MCU to prepare related beacon tasks. */
-#define BIT_FS_BCNDMA0_MB1_INT_EN                  ((u32)0x00000001 << 23)          /*!<R/W 0  When BCNDMA interval arrives before TBTT0_MB1, this interrupt informs MCU to prepare related beacon tasks. */
-#define BIT_FS_BCNDMA0_INT_EN                      ((u32)0x00000001 << 22)          /*!<R/W 0  When BCNDMA interval arrives before TBTT0_MB0, this interrupt informs MCU to prepare related beacon tasks. */
-#define BIT_FS_BCNDMA2_INT_EN                      ((u32)0x00000001 << 21)          /*!<R/W 0  When BCNDMA interval arrives before TBTT2, this interrupt informs MCU to prepare related beacon tasks. */
-#define BIT_PORT0_PKTIN_INT_EN                     ((u32)0x00000001 << 17)          /*!<R/W 0  port 0 packet assign to queue interrupt */
-#define BIT_PORT1_PKTIN_INT_EN                     ((u32)0x00000001 << 16)          /*!<R/W 0  port 1 packet assign to queue interrupt */
-#define BIT_PORT1_RXUCMD0_OK_INT_EN                ((u32)0x00000001 << 3)          /*!<R/W 0  port 1 rx unicast packet with more data = 0 ok interrupt */
-#define BIT_PORT1_RXUCMD1_OK_INT_EN                ((u32)0x00000001 << 2)          /*!<R/W 0  port 1 rx unicast packet with more data = 1 ok interrupt */
-#define BIT_PORT1_RXBCMD0_OK_INT_EN                ((u32)0x00000001 << 1)          /*!<R/W 0  port 1 rx broadcast packet with more data = 0 ok interrupt */
-#define BIT_PORT1_RXBCMD1_OK_INT_EN                ((u32)0x00000001 << 0)          /*!<R/W 0  port 1 rx broadcast packet with more data = 1 ok interrupt */
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_FE4ISR
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_FS_PCIE_BCNDMAERR_INT                  ((u32)0x00000001 << 31)          /*!<RW1C 0  PCIE BCN DMA error interrupt */
-#define BIT_FS_BCNDMA1_INT                         ((u32)0x00000001 << 30)          /*!<RW1C 0  When BCNDMA interval arrives before TBTT1, this interrupt informs MCU to prepare related beacon tasks. */
-#define BIT_FS_BCNDMA0_MB7_INT                     ((u32)0x00000001 << 29)          /*!<RW1C 0  When BCNDMA interval arrives before TBTT0_MB7, this interrupt informs MCU to prepare related beacon tasks. */
-#define BIT_FS_BCNDMA0_MB6_INT                     ((u32)0x00000001 << 28)          /*!<RW1C 0  When BCNDMA interval arrives before TBTT0_MB6, this interrupt informs MCU to prepare related beacon tasks. */
-#define BIT_FS_BCNDMA0_MB5_INT                     ((u32)0x00000001 << 27)          /*!<RW1C 0  When BCNDMA interval arrives before TBTT0_MB5, this interrupt informs MCU to prepare related beacon tasks. */
-#define BIT_FS_BCNDMA0_MB4_INT                     ((u32)0x00000001 << 26)          /*!<RW1C 0  When BCNDMA interval arrives before TBTT0_MB4, this interrupt informs MCU to prepare related beacon tasks. */
-#define BIT_FS_BCNDMA0_MB3_INT                     ((u32)0x00000001 << 25)          /*!<RW1C 0  When BCNDMA interval arrives before TBTT0_MB3, this interrupt informs MCU to prepare related beacon tasks. */
-#define BIT_FS_BCNDMA0_MB2_INT                     ((u32)0x00000001 << 24)          /*!<RW1C 0  When BCNDMA interval arrives before TBTT0_MB2, this interrupt informs MCU to prepare related beacon tasks. */
-#define BIT_FS_BCNDMA0_MB1_INT                     ((u32)0x00000001 << 23)          /*!<RW1C 0  When BCNDMA interval arrives before TBTT0_MB1, this interrupt informs MCU to prepare related beacon tasks. */
-#define BIT_FS_BCNDMA0_INT                         ((u32)0x00000001 << 22)          /*!<RW1C 0  When BCNDMA interval arrives before TBTT0_MB0, this interrupt informs MCU to prepare related beacon tasks. */
-#define BIT_FS_BCNDMA2_INT                         ((u32)0x00000001 << 21)          /*!<RW1C 0  When BCNDMA interval arrives before TBTT2, this interrupt informs MCU to prepare related beacon tasks. */
-#define BIT_PORT0_PKTIN_INT                        ((u32)0x00000001 << 17)          /*!<RW1C 0  port 0 packet assign to queue interrupt */
-#define BIT_PORT1_PKTIN_INT                        ((u32)0x00000001 << 16)          /*!<RW1C 0  port 1 packet assign to queue interrupt */
-#define BIT_PORT1_RXUCMD0_OK_INT                   ((u32)0x00000001 << 3)          /*!<RW1C 0  port 1 rx unicast packet with more data = 0 ok interrupt */
-#define BIT_PORT1_RXUCMD1_OK_INT                   ((u32)0x00000001 << 2)          /*!<RW1C 0  port 1 rx unicast packet with more data = 1 ok interrupt */
-#define BIT_PORT1_RXBCMD0_OK_INT                   ((u32)0x00000001 << 1)          /*!<RW1C 0  port 1 rx broadcast packet with more data = 0 ok interrupt */
-#define BIT_PORT1_RXBCMD1_OK_INT                   ((u32)0x00000001 << 0)          /*!<RW1C 0  port 1 rx broadcast packet with more data = 1 ok interrupt */
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_FT1IMR
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_FS_RXFTMREQ_INT_EN                     ((u32)0x00000001 << 28)          /*!<R/W 0  If BIT_RXFTMREQ_INT_EN =1. When HW receive FTMREQ packet, it will generate interrupt to firmware. */
-#define BIT_FS_RXFTM_INT_EN                        ((u32)0x00000001 << 27)          /*!<R/W 0  If BIT_RXFTM_INT_EN =1. When HW receive FTM and transmit ACK frame successfully, the BB generate FTM report. It will generate interrupt to firmware. */
-#define BIT_FS_TXFTM_INT_EN                        ((u32)0x00000001 << 26)          /*!<R/W 0  If BIT_TXFTM_INT_EN =1. When HW transmit FTM and receive ACK frame successfully, the BB generate FTM report. It will generate interrupt to firmware. */
-#define BIT_FS_RXTMREQ_INT_EN                      ((u32)0x00000001 << 25)          /*!<R/W 0  If BIT_RXTMREQ_INT_EN =1. When HW receive TMREQ packet, it will generate interrupt to firmware. */
-#define BIT_FS_RXTM_INT_EN                         ((u32)0x00000001 << 24)          /*!<R/W 0  If BIT_RXTM_INT_EN =1. When HW receive TM and transmit ACK frame successfully. It will generate interrupt to firmware. */
-#define BIT_FS_TXTM_INT_EN                         ((u32)0x00000001 << 23)          /*!<R/W 0  If BIT_TXTM_INT_EN =1. When HW transmit TM and receive ACK frame successfully. It will generate interrupt to firmware. */
-#define BIT_FS_CTWEND2_INT_EN                      ((u32)0x00000001 << 17)          /*!<R/W 0  CTWindow End NOA2 interrupt. */
-#define BIT_FS_CTWEND1_INT_EN                      ((u32)0x00000001 << 16)          /*!<R/W 0  CTWindow End NOA1 interrupt. */
-#define BIT_FS_CTWEND0_INT_EN                      ((u32)0x00000001 << 15)          /*!<R/W 0  CTWindow End NOA0 interrupt. */
-#define BIT_FS_TX_NULL1_P0_INT_EN                  ((u32)0x00000001 << 14)          /*!<R/W 0  TX null 1 packet done interrupt */
-#define BIT_FS_TX_NULL0_P0_INT_EN                  ((u32)0x00000001 << 13)          /*!<R/W 0  TX null 0 packet done interrupt */
-#define BIT_FS_NOA0_TSF_BIT32_INT_EN               ((u32)0x00000001 << 12)          /*!<R/W 0  NOA unit0 TSFT bit 32 toggle interrupt */
-#define BIT_FS_P2P_RFON2_INT_EN                    ((u32)0x00000001 << 11)          /*!<R/W 0  P2P NoA RF on time indication 2 interrupt */
-#define BIT_FS_P2P_RFOFF2_INT_EN                   ((u32)0x00000001 << 10)          /*!<R/W 0  P2P NoA RF off time indication 2 interrupt */
-#define BIT_FS_P2P_RFON1_INT_EN                    ((u32)0x00000001 << 9)          /*!<R/W 0  P2P NoA RF on time indication 1 interrupt */
-#define BIT_FS_P2P_RFOFF1_INT_EN                   ((u32)0x00000001 << 8)          /*!<R/W 0  P2P NoA RF off time indication 1 interrupt */
-#define BIT_FS_P2P_RFON0_INT_EN                    ((u32)0x00000001 << 7)          /*!<R/W 0  P2P NoA RF on time indication 0 interrupt */
-#define BIT_FS_P2P_RFOFF0_INT_EN                   ((u32)0x00000001 << 6)          /*!<R/W 0  P2P NoA RF off time indication 0 interrupt */
-#define BIT_FS_RX_UAPSDMD1_INT_EN                  ((u32)0x00000001 << 5)          /*!<R/W 0  Setting this bit indicates Rx pkt is matched with one of below: 1.) QoS Unicast data frame with MD=1, UAPSD=0 2.) NonQoS Unicast data frame with MD=1 */
-#define BIT_FS_RX_UAPSDMD0_INT_EN                  ((u32)0x00000001 << 4)          /*!<R/W 0  Setting this bit indicates Rx pkt is matched with one of below: 1.) QoS Unicast data frame with MD=0, UAPSD=0 2.) NonQoS Unicast data frame with MD=0 */
-#define BIT_FS_TRIGGER_PKT_INT_EN                  ((u32)0x00000001 << 3)          /*!<R/W 0  tx TRIGGER_PKT interrupt */
-#define BIT_FS_EOSP_INT_EN                         ((u32)0x00000001 << 2)          /*!<R/W 0  EOSP_INT interrupt mask */
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_FT1ISR
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_FS_RXFTMREQ_INT                        ((u32)0x00000001 << 28)          /*!<RW1C 0  If BIT_RXFTMREQ_INT_EN =1. When HW receive FTMREQ packet, it will generate interrupt to firmware. */
-#define BIT_FS_RXFTM_INT                           ((u32)0x00000001 << 27)          /*!<RW1C 0  If BIT_RXFTM_INT_EN =1. When HW receive FTM and transmit ACK frame successfully, the BB generate FTM report. It will generate interrupt to firmware. */
-#define BIT_FS_TXFTM_INT                           ((u32)0x00000001 << 26)          /*!<RW1C 0  If BIT_TXFTM_INT_EN =1. When HW transmit FTM and receive ACK frame successfully, the BB generate FTM report. It will generate interrupt to firmware. */
-#define BIT_FS_RXTMREQ_INT                         ((u32)0x00000001 << 25)          /*!<RW1C 0  If BIT_RXTMREQ_INT_EN =1. When HW receive TMREQ packet, it will generate interrupt to firmware. */
-#define BIT_FS_RXTM_INT                            ((u32)0x00000001 << 24)          /*!<RW1C 0  If BIT_RXTM_INT_EN =1. When HW receive TM and transmit ACK frame successfully. It will generate interrupt to firmware. */
-#define BIT_FS_TXTM_INT                            ((u32)0x00000001 << 23)          /*!<RW1C 0  If BIT_TXTM_INT_EN =1. When HW transmit TM and receive ACK frame successfully. It will generate interrupt to firmware. */
-#define BIT_FS_CTWEND2_INT                         ((u32)0x00000001 << 17)          /*!<RW1C 0  CTWindow End NOA2 interrupt. */
-#define BIT_FS_CTWEND1_INT                         ((u32)0x00000001 << 16)          /*!<RW1C 0  CTWindow End NOA1 interrupt. */
-#define BIT_FS_CTWEND0_INT                         ((u32)0x00000001 << 15)          /*!<RW1C 0  CTWindow End NOA0 interrupt. */
-#define BIT_FS_TX_NULL1_P0_INT                     ((u32)0x00000001 << 14)          /*!<RW1C 0  TX null 1 packet done interrupt */
-#define BIT_FS_TX_NULL0_P0_INT                     ((u32)0x00000001 << 13)          /*!<RW1C 0  TX null 0 packet done interrupt */
-#define BIT_FS_NOA0_TSF_BIT32_INT                  ((u32)0x00000001 << 12)          /*!<RW1C 0  NOA unit0 TSFT bit 32 toggle interrupt */
-#define BIT_FS_P2P_RFON2_INT                       ((u32)0x00000001 << 11)          /*!<RW1C 0  P2P NoA RF on time indication 2 interrupt */
-#define BIT_FS_P2P_RFOFF2_INT                      ((u32)0x00000001 << 10)          /*!<RW1C 0  P2P NoA RF off time indication 2 interrupt */
-#define BIT_FS_P2P_RFON1_INT                       ((u32)0x00000001 << 9)          /*!<RW1C 0  P2P NoA RF on time indication 1 interrupt */
-#define BIT_FS_P2P_RFOFF1_INT                      ((u32)0x00000001 << 8)          /*!<RW1C 0  P2P NoA RF off time indication 1 interrupt */
-#define BIT_FS_P2P_RFON0_INT                       ((u32)0x00000001 << 7)          /*!<RW1C 0  P2P NoA RF on time indication 0 interrupt */
-#define BIT_FS_P2P_RFOFF0_INT                      ((u32)0x00000001 << 6)          /*!<RW1C 0  P2P NoA RF off time indication 0 interrupt */
-#define BIT_FS_RX_UAPSDMD1_INT                     ((u32)0x00000001 << 5)          /*!<RW1C 0  Setting this bit indicates Rx pkt is matched with one of below: 1.) QoS Unicast data frame with MD=1, UAPSD=0 2.) NonQoS Unicast data frame with MD=1 */
-#define BIT_FS_RX_UAPSDMD0_INT                     ((u32)0x00000001 << 4)          /*!<RW1C 0  Setting this bit indicates Rx pkt is matched with one of below: 1.) QoS Unicast data frame with MD=0, UAPSD=0 2.) NonQoS Unicast data frame with MD=0 */
-#define BIT_FS_TRIGGER_PKT_INT                     ((u32)0x00000001 << 3)          /*!<RW1C 0  tx TRIGGER_PKT interrupt */
-#define BIT_FS_EOSP_INT                            ((u32)0x00000001 << 2)          /*!<RW1C 0  EOSP_INT interrupt mask */
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_TWT_CTRL
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_RX_ACKMD_EN                            ((u32)0x00000001 << 1)          /*!<R/W 0  Enable ACK/BA/MU-BA frame more data interrupt */
-#define BIT_RX_MORE_TF_EN                          ((u32)0x00000001 << 0)          /*!<R/W 0  Enable trigger frame more TF field interrupt */
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_FE5IMR
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_FS_ZIGBEE2WLAN_MAILBOX_MSK             ((u32)0x00000001 << 31)          /*!<R/W 0  Mailbox INT from ZIGBEE CPU */
-#define BIT_FS_EXT_INTF4_EN_MSK                    ((u32)0x00000001 << 5)          /*!<R/W 0  ext bt mailbox int,mailbox_outempty_int| mailbox_in_rdy_int */
-#define BIT_FS_GNT_BT_BB_FALL_MSK                  ((u32)0x00000001 << 4)          /*!<R/W 0  ext Mailbox INT from btcoex */
-#define BIT_FS_GNT_BT_BB_RISE_MSK                  ((u32)0x00000001 << 3)          /*!<R/W 0  ext Mailbox INT from btcoex */
-#define BIT_FS_BT2WL_STS_INT_MSK                   ((u32)0x00000001 << 2)          /*!<R/W 0  ext scoreboard INT from BT */
-#define BIT_FS_BT_MAILBOX_I2C_MSK                  ((u32)0x00000001 << 1)          /*!<R/W 0  Mailbox INT from I2C */
-#define BIT_FS_I2C_INTF4_EN_MSK                    ((u32)0x00000001 << 0)          /*!<R/W 0  bt mailbox int,mailbox_outempty_int| mailbox_in_rdy_int form I2C */
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_FE5ISR
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_FS_ZIGBEE2WLAN_MAILBOX                 ((u32)0x00000001 << 31)          /*!<RW1C 0  Mailbox INT from ZIGBEE CPU */
-#define BIT_FS_EXT_INTF4_EN                        ((u32)0x00000001 << 5)          /*!<RW1C 0  ext bt mailbox int,mailbox_outempty_int| mailbox_in_rdy_int */
-#define BIT_FS_GNT_BT_BB_FALL                      ((u32)0x00000001 << 4)          /*!<RW1C 0  ext Mailbox INT from btcoex */
-#define BIT_FS_GNT_BT_BB_RISE                      ((u32)0x00000001 << 3)          /*!<RW1C 0  ext Mailbox INT from btcoex */
-#define BIT_FS_BT2WL_STS_INT                       ((u32)0x00000001 << 2)          /*!<RW1C 0  ext Mailbox INT from BT */
-#define BIT_FS_BT_MAILBOX_I2C                      ((u32)0x00000001 << 1)          /*!<RW1C 0  Mailbox INT from I2C */
-#define BIT_FS_I2C_INTF4_EN                        ((u32)0x00000001 << 0)          /*!<RW1C 0  bt mailbox int,mailbox_outempty_int| mailbox_in_rdy_int form I2C */
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_FE6IMR
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_PORT0_RXUCMD0_ACK_INT_EN               ((u32)0x00000001 << 9)          /*!<R/W 0  port 0 rx unicast ACK/BA/MBA with more data = 0 ok interrupt */
-#define BIT_PORT0_RXUCMD1_ACK_INT_EN               ((u32)0x00000001 << 8)          /*!<R/W 0  port 0 rx unicast ACK/BA/MBA with more data = 1 ok interrupt */
-#define BIT_PORT0_RXBCMD0_ACK_INT_EN               ((u32)0x00000001 << 7)          /*!<R/W 0  port 0 rx broadcast ACK/BA/MBA with more data = 0 ok interrupt */
-#define BIT_PORT0_RXBCMD1_ACK_INT_EN               ((u32)0x00000001 << 6)          /*!<R/W 0  port 0 rx broadcast ACK/BA/MBA with more data = 1 ok interrupt */
-#define BIT_PORT1_RXUCMD0_ACK_INT_EN               ((u32)0x00000001 << 5)          /*!<R/W 0  port 1 rx unicast ACK/BA/MBA with more data = 0 ok interrupt */
-#define BIT_PORT1_RXUCMD1_ACK_INT_EN               ((u32)0x00000001 << 4)          /*!<R/W 0  port 1 rx unicast ACK/BA/MBA with more data = 1 ok interrupt */
-#define BIT_PORT1_RXBCMD0_ACK_INT_EN               ((u32)0x00000001 << 3)          /*!<R/W 0  port 1 rx broadcast ACK/BA/MBA with more data = 0 ok interrupt */
-#define BIT_PORT1_RXBCMD1_ACK_INT_EN               ((u32)0x00000001 << 2)          /*!<R/W 0  port 1 rx broadcast ACK/BA/MBA with more data = 1 ok interrupt */
-#define BIT_RX_MORE_TF0_INT_EN                     ((u32)0x00000001 << 1)          /*!<R/W 0  interrupt source from trigger frame with more TF field = 0 not addressed to us */
-#define BIT_RX_MORE_TF1_INT_EN                     ((u32)0x00000001 << 0)          /*!<R/W 0  Interrupt source from receiving trigger frame with more TF field = 1 not addressed to us */
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_FE6ISR
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_PORT0_RXUCMD0_ACK_INT                  ((u32)0x00000001 << 9)          /*!<RW1C 0  port 0 rx unicast ACK/BA/MBA with more data = 0 ok interrupt */
-#define BIT_PORT0_RXUCMD1_ACK_INT                  ((u32)0x00000001 << 8)          /*!<RW1C 0  port 0 rx unicast ACK/BA/MBA with more data = 1 ok interrupt */
-#define BIT_PORT0_RXBCMD0_ACK_INT                  ((u32)0x00000001 << 7)          /*!<RW1C 0  port 0 rx broadcast ACK/BA/MBA with more data = 0 ok interrupt */
-#define BIT_PORT0_RXBCMD1_ACK_INT                  ((u32)0x00000001 << 6)          /*!<RW1C 0  port 0 rx broadcast ACK/BA/MBA with more data = 1 ok interrupt */
-#define BIT_PORT1_RXUCMD0_ACK_INT                  ((u32)0x00000001 << 5)          /*!<RW1C 0  port 1 rx unicast ACK/BA/MBA with more data = 0 ok interrupt */
-#define BIT_PORT1_RXUCMD1_ACK_INT                  ((u32)0x00000001 << 4)          /*!<RW1C 0  port 1 rx unicast ACK/BA/MBA with more data = 1 ok interrupt */
-#define BIT_PORT1_RXBCMD0_ACK_INT                  ((u32)0x00000001 << 3)          /*!<RW1C 0  port 1 rx broadcast ACK/BA/MBA with more data = 0 ok interrupt */
-#define BIT_PORT1_RXBCMD1_ACK_INT                  ((u32)0x00000001 << 2)          /*!<RW1C 0  port 1 rx broadcast ACK/BA/MBA with more data = 1 ok interrupt */
-#define BIT_RX_MORE_TF0_INT                        ((u32)0x00000001 << 1)          /*!<RW1C 0  interrupt source from trigger frame with more TF field = 0 not addressed to us */
-#define BIT_RX_MORE_TF1_INT                        ((u32)0x00000001 << 0)          /*!<RW1C 0  Interrupt source from receiving trigger frame with more TF field = 1 not addressed to us */
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_ext_queue_register
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_MASK_TXBUF_WKCAM_OFFSET                ((u32)0x00001FFF << 3)          /*!<R/W 0  the offset of WOL pattern stored in txpktbuffer, unit is 8byte */
-#define BIT_TXBUF_WKCAM_OFFSET(x)                  ((u32)(((x) & 0x00001FFF) << 3))
-#define BIT_GET_TXBUF_WKCAM_OFFSET(x)              ((u32)(((x >> 3) & 0x00001FFF)))
-#define BIT_MASK_H2CQ_PRI                          ((u32)0x00000003 << 0)          /*!<R/W 0   */
-#define BIT_H2CQ_PRI(x)                            ((u32)(((x) & 0x00000003) << 0))
-#define BIT_GET_H2CQ_PRI(x)                        ((u32)(((x >> 0) & 0x00000003)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_I2C_BT_MAILBOX_OUT_LOW
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_MASK_I2C_MAILBOX_DATA_51TO81_L         ((u32)0xFFFFFFFF << 0)          /*!<R/W 0   */
-#define BIT_I2C_MAILBOX_DATA_51TO81_L(x)           ((u32)(((x) & 0xFFFFFFFF) << 0))
-#define BIT_GET_I2C_MAILBOX_DATA_51TO81_L(x)       ((u32)(((x >> 0) & 0xFFFFFFFF)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_I2C_BT_MAILBOX_OUT_HIGH
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_MASK_I2C_MAILBOX_DATA_51TO81_H         ((u32)0xFFFFFFFF << 0)          /*!<R/W 0   */
-#define BIT_I2C_MAILBOX_DATA_51TO81_H(x)           ((u32)(((x) & 0xFFFFFFFF) << 0))
-#define BIT_GET_I2C_MAILBOX_DATA_51TO81_H(x)       ((u32)(((x >> 0) & 0xFFFFFFFF)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_I2C_BT_Mailbox_control
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_I2C_MAILBOX_IN_RDY_INTEN               ((u32)0x00000001 << 17)          /*!<R/W 0   */
-#define BIT_I2C_MAILBOX_IN_RDY                     ((u32)0x00000001 << 16)          /*!<RW1C 0   */
-#define BIT_I2C_MAILBOX_OUTEMPTY_INTEN             ((u32)0x00000001 << 1)          /*!<R/W 0   */
-#define BIT_I2C_MAILBOX_OUT_VLD                    ((u32)0x00000001 << 0)          /*!<RW1C 0   */
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_I2C_BT_MAILBOX_IN_LOW
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_MASK_I2C_MAILBOX_DATA_81TO51_L         ((u32)0xFFFFFFFF << 0)          /*!<R 0   */
-#define BIT_I2C_MAILBOX_DATA_81TO51_L(x)           ((u32)(((x) & 0xFFFFFFFF) << 0))
-#define BIT_GET_I2C_MAILBOX_DATA_81TO51_L(x)       ((u32)(((x >> 0) & 0xFFFFFFFF)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_I2C_BT_MAILBOX_IN_HIGH
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_MASK_I2C_MAILBOX_DATA_81TO51_H         ((u32)0xFFFFFFFF << 0)          /*!<R 0   */
-#define BIT_I2C_MAILBOX_DATA_81TO51_H(x)           ((u32)(((x) & 0xFFFFFFFF) << 0))
-#define BIT_GET_I2C_MAILBOX_DATA_81TO51_H(x)       ((u32)(((x >> 0) & 0xFFFFFFFF)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_EXT_BT_MAILBOX_OUT_LOW
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_MASK_EXT_MAILBOX_DATA_51TO81_L         ((u32)0xFFFFFFFF << 0)          /*!<R/W 0   */
-#define BIT_EXT_MAILBOX_DATA_51TO81_L(x)           ((u32)(((x) & 0xFFFFFFFF) << 0))
-#define BIT_GET_EXT_MAILBOX_DATA_51TO81_L(x)       ((u32)(((x >> 0) & 0xFFFFFFFF)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_EXT_BT_MAILBOX_OUT_HIGH
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_MASK_EXT_MAILBOX_DATA_51TO81_H         ((u32)0xFFFFFFFF << 0)          /*!<R/W 0   */
-#define BIT_EXT_MAILBOX_DATA_51TO81_H(x)           ((u32)(((x) & 0xFFFFFFFF) << 0))
-#define BIT_GET_EXT_MAILBOX_DATA_51TO81_H(x)       ((u32)(((x >> 0) & 0xFFFFFFFF)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_EXT_BT_Mailbox_control
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_EXT_MAILBOX_IN_RDY_INTEN               ((u32)0x00000001 << 17)          /*!<R/W 0  Mailbox IN ready interrupt enable */
-#define BIT_EXT_MAILBOX_IN_RDY                     ((u32)0x00000001 << 16)          /*!<RW1C 0  Mailbox ready BT2Wifi */
-#define BIT_EXT_MAILBOX_OUTEMPTY_INTEN             ((u32)0x00000001 << 1)          /*!<R/W 0  Mailbox OUT empty interrupt enable */
-#define BIT_EXT_MAILBOX_OUT_VLD                    ((u32)0x00000001 << 0)          /*!<RW1C 0  Mailbox ACK Wifi2BT */
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_EXT_BT_MAILBOX_IN_LOW
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_MASK_EXT_MAILBOX_DATA_81TO51_L         ((u32)0xFFFFFFFF << 0)          /*!<R 0   */
-#define BIT_EXT_MAILBOX_DATA_81TO51_L(x)           ((u32)(((x) & 0xFFFFFFFF) << 0))
-#define BIT_GET_EXT_MAILBOX_DATA_81TO51_L(x)       ((u32)(((x >> 0) & 0xFFFFFFFF)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_EXT_BT_MAILBOX_IN_HIGH
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_MASK_EXT_MAILBOX_DATA_81_TO51_H        ((u32)0xFFFFFFFF << 0)          /*!<R 0   */
-#define BIT_EXT_MAILBOX_DATA_81_TO51_H(x)          ((u32)(((x) & 0xFFFFFFFF) << 0))
-#define BIT_GET_EXT_MAILBOX_DATA_81_TO51_H(x)      ((u32)(((x >> 0) & 0xFFFFFFFF)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_FWIMR1
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_FS_TXBCNOK_PORT1_INT_EN                ((u32)0x00000001 << 31)          /*!<R/W 0  ENABLE PORT1 TX beacon OK interrupt */
-#define BIT_FS_TXBCNERR_PORT1_INT_EN               ((u32)0x00000001 << 30)          /*!<R/W 0  ENABLE PORT1 TX beacon Error interrupt */
-#define BIT_FS_TXBCNOK_PORT2_INT_EN                ((u32)0x00000001 << 29)          /*!<R/W 0  PORT2 TX beacon OK interrupt */
-#define BIT_FS_TXBCNERR_PORT2_INT_EN               ((u32)0x00000001 << 28)          /*!<R/W 0  PORT2 TX beacon Error interrupt */
-#define BIT_FS_EVTQ_TXDONE_INT_EN                  ((u32)0x00000001 << 27)          /*!<R/W 0   */
-#define BIT_FS_EVTQ_START_INT_EN                   ((u32)0x00000001 << 26)          /*!<R/W 0   */
-#define BIT_FS_DWWIN_END_INT_EN                    ((u32)0x00000001 << 25)          /*!<R/W 0   */
-#define BIT_FS_BCN_IE_0_HIT_INT_EN                 ((u32)0x00000001 << 24)          /*!<R/W 0  rx bcn with ie0 hit */
-#define BIT_FS_BCN_IE_1_HIT_INT_EN                 ((u32)0x00000001 << 23)          /*!<R/W 0  rx bcn with ie1 hit */
-#define BIT_FS_RXBCN_NAN_RPT_OK_EN                 ((u32)0x00000001 << 22)          /*!<R/W 0  port2 rxbcn rpt and write to txrptbuf ok */
-#define BIT_FS_TIM_NO_HIT_INT_EN                   ((u32)0x00000001 << 21)          /*!<R/W 0  when no my aid or aid is 0(0x16DC[8]) or my bssid is not in tim element(0x16DB[31]),generate this interrupt */
-#define BIT_FS_BC_TWT_PARA_CHG_INT_EN              ((u32)0x00000001 << 20)          /*!<R/W 0  RX broadcast twt with parameter changing,notify fw to read twt report */
-#define BIT_FS_TIM_HIT_INT_EN                      ((u32)0x00000001 << 19)          /*!<R/W 0  when my aid or aid is 0 (0x16DC[8]) or my bssid is in tim element,generate this interrupt */
-#define BIT_FS_HIOE_CHN0_INT_EN                    ((u32)0x00000001 << 18)          /*!<R/W 0  hioe_chn0 done interrupt */
-#define BIT_FS_HIOE_CHN1_INT_EN                    ((u32)0x00000001 << 17)          /*!<R/W 0  hioe_chn1 done interrupt */
-#define BIT_FS_HIOE_CHN_ON_INT_EN                  ((u32)0x00000001 << 16)          /*!<R/W 0  hioe_chn_on done interrupt */
-#define BIT_FS_HIOE_CHN_OFF_INT_EN                 ((u32)0x00000001 << 15)          /*!<R/W 0  hioe_chn_off done interrupt */
-#define BIT_FS_CHINFO_SEG_DONE_INT_NE              ((u32)0x00000001 << 14)          /*!<R/W 0  indicate one channel info segment is received ok */
-#define BIT_FS_DFS_PKT_INT_EN                      ((u32)0x00000001 << 13)          /*!<R/W 0  enable interrupt when receiving dfs pkt and about to reach threshold of given pkt number or timeout */
-#define BIT_FS_RX_PHYSTS_DONE_INT__EN              ((u32)0x00000001 << 12)          /*!<R/W 0  indicate physts is successfully write into physts_mem */
-#define BIT_FS_OPS_TIM_HIT_INT_EN                  ((u32)0x00000001 << 11)          /*!<R/W 0  when my aid or my bssid is in tim frame/ops frame,generate this interrupt */
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_FWISR1
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_FS_TXBCNOK_PORT1_INT                   ((u32)0x00000001 << 31)          /*!<RW1C 0  PORT1 TX beacon OK interrupt */
-#define BIT_FS_TXBCNERR_PORT1_INT                  ((u32)0x00000001 << 30)          /*!<RW1C 0  PORT1 TX beacon Error interrupt */
-#define BIT_FS_TXBCNOK_PORT2_INT                   ((u32)0x00000001 << 29)          /*!<RW1C 0  PORT2 TX beacon OK interrupt */
-#define BIT_FS_TXBCNERR_PORT2_INT                  ((u32)0x00000001 << 28)          /*!<RW1C 0  PORT2 TX beacon Error interrupt */
-#define BIT_FS_EVTQ_TXDONE_INT                     ((u32)0x00000001 << 27)          /*!<RW1C 0  event queue done interrupt for NAN */
-#define BIT_FS_EVTQ_START_INT                      ((u32)0x00000001 << 26)          /*!<RW1C 0  event queue start interrupt for NAN */
-#define BIT_FS_DWWIN_END_INT                       ((u32)0x00000001 << 25)          /*!<RW1C 0  discovery window end interrupt for NAN */
-#define BIT_FS_BCN_IE_0_HIT_INT                    ((u32)0x00000001 << 24)          /*!<RW1C 0  rx bcn with ie0 hit */
-#define BIT_FS_BCN_IE_1_HIT_INT                    ((u32)0x00000001 << 23)          /*!<RW1C 0  rx bcn with ie1 hit */
-#define BIT_FS_RXBCN_NAN_RPT_OK                    ((u32)0x00000001 << 22)          /*!<RW1C 0  port2 rxbcn rpt and write to txrptbuf ok */
-#define BIT_FS_TIM_NO_HIT_INT                      ((u32)0x00000001 << 21)          /*!<RW1C 0  when no my aid or aid is 0(0x16DC[8]) or my bssid is not in tim element(0x16DB[31]),generate this interrupt */
-#define BIT_FS_BC_TWT_PARA_CHG_INT                 ((u32)0x00000001 << 20)          /*!<RW1C 0  RX broadcast twt with parameter changing,notify fw to read twt report */
-#define BIT_FS_TIM_HIT_INT                         ((u32)0x00000001 << 19)          /*!<RW1C 0  when my aid or aid is 0 (0x16DC[8]) or my bssid is in tim element,generate this interrupt */
-#define BIT_FS_HIOE_CHN0_INT                       ((u32)0x00000001 << 18)          /*!<RW1C 0  hioe_chn0 done interrupt */
-#define BIT_FS_HIOE_CHN1_INT                       ((u32)0x00000001 << 17)          /*!<RW1C 0  hioe_chn1 done interrupt */
-#define BIT_FS_HIOE_CHN_ON_INT                     ((u32)0x00000001 << 16)          /*!<RW1C 0  hioe_chn_on done interrupt */
-#define BIT_FS_HIOE_CHN_OFF_INT                    ((u32)0x00000001 << 15)          /*!<RW1C 0  hioe_chn_off done interrupt */
-#define BIT_FS_CHINFO_SEG_DONE_INT                 ((u32)0x00000001 << 14)          /*!<RW1C 0  indicate one channel info segment is received ok */
-#define BIT_FS_DFS_PKT_INT                         ((u32)0x00000001 << 13)          /*!<RW1C 0  enable interrupt when receiving dfs pkt and about to reach threshold of given pkt number or timeout */
-#define BIT_FS_RX_PHYSTS_DONE_INT                  ((u32)0x00000001 << 12)          /*!<RW1C 0  indicate physts is successfully write into physts_mem */
-#define BIT_FS_OPS_TIM_HIT_INT                     ((u32)0x00000001 << 11)          /*!<RW1C 0  when my aid or my bssid is in tim frame/ops frame,generate this interrupt */
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_LPSOFFLOAD_IMR
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_LPS_RXBCN_TSF_GT_THRES_INT_EN          ((u32)0x00000001 << 10)          /*!<R/W 0  The interrupt is issued when difference of tsft in beacon frame of port0 is greater than threshold */
-#define BIT_LPS_RX_PHYSTS_DONE_INT_EN              ((u32)0x00000001 << 9)          /*!<R/W 0  indicate physts is successfully write into physts_mem */
-#define BIT_LPS_HIOE_CHN_ON_INT_EN                 ((u32)0x00000001 << 8)          /*!<R/W 0  hioe_chn_on done interrupt */
-#define BIT_LPS_HIOE_CHN_OFF_INT_EN                ((u32)0x00000001 << 7)          /*!<R/W 0  hioe_chn_off done interrupt */
-#define BIT_LPS_TIM_NO_HIT_INT_EN                  ((u32)0x00000001 << 6)          /*!<R/W 0  when no my aid or aid is 0(0x16DC[8]) or my bssid is not in tim element(0x16DB[31]),generate this interrupt */
-#define BIT_LPS_BCNERLY0_INT_EN                    ((u32)0x00000001 << 5)          /*!<R/W 0  This interrupt is issued at the time set by DRVERLYINT register before TBTT0_MB0 time. */
-#define BIT_LPS_BCNELY0_AGGR_INT_EN                ((u32)0x00000001 << 4)          /*!<R/W 0  port 0 Beacon early aggregation interrupt */
-#define BIT_LPS_TBTT0_INT_EN                       ((u32)0x00000001 << 3)          /*!<R/W 0  the interrupt from the exact TBTT time for P0 MBSSID0. */
-#define BIT_LPS_RX_BCN_P0_INT_EN                   ((u32)0x00000001 << 2)          /*!<R/W 0  When this bit is enable, the interrupt is issued when RX beacon frame occurs in port0. */
-#define BIT_LPS_RX_BCN_ERR_P0_INT_EN               ((u32)0x00000001 << 1)          /*!<R/W 0  When this bit is enable, the interrupt is issued when RX beacon frame with fcs error occurs in port0. */
-#define BIT_LPS_RXBCN_TIMEUP_INT_EN                ((u32)0x00000001 << 0)          /*!<R/W 0  When this bit is enable, the interrupt is issued when RX beacon frame timeout occurs in port0. */
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_FT2IMR
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_PORT1_RX_UCMD1_UAPSD0_OK_INT_EN        ((u32)0x00000001 << 19)          /*!<R/W 0  PORT1 rx unicast packet ok interrupt with more data =1 & UAPSD =0 */
-#define BIT_PORT1_RX_UCMD0_UAPSD0_OK_INT_EN        ((u32)0x00000001 << 18)          /*!<R/W 0  PORT1 rx unicast packet ok interrupt with more data =0 & UAPSD =0 */
-#define BIT_PORT1_TRIPKT_OK_INT_EN                 ((u32)0x00000001 << 17)          /*!<R/W 0  PORT1 trigger packet assign to queue or release interrupt */
-#define BIT_PORT1_RX_EOSP_OK_INT_EN                ((u32)0x00000001 << 16)          /*!<R/W 0  PORT1 RX packet with EOSP =1 ok interrupt */
-#define BIT_FS_TXPRPT_CNT_FULL_INT_EN              ((u32)0x00000001 << 10)          /*!<R/W 0  txrpt buffer full interrupt */
-#define BIT_FS_NOA2_TSFT_BIT32_INT_EN              ((u32)0x00000001 << 9)          /*!<R/W 0  NOA unit2 TSFT bit 32 toggle interrupt */
-#define BIT_FS_NOA1_TSFT_BIT32_INT_EN              ((u32)0x00000001 << 8)          /*!<R/W 0  NOA unit1 TSFT bit 32 toggle interrupt */
-#define BIT_PORT1_TX_NULL1_DONE_INT_EN             ((u32)0x00000001 << 1)          /*!<R/W 0  PORT1 TX NULL1 packet ok interrupt */
-#define BIT_PORT1_TX_NULL0_DONE_INT_EN             ((u32)0x00000001 << 0)          /*!<R/W 0  PORT1 TX NULL0 packet ok interrupt */
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_FT2ISR
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_PORT1_RX_UCMD1_UAPSD0_OK_INT           ((u32)0x00000001 << 19)          /*!<RW1C 0  PORT1 rx unicast packet ok interrupt with more data =1 & UAPSD =0 */
-#define BIT_PORT1_RX_UCMD0_UAPSD0_OK_INT           ((u32)0x00000001 << 18)          /*!<RW1C 0  PORT1 rx unicast packet ok interrupt with more data =0 & UAPSD =0 */
-#define BIT_PORT1_TRIPKT_OK_INT                    ((u32)0x00000001 << 17)          /*!<RW1C 0  PORT1 trigger packet assign to queue or release interrupt */
-#define BIT_PORT1_RX_EOSP_OK_INT                   ((u32)0x00000001 << 16)          /*!<RW1C 0  PORT1 RX packet with EOSP =1 ok interrupt */
-#define BIT_FS_TXPRPT_CNT_FULL_INT                 ((u32)0x00000001 << 10)          /*!<RW1C 0  txrpt buffer full interrupt */
-#define BIT_FS_NOA2_TSFT_BIT32_INT                 ((u32)0x00000001 << 9)          /*!<RW1C 0  NOA unit2 TSFT bit 32 toggle interrupt */
-#define BIT_FS_NOA1_TSFT_BIT32_INT                 ((u32)0x00000001 << 8)          /*!<RW1C 0  NOA unit1 TSFT bit 32 toggle interrupt */
-#define BIT_PORT1_TX_NULL1_DONE_INT                ((u32)0x00000001 << 1)          /*!<RW1C 0  PORT1 TX NULL1 packet ok interrupt */
-#define BIT_PORT1_TX_NULL0_DONE_INT                ((u32)0x00000001 << 0)          /*!<RW1C 0  PORT1 TX NULL0 packet ok interrupt */
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_MSG2
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_MASK_FW_MSG2                           ((u32)0xFFFFFFFF << 0)          /*!<R/W 0  fw message 2 */
-#define BIT_FW_MSG2(x)                             ((u32)(((x) & 0xFFFFFFFF) << 0))
-#define BIT_GET_FW_MSG2(x)                         ((u32)(((x >> 0) & 0xFFFFFFFF)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_MSG3
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_MASK_FW_MSG3                           ((u32)0xFFFFFFFF << 0)          /*!<R/W 0  fw message 3 */
-#define BIT_FW_MSG3(x)                             ((u32)(((x) & 0xFFFFFFFF) << 0))
-#define BIT_GET_FW_MSG3(x)                         ((u32)(((x >> 0) & 0xFFFFFFFF)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_MSG4
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_MASK_FW_MSG4                           ((u32)0xFFFFFFFF << 0)          /*!<R/W 0  fw message 4 */
-#define BIT_FW_MSG4(x)                             ((u32)(((x) & 0xFFFFFFFF) << 0))
-#define BIT_GET_FW_MSG4(x)                         ((u32)(((x >> 0) & 0xFFFFFFFF)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_MSG5
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_MASK_FW_MSG5                           ((u32)0xFFFFFFFF << 0)          /*!<R/W 0  fw message 5 */
-#define BIT_FW_MSG5(x)                             ((u32)(((x) & 0xFFFFFFFF) << 0))
-#define BIT_GET_FW_MSG5(x)                         ((u32)(((x >> 0) & 0xFFFFFFFF)))
-/** @} */
-
-
-/*==========PAGE1 Register Address Definition==========*/
-#define REG_CR                                       0x0100
-#define REG_PG_SIZE                                  0x0104
-#define REG_TSF_CLK_STATE                            0x0108
-#define REG_TXDMA_PQ_MAP                             0x010C
-//#define REG_                                         0x0110
-#define REG_TRXFF_BNDY                               0x0114
-#define REG_PTA_I2C_MBOX                             0x0118
-#define REG_RXFF_PTR                                 0x011C
-#define REG_FE1IMR                                   0x0120
-#define REG_FE1ISR                                   0x0124
-//#define REG_                                         0x0128
-//#define REG_                                         0x012C
-#define REG_FWIMR                                    0x0130
-#define REG_FWISR                                    0x0134
-#define REG_FTIMR                                    0x0138
-#define REG_FTISR                                    0x013C
-#define REG_PHYSTS_REL                               0x0140
-#define REG_CHANNEL_INFO_REL                         0x0144
-
-#define REG_PKTBUF_DBG_DATA_H                        0x0148
-//#define REG_                                         0x014C
-#define REG_TC0_CTRL                                 0x0150
-#define REG_TC1_CTRL                                 0x0154
-#define REG_TC2_CTRL                                 0x0158
-#define REG_TC3_CTRL                                 0x015C
-#define REG_TC4_CTRL                                 0x0160
-#define REG_TCUNIT_BASE                              0x0164
-#define REG_TC5_CTRL                                 0x0168
-#define REG_TC6_CTRL                                 0x016C
-#define REG_HW_IOE_CR_CHN1                           0x0170
-#define REG_HW_IOE_CR_CHN_ON                         0x0174
-#define REG_HW_IOE_CR_CHN_OFF                        0x0178
-#define REG_RXBCN_TIMER                              0x017C
-#define REG_AES_DECRPT_DATA                          0x0180
-#define REG_AES_DECRPT_CFG                           0x0184
-#define REG_RSHA1_DATA                               0x0188
-#define REG_MACCLKFRQ                                0x018C
-#define REG_TMETER                                   0x0190
-#define REG_OSC_32K_CTRL                             0x0194
-#define REG_32K_CAL_REG0                             0x0198
-#define REG_32K_XTAL_CR                              0x019C
-#define REG_C2HEVT                                   0x01A0
-#define REG_C2HEVT_1                                 0x01A4
-#define REG_C2HEVT_2                                 0x01A8
-#define REG_C2HEVT_3                                 0x01AC
-#define REG_HW_IOE_CR_CH0                            0x01B0
-#define REG_BB_RFC_ATR                               0x01B4
-//#define REG_SW_DEFINED_PAGE1                         0x01B8
-//#define REG_SW_DEFINED_PAGE2                         0x01BC
-//#define REG_MCUTST_I                                 0x01C0
-//#define REG_MCUTST_II                                0x01C4
-#define REG_FMETHR                                   0x01C8
-#define REG_HMETFR                                   0x01CC
-#define REG_HMEBOX0                                  0x01D0
-#define REG_HMEBOX1                                  0x01D4
-#define REG_HMEBOX2                                  0x01D8
-#define REG_HMEBOX3                                  0x01DC
-#define REG_LLT_IND_ACCESS                           0x01E0
-#define REG_GENTST                                   0x01E4
-#define REG_BB_ACCESS_CTRL                           0x01E8
-#define REG_BB_ACCESS_DATA                           0x01EC
-#define REG_HMEBOX_E0                                0x01F0
-#define REG_HMEBOX_E1                                0x01F4
-#define REG_HMEBOX_E2                                0x01F8
-#define REG_HMEBOX_E3                                0x01FC
-//#define REG_FS_FW_DEBUG_0                            0x1100
-//#define REG_FS_FW_DEBUG_1                            0x1104
-//#define REG_FS_FW_DEBUG_2                            0x1108
-//#define REG_FS_FW_DEBUG_3                            0x110C
-#define REG_ZB2WL_MAILBOX                            0x1110
-#define REG_WL2ZB_MAILBOX                            0x1114
-//#define REG_                                         0x1118
-//#define REG_                                         0x111C
-#define REG_FE2IMR                                   0x1120
-#define REG_FE2ISR                                   0x1124
-#define REG_FE3IMR                                   0x1128
-#define REG_FE3ISR                                   0x112C
-#define REG_FE4IMR                                   0x1130
-#define REG_FE4ISR                                   0x1134
-#define REG_FT1IMR                                   0x1138
-#define REG_FT1ISR                                   0x113C
-#define REG_TWT_CTRL                                 0x1140
-//#define REG_                                         0x1144
-//#define REG_                                         0x1148
-//#define REG_                                         0x114C
-//#define REG_                                         0x1150
-//#define REG_                                         0x1154
-//#define REG_                                         0x1158
-//#define REG_                                         0x115C
-//#define REG_                                         0x1160
-//#define REG_                                         0x1164
-#define REG_FE5IMR                                   0x1168
-#define REG_FE5ISR                                   0x116C
-#define REG_FE6IMR                                   0x1170
-#define REG_FE6ISR                                   0x1174
-//#define REG_                                         0x1178
-#define REG_EXT_QUEUE_REGISTER                       0x117C
-//#define REG_                                         0x1180
-//#define REG_                                         0x1184
-//#define REG_                                         0x1188
-//#define REG_                                         0x118C
-#define REG_I2C_BT_MAILBOX_OUT_LOW                   0x1190
-#define REG_I2C_BT_MAILBOX_OUT_HIGH                  0x1194
-#define REG_I2C_BT_MAILBOX_CONTROL                   0x1198
-#define REG_I2C_BT_MAILBOX_IN_LOW                    0x119C
-#define REG_I2C_BT_MAILBOX_IN_HIGH                   0x11A0
-#define REG_EXT_BT_MAILBOX_OUT_LOW                   0x11A4
-#define REG_EXT_BT_MAILBOX_OUT_HIGH                  0x11A8
-#define REG_EXT_BT_MAILBOX_CONTROL                   0x11AC
-#define REG_EXT_BT_MAILBOX_IN_LOW                    0x11B0
-#define REG_EXT_BT_MAILBOX_IN_HIGH                   0x11B4
-//#define REG_                                         0x11B8
-//#define REG_                                         0x11BC
-#define REG_FWIMR1                                   0x11C0
-#define REG_FWISR1                                   0x11C4
-#define REG_LPSOFFLOAD_IMR                           0x11C8
-//#define REG_                                         0x11CC
-//#define REG_                                         0x11D0
-//#define REG_                                         0x11D4
-//#define REG_                                         0x11D8
-//#define REG_                                         0x11DC
-#define REG_FT2IMR                                   0x11E0
-#define REG_FT2ISR                                   0x11E4
-//#define REG_                                         0x11E8
-//#define REG_                                         0x11EC
-#define REG_MSG2                                     0x11F0
-#define REG_MSG3                                     0x11F4
-#define REG_MSG4                                     0x11F8
-#define REG_MSG5                                     0x11FC
-
-/* AUTO_GEN_END */
-
-/* MANUAL_GEN_START */
-
-//Please add your defination here
-
-/* MANUAL_GEN_END */
-
-#endif
diff --git a/os/board/rtl8720e/src/component/wifi/wifi_fw/amebalite/include/wififw_reg_page12.h b/os/board/rtl8720e/src/component/wifi/wifi_fw/amebalite/include/wififw_reg_page12.h
deleted file mode 100644
index 0c7357095..000000000
--- a/os/board/rtl8720e/src/component/wifi/wifi_fw/amebalite/include/wififw_reg_page12.h
+++ /dev/null
@@ -1,371 +0,0 @@
-#ifndef __WIFIFW_REG_PAGE12_H__
-#define __WIFIFW_REG_PAGE12_H__
-
-/* AUTO_GEN_START */
-
-/**************************************************************************//**
- * @defgroup REG_DDMA_CH0SA
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_MASK_DDMACH0_SA              ((u32)0xFFFFFFFF << 0)          /*!<R/W 0  Source Address: the source SRAM address that DDMA will read from. This address bus support byte alignment. */
-#define BIT_DDMACH0_SA(x)                ((u32)(((x) & 0xFFFFFFFF) << 0))
-#define BIT_GET_DDMACH0_SA(x)            ((u32)(((x >> 0) & 0xFFFFFFFF)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_DDMA_CH0DA
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_MASK_DDMACH0_DA              ((u32)0xFFFFFFFF << 0)          /*!<R/W 0  Destination Address: This address bus support byte alignment. */
-#define BIT_DDMACH0_DA(x)                ((u32)(((x) & 0xFFFFFFFF) << 0))
-#define BIT_GET_DDMACH0_DA(x)            ((u32)(((x >> 0) & 0xFFFFFFFF)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_DDMA_CH0CTRL
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_DDMACH0_OWN                  ((u32)0x00000001 << 31)          /*!<R/W 0  Set ‘1’ by firmware/driver to denote this DMA channel info is ready for DMA engine to begin DMA activity; after DMA complete, DMA engine will clear it to ‘0’ to denote for firmware that this channel is standby again. */
-#define BIT_DDMACH0_IDMEM_ERR            ((u32)0x00000001 << 30)          /*!<R 0  1: Ddma I/D MEM fail. Please check 0x80[0]=1 or DMEM protection is release 0: No error */
-#define BIT_DDMACH0_CHKSUM_EN            ((u32)0x00000001 << 29)          /*!<R/W 0  16bits Exclusive OR checksum enable */
-#define BIT_DDMACH0_DA_W_DISABLE         ((u32)0x00000001 << 28)          /*!<R/W 0  DA write disable When DDMACH0_CHKSUM_EN=1, DDMACH0_DA_W_DISABLE = 1 means that DMA engine doesn’t move pkt to destination but executes checksum only and report status to DDMACH0_CHKSUM_STS. */
-#define BIT_DDMACH0_CHKSUM_STS           ((u32)0x00000001 << 27)          /*!<R/W1C 0  0: Exclusive OR checksum ok 1: Exclusive OR checksum fail */
-#define BIT_DDMACH0_CHKSUM_CONT          ((u32)0x00000001 << 24)          /*!<R/W 0  Set1, hw will continuously check sum in several ddma bursts */
-#define BIT_MASK_DDMACH0_DLEN            ((u32)0x0003FFFF << 0)          /*!<R/W 0  DMA Length: Length count served by DMA engine, unit in 1 bytes. The range is from 1 to 256K. */
-#define BIT_DDMACH0_DLEN(x)              ((u32)(((x) & 0x0003FFFF) << 0))
-#define BIT_GET_DDMACH0_DLEN(x)          ((u32)(((x >> 0) & 0x0003FFFF)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_DDMA_CH1SA
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_MASK_DDMACH1_SA              ((u32)0xFFFFFFFF << 0)          /*!<R/W 0  Source Address: the source SRAM address that DDMA will read from. This address bus support byte alignment. */
-#define BIT_DDMACH1_SA(x)                ((u32)(((x) & 0xFFFFFFFF) << 0))
-#define BIT_GET_DDMACH1_SA(x)            ((u32)(((x >> 0) & 0xFFFFFFFF)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_DDMA_CH1DA
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_MASK_DDMACH1_DA              ((u32)0xFFFFFFFF << 0)          /*!<R/W 0  Destination Address: This address bus support byte alignment. */
-#define BIT_DDMACH1_DA(x)                ((u32)(((x) & 0xFFFFFFFF) << 0))
-#define BIT_GET_DDMACH1_DA(x)            ((u32)(((x >> 0) & 0xFFFFFFFF)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_DDMA_CH1CTRL
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_DDMACH1_OWN                  ((u32)0x00000001 << 31)          /*!<R/W 0  Set ‘1’ by firmware/driver to denote this DMA channel info is ready for DMA engine to begin DMA activity; after DMA complete, DMA engine will clear it to ‘0’ to denote for firmware that this channel is standby again. */
-#define BIT_DDMACH1_IDMEM_ERR            ((u32)0x00000001 << 30)          /*!<R 0  1: Ddma I/D MEM fail. Please check 0x80[0]=1 or DMEM protection is release 0: No error */
-#define BIT_DDMACH1_CHKSUM_EN            ((u32)0x00000001 << 29)          /*!<R/W 0  16bits Exclusive OR checksum enable */
-#define BIT_DDMACH1_DA_W_DISABLE         ((u32)0x00000001 << 28)          /*!<R/W 0  DA write disable When DDMACH1_CHKSUM_EN=1, DDMACH1_DA_W_DISABLE = 1 means that DMA engine doesn’t move pkt to destination but executes checksum only and report status to DDMACH1_CHKSUM_STS. */
-#define BIT_DDMACH1_CHKSUM_STS           ((u32)0x00000001 << 27)          /*!<R/W1C 0  0: Exclusive OR checksum ok 1: Exclusive OR checksum fail */
-#define BIT_DDMACH1_CHKSUM_CONT          ((u32)0x00000001 << 24)          /*!<R/W 0  Set1, hw will continuously check sum in several ddma bursts */
-#define BIT_MASK_DDMACH1_DLEN            ((u32)0x0003FFFF << 0)          /*!<R/W 0  DMA Length: Length count served by DMA engine, unit in 1 bytes. The range is from 1 to 256K. */
-#define BIT_DDMACH1_DLEN(x)              ((u32)(((x) & 0x0003FFFF) << 0))
-#define BIT_GET_DDMACH1_DLEN(x)          ((u32)(((x >> 0) & 0x0003FFFF)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_DDMA_CH2SA
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_MASK_DDMACH2_SA              ((u32)0xFFFFFFFF << 0)          /*!<R/W 0  Source Address: the source SRAM address that DDMA will read from. This address bus support byte alignment. */
-#define BIT_DDMACH2_SA(x)                ((u32)(((x) & 0xFFFFFFFF) << 0))
-#define BIT_GET_DDMACH2_SA(x)            ((u32)(((x >> 0) & 0xFFFFFFFF)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_DDMA_CH2DA
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_MASK_DDMACH2_DA              ((u32)0xFFFFFFFF << 0)          /*!<R/W 0  Destination Address: This address bus support byte alignment. */
-#define BIT_DDMACH2_DA(x)                ((u32)(((x) & 0xFFFFFFFF) << 0))
-#define BIT_GET_DDMACH2_DA(x)            ((u32)(((x >> 0) & 0xFFFFFFFF)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_DDMA_CH2CTRL
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_DDMACH2_OWN                  ((u32)0x00000001 << 31)          /*!<R/W 0  Set ‘1’ by firmware/driver to denote this DMA channel info is ready for DMA engine to begin DMA activity; after DMA complete, DMA engine will clear it to ‘0’ to denote for firmware that this channel is standby again. */
-#define BIT_DDMACH2_IDMEM_ERR            ((u32)0x00000001 << 30)          /*!<R 0  1: Ddma I/D MEM fail. Please check 0x80[0]=1 or DMEM protection is release 0: No error */
-#define BIT_DDMACH2_CHKSUM_EN            ((u32)0x00000001 << 29)          /*!<R/W 0  16bits Exclusive OR checksum enable */
-#define BIT_DDMACH2_DA_W_DISABLE         ((u32)0x00000001 << 28)          /*!<R/W 0  DA write disable When DDMACH2_CHKSUM_EN=1, DDMACH2_DA_W_DISABLE = 1 means that DMA engine doesn’t move pkt to destination but executes checksum only and report status to DDMACH2_CHKSUM_STS. */
-#define BIT_DDMACH2_CHKSUM_STS           ((u32)0x00000001 << 27)          /*!<R/W1C 0  0: Exclusive OR checksum ok 1: Exclusive OR checksum fail */
-#define BIT_DDMACH2_DDMA_MODE            ((u32)0x00000001 << 26)          /*!<R/W 0  0: access DMEM/IMEM using cpu idle time slot 1: access DMEM/IMEM block cpu */
-#define BIT_MASK_DDMACH2_DLEN            ((u32)0x0003FFFF << 0)          /*!<R/W 0  DMA Length: Length count served by DMA engine, unit in 1 bytes. The range is from 1 to 256K. */
-#define BIT_DDMACH2_DLEN(x)              ((u32)(((x) & 0x0003FFFF) << 0))
-#define BIT_GET_DDMACH2_DLEN(x)          ((u32)(((x >> 0) & 0x0003FFFF)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_DDMA_CH3SA
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_MASK_DDMACH3_SA              ((u32)0xFFFFFFFF << 0)          /*!<R/W 0  Source Address: the source SRAM address that DDMA will read from. This address bus support byte alignment. */
-#define BIT_DDMACH3_SA(x)                ((u32)(((x) & 0xFFFFFFFF) << 0))
-#define BIT_GET_DDMACH3_SA(x)            ((u32)(((x >> 0) & 0xFFFFFFFF)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_DDMA_CH3DA
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_MASK_DDMACH3_DA              ((u32)0xFFFFFFFF << 0)          /*!<R/W 0  Destination Address: This address bus support byte alignment. */
-#define BIT_DDMACH3_DA(x)                ((u32)(((x) & 0xFFFFFFFF) << 0))
-#define BIT_GET_DDMACH3_DA(x)            ((u32)(((x >> 0) & 0xFFFFFFFF)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_DDMA_CH3CTRL
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_DDMACH3_OWN                  ((u32)0x00000001 << 31)          /*!<R/W 0  Set ‘1’ by firmware/driver to denote this DMA channel info is ready for DMA engine to begin DMA activity; after DMA complete, DMA engine will clear it to ‘0’ to denote for firmware that this channel is standby again. */
-#define BIT_DDMACH3_IDMEM_ERR            ((u32)0x00000001 << 30)          /*!<R 0  1: Ddma I/D MEM fail. Please check 0x80[0]=1 or DMEM protection is release 0: No error */
-#define BIT_DDMACH3_CHKSUM_EN            ((u32)0x00000001 << 29)          /*!<R/W 0  16bits Exclusive OR checksum enable */
-#define BIT_DDMACH3_DA_W_DISABLE         ((u32)0x00000001 << 28)          /*!<R/W 0  DA write disable When DDMACH3_CHKSUM_EN=1, DDMACH3_DA_W_DISABLE = 1 means that DMA engine doesn’t move pkt to destination but executes checksum only and report status to DDMACH3_CHKSUM_STS. */
-#define BIT_DDMACH3_CHKSUM_STS           ((u32)0x00000001 << 27)          /*!<R/W1C 0  0: Exclusive OR checksum ok 1: Exclusive OR checksum fail */
-#define BIT_DDMACH3_CHKSUM_CONT          ((u32)0x00000001 << 24)          /*!<R/W 0  Set1, hw will continuously check sum in several ddma bursts */
-#define BIT_MASK_DDMACH3_DLEN            ((u32)0x0003FFFF << 0)          /*!<R/W 0  DMA Length: Length count served by DMA engine, unit in 1 bytes. The range is from 1 to 256K. */
-#define BIT_DDMACH3_DLEN(x)              ((u32)(((x) & 0x0003FFFF) << 0))
-#define BIT_GET_DDMACH3_DLEN(x)          ((u32)(((x >> 0) & 0x0003FFFF)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_DDMA_CH4SA
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_MASK_DDMACH4_SA              ((u32)0xFFFFFFFF << 0)          /*!<R/W 0  Source Address: the source SRAM address that DDMA will read from. This address bus support byte alignment. */
-#define BIT_DDMACH4_SA(x)                ((u32)(((x) & 0xFFFFFFFF) << 0))
-#define BIT_GET_DDMACH4_SA(x)            ((u32)(((x >> 0) & 0xFFFFFFFF)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_DDMA_CH4DA
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_MASK_DDMACH4_DA              ((u32)0xFFFFFFFF << 0)          /*!<R/W 0  Destination Address: This address bus support byte alignment. */
-#define BIT_DDMACH4_DA(x)                ((u32)(((x) & 0xFFFFFFFF) << 0))
-#define BIT_GET_DDMACH4_DA(x)            ((u32)(((x >> 0) & 0xFFFFFFFF)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_DDMA_CH4CTRL
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_DDMACH4_OWN                  ((u32)0x00000001 << 31)          /*!<R/W 0  Set ‘1’ by firmware/driver to denote this DMA channel info is ready for DMA engine to begin DMA activity; after DMA complete, DMA engine will clear it to ‘0’ to denote for firmware that this channel is standby again. */
-#define BIT_DDMACH4_IDMEM_ERR            ((u32)0x00000001 << 30)          /*!<R 0  1: Ddma I/D MEM fail. Please check 0x80[0]=1 or DMEM protection is release 0: No error */
-#define BIT_DDMACH4_CHKSUM_EN            ((u32)0x00000001 << 29)          /*!<R/W 0  16bits Exclusive OR checksum enable */
-#define BIT_DDMACH4_DA_W_DISABLE         ((u32)0x00000001 << 28)          /*!<R/W 0  DA write disable When DDMACH4_CHKSUM_EN=1, DDMACH4_DA_W_DISABLE = 1 means that DMA engine doesn’t move pkt to destination but executes checksum only and report status to DDMACH4_CHKSUM_STS. */
-#define BIT_DDMACH4_CHKSUM_STS           ((u32)0x00000001 << 27)          /*!<R/W1C 0  0: Exclusive OR checksum ok 1: Exclusive OR checksum fail */
-#define BIT_DDMACH4_CHKSUM_CONT          ((u32)0x00000001 << 24)          /*!<R/W 0  Set1, hw will continuously check sum in several ddma bursts */
-#define BIT_MASK_DDMACH4_DLEN            ((u32)0x0003FFFF << 0)          /*!<R/W 0  DMA Length: Length count served by DMA engine, unit in 1 bytes. The range is from 1 to 256K. */
-#define BIT_DDMACH4_DLEN(x)              ((u32)(((x) & 0x0003FFFF) << 0))
-#define BIT_GET_DDMACH4_DLEN(x)          ((u32)(((x >> 0) & 0x0003FFFF)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_DDMA_CH5SA
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_MASK_DDMACH5_SA              ((u32)0xFFFFFFFF << 0)          /*!<R/W 0  Source Address: the source SRAM address that DDMA will read from. This address bus support byte alignment. */
-#define BIT_DDMACH5_SA(x)                ((u32)(((x) & 0xFFFFFFFF) << 0))
-#define BIT_GET_DDMACH5_SA(x)            ((u32)(((x >> 0) & 0xFFFFFFFF)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_DDMA_CH5DA
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_MASK_DDMACH5_DA              ((u32)0xFFFFFFFF << 0)          /*!<R/W 0  Destination Address: This address bus support byte alignment. */
-#define BIT_DDMACH5_DA(x)                ((u32)(((x) & 0xFFFFFFFF) << 0))
-#define BIT_GET_DDMACH5_DA(x)            ((u32)(((x >> 0) & 0xFFFFFFFF)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_DDMA_CH5CTRL
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_DDMACH5_OWN                  ((u32)0x00000001 << 31)          /*!<R/W 0  Set ‘1’ by firmware/driver to denote this DMA channel info is ready for DMA engine to begin DMA activity; after DMA complete, DMA engine will clear it to ‘0’ to denote for firmware that this channel is standby again. */
-#define BIT_DDMACH5_IDMEM_ERR            ((u32)0x00000001 << 30)          /*!<R 0  1: Ddma I/D MEM fail. Please check 0x80[0]=1 or DMEM protection is release 0: No error */
-#define BIT_DDMACH5_CHKSUM_EN            ((u32)0x00000001 << 29)          /*!<R/W 0  16bits Exclusive OR checksum enable */
-#define BIT_DDMACH5_DA_W_DISABLE         ((u32)0x00000001 << 28)          /*!<R/W 0  DA write disable When DDMACH5_CHKSUM_EN=1, DDMACH5_DA_W_DISABLE = 1 means that DMA engine doesn’t move pkt to destination but executes checksum only and report status to DDMACH5_CHKSUM_STS. */
-#define BIT_DDMACH5_CHKSUM_STS           ((u32)0x00000001 << 27)          /*!<R/W1C 0  0: Exclusive OR checksum ok 1: Exclusive OR checksum fail */
-#define BIT_DDMACH5_CHKSUM_CONT          ((u32)0x00000001 << 24)          /*!<R/W 0  Set1, hw will continuously check sum in several ddma bursts */
-#define BIT_MASK_DDMACH5_DLEN            ((u32)0x0003FFFF << 0)          /*!<R/W 0  DMA Length: Length count served by DMA engine, unit in 1 bytes. The range is from 1 to 256K. */
-#define BIT_DDMACH5_DLEN(x)              ((u32)(((x) & 0x0003FFFF) << 0))
-#define BIT_GET_DDMACH5_DLEN(x)          ((u32)(((x >> 0) & 0x0003FFFF)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_DDMA_INT_MSK
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_DDMACH5_MSK                  ((u32)0x00000001 << 5)          /*!<R/W 0  When this bit is set, this DDMA channel will generate interrupt when the DMA done. FW may check the DDMA_CHSTATUS register to determine the DDMA status. */
-#define BIT_DDMACH4_MSK                  ((u32)0x00000001 << 4)          /*!<R/W 0  When this bit is set, this DDMA channel will generate interrupt when the DMA done. FW may check the DDMA_CHSTATUS register to determine the DDMA status. */
-#define BIT_DDMACH3_MSK                  ((u32)0x00000001 << 3)          /*!<R/W 0  When this bit is set, this DDMA channel will generate interrupt when the DMA done. FW may check the DDMA_CHSTATUS register to determine the DDMA status. */
-#define BIT_DDMACH2_MSK                  ((u32)0x00000001 << 2)          /*!<R/W 0  When this bit is set, this DDMA channel will generate interrupt when the DMA done. FW may check the DDMA_CHSTATUS register to determine the DDMA status. */
-#define BIT_DDMACH1_MSK                  ((u32)0x00000001 << 1)          /*!<R/W 0  When this bit is set, this DDMA channel will generate interrupt when the DMA done. FW may check the DDMA_CHSTATUS register to determine the DDMA status. */
-#define BIT_DDMACH0_MSK                  ((u32)0x00000001 << 0)          /*!<R/W 0  When this bit is set, this DDMA channel will generate interrupt when the DMA done. FW may check the DDMA_CHSTATUS register to determine the DDMA status. */
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_DDMA_INT_STS
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_DDMACH5_DDMA_DONE            ((u32)0x00000001 << 5)          /*!<R/W1C 0  When this bit is set, this DDMA channel will generate interrupt when the DMA done. */
-#define BIT_DDMACH4_DDMA_DONE            ((u32)0x00000001 << 4)          /*!<R/W1C 0  When this bit is set, this DDMA channel will generate interrupt when the DMA done. */
-#define BIT_DDMACH3_DDMA_DONE            ((u32)0x00000001 << 3)          /*!<R/W1C 0  When this bit is set, this DDMA channel will generate interrupt when the DMA done. */
-#define BIT_DDMACH2_DDMA_DONE            ((u32)0x00000001 << 2)          /*!<R/W1C 0  When this bit is set, this DDMA channel will generate interrupt when the DMA done. */
-#define BIT_DDMACH1_DDMA_DONE            ((u32)0x00000001 << 1)          /*!<R/W1C 0  When this bit is set, this DDMA channel will generate interrupt when the DMA done. */
-#define BIT_DDMACH0_DDMA_DONE            ((u32)0x00000001 << 0)          /*!<R/W1C 0  When this bit is set, this DDMA channel will generate interrupt when the DMA done. */
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_DDMA_CHSTATUS
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_DDMACH5_REQ                  ((u32)0x00000001 << 5)          /*!<R 0  After CH5CTRL.OWN bit is polled, DDMA starts and asserts this bit. After the DMA transactions finish, this bit is de-asserted. */
-#define BIT_DDMACH4_REQ                  ((u32)0x00000001 << 4)          /*!<R 0  After CH4CTRL.OWN bit is polled, DDMA starts and asserts this bit. After the DMA transactions finish, this bit is de-asserted. */
-#define BIT_DDMACH3_REQ                  ((u32)0x00000001 << 3)          /*!<R 0  After CH3CTRL.OWN bit is polled, DDMA starts and asserts this bit. After the DMA transactions finish, this bit is de-asserted. */
-#define BIT_DDMACH2_REQ                  ((u32)0x00000001 << 2)          /*!<R 0  After CH2CTRL.OWN bit is polled, DDMA starts and asserts this bit. After the DMA transactions finish, this bit is de-asserted. */
-#define BIT_DDMACH1_REQ                  ((u32)0x00000001 << 1)          /*!<R 0  After CH1CTRL.OWN bit is polled, DDMA starts and asserts this bit. After the DMA transactions finish, this bit is de-asserted. */
-#define BIT_DDMACH0_REQ                  ((u32)0x00000001 << 0)          /*!<R 0  After CH0CTRL.OWN bit is polled, DDMA starts and asserts this bit. After the DMA transactions finish, this bit is de-asserted. */
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_DDMA_CHKSUM
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_MASK_DDMA_DST_CS             ((u32)0x00000003 << 22)          /*!<R 0  ddma_dst_ctl current status */
-#define BIT_DDMA_DST_CS(x)               ((u32)(((x) & 0x00000003) << 22))
-#define BIT_GET_DDMA_DST_CS(x)           ((u32)(((x >> 22) & 0x00000003)))
-#define BIT_MASK_DDMA_SRC_CS             ((u32)0x00000003 << 20)          /*!<R 0  ddma_src_ctl current status */
-#define BIT_DDMA_SRC_CS(x)               ((u32)(((x) & 0x00000003) << 20))
-#define BIT_GET_DDMA_SRC_CS(x)           ((u32)(((x >> 20) & 0x00000003)))
-#define BIT_MASK_DDMA_ARB_CS             ((u32)0x0000000F << 16)          /*!<R 0  ddma_arb_ctl current status */
-#define BIT_DDMA_ARB_CS(x)               ((u32)(((x) & 0x0000000F) << 16))
-#define BIT_GET_DDMA_ARB_CS(x)           ((u32)(((x >> 16) & 0x0000000F)))
-#define BIT_MASK_IDDMA0_CHKSUM           ((u32)0x0000FFFF << 0)          /*!<R 0  Iddma0 Check sum Result */
-#define BIT_IDDMA0_CHKSUM(x)             ((u32)(((x) & 0x0000FFFF) << 0))
-#define BIT_GET_IDDMA0_CHKSUM(x)         ((u32)(((x >> 0) & 0x0000FFFF)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_DDMA_MONITOR
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_IDDMA0_PERMU_UNDERFLOW       ((u32)0x00000001 << 14)          /*!<R/W1C 0  IDDMA0 permu underflow,, write clear */
-#define BIT_IDDMA0_FIFO_UNDERFLOW        ((u32)0x00000001 << 13)          /*!<R/W1C 0  IDDMA0 fifo underflow, write clear */
-#define BIT_IDDMA0_FIFO_OVERFLOW         ((u32)0x00000001 << 12)          /*!<R/W1C 0  IDDMA0 fifo overflow, write clear */
-#define BIT_CH5_ERR                      ((u32)0x00000001 << 5)          /*!<R/W1C 0  Ch5 is busy when it is set again, write clear */
-#define BIT_CH4_ERR                      ((u32)0x00000001 << 4)          /*!<R/W1C 0  Ch4 is busy when it is set again, write clear */
-#define BIT_CH3_ERR                      ((u32)0x00000001 << 3)          /*!<R/W1C 0  Ch3 is busy when it is set again, write clear */
-#define BIT_CH2_ERR                      ((u32)0x00000001 << 2)          /*!<R/W1C 0  Ch2 is busy when it is set again, write clear */
-#define BIT_CH1_ERR                      ((u32)0x00000001 << 1)          /*!<R/W1C 0  Ch1 is busy when it is set again, write clear */
-#define BIT_CH0_ERR                      ((u32)0x00000001 << 0)          /*!<R/W1C 0  Ch0 is busy when it is set again, write clear */
-/** @} */
-
-
-/*==========PAGE12 Register Address Definition==========*/
-#define REG_DDMA_CH0SA                               0x1200
-#define REG_DDMA_CH0DA                               0x1204
-#define REG_DDMA_CH0CTRL                             0x1208
-//#define REG_                                         0x120C
-#define REG_DDMA_CH1SA                               0x1210
-#define REG_DDMA_CH1DA                               0x1214
-#define REG_DDMA_CH1CTRL                             0x1218
-//#define REG_                                         0x121C
-#define REG_DDMA_CH2SA                               0x1220
-#define REG_DDMA_CH2DA                               0x1224
-#define REG_DDMA_CH2CTRL                             0x1228
-//#define REG_                                         0x122C
-#define REG_DDMA_CH3SA                               0x1230
-#define REG_DDMA_CH3DA                               0x1234
-#define REG_DDMA_CH3CTRL                             0x1238
-//#define REG_                                         0x123C
-#define REG_DDMA_CH4SA                               0x1240
-#define REG_DDMA_CH4DA                               0x1244
-#define REG_DDMA_CH4CTRL                             0x1248
-//#define REG_                                         0x124C
-#define REG_DDMA_CH5SA                               0x1250
-#define REG_DDMA_CH5DA                               0x1254
-#define REG_DDMA_CH5CTRL                             0x1258
-//#define REG_                                         0x125C
-//#define REG_                                         0x1260
-//#define REG_                                         0x1264
-//#define REG_                                         0x1268
-//#define REG_                                         0x126C
-//#define REG_                                         0x1270
-//#define REG_                                         0x1274
-//#define REG_                                         0x1278
-//#define REG_                                         0x127C
-//#define REG_                                         0x1280
-//#define REG_                                         0x1284
-//#define REG_                                         0x1288
-//#define REG_                                         0x128C
-//#define REG_                                         0x1290
-//#define REG_                                         0x1294
-//#define REG_                                         0x1298
-//#define REG_                                         0x129C
-//#define REG_                                         0x12A0
-//#define REG_                                         0x12A4
-//#define REG_                                         0x12A8
-//#define REG_                                         0x12AC
-//#define REG_                                         0x12B0
-//#define REG_                                         0x12B4
-//#define REG_                                         0x12B8
-//#define REG_                                         0x12BC
-//#define REG_                                         0x12C0
-//#define REG_                                         0x12C4
-//#define REG_                                         0x12C8
-//#define REG_                                         0x12CC
-//#define REG_                                         0x12D0
-//#define REG_                                         0x12D4
-//#define REG_                                         0x12D8
-//#define REG_                                         0x12DC
-#define REG_DDMA_INT_MSK                             0x12E0
-#define REG_DDMA_INT_STS                             0x12E4
-#define REG_DDMA_CHSTATUS                            0x12E8
-//#define REG_                                         0x12EC
-#define REG_DDMA_CHKSUM                              0x12F0
-//#define REG_DUMMY                                    0x12F4
-//#define REG_                                         0x12F8
-#define REG_DDMA_MONITOR                             0x12FC
-
-/* AUTO_GEN_END */
-
-/* MANUAL_GEN_START */
-
-//Please add your defination here
-
-/* MANUAL_GEN_END */
-
-#endif
diff --git a/os/board/rtl8720e/src/component/wifi/wifi_fw/amebalite/include/wififw_reg_page17.h b/os/board/rtl8720e/src/component/wifi/wifi_fw/amebalite/include/wififw_reg_page17.h
deleted file mode 100644
index 81a7419e4..000000000
--- a/os/board/rtl8720e/src/component/wifi/wifi_fw/amebalite/include/wififw_reg_page17.h
+++ /dev/null
@@ -1,844 +0,0 @@
-#ifndef __WIFIFW_REG_PAGE17_H__
-#define __WIFIFW_REG_PAGE17_H__
-
-/* AUTO_GEN_START */
-
-/**************************************************************************//**
- * @defgroup REG_RX_CFG
- * @brief rx configure register
- * @{
- *****************************************************************************/
-#define BIT_R_VHTNDPA_SUAID_0_EN            ((u32)0x00000001 << 31)          /*!<R/W 0  when set, will receive vht/he su ndpa which aid field is set to 0. */
-#define BIT_R_DIS_HE_SIGB_CHK               ((u32)0x00000001 << 30)          /*!<R/W 0  when set, disable check he-mu sigb crc8 */
-#define BIT_R_MBA_RSVD_AID_EN               ((u32)0x00000001 << 29)          /*!<R/W 0  enable parsing resevd aid msta-ba for pre-association */
-#define BIT_R_RXBCN_TIM_NO_HIT_EN           ((u32)0x00000001 << 28)          /*!<R/W 0  enable rxbcn_ok_int when receiving bcn with tim_no_hit,set 0: rxbcn_ok_int will only assert when tim_hit */
-#define BIT_R_TIM_NO_HIT_REJECT             ((u32)0x00000001 << 27)          /*!<R/W 0  enable reject tim no hit beacon */
-#define BIT_R_DIS_CHK_HENDP_LEN             ((u32)0x00000001 << 26)          /*!<R/W 0  disable check HE NDP lsig length value */
-#define BIT_R_CHK_MGNT_BSSID                ((u32)0x00000001 << 25)          /*!<R/W 0  enable check management frame bssid */
-#define BIT_R_CHK_CTL_BSSID                 ((u32)0x00000001 << 24)          /*!<R/W 0  enable check trigger,vht/hendpa and block ack bssid */
-#define BIT_R_DIS_STS_GCLK                  ((u32)0x00000001 << 23)          /*!<R/W 0  disable ppdu status clock gating */
-#define BIT_MASK_R_STS_CHKRX_COND           ((u32)0x0000000F << 19)          /*!<R/W 0  check macrx condition when receiving ppdu status */
-#define BIT_R_STS_CHKRX_COND(x)             ((u32)(((x) & 0x0000000F) << 19))
-#define BIT_GET_R_STS_CHKRX_COND(x)         ((u32)(((x >> 19) & 0x0000000F)))
-#define BIT_R_INTER_PPDU_REJECT             ((u32)0x00000001 << 18)          /*!<R/W 0  enable reject inter ppdu */
-#define BIT_R_EN_MACH_UPD_LEN               ((u32)0x00000001 << 17)          /*!<R/W 0  enable macrx_pktfifo_ctl update mpdu length in MACHDR_CHK state */
-#define BIT_R_SNIFFER_TB                    ((u32)0x00000001 << 16)          /*!<R/W 0  enable to receive TB PPDU for debug mode */
-#define BIT_R_RXPSF_INTER_PLCP              ((u32)0x00000001 << 6)          /*!<R/W 0  enable invalid packet check for inter ppdu, inter ppdu valid when plcp is inter bss */
-#define BIT_R_RXPSF_INTER_MPDU              ((u32)0x00000001 << 5)          /*!<R/W 0  enable invalid packet check for inter ppdu, inter ppdu valid when plcp and mac header are inter bss */
-#define BIT_R_RXPSF_HE_MU_CHKEN             ((u32)0x00000001 << 4)          /*!<R/W 0  enable HE MU invalid packet check for mac header */
-#define BIT_R_RXPSF_HE_ERSU_CHKEN           ((u32)0x00000001 << 3)          /*!<R/W 0  enable HE ER SU invalid packet check for mac header */
-#define BIT_R_RXPSF_HE_SU_CHKEN             ((u32)0x00000001 << 2)          /*!<R/W 0  enable HE SU invalid packet check for mac header */
-#define BIT_R_RXPSF_VHT_MU_CHKEN            ((u32)0x00000001 << 1)          /*!<R/W 0  enable VHT MU invalid packet check for mac header */
-#define BIT_R_RXPSF_VHT_SU_CHKEN            ((u32)0x00000001 << 0)          /*!<R/W 0  enable VHT SU invalid packet check for mac header */
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_RPL_CFG
- * @brief rx receive power level configure register
- * @{
- *****************************************************************************/
-#define BIT_MASK_R_RPLCFG_UPPER_DBM         ((u32)0x000001FF << 11)          /*!<R/W 0  rx power upper level */
-#define BIT_R_RPLCFG_UPPER_DBM(x)           ((u32)(((x) & 0x000001FF) << 11))
-#define BIT_GET_R_RPLCFG_UPPER_DBM(x)       ((u32)(((x >> 11) & 0x000001FF)))
-#define BIT_R_RPLCFG_UPPER_EN               ((u32)0x00000001 << 10)          /*!<R/W 0  enable use r_rplcfg_upper_dbm as rx power level */
-#define BIT_MASK_R_RPLCFG_DBM               ((u32)0x000001FF << 1)          /*!<R/W 0  rx power level */
-#define BIT_R_RPLCFG_DBM(x)                 ((u32)(((x) & 0x000001FF) << 1))
-#define BIT_GET_R_RPLCFG_DBM(x)             ((u32)(((x >> 1) & 0x000001FF)))
-#define BIT_R_RPLCFG_EN                     ((u32)0x00000001 << 0)          /*!<R/W 0  enable use r_rplcfg_dbm as rx power level */
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_AID
- * @brief aid register
- * @{
- *****************************************************************************/
-#define BIT_MASK_R_MAC_AID12_1              ((u32)0x00000FFF << 12)          /*!<R/W 0  aid1 */
-#define BIT_R_MAC_AID12_1(x)                ((u32)(((x) & 0x00000FFF) << 12))
-#define BIT_GET_R_MAC_AID12_1(x)            ((u32)(((x >> 12) & 0x00000FFF)))
-#define BIT_MASK_R_MAC_AID12_0              ((u32)0x00000FFF << 0)          /*!<R/W 0  aid0 */
-#define BIT_R_MAC_AID12_0(x)                ((u32)(((x) & 0x00000FFF) << 0))
-#define BIT_GET_R_MAC_AID12_0(x)            ((u32)(((x >> 0) & 0x00000FFF)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_TRAN_BSSID0_L
- * @brief trasmitted bssid register0_l
- * @{
- *****************************************************************************/
-#define BIT_MASK_R_WMAC_TRANSBSSID0_L       ((u32)0xFFFFFFFF << 0)          /*!<R/W 0  lower 32 bits of transmitted bssid0 */
-#define BIT_R_WMAC_TRANSBSSID0_L(x)         ((u32)(((x) & 0xFFFFFFFF) << 0))
-#define BIT_GET_R_WMAC_TRANSBSSID0_L(x)     ((u32)(((x >> 0) & 0xFFFFFFFF)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_TRAN_BSSID0_H
- * @brief trasmitted bssid register0_h
- * @{
- *****************************************************************************/
-#define BIT_R_MBSSID_CTLINFO_SRCH_EN        ((u32)0x00000001 << 24)          /*!<R/W 0  when set, rx trigger and vht/he ndpa, will search control info using assocaiated bssid */
-#define BIT_R_EN_PARTAID                    ((u32)0x00000001 << 23)          /*!<R/W 0  enable inter ppdu decision according to partial aid for VHT ppdu */
-#define BIT_R_EN_MBSSID                     ((u32)0x00000001 << 22)          /*!<R/W 0  enable multibssid function */
-#define BIT_MASK_R_BSS_COLOR0               ((u32)0x0000003F << 16)          /*!<R/W 0  bss color of current BSS */
-#define BIT_R_BSS_COLOR0(x)                 ((u32)(((x) & 0x0000003F) << 16))
-#define BIT_GET_R_BSS_COLOR0(x)             ((u32)(((x >> 16) & 0x0000003F)))
-#define BIT_MASK_R_WMAC_TRANSBSSID0_H       ((u32)0x0000FFFF << 0)          /*!<R/W 0  higher 16 bits of transmitted bssid0 */
-#define BIT_R_WMAC_TRANSBSSID0_H(x)         ((u32)(((x) & 0x0000FFFF) << 0))
-#define BIT_GET_R_WMAC_TRANSBSSID0_H(x)     ((u32)(((x >> 0) & 0x0000FFFF)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_TRAN_BSSID1_L
- * @brief trasmitted bssid register1_l
- * @{
- *****************************************************************************/
-#define BIT_MASK_R_WMAC_TRANSBSSID1_L       ((u32)0xFFFFFFFF << 0)          /*!<R/W 0  lower 32 bits of transmitted bssid1 */
-#define BIT_R_WMAC_TRANSBSSID1_L(x)         ((u32)(((x) & 0xFFFFFFFF) << 0))
-#define BIT_GET_R_WMAC_TRANSBSSID1_L(x)     ((u32)(((x >> 0) & 0xFFFFFFFF)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_TRAN_BSSID1_H
- * @brief trasmitted bssid register1_h
- * @{
- *****************************************************************************/
-#define BIT_MASK_R_BSS_COLOR1               ((u32)0x0000003F << 16)          /*!<R/W 0  bss color of current BSS */
-#define BIT_R_BSS_COLOR1(x)                 ((u32)(((x) & 0x0000003F) << 16))
-#define BIT_GET_R_BSS_COLOR1(x)             ((u32)(((x >> 16) & 0x0000003F)))
-#define BIT_MASK_R_WMAC_TRANSBSSID1_H       ((u32)0x0000FFFF << 0)          /*!<R/W 0  higher 16 bits of transmitted bssid1 */
-#define BIT_R_WMAC_TRANSBSSID1_H(x)         ((u32)(((x) & 0x0000FFFF) << 0))
-#define BIT_GET_R_WMAC_TRANSBSSID1_H(x)     ((u32)(((x >> 0) & 0x0000FFFF)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_GID_POS_EN_l
- * @brief VHT group id position enable register
- * @{
- *****************************************************************************/
-#define BIT_MASK_R_GID_POSITION_EN_L        ((u32)0xFFFFFFFF << 0)          /*!<R/W 0  VHT group id position enable */
-#define BIT_R_GID_POSITION_EN_L(x)          ((u32)(((x) & 0xFFFFFFFF) << 0))
-#define BIT_GET_R_GID_POSITION_EN_L(x)      ((u32)(((x >> 0) & 0xFFFFFFFF)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_GID_POS0
- * @brief VHT group id position0 register
- * @{
- *****************************************************************************/
-#define BIT_MASK_R_GID_POSITION0            ((u32)0xFFFFFFFF << 0)          /*!<R/W 0  VHT group id position0 */
-#define BIT_R_GID_POSITION0(x)              ((u32)(((x) & 0xFFFFFFFF) << 0))
-#define BIT_GET_R_GID_POSITION0(x)          ((u32)(((x >> 0) & 0xFFFFFFFF)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_GID_POS1
- * @brief VHT group id position1 register
- * @{
- *****************************************************************************/
-#define BIT_MASK_R_GID_POSITION1            ((u32)0xFFFFFFFF << 0)          /*!<R/W 0  VHT group id position1 */
-#define BIT_R_GID_POSITION1(x)              ((u32)(((x) & 0xFFFFFFFF) << 0))
-#define BIT_GET_R_GID_POSITION1(x)          ((u32)(((x >> 0) & 0xFFFFFFFF)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_GID_POS2
- * @brief VHT group id position2 register
- * @{
- *****************************************************************************/
-#define BIT_MASK_R_GID_POSITION2            ((u32)0xFFFFFFFF << 0)          /*!<R/W 0  VHT group id position2 */
-#define BIT_R_GID_POSITION2(x)              ((u32)(((x) & 0xFFFFFFFF) << 0))
-#define BIT_GET_R_GID_POSITION2(x)          ((u32)(((x >> 0) & 0xFFFFFFFF)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_GID_POS3
- * @brief VHT group id position3 register
- * @{
- *****************************************************************************/
-#define BIT_MASK_R_GID_POSITION3            ((u32)0xFFFFFFFF << 0)          /*!<R/W 0  VHT group id position3 */
-#define BIT_R_GID_POSITION3(x)              ((u32)(((x) & 0xFFFFFFFF) << 0))
-#define BIT_GET_R_GID_POSITION3(x)          ((u32)(((x >> 0) & 0xFFFFFFFF)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_BSSCOLOR_BITMAP_L
- * @brief bss color bitmap register_l
- * @{
- *****************************************************************************/
-#define BIT_MASK_R_BSSCOLOR_BITMAP_L        ((u32)0xFFFFFFFF << 0)          /*!<R/W 0  low 32bits bss color bitmap */
-#define BIT_R_BSSCOLOR_BITMAP_L(x)          ((u32)(((x) & 0xFFFFFFFF) << 0))
-#define BIT_GET_R_BSSCOLOR_BITMAP_L(x)      ((u32)(((x >> 0) & 0xFFFFFFFF)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_BSSCOLOR_BITMAP_H
- * @brief bss color bitmap register_h
- * @{
- *****************************************************************************/
-#define BIT_MASK_R_BSSCOLOR_BITMAP_H        ((u32)0xFFFFFFFF << 0)          /*!<R/W 0  high 32bits bss color bitmap */
-#define BIT_R_BSSCOLOR_BITMAP_H(x)          ((u32)(((x) & 0xFFFFFFFF) << 0))
-#define BIT_GET_R_BSSCOLOR_BITMAP_H(x)      ((u32)(((x >> 0) & 0xFFFFFFFF)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_PBSSID_BITMAP_L
- * @brief partial bssid bitmap register_l
- * @{
- *****************************************************************************/
-#define BIT_MASK_R_PARTIAL_BSSID_BITMAP_L   ((u32)0xFFFFFFFF << 0)          /*!<R/W 0  low 32bits partial bssid bitmap */
-#define BIT_R_PARTIAL_BSSID_BITMAP_L(x)     ((u32)(((x) & 0xFFFFFFFF) << 0))
-#define BIT_GET_R_PARTIAL_BSSID_BITMAP_L(x) ((u32)(((x >> 0) & 0xFFFFFFFF)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_PBSSID_BITMAP_H
- * @brief partial bssid bitmap register_h
- * @{
- *****************************************************************************/
-#define BIT_MASK_R_PARTIAL_BSSID_BITMAP_H   ((u32)0xFFFFFFFF << 0)          /*!<R/W 0  high 32bits partial bssid bitmap */
-#define BIT_R_PARTIAL_BSSID_BITMAP_H(x)     ((u32)(((x) & 0xFFFFFFFF) << 0))
-#define BIT_GET_R_PARTIAL_BSSID_BITMAP_H(x) ((u32)(((x >> 0) & 0xFFFFFFFF)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_SR_CFG0
- * @brief spatial reuse configure register0
- * @{
- *****************************************************************************/
-#define BIT_R_SPRUSE_RSVD_EN                ((u32)0x00000001 << 3)          /*!<R/W 0  enable spatial reuse when plcp header spatial reuse field value smaller than 14 or value is 15 and is srg ppdu */
-#define BIT_R_CTL_SRG_CHECK_EN              ((u32)0x00000001 << 2)          /*!<R/W 0  enable control packet srg ppdu check */
-#define BIT_R_SRG_CHECK_EN                  ((u32)0x00000001 << 1)          /*!<R/W 0  enable srg ppdu check */
-#define BIT_R_SR_EN                         ((u32)0x00000001 << 0)          /*!<R/W 0  enable spatial reuse function */
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_SR_CFG1
- * @brief spatial reuse configure register1
- * @{
- *****************************************************************************/
-#define BIT_MASK_R_NONSRG_OBSS_PD_MAX       ((u32)0x000000FF << 24)          /*!<R/W 0  the maximum value of non_SRG OBSS_PD */
-#define BIT_R_NONSRG_OBSS_PD_MAX(x)         ((u32)(((x) & 0x000000FF) << 24))
-#define BIT_GET_R_NONSRG_OBSS_PD_MAX(x)     ((u32)(((x >> 24) & 0x000000FF)))
-#define BIT_MASK_R_NONSRG_OBSS_PD_MIN       ((u32)0x000000FF << 16)          /*!<R/W 0  the minimum value of non_SRG OBSS_PD */
-#define BIT_R_NONSRG_OBSS_PD_MIN(x)         ((u32)(((x) & 0x000000FF) << 16))
-#define BIT_GET_R_NONSRG_OBSS_PD_MIN(x)     ((u32)(((x >> 16) & 0x000000FF)))
-#define BIT_MASK_R_SRG_OBSS_PD_MAX          ((u32)0x000000FF << 8)          /*!<R/W 0  the maximum value of OBSS_PD */
-#define BIT_R_SRG_OBSS_PD_MAX(x)            ((u32)(((x) & 0x000000FF) << 8))
-#define BIT_GET_R_SRG_OBSS_PD_MAX(x)        ((u32)(((x >> 8) & 0x000000FF)))
-#define BIT_MASK_R_SRG_OBSS_PD_MIN          ((u32)0x000000FF << 0)          /*!<R/W 0  the minimum value of OBSS_PD */
-#define BIT_R_SRG_OBSS_PD_MIN(x)            ((u32)(((x) & 0x000000FF) << 0))
-#define BIT_GET_R_SRG_OBSS_PD_MIN(x)        ((u32)(((x >> 0) & 0x000000FF)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_MACTX_SR
- * @brief SR field configure
- * @{
- *****************************************************************************/
-#define BIT_MASK_R_WMAC_WAIT_PHY_REF        ((u32)0x0000003F << 18)          /*!<R/W 0x10  mactx hang handle, reset mactx if the phy_txen is set and wait the begin pulse of phy_txon timeout */
-#define BIT_R_WMAC_WAIT_PHY_REF(x)          ((u32)(((x) & 0x0000003F) << 18))
-#define BIT_GET_R_WMAC_WAIT_PHY_REF(x)      ((u32)(((x >> 18) & 0x0000003F)))
-#define BIT_R_WMAC_SR_FIELD_EN              ((u32)0x00000001 << 17)          /*!<R/W 0  enable sr field reg cfg */
-#define BIT_R_WMAC_SR_VAL15_ALLOW           ((u32)0x00000001 << 16)          /*!<R/W 0  sr field can be the value 15 */
-#define BIT_MASK_R_WMAC_PLCP_SR_FIELD       ((u32)0x0000FFFF << 0)          /*!<R/W 0  value of SR field */
-#define BIT_R_WMAC_PLCP_SR_FIELD(x)         ((u32)(((x) & 0x0000FFFF) << 0))
-#define BIT_GET_R_WMAC_PLCP_SR_FIELD(x)     ((u32)(((x >> 0) & 0x0000FFFF)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_MACTX_MISC
- * @brief misc ctrl cfg
- * @{
- *****************************************************************************/
-#define BIT_R_TXTIME_CAL_DISGCLK            ((u32)0x00000001 << 30)          /*!<R/W 0  disable the clk gating for txtime compute module */
-#define BIT_R_WMAC_CCK_LOCKED_CLK           ((u32)0x00000001 << 29)          /*!<R/W 0x1  indicate that the transmit frequency and symbol clocks are derived from the same oscillator */
-#define BIT_MASK_R_WMAC_RST_BB_CNT          ((u32)0x00000007 << 26)          /*!<R/W 0x3  macclk cycle number of wmac_rst_bb signal */
-#define BIT_R_WMAC_RST_BB_CNT(x)            ((u32)(((x) & 0x00000007) << 26))
-#define BIT_GET_R_WMAC_RST_BB_CNT(x)        ((u32)(((x >> 26) & 0x00000007)))
-#define BIT_MASK_R_TXDFIFO_INTERVAL_THRE    ((u32)0x00003FFF << 12)          /*!<R/W 0x5  the interval threshold between txdfifo write and read pointer, if the interval is smaller than the threshold, mactx_mpdu moudle can pad dummy between mpdu(if eanbled) */
-#define BIT_R_TXDFIFO_INTERVAL_THRE(x)      ((u32)(((x) & 0x00003FFF) << 12))
-#define BIT_GET_R_TXDFIFO_INTERVAL_THRE(x)  ((u32)(((x >> 12) & 0x00003FFF)))
-#define BIT_SW_TXDFIFO_RDY                  ((u32)0x00000001 << 11)          /*!<R/W1C/ES 0  sw read txd fifo ready */
-#define BIT_MASK_SW_TXDFIFO_ADDR            ((u32)0x0000007F << 4)          /*!<R/W 0  sw read txd fifo address,[6:1] is address, [0] : 0 read low 32bit; 1 read high 32bit; */
-#define BIT_SW_TXDFIFO_ADDR(x)              ((u32)(((x) & 0x0000007F) << 4))
-#define BIT_GET_SW_TXDFIFO_ADDR(x)          ((u32)(((x >> 4) & 0x0000007F)))
-#define BIT_R_WMAC_FORCE_READ_TXDFIFO       ((u32)0x00000001 << 3)          /*!<R/W 0  during tx procedure, force read txd fifo, which is only use at the situation when bb is hang. */
-#define BIT_R_WMAC_SW_RD                    ((u32)0x00000001 << 2)          /*!<R/W 0  eanble sw read txdfifo */
-#define BIT_R_WMAC_MPDU_PADEN               ((u32)0x00000001 << 1)          /*!<R/W 0x1  when txdfifo underflow ,eanble the mactx_mpdu moudle to pad dummy between mpdu. */
-#define BIT_R_EOFPAD_EN                     ((u32)0x00000001 << 0)          /*!<R/W 0x1  enable eof pad operation at the end of mpdu */
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_MACTX_MHDR0
- * @brief MAC header configure
- * @{
- *****************************************************************************/
-#define BIT_R_QNULL_ACK_POL_VAL             ((u32)0x00000001 << 30)          /*!<R/W 1  basic trigger resp tb QOS NULL ack policy bit 0 value */
-#define BIT_R_WMAC_EN_HW_SSN                ((u32)0x00000001 << 29)          /*!<R/W 0x1  enable the hw ssn for qos null frame. */
-#define BIT_R_TB_QOSNULL_PWRMGT_VAL         ((u32)0x00000001 << 28)          /*!<R/W 0  the power management bit value in tb qos null, used during twt operation */
-#define BIT_R_WMAC_MHDR_UPH_EN              ((u32)0x00000001 << 27)          /*!<R/W 0  eanble reg wirte HTC field of tb_ppdu, which contain UPH a-control(4) */
-#define BIT_R_TCR_BA_RSVD_VAL               ((u32)0x00000001 << 26)          /*!<R/W 0  multi-sta BA bactl rsvd filed value */
-#define BIT_MASK_R_QOS_NULL_TID_VAL         ((u32)0x0000000F << 22)          /*!<R/W 0  tid value of qos null */
-#define BIT_R_QOS_NULL_TID_VAL(x)           ((u32)(((x) & 0x0000000F) << 22))
-#define BIT_GET_R_QOS_NULL_TID_VAL(x)       ((u32)(((x >> 22) & 0x0000000F)))
-#define BIT_MASK_R_WMAC_LEGACY_USTIMER      ((u32)0x0000001F << 17)          /*!<R/W 0xA  timer cnt before bb fetch txd for ofdm */
-#define BIT_R_WMAC_LEGACY_USTIMER(x)        ((u32)(((x) & 0x0000001F) << 17))
-#define BIT_GET_R_WMAC_LEGACY_USTIMER(x)    ((u32)(((x >> 17) & 0x0000001F)))
-#define BIT_MASK_R_WMAC_NON_LEGACY_USTIMER  ((u32)0x0000001F << 12)          /*!<R/W 0xD  timer cnt before bb fetch txd for he/vht/ht/cck */
-#define BIT_R_WMAC_NON_LEGACY_USTIMER(x)    ((u32)(((x) & 0x0000001F) << 12))
-#define BIT_GET_R_WMAC_NON_LEGACY_USTIMER(x) ((u32)(((x >> 12) & 0x0000001F)))
-#define BIT_MASK_R_BQR_PRIMCH               ((u32)0x00000007 << 9)          /*!<R/W 0  shift bqr bitmap to the allocatied primary 20M channel */
-#define BIT_R_BQR_PRIMCH(x)                 ((u32)(((x) & 0x00000007) << 9))
-#define BIT_GET_R_BQR_PRIMCH(x)             ((u32)(((x >> 9) & 0x00000007)))
-#define BIT_MASK_R_BQR_TID_VAL              ((u32)0x0000000F << 5)          /*!<R/W 0  bandwidth query report TID value */
-#define BIT_R_BQR_TID_VAL(x)                ((u32)(((x) & 0x0000000F) << 5))
-#define BIT_GET_R_BQR_TID_VAL(x)            ((u32)(((x >> 5) & 0x0000000F)))
-#define BIT_R_BSR_QOS_SEL                   ((u32)0x00000001 << 4)          /*!<R/W 0x1  Buffer status report enable */
-#define BIT_R_BSR_VO_TID_SEL                ((u32)0x00000001 << 3)          /*!<R/W 0  1: tid 7; 0: tid 6; */
-#define BIT_R_BSR_VI_TID_SEL                ((u32)0x00000001 << 2)          /*!<R/W 0  1: tid 5; 0: tid 4; */
-#define BIT_R_BSR_BE_TID_SEL                ((u32)0x00000001 << 1)          /*!<R/W 0  1: tid 2; 0: tid 1; */
-#define BIT_R_BSR_BK_TID_SEL                ((u32)0x00000001 << 0)          /*!<R/W 0  1: tid 3; 0: tid 0; */
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_MACTX_MHDR1
- * @brief MAC header HTC
- * @{
- *****************************************************************************/
-#define BIT_MASK_R_WMAC_NHDR_HTC            ((u32)0xFFFFFFFF << 0)          /*!<R/W 0  HTC field of tb_ppdu, which contain UPH a-control(4) */
-#define BIT_R_WMAC_NHDR_HTC(x)              ((u32)(((x) & 0xFFFFFFFF) << 0))
-#define BIT_GET_R_WMAC_NHDR_HTC(x)          ((u32)(((x >> 0) & 0xFFFFFFFF)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_MACTX_TXD_FIFO
- * @brief fifo do
- * @{
- *****************************************************************************/
-#define BIT_MASK_SW_TXDFIFO_DOUT            ((u32)0xFFFFFFFF << 0)          /*!<R 0  sw read rxd_out */
-#define BIT_SW_TXDFIFO_DOUT(x)              ((u32)(((x) & 0xFFFFFFFF) << 0))
-#define BIT_GET_SW_TXDFIFO_DOUT(x)          ((u32)(((x >> 0) & 0xFFFFFFFF)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_RXTRIG_TEST_COMM_0
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_MASK_RXTRIG_COMMON_0            ((u32)0xFFFFFFFF << 0)          /*!<R/W 0x0  low 32bit of comm field in trigger frame of test mode */
-#define BIT_RXTRIG_COMMON_0(x)              ((u32)(((x) & 0xFFFFFFFF) << 0))
-#define BIT_GET_RXTRIG_COMMON_0(x)          ((u32)(((x >> 0) & 0xFFFFFFFF)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_RXTRIG_TEST_COMM_1
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_MASK_RXTRIG_COMMON_1            ((u32)0xFFFFFFFF << 0)          /*!<R/W 0x0  high32bit of comm field in trigger frame of test mode */
-#define BIT_RXTRIG_COMMON_1(x)              ((u32)(((x) & 0xFFFFFFFF) << 0))
-#define BIT_GET_RXTRIG_COMMON_1(x)          ((u32)(((x >> 0) & 0xFFFFFFFF)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_RXTRIG_TEST_USER_0
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_MASK_RXTRIG_USERINFO_0          ((u32)0xFFFFFFFF << 0)          /*!<R/W 0x0  low 32bit of user field in trigger frame of test mode */
-#define BIT_RXTRIG_USERINFO_0(x)            ((u32)(((x) & 0xFFFFFFFF) << 0))
-#define BIT_GET_RXTRIG_USERINFO_0(x)        ((u32)(((x >> 0) & 0xFFFFFFFF)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_RXTRIG_TEST_USER_1
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_MASK_RXTRIG_USERINFO_1          ((u32)0xFFFFFFFF << 0)          /*!<R/W 0x0  high 32bit of user field in trigger frame of test mode */
-#define BIT_RXTRIG_USERINFO_1(x)            ((u32)(((x) & 0xFFFFFFFF) << 0))
-#define BIT_GET_RXTRIG_USERINFO_1(x)        ((u32)(((x >> 0) & 0xFFFFFFFF)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_RXTRIG_TEST_USER_2
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_MASK_RXTRIG_BSS_COLOR           ((u32)0x0000003F << 26)          /*!<R/W 0x0  bss color */
-#define BIT_RXTRIG_BSS_COLOR(x)             ((u32)(((x) & 0x0000003F) << 26))
-#define BIT_GET_RXTRIG_BSS_COLOR(x)         ((u32)(((x >> 26) & 0x0000003F)))
-#define BIT_MASK_RXTRIG_MACID               ((u32)0x0000007F << 19)          /*!<R/W 0x0  macid */
-#define BIT_RXTRIG_MACID(x)                 ((u32)(((x) & 0x0000007F) << 19))
-#define BIT_GET_RXTRIG_MACID(x)             ((u32)(((x >> 19) & 0x0000007F)))
-#define BIT_RXTRIG_FCSCHK_EN                ((u32)0x00000001 << 18)          /*!<R/W 0x0  1:enable fcs check */
-#define BIT_RXTRIG_PORT_SEL                 ((u32)0x00000001 << 17)          /*!<R/W 0x0  port sel */
-#define BIT_RXTRIG_EN                       ((u32)0x00000001 << 16)          /*!<WA0 0x0  enable rx trigger test mode */
-#define BIT_MASK_RXTRIG_USERINFO_2          ((u32)0x000000FF << 0)          /*!<R/W 0x0  msb 8bit of user field in trigger frame of test mode */
-#define BIT_RXTRIG_USERINFO_2(x)            ((u32)(((x) & 0x000000FF) << 0))
-#define BIT_GET_RXTRIG_USERINFO_2(x)        ((u32)(((x >> 0) & 0x000000FF)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_RXTRIG_TEST_CTRL1
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_MASK_RXTRIG_STATUS              ((u32)0x000000FF << 0)          /*!<R 0x0  [7:4]:trig_cntr [3:0]:ctl_state */
-#define BIT_RXTRIG_STATUS(x)                ((u32)(((x) & 0x000000FF) << 0))
-#define BIT_GET_RXTRIG_STATUS(x)            ((u32)(((x >> 0) & 0x000000FF)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_RXTRIG_TEST_CTRL2
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_MASK_RXTRIG_DURATION            ((u32)0x0000FFFF << 0)          /*!<R/W 0x0  duration of trigger frame */
-#define BIT_RXTRIG_DURATION(x)              ((u32)(((x) & 0x0000FFFF) << 0))
-#define BIT_GET_RXTRIG_DURATION(x)          ((u32)(((x >> 0) & 0x0000FFFF)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_AX_CLIENT_OM_CTRL
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_RXTRIG_RU26_DIS                 ((u32)0x00000001 << 7)          /*!<R/W 0  disable response to trigger frame when ru_allocation addressed to me is 26-tone ru */
-#define BIT_CSI_LEN_ERR_FLAG                ((u32)0x00000001 << 6)          /*!<R 0  csi_length error flag */
-#define BIT_CLR_CSI_ERR_FLAG                ((u32)0x00000001 << 5)          /*!<R/W 0  clear csi_length error flag */
-#define BIT_WMAC_RXTB_IGNOREA2              ((u32)0x00000001 << 4)          /*!<R/W 1  will not check a2 when receive tb ppdu */
-#define BIT_MASK_UL_MU_DIS                  ((u32)0x00000003 << 2)          /*!<R/W 0  Disable to respond UL response triggered by any trigger frame. Per port config. */
-#define BIT_UL_MU_DIS(x)                    ((u32)(((x) & 0x00000003) << 2))
-#define BIT_GET_UL_MU_DIS(x)                ((u32)(((x >> 2) & 0x00000003)))
-#define BIT_MASK_UL_MU_DATA_DIS             ((u32)0x00000003 << 0)          /*!<R/W 0  Disable to respond UL data triggered by basic trigger frame. Per port config. (BA/ACK/BSR/BQR are still allowed to Tx) */
-#define BIT_UL_MU_DATA_DIS(x)               ((u32)(((x) & 0x00000003) << 0))
-#define BIT_GET_UL_MU_DATA_DIS(x)           ((u32)(((x >> 0) & 0x00000003)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_SIFS_TIMING_CTRL_CCK
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_MASK_WMAC_100NS_TIME            ((u32)0x000000FF << 24)          /*!<R/W 0x4  Sets the 100ns time unit used by MAC clock.(DEFAULT:40M CLK,eg：20M clk should set this value to 2) */
-#define BIT_WMAC_100NS_TIME(x)              ((u32)(((x) & 0x000000FF) << 24))
-#define BIT_GET_WMAC_100NS_TIME(x)          ((u32)(((x >> 24) & 0x000000FF)))
-#define BIT_MASK_R2T_SIFS_CCK               ((u32)0x00000FFF << 12)          /*!<R/W 0x46  This register sets the SIFS time required for any immediate response for example Data-Ack. It is in unit of 100ns.(default:7us) */
-#define BIT_R2T_SIFS_CCK(x)                 ((u32)(((x) & 0x00000FFF) << 12))
-#define BIT_GET_R2T_SIFS_CCK(x)             ((u32)(((x >> 12) & 0x00000FFF)))
-#define BIT_MASK_T2T_SIFS_CCK               ((u32)0x00000FFF << 0)          /*!<R/W 0x46  This register sets the SIFS time required for consecutive TX events for example CTS-Data, or broadcast bursting. It is in unit of 100ns.(default:7us) */
-#define BIT_T2T_SIFS_CCK(x)                 ((u32)(((x) & 0x00000FFF) << 0))
-#define BIT_GET_T2T_SIFS_CCK(x)             ((u32)(((x >> 0) & 0x00000FFF)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_SIFS_TIMING_CTRL_OFDM
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_MASK_RX_AIR_END_TIME            ((u32)0x000000FF << 24)          /*!<R/W 0x3D  This register sets the time from cca fall to 6us. It is in unit of 100ns.(default:6.1us) */
-#define BIT_RX_AIR_END_TIME(x)              ((u32)(((x) & 0x000000FF) << 24))
-#define BIT_GET_RX_AIR_END_TIME(x)          ((u32)(((x >> 24) & 0x000000FF)))
-#define BIT_MASK_R2T_SIFS_OFDM              ((u32)0x00000FFF << 12)          /*!<R/W 0x82  This register sets the SIFS time required for any immediate response for example Data-Ack. It is in unit of 100ns.(default:13us) */
-#define BIT_R2T_SIFS_OFDM(x)                ((u32)(((x) & 0x00000FFF) << 12))
-#define BIT_GET_R2T_SIFS_OFDM(x)            ((u32)(((x >> 12) & 0x00000FFF)))
-#define BIT_MASK_T2T_SIFS_OFDM              ((u32)0x00000FFF << 0)          /*!<R/W 0x82  This register sets the SIFS time required for consecutive TX events for example CTS-Data, or broadcast bursting. It is in unit of 100ns.(default:13us) */
-#define BIT_T2T_SIFS_OFDM(x)                ((u32)(((x) & 0x00000FFF) << 0))
-#define BIT_GET_T2T_SIFS_OFDM(x)            ((u32)(((x >> 0) & 0x00000FFF)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_AX_TB_TIMING_CTRL
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_MASK_TB_TIMEOUT_REF             ((u32)0x00000FFF << 0)          /*!<R/W 0xB1  This register sets the max time for tb data aggragation, It is in unit of 100ns.(default:17.7us) */
-#define BIT_TB_TIMEOUT_REF(x)               ((u32)(((x) & 0x00000FFF) << 0))
-#define BIT_GET_TB_TIMEOUT_REF(x)           ((u32)(((x >> 0) & 0x00000FFF)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_SR_CONTROL_DBG
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_RXPPDU_SRG                      ((u32)0x00000001 << 27)          /*!<R 0  the received pkt is an srg ppdu */
-#define BIT_SR_UPD_EN                       ((u32)0x00000001 << 26)          /*!<R 0  the received pkt is allowed to update basic nav */
-#define BIT_SR_RESTRICTED                   ((u32)0x00000001 << 25)          /*!<R 0  the spatial reuse type is restricted */
-#define BIT_MASK_SR_PD_TX                   ((u32)0x000001FF << 16)          /*!<R 0  the value of received power level minus obss_pd_min */
-#define BIT_SR_PD_TX(x)                     ((u32)(((x) & 0x000001FF) << 16))
-#define BIT_GET_SR_PD_TX(x)                 ((u32)(((x >> 16) & 0x000001FF)))
-#define BIT_MASK_SR_TIMER_TX                ((u32)0x0000FFFF << 0)          /*!<R 0  time can be used for spatial reuse */
-#define BIT_SR_TIMER_TX(x)                  ((u32)(((x) & 0x0000FFFF) << 0))
-#define BIT_GET_SR_TIMER_TX(x)              ((u32)(((x >> 0) & 0x0000FFFF)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_SR_CONTROL_DBG1
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_MASK_SR_USABLE_TIMER_THRES      ((u32)0x000000FF << 0)          /*!<R/W 0x4  If received pkt can operate spatial reuse,the min threshold for sr_timer_tx. unit:256us(default:1024us) */
-#define BIT_SR_USABLE_TIMER_THRES(x)        ((u32)(((x) & 0x000000FF) << 0))
-#define BIT_GET_SR_USABLE_TIMER_THRES(x)    ((u32)(((x >> 0) & 0x000000FF)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_RX_NAV_CTRL
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_WMAC_PLCP_UP_NAV_EN             ((u32)0x00000001 << 4)          /*!<R/W 0  1:enable using txop_dur in plcp header to update nav */
-#define BIT_WMAC_TF_UP_NAV_EN               ((u32)0x00000001 << 3)          /*!<R/W 1  1:enable updating intra nav when receiving trigger frame */
-#define BIT_SRCTRL_PLCP_EN                  ((u32)0x00000001 << 2)          /*!<R/W 0  1:use txop_dur as sr_tx_timer */
-#define BIT_WMAC_INTRANAV_INTXOP            ((u32)0x00000001 << 1)          /*!<R/W 1  enable updating intra nav in my txop */
-#define BIT_WMAC_BASICNAV_INTXOP            ((u32)0x00000001 << 0)          /*!<R/W 1  enable updating basic nav in my txop */
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_NAV_STATUS
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_MASK_WMAC_INTRA_NAV_UPD         ((u32)0x00000003 << 30)          /*!<R 0  intra nav updated by 10: plcp header 01: mac header */
-#define BIT_WMAC_INTRA_NAV_UPD(x)           ((u32)(((x) & 0x00000003) << 30))
-#define BIT_GET_WMAC_INTRA_NAV_UPD(x)       ((u32)(((x >> 30) & 0x00000003)))
-#define BIT_MASK_WMAC_INTRA_NAV_DUR         ((u32)0x00003FFF << 16)          /*!<R 0  intra_nav */
-#define BIT_WMAC_INTRA_NAV_DUR(x)           ((u32)(((x) & 0x00003FFF) << 16))
-#define BIT_GET_WMAC_INTRA_NAV_DUR(x)       ((u32)(((x >> 16) & 0x00003FFF)))
-#define BIT_MASK_WMAC_BASIC_NAV_UPD         ((u32)0x00000003 << 14)          /*!<R 0  inter nav updated by 10: plcp header 01: mac header */
-#define BIT_WMAC_BASIC_NAV_UPD(x)           ((u32)(((x) & 0x00000003) << 14))
-#define BIT_GET_WMAC_BASIC_NAV_UPD(x)       ((u32)(((x >> 14) & 0x00000003)))
-#define BIT_MASK_WMAC_BASIC_NAV_DUR         ((u32)0x00003FFF << 0)          /*!<R 0  basic_nav */
-#define BIT_WMAC_BASIC_NAV_DUR(x)           ((u32)(((x) & 0x00003FFF) << 0))
-#define BIT_GET_WMAC_BASIC_NAV_DUR(x)       ((u32)(((x >> 0) & 0x00003FFF)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_RESP_CONTROL
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_RESP_CHK_TXNAV                  ((u32)0x00000001 << 31)          /*!<R/W 0  check txnav when need to response */
-#define BIT_RESP_CHK_INTRA_NAV              ((u32)0x00000001 << 30)          /*!<R/W 1  check intra nav when need to response */
-#define BIT_RESP_CHK_BASIC_NAV              ((u32)0x00000001 << 29)          /*!<R/W 1  check basic nav when need to response */
-#define BIT_RESP_STBC_EN                    ((u32)0x00000001 << 28)          /*!<R/W 0  enable stbc when need to response */
-#define BIT_RESP_HTC_EN                     ((u32)0x00000001 << 27)          /*!<R/W 0  enable appending htc when need to response */
-#define BIT_RESP_RATE_DOWNGRADE             ((u32)0x00000001 << 26)          /*!<R/W 0  enable downgrade response rate from HE to VHT, VHT to HT, HE to HT when need to response */
-#define BIT_RESP_DCM_EN                     ((u32)0x00000001 << 25)          /*!<R/W 1  enable using dcm need to response */
-#define BIT_RESP_TBPPDU_CHK_PWR             ((u32)0x00000001 << 23)          /*!<R/W 1  check tb ppdu tx power when rx trigger, if txpwr_ctrl send signal of abort,will not reply with tb ppdu */
-#define BIT_RESP_RXTRIG_CHK_INSIFS          ((u32)0x00000001 << 22)          /*!<R/W 1  check whether channel is idle during sifs, if csreq=1 in trigger frame, will not reply with tb ppdu */
-#define BIT_RESP_CHK_EDCCA                  ((u32)0x00000001 << 21)          /*!<R/W 1  check edcca when response */
-#define BIT_RESP_CHK_BTCCA                  ((u32)0x00000001 << 20)          /*!<R/W 0  check btcca when response */
-#define BIT_RESP_CHK_SEC_CCA20              ((u32)0x00000001 << 19)          /*!<R/W 0  check sec 20 cca when response */
-#define BIT_RESP_CHK_SEC_CCA40              ((u32)0x00000001 << 18)          /*!<R/W 0  check sec 40 cca when response */
-#define BIT_RESP_CHK_SEC_CCA80              ((u32)0x00000001 << 17)          /*!<R/W 0  check sec 80 cca when response */
-#define BIT_RESP_EARLY_LEG_SEC              ((u32)0x00000001 << 16)          /*!<R/W 1  when receive pkt of tkip or wep, While phyrxon down, mac_rxactive on. Ignore mac rx busy or physts_on, respond immediately. */
-#define BIT_MASK_RESP_GI_LTF                ((u32)0x00000007 << 13)          /*!<R/W 0  5:1x+0.8 4:1x+1.6 3:2x+0.8 2:2x+1.6 1:4x+0.8 0:4x+3.2 not support 1x+1.6 when response */
-#define BIT_RESP_GI_LTF(x)                  ((u32)(((x) & 0x00000007) << 13))
-#define BIT_GET_RESP_GI_LTF(x)              ((u32)(((x >> 13) & 0x00000007)))
-#define BIT_RESP_CHK_ZBCCA                  ((u32)0x00000001 << 12)          /*!<R/W 0  check zigbee cca when response */
-#define BIT_RESP_CHK_EDCCA_PER20            ((u32)0x00000001 << 11)          /*!<R/W 0  check edcca_per20_bitmap_sifs[0] when response */
-#define BIT_MASK_RESP_TXRATE                ((u32)0x000003FF << 0)           /*!<R/W 0x04  tx rate use to decide response rate */
-#define BIT_RESP_TXRATE(x)                  ((u32)(((x) & 0x000003FF) << 0))
-#define BIT_GET_RESP_TXRATE(x)              ((u32)(((x >> 0) & 0x000003FF)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_RESP_RATE_RRSR
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_MASK_RESP_RRSR_HE               ((u32)0x000000FF << 24)          /*!<R/W 1  Data Rate Control Table Register BitMap to indicate the response/protection/expected_response rate to use in this BSS. All management and control response frames should obey the rates set in the bitmap. Each bit is mapped as the following: HE 1SS MCS0~MCS7 Response rate must be less than or equal to the rate of the initiating frame. If none of the bits are set, no response is generated by Rtl8712. If both the legacy rates and HT rates are defined as Basic Rates, fill in only the legacy portion of the bitmap. If only HT rates are defined as Basic Rates, fill in both the legacy and HT portion of the bitmap. */
-#define BIT_RESP_RRSR_HE(x)                 ((u32)(((x) & 0x000000FF) << 24))
-#define BIT_GET_RESP_RRSR_HE(x)             ((u32)(((x >> 24) & 0x000000FF)))
-#define BIT_MASK_RESP_RRSR_VHT              ((u32)0x000000FF << 16)          /*!<R/W 1  VHT 1SS MCS0~MCS7 */
-#define BIT_RESP_RRSR_VHT(x)                ((u32)(((x) & 0x000000FF) << 16))
-#define BIT_GET_RESP_RRSR_VHT(x)            ((u32)(((x >> 16) & 0x000000FF)))
-#define BIT_MASK_RESP_RRSR_HT               ((u32)0x000000FF << 8)          /*!<R/W 1  HT 1SS MCS0~MCS7 */
-#define BIT_RESP_RRSR_HT(x)                 ((u32)(((x) & 0x000000FF) << 8))
-#define BIT_GET_RESP_RRSR_HT(x)             ((u32)(((x >> 8) & 0x000000FF)))
-#define BIT_MASK_RESP_RRSR_OFDM             ((u32)0x000000FF << 0)          /*!<R/W 1  {6M, 9M, 12M, 18M, 24M, 36M, 48M, 54M} */
-#define BIT_RESP_RRSR_OFDM(x)               ((u32)(((x) & 0x000000FF) << 0))
-#define BIT_GET_RESP_RRSR_OFDM(x)           ((u32)(((x >> 0) & 0x000000FF)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_RESP_RATE_RRSR_1
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_MASK_RESP_RRSR_CCK              ((u32)0x0000000F << 4)          /*!<R/W 0x3  {1M, 2M, 5.5M, 11M } */
-#define BIT_RESP_RRSR_CCK(x)                ((u32)(((x) & 0x0000000F) << 4))
-#define BIT_GET_RESP_RRSR_CCK(x)            ((u32)(((x >> 4) & 0x0000000F)))
-#define BIT_MASK_RESP_RATE_EN               ((u32)0x0000000F << 0)          /*!<R/W 0xf  [0]：enable respnse rate of CCK and OFDM [1]:enable respnse rate of HT [2]:enable respnse rate of VHT [3]:enable respnse rate of HE */
-#define BIT_RESP_RATE_EN(x)                 ((u32)(((x) & 0x0000000F) << 0))
-#define BIT_GET_RESP_RATE_EN(x)             ((u32)(((x >> 0) & 0x0000000F)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_BEAMFORMING_CTRL
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_MASK_WMAC_HE_CSI_RATE           ((u32)0x000001FF << 23)          /*!<R/W 0x180  HE CSI init rate(HE mode+NSS + MCS) */
-#define BIT_WMAC_HE_CSI_RATE(x)             ((u32)(((x) & 0x000001FF) << 23))
-#define BIT_GET_WMAC_HE_CSI_RATE(x)         ((u32)(((x >> 23) & 0x000001FF)))
-#define BIT_MASK_WMAC_VHT_CSI_RATE          ((u32)0x000001FF << 14)          /*!<R/W 0x100  VHT CSI init rate(VHT mode+ NSS + MCS) */
-#define BIT_WMAC_VHT_CSI_RATE(x)            ((u32)(((x) & 0x000001FF) << 14))
-#define BIT_GET_WMAC_VHT_CSI_RATE(x)        ((u32)(((x >> 14) & 0x000001FF)))
-#define BIT_MASK_WMAC_HT_CSI_RATE           ((u32)0x000001FF << 5)          /*!<R/W 0x080  HT CSI init rate(HT mode + NSS + MCS) */
-#define BIT_WMAC_HT_CSI_RATE(x)             ((u32)(((x) & 0x000001FF) << 5))
-#define BIT_GET_WMAC_HT_CSI_RATE(x)         ((u32)(((x >> 5) & 0x000001FF)))
-#define BIT_MASK_WMAC_MIMO_PARA_CNT         ((u32)0x00000007 << 2)          /*!<R/W 0x3  width of mimo_para_en,deafult:3(mac clk:40M,pluse width:100ns) */
-#define BIT_WMAC_MIMO_PARA_CNT(x)           ((u32)(((x) & 0x00000007) << 2))
-#define BIT_GET_WMAC_MIMO_PARA_CNT(x)       ((u32)(((x >> 2) & 0x00000007)))
-#define BIT_WMAC_CSI_BFRP_STOPTX            ((u32)0x00000001 << 1)          /*!<R/W 0x1  stop tx when rx ndpa/ndp and wait for bfrp poll frame */
-#define BIT_WMAC_HE_NDPA_EN                 ((u32)0x00000001 << 0)          /*!<R/W 1  Set to 1, MAC would inform BB of preparing to receive NDP if the received NDPA is valid. */
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_CSI_RRSR_BITMAP
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_MASK_WMAC_CSI_RRSR_BITMAP       ((u32)0xFFFFFFFF << 0)          /*!<R/W 0x3  BitMap to indicate the CSI frame rate in this BSS. Each bit is mapped as the following: Bit[7:0] = OFDM {6M, 9M, 12M, 18M, 24M, 36M, 48M, 54M} Bit[15:8] = HT MCS0~MCS7 BIT[23:16] = VHT 1SS MCS0~7 bit[31:24] = HE 1SS MCS0~7 The modulation of response rate must be less than or equal to the rate of the initiating frame. If none of the bits are set, no response is generated by Rtl8712. If both legacy rates and HT rates are defined as Basic Rates, fill in only the legacy portion of the bitmap. If only HT rates are defined as Basic Rates, fill in both the legacy and HT portion of the bitmap. */
-#define BIT_WMAC_CSI_RRSR_BITMAP(x)         ((u32)(((x) & 0xFFFFFFFF) << 0))
-#define BIT_GET_WMAC_CSI_RRSR_BITMAP(x)     ((u32)(((x >> 0) & 0xFFFFFFFF)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_LBK_CFG
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_MASK_R_MACLBK_RDY_PERIOD        ((u32)0x00000FFF << 0)          /*!<R/W 0x12  tdrdy/rdrdy interval count */
-#define BIT_R_MACLBK_RDY_PERIOD(x)          ((u32)(((x) & 0x00000FFF) << 0))
-#define BIT_GET_R_MACLBK_RDY_PERIOD(x)      ((u32)(((x >> 0) & 0x00000FFF)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_GID_POS_EN_H
- * @brief VHT group id position enable register
- * @{
- *****************************************************************************/
-#define BIT_MASK_R_GID_POSITION_EN_H        ((u32)0xFFFFFFFF << 0)          /*!<R/W 0  VHT group id position enable */
-#define BIT_R_GID_POSITION_EN_H(x)          ((u32)(((x) & 0xFFFFFFFF) << 0))
-#define BIT_GET_R_GID_POSITION_EN_H(x)      ((u32)(((x >> 0) & 0xFFFFFFFF)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_TRX_PKTCNT_CTRL
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_R_TXPKTCNT_RST                  ((u32)0x00000001 << 11)          /*!<R/W 0  Reset tx packet counter, write “one” to set the counter to zero */
-#define BIT_R_TX_UDPKTCNT_SET               ((u32)0x00000001 << 10)          /*!<R/W 0  Set user define packet configure, write one setting, it is only valid for r_wmac_txpktcnt_sel (4'd0 ~ 4'd3) */
-#define BIT_MASK_R_WMAC_TXPKTCNT_SEL        ((u32)0x0000000F << 6)          /*!<R/W 0  Tx packet counter report selection 4'd0: user define 0 counter 4'd1: user define 1 counter 4'd2: user define 2 counter 4'd3: user define 3 counter 4'd4: HT mpdu tx ok counter 4'd5: VHT SU mpdu tx ok counter 4'd6: HE SU mpdu tx ok counter 4'd7: HE TB mpdu tx ok counter 4'd8: CCK ppdu tx ok counter 4'd9: OFDM ppdu tx ok counter 4'd10: HT ppdu tx ok counter 4'd11: VHT SU ppdu tx ok counter 4'd12: HE SU ppdu tx ok counter 4'd13: HE TB ppdu tx ok counter 4'd14~4'd15: RSVD */
-#define BIT_R_WMAC_TXPKTCNT_SEL(x)          ((u32)(((x) & 0x0000000F) << 6))
-#define BIT_GET_R_WMAC_TXPKTCNT_SEL(x)      ((u32)(((x >> 6) & 0x0000000F)))
-#define BIT_MASK_R_WMAC_TXPKTCNT_CFG        ((u32)0x0000003F << 0)          /*!<R/W 0  Tx packet conuter user define configuration [5:2]:subtype [1:0]:type */
-#define BIT_R_WMAC_TXPKTCNT_CFG(x)          ((u32)(((x) & 0x0000003F) << 0))
-#define BIT_GET_R_WMAC_TXPKTCNT_CFG(x)      ((u32)(((x >> 0) & 0x0000003F)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_TRX_PKTCNT_RPT
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_MASK_RO_WMAC_TXPKTCNT_RPT       ((u32)0x03FFFFFF << 0)          /*!<R 0  [25:22]:Tx packet counter report selection,r_wmac_txpktcnt_sel [21:16]:user define->tx packet type,[21:18]:subtype,[17:16]:type; others->6'h0 [15:0]:The tx reported counter value corresponding to Report type selected */
-#define BIT_RO_WMAC_TXPKTCNT_RPT(x)         ((u32)(((x) & 0x03FFFFFF) << 0))
-#define BIT_GET_RO_WMAC_TXPKTCNT_RPT(x)     ((u32)(((x >> 0) & 0x03FFFFFF)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_BEAMFORMING_MIMO_STATUS
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_MASK_RO_WMAC_HE_CSI_MIMO_H      ((u32)0x00FFFFFF << 0)          /*!<R 0  msb 24bit of he csi mimo field */
-#define BIT_RO_WMAC_HE_CSI_MIMO_H(x)        ((u32)(((x) & 0x00FFFFFF) << 0))
-#define BIT_GET_RO_WMAC_HE_CSI_MIMO_H(x)    ((u32)(((x >> 0) & 0x00FFFFFF)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_PPDU_STATUS_CFG
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_MASK_R_STSBUF_ENDADDR           ((u32)0x000000FF << 4)          /*!<R/W 0xFF  ppdu status buffer end address */
-#define BIT_R_STSBUF_ENDADDR(x)             ((u32)(((x) & 0x000000FF) << 4))
-#define BIT_GET_R_STSBUF_ENDADDR(x)         ((u32)(((x >> 4) & 0x000000FF)))
-#define BIT_MASK_R_STSBUF_THRESHOD          ((u32)0x0000000F << 0)          /*!<R/W 0x4  ppdu status buffer almost full threshold */
-#define BIT_R_STSBUF_THRESHOD(x)            ((u32)(((x) & 0x0000000F) << 0))
-#define BIT_GET_R_STSBUF_THRESHOD(x)        ((u32)(((x >> 0) & 0x0000000F)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_RESP_CONTROL_1
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_WMAC_TXRAW_IGNOREA1             ((u32)0x00000001 << 17)          /*!<R/W 1  If set to 1, will not check A1 of rxpkt when txraw */
-#define BIT_RESP_ACTRL_BQR_EN               ((u32)0x00000001 << 16)          /*!<R/W 1  If set to 1, HW would update BQR info to A-CTRL */
-#define BIT_RESP_ACTRL_UPH_EN               ((u32)0x00000001 << 15)          /*!<R/W 1  If set to 1, HW would update UPH info to A-CTRL */
-#define BIT_RESP_ACTRL_BSR_EN               ((u32)0x00000001 << 14)          /*!<R/W 1  If set to 1, HW would update BSR info to A-CTRL */
-#define BIT_RESP_ACTRL_CAS_EN               ((u32)0x00000001 << 13)          /*!<R/W 1  If set to 1, HW would update CAS info to A-CTRL */
-#define BIT_RESP_LDPC_SEL                   ((u32)0x00000001 << 12)          /*!<R/W 1  1: follow ctrl reg(0x668[15]) 0: follow rxpkt */
-#define BIT_RESP_GID_SEL                    ((u32)0x00000001 << 11)          /*!<R/W 1  HE SIG-A content 1 : group id=0, 0 : group id=63 */
-#define BIT_MASK_RESP_DOPPLER_CTRL          ((u32)0x00000003 << 9)          /*!<R/W 0  0: Doppler unsupported 1: Doppler supported without moving 2: 10 symbol midamble periodicity 3: 20 symbol midamble periodicity */
-#define BIT_RESP_DOPPLER_CTRL(x)            ((u32)(((x) & 0x00000003) << 9))
-#define BIT_GET_RESP_DOPPLER_CTRL(x)        ((u32)(((x >> 9) & 0x00000003)))
-#define BIT_RESP_DOPPLER_SEL                ((u32)0x00000001 << 8)          /*!<R/W 0  1: follow ctrl reg(0x17E0[10]) 0: follow rxpkt */
-#define BIT_RESP_DCM_SEL                    ((u32)0x00000001 << 7)          /*!<R/W 0  1: follow ctrl reg(0x17b4[25]) 0: follow rxpkt */
-#define BIT_RESP_BSR_FORMAT                 ((u32)0x00000001 << 6)          /*!<R/W 0  0: legacy format of queue size 1: HE */
-#define BIT_MASK_RESP_NOMINAL_PAD           ((u32)0x00000003 << 4)          /*!<R/W 0  nominal pkt pad info when response */
-#define BIT_RESP_NOMINAL_PAD(x)             ((u32)(((x) & 0x00000003) << 4))
-#define BIT_GET_RESP_NOMINAL_PAD(x)         ((u32)(((x >> 4) & 0x00000003)))
-#define BIT_RESP_EARLY_START                ((u32)0x00000001 << 3)          /*!<R/W 1  when set to 1:use mac header rdy when rx data frame and use aid fit when rx trigger frame, and use fcsok otherwise to start responding process when set to 0:use fcs ok to start responding process when rx any frame need reply */
-#define BIT_RESP_USE_EARLY_FCS              ((u32)0x00000001 << 2)          /*!<R/W 1  use fcs result from rxpktfifo instead of macrx_parser when receive packet used wep/tkip */
-#define BIT_RESP_ALLACK_EN                  ((u32)0x00000001 << 1)          /*!<R/W 0  enable response with all-ack MBA */
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_SPATIAL_REUSE_CONTROL
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_MASK_TXPWR_CH20_DATA            ((u32)0x000000FF << 1)          /*!<R/W 0  indicate which 20M channel is punctured in RU */
-#define BIT_TXPWR_CH20_DATA(x)              ((u32)(((x) & 0x000000FF) << 1))
-#define BIT_GET_TXPWR_CH20_DATA(x)          ((u32)(((x >> 1) & 0x000000FF)))
-#define BIT_TXPWR_FAST_MODE_EN              ((u32)0x00000001 << 0)          /*!<R/W 1  fast mode enable for txpwr_ctrl,tie 1 for AMEBAD2 */
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_RX_SUPPER_ADDRESS3_L
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_MASK_R_SUP_ADDR3_L              ((u32)0xFFFFFFFF << 0)          /*!<R/W 0  Address3 for data packet check. When address3 is match, RX will receive the packet to RXFF without considering other filter condition except crc32 */
-#define BIT_R_SUP_ADDR3_L(x)                ((u32)(((x) & 0xFFFFFFFF) << 0))
-#define BIT_GET_R_SUP_ADDR3_L(x)            ((u32)(((x >> 0) & 0xFFFFFFFF)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_RX_SUPPER_ADDRESS3_H
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_R_SUP_ADDR3_EN                  ((u32)0x00000001 << 16)          /*!<R/W 0  when set, enable check supper Address3 */
-#define BIT_MASK_R_SUP_ADDR3_H              ((u32)0x0000FFFF << 0)          /*!<R/W 0  Address3 for data packet check. When address3 is match, RX will receive the mpdu to RXFF without considering other filter condition except crc32 */
-#define BIT_R_SUP_ADDR3_H(x)                ((u32)(((x) & 0x0000FFFF) << 0))
-#define BIT_GET_R_SUP_ADDR3_H(x)            ((u32)(((x >> 0) & 0x0000FFFF)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_MASK_LA_TRX_DBG_L
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_MASK_LA_TRX_PATTERN_MASK_L      ((u32)0xFFFFFFFF << 0)          /*!<R/W 0  used for mask one or more bits of debug port */
-#define BIT_LA_TRX_PATTERN_MASK_L(x)        ((u32)(((x) & 0xFFFFFFFF) << 0))
-#define BIT_GET_LA_TRX_PATTERN_MASK_L(x)    ((u32)(((x >> 0) & 0xFFFFFFFF)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_MASK_LA_TRX_DBG_H
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_MASK_LA_TRX_PATTERN_MASK_H      ((u32)0xFFFFFFFF << 0)          /*!<R/W 0  used for mask one or more bits of debug port */
-#define BIT_LA_TRX_PATTERN_MASK_H(x)        ((u32)(((x) & 0xFFFFFFFF) << 0))
-#define BIT_GET_LA_TRX_PATTERN_MASK_H(x)    ((u32)(((x >> 0) & 0xFFFFFFFF)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_REF_LA_TRX_DBG_L
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_MASK_LA_TRX_PATTERN_REF_L       ((u32)0xFFFFFFFF << 0)          /*!<R/W 0  used for mask one or more bits of debug port */
-#define BIT_LA_TRX_PATTERN_REF_L(x)         ((u32)(((x) & 0xFFFFFFFF) << 0))
-#define BIT_GET_LA_TRX_PATTERN_REF_L(x)     ((u32)(((x >> 0) & 0xFFFFFFFF)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_REF_LA_TRX_DBG_H
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_MASK_LA_TRX_PATTERN_REF_H       ((u32)0xFFFFFFFF << 0)          /*!<R/W 0  used for mask one or more bits of debug port */
-#define BIT_LA_TRX_PATTERN_REF_H(x)         ((u32)(((x) & 0xFFFFFFFF) << 0))
-#define BIT_GET_LA_TRX_PATTERN_REF_H(x)     ((u32)(((x >> 0) & 0xFFFFFFFF)))
-/** @} */
-
-
-/*==========PAGE17 Register Address Definition==========*/
-#define REG_RX_CFG                                   0x1710
-#define REG_RPL_CFG                                  0x1714
-#define REG_AID                                      0x1718
-#define REG_TRAN_BSSID0_L                            0x171C
-#define REG_TRAN_BSSID0_H                            0x1720
-#define REG_TRAN_BSSID1_L                            0x1724
-#define REG_TRAN_BSSID1_H                            0x1728
-#define REG_GID_POS_EN_L                             0x172C
-#define REG_GID_POS0                                 0x1730
-#define REG_GID_POS1                                 0x1734
-#define REG_GID_POS2                                 0x1738
-#define REG_GID_POS3                                 0x173C
-#define REG_BSSCOLOR_BITMAP_L                        0x1740
-#define REG_BSSCOLOR_BITMAP_H                        0x1744
-#define REG_PBSSID_BITMAP_L                          0x1748
-#define REG_PBSSID_BITMAP_H                          0x174C
-#define REG_SR_CFG0                                  0x1750
-#define REG_SR_CFG1                                  0x1754
-#define REG_MACTX_SR                                 0x1758
-#define REG_MACTX_MISC                               0x175C
-#define REG_MACTX_MHDR0                              0x1760
-#define REG_MACTX_MHDR1                              0x1764
-#define REG_MACTX_TXD_FIFO                           0x1768
-#define REG_RXTRIG_TEST_COMM_0                       0x1780
-#define REG_RXTRIG_TEST_COMM_1                       0x1784
-#define REG_RXTRIG_TEST_USER_0                       0x1788
-#define REG_RXTRIG_TEST_USER_1                       0x178C
-#define REG_RXTRIG_TEST_USER_2                       0x1790
-#define REG_RXTRIG_TEST_CTRL1                        0x1794
-#define REG_RXTRIG_TEST_CTRL2                        0x1795
-#define REG_AX_CLIENT_OM_CTRL                        0x1797
-#define REG_SIFS_TIMING_CTRL_CCK                     0x1798
-#define REG_SIFS_TIMING_CTRL_OFDM                    0x179C
-#define REG_AX_TB_TIMING_CTRL                        0x17A0
-#define REG_SR_CONTROL_DBG                           0x17A4
-#define REG_SR_CONTROL_DBG1                          0x17A8
-#define REG_RX_NAV_CTRL                              0x17A9
-#define REG_NAV_STATUS                               0x17B0
-#define REG_RESP_CONTROL                             0x17B4
-#define REG_RESP_RATE_RRSR                           0x17B8
-#define REG_RESP_RATE_RRSR_1                         0x17BC
-#define REG_BEAMFORMING_CTRL                         0x17C0
-#define REG_CSI_RRSR_BITMAP                          0x17C4
-#define REG_LBK_CFG                                  0x17C8
-#define REG_GID_POS_EN_H                             0x17CC
-#define REG_TRX_PKTCNT_CTRL                          0x17D0
-#define REG_TRX_PKTCNT_RPT                           0x17D4
-#define REG_BEAMFORMING_MIMO_STATUS                  0x17D8
-#define REG_PPDU_STATUS_CFG                          0x17DC
-#define REG_RESP_CONTROL_1                           0x17E0
-#define REG_SPATIAL_REUSE_CONTROL                    0x17E4
-#define REG_RX_SUPPER_ADDRESS3_L                     0x17E8
-#define REG_RX_SUPPER_ADDRESS3_H                     0x17EC
-#define REG_MASK_LA_TRX_DBG_L                        0x17F0
-#define REG_MASK_LA_TRX_DBG_H                        0x17F4
-#define REG_REF_LA_TRX_DBG_L                         0x17F8
-#define REG_REF_LA_TRX_DBG_H                         0x17FC
-
-/* AUTO_GEN_END */
-
-/* MANUAL_GEN_START */
-
-//Please add your defination here
-
-/* MANUAL_GEN_END */
-
-#endif
diff --git a/os/board/rtl8720e/src/component/wifi/wifi_fw/amebalite/include/wififw_reg_page2.h b/os/board/rtl8720e/src/component/wifi/wifi_fw/amebalite/include/wififw_reg_page2.h
deleted file mode 100644
index 0137a52a2..000000000
--- a/os/board/rtl8720e/src/component/wifi/wifi_fw/amebalite/include/wififw_reg_page2.h
+++ /dev/null
@@ -1,407 +0,0 @@
-#ifndef __WIFIFW_REG_PAGE2_H__
-#define __WIFIFW_REG_PAGE2_H__
-
-/**************************************************************************//**
- * @defgroup REG_RQPN_CTRL_HLPQ
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_LOAD_R_PGNUM               ((u32)0x00000001 << 31)          /*!<WA0 0  Write 1 to set RQPN bit[79:0] value to page numbers for initialization */
-#define BIT_EPQ_PUBLIC_DIS             ((u32)0x00000001 << 27)          /*!<R/W 0  When this bit is set, Extra queue available Tx page size excludes the public queue. Otherwise, Extra queue available Tx page size includes public queue */
-#define BIT_NPQ_PUBLIC_DIS             ((u32)0x00000001 << 26)          /*!<R/W 0  When this bit is set, Normal queue available Tx page size excludes the public queue. Otherwise, Normal queue available Tx page size includes public queue */
-#define BIT_LPQ_PUBLIC_DIS             ((u32)0x00000001 << 25)          /*!<R/W 0  When this bit is set, Low queue available Tx page size excludes the public queue. Otherwise, Low queue available Tx page size includes public queue */
-#define BIT_HPQ_PUBLIC_DIS             ((u32)0x00000001 << 24)          /*!<R/W 0  When this bit is set, High queue available Tx page size excludes the public queue. Otherwise, High queue available Tx page size includes public queue */
-#define BIT_MASK_PUBQ                  ((u32)0x000000FF << 16)          /*!<R/W 0  Public Reserved Page Number */
-#define BIT_PUBQ(x)                    ((u32)(((x) & 0x000000FF) << 16))
-#define BIT_GET_PUBQ(x)                ((u32)(((x >> 16) & 0x000000FF)))
-#define BIT_MASK_LPQ                   ((u32)0x000000FF << 8)          /*!<R/W 0  Low Priority Queue Reserved Page Number */
-#define BIT_LPQ(x)                     ((u32)(((x) & 0x000000FF) << 8))
-#define BIT_GET_LPQ(x)                 ((u32)(((x >> 8) & 0x000000FF)))
-#define BIT_MASK_HPQ                   ((u32)0x000000FF << 0)          /*!<R/W 0  High Priority Queue Reserved Page Number */
-#define BIT_HPQ(x)                     ((u32)(((x) & 0x000000FF) << 0))
-#define BIT_GET_HPQ(x)                 ((u32)(((x >> 0) & 0x000000FF)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_FIFOPAGE_INFO
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_MASK_TXPKTNUM              ((u32)0x000000FF << 24)          /*!<R 0  Packet number in TXPKTBUF (Normal/Low) */
-#define BIT_TXPKTNUM(x)                ((u32)(((x) & 0x000000FF) << 24))
-#define BIT_GET_TXPKTNUM(x)            ((u32)(((x >> 24) & 0x000000FF)))
-#define BIT_MASK_PUBQ_AVAL_PG          ((u32)0x000000FF << 16)          /*!<R 0  Available Public Queue Page Number */
-#define BIT_PUBQ_AVAL_PG(x)            ((u32)(((x) & 0x000000FF) << 16))
-#define BIT_GET_PUBQ_AVAL_PG(x)        ((u32)(((x >> 16) & 0x000000FF)))
-#define BIT_MASK_LPQ_AVAL_PG           ((u32)0x000000FF << 8)          /*!<R 0  Available Low Priority Queue Page Number */
-#define BIT_LPQ_AVAL_PG(x)             ((u32)(((x) & 0x000000FF) << 8))
-#define BIT_GET_LPQ_AVAL_PG(x)         ((u32)(((x >> 8) & 0x000000FF)))
-#define BIT_MASK_HPQ_AVAL_PG           ((u32)0x000000FF << 0)          /*!<R 0  Available High Priority Queue Page Number */
-#define BIT_HPQ_AVAL_PG(x)             ((u32)(((x) & 0x000000FF) << 0))
-#define BIT_GET_HPQ_AVAL_PG(x)         ((u32)(((x >> 0) & 0x000000FF)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_DWBCN0_CTRL
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_MASK_LLT_FREE_PAGE         ((u32)0x000000FF << 24)          /*!<R 0  RSVD */
-#define BIT_LLT_FREE_PAGE(x)           ((u32)(((x) & 0x000000FF) << 24))
-#define BIT_GET_LLT_FREE_PAGE(x)       ((u32)(((x >> 24) & 0x000000FF)))
-#define BIT_MASK_RSVD_BYTE1            ((u32)0x0000007F << 17)          /*!<R/W 0  RSVD */
-#define BIT_RSVD_BYTE1(x)              ((u32)(((x) & 0x0000007F) << 17))
-#define BIT_GET_RSVD_BYTE1(x)          ((u32)(((x >> 17) & 0x0000007F)))
-#define BIT_BCN_VALID                  ((u32)0x00000001 << 16)          /*!<R/W1C 0  When this bit is set, the beacon packet has finished to write to txpktbuffer. Clear by SW */
-#define BIT_MASK_BCN_HEAD              ((u32)0x000000FF << 8)          /*!<R/W 0xF6  The head page of packet of Bcnq which is Tx DMA filled Bcnq packet from */
-#define BIT_BCN_HEAD(x)                ((u32)(((x) & 0x000000FF) << 8))
-#define BIT_GET_BCN_HEAD(x)            ((u32)(((x >> 8) & 0x000000FF)))
-#define BIT_MASK_BLK_DESC_NUM          ((u32)0x0000000F << 4)          /*!<R/W 1  The Most Number of Tx Descriptor per Bulk Out Only for USB */
-#define BIT_BLK_DESC_NUM(x)            ((u32)(((x) & 0x0000000F) << 4))
-#define BIT_GET_BLK_DESC_NUM(x)        ((u32)(((x >> 4) & 0x0000000F)))
-#define BIT_BLK_DESC_OPT               ((u32)0x00000001 << 0)          /*!<R/W 0  option to select usb descriptor number(according to 0x208[7:4]) 1 : usb_desc_num = 2 * r_blk_desc_num 0 : usb_desc_num = 4 * r_blk_desc_num */
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_TXDMA_OFFSET_CHK
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_EN_CHKERR_FINISH           ((u32)0x00000001 << 31)          /*!<R/W 0  Let checksum offload statemachine finish if checksum parser error */
-#define BIT_EN_DMA_PERMU_P             ((u32)0x00000001 << 30)          /*!<R/W 0  Enable every dma latch fifo ptr for pcie as usb mode as one pkt trans in permu */
-#define BIT_EN_TXQUE_CLR               ((u32)0x00000001 << 29)          /*!<R/W 0  Enable tx queue clear tx pkt in tde in usb mode */
-#define BIT_EN_PCIE_FIFO               ((u32)0x00000001 << 28)          /*!<R/W 0  Enable pcie fifo store forward txdesc as before mode */
-#define BIT_MASK_PG_UNDER_TH           ((u32)0x000000FF << 16)          /*!<R/W 0xFD  Page threshold value is check by Tx DMA engine. */
-#define BIT_PG_UNDER_TH(x)             ((u32)(((x) & 0x000000FF) << 16))
-#define BIT_GET_PG_UNDER_TH(x)         ((u32)(((x >> 16) & 0x000000FF)))
-#define BIT_DSC_CHKSUM_EN              ((u32)0x00000001 << 13)          /*!<R/W 0  Enable SDIO checksum */
-#define BIT_RST_RDPTR                  ((u32)0x00000001 << 12)          /*!<R/W 0  Reset the read pointer of sync FIFO */
-#define BIT_RST_WRPTR                  ((u32)0x00000001 << 11)          /*!<R/W 0  Reset the write pointer of sync FIFO */
-#define BIT_CHK_PG_TH_EN               ((u32)0x00000001 << 10)          /*!<R/W 0  Enable Tx DMA to check total pages if it is under page threshold */
-#define BIT_DROP_DATA_EN               ((u32)0x00000001 << 9)          /*!<R/W 0  Enable Tx DMA to drop the redundant data of packet */
-#define BIT_CHECK_OFFSET_EN            ((u32)0x00000001 << 8)          /*!<R/W 0  Enable Tx DMA to check offset value */
-#define BIT_MASK_CHK_OFFSET            ((u32)0x000000FF << 0)          /*!<R/W 0  Offset value is check by Tx DMA engine */
-#define BIT_CHK_OFFSET(x)              ((u32)(((x) & 0x000000FF) << 0))
-#define BIT_GET_CHK_OFFSET(x)          ((u32)(((x >> 0) & 0x000000FF)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_TXDMA_STATUS
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_HI_OQT_UDN                 ((u32)0x00000001 << 17)          /*!<R/W1C 0  High Priority Queue_Tx OQT underflow */
-#define BIT_HI_OQT_OVF                 ((u32)0x00000001 << 16)          /*!<R/W1C 0  High Priority Queue_Tx OQT overflow */
-#define BIT_PAYLOAD_CHKSUM_ERR         ((u32)0x00000001 << 15)          /*!<R/W1C 0  Payload checksum error */
-#define BIT_PAYLOAD_UDN                ((u32)0x00000001 << 14)          /*!<R/W1C 0  Payload is under the packet length of Tx descriptor. Clear by SW. */
-#define BIT_PAYLOAD_OVF                ((u32)0x00000001 << 13)          /*!<R/W1C 0  Payload is over the packet length of Tx descriptor. Clear by SW. */
-#define BIT_DSC_CHKSUM_FAIL            ((u32)0x00000001 << 12)          /*!<R/W1C 0  Tx descriptor checksum error. Clear by SW. */
-#define BIT_UNKNOWN_QSEL               ((u32)0x00000001 << 11)          /*!<R/W1C 0  An unknown QSEL of Tx descriptor is detected. Clear by SW. */
-#define BIT_EP_QSEL_DIFF               ((u32)0x00000001 << 10)          /*!<R/W1C 0  Tx Endpoint is unmatched with the QSEL of descriptor. Clear by SW. */
-#define BIT_TX_OFFS_UNMATCH            ((u32)0x00000001 << 9)          /*!<R/W1C 0  Tx offset is unmatched. Clear by SW. */
-#define BIT_TXOQT_UDN                  ((u32)0x00000001 << 8)          /*!<R/W1C 0  TXOQT Underflow. Clear by SW. */
-#define BIT_TXOQT_OVF                  ((u32)0x00000001 << 7)          /*!<R/W1C 0  TXOQT Overflow. Clear by SW. */
-#define BIT_SFF_UDN                    ((u32)0x00000001 << 6)          /*!<R/W1C 0  TXDMA Sync FIFO Underflow. Clear by SW. */
-#define BIT_SFF_OVF                    ((u32)0x00000001 << 5)          /*!<R/W1C 0  TXDMA Sync FIFO Overflow. Clear by SW. */
-#define BIT_FREE_PG_FF                 ((u32)0x00000001 << 4)          /*!<R/W1C 0  TXDMA reads NULL page. Clear by SW. */
-#define BIT_PAGE_UNDER                 ((u32)0x00000001 << 3)          /*!<R/W1C 0  Total pages included PTCL un-return pages are under the total reserved pages minus the page threshold. Clear by SW. */
-#define BIT_PAGE_OVER                  ((u32)0x00000001 << 2)          /*!<R/W1C 0  Total pages included PTCL un-return pages are over the total reserved pages. Clear by SW. */
-#define BIT_PG_UDN                     ((u32)0x00000001 << 1)          /*!<R/W1C 0  TXFF page underflow in TDE page controller. Clear by SW. */
-#define BIT_PG_OVF                     ((u32)0x00000001 << 0)          /*!<R/W1C 0  TXFF page overflow in TDE page controller.. Clear by SW. */
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_RQPN_NPQ
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_MASK_EPQ_PGNUM             ((u32)0x000000FF << 24)          /*!<R 0  Extra Queue Page Number */
-#define BIT_EPQ_PGNUM(x)               ((u32)(((x) & 0x000000FF) << 24))
-#define BIT_GET_EPQ_PGNUM(x)           ((u32)(((x >> 24) & 0x000000FF)))
-#define BIT_MASK_EPQ_R_PGNUM           ((u32)0x000000FF << 16)          /*!<R/W 0  Extra Queue Reserved Page Number */
-#define BIT_EPQ_R_PGNUM(x)             ((u32)(((x) & 0x000000FF) << 16))
-#define BIT_GET_EPQ_R_PGNUM(x)         ((u32)(((x >> 16) & 0x000000FF)))
-#define BIT_MASK_NPQ_PGNUM             ((u32)0x000000FF << 8)          /*!<R 0  Normal Priority Queue Page Number */
-#define BIT_NPQ_PGNUM(x)               ((u32)(((x) & 0x000000FF) << 8))
-#define BIT_GET_NPQ_PGNUM(x)           ((u32)(((x >> 8) & 0x000000FF)))
-#define BIT_MASK_NPQ_R_PGNUM           ((u32)0x000000FF << 0)          /*!<R/W 0  Normal Priority Queue Reserved Page Number */
-#define BIT_NPQ_R_PGNUM(x)             ((u32)(((x) & 0x000000FF) << 0))
-#define BIT_GET_NPQ_R_PGNUM(x)         ((u32)(((x >> 0) & 0x000000FF)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_TQPNT1
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_MASK_NPQ_HIGH_TH           ((u32)0x000000FF << 24)          /*!<R/W 0  For SDIO, Normal Priority Queue Page Number High Threshold */
-#define BIT_NPQ_HIGH_TH(x)             ((u32)(((x) & 0x000000FF) << 24))
-#define BIT_GET_NPQ_HIGH_TH(x)         ((u32)(((x >> 24) & 0x000000FF)))
-#define BIT_MASK_NPQ_LOW_TH            ((u32)0x000000FF << 16)          /*!<R/W 0  For SDIO, Normal Priority Queue Page Number Low Threshold */
-#define BIT_NPQ_LOW_TH(x)              ((u32)(((x) & 0x000000FF) << 16))
-#define BIT_GET_NPQ_LOW_TH(x)          ((u32)(((x >> 16) & 0x000000FF)))
-#define BIT_MASK_HPQ_HIGH_TH           ((u32)0x000000FF << 8)          /*!<R/W 0  For SDIO, High Priority Queue Page Number High Threshold */
-#define BIT_HPQ_HIGH_TH(x)             ((u32)(((x) & 0x000000FF) << 8))
-#define BIT_GET_HPQ_HIGH_TH(x)         ((u32)(((x >> 8) & 0x000000FF)))
-#define BIT_MASK_HPQ_LOW_TH            ((u32)0x000000FF << 0)          /*!<R/W 0  For SDIO, High Priority Queue Page Number Low Threshold */
-#define BIT_HPQ_LOW_TH(x)              ((u32)(((x) & 0x000000FF) << 0))
-#define BIT_GET_HPQ_LOW_TH(x)          ((u32)(((x >> 0) & 0x000000FF)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_TQPNT2
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_MASK_EXQ_HIGH_TH           ((u32)0x000000FF << 24)          /*!<R/W 0  For SDIO, Extra Priority Queue Page Number High Threshold */
-#define BIT_EXQ_HIGH_TH(x)             ((u32)(((x) & 0x000000FF) << 24))
-#define BIT_GET_EXQ_HIGH_TH(x)         ((u32)(((x >> 24) & 0x000000FF)))
-#define BIT_MASK_EXQ_LOW_TH            ((u32)0x000000FF << 16)          /*!<R/W 0  For SDIO, Extra Priority Queue Page Number Low Threshold */
-#define BIT_EXQ_LOW_TH(x)              ((u32)(((x) & 0x000000FF) << 16))
-#define BIT_GET_EXQ_LOW_TH(x)          ((u32)(((x >> 16) & 0x000000FF)))
-#define BIT_MASK_LPQ_HIGH_TH           ((u32)0x000000FF << 8)          /*!<R/W 0  For SDIO, Low Priority Queue Page Number High Threshold */
-#define BIT_LPQ_HIGH_TH(x)             ((u32)(((x) & 0x000000FF) << 8))
-#define BIT_GET_LPQ_HIGH_TH(x)         ((u32)(((x >> 8) & 0x000000FF)))
-#define BIT_MASK_LPQ_LOW_TH            ((u32)0x000000FF << 0)          /*!<R/W 0  For SDIO, Low Priority Queue Page Number Low Threshold */
-#define BIT_LPQ_LOW_TH(x)              ((u32)(((x) & 0x000000FF) << 0))
-#define BIT_GET_LPQ_LOW_TH(x)          ((u32)(((x >> 0) & 0x000000FF)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_TDE_DEBUG
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_MASK_TDE_DEBUG             ((u32)0xFFFFFFFF << 0)          /*!<R 0  tde debug port register. */
-#define BIT_TDE_DEBUG(x)               ((u32)(((x) & 0xFFFFFFFF) << 0))
-#define BIT_GET_TDE_DEBUG(x)           ((u32)(((x >> 0) & 0xFFFFFFFF)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_AUTO_LLT
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_MASK_TXPKTNUM_H            ((u32)0x000000FF << 24)          /*!<R 0  Packet number in TXPKTBUF (High and Extra) */
-#define BIT_TXPKTNUM_H(x)              ((u32)(((x) & 0x000000FF) << 24))
-#define BIT_GET_TXPKTNUM_H(x)          ((u32)(((x >> 24) & 0x000000FF)))
-#define BIT_TDE_DBG_SEL                ((u32)0x00000001 << 23)          /*!<R/W 0  debug signals selection of Tx DMA */
-#define BIT_MASK_QSEL_DIFF             ((u32)0x00000001 << 22)          /*!<R/W 0  Mask the error bit(tx endpoint is unmatched with qsel, 0x210[10]) */
-#define BIT_AUTO_INIT_LLT              ((u32)0x00000001 << 16)          /*!<R/W 0  Write 1 to enable HW init LLT, driver need polling to 0 meaning init success */
-#define BIT_MASK_TX_OQT_HE_FREE_SPACE  ((u32)0x000000FF << 8)          /*!<R 0  High and Extra priority queue */
-#define BIT_TX_OQT_HE_FREE_SPACE(x)    ((u32)(((x) & 0x000000FF) << 8))
-#define BIT_GET_TX_OQT_HE_FREE_SPACE(x) ((u32)(((x >> 8) & 0x000000FF)))
-#define BIT_MASK_TX_OQT_NL_FREE_SPACE  ((u32)0x000000FF << 0)          /*!<R 0  Normal and low priority queue */
-#define BIT_TX_OQT_NL_FREE_SPACE(x)    ((u32)(((x) & 0x000000FF) << 0))
-#define BIT_GET_TX_OQT_NL_FREE_SPACE(x) ((u32)(((x >> 0) & 0x000000FF)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_DWBCN1_CTRL
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_MASK_BCN_HEAD_2            ((u32)0x000000FF << 24)          /*!<R/W 0xFA  The head page of packet of Bcnq which is Tx DMA filled Bcnq packet from. */
-#define BIT_BCN_HEAD_2(x)              ((u32)(((x) & 0x000000FF) << 24))
-#define BIT_GET_BCN_HEAD_2(x)          ((u32)(((x >> 24) & 0x000000FF)))
-#define BIT_MASK_SW_BCN_SEL            ((u32)0x00000003 << 20)          /*!<R/W 0  Bcnq head selection from SW setting 2'b01 : r_bcn_head_1 2'b10 : r_bcn_head_2 */
-#define BIT_SW_BCN_SEL(x)              ((u32)(((x) & 0x00000003) << 20))
-#define BIT_GET_SW_BCN_SEL(x)          ((u32)(((x >> 20) & 0x00000003)))
-#define BIT_BCN_VALID_2                ((u32)0x00000001 << 18)          /*!<R/W 0  When this bit is set, the beacon packet has finished to write to txpktbuffer. Clear by SW. */
-#define BIT_SW_BCN_SEL_EN              ((u32)0x00000001 << 17)          /*!<R/W 0  Enable Bcnq head selection from SW setting */
-#define BIT_BCN_VALID_1                ((u32)0x00000001 << 16)          /*!<R/W 0  When this bit is set, the beacon packet has finished to write to txpktbuffer. Clear by SW. */
-#define BIT_MASK_BCN_HEAD_1            ((u32)0x000000FF << 8)          /*!<R/W 0xF8  The head page of packet of Bcnq which is Tx DMA filled Bcnq packet from. */
-#define BIT_BCN_HEAD_1(x)              ((u32)(((x) & 0x000000FF) << 8))
-#define BIT_GET_BCN_HEAD_1(x)          ((u32)(((x >> 8) & 0x000000FF)))
-#define BIT_MASK_MAX_TX_PKT            ((u32)0x000000FF << 0)          /*!<R/W 0  Unit : packet number Max_tx_pkt_for_USB_and_SDIO */
-#define BIT_MAX_TX_PKT(x)              ((u32)(((x) & 0x000000FF) << 0))
-#define BIT_GET_MAX_TX_PKT(x)          ((u32)(((x >> 0) & 0x000000FF)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_TX_ALIGNMENT_CTRL
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_ADJUSTABLE_SIZE_EN         ((u32)0x00000001 << 15)          /*!<R/W 0  Enable tx alignment for sdio. SW can assign the alignment size of blocks in an aggregated-packet. */
-#define BIT_MASK_ALIGNMENT_SIZE        ((u32)0x00000FFF << 0)          /*!<R/W 0  The alignment size of blocks in an aggregated-packet. Unit: Byte */
-#define BIT_ALIGNMENT_SIZE(x)          ((u32)(((x) & 0x00000FFF) << 0))
-#define BIT_GET_ALIGNMENT_SIZE(x)      ((u32)(((x >> 0) & 0x00000FFF)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_TDE_GCK_CTRL
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_MASK_TDE_GCLK_DLY_CNT      ((u32)0x0000001F << 2)          /*!<R/W 0xF  when start trigger of clk gating happens, count for several cycles then disable clk,default:16 cycles */
-#define BIT_TDE_GCLK_DLY_CNT(x)        ((u32)(((x) & 0x0000001F) << 2))
-#define BIT_GET_TDE_GCLK_DLY_CNT(x)    ((u32)(((x >> 2) & 0x0000001F)))
-#define BIT_DMA_WAIT_MORE_CYCLE        ((u32)0x00000001 << 1)          /*!<R/W 1  enable this bit,tde_ctl will wait for 16 dma_clk when host dma last data to tde_sync_fifo 1:used for 20M mac clk 0:used for 40M/80M mac clk(will wait for 12 dma_clk) */
-#define BIT_TDE_GCLK_EN                ((u32)0x00000001 << 0)          /*!<R/W 1  enable this bit,txdma engine will use gated clk */
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_RXDMA_AGG_PG_TH
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_RXDMA_STORE                ((u32)0x00000001 << 31)          /*!<R/W 0  usb rx dma old mode store pkt and forward */
-#define BIT_EN_PRE_CALC                ((u32)0x00000001 << 29)          /*!<R/W 0  0: rde start rxdma when aggregated length over specified threshold; 1: rde start rxdma when next packet, if aggregated, will cause the total length over specified threshold */
-#define BIT_MASK_PKT_NUM_WOL           ((u32)0x000000FF << 16)          /*!<R 0  In wol mode, 8051 should refer this packet counter in RXFF */
-#define BIT_PKT_NUM_WOL(x)             ((u32)(((x) & 0x000000FF) << 16))
-#define BIT_GET_PKT_NUM_WOL(x)         ((u32)(((x >> 16) & 0x000000FF)))
-#define BIT_MASK_DMA_TIMEOUT_TH        ((u32)0x000000FF << 8)          /*!<R/W 0x20  dma agg timeout time : unit : 32us */
-#define BIT_DMA_TIMEOUT_TH(x)          ((u32)(((x) & 0x000000FF) << 8))
-#define BIT_GET_DMA_TIMEOUT_TH(x)      ((u32)(((x >> 8) & 0x000000FF)))
-#define BIT_MASK_RXDMA_AGG_PG_TH       ((u32)0x000000FF << 0)          /*!<R/W 0x3  rxdma agg length threshold if sdio : unit 1K, others unit is 4K if use RXDMA_AGG_OLD_MOD in use, unit is 1K */
-#define BIT_RXDMA_AGG_PG_TH(x)         ((u32)(((x) & 0x000000FF) << 0))
-#define BIT_GET_RXDMA_AGG_PG_TH(x)     ((u32)(((x >> 0) & 0x000000FF)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_RXPKT_NUM
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_MASK_RXPKT_QUEUED          ((u32)0x000000FF << 24)          /*!<R 0  The number of packets in RXPKTBUF. */
-#define BIT_RXPKT_QUEUED(x)            ((u32)(((x) & 0x000000FF) << 24))
-#define BIT_GET_RXPKT_QUEUED(x)        ((u32)(((x >> 24) & 0x000000FF)))
-#define BIT_RXDMA_REQ                  ((u32)0x00000001 << 19)          /*!<R 0  rxdma has request */
-#define BIT_FW_RELEASE_EN              ((u32)0x00000001 << 18)          /*!<R/W 0  When this bit is set, RXDMA will enter this mode after on-going RXDMA packet to host completed, and stop DMA packet to host. RXDMA will then report */
-#define BIT_RXDMA_IDLE                 ((u32)0x00000001 << 17)          /*!<R 0  When RXMA finishes on-going DMA operation, RXMDA will report idle state in this bit. FW can start releasing packets after RXDMA entering idle mode. */
-#define BIT_RXPKT_RELEASE_POLL         ((u32)0x00000001 << 16)          /*!<R/W1C 0  When this bit is set, RXDMA will decrease RX PKT counter by one. Before this bit is polled, FW shall update RXFF_RD_PTR first. */
-#define BIT_MASK_FW_UPD_RXPKT_RDPTR    ((u32)0x0000FFFF << 0)          /*!<R/W 0  FW shall update this register before FW write RXPKT_RELEASE_POLL to 1. */
-#define BIT_FW_UPD_RXPKT_RDPTR(x)      ((u32)(((x) & 0x0000FFFF) << 0))
-#define BIT_GET_FW_UPD_RXPKT_RDPTR(x)  ((u32)(((x >> 0) & 0x0000FFFF)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_RXDMA_STATUS
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_C2H_PKT_OVF                ((u32)0x00000001 << 7)          /*!<R/W1C 0  CH2 pkt overflow. Clr by SW */
-#define BIT_AGG_CONFGI_ISSUE           ((u32)0x00000001 << 6)          /*!<R/W1C 0  rxdma agg config error. Clr by SW */
-#define BIT_FW_POLL_ISSUE              ((u32)0x00000001 << 5)          /*!<R/W1C 0  FW Release Poll Error. Clear by SW. */
-#define BIT_RX_DATA_UDN                ((u32)0x00000001 << 4)          /*!<R/W1C 0  FW Release Poll Error. Clear by SW. */
-#define BIT_RX_SFF_UDN                 ((u32)0x00000001 << 3)          /*!<R/W1C 0  RX Sync FIFO Underflow. Clear by SW. */
-#define BIT_RX_SFF_OVF                 ((u32)0x00000001 << 2)          /*!<R/W1C 0  RX Sync FIFO Overflow. Clear by SW. */
-#define BIT_RXPKT_OVF                  ((u32)0x00000001 << 0)          /*!<R/W1C 0  When RX Packet is more than 255 packets remaining in FF. Clear by SW. */
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_RXDMA_DPR
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_MASK_RDE_DBG               ((u32)0xFFFFFFFF << 0)          /*!<R 0  rde debug port register. */
-#define BIT_RDE_DBG(x)                 ((u32)(((x) & 0xFFFFFFFF) << 0))
-#define BIT_GET_RDE_DBG(x)             ((u32)(((x >> 0) & 0xFFFFFFFF)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_RXDMA_MODE
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_RXDMA_GCLK_EN              ((u32)0x00000001 << 6)          /*!<R/W 1  rxdma_engine clock gating control,1：enable clock gating；0：disable clock gating */
-#define BIT_MASK_BURST_SIZE            ((u32)0x00000003 << 4)          /*!<R/W 0  Every burst pkt len 2’b00 : 1KB 2’b01 : 512B 2’b10 : 64B Others : 64B P.S. USB 3.0 must set : 0x00 USB 2.0 High-speed must set : 0x01 USB 2.0 Full-speed must set : 0x10 */
-#define BIT_BURST_SIZE(x)              ((u32)(((x) & 0x00000003) << 4))
-#define BIT_GET_BURST_SIZE(x)          ((u32)(((x >> 4) & 0x00000003)))
-#define BIT_MASK_BURST_CNT             ((u32)0x00000003 << 2)          /*!<R/W 1  Burst number in dma mode, support at most 4burst(2’b11) P.S, DD suggest 0x11 */
-#define BIT_BURST_CNT(x)               ((u32)(((x) & 0x00000003) << 2))
-#define BIT_GET_BURST_CNT(x)           ((u32)(((x >> 2) & 0x00000003)))
-#define BIT_DMA_MODE                   ((u32)0x00000001 << 1)          /*!<R/W 0  For usb use dma mode; for pcie clr this bit ; for SDIO use Rx DMA Aggregation mode */
-#define BIT_MASK_RX_PKT_PS             ((u32)0x00000001 << 0)          /*!<R/W 0  RSVD */
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_C2H_PKT
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_R_C2H_PKT_REQ              ((u32)0x00000001 << 16)          /*!<R/W 0  C2h packet dma request */
-#define BIT_MASK_R_C2H_STR_ADDR        ((u32)0x0000FFFF << 0)          /*!<R/W 0  C2h packet start address */
-#define BIT_R_C2H_STR_ADDR(x)          ((u32)(((x) & 0x0000FFFF) << 0))
-#define BIT_GET_R_C2H_STR_ADDR(x)      ((u32)(((x >> 0) & 0x0000FFFF)))
-/** @} */
-
-
-/*==========PAGE2 Register Address Definition==========*/
-#define REG_RQPN_CTRL_HLPQ                           0x0200
-#define REG_FIFOPAGE_INFO                            0x0204
-#define REG_DWBCN0_CTRL                              0x0208
-#define REG_TXDMA_OFFSET_CHK                         0x020C
-#define REG_TXDMA_STATUS                             0x0210
-#define REG_RQPN_NPQ                                 0x0214
-#define REG_TQPNT1                                   0x0218
-#define REG_TQPNT2                                   0x021C
-#define REG_TDE_DEBUG                                0x0220
-#define REG_AUTO_LLT                                 0x0224
-#define REG_DWBCN1_CTRL                              0x0228
-#define REG_TX_ALIGNMENT_CTRL                        0x022C
-#define REG_TDE_GCK_CTRL                             0x0230
-#define REG_TQPNT3_V1                                0x0234
-//#define REG_                                         0x0238
-//#define REG_                                         0x023C
-//#define REG_                                         0x0240
-#define REG_H2C_HEAD                                 0x0244
-//#define REG_                                         0x0248
-//#define REG_                                         0x024C
-//#define REG_                                         0x0250
-//#define REG_                                         0x0254
-//#define REG_                                         0x0258
-//#define REG_                                         0x025C
-//#define REG_                                         0x0260
-//#define REG_                                         0x0264
-//#define REG_                                         0x0268
-//#define REG_                                         0x026C
-//#define REG_                                         0x0270
-//#define REG_                                         0x0274
-//#define REG_                                         0x0278
-//#define REG_                                         0x027C
-#define REG_RXDMA_AGG_PG_TH                          0x0280
-#define REG_RXPKT_NUM                                0x0284
-#define REG_RXDMA_STATUS                             0x0288
-#define REG_RXDMA_DPR                                0x028C
-#define REG_RXDMA_MODE                               0x0290
-#define REG_C2H_PKT                                  0x0294
-//#define REG_                                         0x0298
-//#define REG_                                         0x029C
-//#define REG_                                         0x02A0
-//#define REG_                                         0x02A4
-//#define REG_                                         0x02A8
-//#define REG_                                         0x02AC
-//#define REG_                                         0x02B0
-//#define REG_                                         0x02B4
-//#define REG_                                         0x02B8
-//#define REG_                                         0x02BC
-//#define REG_                                         0x02C0
-//#define REG_                                         0x02C4
-//#define REG_                                         0x02C6
-//#define REG_                                         0x02C8
-//#define REG_                                         0x02CC
-//#define REG_                                         0x02D0
-//#define REG_                                         0x02D4
-//#define REG_                                         0x02D8
-//#define REG_                                         0x02DC
-//#define REG_                                         0x02E0
-//#define REG_                                         0x02E2
-//#define REG_                                         0x02E4
-//#define REG_                                         0x02E8
-//#define REG_                                         0x02EC
-//#define REG_                                         0x02F0
-//#define REG_                                         0x02F4
-//#define REG_                                         0x02F8
-//#define REG_                                         0x02FC
-
-/* AUTO_GEN_END */
-
-/* MANUAL_GEN_START */
-
-//Please add your defination here
-
-/* MANUAL_GEN_END */
-
-#endif
diff --git a/os/board/rtl8720e/src/component/wifi/wifi_fw/amebalite/include/wififw_reg_page26.h b/os/board/rtl8720e/src/component/wifi/wifi_fw/amebalite/include/wififw_reg_page26.h
deleted file mode 100644
index a5ee878d8..000000000
--- a/os/board/rtl8720e/src/component/wifi/wifi_fw/amebalite/include/wififw_reg_page26.h
+++ /dev/null
@@ -1,127 +0,0 @@
-#ifndef __WIFIFW_REG_PAGE26_H__
-#define __WIFIFW_REG_PAGE26_H__
-
-/* AUTO_GEN_START */
-
-/**************************************************************************//**
- * @defgroup REG_TWT_BC_ID
- * @brief TWT IE ID BITMAP
- * @{
- *****************************************************************************/
-#define BIT_MASK_R_BC_TWT_ID           ((u32)0xFFFFFFFF << 0)          /*!<R/W 0  TWT ID bitmap, each bit corresponding to a ID value */
-#define BIT_R_BC_TWT_ID(x)             ((u32)(((x) & 0xFFFFFFFF) << 0))
-#define BIT_GET_R_BC_TWT_ID(x)         ((u32)(((x >> 0) & 0xFFFFFFFF)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_TWT_BC_RPT0_PERS
- * @brief TWT IE persistence reference and RPT0
- * @{
- *****************************************************************************/
-#define BIT_R_WMAC_BCN_TWT_PSR         ((u32)0x00000001 << 26)          /*!<R/W 0  enable bcn twt bc ie parser */
-#define BIT_MASK_R_TWT_PERSISTENCE     ((u32)0x000000FF << 18)          /*!<R/W 0  persistence vlaue, if persistence value in TWT IE is smaller than the reference, bcnpsf will lat the twt id rpt */
-#define BIT_R_TWT_PERSISTENCE(x)       ((u32)(((x) & 0x000000FF) << 18))
-#define BIT_GET_R_TWT_PERSISTENCE(x)   ((u32)(((x >> 18) & 0x000000FF)))
-#define BIT_MASK_TWT_RPT_0             ((u32)0x0000FFFF << 0)          /*!<R/W/ES 0  specified twt id report */
-#define BIT_TWT_RPT_0(x)               ((u32)(((x) & 0x0000FFFF) << 0))
-#define BIT_GET_TWT_RPT_0(x)           ((u32)(((x >> 0) & 0x0000FFFF)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_TWT_BC_RPT1
- * @brief TWT IE ID RPT1
- * @{
- *****************************************************************************/
-#define BIT_MASK_TWT_RPT_2             ((u32)0x0000FFFF << 16)          /*!<R/W/ES 0  specified twt id report */
-#define BIT_TWT_RPT_2(x)               ((u32)(((x) & 0x0000FFFF) << 16))
-#define BIT_GET_TWT_RPT_2(x)           ((u32)(((x >> 16) & 0x0000FFFF)))
-#define BIT_MASK_TWT_RPT_1             ((u32)0x0000FFFF << 0)          /*!<R/W/ES 0  specified twt id report */
-#define BIT_TWT_RPT_1(x)               ((u32)(((x) & 0x0000FFFF) << 0))
-#define BIT_GET_TWT_RPT_1(x)           ((u32)(((x >> 0) & 0x0000FFFF)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_TWT_BC_RPT2
- * @brief TWT IE ID RPT2
- * @{
- *****************************************************************************/
-#define BIT_MASK_TWT_RPT_4             ((u32)0x0000FFFF << 16)          /*!<R/W/ES 0  specified twt id report */
-#define BIT_TWT_RPT_4(x)               ((u32)(((x) & 0x0000FFFF) << 16))
-#define BIT_GET_TWT_RPT_4(x)           ((u32)(((x >> 16) & 0x0000FFFF)))
-#define BIT_MASK_TWT_RPT_3             ((u32)0x0000FFFF << 0)          /*!<R/W/ES 0  specified twt id report */
-#define BIT_TWT_RPT_3(x)               ((u32)(((x) & 0x0000FFFF) << 0))
-#define BIT_GET_TWT_RPT_3(x)           ((u32)(((x >> 0) & 0x0000FFFF)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_OPS_PSR_RPT
- * @brief OPS DURATION
- * @{
- *****************************************************************************/
-#define BIT_MASK_MBSSID_N_MEM          ((u32)0x000000FF << 8)          /*!<R/W/ES 0  multi-bssid n value */
-#define BIT_MBSSID_N_MEM(x)            ((u32)(((x) & 0x000000FF) << 8))
-#define BIT_GET_MBSSID_N_MEM(x)        ((u32)(((x >> 8) & 0x000000FF)))
-#define BIT_MASK_OPS_DURATION_RPT      ((u32)0x000000FF << 0)          /*!<R/W/ES 0  ops frame duration field rpt */
-#define BIT_OPS_DURATION_RPT(x)        ((u32)(((x) & 0x000000FF) << 0))
-#define BIT_GET_OPS_DURATION_RPT(x)    ((u32)(((x >> 0) & 0x000000FF)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_LA_EVENT_OPTION
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_MASK_R_LASTOP_FCS_ERROR    ((u32)0x00000003 << 3)          /*!<R/W 0  stop LA record when continue fcs error ≥ threshold 0：disable 1：4 2：8 3：12 */
-#define BIT_R_LASTOP_FCS_ERROR(x)      ((u32)(((x) & 0x00000003) << 3))
-#define BIT_GET_R_LASTOP_FCS_ERROR(x)  ((u32)(((x >> 3) & 0x00000003)))
-#define BIT_R_LASTOP_RX_FSM_HANG       ((u32)0x00000001 << 2)          /*!<R/W 0  stop LA record when RX FSM timeout */
-#define BIT_R_LASTOP_PLCP_ERROR        ((u32)0x00000001 << 1)          /*!<R/W 0  stop LA record when RX PLCP error occur, include Length error, parity error or crc error */
-#define BIT_R_LASTOP_RX_INCOMP         ((u32)0x00000001 << 0)          /*!<R/W 0  stop LA record when RX content is incompleted, include PLCP is incompleted or PSDU is incompleted */
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_RESP_AID_11
- * @brief aid 11 for resp
- * @{
- *****************************************************************************/
-#define BIT_MASK_AID11                 ((u32)0x000007FF << 0)          /*!<R/W 0  specified the aid of the sta that mactx responding to */
-#define BIT_AID11(x)                   ((u32)(((x) & 0x000007FF) << 0))
-#define BIT_GET_AID11(x)               ((u32)(((x >> 0) & 0x000007FF)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_MAC_PHY_CR
- * @brief mac phy control reg
- * @{
- *****************************************************************************/
-#define BIT_R_ID_MATH_MPDU             ((u32)0x00000001 << 21)          /*!<R/W 0  when set, per mpdu will trigger rx_id_match, else per ppdu trigger rx_id_match */
-#define BIT_MASK_R_ID_MATCH_CNT        ((u32)0x0000007F << 14)          /*!<R/W 7'h1f  rxpkt_ok or rxpkt_fail pulse counter,unit 25ns when mac clock is 40MHz */
-#define BIT_R_ID_MATCH_CNT(x)          ((u32)(((x) & 0x0000007F) << 14))
-#define BIT_GET_R_ID_MATCH_CNT(x)      ((u32)(((x >> 14) & 0x0000007F)))
-#define BIT_MASK_R_INVALID_PKT_CNT     ((u32)0x000000FF << 6)          /*!<R/W 8'hf  invalid_pkt pulse counter,unit 25ns when mac clock is 40MHz */
-#define BIT_R_INVALID_PKT_CNT(x)       ((u32)(((x) & 0x000000FF) << 6))
-#define BIT_GET_R_INVALID_PKT_CNT(x)   ((u32)(((x >> 6) & 0x000000FF)))
-#define BIT_MASK_R_RXPKT_OK_FAIL_CNT   ((u32)0x0000003F << 0)          /*!<R/W 6'h9  rxpkt_ok or rxpkt_fail pulse counter,unit 25ns when mac clock is 40MHz */
-#define BIT_R_RXPKT_OK_FAIL_CNT(x)     ((u32)(((x) & 0x0000003F) << 0))
-#define BIT_GET_R_RXPKT_OK_FAIL_CNT(x) ((u32)(((x >> 0) & 0x0000003F)))
-/** @} */
-
-/*==========PAGE26 Register Address Definition==========*/
-#define REG_TWT_BC_ID                                0x2600
-#define REG_TWT_BC_RPT0_PERS                         0x2604
-#define REG_TWT_BC_RPT1                              0x2608
-#define REG_TWT_BC_RPT2                              0x260C
-#define REG_OPS_PSR_RPT                              0x2610
-#define REG_LA_EVENT_OPTION                          0x2614
-#define REG_RESP_AID_11                              0x2618
-#define REG_MAC_PHY_CR                               0x261C
-
-/* AUTO_GEN_END */
-
-/* MANUAL_GEN_START */
-
-//Please add your defination here
-
-/* MANUAL_GEN_END */
-
-#endif
diff --git a/os/board/rtl8720e/src/component/wifi/wifi_fw/amebalite/include/wififw_reg_page3.h b/os/board/rtl8720e/src/component/wifi/wifi_fw/amebalite/include/wififw_reg_page3.h
deleted file mode 100644
index 94f2cf405..000000000
--- a/os/board/rtl8720e/src/component/wifi/wifi_fw/amebalite/include/wififw_reg_page3.h
+++ /dev/null
@@ -1,777 +0,0 @@
-#ifndef __WIFIFW_REG_PAGE3_H__
-#define __WIFIFW_REG_PAGE3_H__
-
-/* AUTO_GEN_START */
-
-/**************************************************************************//**
- * @defgroup REG_AXI_CTRL
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_MASK_MAX_RXDMA                ((u32)0x00000003 << 28)          /*!<R/W 3h  RXDMA Burst Size selection default 3. 0: 4bytes; 1: 16bytes; 2: 32bytes; 3: 64bytes */
-#define BIT_MAX_RXDMA(x)                  ((u32)(((x) & 0x00000003) << 28))
-#define BIT_GET_MAX_RXDMA(x)              ((u32)(((x >> 28) & 0x00000003)))
-#define BIT_MASK_MAX_TXDMA                ((u32)0x00000003 << 24)          /*!<R/W 3h  TXDMA Burst Size selection default 3. 0: 4bytes; 1: 16bytes; 2: 32bytes; 3: 64bytes. */
-#define BIT_MAX_TXDMA(x)                  ((u32)(((x) & 0x00000003) << 24))
-#define BIT_GET_MAX_TXDMA(x)              ((u32)(((x >> 24) & 0x00000003)))
-#define BIT_REG_TXDMA_FAIL_PS             ((u32)0x00000001 << 21)          /*!<W 0  Write 1 to cause a txdma fail ps */
-#define BIT_MBSSID_ENSWBCN_BACKDOOR       ((u32)0x00000001 << 16)          /*!<R/W 0  MBSSID enable software becon */
-#define BIT_EN_WT_RXTAG                   ((u32)0x00000001 << 15)          /*!<R/W 1h  Display Dword0[32:16] type of Rx buffer descriptor 0: TotalLen 1: Rxtag */
-#define BIT_STOPBCN                       ((u32)0x00000001 << 14)          /*!<R/W 0  BCNQ DMA STOP */
-#define BIT_STOPMG                        ((u32)0x00000001 << 13)          /*!<R/W 0  MGQ DMA STOP */
-#define BIT_STOPVO                        ((u32)0x00000001 << 12)          /*!<R/W 0  VOQ DMA STOP */
-#define BIT_STOPVI                        ((u32)0x00000001 << 11)          /*!<R/W 0  VIQ DMA STOP */
-#define BIT_STOPBE                        ((u32)0x00000001 << 10)          /*!<R/W 0  BEQ DMA STOP */
-#define BIT_STOPBK                        ((u32)0x00000001 << 9)          /*!<R/W 0  BKQ DMA STOP */
-#define BIT_STOPRX                        ((u32)0x00000001 << 8)          /*!<R/W 0  RX DMA STOP */
-#define BIT_MASK_MQ_STOP                  ((u32)0x000000FF << 0)          /*!<R/W 0  Stop MQ DMA */
-#define BIT_MQ_STOP(x)                    ((u32)(((x) & 0x000000FF) << 0))
-#define BIT_GET_MQ_STOP(x)                ((u32)(((x >> 0) & 0x000000FF)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_INT_MIG
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_MASK_TTMRMIT                  ((u32)0x0000000F << 28)          /*!<R/W 0  When the number of timer matched condition exceeds this setting, then interrupt is issued. */
-#define BIT_TTMRMIT(x)                    ((u32)(((x) & 0x0000000F) << 28))
-#define BIT_GET_TTMRMIT(x)                ((u32)(((x >> 28) & 0x0000000F)))
-#define BIT_MASK_TNUMMIT                  ((u32)0x0000000F << 24)          /*!<R/W 0  When the buffered TX packet number is matched, the interrupt is then issued */
-#define BIT_TNUMMIT(x)                    ((u32)(((x) & 0x0000000F) << 24))
-#define BIT_GET_TNUMMIT(x)                ((u32)(((x >> 24) & 0x0000000F)))
-#define BIT_MASK_RTMRMIT                  ((u32)0x0000000F << 20)          /*!<R/W 0  When the number of timer matched condition exceeds this setting, then interrupt is issued. */
-#define BIT_RTMRMIT(x)                    ((u32)(((x) & 0x0000000F) << 20))
-#define BIT_GET_RTMRMIT(x)                ((u32)(((x >> 20) & 0x0000000F)))
-#define BIT_MASK_RNUMMIT                  ((u32)0x0000000F << 16)          /*!<R/W 0  When the buffered RX packet number is matched, the interrupt is then issued */
-#define BIT_RNUMMIT(x)                    ((u32)(((x) & 0x0000000F) << 16))
-#define BIT_GET_RNUMMIT(x)                ((u32)(((x >> 16) & 0x0000000F)))
-#define BIT_MASK_MIGRATE_TIMER            ((u32)0x0000FFFF << 0)          /*!<R/W 0  Timer for setting Interrupt Migration time, only use [2:0] 3’b000: 64 us 3’b001: 128 us 3’b010: 256 us 3’b011: 512 us 3’b100: 1024 us 3’b101: 2048 us 3’b110: 4096 us 3’b111: 8192 us */
-#define BIT_MIGRATE_TIMER(x)              ((u32)(((x) & 0x0000FFFF) << 0))
-#define BIT_GET_MIGRATE_TIMER(x)          ((u32)(((x >> 0) & 0x0000FFFF)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_BCNQ_TXBD_DESA
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_MASK_BPQDESA                  ((u32)0xFFFFFFFF << 0)          /*!<R/W 0  Buffer Descriptor Base Address for Beacon Queue */
-#define BIT_BPQDESA(x)                    ((u32)(((x) & 0xFFFFFFFF) << 0))
-#define BIT_GET_BPQDESA(x)                ((u32)(((x >> 0) & 0xFFFFFFFF)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_MGQ_TXBD_DESA
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_MASK_MGQDESA                  ((u32)0xFFFFFFFF << 0)          /*!<R/W 0  Buffer Descriptor Base Address for Manage Queue */
-#define BIT_MGQDESA(x)                    ((u32)(((x) & 0xFFFFFFFF) << 0))
-#define BIT_GET_MGQDESA(x)                ((u32)(((x >> 0) & 0xFFFFFFFF)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_VOQ_TXBD_DESA
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_MASK_VOQDESA                  ((u32)0xFFFFFFFF << 0)          /*!<R/W 0  Buffer Descriptor Base Address for VO Queue */
-#define BIT_VOQDESA(x)                    ((u32)(((x) & 0xFFFFFFFF) << 0))
-#define BIT_GET_VOQDESA(x)                ((u32)(((x >> 0) & 0xFFFFFFFF)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_VIQ_TXBD_DESA
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_MASK_VIQDESA                  ((u32)0xFFFFFFFF << 0)          /*!<R/W 0  Buffer Descriptor Base Address for VI Queue */
-#define BIT_VIQDESA(x)                    ((u32)(((x) & 0xFFFFFFFF) << 0))
-#define BIT_GET_VIQDESA(x)                ((u32)(((x >> 0) & 0xFFFFFFFF)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_BEQ_TXBD_DESA
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_MASK_BEQDESA                  ((u32)0xFFFFFFFF << 0)          /*!<R/W 0  Buffer Descriptor Base Address for BE Queue */
-#define BIT_BEQDESA(x)                    ((u32)(((x) & 0xFFFFFFFF) << 0))
-#define BIT_GET_BEQDESA(x)                ((u32)(((x >> 0) & 0xFFFFFFFF)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_BKQ_TXBD_DESA
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_MASK_BKQDESA                  ((u32)0xFFFFFFFF << 0)          /*!<R/W 0  Buffer Descriptor Base Address for BK Queue */
-#define BIT_BKQDESA(x)                    ((u32)(((x) & 0xFFFFFFFF) << 0))
-#define BIT_GET_BKQDESA(x)                ((u32)(((x >> 0) & 0xFFFFFFFF)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_RXQ_RXBD_DESA
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_MASK_RXNRML_DESA              ((u32)0xFFFFFFFF << 0)          /*!<R/W 0  Buffer Descriptor Base Address for RX */
-#define BIT_RXNRML_DESA(x)                ((u32)(((x) & 0xFFFFFFFF) << 0))
-#define BIT_GET_RXNRML_DESA(x)            ((u32)(((x >> 0) & 0xFFFFFFFF)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_MQ0_TXBD_DESA
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_MASK_MQ0DESA                  ((u32)0xFFFFFFFF << 0)          /*!<R/W 0  Buffer Descriptor Base Address for M0 Queue */
-#define BIT_MQ0DESA(x)                    ((u32)(((x) & 0xFFFFFFFF) << 0))
-#define BIT_GET_MQ0DESA(x)                ((u32)(((x >> 0) & 0xFFFFFFFF)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_MQ1_TXBD_DESA
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_MASK_MQ1DESA                  ((u32)0xFFFFFFFF << 0)          /*!<R/W 0  Buffer Descriptor Base Address for M1 Queue */
-#define BIT_MQ1DESA(x)                    ((u32)(((x) & 0xFFFFFFFF) << 0))
-#define BIT_GET_MQ1DESA(x)                ((u32)(((x >> 0) & 0xFFFFFFFF)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_MQ2_TXBD_DESA
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_MASK_MQ2DESA                  ((u32)0xFFFFFFFF << 0)          /*!<R/W 0  Buffer Descriptor Base Address for M2 Queue */
-#define BIT_MQ2DESA(x)                    ((u32)(((x) & 0xFFFFFFFF) << 0))
-#define BIT_GET_MQ2DESA(x)                ((u32)(((x >> 0) & 0xFFFFFFFF)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_MQ3_TXBD_DESA
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_MASK_MQ3DESA                  ((u32)0xFFFFFFFF << 0)          /*!<R/W 0  Buffer Descriptor Base Address for M3 Queue */
-#define BIT_MQ3DESA(x)                    ((u32)(((x) & 0xFFFFFFFF) << 0))
-#define BIT_GET_MQ3DESA(x)                ((u32)(((x >> 0) & 0xFFFFFFFF)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_MQ4_TXBD_DESA
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_MASK_MQ4DESA                  ((u32)0xFFFFFFFF << 0)          /*!<R/W 0  Buffer Descriptor Base Address for M4 Queue */
-#define BIT_MQ4DESA(x)                    ((u32)(((x) & 0xFFFFFFFF) << 0))
-#define BIT_GET_MQ4DESA(x)                ((u32)(((x >> 0) & 0xFFFFFFFF)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_MQ5_TXBD_DESA
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_MASK_MQ5DESA                  ((u32)0xFFFFFFFF << 0)          /*!<R/W 0  Buffer Descriptor Base Address for M5 Queue */
-#define BIT_MQ5DESA(x)                    ((u32)(((x) & 0xFFFFFFFF) << 0))
-#define BIT_GET_MQ5DESA(x)                ((u32)(((x >> 0) & 0xFFFFFFFF)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_MQ6_TXBD_DESA
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_MASK_MQ6DESA                  ((u32)0xFFFFFFFF << 0)          /*!<R/W 0  Buffer Descriptor Base Address for M6 Queue */
-#define BIT_MQ6DESA(x)                    ((u32)(((x) & 0xFFFFFFFF) << 0))
-#define BIT_GET_MQ6DESA(x)                ((u32)(((x >> 0) & 0xFFFFFFFF)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_MQ7_TXBD_DESA
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_MASK_MQ7DESA                  ((u32)0xFFFFFFFF << 0)          /*!<R/W 0  Buffer Descriptor Base Address for M7 Queue */
-#define BIT_MQ7DESA(x)                    ((u32)(((x) & 0xFFFFFFFF) << 0))
-#define BIT_GET_MQ7DESA(x)                ((u32)(((x >> 0) & 0xFFFFFFFF)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_MGQ_TXBD_RX_RXBD_NUM
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_MASK_BCNQ_DESC_MODE           ((u32)0x00000003 << 29)          /*!<R/W 0  BCNQ descriptor mode : 0 : 2 segments each descriptor 1 : 4 segments each descriptor 2 : 8 segments each descriptor */
-#define BIT_BCNQ_DESC_MODE(x)             ((u32)(((x) & 0x00000003) << 29))
-#define BIT_GET_BCNQ_DESC_MODE(x)         ((u32)(((x >> 29) & 0x00000003)))
-#define BIT_BCNQ_FLAG                     ((u32)0x00000001 << 28)          /*!<R/W 0  BCNQ FLAGing bit Read : BCNQ work Write : BCNQ Polling */
-#define BIT_MASK_RXDES_NUM                ((u32)0x00000FFF << 16)          /*!<R/W 100h  RX queue descriptor's number */
-#define BIT_RXDES_NUM(x)                  ((u32)(((x) & 0x00000FFF) << 16))
-#define BIT_GET_RXDES_NUM(x)              ((u32)(((x >> 16) & 0x00000FFF)))
-#define BIT_MGQ_FLAG                      ((u32)0x00000001 << 14)          /*!<R 0  MGQ FLAGing bit, read result will be bpqflag */
-#define BIT_MASK_MGQ_DESC_MODE            ((u32)0x00000003 << 12)          /*!<R/W 0  MGQ descriptor mode : 0 : 2 segments each descriptor 1 : 4 segments each descriptor 2 : 8 segments each descriptor */
-#define BIT_MGQ_DESC_MODE(x)              ((u32)(((x) & 0x00000003) << 12))
-#define BIT_GET_MGQ_DESC_MODE(x)          ((u32)(((x >> 12) & 0x00000003)))
-#define BIT_MASK_MGQDES_NUM               ((u32)0x00000FFF << 0)          /*!<R/W 100h  MG queue descriptor's number */
-#define BIT_MGQDES_NUM(x)                 ((u32)(((x) & 0x00000FFF) << 0))
-#define BIT_GET_MGQDES_NUM(x)             ((u32)(((x >> 0) & 0x00000FFF)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_VOQ_VIQ_TXBD_NUM
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_VIQ_FLAG                      ((u32)0x00000001 << 30)          /*!<R 0  VIQ, read result will be viqflag */
-#define BIT_MASK_VIQ_DESC_MODE            ((u32)0x00000003 << 28)          /*!<R/W 0  VIQ descriptor mode : 0 : 2 segments each descriptor 1 : 4 segments each descriptor 2 : 8 segments each descriptor */
-#define BIT_VIQ_DESC_MODE(x)              ((u32)(((x) & 0x00000003) << 28))
-#define BIT_GET_VIQ_DESC_MODE(x)          ((u32)(((x >> 28) & 0x00000003)))
-#define BIT_MASK_VIQDES_NUM               ((u32)0x00000FFF << 16)          /*!<R/W 100h  VI queue descriptor's number */
-#define BIT_VIQDES_NUM(x)                 ((u32)(((x) & 0x00000FFF) << 16))
-#define BIT_GET_VIQDES_NUM(x)             ((u32)(((x >> 16) & 0x00000FFF)))
-#define BIT_VOQ_FLAG                      ((u32)0x00000001 << 14)          /*!<R 0  VOQ, read result will be voqflag */
-#define BIT_MASK_VOQ_DESC_MODE            ((u32)0x00000003 << 12)          /*!<R/W 0  VOQ descriptor mode : 0 : 2 segments each descriptor 1 : 4 segments each descriptor 2 : 8 segments each descriptor */
-#define BIT_VOQ_DESC_MODE(x)              ((u32)(((x) & 0x00000003) << 12))
-#define BIT_GET_VOQ_DESC_MODE(x)          ((u32)(((x >> 12) & 0x00000003)))
-#define BIT_MASK_VOQDES_NUM               ((u32)0x00000FFF << 0)          /*!<R/W 100h  VO queue descriptor's number */
-#define BIT_VOQDES_NUM(x)                 ((u32)(((x) & 0x00000FFF) << 0))
-#define BIT_GET_VOQDES_NUM(x)             ((u32)(((x >> 0) & 0x00000FFF)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_BEQ_BKQ_TXBD_NUM
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_BKQ_FLAG                      ((u32)0x00000001 << 30)          /*!<R 0  BKQ, read result will be bkqflag */
-#define BIT_MASK_BKQ_DESC_MODE            ((u32)0x00000003 << 28)          /*!<R/W 0  BKQ descriptor mode : 0 : 2 segments each descriptor 1 : 4 segments each descriptor 2 : 8 segments each descriptor */
-#define BIT_BKQ_DESC_MODE(x)              ((u32)(((x) & 0x00000003) << 28))
-#define BIT_GET_BKQ_DESC_MODE(x)          ((u32)(((x >> 28) & 0x00000003)))
-#define BIT_MASK_BKQDES_NUM               ((u32)0x00000FFF << 16)          /*!<R/W 100h  BK queue descriptor's number */
-#define BIT_BKQDES_NUM(x)                 ((u32)(((x) & 0x00000FFF) << 16))
-#define BIT_GET_BKQDES_NUM(x)             ((u32)(((x >> 16) & 0x00000FFF)))
-#define BIT_BEQ_FLAG                      ((u32)0x00000001 << 14)          /*!<R 0  BEQ, read result will be beqflag */
-#define BIT_MASK_BEQ_DESC_MODE            ((u32)0x00000003 << 12)          /*!<R/W 0  BEQ descriptor mode : 0 : 2 segments each descriptor 1 : 4 segments each descriptor 2 : 8 segments each descriptor */
-#define BIT_BEQ_DESC_MODE(x)              ((u32)(((x) & 0x00000003) << 12))
-#define BIT_GET_BEQ_DESC_MODE(x)          ((u32)(((x >> 12) & 0x00000003)))
-#define BIT_MASK_BEQDES_NUM               ((u32)0x00000FFF << 0)          /*!<R/W 100h  BE queue descriptor's number */
-#define BIT_BEQDES_NUM(x)                 ((u32)(((x) & 0x00000FFF) << 0))
-#define BIT_GET_BEQDES_NUM(x)             ((u32)(((x >> 0) & 0x00000FFF)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_MQ0_MQ1_TXBD_NUM
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_MQ1_FLAG                      ((u32)0x00000001 << 30)          /*!<R 0  MQ1, read result will be MQ1flag */
-#define BIT_MASK_MQ1_DESC_MODE            ((u32)0x00000003 << 28)          /*!<R/W 0  MQ1 descriptor mode : 0 : 2 segments each descriptor 1 : 4 segments each descriptor 2 : 8 segments each descriptor */
-#define BIT_MQ1_DESC_MODE(x)              ((u32)(((x) & 0x00000003) << 28))
-#define BIT_GET_MQ1_DESC_MODE(x)          ((u32)(((x >> 28) & 0x00000003)))
-#define BIT_MASK_MQ1DES_NUM               ((u32)0x00000FFF << 16)          /*!<R/W 100h  M1 queue descriptor's number */
-#define BIT_MQ1DES_NUM(x)                 ((u32)(((x) & 0x00000FFF) << 16))
-#define BIT_GET_MQ1DES_NUM(x)             ((u32)(((x >> 16) & 0x00000FFF)))
-#define BIT_MQ0_FLAG                      ((u32)0x00000001 << 14)          /*!<R 0  MQ0, read result will be MQ0flag */
-#define BIT_MASK_MQ0_DESC_MODE            ((u32)0x00000003 << 12)          /*!<R/W 0  MQ0 descriptor mode : 0 : 2 segments each descriptor 1 : 4 segments each descriptor 2 : 8 segments each descriptor */
-#define BIT_MQ0_DESC_MODE(x)              ((u32)(((x) & 0x00000003) << 12))
-#define BIT_GET_MQ0_DESC_MODE(x)          ((u32)(((x >> 12) & 0x00000003)))
-#define BIT_MASK_MQ0DES_NUM               ((u32)0x00000FFF << 0)          /*!<R/W 100h  M0 queue descriptor's number */
-#define BIT_MQ0DES_NUM(x)                 ((u32)(((x) & 0x00000FFF) << 0))
-#define BIT_GET_MQ0DES_NUM(x)             ((u32)(((x >> 0) & 0x00000FFF)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_MQ2_MQ3_TXBD_NUM
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_MQ3_FLAG                      ((u32)0x00000001 << 30)          /*!<R 0  MQ3, read result will be MQ3flag */
-#define BIT_MASK_MQ3_DESC_MODE            ((u32)0x00000003 << 28)          /*!<R/W 0  MQ3 descriptor mode : 0 : 2 segments each descriptor 1 : 4 segments each descriptor 2 : 8 segments each descriptor */
-#define BIT_MQ3_DESC_MODE(x)              ((u32)(((x) & 0x00000003) << 28))
-#define BIT_GET_MQ3_DESC_MODE(x)          ((u32)(((x >> 28) & 0x00000003)))
-#define BIT_MASK_MQ3DES_NUM               ((u32)0x00000FFF << 16)          /*!<R/W 100h  M3 queue descriptor's number */
-#define BIT_MQ3DES_NUM(x)                 ((u32)(((x) & 0x00000FFF) << 16))
-#define BIT_GET_MQ3DES_NUM(x)             ((u32)(((x >> 16) & 0x00000FFF)))
-#define BIT_MQ2_FLAG                      ((u32)0x00000001 << 14)          /*!<R 0  MQ2, read result will be MQ2flag */
-#define BIT_MASK_MQ2_DESC_MODE            ((u32)0x00000003 << 12)          /*!<R/W 0  MQ2 descriptor mode : 0 : 2 segments each descriptor 1 : 4 segments each descriptor 2 : 8 segments each descriptor */
-#define BIT_MQ2_DESC_MODE(x)              ((u32)(((x) & 0x00000003) << 12))
-#define BIT_GET_MQ2_DESC_MODE(x)          ((u32)(((x >> 12) & 0x00000003)))
-#define BIT_MASK_MQ2DES_NUM               ((u32)0x00000FFF << 0)          /*!<R/W 100h  M2 queue descriptor's number */
-#define BIT_MQ2DES_NUM(x)                 ((u32)(((x) & 0x00000FFF) << 0))
-#define BIT_GET_MQ2DES_NUM(x)             ((u32)(((x >> 0) & 0x00000FFF)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_MQ4_MQ5_TXBD_NUM
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_MQ5_FLAG                      ((u32)0x00000001 << 30)          /*!<R 0  MQ5, read result will be MQ5flag */
-#define BIT_MASK_MQ5_DESC_MODE            ((u32)0x00000003 << 28)          /*!<R/W 0  MQ5 descriptor mode : 0 : 2 segments each descriptor 1 : 4 segments each descriptor 2 : 8 segments each descriptor */
-#define BIT_MQ5_DESC_MODE(x)              ((u32)(((x) & 0x00000003) << 28))
-#define BIT_GET_MQ5_DESC_MODE(x)          ((u32)(((x >> 28) & 0x00000003)))
-#define BIT_MASK_MQ5DES_NUM               ((u32)0x00000FFF << 16)          /*!<R/W 100h  M5 queue descriptor's number */
-#define BIT_MQ5DES_NUM(x)                 ((u32)(((x) & 0x00000FFF) << 16))
-#define BIT_GET_MQ5DES_NUM(x)             ((u32)(((x >> 16) & 0x00000FFF)))
-#define BIT_MQ4_FLAG                      ((u32)0x00000001 << 14)          /*!<R 0  MQ4, read result will be MQ4flag */
-#define BIT_MASK_MQ4_DESC_MODE            ((u32)0x00000003 << 12)          /*!<R/W 0  MQ4 descriptor mode : 0 : 2 segments each descriptor 1 : 4 segments each descriptor 2 : 8 segments each descriptor */
-#define BIT_MQ4_DESC_MODE(x)              ((u32)(((x) & 0x00000003) << 12))
-#define BIT_GET_MQ4_DESC_MODE(x)          ((u32)(((x >> 12) & 0x00000003)))
-#define BIT_MASK_MQ4DES_NUM               ((u32)0x00000FFF << 0)          /*!<R/W 100h  M4 queue descriptor's number */
-#define BIT_MQ4DES_NUM(x)                 ((u32)(((x) & 0x00000FFF) << 0))
-#define BIT_GET_MQ4DES_NUM(x)             ((u32)(((x >> 0) & 0x00000FFF)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_MQ6_MQ7_TXBD_NUM
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_MQ7_FLAG                      ((u32)0x00000001 << 30)          /*!<R 0  MQ7, read result will be MQ7flag */
-#define BIT_MASK_MQ7_DESC_MODE            ((u32)0x00000003 << 28)          /*!<R/W 0  MQ7 descriptor mode : 0 : 2 segments each descriptor 1 : 4 segments each descriptor 2 : 8 segments each descriptor */
-#define BIT_MQ7_DESC_MODE(x)              ((u32)(((x) & 0x00000003) << 28))
-#define BIT_GET_MQ7_DESC_MODE(x)          ((u32)(((x >> 28) & 0x00000003)))
-#define BIT_MASK_MQ7DES_NUM               ((u32)0x00000FFF << 16)          /*!<R/W 100h  M7 queue descriptor's number */
-#define BIT_MQ7DES_NUM(x)                 ((u32)(((x) & 0x00000FFF) << 16))
-#define BIT_GET_MQ7DES_NUM(x)             ((u32)(((x >> 16) & 0x00000FFF)))
-#define BIT_MQ6_FLAG                      ((u32)0x00000001 << 14)          /*!<R 0  MQ6, read result will be MQ6flag */
-#define BIT_MASK_MQ6_DESC_MODE            ((u32)0x00000003 << 12)          /*!<R/W 0  MQ6 descriptor mode : 0 : 2 segments each descriptor 1 : 4 segments each descriptor 2 : 8 segments each descriptor */
-#define BIT_MQ6_DESC_MODE(x)              ((u32)(((x) & 0x00000003) << 12))
-#define BIT_GET_MQ6_DESC_MODE(x)          ((u32)(((x >> 12) & 0x00000003)))
-#define BIT_MASK_MQ6DES_NUM               ((u32)0x00000FFF << 0)          /*!<R/W 100h  M6 queue descriptor's number */
-#define BIT_MQ6DES_NUM(x)                 ((u32)(((x) & 0x00000FFF) << 0))
-#define BIT_GET_MQ6DES_NUM(x)             ((u32)(((x >> 0) & 0x00000FFF)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_BD_RWPTR_CLR
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_CLR_MQ7_HW_IDX                ((u32)0x00000001 << 29)          /*!<W 0  Clear MQ7 hardware index, write 1 and hardware auto clear */
-#define BIT_CLR_MQ6_HW_IDX                ((u32)0x00000001 << 28)          /*!<W 0  Clear MQ6 hardware index, write 1 and hardware auto clear */
-#define BIT_CLR_MQ5_HW_IDX                ((u32)0x00000001 << 27)          /*!<W 0  Clear MQ5 hardware index, write 1 and hardware auto clear */
-#define BIT_CLR_MQ4_HW_IDX                ((u32)0x00000001 << 26)          /*!<W 0  Clear MQ4 hardware index, write 1 and hardware auto clear */
-#define BIT_CLR_MQ3_HW_IDX                ((u32)0x00000001 << 25)          /*!<W 0  Clear MQ3 hardware index, write 1 and hardware auto clear */
-#define BIT_CLR_MQ2_HW_IDX                ((u32)0x00000001 << 24)          /*!<W 0  Clear MQ2 hardware index, write 1 and hardware auto clear */
-#define BIT_CLR_MQ1_HW_IDX                ((u32)0x00000001 << 23)          /*!<W 0  Clear MQ1 hardware index, write 1 and hardware auto clear */
-#define BIT_CLR_MQ0_HW_IDX                ((u32)0x00000001 << 22)          /*!<W 0  Clear MQ0 hardware index, write 1 and hardware auto clear */
-#define BIT_CLR_BKQ_HW_IDX                ((u32)0x00000001 << 21)          /*!<W 0  Clear BKQ hardware index, write 1 and hardware auto clear */
-#define BIT_CLR_BEQ_HW_IDX                ((u32)0x00000001 << 20)          /*!<W 0  Clear BEQ hardware index, write 1 and hardware auto clear */
-#define BIT_CLR_VIQ_HW_IDX                ((u32)0x00000001 << 19)          /*!<W 0  Clear VIQ hardware index, write 1 and hardware auto clear */
-#define BIT_CLR_VOQ_HW_IDX                ((u32)0x00000001 << 18)          /*!<W 0  Clear VOQ hardware index, write 1 and hardware auto clear */
-#define BIT_CLR_MGQ_HW_IDX                ((u32)0x00000001 << 17)          /*!<W 0  Clear MGQ hardware index, write 1 and hardware auto clear */
-#define BIT_CLR_RXQ_HW_IDX                ((u32)0x00000001 << 16)          /*!<W 0  Clear RXQ hardware index, write 1 and hardware auto clear */
-#define BIT_SRST_TX_N                     ((u32)0x00000001 << 15)          /*!<W 1h  Reset tx dma */
-#define BIT_SRST_RX_N                     ((u32)0x00000001 << 14)          /*!<W 1h  Reset rx dma */
-#define BIT_CLR_MQ7_HOST_IDX              ((u32)0x00000001 << 13)          /*!<W 0  Clear MQ7 host index, write 1 and hardware auto clear */
-#define BIT_CLR_MQ6_HOST_IDX              ((u32)0x00000001 << 12)          /*!<W 0  Clear MQ6 host index, write 1 and hardware auto clear */
-#define BIT_CLR_MQ5_HOST_IDX              ((u32)0x00000001 << 11)          /*!<W 0  Clear MQ5 host index, write 1 and hardware auto clear */
-#define BIT_CLR_MQ4_HOST_IDX              ((u32)0x00000001 << 10)          /*!<W 0  Clear MQ4 host index, write 1 and hardware auto clear */
-#define BIT_CLR_MQ3_HOST_IDX              ((u32)0x00000001 << 9)          /*!<W 0  Clear MQ3 host index, write 1 and hardware auto clear */
-#define BIT_CLR_MQ2_HOST_IDX              ((u32)0x00000001 << 8)          /*!<W 0  Clear MQ2 host index, write 1 and hardware auto clear */
-#define BIT_CLR_MQ1_HOST_IDX              ((u32)0x00000001 << 7)          /*!<W 0  Clear MQ1 host index, write 1 and hardware auto clear */
-#define BIT_CLR_MQ0_HOST_IDX              ((u32)0x00000001 << 6)          /*!<W 0  Clear MQ0 host index, write 1 and hardware auto clear */
-#define BIT_CLR_BKQ_HOST_IDX              ((u32)0x00000001 << 5)          /*!<W 0  Clear MQ host index, write 1 and hardware auto clear */
-#define BIT_CLR_BEQ_HOST_IDX              ((u32)0x00000001 << 4)          /*!<W 0  Clear BEQ host index, write 1 and hardware auto clear */
-#define BIT_CLR_VIQ_HOST_IDX              ((u32)0x00000001 << 3)          /*!<W 0  Clear VIQ host index, write 1 and hardware auto clear */
-#define BIT_CLR_VOQ_HOST_IDX              ((u32)0x00000001 << 2)          /*!<W 0  Clear VOQ host index, write 1 and hardware auto clear */
-#define BIT_CLR_MGQ_HOST_IDX              ((u32)0x00000001 << 1)          /*!<W 0  Clear MGQ host index, write 1 and hardware auto clear */
-#define BIT_CLR_RXQ_HOST_IDX              ((u32)0x00000001 << 0)          /*!<W 0  Clear RXQ host index, write 1 and hardware auto clear */
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_VOQ_TXBD_IDX
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_MASK_VOQ_HW_IDX               ((u32)0x00000FFF << 16)          /*!<R 0  VO queue descriptor’s hardware index */
-#define BIT_VOQ_HW_IDX(x)                 ((u32)(((x) & 0x00000FFF) << 16))
-#define BIT_GET_VOQ_HW_IDX(x)             ((u32)(((x >> 16) & 0x00000FFF)))
-#define BIT_MASK_VOQ_HOST_IDX             ((u32)0x00000FFF << 0)          /*!<R/W 0  VO queue descriptor’s host index */
-#define BIT_VOQ_HOST_IDX(x)               ((u32)(((x) & 0x00000FFF) << 0))
-#define BIT_GET_VOQ_HOST_IDX(x)           ((u32)(((x >> 0) & 0x00000FFF)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_VIQ_TXBD_IDX
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_MASK_VIQ_HW_IDX               ((u32)0x00000FFF << 16)          /*!<R 0  VI queue descriptor’s hardware index */
-#define BIT_VIQ_HW_IDX(x)                 ((u32)(((x) & 0x00000FFF) << 16))
-#define BIT_GET_VIQ_HW_IDX(x)             ((u32)(((x >> 16) & 0x00000FFF)))
-#define BIT_MASK_VIQ_HOST_IDX             ((u32)0x00000FFF << 0)          /*!<R/W 0  VI queue descriptor’s host index */
-#define BIT_VIQ_HOST_IDX(x)               ((u32)(((x) & 0x00000FFF) << 0))
-#define BIT_GET_VIQ_HOST_IDX(x)           ((u32)(((x >> 0) & 0x00000FFF)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_BEQ_TXBD_IDX
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_MASK_BEQ_HW_IDX               ((u32)0x00000FFF << 16)          /*!<R 0  BE queue descriptor’s hardware index */
-#define BIT_BEQ_HW_IDX(x)                 ((u32)(((x) & 0x00000FFF) << 16))
-#define BIT_GET_BEQ_HW_IDX(x)             ((u32)(((x >> 16) & 0x00000FFF)))
-#define BIT_MASK_BEQ_HOST_IDX             ((u32)0x00000FFF << 0)          /*!<R/W 0  BE queue descriptor’s host index */
-#define BIT_BEQ_HOST_IDX(x)               ((u32)(((x) & 0x00000FFF) << 0))
-#define BIT_GET_BEQ_HOST_IDX(x)           ((u32)(((x >> 0) & 0x00000FFF)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_BKQ_TXBD_IDX
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_MASK_BKQ_HW_IDX               ((u32)0x00000FFF << 16)          /*!<R 0  BK queue descriptor’s hardware index */
-#define BIT_BKQ_HW_IDX(x)                 ((u32)(((x) & 0x00000FFF) << 16))
-#define BIT_GET_BKQ_HW_IDX(x)             ((u32)(((x >> 16) & 0x00000FFF)))
-#define BIT_MASK_BKQ_HOST_IDX             ((u32)0x00000FFF << 0)          /*!<R/W 0  BK queue descriptor’s host index */
-#define BIT_BKQ_HOST_IDX(x)               ((u32)(((x) & 0x00000FFF) << 0))
-#define BIT_GET_BKQ_HOST_IDX(x)           ((u32)(((x >> 0) & 0x00000FFF)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_MGQ_TXBD_IDX
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_MASK_MGQ_HW_IDX               ((u32)0x00000FFF << 16)          /*!<R 0  MG queue descriptor’s hardware index */
-#define BIT_MGQ_HW_IDX(x)                 ((u32)(((x) & 0x00000FFF) << 16))
-#define BIT_GET_MGQ_HW_IDX(x)             ((u32)(((x >> 16) & 0x00000FFF)))
-#define BIT_MASK_MGQ_HOST_IDX             ((u32)0x00000FFF << 0)          /*!<R/W 0  MG queue descriptor’s host index */
-#define BIT_MGQ_HOST_IDX(x)               ((u32)(((x) & 0x00000FFF) << 0))
-#define BIT_GET_MGQ_HOST_IDX(x)           ((u32)(((x >> 0) & 0x00000FFF)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_RXQ_RXBD_IDX
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_MASK_RXNRML_HW_IDX            ((u32)0x00000FFF << 16)          /*!<R 0  RX queue descriptor’s hardware index */
-#define BIT_RXNRML_HW_IDX(x)              ((u32)(((x) & 0x00000FFF) << 16))
-#define BIT_GET_RXNRML_HW_IDX(x)          ((u32)(((x >> 16) & 0x00000FFF)))
-#define BIT_MASK_RXNRML_HOST_IDX          ((u32)0x00000FFF << 0)          /*!<R/W 0  RX queue descriptor’s host index */
-#define BIT_RXNRML_HOST_IDX(x)            ((u32)(((x) & 0x00000FFF) << 0))
-#define BIT_GET_RXNRML_HOST_IDX(x)        ((u32)(((x >> 0) & 0x00000FFF)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_MQ0_TXBD_IDX
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_MASK_MQ0_HW_IDX               ((u32)0x00000FFF << 16)          /*!<R 0  MQ0 queue descriptor’s hardware index */
-#define BIT_MQ0_HW_IDX(x)                 ((u32)(((x) & 0x00000FFF) << 16))
-#define BIT_GET_MQ0_HW_IDX(x)             ((u32)(((x >> 16) & 0x00000FFF)))
-#define BIT_MASK_MQ0_HOST_IDX             ((u32)0x00000FFF << 0)          /*!<R/W 0  MQ0 queue descriptor’s host index */
-#define BIT_MQ0_HOST_IDX(x)               ((u32)(((x) & 0x00000FFF) << 0))
-#define BIT_GET_MQ0_HOST_IDX(x)           ((u32)(((x >> 0) & 0x00000FFF)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_MQ1_TXBD_IDX
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_MASK_MQ1_HW_IDX               ((u32)0x00000FFF << 16)          /*!<R 0  MQ1 queue descriptor’s hardware index */
-#define BIT_MQ1_HW_IDX(x)                 ((u32)(((x) & 0x00000FFF) << 16))
-#define BIT_GET_MQ1_HW_IDX(x)             ((u32)(((x >> 16) & 0x00000FFF)))
-#define BIT_MASK_MQ1_HOST_IDX             ((u32)0x00000FFF << 0)          /*!<R/W 0  MQ1 queue descriptor’s host index */
-#define BIT_MQ1_HOST_IDX(x)               ((u32)(((x) & 0x00000FFF) << 0))
-#define BIT_GET_MQ1_HOST_IDX(x)           ((u32)(((x >> 0) & 0x00000FFF)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_MQ2_TXBD_IDX
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_MASK_MQ2_HW_IDX               ((u32)0x00000FFF << 16)          /*!<R 0  MQ2 queue descriptor’s hardware index */
-#define BIT_MQ2_HW_IDX(x)                 ((u32)(((x) & 0x00000FFF) << 16))
-#define BIT_GET_MQ2_HW_IDX(x)             ((u32)(((x >> 16) & 0x00000FFF)))
-#define BIT_MASK_MQ2_HOST_IDX             ((u32)0x00000FFF << 0)          /*!<R/W 0  MQ2 queue descriptor’s host index */
-#define BIT_MQ2_HOST_IDX(x)               ((u32)(((x) & 0x00000FFF) << 0))
-#define BIT_GET_MQ2_HOST_IDX(x)           ((u32)(((x >> 0) & 0x00000FFF)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_MQ3_TXBD_IDX
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_MASK_MQ3_HW_IDX               ((u32)0x00000FFF << 16)          /*!<R 0  MQ3 queue descriptor’s hardware index */
-#define BIT_MQ3_HW_IDX(x)                 ((u32)(((x) & 0x00000FFF) << 16))
-#define BIT_GET_MQ3_HW_IDX(x)             ((u32)(((x >> 16) & 0x00000FFF)))
-#define BIT_MASK_MQ3_HOST_IDX             ((u32)0x00000FFF << 0)          /*!<R/W 0  MQ3 queue descriptor’s host index */
-#define BIT_MQ3_HOST_IDX(x)               ((u32)(((x) & 0x00000FFF) << 0))
-#define BIT_GET_MQ3_HOST_IDX(x)           ((u32)(((x >> 0) & 0x00000FFF)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_MQ4_TXBD_IDX
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_MASK_MQ4_HW_IDX               ((u32)0x00000FFF << 16)          /*!<R 0  MQ4 queue descriptor’s hardware index */
-#define BIT_MQ4_HW_IDX(x)                 ((u32)(((x) & 0x00000FFF) << 16))
-#define BIT_GET_MQ4_HW_IDX(x)             ((u32)(((x >> 16) & 0x00000FFF)))
-#define BIT_MASK_MQ4_HOST_IDX             ((u32)0x00000FFF << 0)          /*!<R/W 0  MQ4 queue descriptor’s host index */
-#define BIT_MQ4_HOST_IDX(x)               ((u32)(((x) & 0x00000FFF) << 0))
-#define BIT_GET_MQ4_HOST_IDX(x)           ((u32)(((x >> 0) & 0x00000FFF)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_MQ5_TXBD_IDX
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_MASK_MQ5_HW_IDX               ((u32)0x00000FFF << 16)          /*!<R 0  MQ5 queue descriptor’s hardware index */
-#define BIT_MQ5_HW_IDX(x)                 ((u32)(((x) & 0x00000FFF) << 16))
-#define BIT_GET_MQ5_HW_IDX(x)             ((u32)(((x >> 16) & 0x00000FFF)))
-#define BIT_MASK_MQ5_HOST_IDX             ((u32)0x00000FFF << 0)          /*!<R/W 0  MQ5 queue descriptor’s host index */
-#define BIT_MQ5_HOST_IDX(x)               ((u32)(((x) & 0x00000FFF) << 0))
-#define BIT_GET_MQ5_HOST_IDX(x)           ((u32)(((x >> 0) & 0x00000FFF)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_MQ6_TXBD_IDX
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_MASK_MQ6_HW_IDX               ((u32)0x00000FFF << 16)          /*!<R 0  MQ6 queue descriptor’s hardware index */
-#define BIT_MQ6_HW_IDX(x)                 ((u32)(((x) & 0x00000FFF) << 16))
-#define BIT_GET_MQ6_HW_IDX(x)             ((u32)(((x >> 16) & 0x00000FFF)))
-#define BIT_MASK_MQ6_HOST_IDX             ((u32)0x00000FFF << 0)          /*!<R/W 0  MQ6 queue descriptor’s host index */
-#define BIT_MQ6_HOST_IDX(x)               ((u32)(((x) & 0x00000FFF) << 0))
-#define BIT_GET_MQ6_HOST_IDX(x)           ((u32)(((x >> 0) & 0x00000FFF)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_MQ7_TXBD_IDX
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_MASK_MQ7_HW_IDX               ((u32)0x00000FFF << 16)          /*!<R 0  MQ7 queue descriptor’s hardware index */
-#define BIT_MQ7_HW_IDX(x)                 ((u32)(((x) & 0x00000FFF) << 16))
-#define BIT_GET_MQ7_HW_IDX(x)             ((u32)(((x >> 16) & 0x00000FFF)))
-#define BIT_MASK_MQ7_HOST_IDX             ((u32)0x00000FFF << 0)          /*!<R/W 0  MQ7 queue descriptor’s host index */
-#define BIT_MQ7_HOST_IDX(x)               ((u32)(((x) & 0x00000FFF) << 0))
-#define BIT_GET_MQ7_HOST_IDX(x)           ((u32)(((x >> 0) & 0x00000FFF)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_AXI_CTRL2
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_DEBUG_REG2                    ((u32)0x00000001 << 31)          /*!<R/W 0  Debug Selection Register */
-#define BIT_DEBUG_REG1                    ((u32)0x00000001 << 30)          /*!<R/W 0  Write：hps_clkr_ahb[3] Read:Debug Selection Register */
-#define BIT_MASK_HPS_CLKR_AHB             ((u32)0x00000003 << 28)          /*!<R/W 0  The Registers are used to prevent the deadlock whenever HW or FW turn off ANACLK or SYSCLK, which the HW or FW could not resume by themself. Currently they are not used in normal control flow. They might be helpful when Driver would like to handle whole Suspned & Resume flow by itself hps_clkr_ahb[2:1] */
-#define BIT_HPS_CLKR_AHB(x)               ((u32)(((x) & 0x00000003) << 28))
-#define BIT_GET_HPS_CLKR_AHB(x)           ((u32)(((x >> 28) & 0x00000003)))
-#define BIT_INT_WLMAC                     ((u32)0x00000001 << 27)          /*!<R/W 0  Write:hps_clkr_ahb[0] Read:Interrupt.Write clear. */
-#define BIT_MASK_DEBUG_REG0               ((u32)0x00000007 << 24)          /*!<R/W 0  Write:Debug Selection Register Read:3'b000 */
-#define BIT_DEBUG_REG0(x)                 ((u32)(((x) & 0x00000007) << 24))
-#define BIT_GET_DEBUG_REG0(x)             ((u32)(((x >> 24) & 0x00000007)))
-#define BIT_MASK_DEBUG_REG3               ((u32)0x00FFFFFF << 0)          /*!<R/W 4h  Debug Selection Register */
-#define BIT_DEBUG_REG3(x)                 ((u32)(((x) & 0x00FFFFFF) << 0))
-#define BIT_GET_DEBUG_REG3(x)             ((u32)(((x >> 0) & 0x00FFFFFF)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_DRVIER_TO_FIRMWARE_INFO
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_MASK_DRV2FW_AHB               ((u32)0xFFFFFFFF << 0)          /*!<R/W 0  DRIVER TO FIRMWARE MESSAGE */
-#define BIT_DRV2FW_AHB(x)                 ((u32)(((x) & 0xFFFFFFFF) << 0))
-#define BIT_GET_DRV2FW_AHB(x)             ((u32)(((x >> 0) & 0xFFFFFFFF)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_FIRMWARE_TO_DRIVER_INFO
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_MASK_FW2DRV_AHB               ((u32)0xFFFFFFFF << 0)          /*!<R 0  FIRMWARE TO DRIVER MESSAGE */
-#define BIT_FW2DRV_AHB(x)                 ((u32)(((x) & 0xFFFFFFFF) << 0))
-#define BIT_GET_FW2DRV_AHB(x)             ((u32)(((x >> 0) & 0xFFFFFFFF)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_AXI_INTERRUPT
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_MASK_AHB_ISR                  ((u32)0xFFFFFFFF << 0)          /*!<RW1C 0  [0]: setrxok, rx dma ok [1]: set_rdu, rx descriptor unavailable [2]: setvodok, vo queue ok [3]: setvidok, vi queue ok [4]: setbedok, be queue ok [5]: setbkdok, bk queue ok [6]: setmgdok, manage queue ok [7]: seth2cdok, h2c queue ok [8]: sethighdok, high queue ok [15:9]: resvered [16]: setbcndok0, beacon queue ok, mbssid=0 [17]: setbcndok1, beacon queue ok, mbssid=1 [18]: setbcndok2, beacon queue ok, mbssid=2 [19]: setbcndok3, beacon queue ok, mbssid=3 [20]: setbcndok4, beacon queue ok, mbssid=4 [21]: setbcndok5, beacon queue ok, mbssid=5 [22]: setbcndok6, beacon queue ok, mbssid=6 [23]: setbcndok7, beacon queue ok, mbssid=7 [24]: setbcnderr0, beacon queue error, mbssid=0 [25]: setbcnderr1, beacon queue error, mbssid=1 [26]: setbcnderr2, beacon queue error, mbssid=2 [27]: setbcnderr3, beacon queue error, mbssid=3 [28]: setbcnderr4, beacon queue error, mbssid=4 [29]: setbcnderr5, beacon queue error, mbssid=5 [30]: setbcnderr6, beacon queue error, mbssid=6 [31]: setbcnderrk7, beacon queue error, mbssid=7 */
-#define BIT_AHB_ISR(x)                    ((u32)(((x) & 0xFFFFFFFF) << 0))
-#define BIT_GET_AHB_ISR(x)                ((u32)(((x >> 0) & 0xFFFFFFFF)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_AXI_INTERRUPT_MASK
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_MASK_AHB_IMR                  ((u32)0xFFFFFFFF << 0)          /*!<R/W 0  interrupt mask of axi_top */
-#define BIT_AHB_IMR(x)                    ((u32)(((x) & 0xFFFFFFFF) << 0))
-#define BIT_GET_AHB_IMR(x)                ((u32)(((x >> 0) & 0xFFFFFFFF)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_TRXDMA_STUCK
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_RXDMA_STUCK                   ((u32)0x00000001 << 9)          /*!<R 0  rx dma stuck */
-#define BIT_TXDMA_STUCK                   ((u32)0x00000001 << 8)          /*!<R 0  tx dma stuck */
-#define BIT_MST_BUSY                      ((u32)0x00000001 << 3)          /*!<R 0  axi master write/read busy */
-#define BIT_RXBUF_ZERO_ERR                ((u32)0x00000001 << 2)          /*!<RW1C 0  rx pkt size equal to 0 when caculate buffer size */
-#define BIT_HD_SIZE_ERR                   ((u32)0x00000001 << 1)          /*!<RW1C 0  tx dma header size less than TXDESC_SIZE(40d) */
-#define BIT_EN_DBG_STUCK                  ((u32)0x00000001 << 0)          /*!<R/W 0  enable trx dma stuck */
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_LBC_WATCHDOG
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_MASK_WATCH_DOG_RECORD         ((u32)0x00003FFF << 10)          /*!<R 0  Time out register address */
-#define BIT_WATCH_DOG_RECORD(x)           ((u32)(((x) & 0x00003FFF) << 10))
-#define BIT_GET_WATCH_DOG_RECORD(x)       ((u32)(((x >> 10) & 0x00003FFF)))
-#define BIT_R_IO_TIMEOUT_FLAG             ((u32)0x00000001 << 9)          /*!<RW1C 0  Lbc timeout flag.Write “1” to clear. */
-#define BIT_EN_WATCH_DOG                  ((u32)0x00000001 << 8)          /*!<R/W 0  Enable lbc timeout watchdog */
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_ENABLE_DUMMY_READ
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_MASK_R_DEBUG                  ((u32)0x00000003 << 22)          /*!<W 0  Debug Selection Register */
-#define BIT_R_DEBUG(x)                    ((u32)(((x) & 0x00000003) << 22))
-#define BIT_GET_R_DEBUG(x)                ((u32)(((x >> 22) & 0x00000003)))
-#define BIT_EN_OUT_STD                    ((u32)0x00000001 << 6)          /*!<W 1h  cpl multi tag enable */
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_H2CQ_TXBD_DESA
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_MASK_H2CQDESA                 ((u32)0xFFFFFFFF << 0)          /*!<R/W 0  Buffer Descriptor Base Address for H2C Queue */
-#define BIT_H2CQDESA(x)                   ((u32)(((x) & 0xFFFFFFFF) << 0))
-#define BIT_GET_H2CQDESA(x)               ((u32)(((x >> 0) & 0xFFFFFFFF)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_H2CQ_TXBD_NUM
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_H2CQ_FLAG                     ((u32)0x00000001 << 14)          /*!<R 0  H2CQ, read result will be H2CQflag */
-#define BIT_MASK_H2CQ_DESC_MODE           ((u32)0x00000003 << 12)          /*!<R/W 0  H2CQ descriptor mode : 0 : 2 segments each descriptor 1 : 4 segments each descriptor 2 : 8 segments each descriptor */
-#define BIT_H2CQ_DESC_MODE(x)             ((u32)(((x) & 0x00000003) << 12))
-#define BIT_GET_H2CQ_DESC_MODE(x)         ((u32)(((x >> 12) & 0x00000003)))
-#define BIT_MASK_H2CQDES_NUM              ((u32)0x00000FFF << 0)          /*!<R/W 100h  H2C queue descriptor's number */
-#define BIT_H2CQDES_NUM(x)                ((u32)(((x) & 0x00000FFF) << 0))
-#define BIT_GET_H2CQDES_NUM(x)            ((u32)(((x >> 0) & 0x00000FFF)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_H2CQ_TXBD_IDX
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_MASK_H2CQ_HW_IDX              ((u32)0x00000FFF << 16)          /*!<R 0  H2C queue descriptor’s hardware index */
-#define BIT_H2CQ_HW_IDX(x)                ((u32)(((x) & 0x00000FFF) << 16))
-#define BIT_GET_H2CQ_HW_IDX(x)            ((u32)(((x >> 16) & 0x00000FFF)))
-#define BIT_MASK_H2CQ_HOST_IDX            ((u32)0x00000FFF << 0)          /*!<R/W 0  H2C queue descriptor’s host index */
-#define BIT_H2CQ_HOST_IDX(x)              ((u32)(((x) & 0x00000FFF) << 0))
-#define BIT_GET_H2CQ_HOST_IDX(x)          ((u32)(((x >> 0) & 0x00000FFF)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_H2CQ_CSR
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_H2CQ_FULL                     ((u32)0x00000001 << 31)          /*!<RW1C 0  Indicate H2CQ full. Write 1 to clear the bit. */
-#define BIT_CLR_H2CQ_HOST_IDX             ((u32)0x00000001 << 2)          /*!<W 0  Write 1 to clear H2CQ host index, and then hardware auto clear the bit */
-#define BIT_CLR_H2CQ_HW_IDX               ((u32)0x00000001 << 1)          /*!<W 0  Write 1 to clear H2CQ hardware index, and then hardware auto clear the bit */
-#define BIT_STOPH2C                       ((u32)0x00000001 << 0)          /*!<R/W 0  Stop h2c queue dma */
-/** @} */
-
-
-/*==========PAGE3 Register Address Definition==========*/
-#define REG_AXI_CTRL                                 0x0300
-#define REG_INT_MIG                                  0x0304
-#define REG_BCNQ_TXBD_DESA                           0x0308
-#define REG_MGQ_TXBD_DESA                            0x0310
-#define REG_VOQ_TXBD_DESA                            0x0318
-#define REG_VIQ_TXBD_DESA                            0x0320
-#define REG_BEQ_TXBD_DESA                            0x0328
-#define REG_BKQ_TXBD_DESA                            0x0330
-#define REG_RXQ_RXBD_DESA                            0x0338
-#define REG_MQ0_TXBD_DESA                            0x0340
-#define REG_MQ1_TXBD_DESA                            0x0348
-#define REG_MQ2_TXBD_DESA                            0x0350
-#define REG_MQ3_TXBD_DESA                            0x0358
-#define REG_MQ4_TXBD_DESA                            0x0360
-#define REG_MQ5_TXBD_DESA                            0x0368
-#define REG_MQ6_TXBD_DESA                            0x0370
-#define REG_MQ7_TXBD_DESA                            0x0378
-#define REG_MGQ_TXBD_RX_RXBD_NUM                     0x0380
-#define REG_VOQ_VIQ_TXBD_NUM                         0x0384
-#define REG_BEQ_BKQ_TXBD_NUM                         0x0388
-#define REG_MQ0_MQ1_TXBD_NUM                         0x038C
-#define REG_MQ2_MQ3_TXBD_NUM                         0x0390
-#define REG_MQ4_MQ5_TXBD_NUM                         0x0394
-#define REG_MQ6_MQ7_TXBD_NUM                         0x0398
-#define REG_BD_RWPTR_CLR                             0x039C
-#define REG_VOQ_TXBD_IDX                             0x03A0
-#define REG_VIQ_TXBD_IDX                             0x03A4
-#define REG_BEQ_TXBD_IDX                             0x03A8
-#define REG_BKQ_TXBD_IDX                             0x03AC
-#define REG_MGQ_TXBD_IDX                             0x03B0
-#define REG_RXQ_RXBD_IDX                             0x03B4
-#define REG_MQ0_TXBD_IDX                             0x03B8
-#define REG_MQ1_TXBD_IDX                             0x03BC
-#define REG_MQ2_TXBD_IDX                             0x03C0
-#define REG_MQ3_TXBD_IDX                             0x03C4
-#define REG_MQ4_TXBD_IDX                             0x03C8
-#define REG_MQ5_TXBD_IDX                             0x03CC
-#define REG_MQ6_TXBD_IDX                             0x03D0
-#define REG_MQ7_TXBD_IDX                             0x03D4
-#define REG_AXI_CTRL2                                0x03D8
-#define REG_AXI_HRPWM2_CPWM2                         0x03DC
-#define REG_DRVIER_TO_FIRMWARE_INFO                  0x03E0
-#define REG_FIRMWARE_TO_DRIVER_INFO                  0x03E4
-#define REG_AXI_INTERRUPT                            0x03E8
-#define REG_AXI_INTERRUPT_MASK                       0x03EC
-#define REG_TRXDMA_STUCK                             0x03F0
-//#define REG_DUMMY                                    0x03F4
-#define REG_LBC_WATCHDOG                             0x03F8
-#define REG_ENABLE_DUMMY_READ                        0x03FC
-#define REG_H2CQ_TXBD_DESA                           0x1300
-#define REG_H2CQ_TXBD_NUM                            0x1304
-#define REG_H2CQ_TXBD_IDX                            0x1308
-#define REG_H2CQ_CSR                                 0x130C
-
-/* AUTO_GEN_END */
-
-/* MANUAL_GEN_START */
-
-//Please add your defination here
-
-/* MANUAL_GEN_END */
-
-#endif
diff --git a/os/board/rtl8720e/src/component/wifi/wifi_fw/amebalite/include/wififw_reg_page4.h b/os/board/rtl8720e/src/component/wifi/wifi_fw/amebalite/include/wififw_reg_page4.h
deleted file mode 100644
index 53c24bc5e..000000000
--- a/os/board/rtl8720e/src/component/wifi/wifi_fw/amebalite/include/wififw_reg_page4.h
+++ /dev/null
@@ -1,1458 +0,0 @@
-#ifndef __WIFIFW_REG_PAGE4_H__
-#define __WIFIFW_REG_PAGE4_H__
-
-/* AUTO_GEN_START */
-
-/**************************************************************************//**
- * @defgroup REG_Q0_INFO
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_MASK_QUEUEMACID_Q0_V1                      ((u32)0x0000007F << 25)          /*!<R 0x0  MacID of head pkt */
-#define BIT_QUEUEMACID_Q0_V1(x)                        ((u32)(((x) & 0x0000007F) << 25))
-#define BIT_GET_QUEUEMACID_Q0_V1(x)                    ((u32)(((x >> 25) & 0x0000007F)))
-#define BIT_MASK_QUEUEAC_Q0_V1                         ((u32)0x00000003 << 23)          /*!<R 0x0  AC type of Queue 0. */
-#define BIT_QUEUEAC_Q0_V1(x)                           ((u32)(((x) & 0x00000003) << 23))
-#define BIT_GET_QUEUEAC_Q0_V1(x)                       ((u32)(((x >> 23) & 0x00000003)))
-#define BIT_MASK_TAIL_PKT_Q0_V1                        ((u32)0x000000FF << 15)          /*!<R 0xFF  The head page of the last packet of Queue 0. */
-#define BIT_TAIL_PKT_Q0_V1(x)                          ((u32)(((x) & 0x000000FF) << 15))
-#define BIT_GET_TAIL_PKT_Q0_V1(x)                      ((u32)(((x >> 15) & 0x000000FF)))
-#define BIT_MASK_PKT_NUM_Q0_V1                         ((u32)0x0000007F << 8)          /*!<R 0x0  The total Queue 0 pkt number in TxPktbuffer */
-#define BIT_PKT_NUM_Q0_V1(x)                           ((u32)(((x) & 0x0000007F) << 8))
-#define BIT_GET_PKT_NUM_Q0_V1(x)                       ((u32)(((x >> 8) & 0x0000007F)))
-#define BIT_MASK_HEAD_PKT_Q0                           ((u32)0x000000FF << 0)          /*!<R 0xFF  The head page of the first packet of Queue 0. */
-#define BIT_HEAD_PKT_Q0(x)                             ((u32)(((x) & 0x000000FF) << 0))
-#define BIT_GET_HEAD_PKT_Q0(x)                         ((u32)(((x >> 0) & 0x000000FF)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_Q1_INFO
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_MASK_QUEUEMACID_Q1_V1                      ((u32)0x0000007F << 25)          /*!<R 0x0  MacID of head pkt */
-#define BIT_QUEUEMACID_Q1_V1(x)                        ((u32)(((x) & 0x0000007F) << 25))
-#define BIT_GET_QUEUEMACID_Q1_V1(x)                    ((u32)(((x >> 25) & 0x0000007F)))
-#define BIT_MASK_QUEUEAC_Q1_V1                         ((u32)0x00000003 << 23)          /*!<R 0x0  AC type of Queue 1. */
-#define BIT_QUEUEAC_Q1_V1(x)                           ((u32)(((x) & 0x00000003) << 23))
-#define BIT_GET_QUEUEAC_Q1_V1(x)                       ((u32)(((x >> 23) & 0x00000003)))
-#define BIT_MASK_TAIL_PKT_Q1_V1                        ((u32)0x000000FF << 15)          /*!<R 0xFF  The head page of the last packet of Queue 1. */
-#define BIT_TAIL_PKT_Q1_V1(x)                          ((u32)(((x) & 0x000000FF) << 15))
-#define BIT_GET_TAIL_PKT_Q1_V1(x)                      ((u32)(((x >> 15) & 0x000000FF)))
-#define BIT_MASK_PKT_NUM_Q1_V1                         ((u32)0x0000007F << 8)          /*!<R 0x0  The total Queue 1 pkt number in TxPktbuffer */
-#define BIT_PKT_NUM_Q1_V1(x)                           ((u32)(((x) & 0x0000007F) << 8))
-#define BIT_GET_PKT_NUM_Q1_V1(x)                       ((u32)(((x >> 8) & 0x0000007F)))
-#define BIT_MASK_HEAD_PKT_Q1                           ((u32)0x000000FF << 0)          /*!<R 0xFF  The head page of the first packet of Queue 1. */
-#define BIT_HEAD_PKT_Q1(x)                             ((u32)(((x) & 0x000000FF) << 0))
-#define BIT_GET_HEAD_PKT_Q1(x)                         ((u32)(((x >> 0) & 0x000000FF)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_Q2_INFO
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_MASK_QUEUEMACID_Q2_V1                      ((u32)0x0000007F << 25)          /*!<R 0x0  MacID of head pkt */
-#define BIT_QUEUEMACID_Q2_V1(x)                        ((u32)(((x) & 0x0000007F) << 25))
-#define BIT_GET_QUEUEMACID_Q2_V1(x)                    ((u32)(((x >> 25) & 0x0000007F)))
-#define BIT_MASK_QUEUEAC_Q2_V1                         ((u32)0x00000003 << 23)          /*!<R 0x0  AC type of Queue 2. */
-#define BIT_QUEUEAC_Q2_V1(x)                           ((u32)(((x) & 0x00000003) << 23))
-#define BIT_GET_QUEUEAC_Q2_V1(x)                       ((u32)(((x >> 23) & 0x00000003)))
-#define BIT_MASK_TAIL_PKT_Q2_V1                        ((u32)0x000000FF << 15)          /*!<R 0xFF  The head page of the last packet of Queue 2. */
-#define BIT_TAIL_PKT_Q2_V1(x)                          ((u32)(((x) & 0x000000FF) << 15))
-#define BIT_GET_TAIL_PKT_Q2_V1(x)                      ((u32)(((x >> 15) & 0x000000FF)))
-#define BIT_MASK_PKT_NUM_Q2_V1                         ((u32)0x0000007F << 8)          /*!<R 0x0  The total Queue 2 pkt number in TxPktbuffer */
-#define BIT_PKT_NUM_Q2_V1(x)                           ((u32)(((x) & 0x0000007F) << 8))
-#define BIT_GET_PKT_NUM_Q2_V1(x)                       ((u32)(((x >> 8) & 0x0000007F)))
-#define BIT_MASK_HEAD_PKT_Q2                           ((u32)0x000000FF << 0)          /*!<R 0xFF  The head page of the first packet of Queue 2. */
-#define BIT_HEAD_PKT_Q2(x)                             ((u32)(((x) & 0x000000FF) << 0))
-#define BIT_GET_HEAD_PKT_Q2(x)                         ((u32)(((x >> 0) & 0x000000FF)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_Q3_INFO
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_MASK_QUEUEMACID_Q3_V1                      ((u32)0x0000007F << 25)          /*!<R 0x0  MacID of head pkt */
-#define BIT_QUEUEMACID_Q3_V1(x)                        ((u32)(((x) & 0x0000007F) << 25))
-#define BIT_GET_QUEUEMACID_Q3_V1(x)                    ((u32)(((x >> 25) & 0x0000007F)))
-#define BIT_MASK_QUEUEAC_Q3_V1                         ((u32)0x00000003 << 23)          /*!<R 0x0  AC type of Queue 3. */
-#define BIT_QUEUEAC_Q3_V1(x)                           ((u32)(((x) & 0x00000003) << 23))
-#define BIT_GET_QUEUEAC_Q3_V1(x)                       ((u32)(((x >> 23) & 0x00000003)))
-#define BIT_MASK_TAIL_PKT_Q3_V1                        ((u32)0x000000FF << 15)          /*!<R 0xFF  The head page of the last packet of Queue 3. */
-#define BIT_TAIL_PKT_Q3_V1(x)                          ((u32)(((x) & 0x000000FF) << 15))
-#define BIT_GET_TAIL_PKT_Q3_V1(x)                      ((u32)(((x >> 15) & 0x000000FF)))
-#define BIT_MASK_PKT_NUM_Q3_V1                         ((u32)0x0000007F << 8)          /*!<R 0x0  The total Queue 3 pkt number in TxPktbuffer */
-#define BIT_PKT_NUM_Q3_V1(x)                           ((u32)(((x) & 0x0000007F) << 8))
-#define BIT_GET_PKT_NUM_Q3_V1(x)                       ((u32)(((x >> 8) & 0x0000007F)))
-#define BIT_MASK_HEAD_PKT_Q3                           ((u32)0x000000FF << 0)          /*!<R 0xFF  The head page of the first packet of Queue 3. */
-#define BIT_HEAD_PKT_Q3(x)                             ((u32)(((x) & 0x000000FF) << 0))
-#define BIT_GET_HEAD_PKT_Q3(x)                         ((u32)(((x >> 0) & 0x000000FF)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_MGQ_INFO
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_MASK_QUEUEMACID_MGQ_V1                     ((u32)0x0000007F << 25)          /*!<R 0x0  MacID of head pkt */
-#define BIT_QUEUEMACID_MGQ_V1(x)                       ((u32)(((x) & 0x0000007F) << 25))
-#define BIT_GET_QUEUEMACID_MGQ_V1(x)                   ((u32)(((x >> 25) & 0x0000007F)))
-#define BIT_MASK_QUEUEAC_MGQ_V1                        ((u32)0x00000003 << 23)          /*!<R 0x0  AC type of management Queue. */
-#define BIT_QUEUEAC_MGQ_V1(x)                          ((u32)(((x) & 0x00000003) << 23))
-#define BIT_GET_QUEUEAC_MGQ_V1(x)                      ((u32)(((x >> 23) & 0x00000003)))
-#define BIT_MASK_TAIL_PKT_MGQ_V1                       ((u32)0x000000FF << 15)          /*!<R 0xFF  The head page of the last packet of MGQ. */
-#define BIT_TAIL_PKT_MGQ_V1(x)                         ((u32)(((x) & 0x000000FF) << 15))
-#define BIT_GET_TAIL_PKT_MGQ_V1(x)                     ((u32)(((x >> 15) & 0x000000FF)))
-#define BIT_MASK_PKT_NUM_MGQ_V1                        ((u32)0x0000007F << 8)          /*!<R 0x0  The total MGQ pkt number in TxPktbuffer */
-#define BIT_PKT_NUM_MGQ_V1(x)                          ((u32)(((x) & 0x0000007F) << 8))
-#define BIT_GET_PKT_NUM_MGQ_V1(x)                      ((u32)(((x >> 8) & 0x0000007F)))
-#define BIT_MASK_HEAD_PKT_MGQ                          ((u32)0x000000FF << 0)          /*!<R 0xFF  The head page of the first packet of MGQ. */
-#define BIT_HEAD_PKT_MGQ(x)                            ((u32)(((x) & 0x000000FF) << 0))
-#define BIT_GET_HEAD_PKT_MGQ(x)                        ((u32)(((x >> 0) & 0x000000FF)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_HIQ_INFO
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_MASK_QUEUEMACID_HIQ_V1                     ((u32)0x0000007F << 25)          /*!<R 0x0  MacID of head pkt */
-#define BIT_QUEUEMACID_HIQ_V1(x)                       ((u32)(((x) & 0x0000007F) << 25))
-#define BIT_GET_QUEUEMACID_HIQ_V1(x)                   ((u32)(((x >> 25) & 0x0000007F)))
-#define BIT_MASK_QUEUEAC_HIQ_V1                        ((u32)0x00000003 << 23)          /*!<R 0x0  AC type of High Queue. */
-#define BIT_QUEUEAC_HIQ_V1(x)                          ((u32)(((x) & 0x00000003) << 23))
-#define BIT_GET_QUEUEAC_HIQ_V1(x)                      ((u32)(((x >> 23) & 0x00000003)))
-#define BIT_MASK_TAIL_PKT_HIQ_V1                       ((u32)0x000000FF << 15)          /*!<R 0xFF  The head page of the last packet of HIQ. */
-#define BIT_TAIL_PKT_HIQ_V1(x)                         ((u32)(((x) & 0x000000FF) << 15))
-#define BIT_GET_TAIL_PKT_HIQ_V1(x)                     ((u32)(((x >> 15) & 0x000000FF)))
-#define BIT_MASK_PKT_NUM_HIQ_V1                        ((u32)0x0000007F << 8)          /*!<R 0x0  The total HIQ pkt number in TxPktbuffer */
-#define BIT_PKT_NUM_HIQ_V1(x)                          ((u32)(((x) & 0x0000007F) << 8))
-#define BIT_GET_PKT_NUM_HIQ_V1(x)                      ((u32)(((x >> 8) & 0x0000007F)))
-#define BIT_MASK_HEAD_PKT_HIQ                          ((u32)0x000000FF << 0)          /*!<R 0xFF  The head page of the first packet of HIQ. */
-#define BIT_HEAD_PKT_HIQ(x)                            ((u32)(((x) & 0x000000FF) << 0))
-#define BIT_GET_HEAD_PKT_HIQ(x)                        ((u32)(((x >> 0) & 0x000000FF)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_QUE_EMPTY_BCNQ_INFO
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_BCNQ_EMPTY_P2                              ((u32)0x00000001 << 31)          /*!<R 0x1  When this bit is raised, beacon queue of PORT2 is empty. Report by MAC. */
-#define BIT_BCNQ_EMPTY_P1                              ((u32)0x00000001 << 30)          /*!<R 0x1  When this bit is raised, beacon queue of PORT1 is empty. Report by MAC. */
-#define BIT_BCNQ_EMPTY_P0                              ((u32)0x00000001 << 29)          /*!<R 0x1  When this bit is raised, beacon queue of PORT0 is empty. Report by MAC. */
-#define BIT_EVTQ_EMPTY                                 ((u32)0x00000001 << 28)          /*!<R 0x1  When this bit is raised, event queue is empty. Report by MAC. */
-#define BIT_BCNQ_EMPTY                                 ((u32)0x00000001 << 27)          /*!<R 0x1  When this bit is raised, beacon queue is empty. Report by MAC. */
-#define BIT_HQQ_EMPTY                                  ((u32)0x00000001 << 26)          /*!<R 0x1  When this bit is raised, High queue is empty. Report by MAC. */
-#define BIT_MQQ_EMPTY                                  ((u32)0x00000001 << 25)          /*!<R 0x1  When this bit is raised, MGQ queue is empty. Report by MAC. */
-#define BIT_MGQ_CPU_EMPTY                              ((u32)0x00000001 << 24)          /*!<R 0x1  When this bit is raised, MGQ queue poll by cpu is empty. Report by MAC. */
-#define BIT_AC7Q_EMPTY                                 ((u32)0x00000001 << 23)          /*!<R 0x1  When this bit is raised, AC7 queue is empty. Report by MAC. */
-#define BIT_AC6Q_EMPTY                                 ((u32)0x00000001 << 22)          /*!<R 0x1  When this bit is raised, AC6 queue is empty. Report by MAC. */
-#define BIT_AC5Q_EMPTY                                 ((u32)0x00000001 << 21)          /*!<R 0x1  When this bit is raised, AC5 queue is empty. Report by MAC. */
-#define BIT_AC4Q_EMPTY                                 ((u32)0x00000001 << 20)          /*!<R 0x1  When this bit is raised, AC4 queue is empty. Report by MAC. */
-#define BIT_AC3Q_EMPTY                                 ((u32)0x00000001 << 19)          /*!<R 0x1  When this bit is raised, AC3 queue is empty. Report by MAC. */
-#define BIT_AC2Q_EMPTY                                 ((u32)0x00000001 << 18)          /*!<R 0x1  When this bit is raised, AC2 queue is empty. Report by MAC. */
-#define BIT_AC1Q_EMPTY                                 ((u32)0x00000001 << 17)          /*!<R 0x1  When this bit is raised, AC1 queue is empty. Report by MAC. */
-#define BIT_AC0Q_EMPTY                                 ((u32)0x00000001 << 16)          /*!<R 0x1  When this bit is raised, AC0 queue is empty. Report by MAC. */
-#define BIT_MASK_PKT_NUM_BCNQ                          ((u32)0x000000FF << 8)          /*!<R 0x0  The total BcnQ pkt number in TxPktbuffer */
-#define BIT_PKT_NUM_BCNQ(x)                            ((u32)(((x) & 0x000000FF) << 8))
-#define BIT_GET_PKT_NUM_BCNQ(x)                        ((u32)(((x >> 8) & 0x000000FF)))
-#define BIT_MASK_BCNQ_HEAD_PG                          ((u32)0x000000FF << 0)          /*!<R 0xF6  The head page of the first packet of Bcnq */
-#define BIT_BCNQ_HEAD_PG(x)                            ((u32)(((x) & 0x000000FF) << 0))
-#define BIT_GET_BCNQ_HEAD_PG(x)                        ((u32)(((x >> 0) & 0x000000FF)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_CPU_MGQ_INFO
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_BCN_POLL2                                  ((u32)0x00000001 << 31)          /*!<W   Polling BCN Queue2 Packet. Not used in 8723F */
-#define BIT_BCN_POLL1                                  ((u32)0x00000001 << 30)          /*!<W   Polling BCN Queue1 Packet */
-#define BIT_CPUMGT_POLL_SET                            ((u32)0x00000001 << 29)          /*!<W   Polling to set CPU MGT Queue packet */
-#define BIT_BCN_POLL                                   ((u32)0x00000001 << 28)          /*!<W   Polling BCN Queue Packet */
-#define BIT_CPUMGT_POLL_CLR                            ((u32)0x00000001 << 27)          /*!<W   Polling to clear CPU MGT Queue packet */
-#define BIT_EVTQ_VLD                                   ((u32)0x00000001 << 26)          /*!<R/W 0x0  SW set to 1, HW clear to 0 when evtq timeout or tx_finish */
-#define BIT_CMDQ_POLL                                  ((u32)0x00000001 << 24)          /*!<W   polling CMD packet */
-#define BIT_CPUMGQ_FW_NUM                              ((u32)0x00000001 << 8)          /*!<R 0x0  The total cpu mgq fw number in TxPktbuffer */
-#define BIT_MASK_CPUMGQ_HEAD_PG                        ((u32)0x000000FF << 0)          /*!<R 0xF6  The head page of CPU MGQ */
-#define BIT_CPUMGQ_HEAD_PG(x)                          ((u32)(((x) & 0x000000FF) << 0))
-#define BIT_GET_CPUMGQ_HEAD_PG(x)                      ((u32)(((x >> 0) & 0x000000FF)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_FWHW_TXQ_HWSSN_CTRL
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_MASK_HW_SSN_EN                             ((u32)0x000000FF << 24)          /*!<R/W 0x0  HW update the SSN [7:0], When this bit enable and EN_HWSEQ of TXDESC, MAC will overwrite MACHDR SEQ according to TXDESC QSEL [0] BIT_HWSEQ_VO_EN [1] BIT_HWSEQ_VI_EN [2] BIT_HWSEQ_BE_EN [3] BIT_HWSEQ_BK_EN [4] BIT_HWSEQ_MGT_EN [5] BIT_HWSEQ_HI_EN [6] BIT_HWSEQ_BCN_EN,don't care EN_HWSEQ of TXDESC [7] BIT_HWSEQ_CPUM_EN */
-#define BIT_HW_SSN_EN(x)                               ((u32)(((x) & 0x000000FF) << 24))
-#define BIT_GET_HW_SSN_EN(x)                           ((u32)(((x >> 24) & 0x000000FF)))
-#define BIT_RTS_LIMIT_IN_OFDM                          ((u32)0x00000001 << 23)          /*!<R/W 0x0  Rts rate will not down to cck rate */
-#define BIT_EN_BCNQ_DL                                 ((u32)0x00000001 << 22)          /*!<R/W 0x1  1: ptcl consider there is bcn pkt in TXBUF when bcn pkt first be transferd in; 0: mask bcn pkt num in bcn queue */
-#define BIT_EN_RD_RESP_NAV_BK                          ((u32)0x00000001 << 21)          /*!<R/W 0x1  Control the RD responder NAV criteria for TX. When this bit is clear, RD responder may aggregates only according to the number of MPDUs existing in the TXPKTBUF, the limit of aggregation size and number, and also the break time. When this bit is set, RD responder will be under the RX NAV criteria for RD response sequence. No excess NAV is allowed */
-#define BIT_EN_WR_FREE_TAIL                            ((u32)0x00000001 << 20)          /*!<R/W 0x1  1: Drive write Bcnq_boundary, Hw will set free_tail in Boundary-1 0: no update */
-#define BIT_TXRPT_DIS                                  ((u32)0x00000001 << 19)          /*!<R/W 0x0  when this bit is enabled, HW will not generate txrpt for driver's fixed rate packets */
-#define BIT_TXFAILRPT_DIS                              ((u32)0x00000001 << 18)          /*!<R/W 0x1  when this bit is enabled, HW will not generate txrpt for tx failed packets */
-#define BIT_EN_RTY_BC                                  ((u32)0x00000001 << 17)          /*!<R/W 0x0  When this bit is enabled, retry the broadcast packet */
-#define BIT_EN_RTY_BK_COND                             ((u32)0x00000001 << 16)          /*!<R/W 0x0  AMPDU aggregation mode with retry MPDUs and new MPDUs. When this bit is enabled, if new MPDU's data rate is not the same as retry MPDUs' fallback data rate, the aggregation will be broken. */
-#define BIT_MASK_EN_QUEUE_RPT                          ((u32)0x000000FF << 8)          /*!<R/W 0x3F  8723A/8812 1: HW will report tx_status 0: no report BIT0: BK Queue BIT1: BE Queue BIT2: VI Queue BIT3: VO Queue BIT4: MGT Queue BIT5: HI Queue BIT6: BCN Queue BIT7: CPU_MGT Queue */
-#define BIT_EN_QUEUE_RPT(x)                            ((u32)(((x) & 0x000000FF) << 8))
-#define BIT_GET_EN_QUEUE_RPT(x)                        ((u32)(((x >> 8) & 0x000000FF)))
-#define BIT_EN_RTY_BK                                  ((u32)0x00000001 << 7)          /*!<R/W 0x1  AMPDU aggregation mode with retry MPDUs and new MPDUs. When this bit is clear enabled, an AMPDU aggregates retried MPDU and new MPDU. All the aggregation criteria is still the same with normal AMPDU operation. */
-#define BIT_EN_USE_INI_RAT                             ((u32)0x00000001 << 6)          /*!<R/W 0x0  0: If Txdesc's USE RATE = 0 and this field is equal to 0, the datarate of TXRPT SRAM is used as tx pkt's datarate. (ECO flow) 1: TXInfo's datarate is used as tx pkt's datarate. */
-#define BIT_EN_RTS_NAV_BK                              ((u32)0x00000001 << 5)          /*!<R/W 0x0  Control The RTS NAV criteria for TX. When this bit is clear, TX may aggregates only according to the number of MPDUs existing in the TXPKTBUF, the limit of aggregation size and number, and also the break time. When this bit is set, TX will be under the RTS NAV criteria. No excess RTS NAV is allowed. */
-#define BIT_DIS_SSN_CHECK                              ((u32)0x00000001 << 4)          /*!<R/W 0x0  Disable checker the SSN rule when generating AMPDU TX cmd. */
-#define BIT_MACID_MATCH_RTS                            ((u32)0x00000001 << 3)          /*!<R/W 0x0  Enable the packet that follow the RTS have same MACID */
-#define BIT_EN_BCN_TXRPT                               ((u32)0x00000001 << 2)          /*!<R/W 0x1  1: HW will report bcn tx_status 0: no report */
-#define BIT_EN_FTM_RPT                                 ((u32)0x00000001 << 1)          /*!<R/W 0x1  When this bit asserted, HW will report FTM rpt */
-#define BIT_PROTECT_BMC_NAV                            ((u32)0x00000001 << 0)          /*!<R/W 0x1  Enable the NAV protection when transmit broadcast/multicast */
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_BNDY_LIFETIME_TAIL
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_MASK_FW_FREE_TAIL                          ((u32)0x000000FF << 24)          /*!<R 0xF5  Free Tail Page Number */
-#define BIT_FW_FREE_TAIL(x)                            ((u32)(((x) & 0x000000FF) << 24))
-#define BIT_GET_FW_FREE_TAIL(x)                        ((u32)(((x >> 24) & 0x000000FF)))
-#define BIT_MASK_BT_INT_TYPE                           ((u32)0x00000003 << 22)          /*!<R/W 0x0  BT Interrupt type 01: PTA 10: CPU */
-#define BIT_BT_INT_TYPE(x)                             ((u32)(((x) & 0x00000003) << 22))
-#define BIT_GET_BT_INT_TYPE(x)                         ((u32)(((x >> 22) & 0x00000003)))
-#define BIT_HW_SSN_EN_EVTQ                             ((u32)0x00000001 << 21)          /*!<R/W 0x0  HW update the SSN [8] for eventq */
-#define BIT_RTYBIT_CTRL_EN                             ((u32)0x00000001 << 20)          /*!<R/W 0x1  1: Enable Retry Count 0: Disable */
-#define BIT_LIFETIME_BK_EN                             ((u32)0x00000001 << 19)          /*!<R/W 0x0  Enable BK queue lifetime function */
-#define BIT_LIFETIME_BE_EN                             ((u32)0x00000001 << 18)          /*!<R/W 0x0  Enable BE queue lifetime function */
-#define BIT_LIFETIME_VI_EN                             ((u32)0x00000001 << 17)          /*!<R/W 0x0  Enable VI queue lifetime function */
-#define BIT_LIFETIME_VO_EN                             ((u32)0x00000001 << 16)          /*!<R/W 0x0  Enable VO queue lifetime function */
-#define BIT_MASK_MGQ_PGBNDY                            ((u32)0x000000FF << 8)          /*!<R/W 0xF6  TXDMA will pull CPU MGQ Pkt in this address. */
-#define BIT_MGQ_PGBNDY(x)                              ((u32)(((x) & 0x000000FF) << 8))
-#define BIT_GET_MGQ_PGBNDY(x)                          ((u32)(((x >> 8) & 0x000000FF)))
-#define BIT_MASK_BCNQ_PGBNDY                           ((u32)0x000000FF << 0)          /*!<R/W 0xF6  TXDMA will pull BCNQ Pkt in this address. */
-#define BIT_BCNQ_PGBNDY(x)                             ((u32)(((x) & 0x000000FF) << 0))
-#define BIT_GET_BCNQ_PGBNDY(x)                         ((u32)(((x >> 0) & 0x000000FF)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_RETRY_LIMIT_SIFS
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_MASK_SRL                                   ((u32)0x0000003F << 24)          /*!<R/W 0x20  Short Retry Limit */
-#define BIT_SRL(x)                                     ((u32)(((x) & 0x0000003F) << 24))
-#define BIT_GET_SRL(x)                                 ((u32)(((x >> 24) & 0x0000003F)))
-#define BIT_MASK_LRL                                   ((u32)0x0000003F << 16)          /*!<R/W 0x20  Long Retry Limit */
-#define BIT_LRL(x)                                     ((u32)(((x) & 0x0000003F) << 16))
-#define BIT_GET_LRL(x)                                 ((u32)(((x >> 16) & 0x0000003F)))
-#define BIT_MASK_SPEC_SIFS_OFDM_PTCL                   ((u32)0x000000FF << 8)          /*!<R/W 0x10  The spec SIFS value for duration calculation */
-#define BIT_SPEC_SIFS_OFDM_PTCL(x)                     ((u32)(((x) & 0x000000FF) << 8))
-#define BIT_GET_SPEC_SIFS_OFDM_PTCL(x)                 ((u32)(((x >> 8) & 0x000000FF)))
-#define BIT_MASK_SPEC_SIFS_CCK_PTCL                    ((u32)0x000000FF << 0)          /*!<R/W 0x0A  The spec SIFS value for duration calculation */
-#define BIT_SPEC_SIFS_CCK_PTCL(x)                      ((u32)(((x) & 0x000000FF) << 0))
-#define BIT_GET_SPEC_SIFS_CCK_PTCL(x)                  ((u32)(((x >> 0) & 0x000000FF)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_TXBF_CTRL
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_R_ENABLE_NDPA                              ((u32)0x00000001 << 31)          /*!<R/W 0x0  Set ‘1’ for MAC to enable sending NDPA or NDP Announcement MPDU */
-#define BIT_USE_NDPA_PARAMETER                         ((u32)0x00000001 << 30)          /*!<R/W 0x0  1: NDPA rate and BW use reg0x45f settings 0: NDPA rate and BW use NDP settings in Tx descriptor */
-#define BIT_R_EN_NDPA_INT                              ((u32)0x00000001 << 28)          /*!<R/W 0x0  1: enable ndpa interrupt; 0: disable ndpa interrupt */
-#define BIT_R_TXBF1_80M                                ((u32)0x00000001 << 27)          /*!<R/W 0x0  TxBF status of beamformee1 xBW=80M. */
-#define BIT_R_TXBF1_40M                                ((u32)0x00000001 << 26)          /*!<R/W 0x0  TxBF status of beamformee1 xBW=40M */
-#define BIT_R_TXBF1_20M                                ((u32)0x00000001 << 25)          /*!<R/W 0x0  TxBF status of beamformee1 xBW=20M */
-#define BIT_MASK_R_TXBF1_AID                           ((u32)0x000001FF << 16)          /*!<R/W 0x0  P_AID[8:0] of the associated beamformee1 */
-#define BIT_R_TXBF1_AID(x)                             ((u32)(((x) & 0x000001FF) << 16))
-#define BIT_GET_R_TXBF1_AID(x)                         ((u32)(((x >> 16) & 0x000001FF)))
-#define BIT_NDP_BFEN_DIS                               ((u32)0x00000001 << 15)          /*!<R/W 0x1  1: disable beamforming with NDP */
-#define BIT_BCN_NOBLOCK_NDP                            ((u32)0x00000001 << 14)          /*!<R/W 0x1  beacon packet will not block NDP packet */
-#define BIT_R_TXBF0_80M                                ((u32)0x00000001 << 11)          /*!<R/W 0x0  TxBF status of beamformee0 xBW=80M */
-#define BIT_R_TXBF0_40M                                ((u32)0x00000001 << 10)          /*!<R/W 0x0  TxBF status of beamformee0 xBW=40M */
-#define BIT_R_TXBF0_20M                                ((u32)0x00000001 << 9)          /*!<R/W 0x0  TxBF status of beamformee0 xBW=20M */
-#define BIT_MASK_R_TXBF0_AID                           ((u32)0x000001FF << 0)          /*!<R/W 0x0  P_AID[8:0] of the associated beamformee0 */
-#define BIT_R_TXBF0_AID(x)                             ((u32)(((x) & 0x000001FF) << 0))
-#define BIT_GET_R_TXBF0_AID(x)                         ((u32)(((x >> 0) & 0x000001FF)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_DARFRC0_L
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_MASK_DATA_FALLBACK_RC4                     ((u32)0x0000001F << 24)          /*!<R/W 0x04  Data Auto Rate Fallback Retry Count After the number of retry, HW will fall back the rate to the next enabled MAC in ARFR. */
-#define BIT_DATA_FALLBACK_RC4(x)                       ((u32)(((x) & 0x0000001F) << 24))
-#define BIT_GET_DATA_FALLBACK_RC4(x)                   ((u32)(((x >> 24) & 0x0000001F)))
-#define BIT_MASK_DATA_FALLBACK_RC3                     ((u32)0x0000001F << 16)          /*!<R/W 0x03  Data Auto Rate Fallback Retry Count After the number of retry, HW will fall back the rate to the next enabled MAC in ARFR. */
-#define BIT_DATA_FALLBACK_RC3(x)                       ((u32)(((x) & 0x0000001F) << 16))
-#define BIT_GET_DATA_FALLBACK_RC3(x)                   ((u32)(((x >> 16) & 0x0000001F)))
-#define BIT_MASK_DATA_FALLBACK_RC2                     ((u32)0x0000001F << 8)          /*!<R/W 0x02  Data Auto Rate Fallback Retry Count After the number of retry, HW will fall back the rate to the next enabled MAC in ARFR. */
-#define BIT_DATA_FALLBACK_RC2(x)                       ((u32)(((x) & 0x0000001F) << 8))
-#define BIT_GET_DATA_FALLBACK_RC2(x)                   ((u32)(((x >> 8) & 0x0000001F)))
-#define BIT_MASK_DATA_FALLBACK_RC1                     ((u32)0x0000001F << 0)          /*!<R/W 0x01  Data Auto Rate Fallback Retry Count After the number of retry, HW will fall back the rate to the next enabled MAC in ARFR. */
-#define BIT_DATA_FALLBACK_RC1(x)                       ((u32)(((x) & 0x0000001F) << 0))
-#define BIT_GET_DATA_FALLBACK_RC1(x)                   ((u32)(((x >> 0) & 0x0000001F)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_DARFRC0_H
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_MASK_DATA_FALLBACK_RC8                     ((u32)0x0000001F << 24)          /*!<R/W 0x08  Data Auto Rate Fallback Retry Count After the number of retry, HW will fall back the rate to the next enabled MAC in ARFR. */
-#define BIT_DATA_FALLBACK_RC8(x)                       ((u32)(((x) & 0x0000001F) << 24))
-#define BIT_GET_DATA_FALLBACK_RC8(x)                   ((u32)(((x >> 24) & 0x0000001F)))
-#define BIT_MASK_DATA_FALLBACK_RC7                     ((u32)0x0000001F << 16)          /*!<R/W 0x07  Data Auto Rate Fallback Retry Count After the number of retry, HW will fall back the rate to the next enabled MAC in ARFR. */
-#define BIT_DATA_FALLBACK_RC7(x)                       ((u32)(((x) & 0x0000001F) << 16))
-#define BIT_GET_DATA_FALLBACK_RC7(x)                   ((u32)(((x >> 16) & 0x0000001F)))
-#define BIT_MASK_DATA_FALLBACK_RC6                     ((u32)0x0000001F << 8)          /*!<R/W 0x06  Data Auto Rate Fallback Retry Count After the number of retry, HW will fall back the rate to the next enabled MAC in ARFR. */
-#define BIT_DATA_FALLBACK_RC6(x)                       ((u32)(((x) & 0x0000001F) << 8))
-#define BIT_GET_DATA_FALLBACK_RC6(x)                   ((u32)(((x >> 8) & 0x0000001F)))
-#define BIT_MASK_DATA_FALLBACK_RC5                     ((u32)0x0000001F << 0)          /*!<R/W 0x05  Data Auto Rate Fallback Retry Count After the number of retry, HW will fall back the rate to the next enabled MAC in ARFR. */
-#define BIT_DATA_FALLBACK_RC5(x)                       ((u32)(((x) & 0x0000001F) << 0))
-#define BIT_GET_DATA_FALLBACK_RC5(x)                   ((u32)(((x >> 0) & 0x0000001F)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_RARFRC_L
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_MASK_CTRL_FALLBACK_RC4                     ((u32)0x0000001F << 24)          /*!<R/W 0x04  RTS Auto Rate Fallback Retry Count After the number of retry, HW will fall back the rate to the next enabled MAC in ARFR. */
-#define BIT_CTRL_FALLBACK_RC4(x)                       ((u32)(((x) & 0x0000001F) << 24))
-#define BIT_GET_CTRL_FALLBACK_RC4(x)                   ((u32)(((x >> 24) & 0x0000001F)))
-#define BIT_MASK_CTRL_FALLBACK_RC3                     ((u32)0x0000001F << 16)          /*!<R/W 0x03  RTS Auto Rate Fallback Retry Count After the number of retry, HW will fall back the rate to the next enabled MAC in ARFR. */
-#define BIT_CTRL_FALLBACK_RC3(x)                       ((u32)(((x) & 0x0000001F) << 16))
-#define BIT_GET_CTRL_FALLBACK_RC3(x)                   ((u32)(((x >> 16) & 0x0000001F)))
-#define BIT_MASK_CTRL_FALLBACK_RC2                     ((u32)0x0000001F << 8)          /*!<R/W 0x02  RTS Auto Rate Fallback Retry Count After the number of retry, HW will fall back the rate to the next enabled MAC in ARFR. */
-#define BIT_CTRL_FALLBACK_RC2(x)                       ((u32)(((x) & 0x0000001F) << 8))
-#define BIT_GET_CTRL_FALLBACK_RC2(x)                   ((u32)(((x >> 8) & 0x0000001F)))
-#define BIT_MASK_CTRL_FALLBACK_RC1                     ((u32)0x0000001F << 0)          /*!<R/W 0x01  RTS Auto Rate Fallback Retry Count After the number of retry, HW will fall back the rate to the next enabled MAC in ARFR. */
-#define BIT_CTRL_FALLBACK_RC1(x)                       ((u32)(((x) & 0x0000001F) << 0))
-#define BIT_GET_CTRL_FALLBACK_RC1(x)                   ((u32)(((x >> 0) & 0x0000001F)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_RARFRC_H
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_MASK_CTRL_FALLBACK_RC8                     ((u32)0x0000001F << 24)          /*!<R/W 0x08  RTS Auto Rate Fallback Retry Count After the number of retry, HW will fall back the rate to the next enabled MAC in ARFR. */
-#define BIT_CTRL_FALLBACK_RC8(x)                       ((u32)(((x) & 0x0000001F) << 24))
-#define BIT_GET_CTRL_FALLBACK_RC8(x)                   ((u32)(((x >> 24) & 0x0000001F)))
-#define BIT_MASK_CTRL_FALLBACK_RC7                     ((u32)0x0000001F << 16)          /*!<R/W 0x07  RTS Auto Rate Fallback Retry Count After the number of retry, HW will fall back the rate to the next enabled MAC in ARFR. */
-#define BIT_CTRL_FALLBACK_RC7(x)                       ((u32)(((x) & 0x0000001F) << 16))
-#define BIT_GET_CTRL_FALLBACK_RC7(x)                   ((u32)(((x >> 16) & 0x0000001F)))
-#define BIT_MASK_CTRL_FALLBACK_RC6                     ((u32)0x0000001F << 8)          /*!<R/W 0x06  RTS Auto Rate Fallback Retry Count After the number of retry, HW will fall back the rate to the next enabled MAC in ARFR. */
-#define BIT_CTRL_FALLBACK_RC6(x)                       ((u32)(((x) & 0x0000001F) << 8))
-#define BIT_GET_CTRL_FALLBACK_RC6(x)                   ((u32)(((x >> 8) & 0x0000001F)))
-#define BIT_MASK_CTRL_FALLBACK_RC5                     ((u32)0x0000001F << 0)          /*!<R/W 0x05  RTS Auto Rate Fallback Retry Count After the number of retry, HW will fall back the rate to the next enabled MAC in ARFR. */
-#define BIT_CTRL_FALLBACK_RC5(x)                       ((u32)(((x) & 0x0000001F) << 0))
-#define BIT_GET_CTRL_FALLBACK_RC5(x)                   ((u32)(((x >> 0) & 0x0000001F)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_RRSR
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_MASK_RRSR_RSC                              ((u32)0x0000000F << 21)          /*!<R/W 0x3  Response frame sub-channel configuration. Response frames (CTS, ACK, BA) are transmitted in the following condition. 00: Primary 20Mhz BW(0x483[3:0] = 0x8AC[5:2]). 01: Follow Rx packet BW mode. 10: Duplicate mode. */
-#define BIT_RRSR_RSC(x)                                ((u32)(((x) & 0x0000000F) << 21))
-#define BIT_GET_RRSR_RSC(x)                            ((u32)(((x >> 21) & 0x0000000F)))
-#define BIT_MASK_R_RATE_CTRL_TABLE                     ((u32)0x000FFFFF << 0)          /*!<R/W 0x00011  Data Rate Control Table Register BitMap to indicate the response/protection/expected_response rate to use in this BSS. All management and control response frames should obey the rates set in the bitmap. Each bit is mapped as the following: Bit[0:3] = {1M, 2M, 5.5M, 11M } Bit[4:11] = {6M, 9M, 12M, 18M, 24M, 36M, 48M, 54M} Bit[12:19] = HT MCS0~MCS7 Response rate must be less than or equal to the rate of the initiating frame. If none of the bits are set, no response is generated by Rtl8712. If both the legacy rates and HT rates are defined as Basic Rates, fill in only the legacy portion of the bitmap. If only HT rates are defined as Basic Rates, fill in both the legacy and HT portion of the bitmap. */
-#define BIT_R_RATE_CTRL_TABLE(x)                       ((u32)(((x) & 0x000FFFFF) << 0))
-#define BIT_GET_R_RATE_CTRL_TABLE(x)                   ((u32)(((x >> 0) & 0x000FFFFF)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_BCN_AMPDU_CTCL
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_MASK_BCNQ1_HEAD                            ((u32)0x000000FF << 24)          /*!<R/W 0xF6  TXDMA will pull BCNQ1 Pkt in this address. Port1 & VAP 1/3/5/7 of port0 */
-#define BIT_BCNQ1_HEAD(x)                              ((u32)(((x) & 0x000000FF) << 24))
-#define BIT_GET_BCNQ1_HEAD(x)                          ((u32)(((x >> 24) & 0x000000FF)))
-#define BIT_MASK_AMPDU_MAX_TIME                        ((u32)0x000000FF << 16)          /*!<R/W 0x64  AMPDU duration limit in the unit of 32us. */
-#define BIT_AMPDU_MAX_TIME(x)                          ((u32)(((x) & 0x000000FF) << 16))
-#define BIT_GET_AMPDU_MAX_TIME(x)                      ((u32)(((x >> 16) & 0x000000FF)))
-#define BIT_MASK_BCNQ2_HEAD                            ((u32)0x000000FF << 8)          /*!<R/W 0xF6  TXDMA will pull BCNQ2 Pkt in this address. Port2, NAN */
-#define BIT_BCNQ2_HEAD(x)                              ((u32)(((x) & 0x000000FF) << 8))
-#define BIT_GET_BCNQ2_HEAD(x)                          ((u32)(((x >> 8) & 0x000000FF)))
-#define BIT_CHECK_CCK_EN                               ((u32)0x00000001 << 7)          /*!<R/W 0x0  If this bit is set, HW check Tx pkt’s data rate. When data rate is CCK rate, modify the rate to NON_CCK_RATE. */
-#define BIT_EN_BCN_PKT_REL                             ((u32)0x00000001 << 6)          /*!<R/W 0x0  If this bit is set, the BCN pkt will be set to non-valid after BCN TX. */
-#define BIT_BCN_PORT_SEL                               ((u32)0x00000001 << 5)          /*!<R/W 0x0  This bit use to select BCN on port 1 or port 0. This just useful in USB/SDIO interface. */
-#define BIT_MOREDATA_BYPASS                            ((u32)0x00000001 << 4)          /*!<R/W 0x0  If this bit is set, the moredata bit will controlled by DES, otherwise controlled by PTCL according TXPKTBUF status. */
-#define BIT_EN_CLR_CMD_REL_BCN_PKT                     ((u32)0x00000001 << 3)          /*!<R/W 0x0  If this bit is set, the BCN pkt will be set to non-valid when scheduler clear TX BCN CMD even non-TX. */
-#define BIT_EN_SET_MOREDATA                            ((u32)0x00000001 << 2)          /*!<R/W 0x1  1: Enable HW set the more data bit of the PKT that MACID release function tx. 0: Disable HW set the more data bit of the PKT that MACID release function tx. */
-#define BIT_DIS_CLEAR_MACID_RELEASE                    ((u32)0x00000001 << 1)          /*!<R/W 0x0  1: HW No clear MACID Release bit after release the pkt. 0: HW will clear MACID Release bit after release the pkt. */
-#define BIT_EN_MACID_RELEASE                           ((u32)0x00000001 << 0)          /*!<R/W 0x1  1: Enable MACID Release function. (same as MACID DROP) 0: Disable MACID Release function. */
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_AMPDU_MAX_LENGTH
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_MASK_AMPDU_MAX_LENGTH                      ((u32)0xFFFFFFFF << 0)          /*!<R/W 0xFFFFFFFF  AMPDU length limit */
-#define BIT_AMPDU_MAX_LENGTH(x)                        ((u32)(((x) & 0xFFFFFFFF) << 0))
-#define BIT_GET_AMPDU_MAX_LENGTH(x)                    ((u32)(((x >> 0) & 0xFFFFFFFF)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_NDPA_CTRL_LBK_ACQ_STOP
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_MASK_R_NDPA_BW                             ((u32)0x00000003 << 24)          /*!<R/W 0x0  NDPA bandwidth setting 3: 160M 2: 80M 1: 40M 0: 20M */
-#define BIT_R_NDPA_BW(x)                               ((u32)(((x) & 0x00000003) << 24))
-#define BIT_GET_R_NDPA_BW(x)                           ((u32)(((x >> 24) & 0x00000003)))
-#define BIT_MASK_R_SIGTA_BW                            ((u32)0x00000003 << 22)          /*!<R/W 0x0  Enable signaling TA in duplicate BW, valid if EN_SIGTA = 1 in TX DESC */
-#define BIT_R_SIGTA_BW(x)                              ((u32)(((x) & 0x00000003) << 22))
-#define BIT_GET_R_SIGTA_BW(x)                          ((u32)(((x >> 22) & 0x00000003)))
-#define BIT_R_SIGTA_BAR                                ((u32)0x00000001 << 21)          /*!<R/W 0x0  Enable BAR signaling TA in duplicate BW */
-#define BIT_R_EOF_EN                                   ((u32)0x00000001 << 20)          /*!<R/W 0x0  when set to 1, enable eof packet qos packet,but also need set agg_en to 0 in tx_desc */
-#define BIT_R_EN_GNT_BT_AWAKE                          ((u32)0x00000001 << 19)          /*!<R/W 0x1  Enable pollute bit function.(C card ECO item, modify hardware circuit and add two options) 0: Disable 1: Enable When (GNT_BT option/LTE_RX option/(GNT_WL==0)) == 1, retry count can't increase if Tx fail. One or more packets will record in polluted bit field of txreport when txreport generates in Tx ok or tx drop. */
-#define BIT_DIS_RELEASE_RETRY                          ((u32)0x00000001 << 18)          /*!<R/W 0x0  when release one packet for a macid, retry should happen on the same ACQ. Set 1 to remove this requirement */
-#define BIT_DIS_OQT_BLOCK                              ((u32)0x00000001 << 17)          /*!<R/W 0x0  If this bit is set, the OQT will not block by all AC queues occupied by other MACID. */
-#define BIT_SEARCH_QUEUE_EN                            ((u32)0x00000001 << 16)          /*!<R/W 0x0  Search queue request enable in ptcl idle:0 disable; 1 enable */
-#define BIT_MASK_WMAC_LBK_BUF_HEAD                     ((u32)0x000000FF << 8)          /*!<R/W 0xF6  In delay MAC LBK mode, this register indicate the LBK BUF head page. When this buffer size is not enough for LBK packet length, LBK test may fail. In ARP/NS mode, this register indicate the ARP/NS response packet head page. */
-#define BIT_WMAC_LBK_BUF_HEAD(x)                       ((u32)(((x) & 0x000000FF) << 8))
-#define BIT_GET_WMAC_LBK_BUF_HEAD(x)                   ((u32)(((x >> 8) & 0x000000FF)))
-#define BIT_AC7Q_STOP                                  ((u32)0x00000001 << 7)          /*!<R 0x0  When this bit is raised, AC7 queue is stop. Report by MAC. */
-#define BIT_AC6Q_STOP                                  ((u32)0x00000001 << 6)          /*!<R 0x0  When this bit is raised, AC6 queue is stop. Report by MAC. */
-#define BIT_AC5Q_STOP                                  ((u32)0x00000001 << 5)          /*!<R 0x0  When this bit is raised, AC5 queue is stop. Report by MAC. */
-#define BIT_AC4Q_STOP                                  ((u32)0x00000001 << 4)          /*!<R 0x0  When this bit is raised, AC4 queue is stop. Report by MAC. */
-#define BIT_AC3Q_STOP                                  ((u32)0x00000001 << 3)          /*!<R 0x0  When this bit is raised, AC3 queue is stop. Report by MAC. */
-#define BIT_AC2Q_STOP                                  ((u32)0x00000001 << 2)          /*!<R 0x0  When this bit is raised, AC2 queue is stop. Report by MAC. */
-#define BIT_AC1Q_STOP                                  ((u32)0x00000001 << 1)          /*!<R 0x0  When this bit is raised, AC1 queue is stop. Report by MAC. */
-#define BIT_AC0Q_STOP                                  ((u32)0x00000001 << 0)          /*!<R 0x0  When this bit is raised, AC0 queue is stop. Report by MAC. */
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_RD_RESP_PKT_TH
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_MASK_RD_RESP_PKT_TH                        ((u32)0x0000003F << 24)          /*!<R/W 0x03  When RD_CTRL responder enables, and the granted AC queue packet number is beyond this threshold, then responder will carry More PPDU =1 and piggyback data frames back. */
-#define BIT_RD_RESP_PKT_TH(x)                          ((u32)(((x) & 0x0000003F) << 24))
-#define BIT_GET_RD_RESP_PKT_TH(x)                      ((u32)(((x >> 24) & 0x0000003F)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_CMDQ_INFO
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_MASK_PKT_NUM_CMDQ_V2                       ((u32)0x000000FF << 24)          /*!<R 0x0  The total CMD Queue pkt number in TxPktbuffer */
-#define BIT_PKT_NUM_CMDQ_V2(x)                         ((u32)(((x) & 0x000000FF) << 24))
-#define BIT_GET_PKT_NUM_CMDQ_V2(x)                     ((u32)(((x >> 24) & 0x000000FF)))
-#define BIT_MASK_TAIL_PKT_CMDQ                         ((u32)0x000000FF << 16)          /*!<R 0xFF  The head page of the last packet of Queue 4. */
-#define BIT_TAIL_PKT_CMDQ(x)                           ((u32)(((x) & 0x000000FF) << 16))
-#define BIT_GET_TAIL_PKT_CMDQ(x)                       ((u32)(((x >> 16) & 0x000000FF)))
-#define BIT_MASK_PKT_NUM_CMDQ                          ((u32)0x000000FF << 8)          /*!<R 0x0  The total Queue 4 pkt number in TxPktbuffer */
-#define BIT_PKT_NUM_CMDQ(x)                            ((u32)(((x) & 0x000000FF) << 8))
-#define BIT_GET_PKT_NUM_CMDQ(x)                        ((u32)(((x >> 8) & 0x000000FF)))
-#define BIT_MASK_HEAD_PKT_CMDQ                         ((u32)0x000000FF << 0)          /*!<R 0xFF  The head page of the first packet of Queue 4. */
-#define BIT_HEAD_PKT_CMDQ(x)                           ((u32)(((x) & 0x000000FF) << 0))
-#define BIT_GET_HEAD_PKT_CMDQ(x)                       ((u32)(((x >> 0) & 0x000000FF)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_Q4_INFO
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_MASK_QUEUEMACID_Q4_V1                      ((u32)0x0000007F << 25)          /*!<R 0x0  MacID of head pkt */
-#define BIT_QUEUEMACID_Q4_V1(x)                        ((u32)(((x) & 0x0000007F) << 25))
-#define BIT_GET_QUEUEMACID_Q4_V1(x)                    ((u32)(((x >> 25) & 0x0000007F)))
-#define BIT_MASK_QUEUEAC_Q4_V1                         ((u32)0x00000003 << 23)          /*!<R 0x0  AC type of Queue 4. */
-#define BIT_QUEUEAC_Q4_V1(x)                           ((u32)(((x) & 0x00000003) << 23))
-#define BIT_GET_QUEUEAC_Q4_V1(x)                       ((u32)(((x >> 23) & 0x00000003)))
-#define BIT_MASK_TAIL_PKT_Q4_V1                        ((u32)0x000000FF << 15)          /*!<R 0xFF  The head page of the last packet of Queue 4. */
-#define BIT_TAIL_PKT_Q4_V1(x)                          ((u32)(((x) & 0x000000FF) << 15))
-#define BIT_GET_TAIL_PKT_Q4_V1(x)                      ((u32)(((x >> 15) & 0x000000FF)))
-#define BIT_MASK_PKT_NUM_Q4_V1                         ((u32)0x0000007F << 8)          /*!<R 0x0  The total Queue 4 pkt number in TxPktbuffer */
-#define BIT_PKT_NUM_Q4_V1(x)                           ((u32)(((x) & 0x0000007F) << 8))
-#define BIT_GET_PKT_NUM_Q4_V1(x)                       ((u32)(((x >> 8) & 0x0000007F)))
-#define BIT_MASK_HEAD_PKT_Q4                           ((u32)0x000000FF << 0)          /*!<R 0xFF  The head page of the first packet of Queue 4. */
-#define BIT_HEAD_PKT_Q4(x)                             ((u32)(((x) & 0x000000FF) << 0))
-#define BIT_GET_HEAD_PKT_Q4(x)                         ((u32)(((x >> 0) & 0x000000FF)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_Q5_INFO
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_MASK_QUEUEMACID_Q5_V1                      ((u32)0x0000007F << 25)          /*!<R 0x0  MacID of head pkt */
-#define BIT_QUEUEMACID_Q5_V1(x)                        ((u32)(((x) & 0x0000007F) << 25))
-#define BIT_GET_QUEUEMACID_Q5_V1(x)                    ((u32)(((x >> 25) & 0x0000007F)))
-#define BIT_MASK_QUEUEAC_Q5_V1                         ((u32)0x00000003 << 23)          /*!<R 0x0  AC type of Queue 5. */
-#define BIT_QUEUEAC_Q5_V1(x)                           ((u32)(((x) & 0x00000003) << 23))
-#define BIT_GET_QUEUEAC_Q5_V1(x)                       ((u32)(((x >> 23) & 0x00000003)))
-#define BIT_MASK_TAIL_PKT_Q5_V1                        ((u32)0x000000FF << 15)          /*!<R 0xFF  The head page of the last packet of Queue 5. */
-#define BIT_TAIL_PKT_Q5_V1(x)                          ((u32)(((x) & 0x000000FF) << 15))
-#define BIT_GET_TAIL_PKT_Q5_V1(x)                      ((u32)(((x >> 15) & 0x000000FF)))
-#define BIT_MASK_PKT_NUM_Q5_V1                         ((u32)0x0000007F << 8)          /*!<R 0x0  The total Queue 5 pkt number in TxPktbuffer */
-#define BIT_PKT_NUM_Q5_V1(x)                           ((u32)(((x) & 0x0000007F) << 8))
-#define BIT_GET_PKT_NUM_Q5_V1(x)                       ((u32)(((x >> 8) & 0x0000007F)))
-#define BIT_MASK_HEAD_PKT_Q5                           ((u32)0x000000FF << 0)          /*!<R 0xFF  The head page of the first packet of Queue5. */
-#define BIT_HEAD_PKT_Q5(x)                             ((u32)(((x) & 0x000000FF) << 0))
-#define BIT_GET_HEAD_PKT_Q5(x)                         ((u32)(((x >> 0) & 0x000000FF)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_Q6_INFO
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_MASK_QUEUEMACID_Q6_V1                      ((u32)0x0000007F << 25)          /*!<R 0x0  MacID of head pkt */
-#define BIT_QUEUEMACID_Q6_V1(x)                        ((u32)(((x) & 0x0000007F) << 25))
-#define BIT_GET_QUEUEMACID_Q6_V1(x)                    ((u32)(((x >> 25) & 0x0000007F)))
-#define BIT_MASK_QUEUEAC_Q6_V1                         ((u32)0x00000003 << 23)          /*!<R 0x0  AC type of Queue 6. */
-#define BIT_QUEUEAC_Q6_V1(x)                           ((u32)(((x) & 0x00000003) << 23))
-#define BIT_GET_QUEUEAC_Q6_V1(x)                       ((u32)(((x >> 23) & 0x00000003)))
-#define BIT_MASK_TAIL_PKT_Q6_V1                        ((u32)0x000000FF << 15)          /*!<R 0xFF  The head page of the last packet of Queue 6. */
-#define BIT_TAIL_PKT_Q6_V1(x)                          ((u32)(((x) & 0x000000FF) << 15))
-#define BIT_GET_TAIL_PKT_Q6_V1(x)                      ((u32)(((x >> 15) & 0x000000FF)))
-#define BIT_MASK_PKT_NUM_Q6_V1                         ((u32)0x0000007F << 8)          /*!<R 0x0  The total Queue 6 pkt number in TxPktbuffer */
-#define BIT_PKT_NUM_Q6_V1(x)                           ((u32)(((x) & 0x0000007F) << 8))
-#define BIT_GET_PKT_NUM_Q6_V1(x)                       ((u32)(((x >> 8) & 0x0000007F)))
-#define BIT_MASK_HEAD_PKT_Q6                           ((u32)0x000000FF << 0)          /*!<R 0xFF  The head page of the first packet of Queue 6. */
-#define BIT_HEAD_PKT_Q6(x)                             ((u32)(((x) & 0x000000FF) << 0))
-#define BIT_GET_HEAD_PKT_Q6(x)                         ((u32)(((x >> 0) & 0x000000FF)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_Q7_INFO
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_MASK_QUEUEMACID_Q7_V1                      ((u32)0x0000007F << 25)          /*!<R 0x0  MacID of head pkt */
-#define BIT_QUEUEMACID_Q7_V1(x)                        ((u32)(((x) & 0x0000007F) << 25))
-#define BIT_GET_QUEUEMACID_Q7_V1(x)                    ((u32)(((x >> 25) & 0x0000007F)))
-#define BIT_MASK_QUEUEAC_Q7_V1                         ((u32)0x00000003 << 23)          /*!<R 0x0  AC type of Queue 7. */
-#define BIT_QUEUEAC_Q7_V1(x)                           ((u32)(((x) & 0x00000003) << 23))
-#define BIT_GET_QUEUEAC_Q7_V1(x)                       ((u32)(((x >> 23) & 0x00000003)))
-#define BIT_MASK_TAIL_PKT_Q7_V1                        ((u32)0x000000FF << 15)          /*!<R 0xFF  The head page of the last packet of Queue 7. */
-#define BIT_TAIL_PKT_Q7_V1(x)                          ((u32)(((x) & 0x000000FF) << 15))
-#define BIT_GET_TAIL_PKT_Q7_V1(x)                      ((u32)(((x >> 15) & 0x000000FF)))
-#define BIT_MASK_PKT_NUM_Q7_V1                         ((u32)0x0000007F << 8)          /*!<R 0x0  The total Queue 7 pkt number in TxPktbuffer */
-#define BIT_PKT_NUM_Q7_V1(x)                           ((u32)(((x) & 0x0000007F) << 8))
-#define BIT_GET_PKT_NUM_Q7_V1(x)                       ((u32)(((x >> 8) & 0x0000007F)))
-#define BIT_MASK_HEAD_PKT_Q7                           ((u32)0x000000FF << 0)          /*!<R 0xFF  The head page of the first packet of Queue 7. */
-#define BIT_HEAD_PKT_Q7(x)                             ((u32)(((x) & 0x000000FF) << 0))
-#define BIT_GET_HEAD_PKT_Q7(x)                         ((u32)(((x >> 0) & 0x000000FF)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_GCLK_CFG
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_CLR_TXRPT_RW_PTR                           ((u32)0x00000001 << 2)          /*!<R/W 0x0  Write 1 to clear BIT_AMPDU_TXRPT_W_PTR & BIT_AMPDU_TXRPT_R_PTR (0x47C / 0x47D) */
-#define BIT_EN_QUEUE_RPT_B8                            ((u32)0x00000001 << 1)          /*!<R/W 0x1  [8] of BIT_EN_QUEUE_RPT, BIT8: EVENT Queue */
-#define BIT_EN_PTCL_GCLK                               ((u32)0x00000001 << 0)          /*!<R/W 0x1  1: enable clock gating */
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_TXRPT_CTRL
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_MASK_AMPDU_TXRPT_TIME_THRS                 ((u32)0x000000FF << 24)          /*!<R/W 0x10  Time threshold of ampdu txrpt */
-#define BIT_AMPDU_TXRPT_TIME_THRS(x)                   ((u32)(((x) & 0x000000FF) << 24))
-#define BIT_GET_AMPDU_TXRPT_TIME_THRS(x)               ((u32)(((x >> 24) & 0x000000FF)))
-#define BIT_MASK_AMPDU_TXRPT_LEN_THRS                  ((u32)0x000000FF << 16)          /*!<R/W 0x01  Length threshold of ampdu txrpt */
-#define BIT_AMPDU_TXRPT_LEN_THRS(x)                    ((u32)(((x) & 0x000000FF) << 16))
-#define BIT_GET_AMPDU_TXRPT_LEN_THRS(x)                ((u32)(((x >> 16) & 0x000000FF)))
-#define BIT_MASK_AMPDU_TXRPT_R_PTR                     ((u32)0x000000FF << 8)          /*!<R/W 0x0  Read pointer of ampdu txrpt */
-#define BIT_AMPDU_TXRPT_R_PTR(x)                       ((u32)(((x) & 0x000000FF) << 8))
-#define BIT_GET_AMPDU_TXRPT_R_PTR(x)                   ((u32)(((x >> 8) & 0x000000FF)))
-#define BIT_MASK_AMPDU_TXRPT_W_PTR                     ((u32)0x000000FF << 0)          /*!<RO 0x0  Write pointer of ampdu txrpt */
-#define BIT_AMPDU_TXRPT_W_PTR(x)                       ((u32)(((x) & 0x000000FF) << 0))
-#define BIT_GET_AMPDU_TXRPT_W_PTR(x)                   ((u32)(((x >> 0) & 0x000000FF)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_CFEND_RATE_SC_CTRL
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_MASK_TXSC_40M                              ((u32)0x0000000F << 28)          /*!<R/W 0x0  Value of Data frame Tx sub-carrier mode 40MHz */
-#define BIT_TXSC_40M(x)                                ((u32)(((x) & 0x0000000F) << 28))
-#define BIT_GET_TXSC_40M(x)                            ((u32)(((x >> 28) & 0x0000000F)))
-#define BIT_MASK_TXSC_20M                              ((u32)0x0000000F << 24)          /*!<R/W 0x0  Value of Data frame Tx sub-carrier mode 20MHz */
-#define BIT_TXSC_20M(x)                                ((u32)(((x) & 0x0000000F) << 24))
-#define BIT_GET_TXSC_20M(x)                            ((u32)(((x >> 24) & 0x0000000F)))
-#define BIT_MASK_STBC_CFEND_RATE                       ((u32)0x000001FF << 15)          /*!<R/W 0x80  The initial rate for STBC CFEND frame transmitted as EDCA originator. The response control frame shall be selected by the definition of 802.11n. MCS0 */
-#define BIT_STBC_CFEND_RATE(x)                         ((u32)(((x) & 0x000001FF) << 15))
-#define BIT_GET_STBC_CFEND_RATE(x)                     ((u32)(((x >> 15) & 0x000001FF)))
-#define BIT_MASK_BASIC_CFEND_RATE                      ((u32)0x000001FF << 6)          /*!<R/W 0x04  The initial rate for basic CFEND frame transmitted as EDCA originator. The response control frame shall be selected by the definition of 802.11n. OFDM6M */
-#define BIT_BASIC_CFEND_RATE(x)                        ((u32)(((x) & 0x000001FF) << 6))
-#define BIT_GET_BASIC_CFEND_RATE(x)                    ((u32)(((x >> 6) & 0x000001FF)))
-#define BIT_LEAG_RTS_BW_DUP                            ((u32)0x00000001 << 5)          /*!<R/W 0x0  If this bit is set, leag rate RTS use Duplicate in 40M BW / 80M BW. */
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_MACID_SLEEP3
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_MASK_MACID127_96_PKTSLEEP                  ((u32)0xFFFFFFFF << 0)          /*!<R/W 0x0  Macid 127~Macid 96 Packet Sleep (per bit controlled) */
-#define BIT_MACID127_96_PKTSLEEP(x)                    ((u32)(((x) & 0xFFFFFFFF) << 0))
-#define BIT_GET_MACID127_96_PKTSLEEP(x)                ((u32)(((x >> 0) & 0xFFFFFFFF)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_MACID_SLEEP1
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_MASK_MACID63_32_PKTSLEEP                   ((u32)0xFFFFFFFF << 0)          /*!<R/W 0x0  Macid 63~Macid 32 Packet Sleep (per bit controlled) */
-#define BIT_MACID63_32_PKTSLEEP(x)                     ((u32)(((x) & 0xFFFFFFFF) << 0))
-#define BIT_GET_MACID63_32_PKTSLEEP(x)                 ((u32)(((x >> 0) & 0xFFFFFFFF)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_TXRPT_START_OFFSET
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_RPTFIFO_1K                                 ((u32)0x00000001 << 16)          /*!<R/W 0x0  select the size of rptfifo */
-#define BIT_MASK_MACID_CTRL_OFFSET                     ((u32)0x000000FF << 8)          /*!<R/W 0x0  offset of macid control: ctrl_info in the start of txrptbuf */
-#define BIT_MACID_CTRL_OFFSET(x)                       ((u32)(((x) & 0x000000FF) << 8))
-#define BIT_GET_MACID_CTRL_OFFSET(x)                   ((u32)(((x >> 8) & 0x000000FF)))
-#define BIT_MASK_AMPDU_TXRPT_OFFSET                    ((u32)0x000000FF << 0)          /*!<R/W 0x5  offset of AMPDU txrpt */
-#define BIT_AMPDU_TXRPT_OFFSET(x)                      ((u32)(((x) & 0x000000FF) << 0))
-#define BIT_GET_AMPDU_TXRPT_OFFSET(x)                  ((u32)(((x >> 0) & 0x000000FF)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_PTA_WL_PRI_MASK
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_PTA_WL_PRI_MASK_CPU_MGQ                    ((u32)0x00000001 << 31)          /*!<R/W 0x0  PTCL send wl_pri to PTA when pktbuf has CPU_MGQ packet */
-#define BIT_PTA_WL_PRI_MASK_BCNQ                       ((u32)0x00000001 << 30)          /*!<R/W 0x0  PTCL send wl_pri to PTA when pktbuf has BCNQ packet */
-#define BIT_PTA_WL_PRI_MASK_HIQ                        ((u32)0x00000001 << 29)          /*!<R/W 0x0  PTCL send wl_pri to PTA when pktbuf has HIQ packet */
-#define BIT_PTA_WL_PRI_MASK_MGQ                        ((u32)0x00000001 << 28)          /*!<R/W 0x0  PTCL send wl_pri to PTA when pktbuf has MGQ packet */
-#define BIT_PTA_WL_PRI_MASK_BK                         ((u32)0x00000001 << 27)          /*!<R/W 0x0  PTCL send wl_pri to PTA when pktbuf has BKQ packet */
-#define BIT_PTA_WL_PRI_MASK_BE                         ((u32)0x00000001 << 26)          /*!<R/W 0x0  PTCL send wl_pri to PTA when pktbuf has BEQ packet */
-#define BIT_PTA_WL_PRI_MASK_VI                         ((u32)0x00000001 << 25)          /*!<R/W 0x0  PTCL send wl_pri to PTA when pktbuf has VIQ packet */
-#define BIT_PTA_WL_PRI_MASK_VO                         ((u32)0x00000001 << 24)          /*!<R/W 0x0  PTCL send wl_pri to PTA when pktbuf has VOQ packet */
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_EVTQ_RPT
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_MASK_EVTQ_TX_RPT                           ((u32)0x00000007 << 27)          /*!<R 0x0  *000: nothing *100: pktok *010: pktfail / timeout *001: evtq_tx_area_75 */
-#define BIT_EVTQ_TX_RPT(x)                             ((u32)(((x) & 0x00000007) << 27))
-#define BIT_GET_EVTQ_TX_RPT(x)                         ((u32)(((x >> 27) & 0x00000007)))
-#define BIT_PTA_WL_PRI_MASK_EVT                        ((u32)0x00000001 << 25)          /*!<R/W 0x0  PTCL send wl_pri to PTA when pktbuf has EVTQ packet */
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_SW_AMPDU_BURST_MODE_CTRL
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_MASK_EVTQ_HEAD                             ((u32)0x000000FF << 24)          /*!<R/W 0xf6  TXDMA will pull eventq Pkt in this address. NAN */
-#define BIT_EVTQ_HEAD(x)                               ((u32)(((x) & 0x000000FF) << 24))
-#define BIT_GET_EVTQ_HEAD(x)                           ((u32)(((x >> 24) & 0x000000FF)))
-#define BIT_MASK_DMA_THIS_QUEUE                        ((u32)0x0000000F << 20)          /*!<R/W 0x0  scheduler enable */
-#define BIT_DMA_THIS_QUEUE(x)                          ((u32)(((x) & 0x0000000F) << 20))
-#define BIT_GET_DMA_THIS_QUEUE(x)                      ((u32)(((x >> 20) & 0x0000000F)))
-#define BIT_MASK_TOTAL_LEN_THRS                        ((u32)0x00000FFF << 8)          /*!<R/W 0x400  aggregation length over threshold then fetch pad packet in early mode */
-#define BIT_TOTAL_LEN_THRS(x)                          ((u32)(((x) & 0x00000FFF) << 8))
-#define BIT_GET_TOTAL_LEN_THRS(x)                      ((u32)(((x >> 8) & 0x00000FFF)))
-#define BIT_WEP_PRETX_EN                               ((u32)0x00000001 << 7)          /*!<R/W 0x1  Enable pretx for WEP/TKIP, to allow a slower security clock */
-#define BIT_PRE_TX_CMD                                 ((u32)0x00000001 << 6)          /*!<R/W 0x1  enable pre tx cmd to use aggr more packet */
-#define BIT_MASK_NUM_SCL_EN                            ((u32)0x00000003 << 4)          /*!<R/W 0x0  SW MPDU Burst mode select 00: each length field for 1 MPDU 01: each length field is the summation of 2 MPDUs 10: each length field is the summation of 3 MPDUs 11: each length field is the summation of 4 MPDUs Note: the total MPDU number is no more than 15. */
-#define BIT_NUM_SCL_EN(x)                              ((u32)(((x) & 0x00000003) << 4))
-#define BIT_GET_NUM_SCL_EN(x)                          ((u32)(((x >> 4) & 0x00000003)))
-#define BIT_BK_EN                                      ((u32)0x00000001 << 3)          /*!<R/W 0x0  AMPDU burst mode enable for AC_BK queue */
-#define BIT_BE_EN                                      ((u32)0x00000001 << 2)          /*!<R/W 0x0  AMPDU burst mode enable for AC_BE queue */
-#define BIT_VI_EN                                      ((u32)0x00000001 << 1)          /*!<R/W 0x0  AMPDU burst mode enable for AC_VI queue */
-#define BIT_VO_EN                                      ((u32)0x00000001 << 0)          /*!<R/W 0x0  AMPDU burst mode enable for AC_VO queue */
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_PKT_LIFE_TIME
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_MASK_PKT_LIFTIME_BEBK                      ((u32)0x0000FFFF << 16)          /*!<R/W 0x1000  BE/BK packet lifetime unit: 256us */
-#define BIT_PKT_LIFTIME_BEBK(x)                        ((u32)(((x) & 0x0000FFFF) << 16))
-#define BIT_GET_PKT_LIFTIME_BEBK(x)                    ((u32)(((x >> 16) & 0x0000FFFF)))
-#define BIT_MASK_PKT_LIFTIME_VOVI                      ((u32)0x0000FFFF << 0)          /*!<R/W 0x1000  VO/VI packet lifetime unit: 256us */
-#define BIT_PKT_LIFTIME_VOVI(x)                        ((u32)(((x) & 0x0000FFFF) << 0))
-#define BIT_GET_PKT_LIFTIME_VOVI(x)                    ((u32)(((x >> 0) & 0x0000FFFF)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_PTA_STBC_CTRL
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_EN_SINGLE_APMDU                            ((u32)0x00000001 << 31)          /*!<R/W 0x0  If this bit is set, Enable single sub-frame APMDU. */
-#define BIT_FORCE_RND_PRI                              ((u32)0x00000001 << 22)          /*!<R/W 0x0  queue select priority control 1:old round robin method 0:depend on last selected queue */
-#define BIT_PTA_EDCCA_EN                               ((u32)0x00000001 << 21)          /*!<R/W 0x0  0 : wl_tx signal to PTA does not consider EDCCA 1 : wl_tx signal to PTA consider EDCCA */
-#define BIT_PTA_WL_TX_EN                               ((u32)0x00000001 << 20)          /*!<R/W 0x0  enable WL PTA (should be set in init MAC) */
-#define BIT_R_USE_DATA_BW                              ((u32)0x00000001 << 19)          /*!<R/W 0x0  1 : Use des2_data_bw for this packet 0 : when des1_cca_rts = 2'b10, update_bw depend on ch_bw_status */
-#define BIT_TRI_PKT_STATUS                             ((u32)0x00000001 << 18)          /*!<R/W 0x1   */
-#define BIT_TRI_PKT_PKTIN                              ((u32)0x00000001 << 17)          /*!<R/W 0x0  If trigger frame is transmitted into txpktbuf, HW generates interrupt 1: Enable 0: Disable */
-#define BIT_ACQ_MODE_SEL                               ((u32)0x00000001 << 16)          /*!<R/W 0x0  1: Enable 88C 4AC Mode 0: Enable 8723 ACQ0~7 Mode */
-#define BIT_MASK_CDEND_TXTIME_H                        ((u32)0x0000001F << 8)          /*!<R/W 0x3  Cfend packet txtime bit[8:4] */
-#define BIT_CDEND_TXTIME_H(x)                          ((u32)(((x) & 0x0000001F) << 8))
-#define BIT_GET_CDEND_TXTIME_H(x)                      ((u32)(((x >> 8) & 0x0000001F)))
-#define BIT_MASK_CDEND_TXTIME_L                        ((u32)0x0000000F << 4)          /*!<R/W 0x4  Cfend packet txtime bit[3:0] */
-#define BIT_CDEND_TXTIME_L(x)                          ((u32)(((x) & 0x0000000F) << 4))
-#define BIT_GET_CDEND_TXTIME_L(x)                      ((u32)(((x >> 4) & 0x0000000F)))
-#define BIT_MASK_NESS                                  ((u32)0x00000003 << 2)          /*!<R/W 0x0  NESS */
-#define BIT_NESS(x)                                    ((u32)(((x) & 0x00000003) << 2))
-#define BIT_GET_NESS(x)                                ((u32)(((x >> 2) & 0x00000003)))
-#define BIT_MASK_STBC_CFEND                            ((u32)0x00000003 << 0)          /*!<R/W 0x0  CFEND STBC */
-#define BIT_STBC_CFEND(x)                              ((u32)(((x) & 0x00000003) << 0))
-#define BIT_GET_STBC_CFEND(x)                          ((u32)(((x >> 0) & 0x00000003)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_PROT_MODE_CTRL
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_MASK_RTS_MAX_AGG_NUM                       ((u32)0x0000003F << 24)          /*!<R/W 0xC  In RTS frame exchange sequence, the maximum aggregation packet number limit is defined by this register, unit is byte */
-#define BIT_RTS_MAX_AGG_NUM(x)                         ((u32)(((x) & 0x0000003F) << 24))
-#define BIT_GET_RTS_MAX_AGG_NUM(x)                     ((u32)(((x >> 24) & 0x0000003F)))
-#define BIT_MASK_MAX_AGG_NUM                           ((u32)0x0000003F << 16)          /*!<R/W 0x14  the maximum aggregation packet number limit,unit is byte */
-#define BIT_MAX_AGG_NUM(x)                             ((u32)(((x) & 0x0000003F) << 16))
-#define BIT_GET_MAX_AGG_NUM(x)                         ((u32)(((x >> 16) & 0x0000003F)))
-#define BIT_MASK_RTS_TXTIME_TH                         ((u32)0x000000FF << 8)          /*!<R/W 0x1  RTS packet txtime threshold, unit is 64 us */
-#define BIT_RTS_TXTIME_TH(x)                           ((u32)(((x) & 0x000000FF) << 8))
-#define BIT_GET_RTS_TXTIME_TH(x)                       ((u32)(((x >> 8) & 0x000000FF)))
-#define BIT_MASK_RTS_LEN_TH                            ((u32)0x000000FF << 0)          /*!<R/W 0x1  RTS packet Length threshold, unit is 128 bytes */
-#define BIT_RTS_LEN_TH(x)                              ((u32)(((x) & 0x000000FF) << 0))
-#define BIT_GET_RTS_LEN_TH(x)                          ((u32)(((x >> 0) & 0x000000FF)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_BAR_MODE_CTRL
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_MASK_RTY_PKT_LMT                           ((u32)0x0000003F << 24)          /*!<R/W 0x1  retry packet limit */
-#define BIT_RTY_PKT_LMT(x)                             ((u32)(((x) & 0x0000003F) << 24))
-#define BIT_GET_RTY_PKT_LMT(x)                         ((u32)(((x >> 24) & 0x0000003F)))
-#define BIT_MASK_BAR_RTY_LMT                           ((u32)0x00000003 << 16)          /*!<R/W 0x2  BAR retry limit */
-#define BIT_BAR_RTY_LMT(x)                             ((u32)(((x) & 0x00000003) << 16))
-#define BIT_GET_BAR_RTY_LMT(x)                         ((u32)(((x >> 16) & 0x00000003)))
-#define BIT_MASK_BAR_PKTTIME_THRS                      ((u32)0x000000FF << 8)          /*!<R/W 0xFF  BAR packet time thrs */
-#define BIT_BAR_PKTTIME_THRS(x)                        ((u32)(((x) & 0x000000FF) << 8))
-#define BIT_GET_BAR_PKTTIME_THRS(x)                    ((u32)(((x >> 8) & 0x000000FF)))
-#define BIT_MASK_BAR_PKTNUM_TH_V1                      ((u32)0x0000007F << 0)          /*!<R/W 0x7F  BAR Pktnum Thrs */
-#define BIT_BAR_PKTNUM_TH_V1(x)                        ((u32)(((x) & 0x0000007F) << 0))
-#define BIT_GET_BAR_PKTNUM_TH_V1(x)                    ((u32)(((x >> 0) & 0x0000007F)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_MACID_SLEEP2
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_MASK_MACID95_64PKTSLEEP                    ((u32)0xFFFFFFFF << 0)          /*!<R/W 0x0  Macid 95~Macid 64 Packet Sleep (per bit controlled) */
-#define BIT_MACID95_64PKTSLEEP(x)                      ((u32)(((x) & 0xFFFFFFFF) << 0))
-#define BIT_GET_MACID95_64PKTSLEEP(x)                  ((u32)(((x >> 0) & 0xFFFFFFFF)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_MACID_SLEEP
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_MASK_MACID31_0_PKTSLEEP                    ((u32)0xFFFFFFFF << 0)          /*!<R/W 0x0  Macid31 ~ Macid 0Packet Sleep. (per bit controlled) */
-#define BIT_MACID31_0_PKTSLEEP(x)                      ((u32)(((x) & 0xFFFFFFFF) << 0))
-#define BIT_GET_MACID31_0_PKTSLEEP(x)                  ((u32)(((x >> 0) & 0xFFFFFFFF)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_HW_SEQ0_1
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_MASK_HW_SSN_SEQ1                           ((u32)0x00000FFF << 16)          /*!<R/W 0x0  When TXDESC HWSEQEN is set, MAC will overwrite SEQ control by this register. Before DRV hand over the SEQ control to HW, DRV may set the current SEQ to this register. When DRV will take back the SEQ control from HW, DRV may get the current sequence from this register. */
-#define BIT_HW_SSN_SEQ1(x)                             ((u32)(((x) & 0x00000FFF) << 16))
-#define BIT_GET_HW_SSN_SEQ1(x)                         ((u32)(((x >> 16) & 0x00000FFF)))
-#define BIT_MASK_HW_SSN_SEQ0                           ((u32)0x00000FFF << 0)          /*!<R/W 0x0  When TXDESC HWSEQEN is set, MAC will overwrite SEQ control by this register. Before DRV hand over the SEQ control to HW, DRV may set the current SEQ to this register. When DRV will take back the SEQ control from HW, DRV may get the current sequence from this register. */
-#define BIT_HW_SSN_SEQ0(x)                             ((u32)(((x) & 0x00000FFF) << 0))
-#define BIT_GET_HW_SSN_SEQ0(x)                         ((u32)(((x >> 0) & 0x00000FFF)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_HW_SEQ2_3
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_MASK_HW_SSN_SEQ3                           ((u32)0x00000FFF << 16)          /*!<R/W 0x0  When TXDESC HWSEQEN is set, MAC will overwrite SEQ control by this register. Before DRV hand over the SEQ control to HW, DRV may set the current SEQ to this register. When DRV will take back the SEQ control from HW, DRV may get the current sequence from this register. */
-#define BIT_HW_SSN_SEQ3(x)                             ((u32)(((x) & 0x00000FFF) << 16))
-#define BIT_GET_HW_SSN_SEQ3(x)                         ((u32)(((x >> 16) & 0x00000FFF)))
-#define BIT_MASK_HW_SSN_SEQ2                           ((u32)0x00000FFF << 0)          /*!<R/W 0x0  When TXDESC HWSEQEN is set, MAC will overwrite SEQ control by this register. Before DRV hand over the SEQ control to HW, DRV may set the current SEQ to this register. When DRV will take back the SEQ control from HW, DRV may get the current sequence from this register. */
-#define BIT_HW_SSN_SEQ2(x)                             ((u32)(((x) & 0x00000FFF) << 0))
-#define BIT_GET_HW_SSN_SEQ2(x)                         ((u32)(((x >> 0) & 0x00000FFF)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_PTCLERR_NULLPKT_STATUS
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_MASK_PTCL_TOTAL_PG0_7                      ((u32)0x000000FF << 24)          /*!<RO 0x0  Total Page in PTCL */
-#define BIT_PTCL_TOTAL_PG0_7(x)                        ((u32)(((x) & 0x000000FF) << 24))
-#define BIT_GET_PTCL_TOTAL_PG0_7(x)                    ((u32)(((x >> 24) & 0x000000FF)))
-#define BIT_PTCL_TOTAL_PG_8                            ((u32)0x00000001 << 23)          /*!<RO 0x0  Total Page in PTCL */
-#define BIT_PTCL_RATE_TABLE_INVALID                    ((u32)0x00000001 << 22)          /*!<R/W1C 0x0  during rate fallback process, if the all rate table is invalid, then assert ERROR FLAG */
-#define BIT_RD_TXHANG_ERR                              ((u32)0x00000001 << 21)          /*!<R/W1C 0x0  Indicates the txhang error in RDG mode */
-#define BIT_RD_STATUS_ERR                              ((u32)0x00000001 << 20)          /*!<R/W1C 0x0  Indicates the status error in RDG mode */
-#define BIT_RD_CTN_ERR                                 ((u32)0x00000001 << 19)          /*!<R/W1C 0x0  Indicates the cnt error in RDG mode */
-#define BIT_MASK_RD_PKTIN_ERR                          ((u32)0x00000007 << 16)          /*!<R/W1C 0x0  Indicates the pktin error in RDG mode */
-#define BIT_RD_PKTIN_ERR(x)                            ((u32)(((x) & 0x00000007) << 16))
-#define BIT_GET_RD_PKTIN_ERR(x)                        ((u32)(((x >> 16) & 0x00000007)))
-#define BIT_RD_FTMT2R_ERR                              ((u32)0x00000001 << 15)          /*!<R/W1C 0x0  Indicates the timeout error in FTM t2r report */
-#define BIT_P1_TX_NULL_1                               ((u32)0x00000001 << 3)          /*!<RO 0x0  Port 1 Tx Null 1 packet ok indicator */
-#define BIT_P1_TX_NULL_0                               ((u32)0x00000001 << 2)          /*!<RO 0x0  Port 1 Tx Null 0 packet ok indicator */
-#define BIT_P0_TX_NULL_1                               ((u32)0x00000001 << 1)          /*!<RO 0x0  Port 0 Tx Null 1 packet ok indicator */
-#define BIT_P0_TX_NULL_0                               ((u32)0x00000001 << 0)          /*!<RO 0x0  Port 0 Tx Null 0 packet ok indicator */
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_PRETX_DROP_CTRL
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_MASK_COLLI_DETEC_TIME_MAX                  ((u32)0x0000000F << 20)          /*!<R/W 0xF  0~15: The field indicated collision detect time for broadcast or Beacon packet.(unit: us) */
-#define BIT_COLLI_DETEC_TIME_MAX(x)                    ((u32)(((x) & 0x0000000F) << 20))
-#define BIT_GET_COLLI_DETEC_TIME_MAX(x)                ((u32)(((x >> 20) & 0x0000000F)))
-#define BIT_PRETX_AGGR_EN                              ((u32)0x00000001 << 19)          /*!<R/W 0x1  1: enable PRETX function, default is enable 0: disable PRETX function */
-#define BIT_MASK_PRETX_AGGR_TIME_MAX                   ((u32)0x000007FF << 8)          /*!<R/W 0x8C  If BIT_PRETX_AGGR_EN = 1, the bits will count down after PHYTXON signal asserting every transmission in pre-tx mode.(Default: 23F, mac_clk = 20MHz, 3us;Smart,mac_clk = 40MHz, 3.5us) */
-#define BIT_PRETX_AGGR_TIME_MAX(x)                     ((u32)(((x) & 0x000007FF) << 8))
-#define BIT_GET_PRETX_AGGR_TIME_MAX(x)                 ((u32)(((x >> 8) & 0x000007FF)))
-#define BIT_HGQ_DEL_EN                                 ((u32)0x00000001 << 7)          /*!<R/W 0x0  1: HGQ packet will be dropped when enable macid delete function; 0: HGQ packet cannot be dropped */
-#define BIT_MGQ_DEL_EN                                 ((u32)0x00000001 << 6)          /*!<R/W 0x0  1: MGQ packet will be dropped when enable macid delete function; 0: MGQ packet cannot be dropped */
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_BT_POLLUTE_PKT_CNT
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_MASK_BT_RXPOLLUTE_PKT_CNT                  ((u32)0x0000FFFF << 16)          /*!<R 0x0  count the tx fail pkt caused by bt RX pollute, write 0x4E8[31] will clear the counter */
-#define BIT_BT_RXPOLLUTE_PKT_CNT(x)                    ((u32)(((x) & 0x0000FFFF) << 16))
-#define BIT_GET_BT_RXPOLLUTE_PKT_CNT(x)                ((u32)(((x >> 16) & 0x0000FFFF)))
-#define BIT_MASK_BT_TXPOLLUTE_PKT_CNT                  ((u32)0x0000FFFF << 0)          /*!<R 0x0  count the tx fail pkt caused by bt TX pollute, write 0x4E8[15] will clear the counter */
-#define BIT_BT_TXPOLLUTE_PKT_CNT(x)                    ((u32)(((x) & 0x0000FFFF) << 0))
-#define BIT_GET_BT_TXPOLLUTE_PKT_CNT(x)                ((u32)(((x >> 0) & 0x0000FFFF)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_DROP_PKT_NUM
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_MASK_LIFE_DROP_NUM                         ((u32)0x0000FFFF << 16)          /*!<R/W 0x0  TIE 0 in 8723F */
-#define BIT_LIFE_DROP_NUM(x)                           ((u32)(((x) & 0x0000FFFF) << 16))
-#define BIT_GET_LIFE_DROP_NUM(x)                       ((u32)(((x >> 16) & 0x0000FFFF)))
-#define BIT_MASK_DROP_PKT_NUM                          ((u32)0x0000FFFF << 0)          /*!<R/WC 0x0  Statistic the number of dropped packets */
-#define BIT_DROP_PKT_NUM(x)                            ((u32)(((x) & 0x0000FFFF) << 0))
-#define BIT_GET_DROP_PKT_NUM(x)                        ((u32)(((x >> 0) & 0x0000FFFF)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_CPUMGQ_TIMER_CTRL
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_MASK_MGQ_TRI_HEAD                          ((u32)0x00000FFF << 16)          /*!<R/W 0x0  The head page of the CPUMGQ pkt If the CPUMGQ is triggered by TX TIMER. */
-#define BIT_MGQ_TRI_HEAD(x)                            ((u32)(((x) & 0x00000FFF) << 16))
-#define BIT_GET_MGQ_TRI_HEAD(x)                        ((u32)(((x >> 16) & 0x00000FFF)))
-#define BIT_CPUMGQ_TRI_LIFETIME_EN                     ((u32)0x00000001 << 8)          /*!<R/W 0x0  When this bit is set, enable the lifetime function. This lifetime threshold only affect CPUMGQ trigger from Tx_Timer. */
-#define BIT_MASK_CPUMGQ_TRI_LIFETIME                   ((u32)0x000000FF << 0)          /*!<R/W 0x0  LIFETIME Threshold: Unit = 256us. When CPU MgntQ is triggered, If BIT_CPUMGQ_TRI_LIFETIME_EN = 1, count down. If BIT_CPUMGQ_TRI_LIFETIME_EN = 0, do nothing. */
-#define BIT_CPUMGQ_TRI_LIFETIME(x)                     ((u32)(((x) & 0x000000FF) << 0))
-#define BIT_GET_CPUMGQ_TRI_LIFETIME(x)                 ((u32)(((x >> 0) & 0x000000FF)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_DUMMY
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_MASK_DUMMY_REG_1                           ((u32)0x00003FFF << 18)          /*!<R/W 0x3FFF  dummy reg */
-#define BIT_DUMMY_REG_1(x)                             ((u32)(((x) & 0x00003FFF) << 18))
-#define BIT_GET_DUMMY_REG_1(x)                         ((u32)(((x >> 18) & 0x00003FFF)))
-#define BIT_EN_BCN_TRXRPT                              ((u32)0x00000001 << 17)          /*!<R/W 0x1  If this bit is set, PTCL will write BCN TRXRPT when BCNOK/BCNERR INT. FW have clear this bit before enter LPS 32K mode. */
-#define BIT_MASK_DUMMY_REG_0                           ((u32)0x0001FFFF << 0)          /*!<R/W 0x10000  dummy reg */
-#define BIT_DUMMY_REG_0(x)                             ((u32)(((x) & 0x0001FFFF) << 0))
-#define BIT_GET_DUMMY_REG_0(x)                         ((u32)(((x >> 0) & 0x0001FFFF)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_AESIV_SETTING
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_MASK_AESIV_OFFSET                          ((u32)0x00000FFF << 0)          /*!<R/W 0x3  aesiv offset in txrpt buffer (Unit:128Bytes). */
-#define BIT_AESIV_OFFSET(x)                            ((u32)(((x) & 0x00000FFF) << 0))
-#define BIT_GET_AESIV_OFFSET(x)                        ((u32)(((x >> 0) & 0x00000FFF)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_BF0_TIME_SETTING
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_BF0_TIMER_SET                              ((u32)0x00000001 << 31)          /*!<W1C 0x0  write 1 to set beamforming 0 timer to BIT_bf0_lifetime */
-#define BIT_BF0_TIMER_CLR                              ((u32)0x00000001 << 30)          /*!<W1C 0x0  write 1 to clear beamforming 0 timer to 0 */
-#define BIT_EN_BF0_UPDATE                              ((u32)0x00000001 << 29)          /*!<R/W 0x0  1: when tx ndp ok/fail, enable to update beamforming 0 timer */
-#define BIT_EN_BF0_TIMER                               ((u32)0x00000001 << 28)          /*!<R/W 0x0  beamforming 0 timer enable */
-#define BIT_MASK_BF0_PRETIME_OVER                      ((u32)0x00000FFF << 16)          /*!<R/W 0xFFF  beamforming 0 pre timeout time */
-#define BIT_BF0_PRETIME_OVER(x)                        ((u32)(((x) & 0x00000FFF) << 16))
-#define BIT_GET_BF0_PRETIME_OVER(x)                    ((u32)(((x >> 16) & 0x00000FFF)))
-#define BIT_MASK_BF0_LIFETIME                          ((u32)0x0000FFFF << 0)          /*!<R/W 0xFFFF  beamforming 0 life time */
-#define BIT_BF0_LIFETIME(x)                            ((u32)(((x) & 0x0000FFFF) << 0))
-#define BIT_GET_BF0_LIFETIME(x)                        ((u32)(((x >> 0) & 0x0000FFFF)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_BF1_TIME_SETTING
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_BF1_TIMER_SET                              ((u32)0x00000001 << 31)          /*!<W1C 0x0  write 1 to set beamforming 1 timer to BIT_bf1_lifetime */
-#define BIT_BF1_TIMER_CLR                              ((u32)0x00000001 << 30)          /*!<W1C 0x0  write 1 to clear beamforming 1 timer to 0 */
-#define BIT_EN_BF1_UPDATE                              ((u32)0x00000001 << 29)          /*!<R/W 0x0  1: when tx ndp ok/fail, enable to update beamforming 1 timer */
-#define BIT_EN_BF1_TIMER                               ((u32)0x00000001 << 28)          /*!<R/W 0x0  beamforming 1 timer enable */
-#define BIT_MASK_BF1_PRETIME_OVER                      ((u32)0x00000FFF << 16)          /*!<R/W 0xFFF  beamforming 1 pre timeout time */
-#define BIT_BF1_PRETIME_OVER(x)                        ((u32)(((x) & 0x00000FFF) << 16))
-#define BIT_GET_BF1_PRETIME_OVER(x)                    ((u32)(((x >> 16) & 0x00000FFF)))
-#define BIT_MASK_BF1_LIFETIME                          ((u32)0x0000FFFF << 0)          /*!<R/W 0xFFFF  beamforming 1 life time */
-#define BIT_BF1_LIFETIME(x)                            ((u32)(((x) & 0x0000FFFF) << 0))
-#define BIT_GET_BF1_LIFETIME(x)                        ((u32)(((x >> 0) & 0x0000FFFF)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_BF_TIMEOUT_EN
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_EN_VHT_LDPC                                ((u32)0x00000001 << 9)          /*!<R/W 0x1  1: enable ldpc in vht rate mode */
-#define BIT_EN_HT_LDPC                                 ((u32)0x00000001 << 8)          /*!<R/W 0x1  1: enable ldpc in ht rate mode */
-#define BIT_BF1_TIMEOUT_EN                             ((u32)0x00000001 << 1)          /*!<R/W 0x1  1: when beamforming 1 timer count to 0,then disable beamforming 0 */
-#define BIT_BF0_TIMEOUT_EN                             ((u32)0x00000001 << 0)          /*!<R/W 0x1  1: when beamforming 0 timer count to 0,then disable beamforming 0 */
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_MACID_RELEASE0
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_MASK_MACID31_0_RELEASE                     ((u32)0xFFFFFFFF << 0)          /*!<R/W 0x0  Macid31~Macid0 Release(per bit controlled) */
-#define BIT_MACID31_0_RELEASE(x)                       ((u32)(((x) & 0xFFFFFFFF) << 0))
-#define BIT_GET_MACID31_0_RELEASE(x)                   ((u32)(((x >> 0) & 0xFFFFFFFF)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_MACID_RELEASE1
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_MASK_MACID63_32_RELEASE                    ((u32)0xFFFFFFFF << 0)          /*!<R/W 0x0  Macid63~Macid32 Release(per bit controlled) */
-#define BIT_MACID63_32_RELEASE(x)                      ((u32)(((x) & 0xFFFFFFFF) << 0))
-#define BIT_GET_MACID63_32_RELEASE(x)                  ((u32)(((x >> 0) & 0xFFFFFFFF)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_MACID_RELEASE2
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_MASK_MACID95_64_RELEASE                    ((u32)0xFFFFFFFF << 0)          /*!<R/W 0x0  Macid95~Macid64 Release (per bit controlled) */
-#define BIT_MACID95_64_RELEASE(x)                      ((u32)(((x) & 0xFFFFFFFF) << 0))
-#define BIT_GET_MACID95_64_RELEASE(x)                  ((u32)(((x >> 0) & 0xFFFFFFFF)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_MACID_RELEASE3
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_MASK_MACID127_96_RELEASE                   ((u32)0xFFFFFFFF << 0)          /*!<R/W 0x0  Macid127~Macid96 Release (per bit controlled) */
-#define BIT_MACID127_96_RELEASE(x)                     ((u32)(((x) & 0xFFFFFFFF) << 0))
-#define BIT_GET_MACID127_96_RELEASE(x)                 ((u32)(((x >> 0) & 0xFFFFFFFF)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_MACID_RELEASE_SETTING
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_MACID_VALUE                                ((u32)0x00000001 << 7)          /*!<R/W 0x0  write this field to set REG_macid_release[BIT_macid_offset] = BIT_macid_value */
-#define BIT_MASK_MACID_OFFSET                          ((u32)0x0000007F << 0)          /*!<R/W 0x0  write this field to set REG_macid_release[BIT_macid_offset] = BIT_macid_value */
-#define BIT_MACID_OFFSET(x)                            ((u32)(((x) & 0x0000007F) << 0))
-#define BIT_GET_MACID_OFFSET(x)                        ((u32)(((x >> 0) & 0x0000007F)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_FAST_EDCA_VOVI_SETTING
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_MASK_VI_FAST_EDCA_TO                       ((u32)0x000000FF << 24)          /*!<R/W 0x8  vi queue fast edca timeout value */
-#define BIT_VI_FAST_EDCA_TO(x)                         ((u32)(((x) & 0x000000FF) << 24))
-#define BIT_GET_VI_FAST_EDCA_TO(x)                     ((u32)(((x >> 24) & 0x000000FF)))
-#define BIT_VI_THRESHOLD_SEL                           ((u32)0x00000001 << 23)          /*!<R/W 0x0  1: use all vi queue pktnum compare to pktnum_threshold; 0: use single macid pktnum compare to pktnum_threshold; */
-#define BIT_MASK_VI_FAST_EDCA_PKT_TH                   ((u32)0x0000007F << 16)          /*!<R/W 0x4  vi queue fast edca pkt number threshold */
-#define BIT_VI_FAST_EDCA_PKT_TH(x)                     ((u32)(((x) & 0x0000007F) << 16))
-#define BIT_GET_VI_FAST_EDCA_PKT_TH(x)                 ((u32)(((x >> 16) & 0x0000007F)))
-#define BIT_MASK_VO_FAST_EDCA_TO                       ((u32)0x000000FF << 8)          /*!<R/W 0x8  vo queue fast edca timeout value */
-#define BIT_VO_FAST_EDCA_TO(x)                         ((u32)(((x) & 0x000000FF) << 8))
-#define BIT_GET_VO_FAST_EDCA_TO(x)                     ((u32)(((x >> 8) & 0x000000FF)))
-#define BIT_VO_THRESHOLD_SEL                           ((u32)0x00000001 << 7)          /*!<R/W 0x0  1: use all vo queue pktnum compare to pktnum_threshold; 0: use single macid pktnum compare to pktnum_threshold; */
-#define BIT_MASK_VO_FAST_EDCA_PKT_TH                   ((u32)0x0000007F << 0)          /*!<R/W 0x4  vo queue fast edca pkt number threshold */
-#define BIT_VO_FAST_EDCA_PKT_TH(x)                     ((u32)(((x) & 0x0000007F) << 0))
-#define BIT_GET_VO_FAST_EDCA_PKT_TH(x)                 ((u32)(((x >> 0) & 0x0000007F)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_FAST_EDCA_BEBK_SETTING
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_MASK_BK_FAST_EDCA_TO                       ((u32)0x000000FF << 24)          /*!<R/W 0x8  bk queue fast edca timeout value */
-#define BIT_BK_FAST_EDCA_TO(x)                         ((u32)(((x) & 0x000000FF) << 24))
-#define BIT_GET_BK_FAST_EDCA_TO(x)                     ((u32)(((x >> 24) & 0x000000FF)))
-#define BIT_BK_THRESHOLD_SEL                           ((u32)0x00000001 << 23)          /*!<R/W 0x0  1: use all bk queue pktnum compare to pktnum_threshold; 0: use single macid pktnum compare to pktnum_threshold; */
-#define BIT_MASK_BK_FAST_EDCA_PKT_TH                   ((u32)0x0000007F << 16)          /*!<R/W 0x4  bk queue fast edca pkt number threshold */
-#define BIT_BK_FAST_EDCA_PKT_TH(x)                     ((u32)(((x) & 0x0000007F) << 16))
-#define BIT_GET_BK_FAST_EDCA_PKT_TH(x)                 ((u32)(((x >> 16) & 0x0000007F)))
-#define BIT_MASK_BE_FAST_EDCA_TO                       ((u32)0x000000FF << 8)          /*!<R/W 0x8  be queue fast edca timeout value */
-#define BIT_BE_FAST_EDCA_TO(x)                         ((u32)(((x) & 0x000000FF) << 8))
-#define BIT_GET_BE_FAST_EDCA_TO(x)                     ((u32)(((x >> 8) & 0x000000FF)))
-#define BIT_BE_THRESHOLD_SEL                           ((u32)0x00000001 << 7)          /*!<R/W 0x0  1: use all be queue pktnum compare to pktnum_threshold; 0: use single macid pktnum compare to pktnum_threshold; */
-#define BIT_MASK_BE_FAST_EDCA_PKT_TH                   ((u32)0x0000007F << 0)          /*!<R/W 0x4  be queue fast edca pkt number threshold */
-#define BIT_BE_FAST_EDCA_PKT_TH(x)                     ((u32)(((x) & 0x0000007F) << 0))
-#define BIT_GET_BE_FAST_EDCA_PKT_TH(x)                 ((u32)(((x >> 0) & 0x0000007F)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_MACID_DROP0
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_MASK_MACID31_0_DROP                        ((u32)0xFFFFFFFF << 0)          /*!<R/W 0x0  Macid31~Macid0 Drop (per bit controlled) */
-#define BIT_MACID31_0_DROP(x)                          ((u32)(((x) & 0xFFFFFFFF) << 0))
-#define BIT_GET_MACID31_0_DROP(x)                      ((u32)(((x >> 0) & 0xFFFFFFFF)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_MACID_DROP1
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_MASK_MACID63_32_DROP                       ((u32)0xFFFFFFFF << 0)          /*!<R/W 0x0  Macid63~Macid32 Drop (per bit controlled) */
-#define BIT_MACID63_32_DROP(x)                         ((u32)(((x) & 0xFFFFFFFF) << 0))
-#define BIT_GET_MACID63_32_DROP(x)                     ((u32)(((x >> 0) & 0xFFFFFFFF)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_MACID_DROP2
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_MASK_MACID95_64_DROP                       ((u32)0xFFFFFFFF << 0)          /*!<R/W 0x0  Macid95~Macid64 Drop (per bit controlled) */
-#define BIT_MACID95_64_DROP(x)                         ((u32)(((x) & 0xFFFFFFFF) << 0))
-#define BIT_GET_MACID95_64_DROP(x)                     ((u32)(((x >> 0) & 0xFFFFFFFF)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_MACID_DROP3
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_MASK_MACID127_96_DROP                      ((u32)0xFFFFFFFF << 0)          /*!<R/W 0x0  Macid127~Macid96 Drop (per bit controlled) */
-#define BIT_MACID127_96_DROP(x)                        ((u32)(((x) & 0xFFFFFFFF) << 0))
-#define BIT_GET_MACID127_96_DROP(x)                    ((u32)(((x >> 0) & 0xFFFFFFFF)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_r_macid_release_success_0
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_MASK_R_MACID_RELEASE_SUCCESS_0             ((u32)0xFFFFFFFF << 0)          /*!<R/W 0x0  macid0~31 */
-#define BIT_R_MACID_RELEASE_SUCCESS_0(x)               ((u32)(((x) & 0xFFFFFFFF) << 0))
-#define BIT_GET_R_MACID_RELEASE_SUCCESS_0(x)           ((u32)(((x >> 0) & 0xFFFFFFFF)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_r_macid_release_success_1
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_MASK_R_MACID_RELEASE_SUCCESS_1             ((u32)0xFFFFFFFF << 0)          /*!<R/W 0x0  macid32~63 */
-#define BIT_R_MACID_RELEASE_SUCCESS_1(x)               ((u32)(((x) & 0xFFFFFFFF) << 0))
-#define BIT_GET_R_MACID_RELEASE_SUCCESS_1(x)           ((u32)(((x >> 0) & 0xFFFFFFFF)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_r_macid_release_success_2
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_MASK_R_MACID_RELEASE_SUCCESS_2             ((u32)0xFFFFFFFF << 0)          /*!<R/W 0x0  macid64~95 */
-#define BIT_R_MACID_RELEASE_SUCCESS_2(x)               ((u32)(((x) & 0xFFFFFFFF) << 0))
-#define BIT_GET_R_MACID_RELEASE_SUCCESS_2(x)           ((u32)(((x >> 0) & 0xFFFFFFFF)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_r_macid_release_success_3
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_MASK_R_MACID_RELEASE_SUCCESS_3             ((u32)0xFFFFFFFF << 0)          /*!<R/W 0x0  macid96~127 */
-#define BIT_R_MACID_RELEASE_SUCCESS_3(x)               ((u32)(((x) & 0xFFFFFFFF) << 0))
-#define BIT_GET_R_MACID_RELEASE_SUCCESS_3(x)           ((u32)(((x >> 0) & 0xFFFFFFFF)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_MGQ_FIFO_CTRL
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_MGQ_FIFO_EN                                ((u32)0x00000001 << 31)          /*!<R/W 0x0  1: Enable MGQ FIFO Function. 0: Disable MGQ FIFO Function. */
-#define BIT_MASK_MGQ_FIFO_PG_SIZE                      ((u32)0x00000007 << 28)          /*!<R/W 0x1  The page size of MGQ FIFO PKTs. */
-#define BIT_MGQ_FIFO_PG_SIZE(x)                        ((u32)(((x) & 0x00000007) << 28))
-#define BIT_GET_MGQ_FIFO_PG_SIZE(x)                    ((u32)(((x >> 28) & 0x00000007)))
-#define BIT_MASK_MGQ_FIFO_START_PG                     ((u32)0x00000FFF << 16)          /*!<R/W 0x0  The start page of MGQ FIFO. */
-#define BIT_MGQ_FIFO_START_PG(x)                       ((u32)(((x) & 0x00000FFF) << 16))
-#define BIT_GET_MGQ_FIFO_START_PG(x)                   ((u32)(((x >> 16) & 0x00000FFF)))
-#define BIT_MASK_MGQ_FIFO_SIZE                         ((u32)0x00000003 << 14)          /*!<R/W 0x0  2'b00 : FIFO size 4 pkts. 2'b01 : FIFO size 8 pkts. 2'b1x : FIFO size 16 pkts. */
-#define BIT_MGQ_FIFO_SIZE(x)                           ((u32)(((x) & 0x00000003) << 14))
-#define BIT_GET_MGQ_FIFO_SIZE(x)                       ((u32)(((x >> 14) & 0x00000003)))
-#define BIT_MGQ_FIFO_PAUSE                             ((u32)0x00000001 << 13)          /*!<R/W 0x0  1: use all vo queue pktnum compare to pktnum_threshold; 0: use signle macid pktnum compare to pktnum_threshold; */
-#define BIT_MASK_MGQ_FIFO_RPTR                         ((u32)0x0000001F << 8)          /*!<W 0x0  The read pointer of the MGQ FIFO.(clear when disable MGQ FIFO function) */
-#define BIT_MGQ_FIFO_RPTR(x)                           ((u32)(((x) & 0x0000001F) << 8))
-#define BIT_GET_MGQ_FIFO_RPTR(x)                       ((u32)(((x >> 8) & 0x0000001F)))
-#define BIT_MGQ_FIFO_OV                                ((u32)0x00000001 << 7)          /*!<W 0x0  1: MGQ FIFO overflow. 0: NO MGQ FIFO overflow. */
-#define BIT_MGQ_FIFO_WPTR_ERR                          ((u32)0x00000001 << 6)          /*!<W 0x0  1: Error of MGQ FIFO write pointer setting. 0: No error of MGQ FIFO write pointer setting. (clear when disable MGQ FIFO function) */
-#define BIT_CPUM_LIFETIME_EN                           ((u32)0x00000001 << 5)          /*!<R/W 0x0  1: Enable Lifetime function of the MGQ FIFO pkts. 0: Disable Lifetime function of the MGQ FIFO pkts. */
-#define BIT_MASK_MGQ_FIFO_WPTR                         ((u32)0x0000001F << 0)          /*!<R/W 0x0  The write pointer of the MGQ FIFO */
-#define BIT_MGQ_FIFO_WPTR(x)                           ((u32)(((x) & 0x0000001F) << 0))
-#define BIT_GET_MGQ_FIFO_WPTR(x)                       ((u32)(((x >> 0) & 0x0000001F)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_MGQ_FIFO_RELEASE_INT
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_MASK_MGQ_FIFO_INT_FLAG                     ((u32)0x0000FFFF << 16)          /*!<W 0x0  The flag of the MGQ FIFO PKT release interrupt, write one clear. */
-#define BIT_MGQ_FIFO_INT_FLAG(x)                       ((u32)(((x) & 0x0000FFFF) << 16))
-#define BIT_GET_MGQ_FIFO_INT_FLAG(x)                   ((u32)(((x >> 16) & 0x0000FFFF)))
-#define BIT_MASK_MGQ_FIFO_INT_MASK                     ((u32)0x0000FFFF << 0)          /*!<R/W 0x0  The mask of the MGQ FIFO PKT release interrupt. */
-#define BIT_MGQ_FIFO_INT_MASK(x)                       ((u32)(((x) & 0x0000FFFF) << 0))
-#define BIT_GET_MGQ_FIFO_INT_MASK(x)                   ((u32)(((x >> 0) & 0x0000FFFF)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_MGQ_FIFO_LIFETIME_VALID
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_MASK_MGQ_FIFO_LIFETIME                     ((u32)0x0000FFFF << 16)          /*!<R/W 0x1000  MGQ FIFO packet lifetime unit: 256us */
-#define BIT_MGQ_FIFO_LIFETIME(x)                       ((u32)(((x) & 0x0000FFFF) << 16))
-#define BIT_GET_MGQ_FIFO_LIFETIME(x)                   ((u32)(((x >> 16) & 0x0000FFFF)))
-#define BIT_MASK_MGQ_FIFO_VALID_CLR_1                  ((u32)0x000000FF << 8)          /*!<R 0x0  Clear the valid map of the MGQ FIFO PKT, high [15:8] bits */
-#define BIT_MGQ_FIFO_VALID_CLR_1(x)                    ((u32)(((x) & 0x000000FF) << 8))
-#define BIT_GET_MGQ_FIFO_VALID_CLR_1(x)                ((u32)(((x >> 8) & 0x000000FF)))
-#define BIT_MASK_MGQ_FIFO_VALID_CLR_0                  ((u32)0x000000FF << 0)          /*!<R 0x0  Clear the valid map of the MGQ FIFO PKT, low [7:0] bits */
-#define BIT_MGQ_FIFO_VALID_CLR_0(x)                    ((u32)(((x) & 0x000000FF) << 0))
-#define BIT_GET_MGQ_FIFO_VALID_CLR_0(x)                ((u32)(((x >> 0) & 0x000000FF)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_r_macid_release_success_clear_offset
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_MASK_R_MACID_RELEASE_SUCCESS_CLEAR_OFFSET  ((u32)0x0000007F << 0)          /*!<R/W 0x0  HW will set 0x2460~0x246C if one packet was released successfully for a given macid. SW use this register to reset the status. */
-#define BIT_R_MACID_RELEASE_SUCCESS_CLEAR_OFFSET(x)    ((u32)(((x) & 0x0000007F) << 0))
-#define BIT_GET_R_MACID_RELEASE_SUCCESS_CLEAR_OFFSET(x) ((u32)(((x >> 0) & 0x0000007F)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_AX_RESP_RRSR
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_MASK_RRSR_CCK                              ((u32)0x0000000F << 16)          /*!<R/W 0x5  Response rate BIT[3:0] = {(msb) CCK11, …, CCK1} */
-#define BIT_RRSR_CCK(x)                                ((u32)(((x) & 0x0000000F) << 16))
-#define BIT_GET_RRSR_CCK(x)                            ((u32)(((x >> 16) & 0x0000000F)))
-#define BIT_MASK_RRSR_RATE_EN                          ((u32)0x0000000F << 8)          /*!<R/W 0x1  Enabled response rate mode BIT[2:0] = {(msb) HE rate, VHT rate, HT rate, CCK_OFDM rate} */
-#define BIT_RRSR_RATE_EN(x)                            ((u32)(((x) & 0x0000000F) << 8))
-#define BIT_GET_RRSR_RATE_EN(x)                        ((u32)(((x >> 8) & 0x0000000F)))
-#define BIT_MASK_RATE_SEL                              ((u32)0x00000007 << 0)          /*!<R/W 0x0  New ARFR (REG 0x1484) rate group selection: 0: CCK1M – OFDM18M 1: OFDM24MRSVDOFDM54 , other no use 2: HT MCS0~MCS7 3: HT others, not use 4: VHT1SS/ MCS0~MCS7 5: VHT1SS/ MCS8~MCS9,other no use 6: HE 1SS / MCS0~MCS7 7: HE 1SS / MCS8~MCS9 ,other no use */
-#define BIT_RATE_SEL(x)                                ((u32)(((x) & 0x00000007) << 0))
-#define BIT_GET_RATE_SEL(x)                            ((u32)(((x >> 0) & 0x00000007)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_AX_ARFR_WEIGHTING_TABLE
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_MASK_RATE7_WEIGHTING                       ((u32)0x0000000F << 28)          /*!<R/W 0x3  Weighting value of the corresponding data rate with respect to rate_sel in reg 0x1480[2:0] 0: disable fallback to the rate 1~15: valid weighting value default is OFDM18M */
-#define BIT_RATE7_WEIGHTING(x)                         ((u32)(((x) & 0x0000000F) << 28))
-#define BIT_GET_RATE7_WEIGHTING(x)                     ((u32)(((x >> 28) & 0x0000000F)))
-#define BIT_MASK_RATE6_WEIGHTING                       ((u32)0x0000000F << 24)          /*!<R/W 0x2  Weighting value of the corresponding data rate with respect to rate_sel in reg 0x1480[2:0] 0: disable fallback to the rate 1~15: valid weighting value default is OFDM12M */
-#define BIT_RATE6_WEIGHTING(x)                         ((u32)(((x) & 0x0000000F) << 24))
-#define BIT_GET_RATE6_WEIGHTING(x)                     ((u32)(((x >> 24) & 0x0000000F)))
-#define BIT_MASK_RATE5_WEIGHTING                       ((u32)0x0000000F << 20)          /*!<R/W 0x1  Weighting value of the corresponding data rate with respect to rate_sel in reg 0x1480[2:0] 0: disable fallback to the rate 1~15: valid weighting value default is OFDM9M */
-#define BIT_RATE5_WEIGHTING(x)                         ((u32)(((x) & 0x0000000F) << 20))
-#define BIT_GET_RATE5_WEIGHTING(x)                     ((u32)(((x >> 20) & 0x0000000F)))
-#define BIT_MASK_RATE4_WEIGHTING                       ((u32)0x0000000F << 16)          /*!<R/W 0x1  Weighting value of the corresponding data rate with respect to rate_sel in reg 0x1480[2:0] 0: disable fallback to the rate 1~15: valid weighting value default is OFDM6M */
-#define BIT_RATE4_WEIGHTING(x)                         ((u32)(((x) & 0x0000000F) << 16))
-#define BIT_GET_RATE4_WEIGHTING(x)                     ((u32)(((x >> 16) & 0x0000000F)))
-#define BIT_MASK_RATE3_WEIGHTING                       ((u32)0x0000000F << 12)          /*!<R/W 0x2  Weighting value of the corresponding data rate with respect to rate_sel in reg 0x1480[2:0] 0: disable fallback to the rate 1~15: valid weighting value default is CCK11M */
-#define BIT_RATE3_WEIGHTING(x)                         ((u32)(((x) & 0x0000000F) << 12))
-#define BIT_GET_RATE3_WEIGHTING(x)                     ((u32)(((x >> 12) & 0x0000000F)))
-#define BIT_MASK_RATE2_WEIGHTING                       ((u32)0x0000000F << 8)          /*!<R/W 0x1  Weighting value of the corresponding data rate with respect to rate_sel in reg 0x1480[2:0] 0: disable fallback to the rate 1~15: valid weighting value default is CCK5_5M */
-#define BIT_RATE2_WEIGHTING(x)                         ((u32)(((x) & 0x0000000F) << 8))
-#define BIT_GET_RATE2_WEIGHTING(x)                     ((u32)(((x >> 8) & 0x0000000F)))
-#define BIT_MASK_RATE1_WEIGHTING                       ((u32)0x0000000F << 4)          /*!<R/W 0x1  Weighting value of the corresponding data rate with respect to rate_sel in reg 0x1480[2:0] 0: disable fallback to the rate 1~15: valid weighting value default is CCK2M */
-#define BIT_RATE1_WEIGHTING(x)                         ((u32)(((x) & 0x0000000F) << 4))
-#define BIT_GET_RATE1_WEIGHTING(x)                     ((u32)(((x >> 4) & 0x0000000F)))
-#define BIT_MASK_RATE0_WEIGHTING                       ((u32)0x0000000F << 0)          /*!<R/W 0x1  Weighting value of the corresponding data rate with respect to rate_sel in reg 0x1480[2:0] 0: disable fallback to the rate 1~15: valid weighting value default is CCK1M */
-#define BIT_RATE0_WEIGHTING(x)                         ((u32)(((x) & 0x0000000F) << 0))
-#define BIT_GET_RATE0_WEIGHTING(x)                     ((u32)(((x >> 0) & 0x0000000F)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_DARFRC1_L
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_MASK_DATA_FALLBACK1_RC4                    ((u32)0x0000001F << 24)          /*!<R/W 0x04  Data Auto Rate Fallback Retry Count After the number of retry, HW will fall back the rate to the next enabled MAC in ARFR. */
-#define BIT_DATA_FALLBACK1_RC4(x)                      ((u32)(((x) & 0x0000001F) << 24))
-#define BIT_GET_DATA_FALLBACK1_RC4(x)                  ((u32)(((x >> 24) & 0x0000001F)))
-#define BIT_MASK_DATA_FALLBACK1_RC3                    ((u32)0x0000001F << 16)          /*!<R/W 0x03  Data Auto Rate Fallback Retry Count After the number of retry, HW will fall back the rate to the next enabled MAC in ARFR. */
-#define BIT_DATA_FALLBACK1_RC3(x)                      ((u32)(((x) & 0x0000001F) << 16))
-#define BIT_GET_DATA_FALLBACK1_RC3(x)                  ((u32)(((x >> 16) & 0x0000001F)))
-#define BIT_MASK_DATA_FALLBACK1_RC2                    ((u32)0x0000001F << 8)          /*!<R/W 0x02  Data Auto Rate Fallback Retry Count After the number of retry, HW will fall back the rate to the next enabled MAC in ARFR. */
-#define BIT_DATA_FALLBACK1_RC2(x)                      ((u32)(((x) & 0x0000001F) << 8))
-#define BIT_GET_DATA_FALLBACK1_RC2(x)                  ((u32)(((x >> 8) & 0x0000001F)))
-#define BIT_MASK_DATA_FALLBACK1_RC1                    ((u32)0x0000001F << 0)          /*!<R/W 0x01  Data Auto Rate Fallback Retry Count After the number of retry, HW will fall back the rate to the next enabled MAC in ARFR. */
-#define BIT_DATA_FALLBACK1_RC1(x)                      ((u32)(((x) & 0x0000001F) << 0))
-#define BIT_GET_DATA_FALLBACK1_RC1(x)                  ((u32)(((x >> 0) & 0x0000001F)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_DARFRC1_H
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_MASK_DATA_FALLBACK1_RC8                    ((u32)0x0000001F << 24)          /*!<R/W 0x08  Data Auto Rate Fallback Retry Count After the number of retry, HW will fall back the rate to the next enabled MAC in ARFR. */
-#define BIT_DATA_FALLBACK1_RC8(x)                      ((u32)(((x) & 0x0000001F) << 24))
-#define BIT_GET_DATA_FALLBACK1_RC8(x)                  ((u32)(((x >> 24) & 0x0000001F)))
-#define BIT_MASK_DATA_FALLBACK1_RC7                    ((u32)0x0000001F << 16)          /*!<R/W 0x07  Data Auto Rate Fallback Retry Count After the number of retry, HW will fall back the rate to the next enabled MAC in ARFR. */
-#define BIT_DATA_FALLBACK1_RC7(x)                      ((u32)(((x) & 0x0000001F) << 16))
-#define BIT_GET_DATA_FALLBACK1_RC7(x)                  ((u32)(((x >> 16) & 0x0000001F)))
-#define BIT_MASK_DATA_FALLBACK1_RC6                    ((u32)0x0000001F << 8)          /*!<R/W 0x06  Data Auto Rate Fallback Retry Count After the number of retry, HW will fall back the rate to the next enabled MAC in ARFR. */
-#define BIT_DATA_FALLBACK1_RC6(x)                      ((u32)(((x) & 0x0000001F) << 8))
-#define BIT_GET_DATA_FALLBACK1_RC6(x)                  ((u32)(((x >> 8) & 0x0000001F)))
-#define BIT_MASK_DATA_FALLBACK1_RC5                    ((u32)0x0000001F << 0)          /*!<R/W 0x05  Data Auto Rate Fallback Retry Count After the number of retry, HW will fall back the rate to the next enabled MAC in ARFR. */
-#define BIT_DATA_FALLBACK1_RC5(x)                      ((u32)(((x) & 0x0000001F) << 0))
-#define BIT_GET_DATA_FALLBACK1_RC5(x)                  ((u32)(((x >> 0) & 0x0000001F)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_TB_CTRL
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_EN_TB_TXRPT                                ((u32)0x00000001 << 24)          /*!<R/W 0x1  When this bit is set, enable generate report for TB PPDU */
-#define BIT_DIS_CHK_TB_AC                              ((u32)0x00000001 << 23)          /*!<R/W 0x1  When this bit is set, don't care the AC of DATA */
-#define BIT_EN_TB_PRETX                                ((u32)0x00000001 << 22)          /*!<R/W 0x1  When this bit is set, enable pretx function of TB PPDU, assert txen before gen_cmd_rdy. */
-#define BIT_EN_UPD_TB_RETRY                            ((u32)0x00000001 << 21)          /*!<R/W 0x1  enable write retrybit in MH and add retrycnt when TB PPDU TX fail. */
-#define BIT_EN_TB_SIFS_BK                              ((u32)0x00000001 << 20)          /*!<R/W 0x1  If sifs_timeout_tb_ref (from trxptcl) asserted, break the aggr process of TB PPDU */
-#define BIT_HW_SSN_EN_TB                               ((u32)0x00000001 << 19)          /*!<R/W 0x0  HW update the SSN [9] for TB PPDU */
-#define BIT_TB_BYPASS_TXPOWER                          ((u32)0x00000001 << 18)          /*!<R/W 0x0  1: NOT abort TB PPDU even the txpwr_abort_tx_idx(from txpwr_ctrl) is illegal 0: enable tx power abort TB */
-#define BIT_TB_DEL_EN                                  ((u32)0x00000001 << 17)          /*!<R/W 0x0  Enable TB PPDU packet delete: 1) pkt_ageout; 2) macid_delete */
-#define BIT_TB_EN_LIFETIME                             ((u32)0x00000001 << 16)          /*!<R/W 0x0  When this bit is set, enable the lifetime function of TB PPDU. */
-#define BIT_MASK_TB_PKT_LIFE_TIME                      ((u32)0x0000FFFF << 0)          /*!<R/W 0x0  LIFETIME Threshold: Unit = 256us. When TB PPDU is triggered, If BIT_TB_EN_LIFETIME = 1, count down. If BIT_TB_EN_LIFETIME = 0, do nothing. */
-#define BIT_TB_PKT_LIFE_TIME(x)                        ((u32)(((x) & 0x0000FFFF) << 0))
-#define BIT_GET_TB_PKT_LIFE_TIME(x)                    ((u32)(((x >> 0) & 0x0000FFFF)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_OTHER_CFG
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_GI_LTF_FB_SEL                              ((u32)0x00000001 << 31)          /*!<R/W 0x0  0: no GI_LTF fallback 1: GI_LTF fallback option 1 enabled (downgrade GI_LTF first from init. rate) Others RSVD */
-#define BIT_MASK_NDPA_RATE                             ((u32)0x000001FF << 22)          /*!<R/W 0x04  NDPA tx rate setting, from CCK 1M to VHT NSS2 MCS9 */
-#define BIT_NDPA_RATE(x)                               ((u32)(((x) & 0x000001FF) << 22))
-#define BIT_GET_NDPA_RATE(x)                           ((u32)(((x >> 22) & 0x000001FF)))
-#define BIT_EN_A_CTRL_BREAK                            ((u32)0x00000001 << 21)          /*!<R/W 0x1  1: break the AGGR process when the a_ctrl field in TXDESC is different */
-#define BIT_MASK_RTS_TXOP_THRS                         ((u32)0x000003FF << 3)          /*!<R/W 0x0  unit:32us, valid when BIT_EN_TXOP_BASE_RTS = 1 */
-#define BIT_RTS_TXOP_THRS(x)                           ((u32)(((x) & 0x000003FF) << 3))
-#define BIT_GET_RTS_TXOP_THRS(x)                       ((u32)(((x >> 3) & 0x000003FF)))
-#define BIT_EN_TXOP_BASE_RTS                           ((u32)0x00000001 << 2)          /*!<R/W 0x0  enable TXOP duration-based RTS/CTS */
-#define BIT_EN_BT_POLLUTE_RX                           ((u32)0x00000001 << 1)          /*!<R/W 0x1  enable write BT Polluted field during RX RESP */
-#define BIT_EN_SR_CTS2S                                ((u32)0x00000001 << 0)          /*!<R/W 0x0  enable send cts2s frame during SR */
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_RRSR_RATE_CFG
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_MASK_RRSR_HE                               ((u32)0x000000FF << 24)          /*!<R/W 0x0  Response rate BIT[35:28]={(msb) HE MCS7, MCS6, …, MCS0} */
-#define BIT_RRSR_HE(x)                                 ((u32)(((x) & 0x000000FF) << 24))
-#define BIT_GET_RRSR_HE(x)                             ((u32)(((x >> 24) & 0x000000FF)))
-#define BIT_MASK_RRSR_VHT                              ((u32)0x000000FF << 16)          /*!<R/W 0x0  Response rate BIT[27:20] = { (msb) VHT MCS7, MCS6, …, MCS0} */
-#define BIT_RRSR_VHT(x)                                ((u32)(((x) & 0x000000FF) << 16))
-#define BIT_GET_RRSR_VHT(x)                            ((u32)(((x >> 16) & 0x000000FF)))
-#define BIT_MASK_RRSR_HT                               ((u32)0x000000FF << 8)          /*!<R/W 0x0  Response rate BIT[19:12]={(msb) HT MCS7, MCS6, …, MCS0} */
-#define BIT_RRSR_HT(x)                                 ((u32)(((x) & 0x000000FF) << 8))
-#define BIT_GET_RRSR_HT(x)                             ((u32)(((x >> 8) & 0x000000FF)))
-#define BIT_MASK_RRSR_OFDM                             ((u32)0x000000FF << 0)          /*!<R/W 0x15  Response rate BIT[11:4] = { (msb) OFDM54, OFDM48, …,OFDM6} */
-#define BIT_RRSR_OFDM(x)                               ((u32)(((x) & 0x000000FF) << 0))
-#define BIT_GET_RRSR_OFDM(x)                           ((u32)(((x >> 0) & 0x000000FF)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_NDP_RATE
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_MASK_TXPKT_CNT_SEL                         ((u32)0x0000000F << 28)          /*!<R/W 0x0  Select the counter to show in 0X14A0 BIT_TXPKT_CNT_RPT. 0: r_TX_OK_RTY0 1: r_TX_OK_RTY1 2: r_TX_OK_RTY2 3: r_TX_OK_RTY3 4: r_TX_OK_RTY4 5: r_RTY_DROP 6: r_LT_DROP 7: r_BMC_TXOK 8: r_TOTAL_PKT_CNT 9: r_RTS_DROP 10: r_RTS_OK */
-#define BIT_TXPKT_CNT_SEL(x)                           ((u32)(((x) & 0x0000000F) << 28))
-#define BIT_GET_TXPKT_CNT_SEL(x)                       ((u32)(((x >> 28) & 0x0000000F)))
-#define BIT_MASK_REF_MACID                             ((u32)0x0000000F << 24)          /*!<R/W 0xF  if BIT_REF_MACID = 0xF, count all eligible frames and ignore MACID; else, only count the frames whose MACID = BIT_REF_MACID BMC packet ignore MACID. */
-#define BIT_REF_MACID(x)                               ((u32)(((x) & 0x0000000F) << 24))
-#define BIT_GET_REF_MACID(x)                           ((u32)(((x >> 24) & 0x0000000F)))
-#define BIT_TX_CNT_CLR                                 ((u32)0x00000001 << 23)          /*!<R/W 0x0  Write 1 to clear the counters. */
-#define BIT_USE_NDP_PARAMETER                          ((u32)0x00000001 << 9)          /*!<R/W 0x1  1: select NDP rate from CR 0X149C[8:0] */
-#define BIT_MASK_NDP_RATE                              ((u32)0x000001FF << 0)          /*!<R/W 0x04  NDPA tx rate setting, from CCK 1M to VHT NSS2 MCS9 */
-#define BIT_NDP_RATE(x)                                ((u32)(((x) & 0x000001FF) << 0))
-#define BIT_GET_NDP_RATE(x)                            ((u32)(((x >> 0) & 0x000001FF)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_TXPKT_CNT
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_MASK_TXPKT_CNT_RPT                         ((u32)0xFFFFFFFF << 0)          /*!<RO 0x0  The results of TXPKT counter. Depends on BIT_TXPKT_CNT_SEL. */
-#define BIT_TXPKT_CNT_RPT(x)                           ((u32)(((x) & 0xFFFFFFFF) << 0))
-#define BIT_GET_TXPKT_CNT_RPT(x)                       ((u32)(((x >> 0) & 0xFFFFFFFF)))
-/** @} */
-
-
-/*==========PAGE4 Register Address Definition==========*/
-#define REG_Q0_INFO                                  0x0400
-#define REG_Q1_INFO                                  0x0404
-#define REG_Q2_INFO                                  0x0408
-#define REG_Q3_INFO                                  0x040C
-#define REG_MGQ_INFO                                 0x0410
-#define REG_HIQ_INFO                                 0x0414
-#define REG_QUE_EMPTY_BCNQ_INFO                      0x0418
-#define REG_CPU_MGQ_INFO                             0x041C
-#define REG_FWHW_TXQ_HWSSN_CTRL                      0x0420
-#define REG_BNDY_LIFETIME_TAIL                       0x0424
-#define REG_RETRY_LIMIT_SIFS                         0x0428
-#define REG_TXBF_CTRL                                0x042C
-#define REG_DARFRC0_L                                0x0430
-#define REG_DARFRC0_H                                0x0434
-#define REG_RARFRC_L                                 0x0438
-#define REG_RARFRC_H                                 0x043C
-#define REG_RRSR                                     0x0440
-#define REG_BCN_AMPDU_CTCL                           0x0454
-#define REG_AMPDU_MAX_LENGTH                         0x0458
-#define REG_NDPA_CTRL_LBK_ACQ_STOP                   0x045C
-#define REG_RD_RESP_PKT_TH                           0x0460
-#define REG_CMDQ_INFO                                0x0464
-#define REG_Q4_INFO                                  0x0468
-#define REG_Q5_INFO                                  0x046C
-#define REG_Q6_INFO                                  0x0470
-#define REG_Q7_INFO                                  0x0474
-#define REG_GCLK_CFG                                 0x0478
-#define REG_TXRPT_CTRL                               0x047C
-#define REG_CFEND_RATE_SC_CTRL                       0x0480
-#define REG_MACID_SLEEP3                             0x0484
-#define REG_MACID_SLEEP1                             0x0488
-#define REG_TXRPT_START_OFFSET                       0x04AC
-#define REG_PTA_WL_PRI_MASK                          0x04B4
-#define REG_EVTQ_RPT                                 0x04B8
-#define REG_SW_AMPDU_BURST_MODE_CTRL                 0x04BC
-#define REG_PKT_LIFE_TIME                            0x04C0
-#define REG_PTA_STBC_CTRL                            0x04C4
-#define REG_PROT_MODE_CTRL                           0x04C8
-#define REG_BAR_MODE_CTRL                            0x04CC
-#define REG_MACID_SLEEP2                             0x04D0
-#define REG_MACID_SLEEP                              0x04D4
-#define REG_HW_SEQ0_1                                0x04D8
-#define REG_HW_SEQ2_3                                0x04DC
-#define REG_PTCLERR_NULLPKT_STATUS                   0x04E0
-#define REG_PRETX_DROP_CTRL                          0x04E4
-#define REG_BT_POLLUTE_PKT_CNT                       0x04E8
-#define REG_DROP_PKT_NUM                             0x04EC
-#define REG_CPUMGQ_TIMER_CTRL                        0x04F4
-#define REG_DUMMY                                    0x04FC
-#define REG_AESIV_SETTING                            0x1424
-#define REG_BF0_TIME_SETTING                         0x1428
-#define REG_BF1_TIME_SETTING                         0x142C
-#define REG_BF_TIMEOUT_EN                            0x1430
-#define REG_MACID_RELEASE0                           0x1434
-#define REG_MACID_RELEASE1                           0x1438
-#define REG_MACID_RELEASE2                           0x143C
-#define REG_MACID_RELEASE3                           0x1440
-#define REG_MACID_RELEASE_SETTING                    0x1444
-#define REG_FAST_EDCA_VOVI_SETTING                   0x1448
-#define REG_FAST_EDCA_BEBK_SETTING                   0x144C
-#define REG_MACID_DROP0                              0x1450
-#define REG_MACID_DROP1                              0x1454
-#define REG_MACID_DROP2                              0x1458
-#define REG_MACID_DROP3                              0x145C
-#define REG_R_MACID_RELEASE_SUCCESS_0                0x1460
-#define REG_R_MACID_RELEASE_SUCCESS_1                0x1464
-#define REG_R_MACID_RELEASE_SUCCESS_2                0x1468
-#define REG_R_MACID_RELEASE_SUCCESS_3                0x146C
-#define REG_MGQ_FIFO_CTRL                            0x1470
-#define REG_MGQ_FIFO_RELEASE_INT                     0x1474
-#define REG_MGQ_FIFO_LIFETIME_VALID                  0x1478
-#define REG_R_MACID_RELEASE_SUCCESS_CLEAR_OFFSET     0x147C
-#define REG_AX_RESP_RRSR                             0x1480
-#define REG_AX_ARFR_WEIGHTING_TABLE                  0x1484
-#define REG_DARFRC1_L                                0x1488
-#define REG_DARFRC1_H                                0x148C
-#define REG_TB_CTRL                                  0x1490
-#define REG_OTHER_CFG                                0x1494
-#define REG_RRSR_RATE_CFG                            0x1498
-#define REG_NDP_RATE                                 0x149C
-#define REG_TXPKT_CNT                                0x14A0
-
-/* AUTO_GEN_END */
-
-/* MANUAL_GEN_START */
-
-//Please add your defination here
-
-/* MANUAL_GEN_END */
-
-#endif
diff --git a/os/board/rtl8720e/src/component/wifi/wifi_fw/amebalite/include/wififw_reg_page5.h b/os/board/rtl8720e/src/component/wifi/wifi_fw/amebalite/include/wififw_reg_page5.h
deleted file mode 100644
index 772045902..000000000
--- a/os/board/rtl8720e/src/component/wifi/wifi_fw/amebalite/include/wififw_reg_page5.h
+++ /dev/null
@@ -1,1630 +0,0 @@
-#ifndef __WIFIFW_REG_PAGE5_H__
-#define __WIFIFW_REG_PAGE5_H__
-
-/**************************************************************************//**
- * @defgroup REG_EDCA_VO_PARAM
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_MASK_TXOPLIMIT_VO                    ((u32)0x000007FF << 16)          /*!<R/W 0x2f  TXOP Limit An unsigned integer in units of 32 microseconds. Value of zero indicates that a single MSDU or MMPDU in addition to a protection frame exchange can be transmitted at any rate. Default: BK = 0h; BE = 0h; VI = 5Eh; VO = 2Fh. */
-#define BIT_TXOPLIMIT_VO(x)                      ((u32)(((x) & 0x000007FF) << 16))
-#define BIT_GET_TXOPLIMIT_VO(x)                  ((u32)(((x >> 16) & 0x000007FF)))
-#define BIT_MASK_CW_VO                           ((u32)0x000000FF << 8)          /*!<R/W 0x32  ECWmin and ECWmax encode the values of Cwmin and Cwmax respectively in an exponent form. Ex: Cwmax = 2^(ECWmax)-1 Default: BK = Ah/5h; BE = Ah/5h; VI = 5h/4h; VO = 4h/3h. */
-#define BIT_CW_VO(x)                             ((u32)(((x) & 0x000000FF) << 8))
-#define BIT_GET_CW_VO(x)                         ((u32)(((x >> 8) & 0x000000FF)))
-#define BIT_MASK_AIFS_VO                         ((u32)0x000000FF << 0)          /*!<R/W 0x24  Arbitrary Inter frame space In unit of microsecond. AIFS indicates the time a non-AP QSTA should defer before either invoking a backoff or starting a transmission Default: BK = 49h; BE = 25h; VI = 1Ch; VO = 1Ch. */
-#define BIT_AIFS_VO(x)                           ((u32)(((x) & 0x000000FF) << 0))
-#define BIT_GET_AIFS_VO(x)                       ((u32)(((x >> 0) & 0x000000FF)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_EDCA_VI_PARAM
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_MASK_TXOPLIMIT_VI                    ((u32)0x000007FF << 16)          /*!<R/W 0x5e  TXOP Limit An unsigned integer in units of 32 microseconds. Value of zero indicates that a single MSDU or MMPDU in addition to a protection frame exchange can be transmitted at any rate. Default: BK = 0h; BE = 0h; VI = 5Eh; VO = 2Fh. */
-#define BIT_TXOPLIMIT_VI(x)                      ((u32)(((x) & 0x000007FF) << 16))
-#define BIT_GET_TXOPLIMIT_VI(x)                  ((u32)(((x >> 16) & 0x000007FF)))
-#define BIT_MASK_CW_VI                           ((u32)0x000000FF << 8)          /*!<R/W 0x43  ECWmin and ECWmax encode the values of Cwmin and Cwmax respectively in an exponent form. Ex: Cwmax = 2^(ECWmax)-1 Default: BK = Ah/5h; BE = Ah/5h; VI = 5h/4h; VO = 4h/3h. */
-#define BIT_CW_VI(x)                             ((u32)(((x) & 0x000000FF) << 8))
-#define BIT_GET_CW_VI(x)                         ((u32)(((x >> 8) & 0x000000FF)))
-#define BIT_MASK_AIFS_VI                         ((u32)0x000000FF << 0)          /*!<R/W 0x26  Arbitrary Inter frame space In unit of microsecond. AIFS indicates the time a non-AP QSTA should defer before either invoking a backoff or starting a transmission Default: BK = 49h; BE = 25h; VI = 1Ch; VO = 1Ch. */
-#define BIT_AIFS_VI(x)                           ((u32)(((x) & 0x000000FF) << 0))
-#define BIT_GET_AIFS_VI(x)                       ((u32)(((x >> 0) & 0x000000FF)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_EDCA_BE_PARAM
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_MASK_TXOPLIMIT_BE                    ((u32)0x000007FF << 16)          /*!<R/W 0x00  TXOP Limit An unsigned integer in units of 32 microseconds. Value of zero indicates that a single MSDU or MMPDU in addition to a protection frame exchange can be transmitted at any rate. Default: BK = 0h; BE = 0h; VI = 5Eh; VO = 2Fh. */
-#define BIT_TXOPLIMIT_BE(x)                      ((u32)(((x) & 0x000007FF) << 16))
-#define BIT_GET_TXOPLIMIT_BE(x)                  ((u32)(((x >> 16) & 0x000007FF)))
-#define BIT_MASK_CW_BE                           ((u32)0x000000FF << 8)          /*!<R/W 0xa4  ECWmin and ECWmax encode the values of Cwmin and Cwmax respectively in an exponent form. Ex: Cwmax = 2^(ECWmax)-1 Default: BK = Ah/5h; BE = Ah/5h; VI = 5h/4h; VO = 4h/3h. */
-#define BIT_CW_BE(x)                             ((u32)(((x) & 0x000000FF) << 8))
-#define BIT_GET_CW_BE(x)                         ((u32)(((x >> 8) & 0x000000FF)))
-#define BIT_MASK_AIFS_BE                         ((u32)0x000000FF << 0)          /*!<R/W 0x2b  Arbitrary Inter frame space In unit of microsecond. AIFS indicates the time a non-AP QSTA should defer before either invoking a backoff or starting a transmission Default: BK = 49h; BE = 25h; VI = 1Ch; VO = 1Ch. */
-#define BIT_AIFS_BE(x)                           ((u32)(((x) & 0x000000FF) << 0))
-#define BIT_GET_AIFS_BE(x)                       ((u32)(((x >> 0) & 0x000000FF)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_EDCA_BK_PARAM
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_MASK_TXOPLIMIT_BK                    ((u32)0x000007FF << 16)          /*!<R/W 0x00  TXOP Limit An unsigned integer in units of 32 microseconds. Value of zero indicates that a single MSDU or MMPDU in addition to a protection frame exchange can be transmitted at any rate. Default: BK = 0h; BE = 0h; VI = 5Eh; VO = 2Fh. */
-#define BIT_TXOPLIMIT_BK(x)                      ((u32)(((x) & 0x000007FF) << 16))
-#define BIT_GET_TXOPLIMIT_BK(x)                  ((u32)(((x >> 16) & 0x000007FF)))
-#define BIT_MASK_CW_BK                           ((u32)0x000000FF << 8)          /*!<R/W 0xa5  ECWmin and ECWmax encode the values of Cwmin and Cwmax respectively in an exponent form. Ex: Cwmax = 2^(ECWmax)-1 Default: BK = Ah/5h; BE = Ah/5h; VI = 5h/4h; VO = 4h/3h. */
-#define BIT_CW_BK(x)                             ((u32)(((x) & 0x000000FF) << 8))
-#define BIT_GET_CW_BK(x)                         ((u32)(((x >> 8) & 0x000000FF)))
-#define BIT_MASK_AIFS_BK                         ((u32)0x000000FF << 0)          /*!<R/W 0x49  Arbitrary Inter frame space In unit of microsecond. AIFS indicates the time a non-AP QSTA should defer before either invoking a backoff or starting a transmission Default: BK = 49h; BE = 25h; VI = 1Ch; VO = 1Ch. */
-#define BIT_AIFS_BK(x)                           ((u32)(((x) & 0x000000FF) << 0))
-#define BIT_GET_AIFS_BK(x)                       ((u32)(((x >> 0) & 0x000000FF)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_BCN_CFG_PIFS
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_MASK_RDG_PIFS                        ((u32)0x000000FF << 24)          /*!<R/W 0x28  PIFS time. It is only used in RDG mode and in units of us. */
-#define BIT_RDG_PIFS(x)                          ((u32)(((x) & 0x000000FF) << 24))
-#define BIT_GET_RDG_PIFS(x)                      ((u32)(((x >> 24) & 0x000000FF)))
-#define BIT_MASK_PIFS                            ((u32)0x000000FF << 16)          /*!<R/W 0x1c  PIFS time. It is only used in AP mode and in units of us. */
-#define BIT_PIFS(x)                              ((u32)(((x) & 0x000000FF) << 16))
-#define BIT_GET_PIFS(x)                          ((u32)(((x >> 16) & 0x000000FF)))
-#define BIT_MASK_BCNCW_MAX                       ((u32)0x0000000F << 12)          /*!<R/W 0x4  Beacon Contention Window MAX Defines the contention window value for back off before transmitting beacon frame. This field is set to 0 in AP mode to indicate no back off window. In ad hoc mode, its default value is 6. 26-1 = 63 time slots. */
-#define BIT_BCNCW_MAX(x)                         ((u32)(((x) & 0x0000000F) << 12))
-#define BIT_GET_BCNCW_MAX(x)                     ((u32)(((x >> 12) & 0x0000000F)))
-#define BIT_MASK_BCNCW_MIN                       ((u32)0x0000000F << 8)          /*!<R/W 0x4  Beacon Contention Window Defines the contention window value for back off before transmitting beacon frame. This field is set to 0 in AP mode to indicate no back off window. In ad hoc mode, its default value is 6. 26-1 = 63 time slots. */
-#define BIT_BCNCW_MIN(x)                         ((u32)(((x) & 0x0000000F) << 8))
-#define BIT_GET_BCNCW_MIN(x)                     ((u32)(((x >> 8) & 0x0000000F)))
-#define BIT_MASK_BCNIFS                          ((u32)0x000000FF << 0)          /*!<R/W 0x13  Beacon Interframe Space In units of microseconds, this register defines the medium idle time required before transmitting beacon (AP mode) or entering random back off window. */
-#define BIT_BCNIFS(x)                            ((u32)(((x) & 0x000000FF) << 0))
-#define BIT_GET_BCNIFS(x)                        ((u32)(((x >> 0) & 0x000000FF)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_SIFS
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_MASK_SIFS_OFDM_TRX                   ((u32)0x000000FF << 24)          /*!<R/W 0xE  This register sets the SIFS time required in NAV protection period after receiving any immediate response. for example Ack-Data or RTS/CTS-Data. It is in unit of us. */
-#define BIT_SIFS_OFDM_TRX(x)                     ((u32)(((x) & 0x000000FF) << 24))
-#define BIT_GET_SIFS_OFDM_TRX(x)                 ((u32)(((x >> 24) & 0x000000FF)))
-#define BIT_MASK_SIFS_CCK_TRX                    ((u32)0x000000FF << 16)          /*!<R/W 0xA  This register sets the SIFS time required in NAV protection period after receiving any immediate response. for example Ack-Data or RTS/CTS-Data. It is in unit of us. */
-#define BIT_SIFS_CCK_TRX(x)                      ((u32)(((x) & 0x000000FF) << 16))
-#define BIT_GET_SIFS_CCK_TRX(x)                  ((u32)(((x >> 16) & 0x000000FF)))
-#define BIT_MASK_SIFS_OFDM_CTX                   ((u32)0x000000FF << 8)          /*!<R/W 0xE  This register sets the SIFS time required for consecutive TX events for example CTS2S-Data, or broadcast bursting. It is in unit of us. */
-#define BIT_SIFS_OFDM_CTX(x)                     ((u32)(((x) & 0x000000FF) << 8))
-#define BIT_GET_SIFS_OFDM_CTX(x)                 ((u32)(((x >> 8) & 0x000000FF)))
-#define BIT_MASK_SIFS_CCK_CTX                    ((u32)0x000000FF << 0)          /*!<R/W 0xA  This register sets the SIFS time required for consecutive TX events for example CTS2S-Data, or broadcast bursting. It is in unit of us. */
-#define BIT_SIFS_CCK_CTX(x)                      ((u32)(((x) & 0x000000FF) << 0))
-#define BIT_GET_SIFS_CCK_CTX(x)                  ((u32)(((x >> 0) & 0x000000FF)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_TSFT_SYN_OFFSET_SLOT
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_MASK_SLOTTIME                        ((u32)0x000000FF << 24)          /*!<R/W 0x09  This register sets the slot time value mentioned in 802.11 specification. It is in units of us. Default: 0x9 */
-#define BIT_SLOTTIME(x)                          ((u32)(((x) & 0x000000FF) << 24))
-#define BIT_GET_SLOTTIME(x)                      ((u32)(((x >> 24) & 0x000000FF)))
-#define BIT_MASK_AGGR_BK_TIME                    ((u32)0x000000FF << 16)          /*!<R/W 0x14  Hw will break aggr. In sifs condition */
-#define BIT_AGGR_BK_TIME(x)                      ((u32)(((x) & 0x000000FF) << 16))
-#define BIT_GET_AGGR_BK_TIME(x)                  ((u32)(((x >> 16) & 0x000000FF)))
-#define BIT_MASK_TSFTR_SYNC_OFFSET               ((u32)0x0000FFFF << 0)          /*!<R/W 0x640  tsft sync. Offset (bcn0 sync to bcn1 offset or bcn1 sync to bcn0 offset). Unit : 32us, default is 50ms */
-#define BIT_TSFTR_SYNC_OFFSET(x)                 ((u32)(((x) & 0x0000FFFF) << 0))
-#define BIT_GET_TSFTR_SYNC_OFFSET(x)             ((u32)(((x >> 0) & 0x0000FFFF)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_PS_NOA_ERLY_TIME
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_MASK_NOA_OFF_ERLY_TIME               ((u32)0x000000FF << 8)          /*!<R/W 0x5  NOA off early interval, Time unit is TU. */
-#define BIT_NOA_OFF_ERLY_TIME(x)                 ((u32)(((x) & 0x000000FF) << 8))
-#define BIT_GET_NOA_OFF_ERLY_TIME(x)             ((u32)(((x >> 8) & 0x000000FF)))
-#define BIT_MASK_NOA_ON_ERLY_TIME                ((u32)0x000000FF << 0)          /*!<R/W 0x0  not valid. NOA on early interval, Time unit is TU. PS: This function has some issue, so it's value must be 0 */
-#define BIT_NOA_ON_ERLY_TIME(x)                  ((u32)(((x) & 0x000000FF) << 0))
-#define BIT_GET_NOA_ON_ERLY_TIME(x)              ((u32)(((x >> 0) & 0x000000FF)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_TXPAUSE_TXPTCL_DISTXREQ_CTRL
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_DIS_BT_CCA                           ((u32)0x00000001 << 31)          /*!<R/W 0x0  Disable BT_CCA. (NOT USED, SEE 0x1594) */
-#define BIT_DIS_TXREQ_CLR_CPUMGQ                 ((u32)0x00000001 << 30)          /*!<R/W 0x0  1: if this queue can’t own channel ,txcmd will be cleared 0:Only TX_finish can clear txreq */
-#define BIT_DIS_TXREQ_CLR_HI                     ((u32)0x00000001 << 29)          /*!<R/W 0x0  0: if this queue can’t own channel ,txcmd will be cleared 1:Only TX_finish can clear txreq */
-#define BIT_DIS_TXREQ_CLR_MGQ                    ((u32)0x00000001 << 28)          /*!<R/W 0x0  1: if this queue can’t own channel ,txcmd will be cleared 0:Only TX_finish can clear txreq */
-#define BIT_DIS_TXREQ_CLR_BK                     ((u32)0x00000001 << 27)          /*!<R/W 0x0  0: if this queue can’t own channel ,txcmd will be cleared 1:Only TX_finish can clear txreq */
-#define BIT_DIS_TXREQ_CLR_BE                     ((u32)0x00000001 << 26)          /*!<R/W 0x0  0: if this queue can’t own channel ,txcmd will be cleared 1:Only TX_finish can clear txreq */
-#define BIT_DIS_TXREQ_CLR_VI                     ((u32)0x00000001 << 25)          /*!<R/W 0x0  0: if this queue can’t own channel ,txcmd will be cleared 1:Only TX_finish can clear txreq */
-#define BIT_DIS_TXREQ_CLR_VO                     ((u32)0x00000001 << 24)          /*!<R/W 0x0  0: if this queue can’t own channel ,txcmd will be cleared 1:Only TX_finish can clear txreq */
-#define BIT_STOP_CPUMGQ                          ((u32)0x00000001 << 23)          /*!<R/W 0x0  To control CPUMGQ queues contention circuit. 1: CPUMGQ queues all stop. 0: Enable CPUMGQ queues contention circuit */
-#define BIT_MAC_STOPBCNQ                         ((u32)0x00000001 << 22)          /*!<R/W 0x0  Stop BCNQ Queue Write a 1 to this bit via software to immediately stop the transmission of packet from this queue including retry attempts. */
-#define BIT_MAC_STOPHIQ                          ((u32)0x00000001 << 21)          /*!<R/W 0x0  Stop High Queue Write a 1 to this bit via software to immediately stop the transmission of packet from this queue including retry attempts. */
-#define BIT_MAC_STOPMGQ                          ((u32)0x00000001 << 20)          /*!<R/W 0x0  Stop Management Queue Write a 1 to this bit via software to immediately stop the transmission of packet from this queue including retry attempts. */
-#define BIT_MAC_STOPBK                           ((u32)0x00000001 << 19)          /*!<R/W 0x0  Stop BK Queue Write a 1 to this bit via software to immediately stop the transmission of packet from this queue including retry attempts. */
-#define BIT_MAC_STOPBE                           ((u32)0x00000001 << 18)          /*!<R/W 0x0  Stop BE Queue Write a 1 to this bit via software to immediately stop the transmission of packet from this queue including retry attempts. */
-#define BIT_MAC_STOPVI                           ((u32)0x00000001 << 17)          /*!<R/W 0x0  Stop VI Queue Write a 1 to this bit via software to immediately stop the transmission of packet from this queue including retry attempts. */
-#define BIT_MAC_STOPVO                           ((u32)0x00000001 << 16)          /*!<R/W 0x0  Stop VO Queue Write a 1 to this bit via software to immediately stop the transmission of packet from this queue including retry attempts. */
-#define BIT_DIS_EDCCA                            ((u32)0x00000001 << 15)          /*!<R/W 0x0  Disable EDCCA function. (NOT USED, SEE 0x1594) 0: PHY_EDCCA can block TX (default) 1: PHY_EDCCA cannot block TX OK -> TX beacon; X -> cannot TX beacon 0x528[7] 0x520[15] 0x520[14] TX bcn TX bcn (OFDMCCA=0, (OFDMCCA=1, EDCCA=1) EDCCA=1) 0 0 0 X X 0 0 1 X X 0 1 0 OK X 0 1 1 OK OK 1 0 0 X X 1 0 1 X X 1 1 0 OK X 1 1 1 OK OK */
-#define BIT_DIS_CCA                              ((u32)0x00000001 << 14)          /*!<R/W 0x0  Disable CCA. (NOT USED, SEE 0x1594) */
-#define BIT_LSIG_TXOP_TXCMD_NAV                  ((u32)0x00000001 << 13)          /*!<R/W 0x1  Set LSIG_TXOP from TXCMD_NAV field */
-#define BIT_SIFS_BK_EN                           ((u32)0x00000001 << 12)          /*!<R/W 0x1  SIFS Break Check Criteria enable for AMPDU aggregation */
-#define BIT_MASK_TXQ_NAV_MSK                     ((u32)0x0000000F << 8)          /*!<R/W 0xF  1: Queue BKF must wait TX Nav finished 0: Queue not need wait */
-#define BIT_TXQ_NAV_MSK(x)                       ((u32)(((x) & 0x0000000F) << 8))
-#define BIT_GET_TXQ_NAV_MSK(x)                   ((u32)(((x >> 8) & 0x0000000F)))
-#define BIT_DIS_CW                               ((u32)0x00000001 << 7)          /*!<R/W 0x0  When this bit is set, disable CW. */
-#define BIT_NAV_END_TXOP                         ((u32)0x00000001 << 6)          /*!<R/W 0x0  1: In txop mode, Nav protect all txop 0: In txop mode, Nav protect to next pkt */
-#define BIT_RDG_END_TXOP                         ((u32)0x00000001 << 5)          /*!<R/W 0x0  1: In tx RDG mode, Nav protect all txop 0: In tx RDG mode, Nav protect to next pkt */
-#define BIT_MGTQ_TXOP_EN                         ((u32)0x00000001 << 3)          /*!<R/W 0x1  When this bit is set, MGTQ may sent packets by using ACQ TXOP. */
-#define BIT_MGTQ_RTSMF_EN                        ((u32)0x00000001 << 2)          /*!<R/W 0x1  When this bit is set, MTGQ will be TX, not wait until RTS or MF transaction finished. */
-#define BIT_HIQ_RTSMF_EN                         ((u32)0x00000001 << 1)          /*!<R/W 0x1  When this bit is set, HIQ will be TX, not wait until RTS or MF transaction finished. */
-#define BIT_BCN_RTSMF_EN                         ((u32)0x00000001 << 0)          /*!<R/W 0x1  When this bit is set, BCNQ will be TX, not wait until RTS or MF transaction finished. */
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_NOA0_MBSSID_RD_CTRL
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_P2P_NOA0_ALLSTASLEEP                 ((u32)0x00000001 << 31)          /*!<R/W 0x0  It indicates that the state from CTWindow End to BcnEarly 1: Sleep 0: Wake */
-#define BIT_P2P_NOA0_DISTX_EN                    ((u32)0x00000001 << 30)          /*!<R/W 0x0  1: Hw will disable TX in P2P_off period 0: Do Nothing */
-#define BIT_P2P_NOA0_PWR_MGT_EN                  ((u32)0x00000001 << 29)          /*!<R/W 0x0  A main switch for P2P PowerSaving 1: Enable 0: Disable */
-#define BIT_MASK_P2P_NOA0_EN                     ((u32)0x00000003 << 27)          /*!<R/W 0x0  The condition that noa_unit0, [1]-NOA1, [0]-NOA0 1: Enable 0: Disable */
-#define BIT_P2P_NOA0_EN(x)                       ((u32)(((x) & 0x00000003) << 27))
-#define BIT_GET_P2P_NOA0_EN(x)                   ((u32)(((x >> 27) & 0x00000003)))
-#define BIT_MASK_P2P_NOA0_UNIT_SEL               ((u32)0x00000003 << 25)          /*!<R/W 0x0  The selector for the source of noa unit0. 0 for port 0, 1 for port 1,2 for port2 */
-#define BIT_P2P_NOA0_UNIT_SEL(x)                 ((u32)(((x) & 0x00000003) << 25))
-#define BIT_GET_P2P_NOA0_UNIT_SEL(x)             ((u32)(((x >> 25) & 0x00000003)))
-#define BIT_EN_TSFBIT32_RST_NOA0                 ((u32)0x00000001 << 24)          /*!<R/W 0x1  when enable, if tsft_bit32_int is asserted, reset power_cs of noa_unit0 */
-#define BIT_MBID_BCNQ7_EN                        ((u32)0x00000001 << 23)          /*!<R/W 0x1  When enable, auto MBSSID for virtual interface 7 is enable. */
-#define BIT_MBID_BCNQ6_EN                        ((u32)0x00000001 << 22)          /*!<R/W 0x1  When enable, auto MBSSID for virtual interface 6 is enable. */
-#define BIT_MBID_BCNQ5_EN                        ((u32)0x00000001 << 21)          /*!<R/W 0x1  When enable, auto MBSSID for virtual interface 5 is enable. */
-#define BIT_MBID_BCNQ4_EN                        ((u32)0x00000001 << 20)          /*!<R/W 0x1  When enable, auto MBSSID for virtual interface 4 is enable. */
-#define BIT_MBID_BCNQ3_EN                        ((u32)0x00000001 << 19)          /*!<R/W 0x1  When enable, auto MBSSID for virtual interface 3 is enable. */
-#define BIT_MBID_BCNQ2_EN                        ((u32)0x00000001 << 18)          /*!<R/W 0x1  When enable, auto MBSSID for virtual interface 2 is enable. */
-#define BIT_MBID_BCNQ1_EN                        ((u32)0x00000001 << 17)          /*!<R/W 0x1  When enable, auto MBSSID for virtual interface 1 is enable. */
-#define BIT_MBID_BCNQ0_EN                        ((u32)0x00000001 << 16)          /*!<R/W 0x1  When enable, auto MBSSID for root interface is enable. */
-#define BIT_EN_CLR_TXREQ_INCCA                   ((u32)0x00000001 << 15)          /*!<R/W 0x1  not valid。 */
-#define BIT_DIS_TX_OVER_BCNQ                     ((u32)0x00000001 << 14)          /*!<R/W 0x0  1: Tx Packet with ignoring Beacon Area time 0: Disable */
-#define BIT_EN_BCNERR_INCCCA                     ((u32)0x00000001 << 13)          /*!<R/W 0x0  eneble force tx becon ignore CCA in disable contention area */
-#define BIT_EN_BCNERR_INEDCCA                    ((u32)0x00000001 << 12)          /*!<R/W 0x0  eneble force tx becon ignore EDCCA in disable contention area */
-#define BIT_EDCCA_MSK_CNTDOWN_EN                 ((u32)0x00000001 << 11)          /*!<R/W 0x1  1: disable EDCCA count down, 0: enable EDCCA count down AC backoff 是否需要參考PHY_EDCCA 0: 不參考PHY_EDCCA 1: 參考PHY_EDCCA (default, PHY_EDCCA=1時停止backoff) */
-#define BIT_DIS_TXOP_CFE                         ((u32)0x00000001 << 10)          /*!<R/W 0x0  Disable TXOP_CFE function */
-#define BIT_DIS_LSIG_CFE                         ((u32)0x00000001 << 9)          /*!<R/W 0x0  Disable LSIG_TXOP CF-END function */
-#define BIT_DIS_STBC_CFE                         ((u32)0x00000001 << 8)          /*!<R/W 0x0  Disable STBC CF-END function */
-#define BIT_BKQ_RD_INIT_EN                       ((u32)0x00000001 << 7)          /*!<R/W 0x0  Enable BKQ RD initiator function */
-#define BIT_BEQ_RD_INIT_EN                       ((u32)0x00000001 << 6)          /*!<R/W 0x0  Enable BEQ RD initiator function */
-#define BIT_VIQ_RD_INIT_EN                       ((u32)0x00000001 << 5)          /*!<R/W 0x0  Enable VIQ RD initiator function */
-#define BIT_VOQ_RD_INIT_EN                       ((u32)0x00000001 << 4)          /*!<R/W 0x0  Enable VOQ RD initiator function */
-#define BIT_BKQ_RD_RESP_EN                       ((u32)0x00000001 << 3)          /*!<R/W 0x1  Enable BKQ RD responder function */
-#define BIT_BEQ_RD_RESP_EN                       ((u32)0x00000001 << 2)          /*!<R/W 0x1  Enable BEQ RD responder function */
-#define BIT_VIQ_RD_RESP_EN                       ((u32)0x00000001 << 1)          /*!<R/W 0x1  Enable VIQ RD responder function */
-#define BIT_VOQ_RD_RESP_EN                       ((u32)0x00000001 << 0)          /*!<R/W 0x1  Enable VOQ RD responder function */
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_NOA0_PKT_LIFETIME_CTRL
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_POWER_STATE_0                        ((u32)0x00000001 << 31)          /*!<RO   1: On, 0: Off. (It is including early time. ) */
-#define BIT_CTWINDOW_ON_0                        ((u32)0x00000001 << 30)          /*!<RO   Spec time and Beacon Early Time to TBTT Time. (It is including early time. ) */
-#define BIT_BEACON_AREA_ON_0                     ((u32)0x00000001 << 29)          /*!<RO   The time is from HOLD Time to BeaconTx or Timeout. (It is including early time. ) */
-#define BIT_CTWIN_EARLY_DISTX_0                  ((u32)0x00000001 << 28)          /*!<RO   ctwin_early_distx. (It is including early time. ) */
-#define BIT_NOA1_OFF_PERIOD_0                    ((u32)0x00000001 << 27)          /*!<RO   Spec time but exclude BCNDMATIM time for wake. (It is including early time. ) */
-#define BIT_FORCE_DOZE1_0                        ((u32)0x00000001 << 26)          /*!<RO   If NoA_Count == 1, this value is 1. else 0. (It is including early time. ) */
-#define BIT_NOA0_OFF_PERIOD_0                    ((u32)0x00000001 << 25)          /*!<RO   Spec time but exclude BCNDMATIM time for wake. (It is including early time. ) */
-#define BIT_FORCE_DOZE0_0                        ((u32)0x00000001 << 24)          /*!<RO   If NoA_Count == 1, this value is 1. else 0. (It is including early time. ) */
-#define BIT_CHANGE_POW_BCN_AREA                  ((u32)0x00000001 << 23)          /*!<R/W 0x0  select real_ctwindow & real_bcnq_area for noa_unit */
-#define BIT_EN_BKF_CLR_TXREQ                     ((u32)0x00000001 << 22)          /*!<R/W 0x1  when gen tx command done, while will backoff is invalid, then tx command will be cleared */
-#define BIT_EN_BCN_TX_BTCCA                      ((u32)0x00000001 << 20)          /*!<R/W 0x0  1: Enable Beacon Tx at TBTT if BT_CCA is enabled 0: Disable */
-#define BIT_DIS_PKT_TX_ATIM                      ((u32)0x00000001 << 19)          /*!<R/W 0x1  1: Disable AC Queue Packet Tx in ATIM (only valid at Nettype: Adhoc/AP) 0: Enable AC Queue packet Tx in ATIM */
-#define BIT_DIS_BCN_DIS_CTN                      ((u32)0x00000001 << 18)          /*!<R/W 0x1  Disable the Beacon queue disable contention,when set to 0 enable the force beacon function. */
-#define BIT_EN_NAVEND_RST_TXOP                   ((u32)0x00000001 << 17)          /*!<R/W 0x0  When set this bit, TXOP will be reset while NAV end. */
-#define BIT_EN_FILTER_CCA                        ((u32)0x00000001 << 16)          /*!<R/W 0x0  Enable CCA filter threshold */
-#define BIT_MASK_CCA_FILTER_THRS                 ((u32)0x000000FF << 8)          /*!<R/W 0xA  If PHY_CCA signal width is bigger than this threshold, this PHY_CCA signal is valid for MAC. Unit: us */
-#define BIT_CCA_FILTER_THRS(x)                   ((u32)(((x) & 0x000000FF) << 8))
-#define BIT_GET_CCA_FILTER_THRS(x)               ((u32)(((x >> 8) & 0x000000FF)))
-#define BIT_MASK_EDCCA_THRS                      ((u32)0x000000FF << 0)          /*!<R/W 0x8F  EDCCA threshold value, edcca over this threshold will cause bkf_rst Bit[7]: PHY_EDCCA為1時,當timer timeout時擋住TX Bit[6:0]: timer (單位:32us) */
-#define BIT_EDCCA_THRS(x)                        ((u32)(((x) & 0x000000FF) << 0))
-#define BIT_GET_EDCCA_THRS(x)                    ((u32)(((x >> 0) & 0x000000FF)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_P2PON_DIS_TXTIME
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_MASK_P2PON_DIS_TXTIME                ((u32)0x000000FF << 8)          /*!<R/W 0x0  The time of the disable TX period after the P2P RF on interrupt occur. Unit: 64us. */
-#define BIT_P2PON_DIS_TXTIME(x)                  ((u32)(((x) & 0x000000FF) << 8))
-#define BIT_GET_P2PON_DIS_TXTIME(x)              ((u32)(((x >> 8) & 0x000000FF)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_NAN_SETTING_2
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_MASK_SYNC_BCN_DELAY                  ((u32)0x00003FFF << 0)          /*!<R/W 0x168  r_HC * r_SLOTTIME * 8'd40 (unit:us) default: r_HC = 1, r_SLOTTIME = 9, => 360us max is 16ms (DW) */
-#define BIT_SYNC_BCN_DELAY(x)                    ((u32)(((x) & 0x00003FFF) << 0))
-#define BIT_GET_SYNC_BCN_DELAY(x)                ((u32)(((x >> 0) & 0x00003FFF)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_QUEUE_INCOL_THR
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_MASK_BK_QUEUE_THR                    ((u32)0x000000FF << 24)          /*!<R/W 0x0  0: Disable this BK queue condition. Otherwise: When internal collision number of queue equal threshold, the priority of queue enhance. But have more 2 queues which satisfy each queue threshold, the priority will follow VO>VI>BE>BK. */
-#define BIT_BK_QUEUE_THR(x)                      ((u32)(((x) & 0x000000FF) << 24))
-#define BIT_GET_BK_QUEUE_THR(x)                  ((u32)(((x >> 24) & 0x000000FF)))
-#define BIT_MASK_BE_QUEUE_THR                    ((u32)0x000000FF << 16)          /*!<R/W 0x0  0: Disable this BE queue condition. Otherwise: When internal collision number of queue equal threshold, the priority of queue enhance. But have more 2 queues which satisfy each queue threshold, the priority will follow VO>VI>BE>BK. */
-#define BIT_BE_QUEUE_THR(x)                      ((u32)(((x) & 0x000000FF) << 16))
-#define BIT_GET_BE_QUEUE_THR(x)                  ((u32)(((x >> 16) & 0x000000FF)))
-#define BIT_MASK_VI_QUEUE_THR                    ((u32)0x000000FF << 8)          /*!<R/W 0x0  0: Disable this VI queue condition. Otherwise: When internal collision number of queue equal threshold, the priority of queue enhance. But have more 2 queues which satisfy each queue threshold, the priority will follow VO>VI>BE>BK. */
-#define BIT_VI_QUEUE_THR(x)                      ((u32)(((x) & 0x000000FF) << 8))
-#define BIT_GET_VI_QUEUE_THR(x)                  ((u32)(((x >> 8) & 0x000000FF)))
-#define BIT_MASK_VO_QUEUE_THR                    ((u32)0x000000FF << 0)          /*!<R/W 0x0  0: Disable this VO queue condition. Otherwise: When internal collision number of queue equal threshold, the priority of queue enhance. But have more 2 queues which satisfy each queue threshold, the priority will follow VO>VI>BE>BK. */
-#define BIT_VO_QUEUE_THR(x)                      ((u32)(((x) & 0x000000FF) << 0))
-#define BIT_GET_VO_QUEUE_THR(x)                  ((u32)(((x >> 0) & 0x000000FF)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_QUEUE_INCOL_EN
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_DIS_ZGBCCA                           ((u32)0x00000001 << 31)          /*!<R/W 0x0  Disable zigbee CCA (NOT USED, SEE 0x1594) */
-#define BIT_MASK_TXOP_FAILBREAK_CNT              ((u32)0x000000FF << 22)          /*!<R 0x0  if BIT_TXOP_FAIL_BREAK = 1, counter the times of txfail break TXOP */
-#define BIT_TXOP_FAILBREAK_CNT(x)                ((u32)(((x) & 0x000000FF) << 22))
-#define BIT_GET_TXOP_FAILBREAK_CNT(x)            ((u32)(((x >> 22) & 0x000000FF)))
-#define BIT_TXOP_FAIL_BREAK                      ((u32)0x00000001 << 21)          /*!<R/W 0x0  1: if tx pkt fail in txop, then tx cfend to end txop */
-#define BIT_EN_TBTT_AREA_BLK_4AC                 ((u32)0x00000001 << 20)          /*!<R/W 0x1  When set this bit, 4AC backoff is disabled on TBTT setup period */
-#define BIT_ENABLE_RANDOM_SHIFT_TX               ((u32)0x00000001 << 19)          /*!<R/W 0x0  When this bit set 1, enable random shift TX function */
-#define BIT_ENABLE_EDCA_REF_FUNCTION             ((u32)0x00000001 << 18)          /*!<R/W 0x0  When this bit set 1, enable EDCA REF function */
-#define BIT_ENABLE_INTERCOL_EDCA_REF             ((u32)0x00000001 << 17)          /*!<R/W 0x0  When this bit set 1, enable inter-collision edca_ref */
-#define BIT_ACQ_MAX_INCOL_EN                     ((u32)0x00000001 << 16)          /*!<R/W 0x0  1:Enable 0 :Disable */
-#define BIT_MASK_BK_TRIGGER_NUM                  ((u32)0x0000000F << 12)          /*!<R/W1C 0x0  The number is triggered by bkq inter collision */
-#define BIT_BK_TRIGGER_NUM(x)                    ((u32)(((x) & 0x0000000F) << 12))
-#define BIT_GET_BK_TRIGGER_NUM(x)                ((u32)(((x >> 12) & 0x0000000F)))
-#define BIT_MASK_BE_TRIGGER_NUM                  ((u32)0x0000000F << 8)          /*!<R/W1C 0x0  The number is triggered by beq inter collision */
-#define BIT_BE_TRIGGER_NUM(x)                    ((u32)(((x) & 0x0000000F) << 8))
-#define BIT_GET_BE_TRIGGER_NUM(x)                ((u32)(((x >> 8) & 0x0000000F)))
-#define BIT_MASK_VI_TRIGGER_NUM                  ((u32)0x0000000F << 4)          /*!<R/W1C 0x0  The number is triggered by viq inter collision */
-#define BIT_VI_TRIGGER_NUM(x)                    ((u32)(((x) & 0x0000000F) << 4))
-#define BIT_GET_VI_TRIGGER_NUM(x)                ((u32)(((x >> 4) & 0x0000000F)))
-#define BIT_MASK_VO_TRIGGER_NUM                  ((u32)0x0000000F << 0)          /*!<R/W1C 0x0  The number is triggered by voq inter collision */
-#define BIT_VO_TRIGGER_NUM(x)                    ((u32)(((x) & 0x0000000F) << 0))
-#define BIT_GET_VO_TRIGGER_NUM(x)                ((u32)(((x >> 0) & 0x0000000F)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_NOA0_TBTT_PROHIBIT
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_SPEC_POWER_STATE_0                   ((u32)0x00000001 << 31)          /*!<RO   1: On, 0: Off */
-#define BIT_SPEC_CTWINDOW_ON_0                   ((u32)0x00000001 << 30)          /*!<RO   The time from TBTT <-> CTWEND (with BCNDMATIM early time) */
-#define BIT_SPEC_BEACON_AREA_ON_0                ((u32)0x00000001 << 29)          /*!<RO   The time is from TBTT to BeaconTx or Timeout */
-#define BIT_SPEC_CTWIN_EARLY_DISTX_0             ((u32)0x00000001 << 28)          /*!<RO   ctwin_early_distx */
-#define BIT_SPEC_NOA1_OFF_PERIOD_0               ((u32)0x00000001 << 27)          /*!<RO   Spec time */
-#define BIT_SPEC_FORCE_DOZE1_0                   ((u32)0x00000001 << 26)          /*!<RO   If NoA_Count == 1, this value is 1. else 0. */
-#define BIT_SPEC_NOA0_OFF_PERIOD_0               ((u32)0x00000001 << 25)          /*!<RO   Spec time */
-#define BIT_SPEC_FORCE_DOZE0_0                   ((u32)0x00000001 << 24)          /*!<RO   If NoA_Count == 1, this value is 1. else 0. */
-#define BIT_EN_TBTT_AREA_FOR_BB                  ((u32)0x00000001 << 20)          /*!<R/W 0x0  enable notify bb that mac p0 is in tbtt area */
-#define BIT_MASK_TBTT_HOLD_TIME                  ((u32)0x00000FFF << 8)          /*!<R/W 0xc8  TBTT_prohibit_hold time for AP mode, unit is 32 us */
-#define BIT_TBTT_HOLD_TIME(x)                    ((u32)(((x) & 0x00000FFF) << 8))
-#define BIT_GET_TBTT_HOLD_TIME(x)                ((u32)(((x >> 8) & 0x00000FFF)))
-#define BIT_MASK_TBTT_HOLD_TIME_INFRA            ((u32)0x0000000F << 4)          /*!<R/W 0x01  TBTT_prohibit_hold time for infrastructure mode , unit is 2 ms */
-#define BIT_TBTT_HOLD_TIME_INFRA(x)              ((u32)(((x) & 0x0000000F) << 4))
-#define BIT_GET_TBTT_HOLD_TIME_INFRA(x)          ((u32)(((x >> 4) & 0x0000000F)))
-#define BIT_MASK_TBTT_PROHIBIT_SETUP             ((u32)0x0000000F << 0)          /*!<R/W 0x02  TBTT_prohibit_setup, unit is 32us */
-#define BIT_TBTT_PROHIBIT_SETUP(x)               ((u32)(((x) & 0x0000000F) << 0))
-#define BIT_GET_TBTT_PROHIBIT_SETUP(x)           ((u32)(((x >> 0) & 0x0000000F)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_NAV_CTRL
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_MASK_NAV_PROT_LEN                    ((u32)0x0000FFFF << 16)          /*!<R/W 0x40  In TXOP mode ,NAV setting which protects next packets */
-#define BIT_NAV_PROT_LEN(x)                      ((u32)(((x) & 0x0000FFFF) << 16))
-#define BIT_GET_NAV_PROT_LEN(x)                  ((u32)(((x >> 16) & 0x0000FFFF)))
-#define BIT_MASK_RD_NAV_PROT_NXT                 ((u32)0x0000FFFF << 0)          /*!<R/W 0x180  In RDG mode ,NAV setting which protects next packets */
-#define BIT_RD_NAV_PROT_NXT(x)                   ((u32)(((x) & 0x0000FFFF) << 0))
-#define BIT_GET_RD_NAV_PROT_NXT(x)               ((u32)(((x >> 0) & 0x0000FFFF)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_FTM_CTRL
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_FTM_TSF_R2T_PORT                     ((u32)0x00000001 << 24)          /*!<R/W 0x0  0:R2T latch count sync tsf of port 0 1: R2T latch count sync tsf of port 1 */
-#define BIT_FTM_TSF_T2R_PORT                     ((u32)0x00000001 << 20)          /*!<R/W 0x0  0:T2R latch count sync tsf of port 0 1: T2R latch count sync tsf of port 1 */
-#define BIT_FTM_PTT_PORT                         ((u32)0x00000001 << 16)          /*!<R/W 0x0  0: sync tsf of port 0 1: sync tsf of port 1 */
-#define BIT_MASK_FTM_PTT                         ((u32)0x0000FFFF << 0)          /*!<R/W 0x0  partial tsf timer setting */
-#define BIT_FTM_PTT(x)                           ((u32)(((x) & 0x0000FFFF) << 0))
-#define BIT_GET_FTM_PTT(x)                       ((u32)(((x >> 0) & 0x0000FFFF)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_FTM_TSF_CNT
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_MASK_FTM_TSF_R2T                     ((u32)0x0000FFFF << 16)          /*!<R 0x0  R2T latch count sync tsf timer */
-#define BIT_FTM_TSF_R2T(x)                       ((u32)(((x) & 0x0000FFFF) << 16))
-#define BIT_GET_FTM_TSF_R2T(x)                   ((u32)(((x >> 16) & 0x0000FFFF)))
-#define BIT_MASK_FTM_TSF_T2R                     ((u32)0x0000FFFF << 0)          /*!<R 0x0  T2R latch count sync tsf timer */
-#define BIT_FTM_TSF_T2R(x)                       ((u32)(((x) & 0x0000FFFF) << 0))
-#define BIT_GET_FTM_TSF_T2R(x)                   ((u32)(((x >> 0) & 0x0000FFFF)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_TSTRST_P2PRST_BCN_CTRL_PORT0_1
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_P2P_PWR_RST1                         ((u32)0x00000001 << 30)          /*!<W 0x0  rst p2p circuit NOA 1, noa_unit0 */
-#define BIT_SCHEDULER_RST                        ((u32)0x00000001 << 29)          /*!<W 0x0  Write this bit reset scheduler, ioreg_txfail */
-#define BIT_P2P_PWR_RST0                         ((u32)0x00000001 << 28)          /*!<W 0x0  rst p2p circuit NOA 0, noa_unit0 */
-#define BIT_TSFTR1_SYNC_EN                       ((u32)0x00000001 << 27)          /*!<W 0x0  write this bit, bcn1 will sync to bcn0 with TSFTF_SYN_OFFSET */
-#define BIT_TSFTR_SYNC_EN                        ((u32)0x00000001 << 26)          /*!<W 0x0  write this bit, bcn0 will sync to bcn1 with TSFTF_SYN_OFFSET */
-#define BIT_TSFTR1_RST                           ((u32)0x00000001 << 25)          /*!<W 0x0  write this bit , bcn1 tsft will auto reset */
-#define BIT_TSFTR_RST                            ((u32)0x00000001 << 24)          /*!<W 0x0  write this bit , bcn0 tsft will auto reset */
-#define BIT_P2P_PWR_RST5                         ((u32)0x00000001 << 23)          /*!<W 0x0  rst p2p circuit NOA 5, noa_unit2 */
-#define BIT_P2P_PWR_RST4                         ((u32)0x00000001 << 22)          /*!<W 0x0  rst p2p circuit NOA 4, noa_unit2 */
-#define BIT_P2P_PWR_RST3                         ((u32)0x00000001 << 21)          /*!<W 0x0  rst p2p circuit NOA 3, noa_unit1 */
-#define BIT_P2P_PWR_RST2                         ((u32)0x00000001 << 20)          /*!<W 0x0  rst p2p circuit NOA 2, noa_unit1 */
-#define BIT_EN_PRE_DL_BEACON                     ((u32)0x00000001 << 19)          /*!<R/W 0x0  If set 1, hw will enable pre_download beacon */
-#define BIT_MASK_MBID_BCN_NUM                    ((u32)0x00000007 << 16)          /*!<R/W 0x0  The number of virtual interface number excluding the root number. */
-#define BIT_MBID_BCN_NUM(x)                      ((u32)(((x) & 0x00000007) << 16))
-#define BIT_GET_MBID_BCN_NUM(x)                  ((u32)(((x >> 16) & 0x00000007)))
-#define BIT_P1_RXBCN_RPT_ENABLE                  ((u32)0x00000001 << 15)          /*!<R/W 0x0  When this bit asserted, RXBCNOK report is issued */
-#define BIT_P1_DIS_RX_BSSID_FIT                  ((u32)0x00000001 << 14)          /*!<R/W 0x0  0:HW will handle rx_beacon 1:HW will ignore rx_beacon_pk */
-#define BIT_P1_TXBCN_RPT_ENABLE                  ((u32)0x00000001 << 13)          /*!<R/W 0x0  When this bit and BIT_P1_EN_BCN_RPT are set, then TXBCN ERROR report is issued */
-#define BIT_P1_DIS_TSF_UDT                       ((u32)0x00000001 << 12)          /*!<R/W 0x1  When set, disable clint 0 TSF update when beacon frames or probe response frames are received. */
-#define BIT_P1_EN_BCN_FUNCTION                   ((u32)0x00000001 << 11)          /*!<R/W 0x0  When this bit is set, TSF and other beacon related functions are then enabled. 0x700(MACID1)的enable開關 */
-#define BIT_P1_EN_BCN_RPT                        ((u32)0x00000001 << 10)          /*!<R/W 0x1  When this bit asserted, txbcnok_int and txbcnerr_int will valid. */
-#define BIT_P1_ENP2P_CTWINDOW                    ((u32)0x00000001 << 9)          /*!<R/W 0x0  1: Enable P2P CTN WINDOWS function. 0: Disable P2P CTN WINDOWS function. */
-#define BIT_P1_ENP2P_BCNQ_AREA                   ((u32)0x00000001 << 8)          /*!<R/W 0x0  1: Enable P2P BCN area on function. 0 : Disable P2P BCN area on function. */
-#define BIT_P0_RXBCN_RPT_ENABLE                  ((u32)0x00000001 << 7)          /*!<R/W 0x0  When this bit asserted, RXBCNOK report is issued */
-#define BIT_P0_DIS_RX_BSSID_FIT                  ((u32)0x00000001 << 6)          /*!<R/W 0x0  0:HW will handle rx_beacon 1:HW will ignore rx_beacon_pk */
-#define BIT_P0_TXBCN_RPT_ENABLE                  ((u32)0x00000001 << 5)          /*!<R/W 0x0  When this bit and BIT_P0_EN_BCN_RPT are set, then TXBCN ERROR report is issued */
-#define BIT_P0_DIS_TSF_UDT                       ((u32)0x00000001 << 4)          /*!<R/W 0x1  When set, disable port 0 TSF update when beacon frames or probe response frames are received. */
-#define BIT_P0_EN_BCN_FUNCTION                   ((u32)0x00000001 << 3)          /*!<R/W 0x0  When this bit is set, TSF and other beacon related functions are then enabled. 0x610(MACID)的enable開關 */
-#define BIT_P0_EN_BCN_RPT                        ((u32)0x00000001 << 2)          /*!<R/W 0x1  When this bit asserted, txbcnok_int and txbcnerr_int will valid. */
-#define BIT_P0_EN_P2P_CTWINDOW                   ((u32)0x00000001 << 1)          /*!<R/W 0x0  1: Enable P2P CTN WINDOWS function. 0: Disable P2P CTN WINDOWS function. */
-#define BIT_P0_EN_P2P_BCNQ_AREA                  ((u32)0x00000001 << 0)          /*!<R/W 0x0  1: Enable P2P BCN area on function. 0 : Disable P2P BCN area on function. */
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_PORT0_BCN_SPACE
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_MASK_BCN_SUB_SPACE_PORT0             ((u32)0x0000FFFF << 16)          /*!<R/W 0x64  Unit is ms. The sub-beacon interval of the port 0.(valid if mbssid function is enable) */
-#define BIT_BCN_SUB_SPACE_PORT0(x)               ((u32)(((x) & 0x0000FFFF) << 16))
-#define BIT_GET_BCN_SUB_SPACE_PORT0(x)           ((u32)(((x >> 16) & 0x0000FFFF)))
-#define BIT_MASK_BCN_SPACE_PORT0                 ((u32)0x0000FFFF << 0)          /*!<R/W 0x64  Unit is ms. When MBSSID is disable, this field is the beacon interval. When MBSSID is enable, this register is the beacon space of root. */
-#define BIT_BCN_SPACE_PORT0(x)                   ((u32)(((x) & 0x0000FFFF) << 0))
-#define BIT_GET_BCN_SPACE_PORT0(x)               ((u32)(((x >> 0) & 0x0000FFFF)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_ATIMWND0_P0_BCN_ERLY_DMA_CTRL
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_MASK_ATIMWND0                        ((u32)0x0000FFFF << 16)          /*!<R/W 0x02  ATIM window width of root VAP in units of TU. */
-#define BIT_ATIMWND0(x)                          ((u32)(((x) & 0x0000FFFF) << 16))
-#define BIT_GET_ATIMWND0(x)                      ((u32)(((x >> 16) & 0x0000FFFF)))
-#define BIT_MASK_BCNDMATIM_P0                    ((u32)0x000000FF << 8)          /*!<R/W 0x03  Indicates the time before TBTT to perform beacon queue DMA. This register is shared by the time to assert ATIM window end interrupt. Measured in units of “TU” before TBTT and before ATIM window end. */
-#define BIT_BCNDMATIM_P0(x)                      ((u32)(((x) & 0x000000FF) << 8))
-#define BIT_GET_BCNDMATIM_P0(x)                  ((u32)(((x >> 8) & 0x000000FF)))
-#define BIT_MASK_DRVERLYITV_P0                   ((u32)0x000000FF << 0)          /*!<R/W 0x05  Time to send interrupt to notify driver to change beacon content. Time unit is TU. The register also is shared by P2P-CTW and P2P-NoA (from NoA-Absent to NoA-On). It is used to wake up early at DriverEarlyTime */
-#define BIT_DRVERLYITV_P0(x)                     ((u32)(((x) & 0x000000FF) << 0))
-#define BIT_GET_DRVERLYITV_P0(x)                 ((u32)(((x >> 0) & 0x000000FF)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_BCNERR_TSF_CTRL
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_MASK_OFDM_RXTSF_OFFSET               ((u32)0x000000FF << 24)          /*!<R/W 0x0F  The Datapath of OFDM RX_tsf */
-#define BIT_OFDM_RXTSF_OFFSET(x)                 ((u32)(((x) & 0x000000FF) << 24))
-#define BIT_GET_OFDM_RXTSF_OFFSET(x)             ((u32)(((x >> 24) & 0x000000FF)))
-#define BIT_MASK_CCK_RXTSF_OFFSET                ((u32)0x000000FF << 16)          /*!<R/W 0x0F  The Datapath of CCK RX_tsf */
-#define BIT_CCK_RXTSF_OFFSET(x)                  ((u32)(((x) & 0x000000FF) << 16))
-#define BIT_GET_CCK_RXTSF_OFFSET(x)              ((u32)(((x >> 16) & 0x000000FF)))
-#define BIT_MASK_BCN_MAX_ERR                     ((u32)0x000000FF << 8)          /*!<R/W 0x10  When beacon TX error counter goes over this threshold, Beacon will transmit within PIFS. */
-#define BIT_BCN_MAX_ERR(x)                       ((u32)(((x) & 0x000000FF) << 8))
-#define BIT_GET_BCN_MAX_ERR(x)                   ((u32)(((x >> 8) & 0x000000FF)))
-#define BIT_MASK_USTIME_TSF                      ((u32)0x000000FF << 0)          /*!<R/W 0x28  Set the microsecond time unit used by MAC TSF clock. 0x14 - 20MHz 0x28 - 40MHz 0x50 - 80MHz */
-#define BIT_USTIME_TSF(x)                        ((u32)(((x) & 0x000000FF) << 0))
-#define BIT_GET_USTIME_TSF(x)                    ((u32)(((x >> 0) & 0x000000FF)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_P0_TSFTR_L
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_MASK_P0_TSF_TIMER_L                  ((u32)0xFFFFFFFF << 0)          /*!<R/W 0x1  low 32bits of port0's tsft */
-#define BIT_P0_TSF_TIMER_L(x)                    ((u32)(((x) & 0xFFFFFFFF) << 0))
-#define BIT_GET_P0_TSF_TIMER_L(x)                ((u32)(((x >> 0) & 0xFFFFFFFF)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_P0_TSFTR_H
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_MASK_P0_TSF_TIMER_H                  ((u32)0xFFFFFFFF << 0)          /*!<R/W 0x0  high 32bits of port0's tsft */
-#define BIT_P0_TSF_TIMER_H(x)                    ((u32)(((x) & 0xFFFFFFFF) << 0))
-#define BIT_GET_P0_TSF_TIMER_H(x)                ((u32)(((x >> 0) & 0xFFFFFFFF)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_P1_TSFTR_L
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_MASK_P1_TSF_TIMER_L                  ((u32)0xFFFFFFFF << 0)          /*!<R/W 0x1  low 32bits of port1's tsft */
-#define BIT_P1_TSF_TIMER_L(x)                    ((u32)(((x) & 0xFFFFFFFF) << 0))
-#define BIT_GET_P1_TSF_TIMER_L(x)                ((u32)(((x >> 0) & 0xFFFFFFFF)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_P1_TSFTR_H
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_MASK_P1_TSF_TIMER_H                  ((u32)0xFFFFFFFF << 0)          /*!<R/W 0x1  high 32bits of port1's tsft */
-#define BIT_P1_TSF_TIMER_H(x)                    ((u32)(((x) & 0xFFFFFFFF) << 0))
-#define BIT_GET_P1_TSF_TIMER_H(x)                ((u32)(((x >> 0) & 0xFFFFFFFF)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_BCN_ERLY_CTW_CTRL
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_MASK_BCNIVLCUNT_P0                   ((u32)0x0000007F << 24)          /*!<R 0x7f  Be used in multiple BCNIVL early INT. When this counter =1, multiple BCNIVL early INT will be triggered. */
-#define BIT_BCNIVLCUNT_P0(x)                     ((u32)(((x) & 0x0000007F) << 24))
-#define BIT_GET_BCNIVLCUNT_P0(x)                 ((u32)(((x >> 24) & 0x0000007F)))
-#define BIT_MASK_CTWND_P0                        ((u32)0x000000FF << 16)          /*!<R/W 0x0a  CTWindow width in units of TU. PORT0 */
-#define BIT_CTWND_P0(x)                          ((u32)(((x) & 0x000000FF) << 16))
-#define BIT_GET_CTWND_P0(x)                      ((u32)(((x >> 16) & 0x000000FF)))
-#define BIT_MASK_ATIMWND1                        ((u32)0x0000FFFF << 0)          /*!<R/W 0x02  ATIM window width of VAP1 in units of TU. */
-#define BIT_ATIMWND1(x)                          ((u32)(((x) & 0x0000FFFF) << 0))
-#define BIT_GET_ATIMWND1(x)                      ((u32)(((x >> 0) & 0x0000FFFF)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_BCNDROP_TO_MISC_CTRL
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_MASK_TSF_TIMER_0_SEL                 ((u32)0x00000003 << 30)          /*!<R/W 0x0  genarete tsfime_int[0] 00: PORT0's tsft 01: PORT1's tsft 10：PORT2's tsft 11: FREERUN CUT */
-#define BIT_TSF_TIMER_0_SEL(x)                   ((u32)(((x) & 0x00000003) << 30))
-#define BIT_GET_TSF_TIMER_0_SEL(x)               ((u32)(((x >> 30) & 0x00000003)))
-#define BIT_MASK_TSF_TIMER_1_SEL                 ((u32)0x00000003 << 28)          /*!<R/W 0x0  genarete tsfime_int[1] 00: PORT0's tsft 01: PORT1's tsft 10：PORT2's tsft 11: FREERUN CUT */
-#define BIT_TSF_TIMER_1_SEL(x)                   ((u32)(((x) & 0x00000003) << 28))
-#define BIT_GET_TSF_TIMER_1_SEL(x)               ((u32)(((x >> 28) & 0x00000003)))
-#define BIT_MASK_TSF_TIMER_2_SEL                 ((u32)0x00000003 << 26)          /*!<R/W 0x0  genarete tsfime_int[2] 00: PORT0's tsft 01: PORT1's tsft 10：PORT2's tsft 11: FREERUN CUT */
-#define BIT_TSF_TIMER_2_SEL(x)                   ((u32)(((x) & 0x00000003) << 26))
-#define BIT_GET_TSF_TIMER_2_SEL(x)               ((u32)(((x >> 26) & 0x00000003)))
-#define BIT_MASK_TXCMD_TIMEOUT_PERIOD            ((u32)0x000000FF << 16)          /*!<R/W 0xFF  When 40M/80M TX CMD ready and secondary_CCA_20/secondary_CCA_40 set for this period, then the TX CMD will be cleared. TU: 1us */
-#define BIT_TXCMD_TIMEOUT_PERIOD(x)              ((u32)(((x) & 0x000000FF) << 16))
-#define BIT_GET_TXCMD_TIMEOUT_PERIOD(x)          ((u32)(((x >> 16) & 0x000000FF)))
-#define BIT_MASK_HGQ_TIMEOUT_PERIOD              ((u32)0x000000FF << 8)          /*!<R/W 0x10  When hgq empty for this period, close atim window. And this will block hgq dma for pcie, unless 0x524[12] set enable. TU: 32us */
-#define BIT_HGQ_TIMEOUT_PERIOD(x)                ((u32)(((x) & 0x000000FF) << 8))
-#define BIT_GET_HGQ_TIMEOUT_PERIOD(x)            ((u32)(((x >> 8) & 0x000000FF)))
-#define BIT_BEACON_DROP_EN                       ((u32)0x00000001 << 7)          /*!<R/W 0  enable beacon drop function */
-#define BIT_MASK_BEACON_DROP_IVL                 ((u32)0x0000007F << 0)          /*!<R/W 0  indicate the timeout of beacon drop */
-#define BIT_BEACON_DROP_IVL(x)                   ((u32)(((x) & 0x0000007F) << 0))
-#define BIT_GET_BEACON_DROP_IVL(x)               ((u32)(((x >> 0) & 0x0000007F)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_P2_TSFTR_L
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_MASK_P2_TSF_TIMER_L                  ((u32)0xFFFFFFFF << 0)          /*!<R/W 0x1  low 32bits of port2's tsft */
-#define BIT_P2_TSF_TIMER_L(x)                    ((u32)(((x) & 0xFFFFFFFF) << 0))
-#define BIT_GET_P2_TSF_TIMER_L(x)                ((u32)(((x >> 0) & 0xFFFFFFFF)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_P2_TSFTR_H
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_MASK_P2_TSF_TIMER_H                  ((u32)0xFFFFFFFF << 0)          /*!<R/W 0x1  high 32bits of port2's tsft */
-#define BIT_P2_TSF_TIMER_H(x)                    ((u32)(((x) & 0xFFFFFFFF) << 0))
-#define BIT_GET_P2_TSF_TIMER_H(x)                ((u32)(((x >> 0) & 0xFFFFFFFF)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_TSF_TIMER1
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_MASK_TSTTIMER1                       ((u32)0x07FFFFFF << 5)          /*!<R/W 0x00  When the lower 4 bytes of TSFTR matches the content of this register, the FW tsftime_int[0] interrupt is issued. */
-#define BIT_TSTTIMER1(x)                         ((u32)(((x) & 0x07FFFFFF) << 5))
-#define BIT_GET_TSTTIMER1(x)                     ((u32)(((x >> 5) & 0x07FFFFFF)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_TSF_TIMER2
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_MASK_TSTTIMER2                       ((u32)0x07FFFFFF << 5)          /*!<R/W 0x00  When the lower 4 bytes of TSFTR matches the content of this register, the FW tsftime_int[1] interrupt is issued. */
-#define BIT_TSTTIMER2(x)                         ((u32)(((x) & 0x07FFFFFF) << 5))
-#define BIT_GET_TSTTIMER2(x)                     ((u32)(((x >> 5) & 0x07FFFFFF)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_TSF_TIMER3
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_MASK_TSTTIMER3                       ((u32)0x07FFFFFF << 5)          /*!<R/W 0x00  When the lower 4 bytes of TSFTR matches the content of this register, the FW tsftime_int[2] interrupt is issued. */
-#define BIT_TSTTIMER3(x)                         ((u32)(((x) & 0x07FFFFFF) << 5))
-#define BIT_GET_TSTTIMER3(x)                     ((u32)(((x >> 5) & 0x07FFFFFF)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_BCN_IFS_TBTT_CTN
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_MASK_PRE_BCN_DMATIM                  ((u32)0x000000FF << 24)          /*!<R/W 0x06  when 0x552[3] is set, hw will enable pre_download beacon. this register Indicates the time before TBTT to perform beacon queue DMA. */
-#define BIT_PRE_BCN_DMATIM(x)                    ((u32)(((x) & 0x000000FF) << 24))
-#define BIT_GET_PRE_BCN_DMATIM(x)                ((u32)(((x >> 24) & 0x000000FF)))
-#define BIT_MASK_FORCE_BCN_IFS                   ((u32)0x000000FF << 16)          /*!<R/W 0x20  when 0x528 Bit18 set to 0 and TBTT contention area end,force tx beacon use this IFS */
-#define BIT_FORCE_BCN_IFS(x)                     ((u32)(((x) & 0x000000FF) << 16))
-#define BIT_GET_FORCE_BCN_IFS(x)                 ((u32)(((x >> 16) & 0x000000FF)))
-#define BIT_MASK_TBTT_CTN_AREA                   ((u32)0x000000FF << 0)          /*!<R/W 0x60  TBTT contention area,Time unit is 32us,for PORT 0 / 1 / 2 */
-#define BIT_TBTT_CTN_AREA(x)                     ((u32)(((x) & 0x000000FF) << 0))
-#define BIT_GET_TBTT_CTN_AREA(x)                 ((u32)(((x >> 0) & 0x000000FF)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_TXOP_CTRL_PRE_BKF
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_NOPKT_END_RTSMF                      ((u32)0x00000001 << 31)          /*!<R/W 0x1  1: enable exit rts hold mode when there is no corresponding ac pkt to tx */
-#define BIT_MASK_PRETX_US                        ((u32)0x0000000F << 27)          /*!<R/W 0x6  For wep/tkip, enable security engine earlier than mactx by this amount of time. Unit is microsecond (us) */
-#define BIT_PRETX_US(x)                          ((u32)(((x) & 0x0000000F) << 27))
-#define BIT_GET_PRETX_US(x)                      ((u32)(((x >> 27) & 0x0000000F)))
-#define BIT_DTIM_BYPASS                          ((u32)0x00000001 << 26)          /*!<R/W 0x0  1: dtim counter will keep 0 */
-#define BIT_RTS_NAV_TXOP                         ((u32)0x00000001 << 25)          /*!<R/W 0x0  enable RTS NAV protect all txop */
-#define BIT_NOT_CROSS_TXOP                       ((u32)0x00000001 << 24)          /*!<R/W 0x0  1:tx pkt cross tbtt is prohibited 0:tx pkt cross tbtt is permitted */
-#define BIT_MASK_PRE_BKF_TIME                    ((u32)0x000000FF << 16)          /*!<R/W 0x0f  when bkf timer count down this value, sel queue and gen txcmd will start */
-#define BIT_PRE_BKF_TIME(x)                      ((u32)(((x) & 0x000000FF) << 16))
-#define BIT_GET_PRE_BKF_TIME(x)                  ((u32)(((x >> 16) & 0x000000FF)))
-#define BIT_NAV_BLK_HGQ                          ((u32)0x00000001 << 15)          /*!<R/W 0x0  rxnav block HGQ */
-#define BIT_NAV_BLK_MGQ                          ((u32)0x00000001 << 14)          /*!<R/W 0x0  rxnav block MGQ */
-#define BIT_MASK_TXOP_MIN                        ((u32)0x00003FFF << 0)          /*!<R/W 0x0f  if txop counter is more than this value, than tx pkt is considered not cross tbtt */
-#define BIT_TXOP_MIN(x)                          ((u32)(((x) & 0x00003FFF) << 0))
-#define BIT_GET_TXOP_MIN(x)                      ((u32)(((x >> 0) & 0x00003FFF)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_FREERUN_CNT_L
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_MASK_FREERUN_CNT_TIMER_L             ((u32)0xFFFFFFFF << 0)          /*!<R/W 0x1  LOW 32bits of freerun cnt */
-#define BIT_FREERUN_CNT_TIMER_L(x)               ((u32)(((x) & 0xFFFFFFFF) << 0))
-#define BIT_GET_FREERUN_CNT_TIMER_L(x)           ((u32)(((x >> 0) & 0xFFFFFFFF)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_FREERUN_CNT_H
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_MASK_FREERUN_CNT_TIMER_H             ((u32)0xFFFFFFFF << 0)          /*!<R/W 0x1  high 32bits of freerun cnt */
-#define BIT_FREERUN_CNT_TIMER_H(x)               ((u32)(((x) & 0xFFFFFFFF) << 0))
-#define BIT_GET_FREERUN_CNT_TIMER_H(x)           ((u32)(((x >> 0) & 0xFFFFFFFF)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_BCN_ERLY_CTW_CTRL_P1_2
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_MASK_BCNIVLCUNT_P2                   ((u32)0x0000007F << 24)          /*!<R 0x7f  Be used in multiple BCNIVL early INT. When this counter =1, multiple BCNIVL early INT will be triggered. */
-#define BIT_BCNIVLCUNT_P2(x)                     ((u32)(((x) & 0x0000007F) << 24))
-#define BIT_GET_BCNIVLCUNT_P2(x)                 ((u32)(((x >> 24) & 0x0000007F)))
-#define BIT_MASK_CTWND_P2                        ((u32)0x000000FF << 16)          /*!<R/W 0x0a  CTWindow width in units of TU. PORT2 */
-#define BIT_CTWND_P2(x)                          ((u32)(((x) & 0x000000FF) << 16))
-#define BIT_GET_CTWND_P2(x)                      ((u32)(((x >> 16) & 0x000000FF)))
-#define BIT_MASK_BCNIVLCUNT_P1                   ((u32)0x0000007F << 8)          /*!<R 0x7f  Be used in multiple BCNIVL early INT. When this counter =1, multiple BCNIVL early INT will be triggered. */
-#define BIT_BCNIVLCUNT_P1(x)                     ((u32)(((x) & 0x0000007F) << 8))
-#define BIT_GET_BCNIVLCUNT_P1(x)                 ((u32)(((x >> 8) & 0x0000007F)))
-#define BIT_MASK_CTWND_P1                        ((u32)0x000000FF << 0)          /*!<R/W 0x0a  CTWindow width in units of TU. PORT1 */
-#define BIT_CTWND_P1(x)                          ((u32)(((x) & 0x000000FF) << 0))
-#define BIT_GET_CTWND_P1(x)                      ((u32)(((x >> 0) & 0x000000FF)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_ATIMWND2_5
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_MASK_ATIMWND5                        ((u32)0x000000FF << 24)          /*!<R/W 0x02  ATIM window width of VAP5 in units of TU. */
-#define BIT_ATIMWND5(x)                          ((u32)(((x) & 0x000000FF) << 24))
-#define BIT_GET_ATIMWND5(x)                      ((u32)(((x >> 24) & 0x000000FF)))
-#define BIT_MASK_ATIMWND4                        ((u32)0x000000FF << 16)          /*!<R/W 0x02  ATIM window width of VAP4 in units of TU. */
-#define BIT_ATIMWND4(x)                          ((u32)(((x) & 0x000000FF) << 16))
-#define BIT_GET_ATIMWND4(x)                      ((u32)(((x >> 16) & 0x000000FF)))
-#define BIT_MASK_ATIMWND3                        ((u32)0x000000FF << 8)          /*!<R/W 0x02  ATIM window width of VAP3 in units of TU. */
-#define BIT_ATIMWND3(x)                          ((u32)(((x) & 0x000000FF) << 8))
-#define BIT_GET_ATIMWND3(x)                      ((u32)(((x >> 8) & 0x000000FF)))
-#define BIT_MASK_ATIMWND2                        ((u32)0x000000FF << 0)          /*!<R/W 0x02  ATIM window width of VAP2 in units of TU. */
-#define BIT_ATIMWND2(x)                          ((u32)(((x) & 0x000000FF) << 0))
-#define BIT_GET_ATIMWND2(x)                      ((u32)(((x >> 0) & 0x000000FF)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_ATIMWND6_7_URGENT_NOLIMTHGQ
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_HIQ_NO_LMT_EN_VAP7                   ((u32)0x00000001 << 31)          /*!<R/W 0x0  1: Packet in Hi Queue Tx immediately (No constraint for ATIM Period) 0: Disable */
-#define BIT_HIQ_NO_LMT_EN_VAP6                   ((u32)0x00000001 << 30)          /*!<R/W 0x0  1: Packet in Hi Queue Tx immediately (No constraint for ATIM Period) 0: Disable */
-#define BIT_HIQ_NO_LMT_EN_VAP5                   ((u32)0x00000001 << 29)          /*!<R/W 0x0  1: Packet in Hi Queue Tx immediately (No constraint for ATIM Period) 0: Disable */
-#define BIT_HIQ_NO_LMT_EN_VAP4                   ((u32)0x00000001 << 28)          /*!<R/W 0x0  1: Packet in Hi Queue Tx immediately (No constraint for ATIM Period) 0: Disable */
-#define BIT_HIQ_NO_LMT_EN_VAP3                   ((u32)0x00000001 << 27)          /*!<R/W 0x0  1: Packet in Hi Queue Tx immediately (No constraint for ATIM Period) 0: Disable */
-#define BIT_HIQ_NO_LMT_EN_VAP2                   ((u32)0x00000001 << 26)          /*!<R/W 0x0  1: Packet in Hi Queue Tx immediately (No constraint for ATIM Period) 0: Disable */
-#define BIT_HIQ_NO_LMT_EN_VAP1                   ((u32)0x00000001 << 25)          /*!<R/W 0x0  1: Packet in Hi Queue Tx immediately (No constraint for ATIM Period) 0: Disable */
-#define BIT_HIQ_NO_LMT_EN_ROOT                   ((u32)0x00000001 << 24)          /*!<R/W 0x0  1: Packet in Hi Queue Tx immediately (No constraint for ATIM Period) 0: Disable */
-#define BIT_MASK_ATIM_URGENT                     ((u32)0x000000FF << 16)          /*!<R/W 0x01  Indicates the time before ATIM Window end . When BSSID[n] (n=0~7) has HIQ packet to send, HW only DMA BSSID[n]’s HIQ packet in this interval. (unit : TU) */
-#define BIT_ATIM_URGENT(x)                       ((u32)(((x) & 0x000000FF) << 16))
-#define BIT_GET_ATIM_URGENT(x)                   ((u32)(((x >> 16) & 0x000000FF)))
-#define BIT_MASK_ATIMWND7                        ((u32)0x000000FF << 8)          /*!<R/W 0x02  ATIM window width of VAP7 in units of TU. */
-#define BIT_ATIMWND7(x)                          ((u32)(((x) & 0x000000FF) << 8))
-#define BIT_GET_ATIMWND7(x)                      ((u32)(((x >> 8) & 0x000000FF)))
-#define BIT_MASK_ATIMWND6                        ((u32)0x000000FF << 0)          /*!<R/W 0x02  ATIM window width of VAP6 in units of TU. */
-#define BIT_ATIMWND6(x)                          ((u32)(((x) & 0x000000FF) << 0))
-#define BIT_GET_ATIMWND6(x)                      ((u32)(((x >> 0) & 0x000000FF)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_DTIM_COUNT_0_3
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_MASK_DTIM_COUNT_VAP3                 ((u32)0x000000FF << 24)          /*!<R/W 0x0   */
-#define BIT_DTIM_COUNT_VAP3(x)                   ((u32)(((x) & 0x000000FF) << 24))
-#define BIT_GET_DTIM_COUNT_VAP3(x)               ((u32)(((x >> 24) & 0x000000FF)))
-#define BIT_MASK_DTIM_COUNT_VAP2                 ((u32)0x000000FF << 16)          /*!<R/W 0x0   */
-#define BIT_DTIM_COUNT_VAP2(x)                   ((u32)(((x) & 0x000000FF) << 16))
-#define BIT_GET_DTIM_COUNT_VAP2(x)               ((u32)(((x >> 16) & 0x000000FF)))
-#define BIT_MASK_DTIM_COUNT_VAP1                 ((u32)0x000000FF << 8)          /*!<R/W 0x0   */
-#define BIT_DTIM_COUNT_VAP1(x)                   ((u32)(((x) & 0x000000FF) << 8))
-#define BIT_GET_DTIM_COUNT_VAP1(x)               ((u32)(((x >> 8) & 0x000000FF)))
-#define BIT_MASK_DTIM_COUNT_ROOT                 ((u32)0x000000FF << 0)          /*!<R/W 0x0   */
-#define BIT_DTIM_COUNT_ROOT(x)                   ((u32)(((x) & 0x000000FF) << 0))
-#define BIT_GET_DTIM_COUNT_ROOT(x)               ((u32)(((x >> 0) & 0x000000FF)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_DTIM_COUNT_4_7
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_MASK_DTIM_COUNT_VAP7                 ((u32)0x000000FF << 24)          /*!<R/W 0x0   */
-#define BIT_DTIM_COUNT_VAP7(x)                   ((u32)(((x) & 0x000000FF) << 24))
-#define BIT_GET_DTIM_COUNT_VAP7(x)               ((u32)(((x >> 24) & 0x000000FF)))
-#define BIT_MASK_DTIM_COUNT_VAP6                 ((u32)0x000000FF << 16)          /*!<R/W 0x0   */
-#define BIT_DTIM_COUNT_VAP6(x)                   ((u32)(((x) & 0x000000FF) << 16))
-#define BIT_GET_DTIM_COUNT_VAP6(x)               ((u32)(((x >> 16) & 0x000000FF)))
-#define BIT_MASK_DTIM_COUNT_VAP5                 ((u32)0x000000FF << 8)          /*!<R/W 0x0   */
-#define BIT_DTIM_COUNT_VAP5(x)                   ((u32)(((x) & 0x000000FF) << 8))
-#define BIT_GET_DTIM_COUNT_VAP5(x)               ((u32)(((x >> 8) & 0x000000FF)))
-#define BIT_MASK_DTIM_COUNT_VAP4                 ((u32)0x000000FF << 0)          /*!<R/W 0x0   */
-#define BIT_DTIM_COUNT_VAP4(x)                   ((u32)(((x) & 0x000000FF) << 0))
-#define BIT_GET_DTIM_COUNT_VAP4(x)               ((u32)(((x >> 0) & 0x000000FF)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_DISATIM_BCNERLY_TBTTHOLD_BCNCS
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_TSFTR3_SYNC_EN                       ((u32)0x00000001 << 31)          /*!<W 0x0  write this bit, PORT3 will sync to PORT2 with TSFTF_SYN_OFFSET */
-#define BIT_TSFTR2_SYNC_EN                       ((u32)0x00000001 << 29)          /*!<W 0x0  write this bit, PORT2 will sync to PORT3 with TSFTF_SYN_OFFSET */
-#define BIT_TSFTR2_RST                           ((u32)0x00000001 << 28)          /*!<W 0x0  write this bit , bcn2 tsft will auto reset */
-#define BIT_MASK_MULTI_BCN_CS                    ((u32)0x0000000F << 24)          /*!<RO 0x0  indicate which port is tx beacon */
-#define BIT_MULTI_BCN_CS(x)                      ((u32)(((x) & 0x0000000F) << 24))
-#define BIT_GET_MULTI_BCN_CS(x)                  ((u32)(((x >> 24) & 0x0000000F)))
-#define BIT_DIS_BCN_P2                           ((u32)0x00000001 << 23)          /*!<R/W 0x0  set 1 to mask the beacon early interrupt of port2 */
-#define BIT_DIS_BCN_P1                           ((u32)0x00000001 << 22)          /*!<R/W 0x0  set 1 to mask the beacon early interrupt of port1 */
-#define BIT_DIS_BCN_P0                           ((u32)0x00000001 << 21)          /*!<R/W 0x0  set 1 to mask the beacon early interrupt of port0 */
-#define BIT_MASK_TBTT_HOLD_PREDICT_P1            ((u32)0x0000001F << 16)          /*!<R/W 0x2  the predicted hold time after tbtt for beacon tx of port1, unit is 32us */
-#define BIT_TBTT_HOLD_PREDICT_P1(x)              ((u32)(((x) & 0x0000001F) << 16))
-#define BIT_GET_TBTT_HOLD_PREDICT_P1(x)          ((u32)(((x >> 16) & 0x0000001F)))
-#define BIT_MASK_EARLY_128US_P1                  ((u32)0x00000007 << 11)          /*!<R/W 0x0  the BCN EARLY interrupt find tune with unit 128us. The Total Early time of BCN early interrupt is the 0x558 x 1ms + EARLY_128us x 128us. For port 1 */
-#define BIT_EARLY_128US_P1(x)                    ((u32)(((x) & 0x00000007) << 11))
-#define BIT_GET_EARLY_128US_P1(x)                ((u32)(((x >> 11) & 0x00000007)))
-#define BIT_MASK_EARLY_128US_P0                  ((u32)0x00000007 << 8)          /*!<R/W 0x0  the BCN EARLY interrupt find tune with unit 128us. The Total Early time of BCN early interrupt is the 0x558 x 1ms + EARLY_128us x 128us. */
-#define BIT_EARLY_128US_P0(x)                    ((u32)(((x) & 0x00000007) << 8))
-#define BIT_GET_EARLY_128US_P0(x)                ((u32)(((x >> 8) & 0x00000007)))
-#define BIT_DIS_ATIM_VAP7                        ((u32)0x00000001 << 7)          /*!<R/W 0x0   */
-#define BIT_DIS_ATIM_VAP6                        ((u32)0x00000001 << 6)          /*!<R/W 0x0   */
-#define BIT_DIS_ATIM_VAP5                        ((u32)0x00000001 << 5)          /*!<R/W 0x0   */
-#define BIT_DIS_ATIM_VAP4                        ((u32)0x00000001 << 4)          /*!<R/W 0x0   */
-#define BIT_DIS_ATIM_VAP3                        ((u32)0x00000001 << 3)          /*!<R/W 0x0   */
-#define BIT_DIS_ATIM_VAP2                        ((u32)0x00000001 << 2)          /*!<R/W 0x0   */
-#define BIT_DIS_ATIM_VAP1                        ((u32)0x00000001 << 1)          /*!<R/W 0x0   */
-#define BIT_DIS_ATIM_ROOT                        ((u32)0x00000001 << 0)          /*!<R/W 0x0   */
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_FREERUN_CNT_P2POFF_DIS_TXTIME
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_MASK_P2POFF_DIS_TXTIME               ((u32)0x000000FF << 24)          /*!<R/W 0x0  The time of the disable TX period after the P2P RF off interrupt occur. Unit: 64us. */
-#define BIT_P2POFF_DIS_TXTIME(x)                 ((u32)(((x) & 0x000000FF) << 24))
-#define BIT_GET_P2POFF_DIS_TXTIME(x)             ((u32)(((x >> 24) & 0x000000FF)))
-#define BIT_EN_FREECNT                           ((u32)0x00000001 << 13)          /*!<R/W 0x0  enable freerun tsft */
-#define BIT_RESET_FREECNT_P                      ((u32)0x00000001 << 12)          /*!<W 0x0  reset pulse of freerun tsft */
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_PTA_TRXBCN_CTRL
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_PTA_RXBCN_PRI_MASK                   ((u32)0x00000001 << 31)          /*!<R/W 0x1   */
-#define BIT_PTA_RXBCN_EN                         ((u32)0x00000001 << 30)          /*!<R/W 0x1   */
-#define BIT_PTA_RXBCN_DIR                        ((u32)0x00000001 << 29)          /*!<R/W 0x1   */
-#define BIT_MASK_PTA_RXBCN_DUR                   ((u32)0x000001FF << 20)          /*!<R/W 0x60   */
-#define BIT_PTA_RXBCN_DUR(x)                     ((u32)(((x) & 0x000001FF) << 20))
-#define BIT_GET_PTA_RXBCN_DUR(x)                 ((u32)(((x >> 20) & 0x000001FF)))
-#define BIT_MASK_PTA_RXBCN_TIME                  ((u32)0x0000007F << 13)          /*!<R/W 0x6   */
-#define BIT_PTA_RXBCN_TIME(x)                    ((u32)(((x) & 0x0000007F) << 13))
-#define BIT_GET_PTA_RXBCN_TIME(x)                ((u32)(((x >> 13) & 0x0000007F)))
-#define BIT_PTA_PRETX_EN                         ((u32)0x00000001 << 12)          /*!<R/W 0x1   */
-#define BIT_MASK_PTA_PRETX_TIME                  ((u32)0x00000FFF << 0)          /*!<R/W 0x64  WIFI TX shall wait settle time when antenna is switched from BT to WIFI, if the BT use the same RFAFE as WIFI. Unit: 1us */
-#define BIT_PTA_PRETX_TIME(x)                    ((u32)(((x) & 0x00000FFF) << 0))
-#define BIT_GET_PTA_PRETX_TIME(x)                ((u32)(((x >> 0) & 0x00000FFF)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_P2P_NOA1_CTRL_STATE
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_POWER_STATE_1                        ((u32)0x00000001 << 31)          /*!<RO   1: On, 0: Off. (It is including early time. ) */
-#define BIT_CTWINDOW_ON_1                        ((u32)0x00000001 << 30)          /*!<RO   Spec time and Beacon Early Time to TBTT Time. (It is including early time. ) */
-#define BIT_BEACON_AREA_ON_1                     ((u32)0x00000001 << 29)          /*!<RO   The time is from HOLD Time to BeaconTx or Timeout. (It is including early time. ) */
-#define BIT_CTWIN_EARLY_DISTX_1                  ((u32)0x00000001 << 28)          /*!<RO   ctwin_early_distx. (It is including early time. ) */
-#define BIT_NOA1_OFF_PERIOD_1                    ((u32)0x00000001 << 27)          /*!<RO   Spec time but exclude BCNDMATIM time for wake. (It is including early time. ) */
-#define BIT_FORCE_DOZE1_1                        ((u32)0x00000001 << 26)          /*!<RO   If NoA_Count == 1, this value is 1. else 0. (It is including early time. ) */
-#define BIT_NOA0_OFF_PERIOD_1                    ((u32)0x00000001 << 25)          /*!<RO   Spec time but exclude BCNDMATIM time for wake. (It is including early time. ) */
-#define BIT_FORCE_DOZE0_1                        ((u32)0x00000001 << 24)          /*!<RO   If NoA_Count == 1, this value is 1. else 0. (It is including early time. ) */
-#define BIT_SPEC_POWER_STATE_1                   ((u32)0x00000001 << 23)          /*!<RO   1: On, 0: Off */
-#define BIT_SPEC_CTWINDOW_ON_1                   ((u32)0x00000001 << 22)          /*!<RO   The time from TBTT <-> CTWEND (with BCNDMATIM early time) */
-#define BIT_SPEC_BEACON_AREA_ON_1                ((u32)0x00000001 << 21)          /*!<RO   The time is from TBTT to BeaconTx or Timeout */
-#define BIT_SPEC_CTWIN_EARLY_DISTX_1             ((u32)0x00000001 << 20)          /*!<RO   ctwin_early_distx */
-#define BIT_SPEC_NOA1_OFF_PERIOD_1               ((u32)0x00000001 << 19)          /*!<RO   Spec time */
-#define BIT_SPEC_FORCE_DOZE1_1                   ((u32)0x00000001 << 18)          /*!<RO   If NoA_Count == 1, this value is 1. else 0. */
-#define BIT_SPEC_NOA0_OFF_PERIOD_1               ((u32)0x00000001 << 17)          /*!<RO   Spec time */
-#define BIT_SPEC_FORCE_DOZE0_1                   ((u32)0x00000001 << 16)          /*!<RO   If NoA_Count == 1, this value is 1. else 0. */
-#define BIT_P2P_NOA1_ALLSTASLEEP                 ((u32)0x00000001 << 7)          /*!<R/W 0x0  It indicates that the state from CTWindow End to BcnEarly 1: Sleep 0: Wake */
-#define BIT_P2P_NOA1_DISTX_EN                    ((u32)0x00000001 << 6)          /*!<R/W 0x0  1: Hw will disable TX in P2P_off period 0: Do Nothing */
-#define BIT_P2P_NOA1_PWR_MGT_EN                  ((u32)0x00000001 << 5)          /*!<R/W 0x0  A main switch for P2P PowerSaving 1: Enable 0: Disable */
-#define BIT_MASK_P2P_NOA1_EN                     ((u32)0x00000003 << 3)          /*!<R/W 0x0  The condition that noa_unit0, [1]-NOA1, [0]-NOA0 1: Enable 0: Disable */
-#define BIT_P2P_NOA1_EN(x)                       ((u32)(((x) & 0x00000003) << 3))
-#define BIT_GET_P2P_NOA1_EN(x)                   ((u32)(((x >> 3) & 0x00000003)))
-#define BIT_MASK_P2P_NOA1_UNIT_SEL               ((u32)0x00000003 << 1)          /*!<R/W 0x0  The selector for the source of noa unit0. 0 for port 0, 1 for port 1 */
-#define BIT_P2P_NOA1_UNIT_SEL(x)                 ((u32)(((x) & 0x00000003) << 1))
-#define BIT_GET_P2P_NOA1_UNIT_SEL(x)             ((u32)(((x >> 1) & 0x00000003)))
-#define BIT_EN_TSFBIT32_RST_NOA1                 ((u32)0x00000001 << 0)          /*!<R/W 0x1   */
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_ACMHWCTRL
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_MASK_AVGPERIOD                       ((u32)0x0000FFFF << 16)          /*!<R/W 0x00  In unit of 32 us. It is the value Dot11EDCAAveragingPeriod in SPEC. HW will recalculate used_time every this period. Max is 2 sec */
-#define BIT_AVGPERIOD(x)                         ((u32)(((x) & 0x0000FFFF) << 16))
-#define BIT_GET_AVGPERIOD(x)                     ((u32)(((x >> 16) & 0x0000FFFF)))
-#define BIT_BE_ACM_RESET_USED_TIME               ((u32)0x00000001 << 10)          /*!<W 0x0  When HwEn is enabled, software set this bit to inform hardware to reset used_time to 0. Read this bit is always 0. */
-#define BIT_VI_ACM_RESET_USED_TIME               ((u32)0x00000001 << 9)          /*!<W 0x0  When HwEn is enabled, software set this bit to inform hardware to reset used_time to 0. Read this bit is always 0. */
-#define BIT_VO_ACM_RESET_USED_TIME               ((u32)0x00000001 << 8)          /*!<W 0x0  When HwEn is enabled, software set this bit to inform hardware to reset used_time to 0. Read this bit is always 0. */
-#define BIT_BEQ_ACM_STATUS                       ((u32)0x00000001 << 7)          /*!<R 0x0  This bit indicates if the used_time >= admitted_time of AC BE when HW ACM. 0: BEQ ACM Not Exceed. 1: BEQ ACM Exceed. Default: 0h */
-#define BIT_VIQ_ACM_STATUS                       ((u32)0x00000001 << 6)          /*!<R 0x0  This bit indicates if the used_time >= admitted_time of AC VI when HW ACM. 0: VIQ ACM Not Exceed. 1: VIQ ACM Exceed. Default: 0h */
-#define BIT_VOQ_ACM_STATUS                       ((u32)0x00000001 << 5)          /*!<R 0x0  This bit indicates if the used_time >= admitted_time of AC VO when HW ACM. 0: VOQ ACM Not Exceed. 1: VOQ ACM Exceed. Default: 0h */
-#define BIT_BEQ_ACM_EN                           ((u32)0x00000001 << 3)          /*!<R/W 0x0  Set this bit to enable ACM of BE queue. 1: Enable 0: Disable Default: 0h */
-#define BIT_VIQ_ACM_EN                           ((u32)0x00000001 << 2)          /*!<R/W 0x0  Set this bit to enable ACM of VI queue. 1: Enable 0: Disable Default: 0h. */
-#define BIT_VOQ_ACM_EN                           ((u32)0x00000001 << 1)          /*!<R/W 0x0  Set this bit to enable ACM of VO queue. 1: Enable 0: Disable Default: 0h. */
-#define BIT_ACMHWEN                              ((u32)0x00000001 << 0)          /*!<R/W 0x0  Set this bit to enable hardware to take control of ACM. 1: Hardware Control 0: Software Control Default: 0h. */
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_VO_VI_ADMTIME
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_MASK_VI_ADMITTED_TIME                ((u32)0x0000FFFF << 16)          /*!<R/W 0x00  Admitted_time of VI queue. In unit of 32 microsecond. Calculated and set by driver. */
-#define BIT_VI_ADMITTED_TIME(x)                  ((u32)(((x) & 0x0000FFFF) << 16))
-#define BIT_GET_VI_ADMITTED_TIME(x)              ((u32)(((x >> 16) & 0x0000FFFF)))
-#define BIT_MASK_VO_ADMITTED_TIME                ((u32)0x0000FFFF << 0)          /*!<R/W 0x00  Admitted_time of VO queue. In unit of 32 microsecond. Calculated and set by driver. */
-#define BIT_VO_ADMITTED_TIME(x)                  ((u32)(((x) & 0x0000FFFF) << 0))
-#define BIT_GET_VO_ADMITTED_TIME(x)              ((u32)(((x >> 0) & 0x0000FFFF)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_BE_ADMTIME
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_DIS_NDPA_NAV_CHK                     ((u32)0x00000001 << 24)          /*!<R/W 0x0  1-->tx NDPA/NDP can cross TBTT,0-->tx NDPA/NDP can't cross TBTT */
-#define BIT_MASK_MHDR_NAV_OFFSET                 ((u32)0x000000FF << 16)          /*!<R/W 0x0  NDPA NAV compensation value */
-#define BIT_MHDR_NAV_OFFSET(x)                   ((u32)(((x) & 0x000000FF) << 16))
-#define BIT_GET_MHDR_NAV_OFFSET(x)               ((u32)(((x >> 16) & 0x000000FF)))
-#define BIT_MASK_BE_ADMITTED_TIME                ((u32)0x0000FFFF << 0)          /*!<R/W 0x00  Admitted_time of BE queue. In unit of 32 microsecond. Calculated and set by driver. */
-#define BIT_BE_ADMITTED_TIME(x)                  ((u32)(((x) & 0x0000FFFF) << 0))
-#define BIT_GET_BE_ADMITTED_TIME(x)              ((u32)(((x >> 0) & 0x0000FFFF)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_NOACMD_SEL_EDCA_RANDOM_GEN
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_MASK_NOA_SEL                         ((u32)0x00000007 << 28)          /*!<R/W 0x0  TX NoA parameter select (noa_unit0~2,parameter0~5) 0: NoA0 , 1:NoA1, 2:NoA2, 3:NoA3, 4:NoA4, default: NoA5 To control the register setting for which NOA. (register 0x05E0[103:0]) */
-#define BIT_NOA_SEL(x)                           ((u32)(((x) & 0x00000007) << 28))
-#define BIT_GET_NOA_SEL(x)                       ((u32)(((x >> 28) & 0x00000007)))
-#define BIT_MASK_TXCMD_SEG_SEL                   ((u32)0x0000000F << 24)          /*!<R/W 0x1  [HW Debug Info]To select which one TXCMD Segment. For example, 可以在0x5CF[3:0]填 0 or 6 讀取 0x5F8[7:0] : Tx Agg 0x5F9[7:0] : Tx Rate */
-#define BIT_TXCMD_SEG_SEL(x)                     ((u32)(((x) & 0x0000000F) << 24))
-#define BIT_GET_TXCMD_SEG_SEL(x)                 ((u32)(((x >> 24) & 0x0000000F)))
-#define BIT_MASK_RANDOM_GEN                      ((u32)0x00FFFFFF << 0)          /*!<R/W 0xe21051  Random number generator polynomial */
-#define BIT_RANDOM_GEN(x)                        ((u32)(((x) & 0x00FFFFFF) << 0))
-#define BIT_GET_RANDOM_GEN(x)                    ((u32)(((x >> 0) & 0x00FFFFFF)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_TXPAUSE_CFG
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_MASK_TSF_DIFF_P1P2                   ((u32)0x0000FFFF << 16)          /*!<R 0x0  the difference of beacon count down value between port0 and port1, unit is TU */
-#define BIT_TSF_DIFF_P1P2(x)                     ((u32)(((x) & 0x0000FFFF) << 16))
-#define BIT_GET_TSF_DIFF_P1P2(x)                 ((u32)(((x >> 16) & 0x0000FFFF)))
-#define BIT_MASK_TXPAUSE1                        ((u32)0x000000FF << 8)          /*!<R/W 0x0  same as 0x522[7:0], allow FW/DR to control pause jointly */
-#define BIT_TXPAUSE1(x)                          ((u32)(((x) & 0x000000FF) << 8))
-#define BIT_GET_TXPAUSE1(x)                      ((u32)(((x >> 8) & 0x000000FF)))
-#define BIT_MASK_DRVERLYITV_P2                   ((u32)0x000000FF << 0)          /*!<R/W 0x05  Time to send interrupt to notify driver to change beacon content. Time unit is TU. It is used to wake up early at DriverEarlyTime. For port 2 */
-#define BIT_DRVERLYITV_P2(x)                     ((u32)(((x) & 0x000000FF) << 0))
-#define BIT_GET_DRVERLYITV_P2(x)                 ((u32)(((x >> 0) & 0x000000FF)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_NAN_SETTING
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_EN_MULTI_BCN                         ((u32)0x00000001 << 31)          /*!<R/W 0x1  enable multiple beacons of port0~port2 */
-#define BIT_ENP2P_DW_AREA                        ((u32)0x00000001 << 30)          /*!<R/W 0x0  DW condition for P2P,for port2 */
-#define BIT_MASK_TBTT_PROHIBIT_HOLD_P2           ((u32)0x00000FFF << 18)          /*!<R/W 0x100  the predicted hold time after tbtt for beacon tx of port2, unit is 32us */
-#define BIT_TBTT_PROHIBIT_HOLD_P2(x)             ((u32)(((x) & 0x00000FFF) << 18))
-#define BIT_GET_TBTT_PROHIBIT_HOLD_P2(x)         ((u32)(((x >> 18) & 0x00000FFF)))
-#define BIT_MASK_BCN_PORT_PRI                    ((u32)0x00000003 << 16)          /*!<R/W 0x1  the priority of port0 and port2. 10: port2 has higher priority than port0; 01:port0 has higher priority than port2. 00: port0 and port2 have the same priority */
-#define BIT_BCN_PORT_PRI(x)                      ((u32)(((x) & 0x00000003) << 16))
-#define BIT_GET_BCN_PORT_PRI(x)                  ((u32)(((x >> 16) & 0x00000003)))
-#define BIT_MASK_DRVERLYITV_P1                   ((u32)0x000000FF << 8)          /*!<R/W 0x05  Time to send interrupt to notify driver to change beacon content. Time unit is TU. It is used to wake up early at DriverEarlyTime. For port1 */
-#define BIT_DRVERLYITV_P1(x)                     ((u32)(((x) & 0x000000FF) << 8))
-#define BIT_GET_DRVERLYITV_P1(x)                 ((u32)(((x >> 8) & 0x000000FF)))
-#define BIT_P2_RXBCN_RPT_ENABLE                  ((u32)0x00000001 << 7)          /*!<R/W 0x0  When this bit asserted, RXBCNOK report is issued */
-#define BIT_P2_DIS_RX_BSSID_FIT                  ((u32)0x00000001 << 6)          /*!<R/W 0x0  0:HW will handle rx_beacon 1:HW will ignore rx_beacon_pk */
-#define BIT_P2_TXBCN_RPT_ENABLE                  ((u32)0x00000001 << 5)          /*!<R/W 0x0  When this bit asserted, then TXBCN ERROR report is issued */
-#define BIT_P2_DIS_TSF_UDT                       ((u32)0x00000001 << 4)          /*!<R/W 0x1  When set, disable clint 2 TSF update when beacon frames or probe response frames are received. */
-#define BIT_P2_EN_BCN_FUNCTION                   ((u32)0x00000001 << 3)          /*!<R/W 0x0  When this bit is set, TSF and other beacon related functions are then enabled. */
-#define BIT_P2_EN_BCN_RPT                        ((u32)0x00000001 << 2)          /*!<R/W 0x1  When this bit asserted, txbcnok_int and txbcnerr_int will valid. */
-#define BIT_P2_ENP2P_CTWINDOW                    ((u32)0x00000001 << 1)          /*!<R/W 0x0  1: Enable P2P CTN WINDOWS function. 0: Disable P2P CTN WINDOWS function. */
-#define BIT_P2_ENP2P_BCNQ_AREA                   ((u32)0x00000001 << 0)          /*!<R/W 0x0  1: Enable P2P BCN area on function. 0 : Disable P2P BCN area on function. */
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_BCN_SPACE_PORT1_2
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_MASK_BCN_SPACE4                      ((u32)0x0000FFFF << 16)          /*!<R/W 0x200  sync beacon space of port2 */
-#define BIT_BCN_SPACE4(x)                        ((u32)(((x) & 0x0000FFFF) << 16))
-#define BIT_GET_BCN_SPACE4(x)                    ((u32)(((x >> 16) & 0x0000FFFF)))
-#define BIT_MASK_BCN_SPACE3                      ((u32)0x0000FFFF << 0)          /*!<R/W 0x64  sync beacon space of port1 */
-#define BIT_BCN_SPACE3(x)                        ((u32)(((x) & 0x0000FFFF) << 0))
-#define BIT_GET_BCN_SPACE3(x)                    ((u32)(((x >> 0) & 0x0000FFFF)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_NAN_SETTING_1
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_MASK_SYNCBCN_RXNUM                   ((u32)0x0000001F << 27)          /*!<R/W 0x0  if DW is permitted to end early, the number of rx sync beacons is defined in this register */
-#define BIT_SYNCBCN_RXNUM(x)                     ((u32)(((x) & 0x0000001F) << 27))
-#define BIT_GET_SYNCBCN_RXNUM(x)                 ((u32)(((x >> 27) & 0x0000001F)))
-#define BIT_DW_END_EARLY                         ((u32)0x00000001 << 26)          /*!<R/W 0x0  when set, the DW window end earlier than spec definition. When sync bcn and SDF had tx, and rx enough sync bcns defined by 0x5DC[31:27]. DW can early end */
-#define BIT_MASK_NAN_ROLE                        ((u32)0x00000003 << 24)          /*!<R/W 0x0  the role of NAN device, including master, no-master sync, and no-master no-sync. */
-#define BIT_NAN_ROLE(x)                          ((u32)(((x) & 0x00000003) << 24))
-#define BIT_GET_NAN_ROLE(x)                      ((u32)(((x >> 24) & 0x00000003)))
-#define BIT_MASK_MSLOT_EVTQ                      ((u32)0x000000FF << 16)          /*!<R/W 0x0  evtq packet will tx in the m-th SLOT of the m-th DWs */
-#define BIT_MSLOT_EVTQ(x)                        ((u32)(((x) & 0x000000FF) << 16))
-#define BIT_GET_MSLOT_EVTQ(x)                    ((u32)(((x >> 16) & 0x000000FF)))
-#define BIT_MASK_MDW_EVTQ                        ((u32)0x000000FF << 8)          /*!<R/W 0x0  evtq packet will tx in the m-th SLOT of the m-th DWs */
-#define BIT_MDW_EVTQ(x)                          ((u32)(((x) & 0x000000FF) << 8))
-#define BIT_GET_MDW_EVTQ(x)                      ((u32)(((x >> 8) & 0x000000FF)))
-#define BIT_MASK_EVTQ_EARLY                      ((u32)0x00000007 << 5)          /*!<R/W 0x1  the early time of evtq tx window. unit is TU */
-#define BIT_EVTQ_EARLY(x)                        ((u32)(((x) & 0x00000007) << 5))
-#define BIT_GET_EVTQ_EARLY(x)                    ((u32)(((x >> 5) & 0x00000007)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_NOA_PARAM_V1
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_MASK_NOA_DURATION_V1                 ((u32)0xFFFFFFFF << 0)          /*!<R/W 0x00001000  The maximum duration in units of microseconds that the P2P Group Owner shall remain absent following the start of a Notice of Absence interval. */
-#define BIT_NOA_DURATION_V1(x)                   ((u32)(((x) & 0xFFFFFFFF) << 0))
-#define BIT_GET_NOA_DURATION_V1(x)               ((u32)(((x >> 0) & 0xFFFFFFFF)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_NOA_PARAM_V2
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_MASK_NOA_INTERVAL_V2                 ((u32)0xFFFFFFFF << 0)          /*!<R/W 0x00003000  The length of the Notice of Absence interval in units of microseconds. */
-#define BIT_NOA_INTERVAL_V2(x)                   ((u32)(((x) & 0xFFFFFFFF) << 0))
-#define BIT_GET_NOA_INTERVAL_V2(x)               ((u32)(((x >> 0) & 0xFFFFFFFF)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_NOA_PARAM_V3
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_MASK_NOA_START_TIME_V3               ((u32)0xFFFFFFFF << 0)          /*!<R/W 0x00001000  The start time for the schedule expressed in terms of the lower 4 bytes of the TSF timer. */
-#define BIT_NOA_START_TIME_V3(x)                 ((u32)(((x) & 0xFFFFFFFF) << 0))
-#define BIT_GET_NOA_START_TIME_V3(x)             ((u32)(((x >> 0) & 0xFFFFFFFF)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_NOA_PARAM_4
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_MASK_NOA_COUNT_V4                    ((u32)0x000000FF << 0)          /*!<R/W 0x03  indicates the number of absence intervals */
-#define BIT_NOA_COUNT_V4(x)                      ((u32)(((x) & 0x000000FF) << 0))
-#define BIT_GET_NOA_COUNT_V4(x)                  ((u32)(((x >> 0) & 0x000000FF)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_SCHEDULER_DBG
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_MASK_DBG_SCHEDULER                   ((u32)0xFFFFFFFF << 0)          /*!<R 0x0   */
-#define BIT_DBG_SCHEDULER(x)                     ((u32)(((x) & 0xFFFFFFFF) << 0))
-#define BIT_GET_DBG_SCHEDULER(x)                 ((u32)(((x >> 0) & 0xFFFFFFFF)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_SCH_TXCMD
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_MASK_SCH_TXCMD                       ((u32)0xFFFFFFFF << 0)          /*!<R 0x0  Scheduler TXCMD Content */
-#define BIT_SCH_TXCMD(x)                         ((u32)(((x) & 0xFFFFFFFF) << 0))
-#define BIT_GET_SCH_TXCMD(x)                     ((u32)(((x >> 0) & 0xFFFFFFFF)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_PAGE5_DUMMY
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_MASK_DUMMY                           ((u32)0xFFFFFFFF << 0)          /*!<R/W 0xffff0000  Dummy */
-#define BIT_DUMMY(x)                             ((u32)(((x) & 0xFFFFFFFF) << 0))
-#define BIT_GET_DUMMY(x)                         ((u32)(((x >> 0) & 0xFFFFFFFF)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_PS_TIMER_A_L
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_MASK_PS_TIMER_A_L                    ((u32)0xFFFFFFFF << 0)          /*!<R/W 0x0  When the TSF (that select by reg 0x1520 [25：24]) matches the content of this register, the PS_TIMER_A_INT interrupt is issued */
-#define BIT_PS_TIMER_A_L(x)                      ((u32)(((x) & 0xFFFFFFFF) << 0))
-#define BIT_GET_PS_TIMER_A_L(x)                  ((u32)(((x >> 0) & 0xFFFFFFFF)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_PS_TIMER_A_H
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_MASK_PS_TIMER_A_H                    ((u32)0xFFFFFFFF << 0)          /*!<R/W 0x0  When the TSF (that select by reg 0x1520 [25：24]) matches the content of this register, the PS_TIMER_A_INT interrupt is issued */
-#define BIT_PS_TIMER_A_H(x)                      ((u32)(((x) & 0xFFFFFFFF) << 0))
-#define BIT_GET_PS_TIMER_A_H(x)                  ((u32)(((x >> 0) & 0xFFFFFFFF)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_PS_TIMER_B_L
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_MASK_PS_TIMER_B_L                    ((u32)0xFFFFFFFF << 0)          /*!<R/W 0x0  When the TSF (that select by reg 0x1520 [29:28]) matches the content of this register, the PS_TIMER_B_INT interrupt is issued */
-#define BIT_PS_TIMER_B_L(x)                      ((u32)(((x) & 0xFFFFFFFF) << 0))
-#define BIT_GET_PS_TIMER_B_L(x)                  ((u32)(((x >> 0) & 0xFFFFFFFF)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_PS_TIMER_B_H
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_MASK_PS_TIMER_B_H                    ((u32)0xFFFFFFFF << 0)          /*!<R/W 0x0  When the TSF(that select by reg 0x1520 [29:28]) matches the content of this register, the PS_TIMER_B_INT interrupt is issued */
-#define BIT_PS_TIMER_B_H(x)                      ((u32)(((x) & 0xFFFFFFFF) << 0))
-#define BIT_GET_PS_TIMER_B_H(x)                  ((u32)(((x >> 0) & 0xFFFFFFFF)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_PS_TIMER_C_L
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_MASK_PS_TIMER_C_L                    ((u32)0xFFFFFFFF << 0)          /*!<R/W 0x0  When the TSF(that select by reg 0x1520 [21:20]) matches the content of this register, the PS_TIMER_C_INT interrupt is issued */
-#define BIT_PS_TIMER_C_L(x)                      ((u32)(((x) & 0xFFFFFFFF) << 0))
-#define BIT_GET_PS_TIMER_C_L(x)                  ((u32)(((x >> 0) & 0xFFFFFFFF)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_PS_TIMER_C_H
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_MASK_PS_TIMER_C_H                    ((u32)0xFFFFFFFF << 0)          /*!<R/W 0x0  When the TSF(that select by reg 0x1520 [21:20]) matches the content of this register, the PS_TIMER_C_INT interrupt is issued */
-#define BIT_PS_TIMER_C_H(x)                      ((u32)(((x) & 0xFFFFFFFF) << 0))
-#define BIT_GET_PS_TIMER_C_H(x)                  ((u32)(((x >> 0) & 0xFFFFFFFF)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_CPUMGQ_PARAMETER
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_MASK_PS_TIMER_E_EARLY                ((u32)0x000000FF << 24)          /*!<R/W 0x0  It is used to wake up early at PS_Timer_E_Early Time. Time unit is TU. */
-#define BIT_PS_TIMER_E_EARLY(x)                  ((u32)(((x) & 0x000000FF) << 24))
-#define BIT_GET_PS_TIMER_E_EARLY(x)              ((u32)(((x >> 24) & 0x000000FF)))
-#define BIT_MASK_CW                              ((u32)0x000000FF << 8)          /*!<R/W 0x32  ECWmin and ECWmax encode the values of Cwmin and Cwmax respectively in an exponent form. Ex: Cwmax = 2^(ECWmax)-1 Default: BK = Ah/5h; BE = Ah/5h; VI = 5h/4h; VO = 4h/3h. */
-#define BIT_CW(x)                                ((u32)(((x) & 0x000000FF) << 8))
-#define BIT_GET_CW(x)                            ((u32)(((x >> 8) & 0x000000FF)))
-#define BIT_MASK_AIFS                            ((u32)0x000000FF << 0)          /*!<R/W 0x24  Arbitrary Inter frame space In unit of microsecond. AIFS indicates the time a non-AP QSTA should defer before either invoking a backoff or starting a transmission Default: BK = 49h; BE = 25h; VI = 1Ch; VO = 1Ch */
-#define BIT_AIFS(x)                              ((u32)(((x) & 0x000000FF) << 0))
-#define BIT_GET_AIFS(x)                          ((u32)(((x >> 0) & 0x000000FF)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_PS_Timer_Early
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_MASK_PS_TIMER_D_EARLY                ((u32)0x000000FF << 24)          /*!<R/W 0x0  It is used to wake up early at PS_Timer_D_Early Time. Time unit is TU. */
-#define BIT_PS_TIMER_D_EARLY(x)                  ((u32)(((x) & 0x000000FF) << 24))
-#define BIT_GET_PS_TIMER_D_EARLY(x)              ((u32)(((x >> 24) & 0x000000FF)))
-#define BIT_MASK_PS_TIMER_C_EARLY                ((u32)0x000000FF << 16)          /*!<R/W 0x0  It is used to wake up early at PS_Timer_C_Early Time. Time unit is TU. */
-#define BIT_PS_TIMER_C_EARLY(x)                  ((u32)(((x) & 0x000000FF) << 16))
-#define BIT_GET_PS_TIMER_C_EARLY(x)              ((u32)(((x >> 16) & 0x000000FF)))
-#define BIT_MASK_PS_TIMER_B_EARLY                ((u32)0x000000FF << 8)          /*!<R/W 0x0  It is used to wake up early at PS_Timer_B_Early Time. Time unit is TU. */
-#define BIT_PS_TIMER_B_EARLY(x)                  ((u32)(((x) & 0x000000FF) << 8))
-#define BIT_GET_PS_TIMER_B_EARLY(x)              ((u32)(((x >> 8) & 0x000000FF)))
-#define BIT_MASK_PS_TIMER_A_EARLY                ((u32)0x000000FF << 0)          /*!<R/W 0x0  It is used to wake up early at PS_Timer_A_Early Time. Time unit is TU. */
-#define BIT_PS_TIMER_A_EARLY(x)                  ((u32)(((x) & 0x000000FF) << 0))
-#define BIT_GET_PS_TIMER_A_EARLY(x)              ((u32)(((x >> 0) & 0x000000FF)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_PS_TIMER_TWT_CRTL
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_PS_TIMER_A_EN                        ((u32)0x00000001 << 31)          /*!<R/W 0x0  Enable PS_TIMER_B */
-#define BIT_MASK_PS_TIMER_A_TSF_SEL              ((u32)0x00000003 << 28)          /*!<R/W 0x0  0 for port 0, 1 for port1, 2 for port2, 3 for freerun */
-#define BIT_PS_TIMER_A_TSF_SEL(x)                ((u32)(((x) & 0x00000003) << 28))
-#define BIT_GET_PS_TIMER_A_TSF_SEL(x)            ((u32)(((x >> 28) & 0x00000003)))
-#define BIT_PS_TIMER_B_EN                        ((u32)0x00000001 << 27)          /*!<R/W 0x0  Enable PS_TIMER_A */
-#define BIT_MASK_PS_TIMER_B_TSF_SEL              ((u32)0x00000003 << 24)          /*!<R/W 0x0  0 for port 0, 1 for port1, 2 for port2, 3 for freerun */
-#define BIT_PS_TIMER_B_TSF_SEL(x)                ((u32)(((x) & 0x00000003) << 24))
-#define BIT_GET_PS_TIMER_B_TSF_SEL(x)            ((u32)(((x >> 24) & 0x00000003)))
-#define BIT_PS_TIMER_C_EN                        ((u32)0x00000001 << 23)          /*!<R/W 0x0  Enable PS_TIMER_C */
-#define BIT_MASK_PS_TIMER_C_TSF_SEL              ((u32)0x00000003 << 20)          /*!<R/W 0x0  0 for port 0, 1 for port1, 2 for port2, 3 for freerun */
-#define BIT_PS_TIMER_C_TSF_SEL(x)                ((u32)(((x) & 0x00000003) << 20))
-#define BIT_GET_PS_TIMER_C_TSF_SEL(x)            ((u32)(((x >> 20) & 0x00000003)))
-#define BIT_PS_TIMER_D_EN                        ((u32)0x00000001 << 19)          /*!<R/W 0x0  Enable PS_TIMER_D */
-#define BIT_MASK_PS_TIMER_D_TSF_SEL              ((u32)0x00000003 << 16)          /*!<R/W 0x0  0 for port 0, 1 for port1, 2 for port2, 3 for freerun */
-#define BIT_PS_TIMER_D_TSF_SEL(x)                ((u32)(((x) & 0x00000003) << 16))
-#define BIT_GET_PS_TIMER_D_TSF_SEL(x)            ((u32)(((x >> 16) & 0x00000003)))
-#define BIT_PS_TIMER_E_EN                        ((u32)0x00000001 << 15)          /*!<R/W 0x0  Enable PS_TIMER_E */
-#define BIT_MASK_PS_TIMER_E_TSF_SEL              ((u32)0x00000003 << 12)          /*!<R/W 0x0  0 for port 0, 1 for port1, 2 for port2, 3 for freerun */
-#define BIT_PS_TIMER_E_TSF_SEL(x)                ((u32)(((x) & 0x00000003) << 12))
-#define BIT_GET_PS_TIMER_E_TSF_SEL(x)            ((u32)(((x >> 12) & 0x00000003)))
-#define BIT_GET_TSFT_OFFSET_EN                   ((u32)0x00000001 << 1)          /*!<R/W 0x0  1: Enable Enable get TSFT offset function */
-#define BIT_RXBCN_TIME_PORT                      ((u32)0x00000001 << 0)          /*!<R/W 0x0  select port for report the TSFT 0: port0 1: port1 default is port0. */
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_RX_TSFT_DIFF
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_RXBCN_TIME_VLD                       ((u32)0x00000001 << 31)          /*!<R/W1C   1: indicate [30:0] is valid. Write 1 to clear this bit */
-#define BIT_RXBCN_TIME_DIFF_DIR                  ((u32)0x00000001 << 30)          /*!<R   1: wmac_rx_tsf > TSFT 0: wmac_rx_tsf <= TSFT */
-#define BIT_MASK_RXBCN_TIME_DIFF                 ((u32)0x3FFFFFFF << 0)          /*!<R   unit:1us wmac_rx_tsf - TSFT (selected by 0x1520[0]). [30] is the sign bit */
-#define BIT_RXBCN_TIME_DIFF(x)                   ((u32)(((x) & 0x3FFFFFFF) << 0))
-#define BIT_GET_RXBCN_TIME_DIFF(x)               ((u32)(((x >> 0) & 0x3FFFFFFF)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_RXBCN_TSFT_STATISTIC
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_UPD_TSFT_EARLY                       ((u32)0x00000001 << 31)          /*!<R/W 0x1  0: don't update TSFT when the following scenarios occur: tim_no_hit, |TSFT - rxbcn.timestamp| <= BIT_RXBCN_TSFT_THRES, and r_wait_rxbcn_finish = 1 1: update TSFT */
-#define BIT_MASK_RXBCN_TSFT_THRES                ((u32)0x00001FFF << 16)          /*!<R/W 0x0  used for LPS MAC, if |TSFT - rxbcn.timestamp| > BIT_RXBCN_TSFT_THRES, need to wait fcsok. Else, update TSFT at wmac_rxtsf_rdy (before fcsok) unit is 1us,max is 8ms */
-#define BIT_RXBCN_TSFT_THRES(x)                  ((u32)(((x) & 0x00001FFF) << 16))
-#define BIT_GET_RXBCN_TSFT_THRES(x)              ((u32)(((x >> 16) & 0x00001FFF)))
-#define BIT_EN_RXBCN_GT_THRES_CNT                ((u32)0x00000001 << 7)          /*!<R/W 0x0  enable the counter of BIT_RXBCN_GT_THRES_CNT */
-#define BIT_CLR_RXBCN_GT_THRES_CNT               ((u32)0x00000001 << 6)          /*!<W1C 0x0  clear the BIT_RXBCN_GT_THRES_CNT to 0 */
-#define BIT_MASK_RXBCN_GT_THRES_CNT              ((u32)0x0000003F << 0)          /*!<R 0x0  valid when BIT_EN_RXBCN_GT_THRES_CNT = 1. counter the number of beacon with the |TSFT - rxbcn.timestamp| exceed the threshold */
-#define BIT_RXBCN_GT_THRES_CNT(x)                ((u32)(((x) & 0x0000003F) << 0))
-#define BIT_GET_RXBCN_GT_THRES_CNT(x)            ((u32)(((x >> 0) & 0x0000003F)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_P2P_NOA2_CTRL_STATE
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_POWER_STATE_2                        ((u32)0x00000001 << 31)          /*!<RO   1: On, 0: Off. (It is including early time. ) */
-#define BIT_CTWINDOW_ON_2                        ((u32)0x00000001 << 30)          /*!<RO   Spec time and Beacon Early Time to TBTT Time. (It is including early time. ) */
-#define BIT_BEACON_AREA_ON_2                     ((u32)0x00000001 << 29)          /*!<RO   The time is from HOLD Time to BeaconTx or Timeout. (It is including early time. ) */
-#define BIT_CTWIN_EARLY_DISTX_2                  ((u32)0x00000001 << 28)          /*!<RO   ctwin_early_distx. (It is including early time. ) */
-#define BIT_NOA1_OFF_PERIOD_2                    ((u32)0x00000001 << 27)          /*!<RO   Spec time but exclude BCNDMATIM time for wake. (It is including early time. ) */
-#define BIT_FORCE_DOZE1_2                        ((u32)0x00000001 << 26)          /*!<RO   If NoA_Count == 1, this value is 1. else 0. (It is including early time. ) */
-#define BIT_NOA0_OFF_PERIOD_2                    ((u32)0x00000001 << 25)          /*!<RO   Spec time but exclude BCNDMATIM time for wake. (It is including early time. ) */
-#define BIT_FORCE_DOZE0_2                        ((u32)0x00000001 << 24)          /*!<RO   If NoA_Count == 1, this value is 1. else 0. (It is including early time. ) */
-#define BIT_SPEC_POWER_STATE_2                   ((u32)0x00000001 << 23)          /*!<RO   1: On, 0: Off */
-#define BIT_SPEC_CTWINDOW_ON_2                   ((u32)0x00000001 << 22)          /*!<RO   The time from TBTT <-> CTWEND (with BCNDMATIM early time) */
-#define BIT_SPEC_BEACON_AREA_ON_2                ((u32)0x00000001 << 21)          /*!<RO   The time is from TBTT to BeaconTx or Timeout */
-#define BIT_SPEC_CTWIN_EARLY_DISTX_2             ((u32)0x00000001 << 20)          /*!<RO   ctwin_early_distx */
-#define BIT_SPEC_NOA1_OFF_PERIOD_2               ((u32)0x00000001 << 19)          /*!<RO   Spec time */
-#define BIT_SPEC_FORCE_DOZE1_2                   ((u32)0x00000001 << 18)          /*!<RO   If NoA_Count == 1, this value is 1. else 0. */
-#define BIT_SPEC_NOA0_OFF_PERIOD_2               ((u32)0x00000001 << 17)          /*!<RO   Spec time */
-#define BIT_SPEC_FORCE_DOZE0_2                   ((u32)0x00000001 << 16)          /*!<RO   If NoA_Count == 1, this value is 1. else 0. */
-#define BIT_P2P_NOA2_ALLSTASLEEP                 ((u32)0x00000001 << 7)          /*!<R/W 0x0  It indicates that the state from CTWindow End to BcnEarly 1: Sleep 0: Wake */
-#define BIT_P2P_NOA2_DISTX_EN                    ((u32)0x00000001 << 6)          /*!<R/W 0x0  1: Hw will disable TX in P2P_off period 0: Do Nothing */
-#define BIT_P2P_NOA2_PWR_MGT_EN                  ((u32)0x00000001 << 5)          /*!<R/W 0x0  A main switch for P2P PowerSaving 1: Enable 0: Disable */
-#define BIT_MASK_P2P_NOA2_EN                     ((u32)0x00000003 << 3)          /*!<R/W 0x0  The condition that noa_unit0, [1]-NOA1, [0]-NOA0 1: Enable 0: Disable */
-#define BIT_P2P_NOA2_EN(x)                       ((u32)(((x) & 0x00000003) << 3))
-#define BIT_GET_P2P_NOA2_EN(x)                   ((u32)(((x >> 3) & 0x00000003)))
-#define BIT_MASK_P2P_NOA2_UNIT_SEL               ((u32)0x00000003 << 1)          /*!<R/W 0x0  The selector for the source of noa unit0. 0 for port 0, 1 for port 1, 2 for port 2 */
-#define BIT_P2P_NOA2_UNIT_SEL(x)                 ((u32)(((x) & 0x00000003) << 1))
-#define BIT_GET_P2P_NOA2_UNIT_SEL(x)             ((u32)(((x >> 1) & 0x00000003)))
-#define BIT_EN_TSFBIT32_RST_NOA2                 ((u32)0x00000001 << 0)          /*!<R/W 0x1   */
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_TM_CFG
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_MASK_TM_TSFT_PORT_SEL                ((u32)0x00000003 << 3)          /*!<R/W 0x0  selected TM timer port 0: port0; 1: port1; 2: port2; 3: freerun */
-#define BIT_TM_TSFT_PORT_SEL(x)                  ((u32)(((x) & 0x00000003) << 3))
-#define BIT_GET_TM_TSFT_PORT_SEL(x)              ((u32)(((x >> 3) & 0x00000003)))
-#define BIT_RXTM_EN                              ((u32)0x00000001 << 2)          /*!<R/W 0x0  1: HW will parsing rx packet, to find TM frame */
-#define BIT_RXTMREQ_EN                           ((u32)0x00000001 << 1)          /*!<R/W 0x0  1: HW will parsing rx packet, to find TM request frame */
-#define BIT_TM_FUNC_EN                           ((u32)0x00000001 << 0)          /*!<R/W 0x0  1: Enable Timing Measurement function */
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_TM_TSFT_T1
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_MASK_TM_TSFT_T1                      ((u32)0xFFFFFFFF << 0)          /*!<RO 0x0  Latch tsft timer of Tx TM frame, unit: 1us */
-#define BIT_TM_TSFT_T1(x)                        ((u32)(((x) & 0xFFFFFFFF) << 0))
-#define BIT_GET_TM_TSFT_T1(x)                    ((u32)(((x >> 0) & 0xFFFFFFFF)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_TM_TSFT_T2
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_MASK_TM_TSFT_T2                      ((u32)0xFFFFFFFF << 0)          /*!<RO 0x0  Latch tsft timer of Rx TM frame, unit: 1us */
-#define BIT_TM_TSFT_T2(x)                        ((u32)(((x) & 0xFFFFFFFF) << 0))
-#define BIT_GET_TM_TSFT_T2(x)                    ((u32)(((x >> 0) & 0xFFFFFFFF)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_TM_TSFT_T3
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_MASK_TM_TSFT_T3                      ((u32)0xFFFFFFFF << 0)          /*!<RO 0x0  Latch tsft timer of Tx ACK frame, unit: 1us */
-#define BIT_TM_TSFT_T3(x)                        ((u32)(((x) & 0xFFFFFFFF) << 0))
-#define BIT_GET_TM_TSFT_T3(x)                    ((u32)(((x >> 0) & 0xFFFFFFFF)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_TM_TSFT_T4
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_MASK_TM_TSFT_T4                      ((u32)0xFFFFFFFF << 0)          /*!<RO 0x0  Latch tsft timer of Rx ACK frame, unit: 1us */
-#define BIT_TM_TSFT_T4(x)                        ((u32)(((x) & 0xFFFFFFFF) << 0))
-#define BIT_GET_TM_TSFT_T4(x)                    ((u32)(((x >> 0) & 0xFFFFFFFF)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_TM_TIMER_OFFSET
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_MASK_TM_TX_PATH_TIME_OFFSET          ((u32)0x0000FFFF << 16)          /*!<R/W 0x0  Compensate the time, from PHYTXON rising edge to transmit antenna connector. unit: 1us */
-#define BIT_TM_TX_PATH_TIME_OFFSET(x)            ((u32)(((x) & 0x0000FFFF) << 16))
-#define BIT_GET_TM_TX_PATH_TIME_OFFSET(x)        ((u32)(((x >> 16) & 0x0000FFFF)))
-#define BIT_MASK_TM_RX_PATH_TIME_OFFSET          ((u32)0x0000FFFF << 0)          /*!<R/W 0x0  Compensate the time, from receive antenna connector to DATAON rising edge. unit: 1us */
-#define BIT_TM_RX_PATH_TIME_OFFSET(x)            ((u32)(((x) & 0x0000FFFF) << 0))
-#define BIT_GET_TM_RX_PATH_TIME_OFFSET(x)        ((u32)(((x >> 0) & 0x0000FFFF)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_BCN_ELY_ADJ
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_MASK_BCN_ELY_ADJ                     ((u32)0x0000FFFF << 0)          /*!<R/W 0x0  beacon early time adjust, unit is 32us */
-#define BIT_BCN_ELY_ADJ(x)                       ((u32)(((x) & 0x0000FFFF) << 0))
-#define BIT_GET_BCN_ELY_ADJ(x)                   ((u32)(((x >> 0) & 0x0000FFFF)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_PS_TIMER_D_L
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_MASK_PS_TIMER_D_L                    ((u32)0xFFFFFFFF << 0)          /*!<R/W 0x0  When the TSF(that select by reg 0x1520 [16:17]) matches the content of this register, the PS_TIMER_D_INT interrupt is issued */
-#define BIT_PS_TIMER_D_L(x)                      ((u32)(((x) & 0xFFFFFFFF) << 0))
-#define BIT_GET_PS_TIMER_D_L(x)                  ((u32)(((x >> 0) & 0xFFFFFFFF)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_PS_TIMER_D_H
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_MASK_PS_TIMER_D_H                    ((u32)0xFFFFFFFF << 0)          /*!<R/W 0x0  When the TSF(that select by reg 0x1520 [16:17]) matches the content of this register, the PS_TIMER_D_INT interrupt is issued */
-#define BIT_PS_TIMER_D_H(x)                      ((u32)(((x) & 0xFFFFFFFF) << 0))
-#define BIT_GET_PS_TIMER_D_H(x)                  ((u32)(((x >> 0) & 0xFFFFFFFF)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_PS_TIMER_E_L
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_MASK_PS_TIMER_E_L                    ((u32)0xFFFFFFFF << 0)          /*!<R/W 0x0  When the TSF (that select by reg 0x1520 [13:12]) matches the content of this register, the PS_TIMER_E_INT interrupt is issued */
-#define BIT_PS_TIMER_E_L(x)                      ((u32)(((x) & 0xFFFFFFFF) << 0))
-#define BIT_GET_PS_TIMER_E_L(x)                  ((u32)(((x >> 0) & 0xFFFFFFFF)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_PS_TIMER_E_H
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_MASK_PS_TIMER_E_H                    ((u32)0xFFFFFFFF << 0)          /*!<R/W 0x0  When the TSF (that select by reg 0x1520 [13:12]) matches the content of this register, the PS_TIMER_E_INT interrupt is issued */
-#define BIT_PS_TIMER_E_H(x)                      ((u32)(((x) & 0xFFFFFFFF) << 0))
-#define BIT_GET_PS_TIMER_E_H(x)                  ((u32)(((x >> 0) & 0xFFFFFFFF)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_AX_MUEDCA_VO_PARAM
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_MASK_MUEDCA_VO_PARAM_TIMER           ((u32)0x0000FFFF << 16)          /*!<R/W 0x00  MU EDCA TIMER, in units of 32 us Note: SPEC: The MU EDCA Timer field (8b) indicates the duration of time, in units of 8 TUs */
-#define BIT_MUEDCA_VO_PARAM_TIMER(x)             ((u32)(((x) & 0x0000FFFF) << 16))
-#define BIT_GET_MUEDCA_VO_PARAM_TIMER(x)         ((u32)(((x >> 16) & 0x0000FFFF)))
-#define BIT_MASK_MUEDCA_VO_PARAM_CW              ((u32)0x000000FF << 8)          /*!<R/W 0x43  ECWmin and ECWmax encode the values of Cwmin and Cwmax respectively in an exponent form. Ex: Cwmax = 2^(ECWmax)-1 Default: BK = Ah/5h; BE = Ah/5h; VI = 5h/4h; VO = 4h/3h. */
-#define BIT_MUEDCA_VO_PARAM_CW(x)                ((u32)(((x) & 0x000000FF) << 8))
-#define BIT_GET_MUEDCA_VO_PARAM_CW(x)            ((u32)(((x >> 8) & 0x000000FF)))
-#define BIT_MASK_MUEDCA_VO_PARAM_AIFS            ((u32)0x000000FF << 0)          /*!<R/W 0x1C  Arbitrary Inter frame space In unit of microsecond. AIFS indicates the time a non-AP QSTA should defer before either invoking a backoff or starting a transmission Default: BK = 49h; BE = 25h; VI = 1Ch; VO = 1Ch. */
-#define BIT_MUEDCA_VO_PARAM_AIFS(x)              ((u32)(((x) & 0x000000FF) << 0))
-#define BIT_GET_MUEDCA_VO_PARAM_AIFS(x)          ((u32)(((x >> 0) & 0x000000FF)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_AX_MUEDCA_VI_PARAM
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_MASK_MUEDCA_VI_PARAM_TIMER           ((u32)0x0000FFFF << 16)          /*!<R/W 0x00  MU EDCA TIMER, in units of 32 us Note: SPEC: The MU EDCA Timer field (8b) indicates the duration of time, in units of 8 TUs */
-#define BIT_MUEDCA_VI_PARAM_TIMER(x)             ((u32)(((x) & 0x0000FFFF) << 16))
-#define BIT_GET_MUEDCA_VI_PARAM_TIMER(x)         ((u32)(((x >> 16) & 0x0000FFFF)))
-#define BIT_MASK_MUEDCA_VI_PARAM_CW              ((u32)0x000000FF << 8)          /*!<R/W 0x54  ECWmin and ECWmax encode the values of Cwmin and Cwmax respectively in an exponent form. Ex: Cwmax = 2^(ECWmax)-1 Default: BK = Ah/5h; BE = Ah/5h; VI = 5h/4h; VO = 4h/3h. */
-#define BIT_MUEDCA_VI_PARAM_CW(x)                ((u32)(((x) & 0x000000FF) << 8))
-#define BIT_GET_MUEDCA_VI_PARAM_CW(x)            ((u32)(((x >> 8) & 0x000000FF)))
-#define BIT_MASK_MUEDCA_VI_PARAM_AIFS            ((u32)0x000000FF << 0)          /*!<R/W 0x1C  Arbitrary Inter frame space In unit of microsecond. AIFS indicates the time a non-AP QSTA should defer before either invoking a backoff or starting a transmission Default: BK = 49h; BE = 25h; VI = 1Ch; VO = 1Ch. */
-#define BIT_MUEDCA_VI_PARAM_AIFS(x)              ((u32)(((x) & 0x000000FF) << 0))
-#define BIT_GET_MUEDCA_VI_PARAM_AIFS(x)          ((u32)(((x >> 0) & 0x000000FF)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_AX_MUEDCA_BE_PARAM
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_MASK_MUEDCA_BE_PARAM_TIMER           ((u32)0x0000FFFF << 16)          /*!<R/W 0x00  MU EDCA TIMER, in units of 32 us Note: SPEC: The MU EDCA Timer field (8b) indicates the duration of time, in units of 8 TUs */
-#define BIT_MUEDCA_BE_PARAM_TIMER(x)             ((u32)(((x) & 0x0000FFFF) << 16))
-#define BIT_GET_MUEDCA_BE_PARAM_TIMER(x)         ((u32)(((x >> 16) & 0x0000FFFF)))
-#define BIT_MASK_MUEDCA_BE_PARAM_CW              ((u32)0x000000FF << 8)          /*!<R/W 0xA5  ECWmin and ECWmax encode the values of Cwmin and Cwmax respectively in an exponent form. Ex: Cwmax = 2^(ECWmax)-1 Default: BK = Ah/5h; BE = Ah/5h; VI = 5h/4h; VO = 4h/3h. */
-#define BIT_MUEDCA_BE_PARAM_CW(x)                ((u32)(((x) & 0x000000FF) << 8))
-#define BIT_GET_MUEDCA_BE_PARAM_CW(x)            ((u32)(((x >> 8) & 0x000000FF)))
-#define BIT_MASK_MUEDCA_BE_PARAM_AIFS            ((u32)0x000000FF << 0)          /*!<R/W 0x25  Arbitrary Inter frame space In unit of microsecond. AIFS indicates the time a non-AP QSTA should defer before either invoking a backoff or starting a transmission Default: BK = 49h; BE = 25h; VI = 1Ch; VO = 1Ch. */
-#define BIT_MUEDCA_BE_PARAM_AIFS(x)              ((u32)(((x) & 0x000000FF) << 0))
-#define BIT_GET_MUEDCA_BE_PARAM_AIFS(x)          ((u32)(((x >> 0) & 0x000000FF)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_AX_MUEDCA_BK_PARAM
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_MASK_MUEDCA_BK_PARAM_TIMER           ((u32)0x0000FFFF << 16)          /*!<R/W 0x00  MU EDCA TIMER, in units of 32 us Note: SPEC: The MU EDCA Timer field (8b) indicates the duration of time, in units of 8 TUs */
-#define BIT_MUEDCA_BK_PARAM_TIMER(x)             ((u32)(((x) & 0x0000FFFF) << 16))
-#define BIT_GET_MUEDCA_BK_PARAM_TIMER(x)         ((u32)(((x >> 16) & 0x0000FFFF)))
-#define BIT_MASK_MUEDCA_BK_PARAM_CW              ((u32)0x000000FF << 8)          /*!<R/W 0xA5  ECWmin and ECWmax encode the values of Cwmin and Cwmax respectively in an exponent form. Ex: Cwmax = 2^(ECWmax)-1 Default: BK = Ah/5h; BE = Ah/5h; VI = 5h/4h; VO = 4h/3h. */
-#define BIT_MUEDCA_BK_PARAM_CW(x)                ((u32)(((x) & 0x000000FF) << 8))
-#define BIT_GET_MUEDCA_BK_PARAM_CW(x)            ((u32)(((x >> 8) & 0x000000FF)))
-#define BIT_MASK_MUEDCA_BK_PARAM_AIFS            ((u32)0x000000FF << 0)          /*!<R/W 0x49  Arbitrary Inter frame space In unit of microsecond. AIFS indicates the time a non-AP QSTA should defer before either invoking a backoff or starting a transmission Default: BK = 49h; BE = 25h; VI = 1Ch; VO = 1Ch. */
-#define BIT_MUEDCA_BK_PARAM_AIFS(x)              ((u32)(((x) & 0x000000FF) << 0))
-#define BIT_GET_MUEDCA_BK_PARAM_AIFS(x)          ((u32)(((x >> 0) & 0x000000FF)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_AX_TB_MUEDCA_CTRL
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_MASK_TB_TIMER_CNT_INT                ((u32)0x0000001F << 27)          /*!<R/W 0x14  the initial value of th_timer, unit: us */
-#define BIT_TB_TIMER_CNT_INT(x)                  ((u32)(((x) & 0x0000001F) << 27))
-#define BIT_GET_TB_TIMER_CNT_INT(x)              ((u32)(((x >> 27) & 0x0000001F)))
-#define BIT_HE_TB_PPSU_ONLY_EN                   ((u32)0x00000001 << 26)          /*!<R/W 0x0  asserted if the TWT is trigger-enabled TWT */
-#define BIT_TB_TXPAUSE                           ((u32)0x00000001 << 25)          /*!<R/W 0x1  valid if BIT_HE_TB_PPSU_ONLY_EN = 1; select pause edca or not during TWT-SP; default is 1, pause. A TWT requesting STA should not transmit frames to the TWT responding STA outside of negotiated TWT SPs and should not transmit frames that are not contained within HE TB PPDUs to the TWT responding STA within trigger-enabled TWT SPs */
-#define BIT_DIS_UPD_BEAM_CHG                     ((u32)0x00000001 << 2)          /*!<R/W 0x1  1: txcmd_beam_change TIE 0 0: first PPDU in TXOP will assert txcmd_beam_change */
-#define BIT_SET_MUEDCATIMER_TF                   ((u32)0x00000001 << 1)          /*!<R/W 0x0  1: enable HW updating MUEDCATimer after Tx HE TB PPDU 0: disable HW updating MUEDCATimer after Tx HE TB PPDU */
-#define BIT_MUEDCA_EN                            ((u32)0x00000001 << 0)          /*!<R/W 0x1  1: enable HW updating MUEDCATimer 0: disable HW updating MUEDCATimer */
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_CCA_NAV_CHK
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_TB_CHK_EDCCA_PER20_BITMAP_SIFS       ((u32)0x00000001 << 23)          /*!<R/W 0x1  When TF CS required = 1 and EDCCA_PER20_BITMAP_SIFS assert in the SIFS before HE TB PPDU TX 0: Can TX 1: Cannot TX */
-#define BIT_TB_CHK_BASIC_NAV                     ((u32)0x00000001 << 22)          /*!<R/W 0x1  When TF CS required = 1 and BAISC NAV > 0 , in the SIFS before HE TB PPDU TX 0: Can TX 1: Cannot TX */
-#define BIT_TB_CHK_ZGBTCCA                       ((u32)0x00000001 << 21)          /*!<R/W 0x1  When TF CS required = 1 and ~GNT_WL(BT/ZigBee) assert in the SIFS before HE TB PPDU TX 0: Can TX 1: Cannot TX */
-#define BIT_TB_CHK_EDCCA                         ((u32)0x00000001 << 20)          /*!<R/W 0x1  When TF CS required = 1 and EDCCA assert in the SIFS before HE TB PPDU TX 0: Can TX 1: Cannot TX */
-#define BIT_TB_CHK_CCA_S80                       ((u32)0x00000001 << 19)          /*!<R/W 0x1  When TF CS required = 1 and SECONDARY_CCA_80 assert in the SIFS before HE TB PPDU TX 0: Can TX 1: Cannot TX */
-#define BIT_TB_CHK_CCA_S40                       ((u32)0x00000001 << 18)          /*!<R/W 0x1  When TF CS required = 1 and SECONDARY_CCA_40 assert in the SIFS before HE TB PPDU TX 0: Can TX 1: Cannot TX */
-#define BIT_TB_CHK_CCA_S20                       ((u32)0x00000001 << 17)          /*!<R/W 0x1  When TF CS required = 1 and SECONDARY_CCA_20 assert in the SIFS before HE TB PPDU TX 0: Can TX 1: Cannot TX */
-#define BIT_TB_CHK_CCA_P20                       ((u32)0x00000001 << 16)          /*!<R/W 0x1  When TF CS required = 1 and CCA assert in the SIFS before HE TB PPDU TX 0: Can TX 1: Cannot TX */
-#define BIT_SR_CTN_CHK__NAV                      ((u32)0x00000001 << 12)          /*!<R/W 0x1  When BASIC or INTRA NAV > 0 in the AIFS/Backoff before active TX 0: Can backoff, can TX 1: Cannot backoff, cannot TX */
-#define BIT_SR_CTN_CHK_ZGBTCCA                   ((u32)0x00000001 << 11)          /*!<R/W 0x1  When ~GNT_WL(BT/ZigBee) assert in the AIFS/Backoff before active TX 0: Can backoff, can TX 1: Cannot backoff, cannot TX */
-#define BIT_SR_CTN_CHK_EDCCA                     ((u32)0x00000001 << 10)          /*!<R/W 0x1  When EDCCA assert in the AIFS/Backoff before active TX 0: Can backoff, can TX 1: Cannot backoff, cannot TX */
-#define BIT_SR_CTN_CHK_CCA_S40                   ((u32)0x00000001 << 9)          /*!<R/W 0x1  When SECONDARY_CCA_40 assert in the AIFS/Backoff before active TX 0: Can backoff, can TX 1: Can backoff, cannot TX */
-#define BIT_SR_CTN_CHK_CCA_S20                   ((u32)0x00000001 << 8)          /*!<R/W 0x1  When SECONDARY_CCA_20 assert in the AIFS/Backoff before active TX 0: Can backoff, can TX 1: Can backoff, cannot TX */
-#define BIT_CTN_CHK_INTRA_NAV                    ((u32)0x00000001 << 6)          /*!<R/W 0x1  When INTRA NAV > 0 in the AIFS/Backoff before active TX 0: Can backoff, can TX 1: Cannot backoff, cannot TX */
-#define BIT_CTN_CHK_BASIC_NAV                    ((u32)0x00000001 << 5)          /*!<R/W 0x1  When BASIC NAV > 0 in the AIFS/Backoff before active TX 0: Can backoff, can TX 1: Cannot backoff, cannot TX */
-#define BIT_CTN_CHK_ZGBTCCA                      ((u32)0x00000001 << 4)          /*!<R/W 0x1  When ~GNT_WL(BT/ZigBee) assert in the AIFS/Backoff before active TX 0: Can backoff, can TX 1: Cannot backoff, cannot TX */
-#define BIT_CTN_CHK_EDCCA                        ((u32)0x00000001 << 3)          /*!<R/W 0x1  When EDCCA assert in the AIFS/Backoff before active TX 0: Can backoff, can TX 1: Cannot backoff, cannot TX */
-#define BIT_CTN_CHK_CCA_S40                      ((u32)0x00000001 << 2)          /*!<R/W 0x1  When SECONDARY_CCA_40 assert in the AIFS/Backoff before active TX 0: Can backoff, can TX 1: Can backoff, cannot TX */
-#define BIT_CTN_CHK_CCA_S20                      ((u32)0x00000001 << 1)          /*!<R/W 0x1  When SECONDARY_CCA_20 assert in the AIFS/Backoff before active TX 0: Can backoff, can TX 1: Can backoff, cannot TX */
-#define BIT_CTN_CHK_CCA_P20                      ((u32)0x00000001 << 0)          /*!<R/W 0x1  When CCA assert in the AIFS/Backoff before active TX 0: Can backoff, can TX 1: Cannot backoff, cannot TX */
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_TSFT_HIOE_RFON_L
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_MASK_TSFT_AT_HIOE_RFON_L             ((u32)0xFFFFFFFF << 0)          /*!<R 0x0  when hioe_int_chn_on asserted, latch the tsft[31:0] (select port by 0x1520[0]) */
-#define BIT_TSFT_AT_HIOE_RFON_L(x)               ((u32)(((x) & 0xFFFFFFFF) << 0))
-#define BIT_GET_TSFT_AT_HIOE_RFON_L(x)           ((u32)(((x >> 0) & 0xFFFFFFFF)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_TSFT_HIOE_RFON_H
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_MASK_TSFT_AT_HIOE_RFON_H             ((u32)0xFFFFFFFF << 0)          /*!<R 0x0  when hioe_int_chn_on asserted, latch the tsft[63:32] (select port by 0x1520[0]) */
-#define BIT_TSFT_AT_HIOE_RFON_H(x)               ((u32)(((x) & 0xFFFFFFFF) << 0))
-#define BIT_GET_TSFT_AT_HIOE_RFON_H(x)           ((u32)(((x >> 0) & 0xFFFFFFFF)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_TSFT_BCN_CCAUP_L
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_MASK_TSFT_AT_BCN_CCA_UP_L            ((u32)0xFFFFFFFF << 0)          /*!<R 0x0  when CCA asserted, latch the tsft[31:0] (select port by 0x1520[0]). updated to this register after judging that it is a beacon frame */
-#define BIT_TSFT_AT_BCN_CCA_UP_L(x)              ((u32)(((x) & 0xFFFFFFFF) << 0))
-#define BIT_GET_TSFT_AT_BCN_CCA_UP_L(x)          ((u32)(((x >> 0) & 0xFFFFFFFF)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_TSFT_BCN_CCAUP_H
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_MASK_TSFT_AT_BCN_CCA_UP_H            ((u32)0xFFFFFFFF << 0)          /*!<R 0x0  when CCA asserted, latch the tsft[63:32] (select port by 0x1520[0]). updated to this register after judging that it is a beacon frame */
-#define BIT_TSFT_AT_BCN_CCA_UP_H(x)              ((u32)(((x) & 0xFFFFFFFF) << 0))
-#define BIT_GET_TSFT_AT_BCN_CCA_UP_H(x)          ((u32)(((x >> 0) & 0xFFFFFFFF)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_POF_BCNELY_AGG_TBTT
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_EN_P0_TBTT_CNT                       ((u32)0x00000001 << 24)          /*!<R/W 0x0  enable the tbtt counter function. */
-#define BIT_MASK_P0_TBTT_CNT_THRS                ((u32)0x0000FFFF << 8)          /*!<R/W 0x0  P0's TBTT counter threshold . Valid when BIT_EN_P0_TBTT_CNT = 1. when tbtt_cnt >= BIT_P0_TBTT_CNT_THRS, assert p0_tbtt_agg_int. */
-#define BIT_P0_TBTT_CNT_THRS(x)                  ((u32)(((x) & 0x0000FFFF) << 8))
-#define BIT_GET_P0_TBTT_CNT_THRS(x)              ((u32)(((x >> 8) & 0x0000FFFF)))
-#define BIT_EN_POF_ELY_AGG                       ((u32)0x00000001 << 7)          /*!<R/W 0x0  update bcn_ely_agg initial value of P0 to BIT_INI_POF_ELY_AGG_CNT 1: enable 0: disable */
-#define BIT_MASK_INI_POF_ELY_AGG_CNT             ((u32)0x0000007F << 0)          /*!<R/W 0x3  bcn_ely_agg initial value of P0. Valid when BIT_EN_POF_ELY_AGG = 1 */
-#define BIT_INI_POF_ELY_AGG_CNT(x)               ((u32)(((x) & 0x0000007F) << 0))
-#define BIT_GET_INI_POF_ELY_AGG_CNT(x)           ((u32)(((x >> 0) & 0x0000007F)))
-/** @} */
-
-
-/*==========PAGE5 Register Address Definition==========*/
-#define REG_EDCA_VO_PARAM                            0x0500
-#define REG_EDCA_VI_PARAM                            0x0504
-#define REG_EDCA_BE_PARAM                            0x0508
-#define REG_EDCA_BK_PARAM                            0x050C
-#define REG_BCN_CFG_PIFS                             0x0510
-#define REG_SIFS                                     0x0514
-#define REG_TSFT_SYN_OFFSET_SLOT                     0x0518
-#define REG_PS_NOA_ERLY_TIME                         0x051C
-#define REG_TXPAUSE_TXPTCL_DISTXREQ_CTRL             0x0520
-#define REG_NOA0_MBSSID_RD_CTRL                      0x0524
-#define REG_NOA0_PKT_LIFETIME_CTRL                   0x0528
-#define REG_P2PON_DIS_TXTIME                         0x0530
-#define REG_NAN_SETTING_2                            0x0534
-#define REG_QUEUE_INCOL_THR                          0x0538
-#define REG_QUEUE_INCOL_EN                           0x053C
-#define REG_NOA0_TBTT_PROHIBIT                       0x0540
-#define REG_NAV_CTRL                                 0x0544
-#define REG_FTM_CTRL                                 0x0548
-#define REG_FTM_TSF_CNT                              0x054C
-#define REG_TSTRST_P2PRST_BCN_CTRL_PORT0_1           0x0550
-#define REG_PORT0_BCN_SPACE                          0x0554
-#define REG_ATIMWND0_P0_BCN_ERLY_DMA_CTRL            0x0558
-#define REG_BCNERR_TSF_CTRL                          0x055C
-#define REG_P0_TSFTR_L                               0x0560
-#define REG_P0_TSFTR_H                               0x0564
-#define REG_P1_TSFTR_L                               0x0568
-#define REG_P1_TSFTR_H                               0x056C
-#define REG_BCN_ERLY_CTW_CTRL                        0x0570
-#define REG_BCNDROP_TO_MISC_CTRL                     0x0574
-#define REG_P2_TSFTR_L                               0x0578
-#define REG_P2_TSFTR_H                               0x057C
-#define REG_TSF_TIMER1                               0x0580
-#define REG_TSF_TIMER2                               0x0584
-#define REG_TSF_TIMER3                               0x0588
-#define REG_BCN_IFS_TBTT_CTN                         0x058C
-#define REG_TXOP_CTRL_PRE_BKF                        0x0590
-#define REG_FREERUN_CNT_L                            0x0594
-#define REG_FREERUN_CNT_H                            0x0598
-#define REG_BCN_ERLY_CTW_CTRL_P1_2                   0x059C
-#define REG_ATIMWND2_5                               0x05A0
-#define REG_ATIMWND6_7_URGENT_NOLIMTHGQ              0x05A4
-#define REG_DTIM_COUNT_0_3                           0x05A8
-#define REG_DTIM_COUNT_4_7                           0x05AC
-#define REG_DISATIM_BCNERLY_TBTTHOLD_BCNCS           0x05B0
-#define REG_FREERUN_CNT_P2POFF_DIS_TXTIME            0x05B4
-#define REG_PTA_TRXBCN_CTRL                          0x05B8
-#define REG_P2P_NOA1_CTRL_STATE                      0x05BC
-#define REG_ACMHWCTRL                                0x05C0
-#define REG_VO_VI_ADMTIME                            0x05C4
-#define REG_BE_ADMTIME                               0x05C8
-#define REG_NOACMD_SEL_EDCA_RANDOM_GEN               0x05CC
-#define REG_TXPAUSE_CFG                              0x05D0
-#define REG_NAN_SETTING                              0x05D4
-#define REG_BCN_SPACE_PORT1_2                        0x05D8
-#define REG_NAN_SETTING_1                            0x05DC
-#define REG_NOA_PARAM_V1                             0x05E0
-#define REG_NOA_PARAM_V2                             0x05E4
-#define REG_NOA_PARAM_V3                             0x05E8
-#define REG_NOA_PARAM_4                              0x05EC
-#define REG_SCHEDULER_DBG                            0x05F4
-#define REG_SCH_TXCMD                                0x05F8
-#define REG_PAGE5_DUMMY                              0x05FC
-#define REG_PS_TIMER_A_L                             0x1500
-#define REG_PS_TIMER_A_H                             0x1504
-#define REG_PS_TIMER_B_L                             0x1508
-#define REG_PS_TIMER_B_H                             0x150C
-#define REG_PS_TIMER_C_L                             0x1510
-#define REG_PS_TIMER_C_H                             0x1514
-#define REG_CPUMGQ_PARAMETER                         0x1518
-#define REG_PS_TIMER_EARLY                           0x151C
-#define REG_PS_TIMER_TWT_CRTL                        0x1520
-#define REG_RX_TSFT_DIFF                             0x1524
-#define REG_RXBCN_TSFT_STATISTIC                     0x1528
-#define REG_P2P_NOA2_CTRL_STATE                      0x152C
-#define REG_TM_CFG                                   0x1530
-#define REG_TM_TSFT_T1                               0x1534
-#define REG_TM_TSFT_T2                               0x1538
-#define REG_TM_TSFT_T3                               0x153C
-#define REG_TM_TSFT_T4                               0x1540
-#define REG_TM_TIMER_OFFSET                          0x1544
-#define REG_BCN_ELY_ADJ                              0x1548
-#define REG_PS_TIMER_D_L                             0x154C
-#define REG_PS_TIMER_D_H                             0x1550
-#define REG_PS_TIMER_E_L                             0x1554
-#define REG_PS_TIMER_E_H                             0x1558
-#define REG_AX_MUEDCA_VO_PARAM                       0x1580
-#define REG_AX_MUEDCA_VI_PARAM                       0x1584
-#define REG_AX_MUEDCA_BE_PARAM                       0x1588
-#define REG_AX_MUEDCA_BK_PARAM                       0x158C
-#define REG_AX_TB_MUEDCA_CTRL                        0x1590
-#define REG_CCA_NAV_CHK                              0x1594
-#define REG_TSFT_HIOE_RFON_L                         0x1598
-#define REG_TSFT_HIOE_RFON_H                         0x159C
-#define REG_TSFT_BCN_CCAUP_L                         0x15A0
-#define REG_TSFT_BCN_CCAUP_H                         0x15A4
-#define REG_POF_BCNELY_AGG_TBTT                      0x15A8
-
-/* AUTO_GEN_END */
-
-/* MANUAL_GEN_START */
-
-//Please add your defination here
-
-/* MANUAL_GEN_END */
-
-#endif
diff --git a/os/board/rtl8720e/src/component/wifi/wifi_fw/amebalite/include/wififw_reg_page6.h b/os/board/rtl8720e/src/component/wifi/wifi_fw/amebalite/include/wififw_reg_page6.h
deleted file mode 100644
index f484b6498..000000000
--- a/os/board/rtl8720e/src/component/wifi/wifi_fw/amebalite/include/wififw_reg_page6.h
+++ /dev/null
@@ -1,2167 +0,0 @@
-#ifndef __WIFIFW_REG_PAGE6_H__
-#define __WIFIFW_REG_PAGE6_H__
-
-/**************************************************************************//**
- * @defgroup REG_WMAC_CR
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_TXPWR_CTL_CLK_EN                       ((u32)0x00000001 << 31)          /*!<R/W 0  IF set to 1, txpwr_ctrl clock enable, only work when BIT_TXPWR_CTL_ENGCLK set to 1, */
-#define BIT_TXPWR_CTL_ENGCLK                       ((u32)0x00000001 << 30)          /*!<R/W 0  If set to 1, enable txpwr_ctrl clock gating function. */
-#define BIT_WLAN_RX_REQ_SIFS_CLR                   ((u32)0x00000001 << 29)          /*!<R/W 0  When set, enable sifs clear wlan_rx_req */
-#define BIT_DIS_WAIT_HE_SIGB                       ((u32)0x00000001 << 28)          /*!<R/W 0  When set, will not wait and check he mu sigb and ndp info */
-#define BIT_WMAC_20MHZBW                           ((u32)0x00000001 << 26)          /*!<R/W 1   */
-#define BIT_WMAC_M11J                              ((u32)0x00000001 << 24)          /*!<R/W 0   */
-#define BIT_DATA_FW_STS_FILTER                     ((u32)0x00000001 << 18)          /*!<R/W 0  When this bit is set,Accept data frame in partial length condition. It will take effect when RxFilter3-5 is disabled and RxFilter 0-2 is enabled. */
-#define BIT_CTRL_FW_STS_FILTER                     ((u32)0x00000001 << 17)          /*!<R/W 0  When this bit is set,Accept control frame in partial length condition. It will take effect when RxFilter3-5 is disabled and RxFilter 0-2 is enabled. */
-#define BIT_MGNT_FW_STS_FILTER                     ((u32)0x00000001 << 16)          /*!<R/W 0  When this bit is set,Accept management frame in partial length condition. It will take effect when RxFilter3-5 is disabled and RxFilter 0-2 is enabled. */
-#define BIT_FWRX_EN                                ((u32)0x00000001 << 15)          /*!<R/W 0  Enable to receive pkt into FWFF, default 1’b0. When Fw needs to receive pkt, this bit must be set to 1’b1 */
-#define BIT_PHYSTS_PKT_CTRL                        ((u32)0x00000001 << 14)          /*!<R/W 0  If set to 1,HW will send interrupt (0x124[26]) only when there is phy status valid fwsts pkt written into FWFF */
-#define BIT_APPHDR_MIDSRCH_FAIL                    ((u32)0x00000001 << 12)          /*!<R/W 0  If set to 1, Hw will append 16 bytes MAC header into FWFF when MACID search fail */
-#define BIT_FWPARSING_EN                           ((u32)0x00000001 << 11)          /*!<R/W 0  If set to 1, mac header and rx desc of the pkt into rx buff are also received into FWFF. */
-#define BIT_MASK_APPEND_MHDR_LEN                   ((u32)0x00000007 << 8)          /*!<R/W 0  Appended MAC header length, unit in 32 bytes */
-#define BIT_APPEND_MHDR_LEN(x)                     ((u32)(((x) & 0x00000007) << 8))
-#define BIT_GET_APPEND_MHDR_LEN(x)                 ((u32)(((x >> 8) & 0x00000007)))
-#define BIT_APSDOFF                                ((u32)0x00000001 << 6)          /*!<R/W 0  1：MAC issue sleep signal to disable BB/AFE/RF TRX function. After MAC has finished, APSDOFF_STATUS will report“1”. 0：MAC issue wakeup signal to recall BB/AFE/RF back to RX idle mode. After MAC has finished,APSDOFF _STATUS will report “0”. */
-#define BIT_R_RXTRIG_TX_CHK                        ((u32)0x00000001 << 5)          /*!<R/W 0  when set to 1,when tx type is tb,will chk fcs of trigger frame and if phy_rst is high when sifs reach,set 0 will not check */
-#define BIT_R_RXTRIG_DIS_UPD_AID                   ((u32)0x00000001 << 4)          /*!<R/W 0  1:will only update aid_fit info when the first trigger in a ppdu is parsered 0:will update aid_fit info every time when two or more trigger aggregate in a ppdu */
-#define BIT_R_RXTRIG_DIS_CHK_A1                    ((u32)0x00000001 << 3)          /*!<R/W 0  1:will not check if A1 of trigger frame is my unicast or broadcast address 0:will check if A1 of trigger frame is my unicast or broadcast address */
-#define BIT_R_DIS_CHK_NEW_TBREQ                    ((u32)0x00000001 << 2)          /*!<R/W 0  1:rxtrig req_in will assert every time when aid fit if two or more trigger aggregate in a ppdu 0:rxtrig req_in will not assert again when there is already a correct trigger received */
-#define BIT_R_DIS_ABORT_TB_ELY                     ((u32)0x00000001 << 1)          /*!<R/W 0  1:will abort ptcl generating tb data when macrx_active is low 0:will abort ptcl generating tb data when new rxtrig req_in is assert */
-#define BIT_IC_MACPHY_M                            ((u32)0x00000001 << 0)          /*!<R/W 0  To make ASIC become BB+RF only, and put out the MAC_PHY interface */
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_TCR
- * @brief Transmission Configuration Register
- * @{
- *****************************************************************************/
-#define BIT_WMAC_EN_RTS_ADDR                       ((u32)0x00000001 << 31)          /*!<R/W 0  when set to 1, enable change RTS multicast address */
-#define BIT_WMAC_DISABLE_CCK                       ((u32)0x00000001 << 30)          /*!<R/W 0  when set to 1, disable cck rate packet */
-#define BIT_WMAC_RAW_LEN                           ((u32)0x00000001 << 29)          /*!<R/W 1  1: use raw ppdu_len 0: use 4byte alignment ppdu_len */
-#define BIT_WMAC_NOTX_IN_RXNDP                     ((u32)0x00000001 << 28)          /*!<R/W 0  1: block original tx when receiving NDP packet */
-#define BIT_WMAC_EN_EOF                            ((u32)0x00000001 << 27)          /*!<R/W 1  when set to 1, enable single ampdu for qos packet. In early mode,not set to 1. */
-#define BIT_WMAC_BF_SEL                            ((u32)0x00000001 << 26)          /*!<R/W 0  1: set ndp_rx_standby when rx ppdu of ndpa end; 0: set ndp_rx_standby when rx ndpa packet fcs end; */
-#define BIT_WMAC_ANTMODE_SEL                       ((u32)0x00000001 << 25)          /*!<R/W 0  0:4x1 mode, 1:8x1 mode */
-#define BIT_WMAC_TCRPWRMGT_HWCTL                   ((u32)0x00000001 << 24)          /*!<R/W 0  If this bit is set to 1, MAC will overwrite power bit of frame control according to PWR_ST. (only for RTS/CTS/ACK/CFEND/BA/BAR frames) */
-#define BIT_WMAC_SMOOTH_VAL                        ((u32)0x00000001 << 23)          /*!<R/W 0  smooth value of plcp header HTSIG2 */
-#define BIT_WMAC_EN_SCRAM_INC                      ((u32)0x00000001 << 22)          /*!<R/W 0  Increase 1 in service field scrambler seed per tx end */
-#define BIT_UNDERFLOWEN_CMPLEN_SEL                 ((u32)0x00000001 << 21)          /*!<R/W 1  compare length selector for enable condition of underflow, consider plcp header when set 1 */
-#define BIT_FETCH_MPDU_AFTER_WSECRDY               ((u32)0x00000001 << 20)          /*!<R/W 1  If set to 1,mactx_mpdu_gen will fetch mpdu after wsec is ready when sectype is not tkip/wep40/wep104 */
-#define BIT_WMAC_TCR_EN_20MST                      ((u32)0x00000001 << 19)          /*!<R/W 0  when set to 1, enable ndpa signaling TA when BW =20MHz */
-#define BIT_WMAC_DIS_SIGTA                         ((u32)0x00000001 << 18)          /*!<R/W 0  when set to 1, disable signaling TA information for response packet */
-#define BIT_WMAC_DIS_A2B0                          ((u32)0x00000001 << 17)          /*!<R/W 0  when set to 1, not check bit 0 of rx a2 */
-#define BIT_WMAC_MSK_SIGBCRC                       ((u32)0x00000001 << 16)          /*!<R/W 0  when set to 1, mask sigb crc in service field for vht packet */
-#define BIT_WMAC_TCR_ERRSTEN_3                     ((u32)0x00000001 << 15)          /*!<R/W 0  Use phytxend_ps to reset mactx state machine */
-#define BIT_WMAC_TCR_ERRSTEN_2                     ((u32)0x00000001 << 14)          /*!<R/W 0  If txd fifo underflow when txtype is cmpba, reset mactx state machine */
-#define BIT_WMAC_TCR_ERRSTEN_1                     ((u32)0x00000001 << 13)          /*!<R/W 0  If txd fifo underflow, reset mactx state machine */
-#define BIT_WMAC_TCR_ERRSTEN_0                     ((u32)0x00000001 << 12)          /*!<R/W 0  Phytxend_ps comes but mactx still active, reset mactx state machine */
-#define BIT_WMAC_TCR_TXSK_PERPKT                   ((u32)0x00000001 << 11)          /*!<R/W 0  Search key for each mpdu */
-#define BIT_WMAC_TCR_ICV                           ((u32)0x00000001 << 10)          /*!<R/W 0  Integrity Check Value. This bit indicates the existence of an ICV appended to an encipherment packet. 1: No ICV appended 0: ICV appended */
-#define BIT_WMAC_CFENDFOR                          ((u32)0x00000001 << 9)          /*!<R/W 0  CF-End Frame Format.The Address 2 field of CF-End is defined to be the address of the STA contained in the AP, but in 802.11n a STA can also send CF-End.The Address 2 field is not specified clearly in this case. This register chooses between MAC ID of the STA or BSSID of the network. 0: BSSID 1: MAC ID */
-#define BIT_WMAC_TCR_CRC                           ((u32)0x00000001 << 8)          /*!<R/W 0  Append 32-bit Cyclic Redundancy Check. This bit indicates the existence of a CRC32 appended to a packet. 1: No CRC32 appended 0: A CRC32 is appended */
-#define BIT_WMAC_TCR_PWRMGT_CTL                    ((u32)0x00000001 << 7)          /*!<R/W 0  If this bit is set to 1, MAC will overwrite power bit of frame control according to PWR_ST. (only for data frame) */
-#define BIT_WMAC_TCR_PWRMGT_VAL                    ((u32)0x00000001 << 6)          /*!<R/W 0  MAC will overwrite power bit of frame control according to PWR_ST.(only for data frame) */
-#define BIT_WMAC_TCR_UPD_TIMIE                     ((u32)0x00000001 << 5)          /*!<R/W 0  when set to 1, enable hw to update beacon's time field */
-#define BIT_WMAC_TCR_UPD_HGQMD                     ((u32)0x00000001 << 4)          /*!<R/W 0  when set to 1, enable HGQ set moredata bit in Frame control field */
-#define BIT_WMAC_TCR_VHTSIGA1_TXPS                 ((u32)0x00000001 << 3)          /*!<R/W 0  This bit controls TXOP_PS_NOT_ALLOWED bit value of VHT-SIG-A1 field in TX VHT packets 1: TXOP_PS_NOT_ALLOWED is set to 1 0: TXOP_PS_NOT_ALLOWED is set to 0 */
-#define BIT_WMAC_TCR_PADSEL                        ((u32)0x00000001 << 2)          /*!<R/W 0  AMPDU Padding pattern selection 0: 32-bit Zero padding, 1: Zero length delimiter. */
-#define BIT_WMAC_TCR_DISGCLK                       ((u32)0x00000001 << 1)          /*!<R/W 0  when set to 1,disable MACTX clock gating control. */
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_RCR
- * @brief Receive Configuration Register
- * @{
- *****************************************************************************/
-#define BIT_APP_FCS                                ((u32)0x00000001 << 31)          /*!<R/W 0  When set, wmac RX will append FCS after payload. */
-#define BIT_APP_MIC                                ((u32)0x00000001 << 30)          /*!<R/W 0  When this bit is set to 1, MACRX will retain the MIC at the bottom of the packet. Otherwise, MIC will be removed and reported the status in RXDESC. When a MPDU is encrypted with TKIP without MIC, MACRX will ignore this option, that is, MIC must be remained in back of the plain text. */
-#define BIT_APP_ICV                                ((u32)0x00000001 << 29)          /*!<R/W 0  When this bit is set to 1, MACRX will retain the ICV at the bottom of the packet. Otherwise, MIC will be removed and reported the status in RXDESC. */
-#define BIT_APP_PHYSTS                             ((u32)0x00000001 << 28)          /*!<R/W 0  Append RXFF0 PHY Status Enable When this bit is set, then PHY Status is appended before RX packet in RXFF. When this bit is set, the RX_DRV_INFO_SZ shall be set to include PHY Status report. */
-#define BIT_APP_BASSN                              ((u32)0x00000001 << 27)          /*!<R/W 0  Append SSN of previous TXBA Enable When this bit is set, then SSN of previous TXBA is appended as after original RXDESC as the 4-th DW of RXDESC. */
-#define BIT_VHT_DACK                               ((u32)0x00000001 << 26)          /*!<R/W 1  This bit to control response type for vht single mpdu data packet. 1： ACK as response 0： BA as response */
-#define BIT_TCPOFLD_EN                             ((u32)0x00000001 << 25)          /*!<R/W 0  When set,Enable TCP checksum offload */
-#define BIT_ENMBID                                 ((u32)0x00000001 << 24)          /*!<R/W 0  Enable Multiple Bssid. 1: Enable. Only response ACK to the packets whose DID(A1) matching to the addresses in the MBSSID CAM Entries. 0: Disable. */
-#define BIT_LSIGEN                                 ((u32)0x00000001 << 23)          /*!<R/W 0  Enable LSIG TXOP Protection function. 1: Enable. Search KEYCAM for each rx packet to check if LSIGEN bit is set. If LSIGEN is set, then sender support LSIG TXOP protection and we need send response with LSIG TXOP protection 0: Disable */
-#define BIT_MFBEN                                  ((u32)0x00000001 << 22)          /*!<R/W 0  Enable immediate MCS Feedback function 1: Enable. When Rx packet with MRQ = 1‟b1, then search KEYCAM to find sender‟s MCS Feedback function and send response 0: Disable */
-#define BIT_DISCHKPPDLLEN                          ((u32)0x00000001 << 21)          /*!<R/W 0  When set,do not check PPDU while the PPDU length is smaller than 14 byte. */
-#define BIT_PKTCTL_DLKEN                           ((u32)0x00000001 << 20)          /*!<R/W 0  When set,while rx path dead lock occurs, reset rx path */
-#define BIT_DISGCLK                                ((u32)0x00000001 << 19)          /*!<R/W 0  When set,disable macrx clock gating control */
-#define BIT_TIMPSR_EN                              ((u32)0x00000001 << 18)          /*!<R/W 0  When set, enable RX Beacon TIM Parser */
-#define BIT_BCMDINT_EN                             ((u32)0x00000001 << 17)          /*!<R/W 0  Broadcast data packet interrupt enable. When this bit is set, this bit is auto clear by MAC. As long as a data type broadcast packet is received, this bit will be set. */
-#define BIT_UCMDINT_EN                             ((u32)0x00000001 << 16)          /*!<R/W 0  Unicast data packet with FC.MD = 1 interrupt enable. When this bit is set, this bit is auto clear by MAC. As long as a data type unicast packet is received, this bit will be set. */
-#define BIT_RXSK_PERPKT                            ((u32)0x00000001 << 15)          /*!<R/W 0  Executing key search per MPDU */
-#define BIT_HTCBFMC                                ((u32)0x00000001 << 14)          /*!<R/W 0  1: HTC -> MFC 0: MFC-> HTC */
-#define BIT_CHK_PREVTXA2                           ((u32)0x00000001 << 13)          /*!<R/W 0  When set,enable check rxa1 with txa2. */
-#define BIT_ACK_CBSSID                             ((u32)0x00000001 << 12)          /*!<R/W 0  The field effects behavior of BA/ACK frame. 0:Only A1 match to send BA/ACK frame. 1:A1 match and satisfy BSSID condition(if BIT_CBSSID_DATA = 1) will send BA/ACK frame. If BIT_CBSSID_DATA = 0, hardware send BA/ACK frame decided by A1 match condition. */
-#define BIT_CHKTA_MGNT                             ((u32)0x00000001 << 11)          /*!<R/W 0  Check Transmitter_BCN When set to 1, MAC will check the Transmitter Address (A2) of RX beacon or Probe response to determine if this packet belongs to this Transmitter Address (Address 2) . Both in Infrastructure mode and Ad-hoc mode. */
-#define BIT_DISDECNMYPKT                           ((u32)0x00000001 << 10)          /*!<R/W 0  This bit determines whether hw need to do decryption. 1: If A1 match or broadcast, do decryption. 0: Do decryption. */
-#define BIT_AICV                                   ((u32)0x00000001 << 9)          /*!<R/W 0  Accept Integrity Check Value Error packets. This bit determines whether packets with ICV errors will be accepted or rejected. 1: Accept 0: Reject */
-#define BIT_ACRC32                                 ((u32)0x00000001 << 8)          /*!<R/W 0  Accept CRC32 Error packets. When set to 1, packets with CRC32 errors will be accepted. When set to 0, packets with CRC32 errors will be rejected. 1: Accept 0: Reject */
-#define BIT_CBSSID_MGNT                            ((u32)0x00000001 << 7)          /*!<R/W 0  Check BSSID_BCN When set to 1, MAC will check the BSSID of RX beacon or Probe response to determine if this packet belongs to this BSSID. */
-#define BIT_CBSSID_DATA                            ((u32)0x00000001 << 6)          /*!<R/W 0  Check BSSID_DATA, To DS, From DS Match Packet. When set to 1, MAC will check the Rx data type frame‟s BSSID, To DS, and From DS fields, to determine if it is set to Link OK in an Infrastructure or Ad hoc network. Note this setting is independent of nettype. Driver must set this bit in ad hoc mode and client mode. */
-#define BIT_APWRMGT                                ((u32)0x00000001 << 5)          /*!<R/W 0  Accept Power Management Packet. This bit determines whether the RTL8192D will accept or reject packets with the power management bit set. 1: Accept 0: Reject */
-#define BIT_ADD3                                   ((u32)0x00000001 << 4)          /*!<R/W 0  Accept Address 3 Match Packets. Set this bit to 1 to accept broadcast/multicast data type frames that Address 3 matching RTL8190‟s MAC address. This bit is valid only when NETYPE (bit 3-2, MSR) is set to Link OK on an Infrastructure network. */
-#define BIT_AB                                     ((u32)0x00000001 << 3)          /*!<R/W 0  Accept Broadcast packets. This bit determines whether broadcast packets will be accepted or rejected. 1: Accept 0: Reject */
-#define BIT_AM                                     ((u32)0x00000001 << 2)          /*!<R/W 0  Accept Multicast packets. This bit determines whether multicast packets will be accepted or rejected. 1: Accept 0: Reject */
-#define BIT_APM                                    ((u32)0x00000001 << 1)          /*!<R/W 0  Accept Physical Match packets. This bit determines whether physical match packets will be accepted or rejected. 1: Accept 0: Reject */
-#define BIT_AAP                                    ((u32)0x00000001 << 0)          /*!<R/W 0  Accept Destination Address packets. This bit determines whether packets with a destination address will be accepted or rejected. 1: Accept 0: Reject */
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_RXPKT_CTL
- * @brief RX Packet Control Register
- * @{
- *****************************************************************************/
-#define BIT_APP_PHYSTS_PER_SUBMPDU                 ((u32)0x00000001 << 31)          /*!<R/W 0  When this bit is set to 1,append phy status for each mpdu if phy status is valid. Otherwise,append phy status for each ppdu. */
-#define BIT_APP_MH_SHIFT_VAL                       ((u32)0x00000001 << 30)          /*!<R/W 0  When this bit is set to 1,append MAC header shift value in rx descriptor,otherwise, not append */
-#define BIT_WMAC_ENSHIFT                           ((u32)0x00000001 << 29)          /*!<R/W 0  MAC header shift function enable signal in MACRX */
-#define BIT_MASK_RX_DRVINFO_SZ                     ((u32)0x0000000F << 24)          /*!<R/W 0x4  RX DESC Driver Info Size: For RXPKTBUF layout, this field indicates the offset starting from the end of RXDESC to the beginning of RX packet. The unit is 8-byte. This value will be copied to DRV_INFO_SIZE field in RXDESC. */
-#define BIT_RX_DRVINFO_SZ(x)                       ((u32)(((x) & 0x0000000F) << 24))
-#define BIT_GET_RX_DRVINFO_SZ(x)                   ((u32)(((x >> 24) & 0x0000000F)))
-#define BIT_MBID_EN                                ((u32)0x00000001 << 23)          /*!<R/W 0   */
-#define BIT_MASK_MBID_BCNNO                        ((u32)0x00000007 << 20)          /*!<R/W 0   */
-#define BIT_MBID_BCNNO(x)                          ((u32)(((x) & 0x00000007) << 20))
-#define BIT_GET_MBID_BCNNO(x)                      ((u32)(((x >> 20) & 0x00000007)))
-#define BIT_MASK_RX_DLK_TIME                       ((u32)0x000000FF << 8)          /*!<R/W 0x04  macrx dead lock timer timeout value (unit in 4us). As data_on is deasserted and no RXD is received but macrx still waits coming RXD, the deadlock timer will be enabled in this case */
-#define BIT_RX_DLK_TIME(x)                         ((u32)(((x) & 0x000000FF) << 8))
-#define BIT_GET_RX_DLK_TIME(x)                     ((u32)(((x >> 8) & 0x000000FF)))
-#define BIT_MASK_RXPKTLMT                          ((u32)0x0000003F << 0)          /*!<R/W 0x10  RX PKT Upper Limit. The unit is 512 bytes. When “0”, no RX limit is forced. */
-#define BIT_RXPKTLMT(x)                            ((u32)(((x) & 0x0000003F) << 0))
-#define BIT_GET_RXPKTLMT(x)                        ((u32)(((x >> 0) & 0x0000003F)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_MACID
- * @brief MAC ID Register
- * @{
- *****************************************************************************/
-#define BIT_MASK_MACID_V1                          ((u32)0xFFFFFFFF << 0)          /*!<R/W 0  MAC Identification Number Register BIT[31:0] */
-#define BIT_MACID_V1(x)                            ((u32)(((x) & 0xFFFFFFFF) << 0))
-#define BIT_GET_MACID_V1(x)                        ((u32)(((x >> 0) & 0xFFFFFFFF)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_MACID_H
- * @brief MAC ID Register
- * @{
- *****************************************************************************/
-#define BIT_AP_BSSID_FIT_UC                        ((u32)0x00000001 << 21)          /*!<R/W 0  When set1,bssid fit when AP port0 rx unciast data packet */
-#define BIT_EN_PORT1                               ((u32)0x00000001 << 17)          /*!<R/W 0x1  When set1,enable PORT1 */
-#define BIT_EN_PORT0                               ((u32)0x00000001 << 16)          /*!<R/W 0x1  When set1,enable PORT0 */
-#define BIT_MASK_MACID_H                           ((u32)0x0000FFFF << 0)          /*!<R/W 0  MAC Identification Number Register BIT[47:32] */
-#define BIT_MACID_H(x)                             ((u32)(((x) & 0x0000FFFF) << 0))
-#define BIT_GET_MACID_H(x)                         ((u32)(((x >> 0) & 0x0000FFFF)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_BSSID
- * @brief BSSID Register
- * @{
- *****************************************************************************/
-#define BIT_MASK_BSSID_V1                          ((u32)0xFFFFFFFF << 0)          /*!<R/W 0  Basic Station Set Identification BIT[31:0] */
-#define BIT_BSSID_V1(x)                            ((u32)(((x) & 0xFFFFFFFF) << 0))
-#define BIT_GET_BSSID_V1(x)                        ((u32)(((x >> 0) & 0xFFFFFFFF)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_BSSID_H
- * @brief BSSID Register
- * @{
- *****************************************************************************/
-#define BIT_MASK_BSSID_H                           ((u32)0x0000FFFF << 0)          /*!<R/W 0  Basic Station Set Identification BIT[47:32] */
-#define BIT_BSSID_H(x)                             ((u32)(((x) & 0x0000FFFF) << 0))
-#define BIT_GET_BSSID_H(x)                         ((u32)(((x >> 0) & 0x0000FFFF)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_MAR
- * @brief Multicast Address Register
- * @{
- *****************************************************************************/
-#define BIT_MASK_MAR_V1                            ((u32)0xFFFFFFFF << 0)          /*!<R/W 0  Multicast Address Register BIT[31:0]. The value of this register is written by the driver to specify the type of multicast address supported by RTL8192D. The value is created by a hashed calculation that is also implemented by the hardware for multicast address filtering. */
-#define BIT_MAR_V1(x)                              ((u32)(((x) & 0xFFFFFFFF) << 0))
-#define BIT_GET_MAR_V1(x)                          ((u32)(((x >> 0) & 0xFFFFFFFF)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_MAR_H
- * @brief Multicast Address Register
- * @{
- *****************************************************************************/
-#define BIT_MASK_MAR_H                             ((u32)0xFFFFFFFF << 0)          /*!<R/W 0  Multicast Address Register BIT[63:32].The value of this register is written by the driver to specify the type of multicast address supported by RTL8192D. The value is created by a hashed calculation that is also implemented by the hardware for multicast address filtering. */
-#define BIT_MAR_H(x)                               ((u32)(((x) & 0xFFFFFFFF) << 0))
-#define BIT_GET_MAR_H(x)                           ((u32)(((x >> 0) & 0xFFFFFFFF)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_MBIDCAMCFG_1
- * @brief MBSSID CAM Configuration Register
- * @{
- *****************************************************************************/
-#define BIT_MASK_MBIDCAM_WDATA_L                   ((u32)0xFFFFFFFF << 0)          /*!<R/W 0  BSSID[31:0] */
-#define BIT_MBIDCAM_WDATA_L(x)                     ((u32)(((x) & 0xFFFFFFFF) << 0))
-#define BIT_GET_MBIDCAM_WDATA_L(x)                 ((u32)(((x >> 0) & 0xFFFFFFFF)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_MBIDCAM_CFG
- * @brief MBSSID CAM Configuration Register
- * @{
- *****************************************************************************/
-#define BIT_MBIDCAM_POLL                           ((u32)0x00000001 << 31)          /*!<W 0  Pooling bit. */
-#define BIT_MBIDCAM_WT_EN                          ((u32)0x00000001 << 30)          /*!<R/W 0  Write Enable. */
-#define BIT_MBIDCAM_DA_EN                          ((u32)0x00000001 << 29)          /*!<R/W 0  CAM Direct Acess Enable */
-#define BIT_MASK_MBIDCAM_ADDR_V1                   ((u32)0x0000001F << 24)          /*!<R/W 0  CAM Address */
-#define BIT_MBIDCAM_ADDR_V1(x)                     ((u32)(((x) & 0x0000001F) << 24))
-#define BIT_GET_MBIDCAM_ADDR_V1(x)                 ((u32)(((x >> 24) & 0x0000001F)))
-#define BIT_MBIDCAM_VALID                          ((u32)0x00000001 << 23)          /*!<R/W 0  CAM Valid bit. */
-#define BIT_LSIC_TXOP_EN                           ((u32)0x00000001 << 17)          /*!<R/W 0  LSIG TXOP enable */
-#define BIT_CTS_EN                                 ((u32)0x00000001 << 16)          /*!<R/W 0  Dual CTS/CFE enable */
-#define BIT_MASK_MBIDCAM_RWDATA_H                  ((u32)0x0000FFFF << 0)          /*!<R/W 0  BSSID[47:32] */
-#define BIT_MBIDCAM_RWDATA_H(x)                    ((u32)(((x) & 0x0000FFFF) << 0))
-#define BIT_GET_MBIDCAM_RWDATA_H(x)                ((u32)(((x >> 0) & 0x0000FFFF)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_WMAC_TCR_CTL
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_MASK_ZLD_NUM                           ((u32)0x000000FF << 24)          /*!<R/W 0x8  Fetch zero length delimiter number(unit : 4bytes) when mactx underflow */
-#define BIT_ZLD_NUM(x)                             ((u32)(((x) & 0x000000FF) << 24))
-#define BIT_GET_ZLD_NUM(x)                         ((u32)(((x >> 24) & 0x000000FF)))
-#define BIT_UDF_THSD_V1                            ((u32)0x00000001 << 23)          /*!<R/W 0x1  BIT_UDF_THSD[7]=1,enable underflow recovery;r_UDF_THSD[7]=0,disable underflow recovery; BIT_UDF_THSD[6:0]: when mac_wrptr - PHY_rdptr is less than this value, set underflow; */
-#define BIT_MASK_UDF_THSD_VALUE                    ((u32)0x0000007F << 16)          /*!<R/W 0x6  Underflow threshold */
-#define BIT_UDF_THSD_VALUE(x)                      ((u32)(((x) & 0x0000007F) << 16))
-#define BIT_GET_UDF_THSD_VALUE(x)                  ((u32)(((x >> 16) & 0x0000007F)))
-#define BIT_MASK_WMAC_TCR_TSFT_OFS                 ((u32)0x0000FFFF << 0)          /*!<R/W 0x450  BIT_WMAC_TCR_TSFT_OFS[7:0] is for cck stamp time offset; BIT_WMAC_TCR_TSFT_OFS[15:8] is for ofdm rate time offset; */
-#define BIT_WMAC_TCR_TSFT_OFS(x)                   ((u32)(((x) & 0x0000FFFF) << 0))
-#define BIT_GET_WMAC_TCR_TSFT_OFS(x)               ((u32)(((x >> 0) & 0x0000FFFF)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_STMP_THSD
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_MASK_WMAC_TCR_E_TSFT_OFS               ((u32)0x000000FF << 8)          /*!<R/W 0x8  BIT_WMAC_TCR_TSFT_OFS[7:0] is for ht/vht/he stamp time offset; */
-#define BIT_WMAC_TCR_E_TSFT_OFS(x)                 ((u32)(((x) & 0x000000FF) << 8))
-#define BIT_GET_WMAC_TCR_E_TSFT_OFS(x)             ((u32)(((x >> 8) & 0x000000FF)))
-#define BIT_MASK_STMP_THSD                         ((u32)0x000000FF << 0)          /*!<R/W 0x2  when PHY_rdptr is greater than this value, then latch STMP value from TSFT */
-#define BIT_STMP_THSD(x)                           ((u32)(((x) & 0x000000FF) << 0))
-#define BIT_GET_STMP_THSD(x)                       ((u32)(((x >> 0) & 0x000000FF)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_USTIME_EDCA
- * @brief US Time Tuning for EDCA Register
- * @{
- *****************************************************************************/
-#define BIT_MASK_SPEC_SIFS_OFDM                    ((u32)0x000000FF << 24)          /*!<R/W 0x10  The spec SIFS value for duration calculation */
-#define BIT_SPEC_SIFS_OFDM(x)                      ((u32)(((x) & 0x000000FF) << 24))
-#define BIT_GET_SPEC_SIFS_OFDM(x)                  ((u32)(((x >> 24) & 0x000000FF)))
-#define BIT_MASK_SPEC_SIFS_CCK                     ((u32)0x000000FF << 16)          /*!<R/W 0x0A  The spec SIFS value for duration calculation */
-#define BIT_SPEC_SIFS_CCK(x)                       ((u32)(((x) & 0x000000FF) << 16))
-#define BIT_GET_SPEC_SIFS_CCK(x)                   ((u32)(((x >> 16) & 0x000000FF)))
-#define BIT_MASK_USTIME_EDCA                       ((u32)0x000000FF << 0)          /*!<R/W 0x28  Sets the microsecond time unit used by MAC EDCA clock. */
-#define BIT_USTIME_EDCA(x)                         ((u32)(((x) & 0x000000FF) << 0))
-#define BIT_GET_USTIME_EDCA(x)                     ((u32)(((x >> 0) & 0x000000FF)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_RESP_SIFS_CCK
- * @brief Response SIFS for CCK Register
- * @{
- *****************************************************************************/
-#define BIT_MASK_ACKTO_CCK                         ((u32)0x00000FFF << 12)          /*!<R/W 0x7E  This register sets the Ack time out value after Tx unicast packet with CCK rate. It is in units of us. */
-#define BIT_ACKTO_CCK(x)                           ((u32)(((x) & 0x00000FFF) << 12))
-#define BIT_GET_ACKTO_CCK(x)                       ((u32)(((x >> 12) & 0x00000FFF)))
-#define BIT_MASK_ACKTO_OFDM                        ((u32)0x00000FFF << 0)          /*!<R/W 0x2D  This register sets the Ack time out value after Tx unicast packet. It is in units of us. */
-#define BIT_ACKTO_OFDM(x)                          ((u32)(((x) & 0x00000FFF) << 0))
-#define BIT_GET_ACKTO_OFDM(x)                      ((u32)(((x >> 0) & 0x00000FFF)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_ACKTO
- * @brief ACK Timeout Register
- * @{
- *****************************************************************************/
-#define BIT_MASK_EIFS                              ((u32)0x0000FFFF << 16)          /*!<R/W 0x013A  This register sets the EIFS value mentioned in 802.11 specification. It is in units of us. To receive 1Mbps ACK frame, EIFS = SIFS + 144us (preamble length) + 48us (PLCP header length) + 112us (14 bytes of data) = 314us. */
-#define BIT_EIFS(x)                                ((u32)(((x) & 0x0000FFFF) << 16))
-#define BIT_GET_EIFS(x)                            ((u32)(((x >> 16) & 0x0000FFFF)))
-#define BIT_R_RESP_ERSU_DISUSE_RX                  ((u32)0x00000001 << 13)          /*!<R/W 0  0:rx er su will response tx er su */
-#define BIT_R_RESP_DCM_DISUSE_RX                   ((u32)0x00000001 << 12)          /*!<R/W 0  0:rx dcm will response tx dcm when ctrl info is valid and inf0_dcm=1 */
-#define BIT_MASK_CTS2TO                            ((u32)0x00000FFF << 0)          /*!<R/W 0x2D  This register sets the CTS2 time out value after CTS1 in Dual CTS sequence. It is in units of us. */
-#define BIT_CTS2TO(x)                              ((u32)(((x) & 0x00000FFF) << 0))
-#define BIT_GET_CTS2TO(x)                          ((u32)(((x >> 0) & 0x00000FFF)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_NAV_THRSHOLD
- * @brief NAV Threshold Register
- * @{
- *****************************************************************************/
-#define BIT_MASK_NAV_UPBDY                         ((u32)0x000000FF << 16)          /*!<R/W 0  When NAV update is beyond this value, then NAV update is aborted. When this field is 0x00, NAV_UPPER function is disable. The unit is 128us. */
-#define BIT_NAV_UPBDY(x)                           ((u32)(((x) & 0x000000FF) << 16))
-#define BIT_GET_NAV_UPBDY(x)                       ((u32)(((x >> 16) & 0x000000FF)))
-#define BIT_MASK_RXMYRTS_NAV                       ((u32)0x0000000F << 8)          /*!<R/W 0x4  RX my RTS NAV. As rx my unicast RTS and RxMyRTS_NAV is not equal to zero, then rx NAV is set to wait response transition time and RxMyRTS_NAV to avoid contention with the TXOP originator. If RxMyRTS_NAV is equal to zero, this mechanism is disabled */
-#define BIT_RXMYRTS_NAV(x)                         ((u32)(((x) & 0x0000000F) << 8))
-#define BIT_GET_RXMYRTS_NAV(x)                     ((u32)(((x >> 8) & 0x0000000F)))
-#define BIT_MASK_RTS_RST_DUR                       ((u32)0x000000FF << 0)          /*!<R/W 0x26  RTS NAV Reset Time. This is the value in us, not including the time of CTS frame, to reset the NAV set by an RTS frame if no PHY indication occurred during this time. Refer to 802.11 1999 Section 9.2.5.4 for detailed description. */
-#define BIT_RTS_RST_DUR(x)                         ((u32)(((x) & 0x000000FF) << 0))
-#define BIT_GET_RTS_RST_DUR(x)                     ((u32)(((x >> 0) & 0x000000FF)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_BACAMCMD
- * @brief Block ACK CAM Command Register
- * @{
- *****************************************************************************/
-#define BIT_BACAM_POLL                             ((u32)0x00000001 << 31)          /*!<W 0  Polling bit BA CAM */
-#define BIT_BACAM_RST                              ((u32)0x00000001 << 17)          /*!<RW1C 0  Set 1 to reset BA CAM. Hardware will set the invalid bit for all entries. After reset is finished this bit is reset to 0. */
-#define BIT_BACAM_RW                               ((u32)0x00000001 << 16)          /*!<R/W 0  Set 1 = Write, set 0 = Read */
-#define BIT_MASK_TXSBMPMOD                         ((u32)0x00000003 << 14)          /*!<R/W 0  Bit[15]: if macrx_dma idle, grant txsbmp_req Bit[14]: if macrx is idle, grant txsbmp_req 00: If FSM is idle, grant txsbmp_req 01: If FSM and mac rx is idle, grant txsbmp_req 10: If FSM and macrx_dma is idle, grant txsbmp_req 11: if FSM, macrx and macrx_dma is idle, grant txsbmp_req */
-#define BIT_TXSBMPMOD(x)                           ((u32)(((x) & 0x00000003) << 14))
-#define BIT_GET_TXSBMPMOD(x)                       ((u32)(((x >> 14) & 0x00000003)))
-#define BIT_RXBACAM_DA_EN                          ((u32)0x00000001 << 13)          /*!<R/W 0  CAM Direct Acess enable */
-#define BIT_MASK_BACAM_AD                          ((u32)0x0000003F << 0)          /*!<R/W 0  BA CAM address. Memory is double-word access. */
-#define BIT_BACAM_AD(x)                            ((u32)(((x) & 0x0000003F) << 0))
-#define BIT_GET_BACAM_AD(x)                        ((u32)(((x >> 0) & 0x0000003F)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_BACAM_WD
- * @brief Block ACK CAM Content Register
- * @{
- *****************************************************************************/
-#define BIT_MASK_BA_CONTENT_L                      ((u32)0xFFFFFFFF << 0)          /*!<R/W 0  Used for CAM content read and write access register. Because BA CAM is 64 bit access, the double word (32-bit) responds to the lower 32 bits of CAM content. */
-#define BIT_BA_CONTENT_L(x)                        ((u32)(((x) & 0xFFFFFFFF) << 0))
-#define BIT_GET_BA_CONTENT_L(x)                    ((u32)(((x >> 0) & 0xFFFFFFFF)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_BACAM_WD_H
- * @brief Block ACK CAM Content Register
- * @{
- *****************************************************************************/
-#define BIT_MASK_BA_CONTENT_H                      ((u32)0xFFFFFFFF << 0)          /*!<R/W 0  Used for CAM content read and write access register. Because BA CAM is 64 bit access, the double word (32-bit) responds to the upper 32 bits of CAM content. */
-#define BIT_BA_CONTENT_H(x)                        ((u32)(((x) & 0xFFFFFFFF) << 0))
-#define BIT_GET_BA_CONTENT_H(x)                    ((u32)(((x >> 0) & 0xFFFFFFFF)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_LBK_DLY
- * @brief Loopback Delay Register
- * @{
- *****************************************************************************/
-#define BIT_BITMAP_FLAG_VO                         ((u32)0x00000001 << 31)          /*!<RW1C 0  When BIT_BITMAP_VO = 1, HW will check received packet's sequence number by BIT_BITMAP_CONDITION, and clear the bit after occur one time which received the correct sequence number. */
-#define BIT_BITMAP_FLAG_VI                         ((u32)0x00000001 << 30)          /*!<RW1C 0  When BIT_BITMAP_VI = 1, HW will check received packet’s sequence number by BIT_BITMAP_CONDITION, and clear the bit after occur one time which received the correct sequence number. */
-#define BIT_BITMAP_FLAG_BE                         ((u32)0x00000001 << 29)          /*!<RW1C 0  When BIT_BITMAP_BE = 1, HW will check received packet's sequence number by BIT_BITMAP_CONDITION, and clear the bit after occur one time which received the correct sequence number. */
-#define BIT_BITMAP_FLAG_BK                         ((u32)0x00000001 << 28)          /*!<RW1C 0  When BIT_BITMAP_BK = 1, HW will check received packet's sequence number by BIT_BITMAP_CONDITION, and clear the bit after occur one time which received the correct sequence number. */
-#define BIT_MASK_BITMAP_CONDITION                  ((u32)0x00000003 << 26)          /*!<R/W 0  ADDBA condition: 0: HW start sequence - 64. 1: HW start sequence - 128. 2: HW start sequence - 256. 3: HW start sequence - 512. */
-#define BIT_BITMAP_CONDITION(x)                    ((u32)(((x) & 0x00000003) << 26))
-#define BIT_GET_BITMAP_CONDITION(x)                ((u32)(((x >> 26) & 0x00000003)))
-#define BIT_BITMAP_SSNBK_COUNTER_CLR               ((u32)0x00000001 << 25)          /*!<RW1C 0  Clear BIT_BITMAP_SSNBK_COUNTER. */
-#define BIT_BITMAP_FORCE                           ((u32)0x00000001 << 24)          /*!<R/W 0  Under the BIT_BITMAP_EN = 1 condition. 1: Rx’s packet always checks sequence number by BIT_BITMAP_CONDITION. 0: Disable */
-#define BIT_MASK_RXPKT_TYPE                        ((u32)0x0000003F << 18)          /*!<R 0  The type and subtype field of frame control of rx packet */
-#define BIT_RXPKT_TYPE(x)                          ((u32)(((x) & 0x0000003F) << 18))
-#define BIT_GET_RXPKT_TYPE(x)                      ((u32)(((x >> 18) & 0x0000003F)))
-#define BIT_TXACT_IND                              ((u32)0x00000001 << 17)          /*!<R 0  Indicate MAC/PHY is busy to tx packet */
-#define BIT_RXACT_IND                              ((u32)0x00000001 << 16)          /*!<R 0  Indicate MAC is busy to rx packet */
-#define BIT_MASK_BITMAP_SSNBK_COUNTER              ((u32)0x0000003F << 10)          /*!<R 0  Count the sequence number out of BITMAP condition (0x663[3:2]). */
-#define BIT_BITMAP_SSNBK_COUNTER(x)                ((u32)(((x) & 0x0000003F) << 10))
-#define BIT_GET_BITMAP_SSNBK_COUNTER(x)            ((u32)(((x >> 10) & 0x0000003F)))
-#define BIT_BITMAP_EN                              ((u32)0x00000001 << 9)          /*!<R/W 0  1:Enable of counter and WMAC_BITMAP_CTL(0x663) 0:Disable function */
-#define BIT_BACAM_RPMEN                            ((u32)0x00000001 << 8)          /*!<R/W 0  1:Enable repeat mode 0:Disable function */
-#define BIT_MASK_LBK_DLY                           ((u32)0x0000001F << 0)          /*!<R/W 0x19  Loopback Delay. In unit of 'us'; indicates the delay after which the tdrdy_mac starts. In wep/tkip mode, the delay should be larger than 15, because the initial delay of security is about 1320 cycles, approximately to 16.5 us. */
-#define BIT_LBK_DLY(x)                             ((u32)(((x) & 0x0000001F) << 0))
-#define BIT_GET_LBK_DLY(x)                         ((u32)(((x >> 0) & 0x0000001F)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_RXERR_RPT
- * @brief RX Error Report Register
- * @{
- *****************************************************************************/
-#define BIT_MASK_RXERR_RPT_SEL_V1_3_0              ((u32)0x0000000F << 28)          /*!<R/W 0  Rx packet counter report selection bit3~bit0 RXERR_RPT_SEL[25,26,31:28]: Counter description 6'd0: OFDM MPDU OK counter 6'd1: OFDM MPDU Fail counter 6'd2: OFDM False Alarm counter 6'd3: CCK MPDU OK counter 6'd4: CCK MPDU Fail counter 6'd5: CCK False Alarm counter; 6'd6: HT MPDU OK counter 6'd7: HT MPDU Fail counter 6'd8: HT PPDU PLCP ok counter 6'd9: HT False Alarm counter 6'd10: Rx full drop packet counter 6'd11: RSVD 6'd12: user define 0 counter 6'd13: user define 1 counter 6'd14: user define 2 counter 6'd15: user define 3 counter 6'd16: VHT SU MPDU OK counter 6'd17: VHT SU MPDU Fail counter 6'd18: VHT SU PPDU plcp ok counter 6'd19: VHT SU False Alarm counter 6'd20: invalid_pkt counter 6'd21: VHT MU MPDU OK counter 6'd22: VHT MU MPDU Fail counter 6'd23: VHT MU PPDU plcp ok counter 6'd24: VHT MU False Alarm counter 6'd25: HE SU MPDU OK counter 6'd26: HE SU MPDU Fail counter 6'd27: HE SU PPDU plcp ok counter 6'd28: HE SU False Alarm counter 6'd29: HE MU MPDU OK counter 6'd30: HE MU MPDU Fail counter 6'd31: HE MU PPDU plcp ok counter 6'd32: HE MU False Alarm counter 6'd33: drop packet counter */
-#define BIT_RXERR_RPT_SEL_V1_3_0(x)                ((u32)(((x) & 0x0000000F) << 28))
-#define BIT_GET_RXERR_RPT_SEL_V1_3_0(x)            ((u32)(((x >> 28) & 0x0000000F)))
-#define BIT_RXERR_RPT_RST                          ((u32)0x00000001 << 27)          /*!<WA0 0  Write “1” to set the counter to zero. One pulse */
-#define BIT_RXERR_RPT_SEL_V1_4                     ((u32)0x00000001 << 26)          /*!<R/W 0  Rx packet counter report selection bit4 */
-#define BIT_RXERR_RPT_SEL_V1_5                     ((u32)0x00000001 << 25)          /*!<R/W 0  Rx packet counter report selection bit5 */
-#define BIT_UD_SELECT_BSSID_1                      ((u32)0x00000001 << 24)          /*!<R/W 0  {24,22} Select matched BSSID: 2'b0: Port 0 2'b1: Port 1 otherwise, do not care bssid match or not */
-#define BIT_W1S                                    ((u32)0x00000001 << 23)          /*!<R/W 0  Write One Setting, it is only valid for RXERR_RPT_SEL (4'd12 ~ 4'd15) */
-#define BIT_UD_SELECT_BSSID_0                      ((u32)0x00000001 << 22)          /*!<R/W 0  Select BSSID bit0 */
-#define BIT_MASK_UD_SUB_TYPE                       ((u32)0x0000000F << 18)          /*!<R/W 0  User defined: SubType */
-#define BIT_UD_SUB_TYPE(x)                         ((u32)(((x) & 0x0000000F) << 18))
-#define BIT_GET_UD_SUB_TYPE(x)                     ((u32)(((x >> 18) & 0x0000000F)))
-#define BIT_MASK_UD_TYPE                           ((u32)0x00000003 << 16)          /*!<R/W 0  User defined: Type */
-#define BIT_UD_TYPE(x)                             ((u32)(((x) & 0x00000003) << 16))
-#define BIT_GET_UD_TYPE(x)                         ((u32)(((x >> 16) & 0x00000003)))
-#define BIT_MASK_RPT_COUNTER                       ((u32)0x0000FFFF << 0)          /*!<R/W 0  The reported counter value corresponding to Report type selected. */
-#define BIT_RPT_COUNTER(x)                         ((u32)(((x) & 0x0000FFFF) << 0))
-#define BIT_GET_RPT_COUNTER(x)                     ((u32)(((x >> 0) & 0x0000FFFF)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_WMAC_TRXPTCL_CTL
- * @brief WMAC TX/RX Protocol Control Register
- * @{
- *****************************************************************************/
-#define BIT_BLK_EDCA_BBSLP                         ((u32)0x00000001 << 31)          /*!<R/W 0  Block EDCA Tx while BB in sleep state */
-#define BIT_BLK_EDCA_BBSBY                         ((u32)0x00000001 << 30)          /*!<R/W 0  Block EDCA Tx while BB in standby state */
-#define BIT_EN_STOP_UPDNAV                         ((u32)0x00000001 << 28)          /*!<R/W 0  When this bit set 1. If RX packet with EDCA_REF is low, not update NAV. */
-#define BIT_RST_EDCA_ACKTO                         ((u32)0x00000001 << 27)          /*!<R/W 1  While in ACKTO duration, reset scheduler top to TX */
-#define BIT_RST_EDCA_EIFS                          ((u32)0x00000001 << 26)          /*!<R/W 1  While in EIFS duration, reset scheduler top to TX */
-#define BIT_PLCPCHK_RST_EIFS                       ((u32)0x00000001 << 25)          /*!<R/W 1  Reset EIFS counter while receive correct PLCP. */
-#define BIT_CCA_RST_EIFS                           ((u32)0x00000001 << 24)          /*!<R/W 0  Reset EIFS counter while CCA on */
-#define BIT_DIS_UPD_MYRXPKTNAV                     ((u32)0x00000001 << 23)          /*!<R/W 1  Do not update NAV, while receiving my packet. */
-#define BIT_EARLY_TXBA                             ((u32)0x00000001 << 22)          /*!<R/W 0  While phyrxon down, mac_rxactive on. Ignore mac rx busy, respond BA immediately. */
-#define BIT_MASK_RESP_CHNBUSY                      ((u32)0x00000003 << 20)          /*!<R/W 0x2  Define channel busy condition in responder to determine RX busy 1: PHYRXON (OFDM_VBON/CCKCCA) 0: CCA (CCKCCA/OFDMCCA) */
-#define BIT_RESP_CHNBUSY(x)                        ((u32)(((x) & 0x00000003) << 20))
-#define BIT_GET_RESP_CHNBUSY(x)                    ((u32)(((x >> 20) & 0x00000003)))
-#define BIT_RESP_DCTS_EN                           ((u32)0x00000001 << 19)          /*!<R/W 0  Enable responder send dual CTS for responding Rx RTS */
-#define BIT_RESP_DCFE_EN                           ((u32)0x00000001 << 18)          /*!<R/W 0  Enable responder send dual CF-END for responding RX CF-END */
-#define BIT_RESP_SPLCPEN                           ((u32)0x00000001 << 17)          /*!<R/W 0  Enable responder send SPLCP CCK response for acknowledging Rx SPLCP CCK packet */
-#define BIT_RESP_SGIEN                             ((u32)0x00000001 << 16)          /*!<R/W 0  Enable responder send SGI HT-OFDM response for acknowledging Rx SGI HT-OFDM packet */
-#define BIT_RESP_LDPC_EN                           ((u32)0x00000001 << 15)          /*!<R/W 0  if rxpkt with ldpc, response pkt with ldpc */
-#define BIT_DIS_RESP_ACKINCCA                      ((u32)0x00000001 << 14)          /*!<R/W 0  Disable to response ack when cca goes high after SIFS */
-#define BIT_DIS_RESP_CTSINCCA                      ((u32)0x00000001 << 13)          /*!<R/W 0  8812 Disable to response cts when cca goes high after SIFS */
-#define BIT_MASK_SECOND_CCA_TIMER                  ((u32)0x00000007 << 10)          /*!<R/W 0x4  8812 The maximum time interval in us that secondary cca is pull high before primary cca When receive duplicated rts. When station response with cts, if the time that secondary cca pull high before primary cca is larger than this threshold, then secondary cca is judged to be interference, otherwise it is judged to the received RTS frame. default: 3‟b0 */
-#define BIT_SECOND_CCA_TIMER(x)                    ((u32)(((x) & 0x00000007) << 10))
-#define BIT_GET_SECOND_CCA_TIMER(x)                ((u32)(((x >> 10) & 0x00000007)))
-#define BIT_MASK_RFMOD                             ((u32)0x00000003 << 7)          /*!<R/W 0  8812 RF_BW indication, Used to decide response duplicated cts txsc 2‟b00: 20M, 2‟b01: 40M, 2‟b10: 80M e.g: when RF_BW= 80M, duplicated cts BW= 40M, txsc = 9 or 10 when RF_BW = 40M, duplicated cts BW = 40M, txsc = 0 */
-#define BIT_RFMOD(x)                               ((u32)(((x) & 0x00000003) << 7))
-#define BIT_GET_RFMOD(x)                           ((u32)(((x >> 7) & 0x00000003)))
-#define BIT_MASK_RESP_CTS_DYNBW_SEL                ((u32)0x00000003 << 5)          /*!<R/W 0  8812 Response cts bw selection when dynamic rts frame is received 00: current maximum bw indicated by secondary cca 01: bw fall back by one level based on bw in 2‟b00 if not reach 20M 10: bw fall back by one level based on bw in 2‟b01 if not reach 20M 11: bw fall back by one level based on bw in 2‟b10 if not reach 20M e.g, current maximum bw indicated by secondary_cca is 80M, when set to 2‟b00, the response cts bw is 80M, when set to 2‟b01, cts bw is 40M, when set to 2‟b10 or 2‟b11 , cts bw is 20M */
-#define BIT_RESP_CTS_DYNBW_SEL(x)                  ((u32)(((x) & 0x00000003) << 5))
-#define BIT_GET_RESP_CTS_DYNBW_SEL(x)              ((u32)(((x >> 5) & 0x00000003)))
-#define BIT_DLY_TX_WAIT_RXANTSEL                   ((u32)0x00000001 << 4)          /*!<R/W 0  8188E/8812 In some Cases, the phy status may be received too late to be used in the response frame. Enable this bit to postpone the tx of response frame until the phy status is obtained. Otherwise, If the phy status unavailable for its delay, The IOREG value of 0x06D8[6] will be used as before. */
-#define BIT_TXRESP_BY_RXANTSEL                     ((u32)0x00000001 << 3)          /*!<R/W 0  8188E/8812 Enable responder send the response frame with the antenna selection information which from the phy status of the previous rx frame. */
-#define BIT_MASK_ORIG_DCTS_CHK                     ((u32)0x00000003 << 0)          /*!<R/W 0  Txok condition for dual CTS frame exchange: 00: Either one Rx ok 01: 1st one Rx ok 10: 2nd one Rx ok 11: both Rx ok */
-#define BIT_ORIG_DCTS_CHK(x)                       ((u32)(((x) & 0x00000003) << 0))
-#define BIT_GET_ORIG_DCTS_CHK(x)                   ((u32)(((x >> 0) & 0x00000003)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_WMAC_TRXPTCL_CTL_H
- * @brief WMAC TX/RX Protocol Control Register Higher Bit
- * @{
- *****************************************************************************/
-#define BIT_MASK_ACKBA_TYPSEL                      ((u32)0x0000000F << 28)          /*!<R/W 0  Determine response type for RX BA, and the definition as the bellow 0: NAV 1: Send ACK ACKBA_TYPESEL[0]: used for Basic BA ACKBA_TYPESEL[1]: used for Compression BA ACKBA_TYPESEL[2]: RSVD ACKBA_TYPESEL[3]: used for MTID BA */
-#define BIT_ACKBA_TYPSEL(x)                        ((u32)(((x) & 0x0000000F) << 28))
-#define BIT_GET_ACKBA_TYPSEL(x)                    ((u32)(((x >> 28) & 0x0000000F)))
-#define BIT_MASK_ACKBA_ACKPCHK                     ((u32)0x0000000F << 24)          /*!<R/W 0  If set 1, then check ACK Policy of BA control field to determine whether send response or not. When this bit set to 1 and a. ACK Policy of Rx BA control field is 0, then response type is controlled by ACLBA_TYPESEL. b. ACK Policy of Rx BA control field is 1, then don't send response If set 0, then ignore the ACK policy of RX BA control field and response type controlled by ACKBA_TYPESEL ACKBA_ACKPCHK[0]: used for Basic BA ACKBA_ACKPCHK[1]: used for Compression BA ACKBA_ACKPCHK[2]: RSVD ACKBA_ACKPCHK[3]: used for MTID BA */
-#define BIT_ACKBA_ACKPCHK(x)                       ((u32)(((x) & 0x0000000F) << 24))
-#define BIT_GET_ACKBA_ACKPCHK(x)                   ((u32)(((x >> 24) & 0x0000000F)))
-#define BIT_MASK_ACKBAR_TYPESEL                    ((u32)0x000000FF << 16)          /*!<R/W 0x4  Determine response type for RX BAR, and the definition as the bellow 00: NAV 01: Send BA 10: Send ACK ACKBAR_TYPESEL[1:0]: used for Basic BAR ACKBAR_TYPESEL[3:2]: used for Compression BAR ACKBAR_TYPESEL[5:4]: RSVD ACKBAR_TYPESEL[7:6]: used for MTID BAR */
-#define BIT_ACKBAR_TYPESEL(x)                      ((u32)(((x) & 0x000000FF) << 16))
-#define BIT_GET_ACKBAR_TYPESEL(x)                  ((u32)(((x >> 16) & 0x000000FF)))
-#define BIT_MASK_ACKBAR_ACKPCHK                    ((u32)0x0000000F << 12)          /*!<R/W 0x2  If set 1, then check ACK Policy of BAR control field to determine whether send response or not. When this bit set to 1 and a. ACK Policy of Rx BAR control field is 0, then response type is controlled by ACLBAR_TYPESEL. b. ACK Policy of Rx BAR control field is 1, then don't send response If set 0, then ignore the ACK policy of RX BAR control field and response type controlled by ACKBA_TYPESEL ACKBA_ACKPCHK[0]: used for Basic BAR ACKBA_ACKPCHK[1]: used for Compression BAR ACKBA_ACKPCHK[2]: RSVD ACKBA_ACKPCHK[3]: used for MTID BAR */
-#define BIT_ACKBAR_ACKPCHK(x)                      ((u32)(((x) & 0x0000000F) << 12))
-#define BIT_GET_ACKBAR_ACKPCHK(x)                  ((u32)(((x >> 12) & 0x0000000F)))
-#define BIT_RXBA_IGNOREA2_V1                       ((u32)0x00000001 << 10)          /*!<R/W 0  Disable check A2 field of RX BA */
-#define BIT_EN_SAVE_ALL_TXOPADDR_V1                ((u32)0x00000001 << 9)          /*!<R/W 0   */
-#define BIT_EN_TXCTS_TO_TXOPOWNER_INRXNAV_V1       ((u32)0x00000001 << 8)          /*!<R/W 0  together with bit41, implement 802.11ac txop owner function */
-#define BIT_DIS_TXBA_AMPDUFCSERR_V1                ((u32)0x00000001 << 7)          /*!<R/W 0  Disable to send BA for responding RX AMPDU with FCS error subframe */
-#define BIT_DIS_TXBA_RXBARINFULL_V1                ((u32)0x00000001 << 6)          /*!<R/W 0  Disable to send BA for responding RX control wrapper BAR dropped by rxpkbuffer full */
-#define BIT_DIS_TXCFE_INFULL_V1                    ((u32)0x00000001 << 5)          /*!<R/W 0  Disable to send CF-END for responding RX control wrapper CF-END dropped by rxpktbuffer full. This bit is valid when RESP_DCFE_EN is set to 1 */
-#define BIT_DIS_TXCTS_INFULL_V1                    ((u32)0x00000001 << 4)          /*!<R/W 0  Disable to send CTS for responding RX control wrapper RTS dropped by rxpktbuffer full */
-#define BIT_EN_TXACKBA_INTX_RDG_V1                 ((u32)0x00000001 << 3)          /*!<R/W 0  If this bit is set, then MAC will Tx ACK/BA to respond previous rx my unicast packets send by another STA during TX RDG */
-#define BIT_EN_TXACKBA_INTXOP_V1                   ((u32)0x00000001 << 2)          /*!<R/W 1  If this bit is set, then MAC will Tx ACK/BA to respond previous rx my unitcast packets send by another STA during my TXOP */
-#define BIT_EN_TXCTS_INRXNAV_V1                    ((u32)0x00000001 << 1)          /*!<R/W 1  Enable to send CTS in Rx NAV */
-#define BIT_EN_TXCTS_INTXOP_V1                     ((u32)0x00000001 << 0)          /*!<R/W 1  Enable to send CTS for responding RX RTS during our TXOP period */
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_KEYCAMCMD
- * @brief CAM Command Register
- * @{
- *****************************************************************************/
-#define BIT_KEYCAM_POLLING                         ((u32)0x00000001 << 31)          /*!<R 0  Security CAM Polling */
-#define BIT_KEYCAM_CLEAR                           ((u32)0x00000001 << 30)          /*!<W1C 0  Set to 1 to clear all valid bits in CAM. After reset will self clear to 0. */
-#define BIT_MFBCAM_CLEAR                           ((u32)0x00000001 << 29)          /*!<W1C 0  Write 1 to clear all MFB value in CAM to 7'h7F. After reset will self clear to 0 */
-#define BIT_KEYCAM_DA_EN                           ((u32)0x00000001 << 17)          /*!<R/W 0  Security CAM Direct Acess Enable */
-#define BIT_SECCAM_WE                              ((u32)0x00000001 << 16)          /*!<R/W 0  Security CAM Write Enable */
-#define BIT_MASK_KEYCAM_AD                         ((u32)0x000003FF << 0)          /*!<R/W 0  Security CAM Address Offset CAM address is organized into 8 double-words/entry. */
-#define BIT_KEYCAM_AD(x)                           ((u32)(((x) & 0x000003FF) << 0))
-#define BIT_GET_KEYCAM_AD(x)                       ((u32)(((x >> 0) & 0x000003FF)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_KEYCAM_WD
- * @brief Security CAM Content Register
- * @{
- *****************************************************************************/
-#define BIT_MASK_KEYCAM_WDATA                      ((u32)0xFFFFFFFF << 0)          /*!<R/W 0  Security CAM Write Content */
-#define BIT_KEYCAM_WDATA(x)                        ((u32)(((x) & 0xFFFFFFFF) << 0))
-#define BIT_GET_KEYCAM_WDATA(x)                    ((u32)(((x >> 0) & 0xFFFFFFFF)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_CAMREAD
- * @brief CAM Read Register
- * @{
- *****************************************************************************/
-#define BIT_MASK_CAMR_DATA                         ((u32)0xFFFFFFFF << 0)          /*!<R/W 0  Security CAM Read Content */
-#define BIT_CAMR_DATA(x)                           ((u32)(((x) & 0xFFFFFFFF) << 0))
-#define BIT_GET_CAMR_DATA(x)                       ((u32)(((x >> 0) & 0xFFFFFFFF)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_CAMDBG
- * @brief CAM Debug Register
- * @{
- *****************************************************************************/
-#define BIT_KEYCAM_DBGSEL                          ((u32)0x00000001 << 31)          /*!<R/W 0  Select TX/RX CAM Information. Set to 1 to retrieve latest Tx search result. Set to 0 to retrieve latest Rx search result. */
-#define BIT_SEC_KEYFOUND_V1                        ((u32)0x00000001 << 15)          /*!<R 0  Security Key Found in CAM 0: key not found 1: key found */
-#define BIT_MASK_CAMDBG_SEC_TYPE_V1                ((u32)0x00000007 << 12)          /*!<R 0  Found security key type */
-#define BIT_CAMDBG_SEC_TYPE_V1(x)                  ((u32)(((x) & 0x00000007) << 12))
-#define BIT_GET_CAMDBG_SEC_TYPE_V1(x)              ((u32)(((x >> 12) & 0x00000007)))
-#define BIT_EXT_SECTYPE                            ((u32)0x00000001 << 11)          /*!<R 0  Found security key ext_sectype */
-#define BIT_MASK_CAMDBG_MIC_KEY_IDX_V3             ((u32)0x0000001F << 5)          /*!<R 0  Mic KEY INDEX */
-#define BIT_CAMDBG_MIC_KEY_IDX_V3(x)               ((u32)(((x) & 0x0000001F) << 5))
-#define BIT_GET_CAMDBG_MIC_KEY_IDX_V3(x)           ((u32)(((x >> 5) & 0x0000001F)))
-#define BIT_MASK_CAMDBG_SEC_KEY_IDX_V2             ((u32)0x0000001F << 0)          /*!<R 0  Security KEY INDEX */
-#define BIT_CAMDBG_SEC_KEY_IDX_V2(x)               ((u32)(((x) & 0x0000001F) << 0))
-#define BIT_GET_CAMDBG_SEC_KEY_IDX_V2(x)           ((u32)(((x >> 0) & 0x0000001F)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_SECCFG
- * @brief Security Configuration Register
- * @{
- *****************************************************************************/
-#define BIT_MASK_RXFILTER_ACTION_1                 ((u32)0x000000FF << 24)          /*!<R/W 0  Configured by FW, Refer to 0x68E[10] to decide accepting this frame or not */
-#define BIT_RXFILTER_ACTION_1(x)                   ((u32)(((x) & 0x000000FF) << 24))
-#define BIT_GET_RXFILTER_ACTION_1(x)               ((u32)(((x >> 24) & 0x000000FF)))
-#define BIT_MASK_RXFILTER_CATEGORY_1               ((u32)0x000000FF << 16)          /*!<R/W 0  Configured by FW, Refer to 0x68E[10] to decide accepting this frame or not */
-#define BIT_RXFILTER_CATEGORY_1(x)                 ((u32)(((x) & 0x000000FF) << 16))
-#define BIT_GET_RXFILTER_CATEGORY_1(x)             ((u32)(((x >> 16) & 0x000000FF)))
-#define BIT_DIS_GCLK_WAPI                          ((u32)0x00000001 << 15)          /*!<R/W 0  Disable gated clock control for WAPI engine */
-#define BIT_DIS_GCLK_AES                           ((u32)0x00000001 << 14)          /*!<R/W 0  Disable gated clock control for AES engine. */
-#define BIT_DIS_GCLK_TKIP                          ((u32)0x00000001 << 13)          /*!<R/W 0  Disable gated clock control for WEP/TKIP engine. */
-#define BIT_AES_SEL_QC_1                           ((u32)0x00000001 << 12)          /*!<R/W 0  1: use QC[7] to compute mic 0: not use QC[7] to compute mic */
-#define BIT_AES_SEL_QC_0                           ((u32)0x00000001 << 11)          /*!<R/W 0  1:use QC[7] to compute ctr 0: not use QC[7] to compute ctr */
-#define BIT_WMAC_CKECK_BMC                         ((u32)0x00000001 << 9)          /*!<R/W 0  If this bit is set to 1, key search engine need to check if broadcast/multicast bit matched. */
-#define BIT_CHK_KEYID                              ((u32)0x00000001 << 8)          /*!<R/W 0  If this bit is set to 1, key search engine need to check if key ID matched. If this bit is set to 0, then key ID table must be filled with 2‟b00. */
-#define BIT_RXBCUSEDK                              ((u32)0x00000001 << 7)          /*!<R/W 0  Force RX Broadcast packets Use Default Key If this bit is set to 1, use default key for RX key search when received packet is broadcast and multicast. */
-#define BIT_TXBCUSEDK                              ((u32)0x00000001 << 6)          /*!<R/W 0  Force Tx Broadcast packets Use Default Key If this bit is set to 1, use default key for TX key search when transmitted packet is broadcast and multicast. */
-#define BIT_NOSKMC                                 ((u32)0x00000001 << 5)          /*!<R/W 0  No Key Search for Multicast Setting 1 to disable key search for multicast frames. Used in MBSSID AP mode. Software should manage security encryption and decryption. */
-#define BIT_SKBYA2                                 ((u32)0x00000001 << 4)          /*!<R/W 0  Search Key by A2 Setting 1 to search security CAM by address 2 for TX and search CAM by address 1 for RX. Setting 0 to search security CAM by address 1 for TX and search CAM by address 2 for RX. Used in MBSSID client mode. */
-#define BIT_RXDEC                                  ((u32)0x00000001 << 3)          /*!<R/W 1  Enable Rx Decryption Setting 1 to enable Rx hardware decryption. */
-#define BIT_TXENC                                  ((u32)0x00000001 << 2)          /*!<R/W 1  Enable Tx Encryption Setting to 1 to enable Tx hardware encryption. */
-#define BIT_RXUHUSEDK                              ((u32)0x00000001 << 1)          /*!<R/W 0  Force RX Unicast Use Default Key If this bit is set to 1, use default key for RX key search when pairwise key is not found. */
-#define BIT_TXUHUSEDK                              ((u32)0x00000001 << 0)          /*!<R/W 0  Force Tx Unicast Use Default Key If this bit is set to 1, use default key for TX key search when pairwise key is not found. */
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_RXFILTER_CATEGORY_ACTION
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_MASK_RXFILTER_ACTION_3                 ((u32)0x000000FF << 24)          /*!<R/W 0x0  Configured by FW, Refer to 0x68E[15] to decide accepting this frame or not */
-#define BIT_RXFILTER_ACTION_3(x)                   ((u32)(((x) & 0x000000FF) << 24))
-#define BIT_GET_RXFILTER_ACTION_3(x)               ((u32)(((x >> 24) & 0x000000FF)))
-#define BIT_MASK_RXFILTER_CATEGORY_3               ((u32)0x000000FF << 16)          /*!<R/W 0x0  Configured by FW, Refer to 0x68E[15] to decide accepting this frame or not */
-#define BIT_RXFILTER_CATEGORY_3(x)                 ((u32)(((x) & 0x000000FF) << 16))
-#define BIT_GET_RXFILTER_CATEGORY_3(x)             ((u32)(((x >> 16) & 0x000000FF)))
-#define BIT_MASK_RXFILTER_ACTION_2                 ((u32)0x000000FF << 8)          /*!<R/W 0x0  Configured by FW, Refer to 0x68E[11] to decide accepting this frame or not */
-#define BIT_RXFILTER_ACTION_2(x)                   ((u32)(((x) & 0x000000FF) << 8))
-#define BIT_GET_RXFILTER_ACTION_2(x)               ((u32)(((x >> 8) & 0x000000FF)))
-#define BIT_MASK_RXFILTER_CATEGORY_2               ((u32)0x000000FF << 0)          /*!<R/W 0x0  Configured by FW, Refer to 0x68E[11] to decide accepting this frame or not */
-#define BIT_RXFILTER_CATEGORY_2(x)                 ((u32)(((x) & 0x000000FF) << 0))
-#define BIT_GET_RXFILTER_CATEGORY_2(x)             ((u32)(((x >> 0) & 0x000000FF)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_RXFLTMAP3
- * @brief RX Filter Map Group 0
- * @{
- *****************************************************************************/
-#define BIT_CTRLFLT15EN_FW                         ((u32)0x00000001 << 31)          /*!<R/W 0  When set, frames with type=01 and subtype=1111 are received into FWFF. */
-#define BIT_CTRLFLT14EN_FW                         ((u32)0x00000001 << 30)          /*!<R/W 0  When set, frames with type=01 and subtype=1110 are received into FWFF. */
-#define BIT_CTRLFLT13EN_FW                         ((u32)0x00000001 << 29)          /*!<R/W 0  When set, frames with type=01 and subtype=1101 are received into FWFF. */
-#define BIT_CTRLFLT12EN_FW                         ((u32)0x00000001 << 28)          /*!<R/W 0  When set, frames with type=01 and subtype=1100 are received into FWFF. */
-#define BIT_CTRLFLT11EN_FW                         ((u32)0x00000001 << 27)          /*!<R/W 0  When set, frames with type=01 and subtype=1011 are received into FWFF. */
-#define BIT_CTRLFLT10EN_FW                         ((u32)0x00000001 << 26)          /*!<R/W 0  When set, frames with type=01 and subtype=1010 are received into FWFF. */
-#define BIT_CTRLFLT9EN_FW                          ((u32)0x00000001 << 25)          /*!<R/W 0  When set, frames with type=01 and subtype=1001 are received into FWFF. */
-#define BIT_CTRLFLT8EN_FW                          ((u32)0x00000001 << 24)          /*!<R/W 0  When set, frames with type=01 and subtype=1000 are received into FWFF. */
-#define BIT_CTRLFLT7EN_FW                          ((u32)0x00000001 << 23)          /*!<R/W 0  When set, frames with type=01 and subtype=0111 are received into FWFF. */
-#define BIT_CTRLFLT6EN_FW                          ((u32)0x00000001 << 22)          /*!<R/W 0  When set, frames with type=01 and subtype=0110 are received into FWFF. */
-#define BIT_CTRLFLT5EN_FW                          ((u32)0x00000001 << 21)          /*!<R/W 0  When set, frames with type=01 and subtype=0101 are received into FWFF. */
-#define BIT_CTRLFLT4EN_FW                          ((u32)0x00000001 << 20)          /*!<R/W 0  When set, frames with type=01 and subtype=0100 are received into FWFF. */
-#define BIT_CTRLFLT3EN_FW                          ((u32)0x00000001 << 19)          /*!<R/W 0  When set, frames with type=01 and subtype=0011 are received into FWFF. */
-#define BIT_CTRLFLT2EN_FW                          ((u32)0x00000001 << 18)          /*!<R/W 0  When set, frames with type=01 and subtype=0010 are received into FWFF. */
-#define BIT_CTRLFLT1EN_FW                          ((u32)0x00000001 << 17)          /*!<R/W 0  When set, frames with type=01 and subtype=0001 are received into FWFF. */
-#define BIT_CTRLFLT0EN_FW                          ((u32)0x00000001 << 16)          /*!<R/W 0  When set, frames with type=01 and subtype=0000 are received into FWFF. */
-#define BIT_MGTFLT15EN_FW                          ((u32)0x00000001 << 15)          /*!<R/W 0  When set, frames with type=00 and subtype=1111 are received into FWFF. */
-#define BIT_MGTFLT14EN_FW                          ((u32)0x00000001 << 14)          /*!<R/W 0  When set, all the frames with type=00 and subtype=1110 are received into FWFF. When set to 0, refer to 0x68E[15:12] for deciding which action noack frames will be accepted */
-#define BIT_MGTFLT13EN_FW                          ((u32)0x00000001 << 13)          /*!<R/W 0  When set, all the frames with type=00 and subtype=1101 are received into FWFF. When set to 0, refer to 0x68E[11:0] for deciding which action frames will be accepted */
-#define BIT_MGTFLT12EN_FW                          ((u32)0x00000001 << 12)          /*!<R/W 0  When set, frames with type=00 and subtype=1100 are received into FWFF. */
-#define BIT_MGTFLT11EN_FW                          ((u32)0x00000001 << 11)          /*!<R/W 0  When set, frames with type=00 and subtype=1011 are received into FWFF. */
-#define BIT_MGTFLT10EN_FW                          ((u32)0x00000001 << 10)          /*!<R/W 0  When set, frames with type=00 and subtype=1010 are received into FWFF. */
-#define BIT_MGTFLT9EN_FW                           ((u32)0x00000001 << 9)          /*!<R/W 0  When set, frames with type=00 and subtype=1001 are received into FWFF. */
-#define BIT_MGTFLT8EN_FW                           ((u32)0x00000001 << 8)          /*!<R/W 0  When set, frames with type=00 and subtype=1000 are received into FWFF. */
-#define BIT_MGTFLT7EN_FW                           ((u32)0x00000001 << 7)          /*!<R/W 0  When set, frames with type=00 and subtype=0111 are received into FWFF. */
-#define BIT_MGTFLT6EN_FW                           ((u32)0x00000001 << 6)          /*!<R/W 0  When set, frames with type=00 and subtype=0110 are received into FWFF. */
-#define BIT_MGTFLT5EN_FW                           ((u32)0x00000001 << 5)          /*!<R/W 0  When set, frames with type=00 and subtype=0101 are received into FWFF. */
-#define BIT_MGTFLT4EN_FW                           ((u32)0x00000001 << 4)          /*!<R/W 0  When set, frames with type=00 and subtype=0100 are received into FWFF. */
-#define BIT_MGTFLT3EN_FW                           ((u32)0x00000001 << 3)          /*!<R/W 0  When set, frames with type=00 and subtype=0011 are received into FWFF. */
-#define BIT_MGTFLT2EN_FW                           ((u32)0x00000001 << 2)          /*!<R/W 0  When set, frames with type=00 and subtype=0010 are received into FWFF. */
-#define BIT_MGTFLT1EN_FW                           ((u32)0x00000001 << 1)          /*!<R/W 0  When set, frames with type=00 and subtype=0001 are received into FWFF. */
-#define BIT_MGTFLT0EN_FW                           ((u32)0x00000001 << 0)          /*!<R/W 0  When set, frames with type=00 and subtype=0000 are received into FWFF. */
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_RXFLTMAP5
- * @brief RX Filter Map Group 1
- * @{
- *****************************************************************************/
-#define BIT_ACTIONFLT15EN_FW                       ((u32)0x00000001 << 31)          /*!<R/W 0  When set, Action noack frame with category = r_RXFILTER_CATEGORY_3(0x686[7:0]) and action = r_RXFILTER_ACTION_3(0x687[7:0]) will be received into FWFF */
-#define BIT_ACTIONFLT14EN_FW                       ((u32)0x00000001 << 30)          /*!<R/W 0  When set, VHT compressed beamforming frame will be received into FWFF. */
-#define BIT_ACTIONFLT13EN_FW                       ((u32)0x00000001 << 29)          /*!<R/W 0  When set, HT compressed beamforming frame will be received into FWFF. */
-#define BIT_ACTIONFLT12EN_FW                       ((u32)0x00000001 << 28)          /*!<R/W 0  When set, CSI frame will be received into FWFF. */
-#define BIT_ACTIONFLT11EN_FW                       ((u32)0x00000001 << 27)          /*!<R/W 0  When set, Action frame with category = r_RXFILTER_CATEGORY_2(0x684[7:0]) and action = r_RXFILTER_ACTION_2(0x685[7:0]) will be received into FWFF */
-#define BIT_ACTIONFLT10EN_FW                       ((u32)0x00000001 << 26)          /*!<R/W 0  When set, Action frame with category = r_RXFILTER_CATEGORY_1(0x682[7:0]) and action = r_RXFILTER_ACTION_1(0x683[7:0]) will be received into FWFF */
-#define BIT_ACTIONFLT9EN_FW                        ((u32)0x00000001 << 25)          /*!<R/W 0  When set, Operating mode notification frame will be received into FWFF. */
-#define BIT_ACTIONFLT8EN_FW                        ((u32)0x00000001 << 24)          /*!<R/W 0  When set, Group ID Management frame will be received into FWFF. */
-#define BIT_ACTIONFLT7EN_FW                        ((u32)0x00000001 << 23)          /*!<R/W 0  When set, Notify channel width frame will be received into FWFF. */
-#define BIT_ACTIONFLT6EN_FW                        ((u32)0x00000001 << 22)          /*!<R/W 0  When set, DELBA frame will be received into FWFF. */
-#define BIT_ACTIONFLT5EN_FW                        ((u32)0x00000001 << 21)          /*!<R/W 0  When set, ADDBA Response frame will be received into FWFF. */
-#define BIT_ACTIONFLT4EN_FW                        ((u32)0x00000001 << 20)          /*!<R/W 0  When set, ADDBA Request frame will be received into FWFF. */
-#define BIT_ACTIONFLT3EN_FW                        ((u32)0x00000001 << 19)          /*!<R/W 0  When set, DELTS frame will be received into FWFF. */
-#define BIT_ACTIONFLT2EN_FW                        ((u32)0x00000001 << 18)          /*!<R/W 0  When set, ADDTS Response frame will be received into FWFF. */
-#define BIT_ACTIONFLT1EN_FW                        ((u32)0x00000001 << 17)          /*!<R/W 0  When set, ADDTS Request frame will be received into FWFF. */
-#define BIT_ACTIONFLT0EN_FW                        ((u32)0x00000001 << 16)          /*!<R/W 0  When set, Channel Switch Announcement frame will be received into FWFF. */
-#define BIT_DATAFLT15EN_FW                         ((u32)0x00000001 << 15)          /*!<R/W 0  When set, frames with type=10 and subtype=1111 are received into FWFF. */
-#define BIT_DATAFLT14EN_FW                         ((u32)0x00000001 << 14)          /*!<R/W 0  When set, frames with type=10 and subtype=1110 are received into FWFF. */
-#define BIT_DATAFLT13EN_FW                         ((u32)0x00000001 << 13)          /*!<R/W 0  When set, frames with type=10 and subtype=1101 are received into FWFF. */
-#define BIT_DATAFLT12EN_FW                         ((u32)0x00000001 << 12)          /*!<R/W 0  When set, frames with type=10 and subtype=1100 are received into FWFF. */
-#define BIT_DATAFLT11EN_FW                         ((u32)0x00000001 << 11)          /*!<R/W 0  When set, frames with type=10 and subtype=1011 are received into FWFF. */
-#define BIT_DATAFLT10EN_FW                         ((u32)0x00000001 << 10)          /*!<R/W 0  When set, frames with type=10 and subtype=1010 are received into FWFF. */
-#define BIT_DATAFLT9EN_FW                          ((u32)0x00000001 << 9)          /*!<R/W 0  When set, frames with type=10 and subtype=1001 are received into FWFF. */
-#define BIT_DATAFLT8EN_FW                          ((u32)0x00000001 << 8)          /*!<R/W 0  When set, frames with type=10 and subtype=1000 are received into FWFF. */
-#define BIT_DATAFLT7EN_FW                          ((u32)0x00000001 << 7)          /*!<R/W 0  When set, frames with type=10 and subtype=0111 are received into FWFF. */
-#define BIT_DATAFLT6EN_FW                          ((u32)0x00000001 << 6)          /*!<R/W 0  When set, frames with type=10 and subtype=0110 are received into FWFF. */
-#define BIT_DATAFLT5EN_FW                          ((u32)0x00000001 << 5)          /*!<R/W 0  When set, frames with type=10 and subtype=0101 are received into FWFF. */
-#define BIT_DATAFLT4EN_FW                          ((u32)0x00000001 << 4)          /*!<R/W 0  When set, frames with type=10 and subtype=0100 are received into FWFF. */
-#define BIT_DATAFLT3EN_FW                          ((u32)0x00000001 << 3)          /*!<R/W 0  When set, frames with type=10 and subtype=0011 are received into FWFF. */
-#define BIT_DATAFLT2EN_FW                          ((u32)0x00000001 << 2)          /*!<R/W 0  When set, frames with type=10 and subtype=0010 are received into FWFF. */
-#define BIT_DATAFLT1EN_FW                          ((u32)0x00000001 << 1)          /*!<R/W 0  When set, frames with type=10 and subtype=0001 are received into FWFF. */
-#define BIT_DATAFLT0EN_FW                          ((u32)0x00000001 << 0)          /*!<R/W 0  When set, frames with type=10 and subtype=0000 are received into FWFF. */
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_WOW_NAN_CTRL
- * @brief Wake On WLAN and NAN Control Register
- * @{
- *****************************************************************************/
-#define BIT_WMMPS_UAPSD_TID7                       ((u32)0x00000001 << 31)          /*!<R/W 0  Disable interrupt 8051 when rx WMMPS UAPSD Qos data with TID7 */
-#define BIT_WMMPS_UAPSD_TID6                       ((u32)0x00000001 << 30)          /*!<R/W 0  Disable interrupt 8051 when rx WMMPS UAPSD Qos data with TID6 */
-#define BIT_WMMPS_UAPSD_TID5                       ((u32)0x00000001 << 29)          /*!<R/W 0  Disable interrupt 8051 when rx WMMPS UAPSD Qos data with TID5 */
-#define BIT_WMMPS_UAPSD_TID4                       ((u32)0x00000001 << 28)          /*!<R/W 0  Disable interrupt 8051 when rx WMMPS UAPSD Qos data with TID4 */
-#define BIT_WMMPS_UAPSD_TID3                       ((u32)0x00000001 << 27)          /*!<R/W 0  Disable interrupt 8051 when rx WMMPS UAPSD Qos data with TID3 */
-#define BIT_WMMPS_UAPSD_TID2                       ((u32)0x00000001 << 26)          /*!<R/W 0  Disable interrupt 8051 when rx WMMPS UAPSD Qos data with TID2 */
-#define BIT_WMMPS_UAPSD_TID1                       ((u32)0x00000001 << 25)          /*!<R/W 0  Disable interrupt 8051 when rx WMMPS UAPSD Qos data with TID1 */
-#define BIT_WMMPS_UAPSD_TID0                       ((u32)0x00000001 << 24)          /*!<R/W 0  Disable interrupt 8051 when rx WMMPS UAPSD Qos data with TID0 */
-#define BIT_MASK_PORTSEL_PS_RX_INFO                ((u32)0x00000007 << 21)          /*!<R/W 0  The selector for the source of PS RX information (0x692[4:0]). 0 for port 0, 1 for clint0, 2 for clint1, 3 for clint2, 4 for clint3. */
-#define BIT_PORTSEL_PS_RX_INFO(x)                  ((u32)(((x) & 0x00000007) << 21))
-#define BIT_GET_PORTSEL_PS_RX_INFO(x)              ((u32)(((x >> 21) & 0x00000007)))
-#define BIT_RXCTRLIN0                              ((u32)0x00000001 << 20)          /*!<R 0  It is set to 1 if NIC received control frame with correct DA. */
-#define BIT_RXMGTIN0                               ((u32)0x00000001 << 19)          /*!<R 0  It is set to 1 if NIC received management frame with correct BSSID and DA (including unicast and BMC). */
-#define BIT_RXDATAIN2                              ((u32)0x00000001 << 18)          /*!<R 0  It is set to 1 if NIC received data frame with correct BSSID and DA (including unicast and BMC). */
-#define BIT_RXDATAIN1                              ((u32)0x00000001 << 17)          /*!<R 0  It is set to 1 if NIC received data frame with correct BSSID and DA (including unicast and BMC). */
-#define BIT_RXDATAIN0                              ((u32)0x00000001 << 16)          /*!<R 0  It is set to 1 if NIC received data frame with correct BSSID and DA (including unicast and BMC). */
-#define BIT_NAN_RX_CHKTA                           ((u32)0x00000001 << 10)          /*!<R/W 0  Enable bit for check TSF filter When set to 1, the TSF address filter will enable. When set to 0, the TSF address filter will disable. */
-#define BIT_NAN_RX_CHKBSSID                        ((u32)0x00000001 << 9)          /*!<R/W 0  Check BSSID_BCN for TSF When set to 1, MAC will check the BSSID (A3) of RX beacon or Probe to determine if this packet will sync TSF or not */
-#define BIT_NAN_RX_FILTER_EN                       ((u32)0x00000001 << 8)          /*!<R/W 0  When set to 1, the TSF address filter will enable. When set to 0, the TSF address filter will disable. */
-#define BIT_MASK_PSF_BSSIDSEL_H                    ((u32)0x00000003 << 6)          /*!<R/W 0  Bit 1,2 of Select to check the MACID of which port for the WMAC PSF NSARP function. 0: to check the MACID of port0; 1: to check the MACID of port1. 2: to check the MACID of port2. 3: to check the MACID of port3. 4: to check the MACID of port4. */
-#define BIT_PSF_BSSIDSEL_H(x)                      ((u32)(((x) & 0x00000003) << 6))
-#define BIT_GET_PSF_BSSIDSEL_H(x)                  ((u32)(((x >> 6) & 0x00000003)))
-#define BIT_WOWHCI                                 ((u32)0x00000001 << 5)          /*!<R/W 0  This bit is set to allow wake host as wake on wlan event occurring */
-#define BIT_PSF_BSSIDSEL_L                         ((u32)0x00000001 << 4)          /*!<R/W 0  Bit 0 of Select to check the MACID of which port for the WMAC PSF NSARP function. 0: to check the MACID of port0; 1: to check the MACID of port1. 2: to check the MACID of port2. 3: to check the MACID of port3. 4: to check the MACID of port4. */
-#define BIT_UWF                                    ((u32)0x00000001 << 3)          /*!<R/W 0  Unicast Packet. 1: Enable to check packet‟s DA match MAC address or not. 0: Disable. (default value) */
-#define BIT_MAGIC                                  ((u32)0x00000001 << 2)          /*!<R/W 0  Magic Packet. This bit is valid when the PMEn bit of the PMR register is set. The RTL8192 will assert the PMEB signal to wakeup the operating system when a Magic Packet is received. Once the RTL8192 has been enabled for Magic Packet wakeup, it scans incoming packets addressed to the node for a data sequence. The correct sequence indicates to the controller that this is a Magic Packet frame. A Magic Packet frame must also meet the basic requirements: Frame Control + Duration/ID + Destination address + Address 2 + Address 3 + Sequence Control + data + CRC. The destination address may be the node ID of the receiving station or a multicast address, including the broadcast address. The specific sequence consists of 16 duplications of 6 byte ID registers, with no breaks or interrupts. This sequence can be located anywhere within the packet, but must be preceded by a synchronization stream, 6 bytes of FFh. The device will also accept a multicast address, as long as the 16 duplications of the IEEE address match the address of the ID registers. If the Node ID is 11h 22h 33h 44h 55h 66h, then the magic frame‟s format is as follows: Frame Control + Duration/ID + Destination address + Address 2 + Address 3 + Sequence Control + MISC + FF FF FF FF FF FF + MISC + 11 22 33 44 55 66 + 11 22 33 44 55 66 + 11 22 33 44 55 66 + 11 22 33 44 55 66 + 11 22 33 44 55 66 + 11 22 33 44 55 66 + 11 22 33 44 55 66 + 11 22 33 44 55 66 + 11 22 33 44 55 66 + 11 22 33 44 55 66 + 11 22 33 44 55 66 + 11 22 33 44 55 66 + 11 22 33 44 55 66 + 11 22 33 44 55 66 + 11 22 33 44 55 66 + 11 22 33 44 55 66 + MISC + CRC. */
-#define BIT_WFMSK                                  ((u32)0x00000001 << 1)          /*!<R/W 0  WoW function on or off. */
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_LPNAV_CTRL
- * @brief Low Power NAV Control Register
- * @{
- *****************************************************************************/
-#define BIT_LPNAV_EN                               ((u32)0x00000001 << 31)          /*!<R/W 0  Low Power NAV Mode Enable. When this bit is set, enable MAC low power NAV mode */
-#define BIT_MASK_LPNAV_EARLY                       ((u32)0x00007FFF << 16)          /*!<R/W 0x0A  When in LPNAV mode, MAC will recall BB and RF into RX idle mode. The unit is us. */
-#define BIT_LPNAV_EARLY(x)                         ((u32)(((x) & 0x00007FFF) << 16))
-#define BIT_GET_LPNAV_EARLY(x)                     ((u32)(((x >> 16) & 0x00007FFF)))
-#define BIT_MASK_LPNAV_THR                         ((u32)0x0000FFFF << 0)          /*!<R/W 0x200  When protected NAV in the received frame is greater than this threshold value, then MAC enters into LPNAV mode. The time unit is 16us. */
-#define BIT_LPNAV_THR(x)                           ((u32)(((x) & 0x0000FFFF) << 0))
-#define BIT_GET_LPNAV_THR(x)                       ((u32)(((x >> 0) & 0x0000FFFF)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_WKFMCAM_CMD
- * @brief Wakeup Frame CAM Number Register
- * @{
- *****************************************************************************/
-#define BIT_WKFMCAM_WE                             ((u32)0x00000001 << 16)          /*!<R/W 0  CAM Write Enable */
-#define BIT_MASK_WKFMCAM_AD                        ((u32)0x000000FF << 8)          /*!<R/W 0  Entry address */
-#define BIT_WKFMCAM_AD(x)                          ((u32)(((x) & 0x000000FF) << 8))
-#define BIT_GET_WKFMCAM_AD(x)                      ((u32)(((x >> 8) & 0x000000FF)))
-#define BIT_MASK_CAM_NUM                           ((u32)0x000000FF << 0)          /*!<R/W 0  CAM Entry Number */
-#define BIT_CAM_NUM(x)                             ((u32)(((x) & 0x000000FF) << 0))
-#define BIT_GET_CAM_NUM(x)                         ((u32)(((x >> 0) & 0x000000FF)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_WKFMCAM_WD
- * @brief Wakeup Frame CAM CONTENT Register
- * @{
- *****************************************************************************/
-#define BIT_MASK_WKFMCAM_WD                        ((u32)0xFFFFFFFF << 0)          /*!<R/W   CAM Write Data */
-#define BIT_WKFMCAM_WD(x)                          ((u32)(((x) & 0xFFFFFFFF) << 0))
-#define BIT_GET_WKFMCAM_WD(x)                      ((u32)(((x >> 0) & 0xFFFFFFFF)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_RXFLTMAP0
- * @brief RX Filter Map Group 0
- * @{
- *****************************************************************************/
-#define BIT_CTRLFLT15EN                            ((u32)0x00000001 << 31)          /*!<R/W 0  When set, frames with type=01 and subtype=1111 are received into RXFF */
-#define BIT_CTRLFLT14EN                            ((u32)0x00000001 << 30)          /*!<R/W 0  When set, frames with type=01 and subtype=1110 are received into RXFF */
-#define BIT_CTRLFLT13EN                            ((u32)0x00000001 << 29)          /*!<R/W 0  When set, frames with type=01 and subtype=1101 are received into RXFF. */
-#define BIT_CTRLFLT12EN                            ((u32)0x00000001 << 28)          /*!<R/W 0  When set, frames with type=01 and subtype=1100 are received into RXFF. */
-#define BIT_CTRLFLT11EN                            ((u32)0x00000001 << 27)          /*!<R/W 0  When set, frames with type=01 and subtype=1011 are received into RXFF */
-#define BIT_CTRLFLT10EN                            ((u32)0x00000001 << 26)          /*!<R/W 0  When set, frames with type=01 and subtype=1010 are received into RXFF. */
-#define BIT_CTRLFLT9EN                             ((u32)0x00000001 << 25)          /*!<R/W 0  When set, frames with type=01 and subtype=1001 are received into RXFF */
-#define BIT_CTRLFLT8EN                             ((u32)0x00000001 << 24)          /*!<R/W 0  When set, frames with type=01 and subtype=1000 are received into RXFF */
-#define BIT_CTRLFLT7EN                             ((u32)0x00000001 << 23)          /*!<R/W 0  When set, frames with type=01 and subtype=0111 are received into RXFF */
-#define BIT_CTRLFLT6EN                             ((u32)0x00000001 << 22)          /*!<R/W 0  When set, frames with type=01 and subtype=0110 are received into RXFF. */
-#define BIT_CTRLFLT5EN                             ((u32)0x00000001 << 21)          /*!<R/W 0  When set, frames with type=01 and subtype=0101 are received into RXFF. */
-#define BIT_CTRLFLT4EN                             ((u32)0x00000001 << 20)          /*!<R/W 0  When set, frames with type=01 and subtype=0100 are received into RXFF. */
-#define BIT_CTRLFLT3EN                             ((u32)0x00000001 << 19)          /*!<R/W 0  When set, frames with type=01 and subtype=0011 are received into RXFF. */
-#define BIT_CTRLFLT2EN                             ((u32)0x00000001 << 18)          /*!<R/W 0  When set, frames with type=01 and subtype=0010 are received into RXFF. */
-#define BIT_CTRLFLT1EN                             ((u32)0x00000001 << 17)          /*!<R/W 0  When set, frames with type=01 and subtype=0001 are received into RXFF. */
-#define BIT_CTRLFLT0EN                             ((u32)0x00000001 << 16)          /*!<R/W 0  When set, frames with type=01 and subtype=0000 are received into RXFF. */
-#define BIT_MGTFLT15EN                             ((u32)0x00000001 << 15)          /*!<R/W 0  When set, frames with type=00 and subtype=1111 are received into RXFF. */
-#define BIT_MGTFLT14EN                             ((u32)0x00000001 << 14)          /*!<R/W 0  When set, frames with type=00 and subtype=1110 are received into RXFF. */
-#define BIT_MGTFLT13EN                             ((u32)0x00000001 << 13)          /*!<R/W 0  When set, frames with type=00 and subtype=1101 are received into RXFF. */
-#define BIT_MGTFLT12EN                             ((u32)0x00000001 << 12)          /*!<R/W 0  When set, frames with type=00 and subtype=1100 are received into RXFF. */
-#define BIT_MGTFLT11EN                             ((u32)0x00000001 << 11)          /*!<R/W 0  When set, frames with type=00 and subtype=1011 are received into RXFF. */
-#define BIT_MGTFLT10EN                             ((u32)0x00000001 << 10)          /*!<R/W 0  When set, frames with type=00 and subtype=1010 are received into RXFF */
-#define BIT_MGTFLT9EN                              ((u32)0x00000001 << 9)          /*!<R/W 0  When set, frames with type=00 and subtype=1001 are received into RXFF. */
-#define BIT_MGTFLT8EN                              ((u32)0x00000001 << 8)          /*!<R/W 0  When set, frames with type=00 and subtype=1000 are received into RXFF */
-#define BIT_MGTFLT7EN                              ((u32)0x00000001 << 7)          /*!<R/W 0  When set, frames with type=00 and subtype=0111 are received into RXFF. */
-#define BIT_MGTFLT6EN                              ((u32)0x00000001 << 6)          /*!<R/W 0  When set, frames with type=00 and subtype=0110 are received into RXFF. */
-#define BIT_MGTFLT5EN                              ((u32)0x00000001 << 5)          /*!<R/W 0  When set, frames with type=00 and subtype=0101 are received into RXFF */
-#define BIT_MGTFLT4EN                              ((u32)0x00000001 << 4)          /*!<R/W 0  When set, frames with type=00 and subtype=0100 are received into RXFF. */
-#define BIT_MGTFLT3EN                              ((u32)0x00000001 << 3)          /*!<R/W 0  When set, frames with type=00 and subtype=0011 are received into RXFF */
-#define BIT_MGTFLT2EN                              ((u32)0x00000001 << 2)          /*!<R/W 0  When set, frames with type=00 and subtype=0010 are received into RXFF */
-#define BIT_MGTFLT1EN                              ((u32)0x00000001 << 1)          /*!<R/W 0  When set, frames with type=00 and subtype=0001 are received into RXFF */
-#define BIT_MGTFLT0EN                              ((u32)0x00000001 << 0)          /*!<R/W 0  When set, frames with type=00 and subtype=0000 are received into RXFF */
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_RXFLTMAP
- * @brief RX Filter Map Group 1
- * @{
- *****************************************************************************/
-#define BIT_DATAFLT15EN                            ((u32)0x00000001 << 15)          /*!<R/W 0  When set, frames with type=10 and subtype=1111 are received into RXFF */
-#define BIT_DATAFLT14EN                            ((u32)0x00000001 << 14)          /*!<R/W 0  When set, frames with type=10 and subtype=1110 are received into RXFF */
-#define BIT_DATAFLT13EN                            ((u32)0x00000001 << 13)          /*!<R/W 0  When set, frames with type=10 and subtype=1101 are received into RXFF. */
-#define BIT_DATAFLT12EN                            ((u32)0x00000001 << 12)          /*!<R/W 0  When set, frames with type=10 and subtype=1100 are received into RXFF. */
-#define BIT_DATAFLT11EN                            ((u32)0x00000001 << 11)          /*!<R/W 0  When set, frames with type=10 and subtype=1011 are received into RXFF. */
-#define BIT_DATAFLT10EN                            ((u32)0x00000001 << 10)          /*!<R/W 0  When set, frames with type=10 and subtype=1010 are received into RXFF. */
-#define BIT_DATAFLT9EN                             ((u32)0x00000001 << 9)          /*!<R/W 0  When set, frames with type=10 and subtype=1001 are received into RXFF */
-#define BIT_DATAFLT8EN                             ((u32)0x00000001 << 8)          /*!<R/W 0  When set, frames with type=10 and subtype=1000 are received into RXFF */
-#define BIT_DATAFLT7EN                             ((u32)0x00000001 << 7)          /*!<R/W 0  When set, frames with type=10 and subtype=0111 are received into RXFF. */
-#define BIT_DATAFLT6EN                             ((u32)0x00000001 << 6)          /*!<R/W 0  When set, frames with type=10 and subtype=0110 are received into RXFF */
-#define BIT_DATAFLT5EN                             ((u32)0x00000001 << 5)          /*!<R/W 0  When set, frames with type=10 and subtype=0101 are received into RXFF */
-#define BIT_DATAFLT4EN                             ((u32)0x00000001 << 4)          /*!<R/W 0  When set, frames with type=10 and subtype=0100 are received into RXFF. */
-#define BIT_DATAFLT3EN                             ((u32)0x00000001 << 3)          /*!<R/W 0  When set, frames with type=10 and subtype=0011 are received into RXFF */
-#define BIT_DATAFLT2EN                             ((u32)0x00000001 << 2)          /*!<R/W 0  When set, frames with type=10 and subtype=0010 are received into RXFF. */
-#define BIT_DATAFLT1EN                             ((u32)0x00000001 << 1)          /*!<R/W 0  When set, frames with type=10 and subtype=0001 are received into RXFF. */
-#define BIT_DATAFLT0EN                             ((u32)0x00000001 << 0)          /*!<R/W 0  When set, frames with type=10 and subtype=0000 are received into RXFF. */
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_BCN_PSR_RPT0
- * @brief Beacon Parser Report Register
- * @{
- *****************************************************************************/
-#define BIT_MASK_DTIM_CNT0                         ((u32)0x000000FF << 24)          /*!<R 0  The DTIM count field of the TIM element of Rx beacon */
-#define BIT_DTIM_CNT0(x)                           ((u32)(((x) & 0x000000FF) << 24))
-#define BIT_GET_DTIM_CNT0(x)                       ((u32)(((x >> 24) & 0x000000FF)))
-#define BIT_MASK_DTIM_PERIOD0                      ((u32)0x000000FF << 16)          /*!<R 0  The DTIM period field of the TIM element of Rx beacon */
-#define BIT_DTIM_PERIOD0(x)                        ((u32)(((x) & 0x000000FF) << 16))
-#define BIT_GET_DTIM_PERIOD0(x)                    ((u32)(((x >> 16) & 0x000000FF)))
-#define BIT_HAS_MY_BC0                             ((u32)0x00000001 << 15)          /*!<R 0  Indicate BC/MC packets are buffered in transmitted BSSID or AP */
-#define BIT_HAS_MY_BSSID0                          ((u32)0x00000001 << 14)          /*!<R 0  Indicate BC/MC packets are buffered in nontransmitted BSSID, SW need check crespponding dtim count field in multiple bssid index field */
-#define BIT_HAS_MYAID0                             ((u32)0x00000001 << 13)          /*!<R 0  Indicate has my unicast packet */
-#define BIT_RPT_VALID0                             ((u32)0x00000001 << 12)          /*!<R 0  when set to 1, indicate the tim report is valid */
-#define BIT_MASK_PS_AID_0                          ((u32)0x000007FF << 0)          /*!<R/W 0  AID0 for MACID */
-#define BIT_PS_AID_0(x)                            ((u32)(((x) & 0x000007FF) << 0))
-#define BIT_GET_PS_AID_0(x)                        ((u32)(((x >> 0) & 0x000007FF)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_FLC_CTRL
- * @brief FW LPS Condition PKT Counter
- * @{
- *****************************************************************************/
-#define BIT_FLC_RPCT_V1                            ((u32)0x00000001 << 31)          /*!<R/W 0  When write “1” to this bit, FLC_TRPC will be enabled. */
-#define BIT_FLC_MODSL                              ((u32)0x00000001 << 30)          /*!<R/W 0  1:Timer Mode 0:Counter Mode */
-#define BIT_MASK_TORRD                             ((u32)0x0000003F << 24)          /*!<R/W 0  It specifies the time-out duration. (unit: 32 ms) */
-#define BIT_TORRD(x)                               ((u32)(((x) & 0x0000003F) << 24))
-#define BIT_GET_TORRD(x)                           ((u32)(((x >> 24) & 0x0000003F)))
-#define BIT_FLC_CMFEN                              ((u32)0x00000001 << 18)          /*!<R/W 0  Count Management Frame (1: Enable, 0:Disable) */
-#define BIT_FLC_CCFEN                              ((u32)0x00000001 << 17)          /*!<R/W 0  Count Control Frame (1: Enable, 0:Disable) */
-#define BIT_FLC_CDFEN                              ((u32)0x00000001 << 16)          /*!<R/W 0  Count Data Frame (1: Enable, 0:Disable) */
-#define BIT_MASK_FLC_PKTTH                         ((u32)0x000000FF << 8)          /*!<R/W 0  Rx PKT number threshold */
-#define BIT_FLC_PKTTH(x)                           ((u32)(((x) & 0x000000FF) << 8))
-#define BIT_GET_FLC_PKTTH(x)                       ((u32)(((x >> 8) & 0x000000FF)))
-#define BIT_MASK_FLC_RPC                           ((u32)0x000000FF << 0)          /*!<R 0  Number of Rx PKT in the interval which is specified by FLC_TRPC. The Rx PKT type is specified by 0x6AE[2:0] */
-#define BIT_FLC_RPC(x)                             ((u32)(((x) & 0x000000FF) << 0))
-#define BIT_GET_FLC_RPC(x)                         ((u32)(((x >> 0) & 0x000000FF)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_RXPKTMON_CTRL
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_MASK_RXBKQPKT_SEQ                      ((u32)0x0000000F << 20)          /*!<R 0  The expected Rx BKQ packet index */
-#define BIT_RXBKQPKT_SEQ(x)                        ((u32)(((x) & 0x0000000F) << 20))
-#define BIT_GET_RXBKQPKT_SEQ(x)                    ((u32)(((x >> 20) & 0x0000000F)))
-#define BIT_MASK_RXBEQPKT_SEQ                      ((u32)0x0000000F << 16)          /*!<R 0  The expected Rx BEQ packet index */
-#define BIT_RXBEQPKT_SEQ(x)                        ((u32)(((x) & 0x0000000F) << 16))
-#define BIT_GET_RXBEQPKT_SEQ(x)                    ((u32)(((x >> 16) & 0x0000000F)))
-#define BIT_MASK_RXVIQPKT_SEQ                      ((u32)0x0000000F << 12)          /*!<R 0  The expected Rx VIQ packet index */
-#define BIT_RXVIQPKT_SEQ(x)                        ((u32)(((x) & 0x0000000F) << 12))
-#define BIT_GET_RXVIQPKT_SEQ(x)                    ((u32)(((x >> 12) & 0x0000000F)))
-#define BIT_MASK_RXVOQPKT_SEQ                      ((u32)0x0000000F << 8)          /*!<R 0  The expected Rx VOQ packet index */
-#define BIT_RXVOQPKT_SEQ(x)                        ((u32)(((x) & 0x0000000F) << 8))
-#define BIT_GET_RXVOQPKT_SEQ(x)                    ((u32)(((x >> 8) & 0x0000000F)))
-#define BIT_RXBKQPKT_ERR                           ((u32)0x00000001 << 7)          /*!<R 0  Indicate monitor find the Rx BKQ packet without incremental index */
-#define BIT_RXBEQPKT_ERR                           ((u32)0x00000001 << 6)          /*!<R 0  Indicate monitor find the Rx BEQ packet without incremental index */
-#define BIT_RXVIQPKT_ERR                           ((u32)0x00000001 << 5)          /*!<R 0  Indicate monitor find the Rx VIQ packet without incremental index */
-#define BIT_RXVOQPKT_ERR                           ((u32)0x00000001 << 4)          /*!<R 0  Indicate monitor find the Rx VOQ packet without incremental index */
-#define BIT_RXDMA_MON_EN                           ((u32)0x00000001 << 2)          /*!<R/W 0  Enable packet loss monitor function for Rx DMA. If this bit is set to 1, then MACRX append the incremental index to fragment field of sequence number field of rxmpdu restored to rxpkbuffer successfully */
-#define BIT_RXPKT_MON_EN                           ((u32)0x00000001 << 0)          /*!<R/W 0  Enable packet loss monitor function for Rx packets. If this bit is set to 1, then MACRX uses fragment field of sequence number field of rxmpdu as the mpdu index and check if the index is incremental. */
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_STATE_MON
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_MASK_STATE_SEL                         ((u32)0x0000001F << 24)          /*!<R/W 0  WMAC read and write FSM selection： 000,001：read mactx status 010,011：read mactx status 100：read response status 00xxx: write [6：0]to mactx fsm when [7] valid 01xxx：write [6：0]to macrx fsm when [7] valid 100xx: write [6：0]to response fsm when [7] valid */
-#define BIT_STATE_SEL(x)                           ((u32)(((x) & 0x0000001F) << 24))
-#define BIT_GET_STATE_SEL(x)                       ((u32)(((x >> 24) & 0x0000001F)))
-#define BIT_MASK_CUR_STATE1                        ((u32)0x000000FF << 8)          /*!<R 0  when BIT_WRITE_FSM_EN is valid,is rsvd. When BIT_WRITE_FSM_EN is not valid, means read status */
-#define BIT_CUR_STATE1(x)                          ((u32)(((x) & 0x000000FF) << 8))
-#define BIT_GET_CUR_STATE1(x)                      ((u32)(((x >> 8) & 0x000000FF)))
-#define BIT_WRITE_FSM_EN                           ((u32)0x00000001 << 7)          /*!<R 0  when set 1, generate write pulse, otherwise means read status */
-#define BIT_MASK_CUR_STATE0                        ((u32)0x0000007F << 0)          /*!<R/W 0  when BIT_WRITE_FSM_EN is valid,Indicate the FSM current state to write. When BIT_WRITE_FSM_EN is not valid, means read status */
-#define BIT_CUR_STATE0(x)                          ((u32)(((x) & 0x0000007F) << 0))
-#define BIT_GET_CUR_STATE0(x)                      ((u32)(((x >> 0) & 0x0000007F)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_ERROR_EVT_CTL
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_CSIRPT_LEN_BB_MORE_THAN_MAC            ((u32)0x00000001 << 23)          /*!<R 0  Indicate MAC Rx csi rxd number overflow */
-#define BIT_CSI_CHKSUM_ERROR                       ((u32)0x00000001 << 22)          /*!<R 0  Indicate MAC Rx csi rpt checksum error */
-#define BIT_MACRX_ERR_4                            ((u32)0x00000001 << 20)          /*!<R 0  Indicate last MPDU length of AMPDU or PPDU length is error. */
-#define BIT_MACRX_ERR_3                            ((u32)0x00000001 << 19)          /*!<R 0  Indicate rxfifo or mac phy interface fifo overflow */
-#define BIT_MACRX_ERR_2                            ((u32)0x00000001 << 18)          /*!<R 0  Indicate MAC Rx occurs internal halt event */
-#define BIT_MACRX_ERR_1                            ((u32)0x00000001 << 17)          /*!<R 0  Indicate Rx packet length >= 12K bytes */
-#define BIT_MACRX_ERR_0                            ((u32)0x00000001 << 16)          /*!<R 0  Indicate MAC Rx occurs halt event */
-#define BIT_PRETX_ERRHDL_EN                        ((u32)0x00000001 << 15)          /*!<R/W 0  Pre tx error block enable signal */
-#define BIT_MACTX_ERR_3                            ((u32)0x00000001 << 3)          /*!<R 0  Indicate PHY fetch plcp before it is ready */
-#define BIT_MACTX_ERR_2                            ((u32)0x00000001 << 2)          /*!<R 0  phy_txen is set ,but wait phy_phytxon time out */
-#define BIT_MACTX_ERR_1                            ((u32)0x00000001 << 1)          /*!<R 0  Indicate TXD FIFO underflow,ppdu fetch zld */
-#define BIT_MACTX_ERR_0                            ((u32)0x00000001 << 0)          /*!<R 0  Indicate TXD FIFO underflow,mpdu fetch zld */
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_SEARCH_MACID
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_EN_TXRPTBUF_CLK                        ((u32)0x00000001 << 31)          /*!<R/W 0  when set to 1,keep txrptbuf sram always have clock */
-#define BIT_MASK_INFO_INDEX_OFFSET                 ((u32)0x00001FFF << 16)          /*!<R/W 0x150  Pre-macid information index address offset. */
-#define BIT_INFO_INDEX_OFFSET(x)                   ((u32)(((x) & 0x00001FFF) << 16))
-#define BIT_GET_INFO_INDEX_OFFSET(x)               ((u32)(((x >> 16) & 0x00001FFF)))
-#define BIT_WMAC_SRCH_FIFOFULL                     ((u32)0x00000001 << 15)          /*!<R/W 0  when set to 1, when fifofull, stop macid search; */
-#define BIT_DIS_INFOSRCH                           ((u32)0x00000001 << 14)          /*!<R/W 0  when set to 1,disable to search information */
-#define BIT_DISABLE_B0                             ((u32)0x00000001 << 13)          /*!<R/W 0  when set to 1,disable to check a2[0] */
-#define BIT_MASK_INFO_ADDR_OFFSET                  ((u32)0x00001FFF << 0)          /*!<R/W 0  per-macid information address offset (Unit:8bytes). */
-#define BIT_INFO_ADDR_OFFSET(x)                    ((u32)(((x) & 0x00001FFF) << 0))
-#define BIT_GET_INFO_ADDR_OFFSET(x)                ((u32)(((x >> 0) & 0x00001FFF)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_BT_COEX_TABLE_V1
- * @brief BT Coexistence Control register
- * @{
- *****************************************************************************/
-#define BIT_MASK_COEX_TABLE_1                      ((u32)0xFFFFFFFF << 0)          /*!<R/W 0  coexistence table, used at dual antenna & out of band */
-#define BIT_COEX_TABLE_1(x)                        ((u32)(((x) & 0xFFFFFFFF) << 0))
-#define BIT_GET_COEX_TABLE_1(x)                    ((u32)(((x >> 0) & 0xFFFFFFFF)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_BT_COEX_TABLE2_V1
- * @brief BTCoexistence Control register
- * @{
- *****************************************************************************/
-#define BIT_MASK_COEX_TABLE_2                      ((u32)0xFFFFFFFF << 0)          /*!<R/W 0  coexistence table, used at dual antenna & in band or single antenna */
-#define BIT_COEX_TABLE_2(x)                        ((u32)(((x) & 0xFFFFFFFF) << 0))
-#define BIT_GET_COEX_TABLE_2(x)                    ((u32)(((x >> 0) & 0xFFFFFFFF)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_BT_COEX_BREAK_TABLE
- * @brief BT Coexistence Control register
- * @{
- *****************************************************************************/
-#define BIT_MASK_BREAK_TABLE_2                     ((u32)0x0000FFFF << 16)          /*!<R/W 0  Table used to break BT activity, when new WLAN request is coming and BT is on transmitting or receiving */
-#define BIT_BREAK_TABLE_2(x)                       ((u32)(((x) & 0x0000FFFF) << 16))
-#define BIT_GET_BREAK_TABLE_2(x)                   ((u32)(((x >> 16) & 0x0000FFFF)))
-#define BIT_MASK_BREAK_TABLE_1                     ((u32)0x0000FFFF << 0)          /*!<R/W 0  Table used to break WLAN activity, when new BT request is coming and WLAN is on transmitting or receiving */
-#define BIT_BREAK_TABLE_1(x)                       ((u32)(((x) & 0x0000FFFF) << 0))
-#define BIT_GET_BREAK_TABLE_1(x)                   ((u32)(((x >> 0) & 0x0000FFFF)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_BT_COEX_TABLE_H_V1
- * @brief BT Coexistence Control register
- * @{
- *****************************************************************************/
-#define BIT_PRI_MASK_RX_RESP_V1                    ((u32)0x00000001 << 30)          /*!<R/W 0  Priority Mask for RX Response Packet */
-#define BIT_PRI_MASK_RXOFDM_V1                     ((u32)0x00000001 << 29)          /*!<R/W 0  Priority Mask for RX OFDM */
-#define BIT_PRI_MASK_RXCCK_V1                      ((u32)0x00000001 << 28)          /*!<R/W 0  Priority Mask for RX CCK */
-#define BIT_MASK_PRI_MASK_TXAC                     ((u32)0x0000007F << 21)          /*!<R/W 0  Priority Mask for Tx Queue */
-#define BIT_PRI_MASK_TXAC(x)                       ((u32)(((x) & 0x0000007F) << 21))
-#define BIT_GET_PRI_MASK_TXAC(x)                   ((u32)(((x >> 21) & 0x0000007F)))
-#define BIT_MASK_PRI_MASK_NAV                      ((u32)0x000000FF << 13)          /*!<R/W 0  Priority Mask for Tx NAV */
-#define BIT_PRI_MASK_NAV(x)                        ((u32)(((x) & 0x000000FF) << 13))
-#define BIT_GET_PRI_MASK_NAV(x)                    ((u32)(((x >> 13) & 0x000000FF)))
-#define BIT_PRI_MASK_CCK_V1                        ((u32)0x00000001 << 12)          /*!<R/W 0  Priority Mask for Tx CCK */
-#define BIT_PRI_MASK_OFDM_V1                       ((u32)0x00000001 << 11)          /*!<R/W 0  Priority Mask for Tx OFDM */
-#define BIT_PRI_MASK_RTY_V1                        ((u32)0x00000001 << 10)          /*!<R/W 0  Priority Mask for Tx Retry Packet */
-#define BIT_MASK_PRI_MASK_NUM                      ((u32)0x0000000F << 6)          /*!<R/W 0  Priority Mask for Tx packet number */
-#define BIT_PRI_MASK_NUM(x)                        ((u32)(((x) & 0x0000000F) << 6))
-#define BIT_GET_PRI_MASK_NUM(x)                    ((u32)(((x >> 6) & 0x0000000F)))
-#define BIT_MASK_PRI_MASK_TYPE                     ((u32)0x0000000F << 2)          /*!<R/W 0  Priority Mask for Tx packet type [98]: Rx response [99]: Tx response [100]: beacon */
-#define BIT_PRI_MASK_TYPE(x)                       ((u32)(((x) & 0x0000000F) << 2))
-#define BIT_GET_PRI_MASK_TYPE(x)                   ((u32)(((x >> 2) & 0x0000000F)))
-#define BIT_OOB_V1                                 ((u32)0x00000001 << 1)          /*!<R/W 0  out of band indication (0: in band ; 1 : out of band) */
-#define BIT_ANT_SEL_V1                             ((u32)0x00000001 << 0)          /*!<R/W 0  single or dual antenna selection (0: single; 1 : dual) */
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_RXCMD_0
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_RXCMD_EN                               ((u32)0x00000001 << 31)          /*!<R/W 0  RXCMD function enable */
-#define BIT_MASK_RXCMD_INFO                        ((u32)0x7FFFFFFF << 0)          /*!<R/W 0  The Information is send to rxpktbuffer for host SW */
-#define BIT_RXCMD_INFO(x)                          ((u32)(((x) & 0x7FFFFFFF) << 0))
-#define BIT_GET_RXCMD_INFO(x)                      ((u32)(((x >> 0) & 0x7FFFFFFF)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_RXCMD_1
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_MASK_RXCMD_PRD                         ((u32)0x0000FFFF << 0)          /*!<R/W 0  Define the period unit in us to send the RXCMD_INFO to rxpktbuffer for host SW */
-#define BIT_RXCMD_PRD(x)                           ((u32)(((x) & 0x0000FFFF) << 0))
-#define BIT_GET_RXCMD_PRD(x)                       ((u32)(((x >> 0) & 0x0000FFFF)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_RESP_TXINFO_CFG
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_MASK_RESP_MFB                          ((u32)0x0000007F << 25)          /*!<R/W 0  MFB information in register for response packet */
-#define BIT_RESP_MFB(x)                            ((u32)(((x) & 0x0000007F) << 25))
-#define BIT_GET_RESP_MFB(x)                        ((u32)(((x >> 25) & 0x0000007F)))
-#define BIT_MASK_ANTINF_SEL                        ((u32)0x00000003 << 23)          /*!<R/W 0  Antsel information for response frame in register or ctrl info 00: Antsel_en always disable, 01:Antsel_en field follow ctrl info 1X:Antsel_en always enable */
-#define BIT_ANTINF_SEL(x)                          ((u32)(((x) & 0x00000003) << 23))
-#define BIT_GET_ANTINF_SEL(x)                      ((u32)(((x >> 23) & 0x00000003)))
-#define BIT_MASK_ANTSEL_SEL                        ((u32)0x00000003 << 21)          /*!<R/W 0  antenna select 0: use rx phystatus antsel information; 1: use tx report antsel information; other: use register antsel information. */
-#define BIT_ANTSEL_SEL(x)                          ((u32)(((x) & 0x00000003) << 21))
-#define BIT_GET_ANTSEL_SEL(x)                      ((u32)(((x >> 21) & 0x00000003)))
-#define BIT_MASK_RESP_TXPOWER                      ((u32)0x00000007 << 18)          /*!<R/W 0  tx power setting when send response packet */
-#define BIT_RESP_TXPOWER(x)                        ((u32)(((x) & 0x00000007) << 18))
-#define BIT_GET_RESP_TXPOWER(x)                    ((u32)(((x >> 18) & 0x00000007)))
-#define BIT_MASK_RESP_TXANT                        ((u32)0x0003FFFF << 0)          /*!<R/W 0x3F  tx antenna information */
-#define BIT_RESP_TXANT(x)                          ((u32)(((x) & 0x0003FFFF) << 0))
-#define BIT_GET_RESP_TXANT(x)                      ((u32)(((x >> 0) & 0x0003FFFF)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_CSI_CTRL
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_CTL_IDLE_CLR_CSI_RPT_V1                ((u32)0x00000001 << 31)          /*!<R/W 0  ckr csi report request if response fsm idle */
-#define BIT_USE_NDPARATE                           ((u32)0x00000001 << 30)          /*!<R/W 1  1: use ndpa rx rate to decide csi report rate 0: use ndp rx rate to decide csi report rate */
-#define BIT_WMAC_CSI_RATE_FORCE_EN                 ((u32)0x00000001 << 15)          /*!<R/W 0  0: disable CSI force rate. Refer to RRSR bitmask 1: CSI frame Tx rate refers to 0x6DC[29:24] */
-#define BIT_MASK_WMAC_CSI_RSC_FORCE                ((u32)0x00000003 << 13)          /*!<R/W 0  If csi_force_rate_en = 1, CSI frame sub-channel configuration 00: Primary 20Mhz BW(0x483[3:0]) 01: Follow Rx packet BW. 10: Duplicate mode. 11: Reserved */
-#define BIT_WMAC_CSI_RSC_FORCE(x)                  ((u32)(((x) & 0x00000003) << 13))
-#define BIT_GET_WMAC_CSI_RSC_FORCE(x)              ((u32)(((x >> 13) & 0x00000003)))
-#define BIT_CSI_GID_SEL                            ((u32)0x00000001 << 12)          /*!<R/W 0  SIG-A content 1 : group id=0, 0 : group id=63 */
-#define BIT_RDCSIMD_FLAG_TRIG_SEL                  ((u32)0x00000001 << 11)          /*!<R/W 0  0: Trigger read csi mode flag raising when mac_csi_granted & ndp_valid positive edge 1: Trigger read csi mode flag raising when mac_csi_granted positive edge */
-#define BIT_NDPVLD_POS_RST_FFPTR_DIS_V1            ((u32)0x00000001 << 10)          /*!<R/W 0  0: Reset rx_fifo read/wrtie pointer when ndp_valid positive edge 1: Not reset rx_fifo read/wrtie pointer when ndp_valid positive edge */
-#define BIT_NDPVLD_PROTECT_RDRDY_DIS               ((u32)0x00000001 << 9)          /*!<R/W 0  0: Protect write enable of rx_fifo when ndp_valid =1 1: Not Protect write enable of rx_fifo when ndp_valid =1 */
-#define BIT_CSIRD_EMPTY_APPZERO                    ((u32)0x00000001 << 8)          /*!<R/W 0  0: Not append zero data when rx_fifo read csi data to empty. If csi data length of BB transmitted is smaller than MAC expected, Tx CSI report would be FCS error. 1: Append zero data when rx_fifo read csi data to empty. If csi data length of BB transmitted is smaller than MAC expected, there would be zero before FCS field of Tx CSI report pkt and the CSI report pkt would be FCS ok */
-#define BIT_WMC_CSI_RATE_FB_EN                     ((u32)0x00000001 << 7)          /*!<R/W 0  Enable CSI frame rate fallback (only one step in CSI RRSR) This bit is set to 1 to enable MAC to use previous latched csi resp rate for retry pkt. */
-#define BIT_RXFIFO_WRPTR_WO_CHKSUM                 ((u32)0x00000001 << 6)          /*!<R/W 0  This bit is set to 1 when rx_fifo don’t enable csi data checksum. */
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_P2P_RX_BCN_NOA
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_P2P_NOA_PARSER_EN                      ((u32)0x00000001 << 15)          /*!<R/W 0  NoA Parser enabled. */
-#define BIT_MASK_P2P_BSSID_SEL_V1                  ((u32)0x00000007 << 12)          /*!<R/W 0  When this valueis 0/1/2/3/4, then beacon with matched BSSID0/1/2/3/4 is parsed. */
-#define BIT_P2P_BSSID_SEL_V1(x)                    ((u32)(((x) & 0x00000007) << 12))
-#define BIT_GET_P2P_BSSID_SEL_V1(x)                ((u32)(((x >> 12) & 0x00000007)))
-#define BIT_MASK_P2P_OUI_TYPE                      ((u32)0x000000FF << 0)          /*!<R/W 0  NOA OUI Type */
-#define BIT_P2P_OUI_TYPE(x)                        ((u32)(((x) & 0x000000FF) << 0))
-#define BIT_GET_P2P_OUI_TYPE(x)                    ((u32)(((x >> 0) & 0x000000FF)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_ASSOCIATED_BFMER0_INFO
- * @brief Associated Beamformer0 Info Register
- * @{
- *****************************************************************************/
-#define BIT_MASK_R_WMAC_SOUNDING_RXADD_R0_V1       ((u32)0xFFFFFFFF << 0)          /*!<R/W 0  MACID of the associated beamformer0 bit[31:0] */
-#define BIT_R_WMAC_SOUNDING_RXADD_R0_V1(x)         ((u32)(((x) & 0xFFFFFFFF) << 0))
-#define BIT_GET_R_WMAC_SOUNDING_RXADD_R0_V1(x)     ((u32)(((x >> 0) & 0xFFFFFFFF)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_SOUNDING_CFG1
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_MASK_R_WMAC_TXCSI_AID0                 ((u32)0x000001FF << 16)          /*!<R/W 0  P_AID of the associated bemaformer0 */
-#define BIT_R_WMAC_TXCSI_AID0(x)                   ((u32)(((x) & 0x000001FF) << 16))
-#define BIT_GET_R_WMAC_TXCSI_AID0(x)               ((u32)(((x >> 16) & 0x000001FF)))
-#define BIT_MASK_R_WMAC_SOUNDING_RXADD_R0_H        ((u32)0x0000FFFF << 0)          /*!<R/W 0  MACID of the associated beamformer0 bit[47:32] */
-#define BIT_R_WMAC_SOUNDING_RXADD_R0_H(x)          ((u32)(((x) & 0x0000FFFF) << 0))
-#define BIT_GET_R_WMAC_SOUNDING_RXADD_R0_H(x)      ((u32)(((x >> 0) & 0x0000FFFF)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_SOUNDING_CFG2
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_MASK_R_WMAC_SOUNDING_RXADD_L           ((u32)0xFFFFFFFF << 0)          /*!<R/W 0  MACID of the associated beamformer1 bit[31:0] */
-#define BIT_R_WMAC_SOUNDING_RXADD_L(x)             ((u32)(((x) & 0xFFFFFFFF) << 0))
-#define BIT_GET_R_WMAC_SOUNDING_RXADD_L(x)         ((u32)(((x >> 0) & 0xFFFFFFFF)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_SOUNDING_CFG3
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_MASK_R_WMAC_TXCSI_AID1                 ((u32)0x000001FF << 16)          /*!<R/W 0  P_AID of the associated bemaformer1 */
-#define BIT_R_WMAC_TXCSI_AID1(x)                   ((u32)(((x) & 0x000001FF) << 16))
-#define BIT_GET_R_WMAC_TXCSI_AID1(x)               ((u32)(((x >> 16) & 0x000001FF)))
-#define BIT_MASK_R_WMAC_SOUNDING_RXADD_H           ((u32)0x0000FFFF << 0)          /*!<R/W 0  MACID of the associated beamformer1 bit[15:0] */
-#define BIT_R_WMAC_SOUNDING_RXADD_H(x)             ((u32)(((x) & 0x0000FFFF) << 0))
-#define BIT_GET_R_WMAC_SOUNDING_RXADD_H(x)         ((u32)(((x >> 0) & 0x0000FFFF)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_SOUNDING_CFG0
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_MASK_R_WMAC_BFINFO_20M_1               ((u32)0x00000FFF << 16)          /*!<R/W 0  BF Info of the associated beamformer1 at BW=20M bit[18:16]: Nc index bit[21:19]: Nr index bit[23:22]: grouping bit[25:24]: codebook info bit[27:26]: coefficient size */
-#define BIT_R_WMAC_BFINFO_20M_1(x)                 ((u32)(((x) & 0x00000FFF) << 16))
-#define BIT_GET_R_WMAC_BFINFO_20M_1(x)             ((u32)(((x >> 16) & 0x00000FFF)))
-#define BIT_MASK_R_WMAC_BFINFO_20M_0               ((u32)0x00000FFF << 0)          /*!<R/W 0  BF Info of the associated beamformer0 at BW=20M bit[2:0]: Nc index bit[5:3]: Nr index bit[7:6]: grouping bit[9:8]: codebook info bit[11:10]: coefficient size */
-#define BIT_R_WMAC_BFINFO_20M_0(x)                 ((u32)(((x) & 0x00000FFF) << 0))
-#define BIT_GET_R_WMAC_BFINFO_20M_0(x)             ((u32)(((x >> 0) & 0x00000FFF)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_ANTCD_INFO
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_MASK_WMAC_RESP_ANTD                    ((u32)0x0000000F << 12)          /*!<R/W 0  used for antenna select d value BIT_WMAC_RESP_ANTCD[3:2], used for antsel_d value; */
-#define BIT_WMAC_RESP_ANTD(x)                      ((u32)(((x) & 0x0000000F) << 12))
-#define BIT_GET_WMAC_RESP_ANTD(x)                  ((u32)(((x >> 12) & 0x0000000F)))
-#define BIT_MASK_WMAC_RESP_ANTC                    ((u32)0x0000000F << 8)          /*!<R/W 0  used for antenna select c value BIT_WMAC_RESP_ANTCD[3:3], used for antsel_d value; */
-#define BIT_WMAC_RESP_ANTC(x)                      ((u32)(((x) & 0x0000000F) << 8))
-#define BIT_GET_WMAC_RESP_ANTC(x)                  ((u32)(((x >> 8) & 0x0000000F)))
-#define BIT_MASK_WMAC_RESP_ANTB                    ((u32)0x0000000F << 4)          /*!<R/W 0  used for antenna select b value BIT_WMAC_RESP_ANTCD[3:4], used for antsel_d value; */
-#define BIT_WMAC_RESP_ANTB(x)                      ((u32)(((x) & 0x0000000F) << 4))
-#define BIT_GET_WMAC_RESP_ANTB(x)                  ((u32)(((x >> 4) & 0x0000000F)))
-#define BIT_MASK_WMAC_RESP_ANTA                    ((u32)0x0000000F << 0)          /*!<R/W 0  used for antenna select a value BIT_WMAC_RESP_ANTCD[3:5], used for antsel_d value; */
-#define BIT_WMAC_RESP_ANTA(x)                      ((u32)(((x) & 0x0000000F) << 0))
-#define BIT_GET_WMAC_RESP_ANTA(x)                  ((u32)(((x >> 0) & 0x0000000F)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_CSI_PTR
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_MASK_CSI_RADDR_LATCH_V2                ((u32)0x0000FFFF << 16)          /*!<R 0  Tx_fifo read pointer latch value after Tx CSI report pkt (unit: 8B) */
-#define BIT_CSI_RADDR_LATCH_V2(x)                  ((u32)(((x) & 0x0000FFFF) << 16))
-#define BIT_GET_CSI_RADDR_LATCH_V2(x)              ((u32)(((x >> 16) & 0x0000FFFF)))
-#define BIT_MASK_CSI_WADDR_LATCH_V2                ((u32)0x0000FFFF << 0)          /*!<R 0  Tx_fifo write pointer latch value at ndp_valid negative edge (unit: 8B) */
-#define BIT_CSI_WADDR_LATCH_V2(x)                  ((u32)(((x) & 0x0000FFFF) << 0))
-#define BIT_GET_CSI_WADDR_LATCH_V2(x)              ((u32)(((x >> 0) & 0x0000FFFF)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_BCN_PSR_RPT2
- * @brief Beacon Parser Report Register2
- * @{
- *****************************************************************************/
-#define BIT_MASK_DTIM_CNT2                         ((u32)0x000000FF << 24)          /*!<R 0  The DTIM count field of the TIM element of Rx beacon */
-#define BIT_DTIM_CNT2(x)                           ((u32)(((x) & 0x000000FF) << 24))
-#define BIT_GET_DTIM_CNT2(x)                       ((u32)(((x >> 24) & 0x000000FF)))
-#define BIT_MASK_DTIM_PERIOD2                      ((u32)0x000000FF << 16)          /*!<R 0  The DTIM period field of the TIM element of Rx beacon */
-#define BIT_DTIM_PERIOD2(x)                        ((u32)(((x) & 0x000000FF) << 16))
-#define BIT_GET_DTIM_PERIOD2(x)                    ((u32)(((x >> 16) & 0x000000FF)))
-#define BIT_HAS_MY_BC2                             ((u32)0x00000001 << 15)          /*!<R 0  Indicate BC/MC packets are buffered in transmitted BSSID or AP */
-#define BIT_HAS_MY_BSSID2                          ((u32)0x00000001 << 14)          /*!<R 0  Indicate BC/MC packets are buffered in nontransmitted BSSID, SW need check crespponding dtim count field in multiple bssid index field */
-#define BIT_HAS_MYAID2                             ((u32)0x00000001 << 13)          /*!<R 0  Indicate has my unicast packet */
-#define BIT_RPT_VALID2                             ((u32)0x00000001 << 12)          /*!<R 0  when set to 1, indicate the tim report is valid */
-#define BIT_MASK_PS_AID_2                          ((u32)0x000007FF << 0)          /*!<R/W 0  AID0 for MACID */
-#define BIT_PS_AID_2(x)                            ((u32)(((x) & 0x000007FF) << 0))
-#define BIT_GET_PS_AID_2(x)                        ((u32)(((x >> 0) & 0x000007FF)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_BCN_PSR_RPT3
- * @brief Beacon Parser Report Register3
- * @{
- *****************************************************************************/
-#define BIT_MASK_DTIM_CNT3                         ((u32)0x000000FF << 24)          /*!<R 0  The DTIM count field of the TIM element of Rx beacon */
-#define BIT_DTIM_CNT3(x)                           ((u32)(((x) & 0x000000FF) << 24))
-#define BIT_GET_DTIM_CNT3(x)                       ((u32)(((x >> 24) & 0x000000FF)))
-#define BIT_MASK_DTIM_PERIOD3                      ((u32)0x000000FF << 16)          /*!<R 0  The DTIM period field of the TIM element of Rx beacon */
-#define BIT_DTIM_PERIOD3(x)                        ((u32)(((x) & 0x000000FF) << 16))
-#define BIT_GET_DTIM_PERIOD3(x)                    ((u32)(((x >> 16) & 0x000000FF)))
-#define BIT_HAS_MY_BC3                             ((u32)0x00000001 << 15)          /*!<R 0  Indicate BC/MC packets are buffered in transmitted BSSID or AP */
-#define BIT_HAS_MY_BSSID3                          ((u32)0x00000001 << 14)          /*!<R 0  Indicate BC/MC packets are buffered in nontransmitted BSSID, SW need check crespponding dtim count field in multiple bssid index field */
-#define BIT_HAS_MYAID3                             ((u32)0x00000001 << 13)          /*!<R 0  Indicate has my unicast packet */
-#define BIT_RPT_VALID3                             ((u32)0x00000001 << 12)          /*!<R 0  when set to 1, indicate the tim report is valid */
-#define BIT_MASK_PS_AID_3                          ((u32)0x000007FF << 0)          /*!<R/W 0  AID0 for MACID */
-#define BIT_PS_AID_3(x)                            ((u32)(((x) & 0x000007FF) << 0))
-#define BIT_GET_PS_AID_3(x)                        ((u32)(((x >> 0) & 0x000007FF)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_BCN_PSR_RPT4
- * @brief Beacon Parser Report Register4
- * @{
- *****************************************************************************/
-#define BIT_MASK_DTIM_CNT4                         ((u32)0x000000FF << 24)          /*!<R 0  The DTIM count field of the TIM element of Rx beacon */
-#define BIT_DTIM_CNT4(x)                           ((u32)(((x) & 0x000000FF) << 24))
-#define BIT_GET_DTIM_CNT4(x)                       ((u32)(((x >> 24) & 0x000000FF)))
-#define BIT_MASK_DTIM_PERIOD4                      ((u32)0x000000FF << 16)          /*!<R 0  The DTIM period field of the TIM element of Rx beacon */
-#define BIT_DTIM_PERIOD4(x)                        ((u32)(((x) & 0x000000FF) << 16))
-#define BIT_GET_DTIM_PERIOD4(x)                    ((u32)(((x >> 16) & 0x000000FF)))
-#define BIT_HAS_MY_BC4                             ((u32)0x00000001 << 15)          /*!<R 0  Indicate BC/MC packets are buffered in transmitted BSSID or AP */
-#define BIT_HAS_MY_BSSID4                          ((u32)0x00000001 << 14)          /*!<R 0  Indicate BC/MC packets are buffered in nontransmitted BSSID, SW need check crespponding dtim count field in multiple bssid index field */
-#define BIT_HAS_MYAID4                             ((u32)0x00000001 << 13)          /*!<R 0  Indicate has my unicast packet */
-#define BIT_RPT_VALID4                             ((u32)0x00000001 << 12)          /*!<R 0  when set to 1, indicate the tim report is valid */
-#define BIT_MASK_PS_AID_4                          ((u32)0x000007FF << 0)          /*!<R/W 0  AID0 for MACID */
-#define BIT_PS_AID_4(x)                            ((u32)(((x) & 0x000007FF) << 0))
-#define BIT_GET_PS_AID_4(x)                        ((u32)(((x >> 0) & 0x000007FF)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_A1_ADDR_MASK
- * @brief A1 Addr Mask Register
- * @{
- *****************************************************************************/
-#define BIT_MASK_A1_ADDR_MASK                      ((u32)0xFFFFFFFF << 0)          /*!<R/W 0xFFFFFFFF  mask rx A1 addr [39:8] for test */
-#define BIT_A1_ADDR_MASK(x)                        ((u32)(((x) & 0xFFFFFFFF) << 0))
-#define BIT_GET_A1_ADDR_MASK(x)                    ((u32)(((x >> 0) & 0xFFFFFFFF)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_RXPSF_CTRL
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_RXGCK_FIFOTHR_EN                       ((u32)0x00000001 << 28)          /*!<R/W 0  1: enable RXGCK fifo threshold 0: disable RXGCK fifo threshold (ignore fifo threshold) Should be 0 if MAC loopback mode */
-#define BIT_MASK_RXGCK_VHT_FIFOTHR                 ((u32)0x00000003 << 26)          /*!<R/W 0  VHT rate RXGCK fifo threshold If RXVHT = 1 and RXGCK fifo write pointer >= this threshold, MAC_RX clock will stop gating. 0: 0 1: 1 (minimum RDRDY threshold for avoiding false alarm), can work at all situation. 2: 3 (number of RDRDY before receiving MAC header - 1), may cause error at some situation. 3: 4 (number of RDRDY before receiving MAC header), may cause error at some situation. */
-#define BIT_RXGCK_VHT_FIFOTHR(x)                   ((u32)(((x) & 0x00000003) << 26))
-#define BIT_GET_RXGCK_VHT_FIFOTHR(x)               ((u32)(((x >> 26) & 0x00000003)))
-#define BIT_MASK_RXGCK_HT_FIFOTHR                  ((u32)0x00000003 << 24)          /*!<R/W 0  HT rate RXGCK fifo threshold If RXHT = 1 and RXGCK fifo write pointer >= this threshold, MAC_RX clock will stop gating. 0: 0 1: 1 (minimum RDRDY threshold for avoiding false alarm), can work at all situation. 2: 2 (number of RDRDY before receiving MAC header - 1), may cause error at some situation. 3: 3 (number of RDRDY before receiving MAC header), may cause error at some situation. */
-#define BIT_RXGCK_HT_FIFOTHR(x)                    ((u32)(((x) & 0x00000003) << 24))
-#define BIT_GET_RXGCK_HT_FIFOTHR(x)                ((u32)(((x >> 24) & 0x00000003)))
-#define BIT_MASK_RXGCK_OFDM_FIFOTHR                ((u32)0x00000003 << 22)          /*!<R/W 0  OFDM rate RXGCK fifo threshold If OFDM_VBON = 1 and RXGCK fifo write pointer >= this threshold, MAC_RX clock will stop gating. 0: 0 1: 1 (number of RDRDY before receiving MAC header = minimum RDRDY threshold for avoiding false alarm), can work at all situation. 2: 2, may cause error at some situation. 3: 3 (minimum RDRDY number within one packet), may cause error at some situation. */
-#define BIT_RXGCK_OFDM_FIFOTHR(x)                  ((u32)(((x) & 0x00000003) << 22))
-#define BIT_GET_RXGCK_OFDM_FIFOTHR(x)              ((u32)(((x >> 22) & 0x00000003)))
-#define BIT_MASK_RXGCK_CCK_FIFOTHR                 ((u32)0x00000003 << 20)          /*!<R/W 0  CCK rate RXGCK fifo threshold If CCKCCA = 1 and RXGCK fifo write pointer >= this threshold, MAC_RX clock will stop gating. 0: 0 1: 1 (minimum RDRDY threshold for avoiding false alarm), can work at all situation. 2: 8, may cause error at some situation. 3: 15 (number of RDRDY before receiving MAC header), may cause error at some situation. */
-#define BIT_RXGCK_CCK_FIFOTHR(x)                   ((u32)(((x) & 0x00000003) << 20))
-#define BIT_GET_RXGCK_CCK_FIFOTHR(x)               ((u32)(((x >> 20) & 0x00000003)))
-#define BIT_MASK_RXGCK_ENTRY_DELAY                 ((u32)0x00000007 << 17)          /*!<R/W 0x2  MAC_RX wait some time to gate clock after making the decision (about gating clock). Unit: T (MAC clock cycle) 0: 0 1: 2 2: 4 3: 8 4: 16 5: 32 6: 64 7: 128 */
-#define BIT_RXGCK_ENTRY_DELAY(x)                   ((u32)(((x) & 0x00000007) << 17))
-#define BIT_GET_RXGCK_ENTRY_DELAY(x)               ((u32)(((x >> 17) & 0x00000007)))
-#define BIT_RXGCK_OFDMCCA_EN                       ((u32)0x00000001 << 16)          /*!<R/W 0  This bit is set to 1 to let OFDMCCA be one of the signals that can wakeup MAC from Rx_idle */
-#define BIT_MASK_RXPSF_PKTLENTHR                   ((u32)0x00000007 << 13)          /*!<R/W 0  Packet length threshold 3'd0: 16 Bytes 3'd1: 32 Bytes 3'd2: 64 Bytes 3'd3: 128 Bytes 3'd4: 256 Bytes 3'd5: 512 Bytes 3'd6: 1024 Bytes 3'd7: 2048 Bytes Only the packet which packet length is longer than this threshold will trigger an invalid_pkt pulse. */
-#define BIT_RXPSF_PKTLENTHR(x)                     ((u32)(((x) & 0x00000007) << 13))
-#define BIT_GET_RXPSF_PKTLENTHR(x)                 ((u32)(((x >> 13) & 0x00000007)))
-#define BIT_RXPSF_CTRLEN                           ((u32)0x00000001 << 12)          /*!<R/W 0  This bit is set to 1 to enable MAC to consider trigging invalid_pkt as rx packet Type=01. */
-#define BIT_RXPSF_VHTCHKEN                         ((u32)0x00000001 << 11)          /*!<R/W 0  This bit is set to 1 to enable MAC to consider trigging invalid_pkt as rx packet rate = VHT */
-#define BIT_RXPSF_HTCHKEN                          ((u32)0x00000001 << 10)          /*!<R/W 0  This bit is set to 1 to enable MAC to consider trigging invalid_pkt as rx packet rate = HT */
-#define BIT_RXPSF_OFDMCHKEN                        ((u32)0x00000001 << 9)          /*!<R/W 0  This bit is set to 1 to enable MAC to consider trigging invalid_pkt as rx packet rate = OFDM */
-#define BIT_RXPSF_CCKCHKEN                         ((u32)0x00000001 << 8)          /*!<R/W 0  This bit is set to 1 to enable MAC to consider trigging invalid_pkt as rx packet rate = CCK */
-#define BIT_RXPSF_OFDMRST                          ((u32)0x00000001 << 7)          /*!<R/W 1  This bit is set to 1 to reset MAC Rx before sending OFDM (include OFDM, HT, VHT) packet triggered invalid_pkt pulse (0 for debug) */
-#define BIT_RXPSF_CCKRST                           ((u32)0x00000001 << 6)          /*!<R/W 1  This bit is set to 1 to reset MAC Rx before sending CCK packet triggered invalid_pkt pulse(0 for debug) */
-#define BIT_RXPSF_MHCHKEN                          ((u32)0x00000001 << 5)          /*!<R/W 0  This bit is set to 1 to enable MAC to inform BB enter power saving mode as rx unmatch my MACID unicast or unmatch my BSSID Broadcast/Mutlicast packets (including aggrigation and non-aggrigation) */
-#define BIT_RXPSF_CONT_ERRCHKEN                    ((u32)0x00000001 << 4)          /*!<R/W 0  This bit is set to 1 to enable MAC to inform BB enter power saving mode as continuous rx FCS error packets number in a PPDU is large than the FCS error packet threshold defined by BBPSF_ERRTHR. This function is independent from rate, type and IDs. */
-#define BIT_RXPSF_ALL_ERRCHKEN                     ((u32)0x00000001 << 3)          /*!<R/W 0  This bit is set to 1 to enable MAC to inform BB enter power saving mode as rx FCS error packets number in a PPDU is larger than the FCS error packet threshold defined by BBPSF_ERRTHR. This function is independent from rate, type and IDs. */
-#define BIT_MASK_RXPSF_ERRTHR                      ((u32)0x00000007 << 0)          /*!<R/W 0  FCS error packet threshold 3'd0: 1 packet 3'd1: 4 packets 3'd2: 8 packets 3'd3: 12 packets 3'd4: 16 packets 3'd5: 20 packets 3'd6: 24 packets 3'd7: 28 packets */
-#define BIT_RXPSF_ERRTHR(x)                        ((u32)(((x) & 0x00000007) << 0))
-#define BIT_GET_RXPSF_ERRTHR(x)                    ((u32)(((x >> 0) & 0x00000007)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_RXPSF_TYPE_CTRL
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_RXPSF_DATA15EN                         ((u32)0x00000001 << 31)          /*!<R/W 0  This bit is set to 1 to enable MAC to consider trigging invalid_pkt as rx packet Type=10 and subtype=1111. */
-#define BIT_RXPSF_DATA14EN                         ((u32)0x00000001 << 30)          /*!<R/W 0  This bit is set to 1 to enable MAC to consider trigging invalid_pkt as rx packet Type=10 and subtype=1110. */
-#define BIT_RXPSF_DATA13EN                         ((u32)0x00000001 << 29)          /*!<R/W 0  This bit is set to 1 to enable MAC to consider trigging invalid_pkt as rx packet Type=10 and subtype=1101. */
-#define BIT_RXPSF_DATA12EN                         ((u32)0x00000001 << 28)          /*!<R/W 0  This bit is set to 1 to enable MAC to consider trigging invalid_pkt as rx packet Type=10 and subtype=1100. */
-#define BIT_RXPSF_DATA11EN                         ((u32)0x00000001 << 27)          /*!<R/W 0  This bit is set to 1 to enable MAC to consider trigging invalid_pkt as rx packet Type=10 and subtype=1011. */
-#define BIT_RXPSF_DATA10EN                         ((u32)0x00000001 << 26)          /*!<R/W 0  This bit is set to 1 to enable MAC to consider trigging invalid_pkt as rx packet Type=10 and subtype=1010. */
-#define BIT_RXPSF_DATA9EN                          ((u32)0x00000001 << 25)          /*!<R/W 0  This bit is set to 1 to enable MAC to consider trigging invalid_pkt as rx packet Type=10 and subtype=1001. */
-#define BIT_RXPSF_DATA8EN                          ((u32)0x00000001 << 24)          /*!<R/W 0  This bit is set to 1 to enable MAC to consider trigging invalid_pkt as rx packet Type=10 and subtype=1000. */
-#define BIT_RXPSF_DATA7EN                          ((u32)0x00000001 << 23)          /*!<R/W 0  This bit is set to 1 to enable MAC to consider trigging invalid_pkt as rx packet Type=10 and subtype=0111. */
-#define BIT_RXPSF_DATA6EN                          ((u32)0x00000001 << 22)          /*!<R/W 0  This bit is set to 1 to enable MAC to consider trigging invalid_pkt as rx packet Type=10 and subtype=0110. */
-#define BIT_RXPSF_DATA5EN                          ((u32)0x00000001 << 21)          /*!<R/W 0  This bit is set to 1 to enable MAC to consider trigging invalid_pkt as rx packet Type=10 and subtype=0101. */
-#define BIT_RXPSF_DATA4EN                          ((u32)0x00000001 << 20)          /*!<R/W 0  This bit is set to 1 to enable MAC to consider trigging invalid_pkt as rx packet Type=10 and subtype=0100. */
-#define BIT_RXPSF_DATA3EN                          ((u32)0x00000001 << 19)          /*!<R/W 0  This bit is set to 1 to enable MAC to consider trigging invalid_pkt as rx packet Type=10 and subtype=0011. */
-#define BIT_RXPSF_DATA2EN                          ((u32)0x00000001 << 18)          /*!<R/W 0  This bit is set to 1 to enable MAC to consider trigging invalid_pkt as rx packet Type=10 and subtype=0010. */
-#define BIT_RXPSF_DATA1EN                          ((u32)0x00000001 << 17)          /*!<R/W 0  This bit is set to 1 to enable MAC to consider trigging invalid_pkt as rx packet Type=10 and subtype=0001. */
-#define BIT_RXPSF_DATA0EN                          ((u32)0x00000001 << 16)          /*!<R/W 0  This bit is set to 1 to enable MAC to consider trigging invalid_pkt as rx packet Type=10 and subtype=0000. */
-#define BIT_RXPSF_MGT15EN                          ((u32)0x00000001 << 15)          /*!<R/W 0  This bit is set to 1 to enable MAC to consider trigging invalid_pkt as rx packet Type=00 and subtype=1111. */
-#define BIT_RXPSF_MGT14EN                          ((u32)0x00000001 << 14)          /*!<R/W 0  This bit is set to 1 to enable MAC to consider trigging invalid_pkt as rx packet Type=00 and subtype=1110. */
-#define BIT_RXPSF_MGT13EN                          ((u32)0x00000001 << 13)          /*!<R/W 0  This bit is set to 1 to enable MAC to consider trigging invalid_pkt as rx packet Type=00 and subtype=1101. */
-#define BIT_RXPSF_MGT12EN                          ((u32)0x00000001 << 12)          /*!<R/W 0  This bit is set to 1 to enable MAC to consider trigging invalid_pkt as rx packet Type=00 and subtype=1100. */
-#define BIT_RXPSF_MGT11EN                          ((u32)0x00000001 << 11)          /*!<R/W 0  This bit is set to 1 to enable MAC to consider trigging invalid_pkt as rx packet Type=00 and subtype=1011. */
-#define BIT_RXPSF_MGT10EN                          ((u32)0x00000001 << 10)          /*!<R/W 0  This bit is set to 1 to enable MAC to consider trigging invalid_pkt as rx packet Type=00 and subtype=1010. */
-#define BIT_RXPSF_MGT9EN                           ((u32)0x00000001 << 9)          /*!<R/W 0  This bit is set to 1 to enable MAC to consider trigging invalid_pkt as rx packet Type=00 and subtype=1001. */
-#define BIT_RXPSF_MGT8EN                           ((u32)0x00000001 << 8)          /*!<R/W 0  This bit is set to 1 to enable MAC to consider trigging invalid_pkt as rx packet Type=00 and subtype=1000. */
-#define BIT_RXPSF_MGT7EN                           ((u32)0x00000001 << 7)          /*!<R/W 0  This bit is set to 1 to enable MAC to consider trigging invalid_pkt as rx packet Type=00 and subtype=0111. */
-#define BIT_RXPSF_MGT6EN                           ((u32)0x00000001 << 6)          /*!<R/W 0  This bit is set to 1 to enable MAC to consider trigging invalid_pkt as rx packet Type=00 and subtype=0110. */
-#define BIT_RXPSF_MGT5EN                           ((u32)0x00000001 << 5)          /*!<R/W 0  This bit is set to 1 to enable MAC to consider trigging invalid_pkt as rx packet Type=00 and subtype=0101. */
-#define BIT_RXPSF_MGT4EN                           ((u32)0x00000001 << 4)          /*!<R/W 0  This bit is set to 1 to enable MAC to consider trigging invalid_pkt as rx packet Type=00 and subtype=0100. */
-#define BIT_RXPSF_MGT3EN                           ((u32)0x00000001 << 3)          /*!<R/W 0  This bit is set to 1 to enable MAC to consider trigging invalid_pkt as rx packet Type=00 and subtype=0011. */
-#define BIT_RXPSF_MGT2EN                           ((u32)0x00000001 << 2)          /*!<R/W 0  This bit is set to 1 to enable MAC to consider trigging invalid_pkt as rx packet Type=00 and subtype=0010. */
-#define BIT_RXPSF_MGT1EN                           ((u32)0x00000001 << 1)          /*!<R/W 0  This bit is set to 1 to enable MAC to consider trigging invalid_pkt as rx packet Type=00 and subtype=0001. */
-#define BIT_RXPSF_MGT0EN                           ((u32)0x00000001 << 0)          /*!<R/W 0  This bit is set to 1 to enable MAC to consider trigging invalid_pkt as rx packet Type=00 and subtype=0000. */
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_WAIT_PHYSTS_CTL
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_BB_RST_RESP                            ((u32)0x00000001 << 7)          /*!<R/W 0  When set to 1,enable bb/rdrdy_err/cca_spoofing to reset mac and will not tx response */
-#define BIT_CCA_SPOOFING_EN                        ((u32)0x00000001 << 6)          /*!<R/W 0  When set to 1,enable cca_spoofing reset macrx */
-#define BIT_RDRDY_NUM_CHK_EN                       ((u32)0x00000001 << 5)          /*!<R/W 1  When set, enable check rdrdy number is enough or not. If number is not enough will rst macrx */
-#define BIT_WAIT_PHYSTS_EN                         ((u32)0x00000001 << 4)          /*!<R/W 0  When set to 1,enable wait physts rpt valid function */
-#define BIT_MASK_WAIT_PHYSTS_TIME                  ((u32)0x0000000F << 0)          /*!<R/W 0x4  Wait physts rpt timeout ,unit μs（6μs is the recommeded value） */
-#define BIT_WAIT_PHYSTS_TIME(x)                    ((u32)(((x) & 0x0000000F) << 0))
-#define BIT_GET_WAIT_PHYSTS_TIME(x)                ((u32)(((x >> 0) & 0x0000000F)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_MACID2
- * @brief MAC ID2 Register
- * @{
- *****************************************************************************/
-#define BIT_MASK_MACID2_V1                         ((u32)0xFFFFFFFF << 0)          /*!<R/W 0  MAC Identification Number 2 Register */
-#define BIT_MACID2_V1(x)                           ((u32)(((x) & 0xFFFFFFFF) << 0))
-#define BIT_GET_MACID2_V1(x)                       ((u32)(((x >> 0) & 0xFFFFFFFF)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_MACID2_H
- * @brief MAC ID2 Register
- * @{
- *****************************************************************************/
-#define BIT_MASK_MACID2_H_V1                       ((u32)0x0000FFFF << 0)          /*!<R/W 0  MAC Identification Number 2 Register */
-#define BIT_MACID2_H_V1(x)                         ((u32)(((x) & 0x0000FFFF) << 0))
-#define BIT_GET_MACID2_H_V1(x)                     ((u32)(((x >> 0) & 0x0000FFFF)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_BSSID2
- * @brief BSSID2 Register
- * @{
- *****************************************************************************/
-#define BIT_MASK_BSSID2_V1                         ((u32)0xFFFFFFFF << 0)          /*!<R/W 0  Basic Station Set Identification 2 */
-#define BIT_BSSID2_V1(x)                           ((u32)(((x) & 0xFFFFFFFF) << 0))
-#define BIT_GET_BSSID2_V1(x)                       ((u32)(((x >> 0) & 0xFFFFFFFF)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_BSSID2_H
- * @brief BSSID2 Register
- * @{
- *****************************************************************************/
-#define BIT_MASK_BSSID2_H_V1                       ((u32)0x0000FFFF << 0)          /*!<R/W 0  Basic Station Set Identification 2 */
-#define BIT_BSSID2_H_V1(x)                         ((u32)(((x) & 0x0000FFFF) << 0))
-#define BIT_GET_BSSID2_H_V1(x)                     ((u32)(((x >> 0) & 0x0000FFFF)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_MACID3
- * @brief MAC ID3 Register
- * @{
- *****************************************************************************/
-#define BIT_MASK_MACID3_V1                         ((u32)0xFFFFFFFF << 0)          /*!<R/W 0  MAC Identification Number 3 Register */
-#define BIT_MACID3_V1(x)                           ((u32)(((x) & 0xFFFFFFFF) << 0))
-#define BIT_GET_MACID3_V1(x)                       ((u32)(((x >> 0) & 0xFFFFFFFF)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_MACID3_H
- * @brief MAC ID3 Register
- * @{
- *****************************************************************************/
-#define BIT_MASK_MACID3_H_V1                       ((u32)0x0000FFFF << 0)          /*!<R/W 0  MAC Identification Number 3 Register */
-#define BIT_MACID3_H_V1(x)                         ((u32)(((x) & 0x0000FFFF) << 0))
-#define BIT_GET_MACID3_H_V1(x)                     ((u32)(((x >> 0) & 0x0000FFFF)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_BSSID3
- * @brief BSSID3 Register
- * @{
- *****************************************************************************/
-#define BIT_MASK_BSSID3_V1                         ((u32)0xFFFFFFFF << 0)          /*!<R/W 0  Basic Station Set Identification 3 */
-#define BIT_BSSID3_V1(x)                           ((u32)(((x) & 0xFFFFFFFF) << 0))
-#define BIT_GET_BSSID3_V1(x)                       ((u32)(((x >> 0) & 0xFFFFFFFF)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_BSSID3_H
- * @brief BSSID3 Register
- * @{
- *****************************************************************************/
-#define BIT_MASK_BSSID3_H_V1                       ((u32)0x0000FFFF << 0)          /*!<R/W 0  Basic Station Set Identification 3 */
-#define BIT_BSSID3_H_V1(x)                         ((u32)(((x) & 0x0000FFFF) << 0))
-#define BIT_GET_BSSID3_H_V1(x)                     ((u32)(((x >> 0) & 0x0000FFFF)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_MACID4
- * @brief MAC ID4 Register
- * @{
- *****************************************************************************/
-#define BIT_MASK_MACID4_V1                         ((u32)0xFFFFFFFF << 0)          /*!<R/W 0  MAC Identification Number 4 Register */
-#define BIT_MACID4_V1(x)                           ((u32)(((x) & 0xFFFFFFFF) << 0))
-#define BIT_GET_MACID4_V1(x)                       ((u32)(((x >> 0) & 0xFFFFFFFF)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_MACID4_H
- * @brief MAC ID4 Register
- * @{
- *****************************************************************************/
-#define BIT_MASK_MACID4_H_V1                       ((u32)0x0000FFFF << 0)          /*!<R/W 0  MAC Identification Number 4 Register */
-#define BIT_MACID4_H_V1(x)                         ((u32)(((x) & 0x0000FFFF) << 0))
-#define BIT_GET_MACID4_H_V1(x)                     ((u32)(((x >> 0) & 0x0000FFFF)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_BSSID4
- * @brief BSSID4 Register
- * @{
- *****************************************************************************/
-#define BIT_MASK_BSSID4_V1                         ((u32)0xFFFFFFFF << 0)          /*!<R/W 0  Basic Station Set Identification 4 */
-#define BIT_BSSID4_V1(x)                           ((u32)(((x) & 0xFFFFFFFF) << 0))
-#define BIT_GET_BSSID4_V1(x)                       ((u32)(((x >> 0) & 0xFFFFFFFF)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_BSSID4_H
- * @brief BSSID4 Register
- * @{
- *****************************************************************************/
-#define BIT_MASK_BSSID4_H_V1                       ((u32)0x0000FFFF << 0)          /*!<R/W 0  Basic Station Set Identification 4 */
-#define BIT_BSSID4_H_V1(x)                         ((u32)(((x) & 0x0000FFFF) << 0))
-#define BIT_GET_BSSID4_H_V1(x)                     ((u32)(((x >> 0) & 0x0000FFFF)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_NOA_REPORT
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_MASK_NOA_RPT                           ((u32)0xFFFFFFFF << 0)          /*!<R/W 0   */
-#define BIT_NOA_RPT(x)                             ((u32)(((x) & 0xFFFFFFFF) << 0))
-#define BIT_GET_NOA_RPT(x)                         ((u32)(((x >> 0) & 0xFFFFFFFF)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_NOA_REPORT_1
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_MASK_NOA_RPT_1                         ((u32)0xFFFFFFFF << 0)          /*!<R/W 0   */
-#define BIT_NOA_RPT_1(x)                           ((u32)(((x) & 0xFFFFFFFF) << 0))
-#define BIT_GET_NOA_RPT_1(x)                       ((u32)(((x >> 0) & 0xFFFFFFFF)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_NOA_REPORT_2
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_MASK_NOA_RPT_2                         ((u32)0xFFFFFFFF << 0)          /*!<R/W 0   */
-#define BIT_NOA_RPT_2(x)                           ((u32)(((x) & 0xFFFFFFFF) << 0))
-#define BIT_GET_NOA_RPT_2(x)                       ((u32)(((x >> 0) & 0xFFFFFFFF)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_NOA_REPORT_3
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_MASK_NOA_RPT_3                         ((u32)0x000000FF << 0)          /*!<R/W 0   */
-#define BIT_NOA_RPT_3(x)                           ((u32)(((x) & 0x000000FF) << 0))
-#define BIT_GET_NOA_RPT_3(x)                       ((u32)(((x >> 0) & 0x000000FF)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_PWRBIT_SETTING
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_CLI3_PWRBIT_OW_EN                      ((u32)0x00000001 << 7)          /*!<R/W 0  For client3 (port4). If this bit is set to 1, MAC will overwrite power bit of frame control according to CLI3_PWR_ST. (only for data frame) */
-#define BIT_CLI3_PWR_ST                            ((u32)0x00000001 << 6)          /*!<R/W 0  For client3 (port4). MAC will overwrite power bit of frame control according to CLI3_PWR_ST.(only for data frame) */
-#define BIT_CLI2_PWRBIT_OW_EN                      ((u32)0x00000001 << 5)          /*!<R/W 0  For client2 (port3). If this bit is set to 1, MAC will overwrite power bit of frame control according to CLI2_PWR_ST. (only for data frame) */
-#define BIT_CLI2_PWR_ST                            ((u32)0x00000001 << 4)          /*!<R/W 0  For client2 (port3). MAC will overwrite power bit of frame control according to CLI2_PWR_ST.(only for data frame) */
-#define BIT_CLI1_PWRBIT_OW_EN                      ((u32)0x00000001 << 3)          /*!<R/W 0  For client1 (port2). If this bit is set to 1, MAC will overwrite power bit of frame control according to CLI1_PWR_ST. (only for data frame) */
-#define BIT_CLI1_PWR_ST                            ((u32)0x00000001 << 2)          /*!<R/W 0  For client1 (port2). MAC will overwrite power bit of frame control according to CLI1_PWR_ST.(only for data frame) */
-#define BIT_CLI0_PWRBIT_OW_EN                      ((u32)0x00000001 << 1)          /*!<R/W 0  For client0 (port1). If this bit is set to 1, MAC will overwrite power bit of frame control according to CLI0_PWR_ST. (only for data frame) */
-#define BIT_CLI0_PWR_ST                            ((u32)0x00000001 << 0)          /*!<R/W 0  For client0 (port1). MAC will overwrite power bit of frame control according to CLI0_PWR_ST.(only for data frame) */
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_GENERAL_OPTION
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_EXT_DBGSEL                             ((u32)0x00000001 << 6)          /*!<R/W 0  enable extend dbg port sel */
-#define BIT_TXSERV_FIELD_SEL                       ((u32)0x00000001 << 2)          /*!<R/W 0   */
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_RXAI_CTRL
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_RXAI_PRTCT_REL                         ((u32)0x00000001 << 6)          /*!<R 0  If MAC_reset_protect is set to 0 by MAC decision circuit (address/A-MPDU checking), set this bit to 1. Reset by BIT_RXAI_INFO_RST = 1 */
-#define BIT_RXAI_PRTCT_VIO                         ((u32)0x00000001 << 5)          /*!<R 0  If MAC gets BB_reset_MAC pulse when MAC_reset_protect = 1, set this bit to 1. Reset by BIT_RXAI_INFO_RST = 1 */
-#define BIT_RXAI_PRTCT_SEL                         ((u32)0x00000001 << 2)          /*!<R/W 0  MAC_reset_protect rises at 0: DATA_ON rises 1: PLCP check OK (OFDM/CCK) or receiving 3rd/2nd (VHT/HT) RDRDY */
-#define BIT_RXAI_AGG_CHKEN                         ((u32)0x00000001 << 1)          /*!<R/W 0  This bit is only workable when BIT_RXAI_ADDR_CHKEN = 1. 1: if and only if the receiving address matched PPDU is A-MPDU and is not VHT single MPDU, then MAC inform BB not doing reCCA. */
-#define BIT_RXAI_ADDR_CHKEN                        ((u32)0x00000001 << 0)          /*!<R/W 0  This bit is set to 1 to enable MAC to inform BB not doing reCCA during receiving the address matched PPDU. */
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_RX_BCN_TM
- * @brief rx beacon timer
- * @{
- *****************************************************************************/
-#define BIT_MASK_RX_BCN_TIMER                      ((u32)0x0000FFFF << 0)          /*!<R 0  indicate rx beacon timer from cca up to fcs ok, units us */
-#define BIT_RX_BCN_TIMER(x)                        ((u32)(((x) & 0x0000FFFF) << 0))
-#define BIT_GET_RX_BCN_TIMER(x)                    ((u32)(((x >> 0) & 0x0000FFFF)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_CSI_RRSR
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_CSI_LDPC_EN                            ((u32)0x00000001 << 29)          /*!<R/W 0  Enable LDPC in Tx CSI Frame */
-#define BIT_CSI_STBC_EN                            ((u32)0x00000001 << 28)          /*!<R/W 0  Enable STBC in Tx CSI Frame */
-#define BIT_MASK_CSI_RRSC_BITMAP                   ((u32)0x00FFFFFF << 4)          /*!<R/W 0  BitMap to indicate the CSI frame rate in this BSS. Each bit is mapped as the following: Bit[4:11] = {6M, 9M, 12M, 18M, 24M, 36M, 48M, 54M} Bit[12:19] = HT MCS0~MCS7 BIT[27:20] = VHT 1SSMCS0~7 The modulation of response rate must be less than or equal to the rate of the initiating frame. If none of the bits are set, no response is generated by Rtl8712. If both legacy rates and HT rates are defined as Basic Rates, fill in only the legacy portion of the bitmap. If only HT rates are defined as Basic Rates, fill in both the legacy and HT portion of the bitmap. */
-#define BIT_CSI_RRSC_BITMAP(x)                     ((u32)(((x) & 0x00FFFFFF) << 4))
-#define BIT_GET_CSI_RRSC_BITMAP(x)                 ((u32)(((x >> 4) & 0x00FFFFFF)))
-#define BIT_MASK_OFDM_LEN_TH                       ((u32)0x0000000F << 0)          /*!<R/W 0  CSI frame length threshold for using legacy OFDM (unit: 128B). 0 means disabled. If CSI frame length > threshold, search from VHT or HT bitmap If CSI frame length < threshold, search from legacy OFDM bitmap */
-#define BIT_OFDM_LEN_TH(x)                         ((u32)(((x) & 0x0000000F) << 0))
-#define BIT_GET_OFDM_LEN_TH(x)                     ((u32)(((x >> 0) & 0x0000000F)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_MU_BF_OPTION
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_WMAC_NOCHK_BFPOLL_BMP                  ((u32)0x00000001 << 31)          /*!<R/W 0  Set this bit to ignore retransmission bitmap of rx beamforming report poll */
-#define BIT_MASK_WMAC_CSI_PARA_RDY_DLYCNT          ((u32)0x0000001F << 24)          /*!<R/W 0x1F  1:Cycle number from txctl state machine IDLE(VBON falling) to CSI_standby falling. 2:Half of this value is txctl state machine IDLE(VBON falling) to CSI_parameter_ready rising cycle number. */
-#define BIT_WMAC_CSI_PARA_RDY_DLYCNT(x)            ((u32)(((x) & 0x0000001F) << 24))
-#define BIT_GET_WMAC_CSI_PARA_RDY_DLYCNT(x)        ((u32)(((x >> 24) & 0x0000001F)))
-#define BIT_ARB_HW_ADAPT_EN                        ((u32)0x00000001 << 23)          /*!<R/W 0  Enable hardware to arbitrate data according to rate offset of user0 and user1 */
-#define BIT_ARB_SW_EN                              ((u32)0x00000001 << 22)          /*!<R/W 0  Enable software to set initial state of MU arbiter */
-#define BIT_MASK_ARB_SW_STATE                      ((u32)0x0000003F << 16)          /*!<R/W 0x2A  MU arbiter software initial state */
-#define BIT_ARB_SW_STATE(x)                        ((u32)(((x) & 0x0000003F) << 16))
-#define BIT_GET_ARB_SW_STATE(x)                    ((u32)(((x >> 16) & 0x0000003F)))
-#define BIT_MASK_WMAC_PAUSE_BB_CLR_TH              ((u32)0x000000FF << 8)          /*!<R/W 8'h48  MAC_PAUSE_BB High to Low clear threshold of csidma syncff read-write pointer */
-#define BIT_WMAC_PAUSE_BB_CLR_TH(x)                ((u32)(((x) & 0x000000FF) << 8))
-#define BIT_GET_WMAC_PAUSE_BB_CLR_TH(x)            ((u32)(((x >> 8) & 0x000000FF)))
-#define BIT_WMAC_RESP_NONSTA1_DIS                  ((u32)0x00000001 << 7)          /*!<R/W 0  Disable response BA when receive non-STA1 user position MU PPDU */
-#define BIT_MASK_WMAC_MU_BFEE_PORT_SEL             ((u32)0x00000007 << 1)          /*!<R/W 0  Enable software to set initial state of MU arbiter */
-#define BIT_WMAC_MU_BFEE_PORT_SEL(x)               ((u32)(((x) & 0x00000007) << 1))
-#define BIT_GET_WMAC_MU_BFEE_PORT_SEL(x)           ((u32)(((x >> 1) & 0x00000007)))
-#define BIT_WMAC_MU_BFEE_DIS                       ((u32)0x00000001 << 0)          /*!<R/W 0  If set to 1, HW will be SU only beamformee and not response to NDPA or Beamforming report poll. */
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_WMAC_MU_BF_CTL
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_MASK_BFRPT_PARA_USERID_SEL_V1          ((u32)0x00000007 << 29)          /*!<R/W 0  User ID of associated Bfee, MU: 2~7 ,SU:0~1 */
-#define BIT_BFRPT_PARA_USERID_SEL_V1(x)            ((u32)(((x) & 0x00000007) << 29))
-#define BIT_GET_BFRPT_PARA_USERID_SEL_V1(x)        ((u32)(((x >> 29) & 0x00000007)))
-#define BIT_MASK_BFRPT_PARA_V1                     ((u32)0x00001FFF << 16)          /*!<R 0  CSI report parameter of selected user ID BFee {bw[1:0],cb[1:0],ng[1:0],nr[2:0],nc[2:0]} ; */
-#define BIT_BFRPT_PARA_V1(x)                       ((u32)(((x) & 0x00001FFF) << 16))
-#define BIT_GET_BFRPT_PARA_V1(x)                   ((u32)(((x >> 16) & 0x00001FFF)))
-#define BIT_WMAC_INVLD_BFPRT_CHK                   ((u32)0x00000001 << 15)          /*!<R/W 0  Check invalid case of received beamforming report */
-#define BIT_WMAC_RETXBFRPTSEQ_UPD                  ((u32)0x00000001 << 14)          /*!<R/W 0  Update sequence number and not set retry bit when retransmit beamforming report. */
-#define BIT_MASK_WMAC_MU_BFRPTSEG_SEL              ((u32)0x00000003 << 12)          /*!<R/W 0  Beamforming report segment length select 2'h00 :3895 bytes(also means csi segmentation enable),2'h01:7991bytes, 2'h10:11454bytes */
-#define BIT_WMAC_MU_BFRPTSEG_SEL(x)                ((u32)(((x) & 0x00000003) << 12))
-#define BIT_GET_WMAC_MU_BFRPTSEG_SEL(x)            ((u32)(((x >> 12) & 0x00000003)))
-#define BIT_MASK_WMAC_MU_BF_MYAID                  ((u32)0x00000FFF << 0)          /*!<R/W 0  When I'm one of Bfees, my AID12 to identify STA_info in NDPA */
-#define BIT_WMAC_MU_BF_MYAID(x)                    ((u32)(((x) & 0x00000FFF) << 0))
-#define BIT_GET_WMAC_MU_BF_MYAID(x)                ((u32)(((x >> 0) & 0x00000FFF)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_WMAC_ASSOCIATED_MU_BFMEE2
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_STATUS_BFEE3                           ((u32)0x00000001 << 26)          /*!<R 0  beamforming report status of beamformee3 0: fail, 1: success */
-#define BIT_WMAC_MU_BFEE3_EN                       ((u32)0x00000001 << 25)          /*!<R/W 0  If enabled, NDPA/BF-rpt-poll would be sent to beamformee3, and CSI rpt of beamformee3 can be read from 0x1682[11:0] when 0x1682[14:12] is 3 */
-#define BIT_MASK_WMAC_MU_BFEE3_AID                 ((u32)0x000001FF << 16)          /*!<R/W 0  P_AID of the target beamformee3 */
-#define BIT_WMAC_MU_BFEE3_AID(x)                   ((u32)(((x) & 0x000001FF) << 16))
-#define BIT_GET_WMAC_MU_BFEE3_AID(x)               ((u32)(((x >> 16) & 0x000001FF)))
-#define BIT_STATUS_BFEE2                           ((u32)0x00000001 << 10)          /*!<R 0  beamforming report status of beamformee2 0: fail, 1: success */
-#define BIT_WMAC_MU_BFEE2_EN                       ((u32)0x00000001 << 9)          /*!<R/W 0  If enabled, NDPA/BF-rpt-poll would be sent to beamformee2, and CSI rpt of beamformee2 can be read from 0x1682[11:0] when 0x1682[14:12] is 2 */
-#define BIT_MASK_WMAC_MU_BFEE2_AID                 ((u32)0x000001FF << 0)          /*!<R/W 0  P_AID of the target beamformee2 */
-#define BIT_WMAC_MU_BFEE2_AID(x)                   ((u32)(((x) & 0x000001FF) << 0))
-#define BIT_GET_WMAC_MU_BFEE2_AID(x)               ((u32)(((x >> 0) & 0x000001FF)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_WMAC_ASSOCIATED_MU_BFMEE4
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_WMAC_MU_BFEE5_EN                       ((u32)0x00000001 << 25)          /*!<R/W 0  If enabled, NDPA/BF-rpt-poll would be sent to beamformee5, and CSI rpt of beamformee5 can be read from 0x1682[11:0] when 0x1682[14:12] is 5 */
-#define BIT_MASK_WMAC_MU_BFEE5_AID                 ((u32)0x000001FF << 16)          /*!<R/W 0  P_AID of the target beamformee5 */
-#define BIT_WMAC_MU_BFEE5_AID(x)                   ((u32)(((x) & 0x000001FF) << 16))
-#define BIT_GET_WMAC_MU_BFEE5_AID(x)               ((u32)(((x >> 16) & 0x000001FF)))
-#define BIT_WMAC_MU_BFEE4_EN                       ((u32)0x00000001 << 9)          /*!<R/W 0  If enabled, NDPA/BF-rpt-poll would be sent to beamformee4, and CSI rpt of beamformee4 can be read from 0x1682[11:0] when 0x1682[14:12] is 4 */
-#define BIT_MASK_WMAC_MU_BFEE4_AID                 ((u32)0x000001FF << 0)          /*!<R/W 0  P_AID of the target beamformee4 */
-#define BIT_WMAC_MU_BFEE4_AID(x)                   ((u32)(((x) & 0x000001FF) << 0))
-#define BIT_GET_WMAC_MU_BFEE4_AID(x)               ((u32)(((x >> 0) & 0x000001FF)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_WMAC_ASSOCIATED_MU_BFMEE6
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_WMAC_MU_BFEE7_EN                       ((u32)0x00000001 << 25)          /*!<R/W 0  If enabled, NDPA/BF-rpt-poll would be sent to beamformee7, and CSI rpt of beamformee7 can be read from 0x1682[11:0] when 0x1682[14:12] is 7 */
-#define BIT_MASK_WMAC_MU_BFEE7_AID                 ((u32)0x000001FF << 16)          /*!<R/W 0  P_AID of the target beamformee7 */
-#define BIT_WMAC_MU_BFEE7_AID(x)                   ((u32)(((x) & 0x000001FF) << 16))
-#define BIT_GET_WMAC_MU_BFEE7_AID(x)               ((u32)(((x >> 16) & 0x000001FF)))
-#define BIT_WMAC_MU_BFEE6_EN                       ((u32)0x00000001 << 9)          /*!<R/W 0  If enabled, NDPA/BF-rpt-poll would be sent to beamformee6, and CSI rpt of beamformee6 can be read from 0x1682[11:0] when 0x1682[14:12] is 6 */
-#define BIT_MASK_WMAC_MU_BFEE6_AID                 ((u32)0x000001FF << 0)          /*!<R/W 0  P_AID of the target beamformee6 */
-#define BIT_WMAC_MU_BFEE6_AID(x)                   ((u32)(((x) & 0x000001FF) << 0))
-#define BIT_GET_WMAC_MU_BFEE6_AID(x)               ((u32)(((x >> 0) & 0x000001FF)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_WMAC_BB_STOP_RX_COUNTER
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_RST_ALL_COUNTER                        ((u32)0x00000001 << 31)          /*!<W1C 0  Write one to reset all counters to zero. */
-#define BIT_MASK_ABORT_RX_VBON_COUNTER             ((u32)0x000000FF << 16)          /*!<R 0  Increase when mac_abort_rx_vbon trigger. 0x120[29] / 0x124[29] : BB_STOP_RX mask/interrupt 0x0B8[0] / 0x0BC[0] : BB_STOP_RX mask/interrupt Interrupts will be trigger when mac detect any counter of 0x1690 increase. */
-#define BIT_ABORT_RX_VBON_COUNTER(x)               ((u32)(((x) & 0x000000FF) << 16))
-#define BIT_GET_ABORT_RX_VBON_COUNTER(x)           ((u32)(((x >> 16) & 0x000000FF)))
-#define BIT_MASK_ABORT_RX_RDRDY_COUNTER            ((u32)0x000000FF << 8)          /*!<R 0  Increase when mac_abort_rx_rdrdy trigger 0x120[29] / 0x124[29] : BB_STOP_RX mask/interrupt 0x0B8[0] / 0x0BC[0] : BB_STOP_RX mask/interrupt Interrupts will be trigger when mac detect any counter of 0x1690 increase. */
-#define BIT_ABORT_RX_RDRDY_COUNTER(x)              ((u32)(((x) & 0x000000FF) << 8))
-#define BIT_GET_ABORT_RX_RDRDY_COUNTER(x)          ((u32)(((x >> 8) & 0x000000FF)))
-#define BIT_MASK_VBON_EARLY_FALLING_COUNTER        ((u32)0x000000FF << 0)          /*!<R 0  Increase when VBON fall & no rx plcp error & rx_parser is waiting for rdrdy which is expected but not received . 0x120[29] / 0x124[29] : BB_STOP_RX mask/interrupt 0x0B8[0] / 0x0BC[0] : BB_STOP_RX mask/interrupt Interrupts will be trigger when mac detect any counter of 0x1690 increase. */
-#define BIT_VBON_EARLY_FALLING_COUNTER(x)          ((u32)(((x) & 0x000000FF) << 0))
-#define BIT_GET_VBON_EARLY_FALLING_COUNTER(x)      ((u32)(((x >> 0) & 0x000000FF)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_WMAC_PLCP_MONITOR
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_WMAC_PLCP_TRX_SEL                      ((u32)0x00000001 << 31)          /*!<R/W 0  Selection of Tx/Rx plcp header 0:Rx 1:Tx */
-#define BIT_MASK_WMAC_PLCP_RDSIG_SEL               ((u32)0x00000007 << 28)          /*!<R/W 0  Selection of plcp header signal field 0:LSIG/CCK PLCP 1:HTSIG1/VHTSIGA1/HESIGA1 2:HTSIG2/VHTSIGA2/HESIGA2 3:VHTSIGB/HESIGB, low 4bit is dummy 4: HE USER FIELD 5: SERVICE */
-#define BIT_WMAC_PLCP_RDSIG_SEL(x)                 ((u32)(((x) & 0x00000007) << 28))
-#define BIT_GET_WMAC_PLCP_RDSIG_SEL(x)             ((u32)(((x >> 28) & 0x00000007)))
-#define BIT_MASK_WMAC_RATE_IDX                     ((u32)0x0000000F << 24)          /*!<R 0  PPDU type 0:Long PLCP, 1:Short PLCP, 2: Legacy, 3: HT_MF, 4:HT_GF, 5: VHT-SU, 6: VHT-MU, 7: HE-SU, 8: HE-ER_SU, 9: HE_MU, 10: HE_TB, 11~15:RSVD U(4,0) */
-#define BIT_WMAC_RATE_IDX(x)                       ((u32)(((x) & 0x0000000F) << 24))
-#define BIT_GET_WMAC_RATE_IDX(x)                   ((u32)(((x >> 24) & 0x0000000F)))
-#define BIT_MASK_WMAC_PLCP_RDSIG                   ((u32)0x00FFFFFF << 0)          /*!<R 0  Selected signal field to read out */
-#define BIT_WMAC_PLCP_RDSIG(x)                     ((u32)(((x) & 0x00FFFFFF) << 0))
-#define BIT_GET_WMAC_PLCP_RDSIG(x)                 ((u32)(((x >> 0) & 0x00FFFFFF)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_WMAC_CSIDMA_CFG
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_MASK_CSI_SEG_SIZE                      ((u32)0x00000FFF << 16)          /*!<R/W 0xF16  CSI data segmentation size (bytes) = Max. MPDU length - mac hdr (24) - act type (1) - category (1) – mimo ctrl (3) – FCS (4)（default:3862byte） */
-#define BIT_CSI_SEG_SIZE(x)                        ((u32)(((x) & 0x00000FFF) << 16))
-#define BIT_GET_CSI_SEG_SIZE(x)                    ((u32)(((x >> 16) & 0x00000FFF)))
-#define BIT_MASK_CSI_START_PAGE                    ((u32)0x00000FFF << 0)          /*!<R/W 0xf8  The starting page number of csi buffer in TXPKTBUF */
-#define BIT_CSI_START_PAGE(x)                      ((u32)(((x) & 0x00000FFF) << 0))
-#define BIT_GET_CSI_START_PAGE(x)                  ((u32)(((x >> 0) & 0x00000FFF)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_TRANSMIT_ADDRSS_0
- * @brief TA0 Register
- * @{
- *****************************************************************************/
-#define BIT_MASK_TA0_V1                            ((u32)0xFFFFFFFF << 0)          /*!<R/W 0  Transmitter address for port 0 */
-#define BIT_TA0_V1(x)                              ((u32)(((x) & 0xFFFFFFFF) << 0))
-#define BIT_GET_TA0_V1(x)                          ((u32)(((x >> 0) & 0xFFFFFFFF)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_TRANSMIT_ADDRSS_0_H
- * @brief TA0 Register
- * @{
- *****************************************************************************/
-#define BIT_MASK_TA0_H_V1                          ((u32)0x0000FFFF << 0)          /*!<R/W 0  Transmitter address for port 0 */
-#define BIT_TA0_H_V1(x)                            ((u32)(((x) & 0x0000FFFF) << 0))
-#define BIT_GET_TA0_H_V1(x)                        ((u32)(((x >> 0) & 0x0000FFFF)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_TRANSMIT_ADDRSS_1
- * @brief TA1 Register
- * @{
- *****************************************************************************/
-#define BIT_MASK_TA1_V1                            ((u32)0xFFFFFFFF << 0)          /*!<R/W 0  Transmitter address for port 1 */
-#define BIT_TA1_V1(x)                              ((u32)(((x) & 0xFFFFFFFF) << 0))
-#define BIT_GET_TA1_V1(x)                          ((u32)(((x >> 0) & 0xFFFFFFFF)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_TRANSMIT_ADDRSS_1_H
- * @brief TA1 Register
- * @{
- *****************************************************************************/
-#define BIT_MASK_TA1_H_V1                          ((u32)0x0000FFFF << 0)          /*!<R/W 0  Transmitter address for port 1 */
-#define BIT_TA1_H_V1(x)                            ((u32)(((x) & 0x0000FFFF) << 0))
-#define BIT_GET_TA1_H_V1(x)                        ((u32)(((x >> 0) & 0x0000FFFF)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_TRANSMIT_ADDRSS_2
- * @brief TA2 Register
- * @{
- *****************************************************************************/
-#define BIT_MASK_TA2_V1                            ((u32)0xFFFFFFFF << 0)          /*!<R/W 0  Transmitter address for port 2 */
-#define BIT_TA2_V1(x)                              ((u32)(((x) & 0xFFFFFFFF) << 0))
-#define BIT_GET_TA2_V1(x)                          ((u32)(((x >> 0) & 0xFFFFFFFF)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_TRANSMIT_ADDRSS_2_H
- * @brief TA2 Register)
- * @{
- *****************************************************************************/
-#define BIT_MASK_TA2_H_V1                          ((u32)0x0000FFFF << 0)          /*!<R/W 0  Transmitter address for port 2 */
-#define BIT_TA2_H_V1(x)                            ((u32)(((x) & 0x0000FFFF) << 0))
-#define BIT_GET_TA2_H_V1(x)                        ((u32)(((x >> 0) & 0x0000FFFF)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_TRANSMIT_ADDRSS_3
- * @brief TA3 Register
- * @{
- *****************************************************************************/
-#define BIT_MASK_TA3_V1                            ((u32)0xFFFFFFFF << 0)          /*!<R/W 0  Transmitter address for port 3 */
-#define BIT_TA3_V1(x)                              ((u32)(((x) & 0xFFFFFFFF) << 0))
-#define BIT_GET_TA3_V1(x)                          ((u32)(((x >> 0) & 0xFFFFFFFF)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_TRANSMIT_ADDRSS_3_H
- * @brief TA3 Register
- * @{
- *****************************************************************************/
-#define BIT_MASK_TA3_H_V1                          ((u32)0x0000FFFF << 0)          /*!<R/W 0  Transmitter address for port 3 */
-#define BIT_TA3_H_V1(x)                            ((u32)(((x) & 0x0000FFFF) << 0))
-#define BIT_GET_TA3_H_V1(x)                        ((u32)(((x >> 0) & 0x0000FFFF)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_TRANSMIT_ADDRSS_4
- * @brief TA4 Register
- * @{
- *****************************************************************************/
-#define BIT_MASK_TA4_V1                            ((u32)0xFFFFFFFF << 0)          /*!<R/W 0  Transmitter address for port 4 */
-#define BIT_TA4_V1(x)                              ((u32)(((x) & 0xFFFFFFFF) << 0))
-#define BIT_GET_TA4_V1(x)                          ((u32)(((x >> 0) & 0xFFFFFFFF)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_TRANSMIT_ADDRSS_4_H
- * @brief TA4 Register
- * @{
- *****************************************************************************/
-#define BIT_MASK_TA4_H_V1                          ((u32)0x0000FFFF << 0)          /*!<R/W 0  Transmitter address for port 4 */
-#define BIT_TA4_H_V1(x)                            ((u32)(((x) & 0x0000FFFF) << 0))
-#define BIT_GET_TA4_H_V1(x)                        ((u32)(((x >> 0) & 0x0000FFFF)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_NAN_FUN
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_MASK_R_WMAC_ATTRI_ID1                  ((u32)0x000000FF << 24)          /*!<R/W 0  the NAN attribute whose ID is r_WMAC_ATTRI_ID1 will be written into NAN beacon report */
-#define BIT_R_WMAC_ATTRI_ID1(x)                    ((u32)(((x) & 0x000000FF) << 24))
-#define BIT_GET_R_WMAC_ATTRI_ID1(x)                ((u32)(((x >> 24) & 0x000000FF)))
-#define BIT_MASK_R_WMAC_ATTRI_ID0                  ((u32)0x000000FF << 16)          /*!<R/W 0  the NAN attribute whose ID is r_WMAC_ATTRI_ID0 will be written into NAN beacon report */
-#define BIT_R_WMAC_ATTRI_ID0(x)                    ((u32)(((x) & 0x000000FF) << 16))
-#define BIT_GET_R_WMAC_ATTRI_ID0(x)                ((u32)(((x >> 16) & 0x000000FF)))
-#define BIT_MASK_R_WMAC_ATTRI_IDI_VLD              ((u32)0x0000001F << 8)          /*!<R/W 0  valid flag bitmap of r_WMAC_ATTRI_IDi */
-#define BIT_R_WMAC_ATTRI_IDI_VLD(x)                ((u32)(((x) & 0x0000001F) << 8))
-#define BIT_GET_R_WMAC_ATTRI_IDI_VLD(x)            ((u32)(((x >> 8) & 0x0000001F)))
-#define BIT_MASK_R_TXRPT_NAN_ENTRY_NUM             ((u32)0x00000007 << 4)          /*!<R/W 0  number of NAN beacon report entry in txrptbuffer */
-#define BIT_R_TXRPT_NAN_ENTRY_NUM(x)               ((u32)(((x) & 0x00000007) << 4))
-#define BIT_GET_R_TXRPT_NAN_ENTRY_NUM(x)           ((u32)(((x >> 4) & 0x00000007)))
-#define BIT_MASK_R_NAN_ENTRY_SIZE                  ((u32)0x00000007 << 1)          /*!<R/W 0x2  size of one NAN beacon report entry, unit is 8byte */
-#define BIT_R_NAN_ENTRY_SIZE(x)                    ((u32)(((x) & 0x00000007) << 1))
-#define BIT_GET_R_NAN_ENTRY_SIZE(x)                ((u32)(((x >> 1) & 0x00000007)))
-#define BIT_R_WMAC_RXNANPSR_EN                     ((u32)0x00000001 << 0)          /*!<R/W 0  parse enable of rx NAN sync beacon */
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_NAN_CTL
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_MASK_R_TXRPT_NAN_ENTRY_FLAG            ((u32)0x000000FF << 24)          /*!<R 0  indicate NAN beacon report(i) in txrptbuffer is valid, it is set by HW and clear by FW */
-#define BIT_R_TXRPT_NAN_ENTRY_FLAG(x)              ((u32)(((x) & 0x000000FF) << 24))
-#define BIT_GET_R_TXRPT_NAN_ENTRY_FLAG(x)          ((u32)(((x >> 24) & 0x000000FF)))
-#define BIT_MASK_R_WMAC_ATTRI_ID4                  ((u32)0x000000FF << 16)          /*!<R/W 0  the NAN attribute whose ID is r_WMAC_ATTRI_ID4 will be written into NAN beacon report */
-#define BIT_R_WMAC_ATTRI_ID4(x)                    ((u32)(((x) & 0x000000FF) << 16))
-#define BIT_GET_R_WMAC_ATTRI_ID4(x)                ((u32)(((x >> 16) & 0x000000FF)))
-#define BIT_MASK_R_WMAC_ATTRI_ID3                  ((u32)0x000000FF << 8)          /*!<R/W 0  the NAN attribute whose ID is r_WMAC_ATTRI_ID3 will be written into NAN beacon report */
-#define BIT_R_WMAC_ATTRI_ID3(x)                    ((u32)(((x) & 0x000000FF) << 8))
-#define BIT_GET_R_WMAC_ATTRI_ID3(x)                ((u32)(((x >> 8) & 0x000000FF)))
-#define BIT_MASK_R_WMAC_ATTRI_ID2                  ((u32)0x000000FF << 0)          /*!<R/W 0  the NAN attribute whose ID is r_WMAC_ATTRI_ID2 will be written into NAN beacon report */
-#define BIT_R_WMAC_ATTRI_ID2(x)                    ((u32)(((x) & 0x000000FF) << 0))
-#define BIT_GET_R_WMAC_ATTRI_ID2(x)                ((u32)(((x >> 0) & 0x000000FF)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_NAN_ADDR
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_R_RX_NAN_ADDR_FILTER_EN                ((u32)0x00000001 << 13)          /*!<R/W 0  enable of rx nan beacon address filter, can not used in D2 testchip */
-#define BIT_MASK_R_NAN_START_ADDR_OFFSET           ((u32)0x00001FFF << 0)          /*!<R/W 0x152  Start offset Location of NAN beacon report FIFO. Unit: 8bytes */
-#define BIT_R_NAN_START_ADDR_OFFSET(x)             ((u32)(((x) & 0x00001FFF) << 0))
-#define BIT_GET_R_NAN_START_ADDR_OFFSET(x)         ((u32)(((x >> 0) & 0x00001FFF)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_NAN_ADDR_FLITER
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_MASK_R_RX_NAN_ADDR_FILTER              ((u32)0xFFFFFFFF << 0)          /*!<R/W 0  nan address filter */
-#define BIT_R_RX_NAN_ADDR_FILTER(x)                ((u32)(((x) & 0xFFFFFFFF) << 0))
-#define BIT_GET_R_RX_NAN_ADDR_FILTER(x)            ((u32)(((x >> 0) & 0xFFFFFFFF)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_BCN_IEPSR0
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_R_WMAC_BCN_MBSSID_MASK                 ((u32)0x00000001 << 31)          /*!<R/W 0  enable tim no hit don't check whether BC/MC packets are buffered at nontransmitted BSSID */
-#define BIT_R_WMAC_BCN_CLR_N                       ((u32)0x00000001 << 30)          /*!<R/W 0  enable clear macbssid indicator when no multiple BSSID element is found. */
-#define BIT_R_WMAC_BCN_IE1_PSR                     ((u32)0x00000001 << 29)          /*!<R/W 0  enable parser specified ie 1 element */
-#define BIT_R_WMAC_BCN_IE0_PSR                     ((u32)0x00000001 << 28)          /*!<R/W 0  enable parser specified ie0 element */
-#define BIT_R_WMAC_BCN_MBSSID_PSR                  ((u32)0x00000001 << 27)          /*!<R/W 0  enable parser multiple BSSID element */
-#define BIT_R_WMAC_BCN_SW_MBSSID                   ((u32)0x00000001 << 26)          /*!<R/W 0  enable the MaxBSSID indicator value from SW */
-#define BIT_MASK_R_WMAC_BCN_MBSSID_N               ((u32)0x000000FF << 18)          /*!<R/W 0  SW write the value of MaxBSSID Indicator field */
-#define BIT_R_WMAC_BCN_MBSSID_N(x)                 ((u32)(((x) & 0x000000FF) << 18))
-#define BIT_GET_R_WMAC_BCN_MBSSID_N(x)             ((u32)(((x >> 18) & 0x000000FF)))
-#define BIT_R_WMAC_BCN_ID1_EXT                     ((u32)0x00000001 << 17)          /*!<R/W 0  indicate current ie is the extend element which need to parser extend id field */
-#define BIT_MASK_R_WMAC_BCN_IE_ID1                 ((u32)0x000000FF << 9)          /*!<R/W 0  specified Element ID, set corresponding interrupt when it is parsed */
-#define BIT_R_WMAC_BCN_IE_ID1(x)                   ((u32)(((x) & 0x000000FF) << 9))
-#define BIT_GET_R_WMAC_BCN_IE_ID1(x)               ((u32)(((x >> 9) & 0x000000FF)))
-#define BIT_R_WMAC_BCN_ID0_EXT                     ((u32)0x00000001 << 8)          /*!<R/W 0  indicate current ie is the extend element which need to parser extend id field */
-#define BIT_MASK_R_WMAC_BCN_IE_ID0                 ((u32)0x000000FF << 0)          /*!<R/W 0  specified Element ID, set corresponding interrupt when it is parsed */
-#define BIT_R_WMAC_BCN_IE_ID0(x)                   ((u32)(((x) & 0x000000FF) << 0))
-#define BIT_GET_R_WMAC_BCN_IE_ID0(x)               ((u32)(((x >> 0) & 0x000000FF)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_BCN_IEPSR1
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_MASK_R_WMAC_BCN_MBSSID_OFS             ((u32)0x0000FFFF << 16)          /*!<R 0  the multiple bssid element offset (byte unit) in frame body */
-#define BIT_R_WMAC_BCN_MBSSID_OFS(x)               ((u32)(((x) & 0x0000FFFF) << 16))
-#define BIT_GET_R_WMAC_BCN_MBSSID_OFS(x)           ((u32)(((x >> 16) & 0x0000FFFF)))
-#define BIT_R_WMAC_BCN_N0_CHG                      ((u32)0x00000001 << 15)          /*!<R 0  indicate parsed maxmbssid indicator field value has changed which leads to the change of N0. */
-#define BIT_R_WMAC_BCN_MBSSID_VAL                  ((u32)0x00000001 << 14)          /*!<R 0  indicate ofs and n0 change bit is valid. */
-#define BIT_R_WMAC_OPS_PSR_EN                      ((u32)0x00000001 << 10)          /*!<R/W 0  enable parser ops frame tim elemnt and ops element */
-#define BIT_R_WMAC_TIM_TIMPSR_EN                   ((u32)0x00000001 << 9)          /*!<R/W 0  enable parser tim frame tim element */
-#define BIT_R_WMAC_BCN_BMC_MASK                    ((u32)0x00000001 << 8)          /*!<R/W 0  bcn tim hit bc/mc mask */
-#define BIT_MASK_R_WMAC_BCN_MBSSID_IDX             ((u32)0x000000FF << 0)          /*!<R/W 0  the multiple bssid index that current sta connect with */
-#define BIT_R_WMAC_BCN_MBSSID_IDX(x)               ((u32)(((x) & 0x000000FF) << 0))
-#define BIT_GET_R_WMAC_BCN_MBSSID_IDX(x)           ((u32)(((x >> 0) & 0x000000FF)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_CHINFO_ADDR
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_MASK_R_CHINFO_TX_ADDR_L                ((u32)0xFFFFFFFF << 0)          /*!<R/W 0  low 32bit tx address for trigger channel info */
-#define BIT_R_CHINFO_TX_ADDR_L(x)                  ((u32)(((x) & 0xFFFFFFFF) << 0))
-#define BIT_GET_R_CHINFO_TX_ADDR_L(x)              ((u32)(((x >> 0) & 0xFFFFFFFF)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_CHINFO_CFG
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_R_CHINFO_FCS                           ((u32)0x00000001 << 28)          /*!<R/W 0  when set to 1, will not check channel info fcs ok flag */
-#define BIT_R_CHINFO_WTM_OUT                       ((u32)0x00000001 << 27)          /*!<R/W1C 0  BB does’t send channel info when timeout occur */
-#define BIT_R_CHINFO_TIME_OUT                      ((u32)0x00000001 << 26)          /*!<R/W1C 0  BB send channel info length is less than report length */
-#define BIT_R_CSI_BUFF_FULL                        ((u32)0x00000001 << 25)          /*!<R/W1C 0  Indicate rxcsibuff full occur */
-#define BIT_MASK_R_CHINFO_TIMER                    ((u32)0x00000007 << 22)          /*!<R/W 0x4  Wait timeout value after repuest channe info, unit 4 mac clock cycles */
-#define BIT_R_CHINFO_TIMER(x)                      ((u32)(((x) & 0x00000007) << 22))
-#define BIT_GET_R_CHINFO_TIMER(x)                  ((u32)(((x >> 22) & 0x00000007)))
-#define BIT_MASK_R_CHINFO_MODE                     ((u32)0x00000003 << 17)          /*!<R/W 0  channel info mode setting. 0: enable normal rx trigger; 1: enable ndpa trigger; note: repsonse mode decided by tx descriptor. Valid when r_CHINFO_EN is 1. */
-#define BIT_R_CHINFO_MODE(x)                       ((u32)(((x) & 0x00000003) << 17))
-#define BIT_GET_R_CHINFO_MODE(x)                   ((u32)(((x >> 17) & 0x00000003)))
-#define BIT_R_CHINFO_EN                            ((u32)0x00000001 << 16)          /*!<R/W 0  enable for getting channel info from BB. When set to 0, will not trigger channel info function */
-#define BIT_MASK_R_CHINFO_TX_ADDR_H                ((u32)0x0000FFFF << 0)          /*!<R/W 0  high 16bit tx address for trigger channel info */
-#define BIT_R_CHINFO_TX_ADDR_H(x)                  ((u32)(((x) & 0x0000FFFF) << 0))
-#define BIT_GET_R_CHINFO_TX_ADDR_H(x)              ((u32)(((x >> 0) & 0x0000FFFF)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_RXCSIBUF_CFG
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_MASK_R_CHINFO_REQ_SIZE                 ((u32)0x0000003F << 16)          /*!<R/W 0  The channel info trigger request rxcsibuffer size, unit 32bytes, the actually request size = (r_chinfo_req_size + 1) * 32byte */
-#define BIT_R_CHINFO_REQ_SIZE(x)                   ((u32)(((x) & 0x0000003F) << 16))
-#define BIT_GET_R_CHINFO_REQ_SIZE(x)               ((u32)(((x >> 16) & 0x0000003F)))
-#define BIT_MASK_R_CHINFO_WDFS_TIME                ((u32)0x0000000F << 12)          /*!<R/W 0xA  Wait DFS timeout value, unit 4 mac clock cycles */
-#define BIT_R_CHINFO_WDFS_TIME(x)                  ((u32)(((x) & 0x0000000F) << 12))
-#define BIT_GET_R_CHINFO_WDFS_TIME(x)              ((u32)(((x >> 12) & 0x0000000F)))
-#define BIT_MASK_R_CSIBUF_THRESHOD                 ((u32)0x0000000F << 8)          /*!<R/W 0x4  rxcsibuffer full threshold, size must greater than or equal to csi descriptors */
-#define BIT_R_CSIBUF_THRESHOD(x)                   ((u32)(((x) & 0x0000000F) << 8))
-#define BIT_GET_R_CSIBUF_THRESHOD(x)               ((u32)(((x >> 8) & 0x0000000F)))
-#define BIT_MASK_R_CSIBUF_ENDADDR                  ((u32)0x000000FF << 0)          /*!<R/W 0xBF  End address of rxcsibuffer, unit 8bytes. Rxcsibuffer is 1536 bytes */
-#define BIT_R_CSIBUF_ENDADDR(x)                    ((u32)(((x) & 0x000000FF) << 0))
-#define BIT_GET_R_CSIBUF_ENDADDR(x)                ((u32)(((x >> 0) & 0x000000FF)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_BT_ZB_COEX_TB
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_MASK_R_BT_ZB_COEX_TABLE                ((u32)0xFFFFFFFF << 0)          /*!<R/W 0  bt and zigbee coexist table */
-#define BIT_R_BT_ZB_COEX_TABLE(x)                  ((u32)(((x) & 0xFFFFFFFF) << 0))
-#define BIT_GET_R_BT_ZB_COEX_TABLE(x)              ((u32)(((x >> 0) & 0xFFFFFFFF)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_CHINFO_TRIG_TYPE0
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_CTL_TRG_15EN                           ((u32)0x00000001 << 31)          /*!<R/W 0  When set, control frames with type=01 and subtype=1111 will trigger channel info */
-#define BIT_CTL_TRG_14EN                           ((u32)0x00000001 << 30)          /*!<R/W 0  When set, control frames with type=01 and subtype=1110 will trigger channel info */
-#define BIT_CTL_TRG_13EN                           ((u32)0x00000001 << 29)          /*!<R/W 0  When set, control frames with type=01 and subtype=1101 will trigger channel info */
-#define BIT_CTL_TRG_12EN                           ((u32)0x00000001 << 28)          /*!<R/W 0  When set, control frames with type=01 and subtype=1100 will trigger channel info */
-#define BIT_CTL_TRG_11EN                           ((u32)0x00000001 << 27)          /*!<R/W 0  When set, control frames with type=01 and subtype=1011 will trigger channel info */
-#define BIT_CTL_TRG_10EN                           ((u32)0x00000001 << 26)          /*!<R/W 0  When set, control frames with type=01 and subtype=1010 will trigger channel info */
-#define BIT_CTL_TRG_9EN                            ((u32)0x00000001 << 25)          /*!<R/W 0  When set, control frames with type=01 and subtype=1001 will trigger channel info */
-#define BIT_CTL_TRG_8EN                            ((u32)0x00000001 << 24)          /*!<R/W 0  When set, control frames with type=01 and subtype=1000 will trigger channel info */
-#define BIT_CTL_TRG_7EN                            ((u32)0x00000001 << 23)          /*!<R/W 0  When set, control frames with type=01 and subtype=0111 will trigger channel info */
-#define BIT_CTL_TRG_6EN                            ((u32)0x00000001 << 22)          /*!<R/W 0  When set, control frames with type=01 and subtype=0110 will trigger channel info */
-#define BIT_CTL_TRG_5EN                            ((u32)0x00000001 << 21)          /*!<R/W 0  When set, control frames with type=01 and subtype=0101 will trigger channel info */
-#define BIT_CTL_TRG_4EN                            ((u32)0x00000001 << 20)          /*!<R/W 0  When set, control frames with type=01 and subtype=0100 will trigger channel info */
-#define BIT_CTL_TRG_3EN                            ((u32)0x00000001 << 19)          /*!<R/W 0  When set, control frames with type=01 and subtype=0011 will trigger channel info */
-#define BIT_CTL_TRG_2EN                            ((u32)0x00000001 << 18)          /*!<R/W 0  When set, control frames with type=01 and subtype=0010 will trigger channel info */
-#define BIT_CTL_TRG_1EN                            ((u32)0x00000001 << 17)          /*!<R/W 0  When set, control frames with type=01 and subtype=0001 will trigger channel info */
-#define BIT_CTL_TRG_0EN                            ((u32)0x00000001 << 16)          /*!<R/W 0  When set, control frames with type=01 and subtype=0000 will trigger channel info */
-#define BIT_MGT_TRG_15EN                           ((u32)0x00000001 << 15)          /*!<R/W 0  When set, management frames with type=00 and subtype=1111 will trigger channel info */
-#define BIT_MGT_TRG_14EN                           ((u32)0x00000001 << 14)          /*!<R/W 0  When set, management frames with type=00 and subtype=1110 will trigger channel info */
-#define BIT_MGT_TRG_13EN                           ((u32)0x00000001 << 13)          /*!<R/W 0  When set, management frames with type=00 and subtype=1101 will trigger channel info */
-#define BIT_MGT_TRG_12EN                           ((u32)0x00000001 << 12)          /*!<R/W 0  When set, management frames with type=00 and subtype=1100 will trigger channel info */
-#define BIT_MGT_TRG_11EN                           ((u32)0x00000001 << 11)          /*!<R/W 0  When set, management frames with type=00 and subtype=1011 will trigger channel info */
-#define BIT_MGT_TRG_10EN                           ((u32)0x00000001 << 10)          /*!<R/W 0  When set, management frames with type=00 and subtype=1010 will trigger channel info */
-#define BIT_MGT_TRG_9EN                            ((u32)0x00000001 << 9)          /*!<R/W 0  When set, management frames with type=00 and subtype=1001 will trigger channel info */
-#define BIT_MGT_TRG_8EN                            ((u32)0x00000001 << 8)          /*!<R/W 0  When set, management frames with type=00 and subtype=1000 will trigger channel info */
-#define BIT_MGT_TRG_7EN                            ((u32)0x00000001 << 7)          /*!<R/W 0  When set, management frames with type=00 and subtype=0111 will trigger channel info */
-#define BIT_MGT_TRG_6EN                            ((u32)0x00000001 << 6)          /*!<R/W 0  When set, management frames with type=00 and subtype=0110 will trigger channel info */
-#define BIT_MGT_TRG_5EN                            ((u32)0x00000001 << 5)          /*!<R/W 0  When set, management frames with type=00 and subtype=0101 will trigger channel info */
-#define BIT_MGT_TRG_4EN                            ((u32)0x00000001 << 4)          /*!<R/W 0  When set, management frames with type=00 and subtype=0100 will trigger channel info */
-#define BIT_MGT_TRG_3EN                            ((u32)0x00000001 << 3)          /*!<R/W 0  When set, management frames with type=00 and subtype=0011 will trigger channel info */
-#define BIT_MGT_TRG_2EN                            ((u32)0x00000001 << 2)          /*!<R/W 0  When set, management frames with type=00 and subtype=0010 will trigger channel info */
-#define BIT_MGT_TRG_1EN                            ((u32)0x00000001 << 1)          /*!<R/W 0  When set, management frames with type=00 and subtype=0001 will trigger channel info */
-#define BIT_MGT_TRG_0EN                            ((u32)0x00000001 << 0)          /*!<R/W 0  When set, management frames with type=00 and subtype=0000 will trigger channel info */
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_CHINFO_TRIG_TYPE1
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_MASK_R_TXTRIG_STOP_SEL                 ((u32)0x0000001F << 24)          /*!<R/W 0  select tx trigger stop signal for LA dump */
-#define BIT_R_TXTRIG_STOP_SEL(x)                   ((u32)(((x) & 0x0000001F) << 24))
-#define BIT_GET_R_TXTRIG_STOP_SEL(x)               ((u32)(((x >> 24) & 0x0000001F)))
-#define BIT_MASK_R_RXTRIG_STOP_SEL                 ((u32)0x0000001F << 19)          /*!<R/W 0  select rx trigger stop signal for LA dump */
-#define BIT_R_RXTRIG_STOP_SEL(x)                   ((u32)(((x) & 0x0000001F) << 19))
-#define BIT_GET_R_RXTRIG_STOP_SEL(x)               ((u32)(((x >> 19) & 0x0000001F)))
-#define BIT_R_NEW_RX_RST_EN                        ((u32)0x00000001 << 18)          /*!<R/W 0  when set, enable new rx rst macrx when macrx is active */
-#define BIT_MASK_R_RXD_OFFSET_SEL                  ((u32)0x00000003 << 16)          /*!<R/W 0  select 2bytes of rxd to debug port 0: 0~1 bytes; 1: 2~3 bytes; 2: 4~5 bytes; 3: 6~7 bytes; */
-#define BIT_R_RXD_OFFSET_SEL(x)                    ((u32)(((x) & 0x00000003) << 16))
-#define BIT_GET_R_RXD_OFFSET_SEL(x)                ((u32)(((x >> 16) & 0x00000003)))
-#define BIT_DATA_TRG_15EN                          ((u32)0x00000001 << 15)          /*!<R/W 0  When set, data frames with type=10 and subtype=1111 will trigger channel info */
-#define BIT_DATA_TRG_14EN                          ((u32)0x00000001 << 14)          /*!<R/W 0  When set, data frames with type=10 and subtype=1110 will trigger channel info */
-#define BIT_DATA_TRG_13EN                          ((u32)0x00000001 << 13)          /*!<R/W 0  When set, data frames with type=10 and subtype=1101 will trigger channel info */
-#define BIT_DATA_TRG_12EN                          ((u32)0x00000001 << 12)          /*!<R/W 0  When set, data frames with type=10 and subtype=1100 will trigger channel info */
-#define BIT_DATA_TRG_11EN                          ((u32)0x00000001 << 11)          /*!<R/W 0  When set, data frames with type=10 and subtype=1011 will trigger channel info */
-#define BIT_DATA_TRG_10EN                          ((u32)0x00000001 << 10)          /*!<R/W 0  When set, data frames with type=10 and subtype=1010 will trigger channel info */
-#define BIT_DATA_TRG_9EN                           ((u32)0x00000001 << 9)          /*!<R/W 0  When set, data frames with type=10 and subtype=1001 will trigger channel info */
-#define BIT_DATA_TRG_8EN                           ((u32)0x00000001 << 8)          /*!<R/W 0  When set, data frames with type=10 and subtype=1000 will trigger channel info */
-#define BIT_DATA_TRG_7EN                           ((u32)0x00000001 << 7)          /*!<R/W 0  When set, data frames with type=10 and subtype=0111 will trigger channel info */
-#define BIT_DATA_TRG_6EN                           ((u32)0x00000001 << 6)          /*!<R/W 0  When set, data frames with type=10 and subtype=0110 will trigger channel info */
-#define BIT_DATA_TRG_5EN                           ((u32)0x00000001 << 5)          /*!<R/W 0  When set, data frames with type=10 and subtype=0101 will trigger channel info */
-#define BIT_DATA_TRG_4EN                           ((u32)0x00000001 << 4)          /*!<R/W 0  When set, data frames with type=10 and subtype=0100 will trigger channel info */
-#define BIT_DATA_TRG_3EN                           ((u32)0x00000001 << 3)          /*!<R/W 0  When set, data frames with type=10 and subtype=0011 will trigger channel info */
-#define BIT_DATA_TRG_2EN                           ((u32)0x00000001 << 2)          /*!<R/W 0  When set, data frames with type=10 and subtype=0010 will trigger channel info */
-#define BIT_DATA_TRG_1EN                           ((u32)0x00000001 << 1)          /*!<R/W 0  When set, data frames with type=10 and subtype=0001 will trigger channel info */
-#define BIT_DATA_TRG_0EN                           ((u32)0x00000001 << 0)          /*!<R/W 0  When set, data frames with type=10 and subtype=0000 will trigger channel info */
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_DFS_CFG
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_MASK_R_DFS_DROP_CNT                    ((u32)0x000001FF << 23)          /*!<R 0  drop dfs packets number when dfsbuffer is full */
-#define BIT_R_DFS_DROP_CNT(x)                      ((u32)(((x) & 0x000001FF) << 23))
-#define BIT_GET_R_DFS_DROP_CNT(x)                  ((u32)(((x >> 23) & 0x000001FF)))
-#define BIT_DFS_BUFF_FULL                          ((u32)0x00000001 << 18)          /*!<R/W1C 0  dfs buffer is full */
-#define BIT_DFS_EN_INTRPT                          ((u32)0x00000001 << 17)          /*!<R 0  When valid, enable generate dfs interrupt */
-#define BIT_R_DFS_EN_INTRPT                        ((u32)0x00000001 << 16)          /*!<WA0 0  When set to 1, enable generate DFS interrupt, one pulse */
-#define BIT_MASK_R_DFS_PKT_LEN                     ((u32)0x000003FF << 6)          /*!<R 0  dfs packet length need Host to read, 4 bytes unit */
-#define BIT_R_DFS_PKT_LEN(x)                       ((u32)(((x) & 0x000003FF) << 6))
-#define BIT_GET_R_DFS_PKT_LEN(x)                   ((u32)(((x >> 6) & 0x000003FF)))
-#define BIT_R_DFS_RST_DROP_CNT                     ((u32)0x00000001 << 5)          /*!<WA0 0  When set to 1, clear r_dfs_drop_cnt, one pulse */
-#define BIT_R_DFS_READ_MODE                        ((u32)0x00000001 << 1)          /*!<R/W 0  When set to 1,means host read mode for debug */
-#define BIT_R_DFS_STOP                             ((u32)0x00000001 << 0)          /*!<R/W 0  When set to 1, stop to get DFS from BB and clear the DFS buffer */
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_DFS_AGG_TIME
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_MASK_R_TXTRIG_TYPE                     ((u32)0x0000003F << 23)          /*!<R/W 0  mapping to frame control type and subtype filed, for LA trigger select */
-#define BIT_R_TXTRIG_TYPE(x)                       ((u32)(((x) & 0x0000003F) << 23))
-#define BIT_GET_R_TXTRIG_TYPE(x)                   ((u32)(((x >> 23) & 0x0000003F)))
-#define BIT_MASK_R_RXTRIG_TYPE                     ((u32)0x0000003F << 17)          /*!<R/W 0  mapping to frame control type and subtype filed, for LA trigger select */
-#define BIT_R_RXTRIG_TYPE(x)                       ((u32)(((x) & 0x0000003F) << 17))
-#define BIT_GET_R_RXTRIG_TYPE(x)                   ((u32)(((x >> 17) & 0x0000003F)))
-#define BIT_MASK_R_DFS_AGG_TIME                    ((u32)0x000000FF << 9)          /*!<R/W 0  DFS packet aggregation time. When reach the target, will inform host by interrupt, unit ms */
-#define BIT_R_DFS_AGG_TIME(x)                      ((u32)(((x) & 0x000000FF) << 9))
-#define BIT_GET_R_DFS_AGG_TIME(x)                  ((u32)(((x >> 9) & 0x000000FF)))
-#define BIT_MASK_R_DFS_AGG_NUM                     ((u32)0x000001FF << 0)          /*!<R/W 0  aggregation DFS packet number selection. When reach the target, will inform host by interrupt, unit 4bytes */
-#define BIT_R_DFS_AGG_NUM(x)                       ((u32)(((x) & 0x000001FF) << 0))
-#define BIT_GET_R_DFS_AGG_NUM(x)                   ((u32)(((x >> 0) & 0x000001FF)))
-/** @} */
-
-
-/*==========PAGE6 Register Address Definition==========*/
-#define REG_WMAC_CR                                  0x0600
-#define REG_TCR                                      0x0604
-#define REG_RCR                                      0x0608
-#define REG_RXPKT_CTL                                0x060C
-#define REG_MACID                                    0x0610
-#define REG_MACID_H                                  0x0614
-#define REG_BSSID                                    0x0618
-#define REG_BSSID_H                                  0x061C
-#define REG_MAR                                      0x0620
-#define REG_MAR_H                                    0x0624
-#define REG_MBIDCAMCFG_1                             0x0628
-#define REG_MBIDCAM_CFG                              0x062C
-#define REG_WMAC_TCR_CTL                             0x0630
-#define REG_STMP_THSD                                0x0634
-#define REG_USTIME_EDCA                              0x0638
-#define REG_RESP_SIFS_CCK                            0x063C
-#define REG_ACKTO                                    0x0640
-#define REG_NAV_THRSHOLD                             0x0650
-#define REG_BACAMCMD                                 0x0654
-#define REG_BACAM_WD                                 0x0658
-#define REG_BACAM_WD_H                               0x065C
-#define REG_LBK_DLY                                  0x0660
-#define REG_RXERR_RPT                                0x0664
-#define REG_WMAC_TRXPTCL_CTL                         0x0668
-#define REG_WMAC_TRXPTCL_CTL_H                       0x066C
-#define REG_KEYCAMCMD                                0x0670
-#define REG_KEYCAM_WD                                0x0674
-#define REG_CAMREAD                                  0x0678
-#define REG_CAMDBG                                   0x067C
-#define REG_SECCFG                                   0x0680
-#define REG_RXFILTER_CATEGORY_ACTION                 0x0684
-#define REG_RXFLTMAP3                                0x0688
-#define REG_RXFLTMAP5                                0x068C
-#define REG_WOW_NAN_CTRL                             0x0690
-#define REG_LPNAV_CTRL                               0x0694
-#define REG_WKFMCAM_CMD                              0x0698
-#define REG_WKFMCAM_WD                               0x069C
-#define REG_RXFLTMAP0                                0x06A0
-#define REG_RXFLTMAP                                 0x06A4
-#define REG_BCN_PSR_RPT0                             0x06A8
-#define REG_FLC_CTRL                                 0x06AC
-#define REG_RXPKTMON_CTRL                            0x06B0
-#define REG_STATE_MON                                0x06B4
-#define REG_ERROR_EVT_CTL                            0x06B8
-#define REG_SEARCH_MACID                             0x06BC
-#define REG_BT_COEX_TABLE_V1                         0x06C0
-#define REG_BT_COEX_TABLE2_V1                        0x06C4
-#define REG_BT_COEX_BREAK_TABLE                      0x06C8
-#define REG_BT_COEX_TABLE_H_V1                       0x06CC
-#define REG_RXCMD_0                                  0x06D0
-#define REG_RXCMD_1                                  0x06D4
-#define REG_RESP_TXINFO_CFG                          0x06D8
-#define REG_CSI_CTRL                                 0x06DC
-#define REG_P2P_RX_BCN_NOA                           0x06E0
-#define REG_ASSOCIATED_BFMER0_INFO                   0x06E4
-#define REG_SOUNDING_CFG1                            0x06E8
-#define REG_SOUNDING_CFG2                            0x06EC
-#define REG_SOUNDING_CFG3                            0x06F0
-#define REG_SOUNDING_CFG0                            0x06F4
-#define REG_ANTCD_INFO                               0x06F8
-#define REG_CSI_PTR                                  0x06FC
-#define REG_BCN_PSR_RPT2                             0x1600
-#define REG_BCN_PSR_RPT3                             0x1604
-#define REG_BCN_PSR_RPT4                             0x1608
-#define REG_A1_ADDR_MASK                             0x160C
-#define REG_RXPSF_CTRL                               0x1610
-#define REG_RXPSF_TYPE_CTRL                          0x1614
-#define REG_WAIT_PHYSTS_CTL                          0x1618
-#define REG_MACID2                                   0x1620
-#define REG_MACID2_H                                 0x1624
-#define REG_BSSID2                                   0x1628
-#define REG_BSSID2_H                                 0x162C
-#define REG_MACID3                                   0x1630
-#define REG_MACID3_H                                 0x1634
-#define REG_BSSID3                                   0x1638
-#define REG_BSSID3_H                                 0x163C
-#define REG_MACID4                                   0x1640
-#define REG_MACID4_H                                 0x1644
-#define REG_BSSID4                                   0x1648
-#define REG_BSSID4_H                                 0x164C
-#define REG_NOA_REPORT                               0x1650
-#define REG_NOA_REPORT_1                             0x1654
-#define REG_NOA_REPORT_2                             0x1658
-#define REG_NOA_REPORT_3                             0x165C
-#define REG_PWRBIT_SETTING                           0x1660
-#define REG_GENERAL_OPTION                           0x1664
-#define REG_RXAI_CTRL                                0x1668
-#define REG_RX_BCN_TM                                0x166C
-#define REG_CSI_RRSR                                 0x1678
-#define REG_MU_BF_OPTION                             0x167C
-#define REG_WMAC_MU_BF_CTL                           0x1680
-#define REG_WMAC_ASSOCIATED_MU_BFMEE2                0x1684
-#define REG_WMAC_ASSOCIATED_MU_BFMEE4                0x1688
-#define REG_WMAC_ASSOCIATED_MU_BFMEE6                0x168C
-#define REG_WMAC_BB_STOP_RX_COUNTER                  0x1690
-#define REG_WMAC_PLCP_MONITOR                        0x1694
-#define REG_WMAC_CSIDMA_CFG                          0x169C
-#define REG_TRANSMIT_ADDRSS_0                        0x16A0
-#define REG_TRANSMIT_ADDRSS_0_H                      0x16A4
-#define REG_TRANSMIT_ADDRSS_1                        0x16A8
-#define REG_TRANSMIT_ADDRSS_1_H                      0x16AC
-#define REG_TRANSMIT_ADDRSS_2                        0x16B0
-#define REG_TRANSMIT_ADDRSS_2_H                      0x16B4
-#define REG_TRANSMIT_ADDRSS_3                        0x16B8
-#define REG_TRANSMIT_ADDRSS_3_H                      0x16BC
-#define REG_TRANSMIT_ADDRSS_4                        0x16C0
-#define REG_TRANSMIT_ADDRSS_4_H                      0x16C4
-#define REG_NAN_FUN                                  0x16C8
-#define REG_NAN_CTL                                  0x16CC
-#define REG_NAN_ADDR                                 0x16D0
-#define REG_NAN_ADDR_FLITER                          0x16D4
-#define REG_BCN_IEPSR0                               0x16D8
-#define REG_BCN_IEPSR1                               0x16DC
-#define REG_CHINFO_ADDR                              0x16E0
-#define REG_CHINFO_CFG                               0x16E4
-#define REG_RXCSIBUF_CFG                             0x16E8
-#define REG_BT_ZB_COEX_TB                            0x16EC
-#define REG_CHINFO_TRIG_TYPE0                        0x16F0
-#define REG_CHINFO_TRIG_TYPE1                        0x16F4
-#define REG_DFS_CFG                                  0x16F8
-#define REG_DFS_AGG_TIME                             0x16FC
-
-/* AUTO_GEN_END */
-
-/* MANUAL_GEN_START */
-
-//Please add your defination here
-
-/* MANUAL_GEN_END */
-
-#endif
diff --git a/os/board/rtl8720e/src/component/wifi/wifi_fw/amebalite/include/wififw_reg_page7.h b/os/board/rtl8720e/src/component/wifi/wifi_fw/amebalite/include/wififw_reg_page7.h
deleted file mode 100644
index bb5ae910f..000000000
--- a/os/board/rtl8720e/src/component/wifi/wifi_fw/amebalite/include/wififw_reg_page7.h
+++ /dev/null
@@ -1,1037 +0,0 @@
-#ifndef __WIFIFW_REG_PAGE7_H__
-#define __WIFIFW_REG_PAGE7_H__
-
-/* AUTO_GEN_START */
-
-/**************************************************************************//**
- * @defgroup REG_MACID1
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_MASK_MACID1_0                         ((u32)0xFFFFFFFF << 0)          /*!<R/W 0  MAC Identification Number Register for port 1 */
-#define BIT_MACID1_0(x)                           ((u32)(((x) & 0xFFFFFFFF) << 0))
-#define BIT_GET_MACID1_0(x)                       ((u32)(((x >> 0) & 0xFFFFFFFF)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_MACID1_1
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_MASK_MACID1_1                         ((u32)0x0000FFFF << 0)          /*!<R/W 0  MAC Identification Number Register for port 1 */
-#define BIT_MACID1_1(x)                           ((u32)(((x) & 0x0000FFFF) << 0))
-#define BIT_GET_MACID1_1(x)                       ((u32)(((x >> 0) & 0x0000FFFF)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_BSSID1
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_MASK_BSSID1_0                         ((u32)0xFFFFFFFF << 0)          /*!<R/W 0  Basic Station Set Identification for port 1. */
-#define BIT_BSSID1_0(x)                           ((u32)(((x) & 0xFFFFFFFF) << 0))
-#define BIT_GET_BSSID1_0(x)                       ((u32)(((x >> 0) & 0xFFFFFFFF)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_BSSID1_1
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_MASK_BSSID1_1                         ((u32)0x0000FFFF << 0)          /*!<R/W 0  Basic Station Set Identification for port 1. */
-#define BIT_BSSID1_1(x)                           ((u32)(((x) & 0x0000FFFF) << 0))
-#define BIT_GET_BSSID1_1(x)                       ((u32)(((x >> 0) & 0x0000FFFF)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_BCN_PSR_RPT1
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_MASK_DTIM_CNT1                        ((u32)0x000000FF << 24)          /*!<R 0  DTIM count */
-#define BIT_DTIM_CNT1(x)                          ((u32)(((x) & 0x000000FF) << 24))
-#define BIT_GET_DTIM_CNT1(x)                      ((u32)(((x >> 24) & 0x000000FF)))
-#define BIT_MASK_DTIM_PERIOD1                     ((u32)0x000000FF << 16)          /*!<R 0  DTIM Period */
-#define BIT_DTIM_PERIOD1(x)                       ((u32)(((x) & 0x000000FF) << 16))
-#define BIT_GET_DTIM_PERIOD1(x)                   ((u32)(((x >> 16) & 0x000000FF)))
-#define BIT_TIM_HAS_AID                           ((u32)0x00000001 << 15)          /*!<R 0  indicate BC/MC packets are buffered at the AP or transimited BSSID */
-#define BIT_TIM_HAS_MY_BSSID                      ((u32)0x00000001 << 14)          /*!<R 0  indicate BC/MC packets are buffered at nontransmitted BSSID, sw need to check corresponding dtim count field in multiple bssid index field */
-#define BIT_TIM_HAS_MYAID                         ((u32)0x00000001 << 13)          /*!<R 0  my aid in the virtual bitmap is set */
-#define BIT_TIM_VALID                             ((u32)0x00000001 << 12)          /*!<R 0  when set to 1 , indicate tim report valid */
-#define BIT_MASK_PS_AID_1                         ((u32)0x000007FF << 0)          /*!<R/W 0  AID1 for MACID1 */
-#define BIT_PS_AID_1(x)                           ((u32)(((x) & 0x000007FF) << 0))
-#define BIT_GET_PS_AID_1(x)                       ((u32)(((x >> 0) & 0x000007FF)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_ASSOCIATED_BFMEE_SEL
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_BFMEE1_EN                             ((u32)0x00000001 << 25)          /*!<R/W 0  If enabled, NDPA would be sent to beamformee1. */
-#define BIT_MASK_BFMEE1_AID                       ((u32)0x000001FF << 16)          /*!<R/W 0  P_AID of the target beamformee1 */
-#define BIT_BFMEE1_AID(x)                         ((u32)(((x) & 0x000001FF) << 16))
-#define BIT_GET_BFMEE1_AID(x)                     ((u32)(((x >> 16) & 0x000001FF)))
-#define BIT_BFMEE0_EN                             ((u32)0x00000001 << 9)          /*!<R/W 0  If enabled, NDPA would be sent to beamformee0. */
-#define BIT_MASK_BFMEE0_AID                       ((u32)0x000001FF << 0)          /*!<R/W 0  P_AID of the target beamformee0 */
-#define BIT_BFMEE0_AID(x)                         ((u32)(((x) & 0x000001FF) << 0))
-#define BIT_GET_BFMEE0_AID(x)                     ((u32)(((x >> 0) & 0x000001FF)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_SND_PTCL_CTRL
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_MASK_NDP_RX_STANDBY_TIMER             ((u32)0x000000FF << 24)          /*!<R/W 0x42  A timeout value for MAC to leave NDP_Rx_standby_state and go back to normal Rx mode. (unit: 2us) */
-#define BIT_NDP_RX_STANDBY_TIMER(x)               ((u32)(((x) & 0x000000FF) << 24))
-#define BIT_GET_NDP_RX_STANDBY_TIMER(x)           ((u32)(((x >> 24) & 0x000000FF)))
-#define BIT_R_WMAC_CHK_RPTPOLL_A2_DIS             ((u32)0x00000001 << 23)          /*!<R/W 0  1: For any A1-matched BF Rpt Poll, send back VHT-CB 0: If A1-matched BF Rpt Poll's A2 fails to match the previous receiving NDPA's A2, do not send VHT-CB */
-#define BIT_R_WMAC_CHK_UCNDPA_A2_DIS              ((u32)0x00000001 << 22)          /*!<R/W 0  0: If A1-matched NDPA's A2 fails to match 0x6E4 or 0x6EC, use default csi parameter 1: For any receiving A1-matched NDPA, use 0x6F4[11:0] as csi parameter */
-#define BIT_MASK_R_WMAC_HT_CATEGORY               ((u32)0x0000003F << 16)          /*!<R/W 0  csi report offset for ht mode */
-#define BIT_R_WMAC_HT_CATEGORY(x)                 ((u32)(((x) & 0x0000003F) << 16))
-#define BIT_GET_R_WMAC_HT_CATEGORY(x)             ((u32)(((x >> 16) & 0x0000003F)))
-#define BIT_R_WMAC_OFFSET_RPTPOLL_EN              ((u32)0x00000001 << 15)          /*!<R/W 0  1: If previous Tx pkt is BF Rpt Poll or VHT NDP, use vht csi start offset; otherwise ht csi start offset 0: If previous Tx pkt is vht rate, use vht csi start offset; otherwise ht csi start offset */
-#define BIT_R_WMAC_CSI_CHKSUM_DIS                 ((u32)0x00000001 << 14)          /*!<R/W 0  1:Disable check 16bit checksum value of csi report from BB 0:Enable check 16bit checksum value of csi report from BB */
-#define BIT_MASK_R_WMAC_VHT_CATEGORY              ((u32)0x0000003F << 8)          /*!<R/W 0x02  used as csi report offset */
-#define BIT_R_WMAC_VHT_CATEGORY(x)                ((u32)(((x) & 0x0000003F) << 8))
-#define BIT_GET_R_WMAC_VHT_CATEGORY(x)            ((u32)(((x >> 8) & 0x0000003F)))
-#define BIT_R_WMAC_USE_NSTS                       ((u32)0x00000001 << 7)          /*!<R/W 1  1: use Nsts as Nr, 0: use register value as Nr */
-#define BIT_R_DISABLE_CHECK_VHTSIGB_CRC           ((u32)0x00000001 << 6)          /*!<R/W 0  1: disable, 0: enable */
-#define BIT_R_DISABLE_CHECK_VHTSIGA_CRC           ((u32)0x00000001 << 5)          /*!<R/W 0  1: disable, 0: enable */
-#define BIT_R_WMAC_BFPARAM_SEL                    ((u32)0x00000001 << 4)          /*!<R/W 0  1: use beamforming nc/nr/ng parameter from register 0x6F4 0: use beamforming nc/nr/ng parameter from tx report buffer */
-#define BIT_R_WMAC_CSISEQ_SEL                     ((u32)0x00000001 << 3)          /*!<R/W 0  By which the sequence number of CSI frame is controlled 1: non-QoS SEQ number 0: counter */
-#define BIT_R_WMAC_CSI_WITHHTC_EN                 ((u32)0x00000001 << 2)          /*!<R/W 0  Set to 1, CSI frame would carry HTC in MAC header. */
-#define BIT_R_WMAC_HT_NDPA_EN                     ((u32)0x00000001 << 1)          /*!<R/W 0  Set to 1, MAC would inform BB of preparing to receive NDP if the received NDP Announcement MPDU is valid. */
-#define BIT_R_WMAC_VHT_NDPA_EN                    ((u32)0x00000001 << 0)          /*!<R/W 0  Set to 1, MAC would inform BB of preparing to receive NDP if the received NDPA is valid. */
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_BEAMFORM_STATUS
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_WRITE_ENABLE                          ((u32)0x00000001 << 31)          /*!<R 0  Access flag. '0' for read. ‘1’ for write, 0x72C[15:0] must be sett before this bit is set */
-#define BIT_WMAC_CHECK_SOUNDING_SEQ               ((u32)0x00000001 << 30)          /*!<R/W 0  Set to 1,MAC would check sounding sequence number of received CSI report and transmitted NDPA */
-#define BIT_MASK_VHTHT_MIMO_CTRL_FIELD            ((u32)0x00FFFFFF << 1)          /*!<R 0  when 'read': [24:1]: currently received VHT MIMO Control field or [16:1]: currently received HT MIMO Control field */
-#define BIT_VHTHT_MIMO_CTRL_FIELD(x)              ((u32)(((x) & 0x00FFFFFF) << 1))
-#define BIT_GET_VHTHT_MIMO_CTRL_FIELD(x)          ((u32)(((x >> 1) & 0x00FFFFFF)))
-#define BIT_CSI_INTRRUPT_STATUS                   ((u32)0x00000001 << 0)          /*!<R 0  sounding status: '0’: fail; ‘1’: success; */
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_NSARP_CFG
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_NSARP_RESPEN                          ((u32)0x00000001 << 15)          /*!<R/W 0  NAARP parser enable */
-#define BIT_NSARP_PARP                            ((u32)0x00000001 << 9)          /*!<R/W 0  when set to 1, reject ARP */
-#define BIT_NSARP_RIPV6                           ((u32)0x00000001 << 8)          /*!<R/W 0  when set to 1, reject IPV6 */
-#define BIT_MASK_NSARP_MODEN                      ((u32)0x00000003 << 6)          /*!<R/W 0  r_WMAC_NSARP_MODEN[0]: when set to 1, enable arp request; r_WMAC_NSARP_MODEN[1]: when set to 1, enable ipv6 request; */
-#define BIT_NSARP_MODEN(x)                        ((u32)(((x) & 0x00000003) << 6))
-#define BIT_GET_NSARP_MODEN(x)                    ((u32)(((x >> 6) & 0x00000003)))
-#define BIT_MASK_NSARP_RSPFTP                     ((u32)0x00000003 << 4)          /*!<R/W 0  used to select Response_type and TID */
-#define BIT_NSARP_RSPFTP(x)                       ((u32)(((x) & 0x00000003) << 4))
-#define BIT_GET_NSARP_RSPFTP(x)                   ((u32)(((x >> 4) & 0x00000003)))
-#define BIT_MASK_NSARP_RSPSEC                     ((u32)0x0000000F << 0)          /*!<R/W 0  select response packet security type */
-#define BIT_NSARP_RSPSEC(x)                       ((u32)(((x) & 0x0000000F) << 0))
-#define BIT_GET_NSARP_RSPSEC(x)                   ((u32)(((x >> 0) & 0x0000000F)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_ZB_STATISTIC_1
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_MASK_ZB_HI_RX                         ((u32)0x0000FFFF << 16)          /*!<R   for statistic */
-#define BIT_ZB_HI_RX(x)                           ((u32)(((x) & 0x0000FFFF) << 16))
-#define BIT_GET_ZB_HI_RX(x)                       ((u32)(((x >> 16) & 0x0000FFFF)))
-#define BIT_MASK_ZB_HI_TX                         ((u32)0x0000FFFF << 0)          /*!<R    */
-#define BIT_ZB_HI_TX(x)                           ((u32)(((x) & 0x0000FFFF) << 0))
-#define BIT_GET_ZB_HI_TX(x)                       ((u32)(((x >> 0) & 0x0000FFFF)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_ZB_STATISTIC_2
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_MASK_ZB_LO_RX                         ((u32)0x0000FFFF << 16)          /*!<R   for statistic */
-#define BIT_ZB_LO_RX(x)                           ((u32)(((x) & 0x0000FFFF) << 16))
-#define BIT_GET_ZB_LO_RX(x)                       ((u32)(((x >> 16) & 0x0000FFFF)))
-#define BIT_MASK_ZB_LO_TX                         ((u32)0x0000FFFF << 0)          /*!<R    */
-#define BIT_ZB_LO_TX(x)                           ((u32)(((x) & 0x0000FFFF) << 0))
-#define BIT_GET_ZB_LO_TX(x)                       ((u32)(((x >> 0) & 0x0000FFFF)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_BEAMFORMING_INFO_NSARP
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_MASK_UPD_BFMEE_USERID                 ((u32)0x00000007 << 13)          /*!<R/W 0  Select BFMEE User ID */
-#define BIT_UPD_BFMEE_USERID(x)                   ((u32)(((x) & 0x00000007) << 13))
-#define BIT_GET_UPD_BFMEE_USERID(x)               ((u32)(((x >> 13) & 0x00000007)))
-#define BIT_UPD_BFMEE_FBTP                        ((u32)0x00000001 << 12)          /*!<R/W 0  Feedback Type(B11) of VHT MIMO Control field, HT is no used */
-#define BIT_MASK_UPD_BFMEE_BW                     ((u32)0x00000003 << 10)          /*!<R/W 0  Channel Width of VHT MIMO control field (B7-6) and (B4) when HT mode */
-#define BIT_UPD_BFMEE_BW(x)                       ((u32)(((x) & 0x00000003) << 10))
-#define BIT_GET_UPD_BFMEE_BW(x)                   ((u32)(((x >> 10) & 0x00000003)))
-#define BIT_MASK_UPD_BFMEE_CB                     ((u32)0x00000003 << 8)          /*!<R/W 0  Codebook Information of MIMO control field [8] for VHT (B10) and (B10-9) when HT mode */
-#define BIT_UPD_BFMEE_CB(x)                       ((u32)(((x) & 0x00000003) << 8))
-#define BIT_GET_UPD_BFMEE_CB(x)                   ((u32)(((x >> 8) & 0x00000003)))
-#define BIT_MASK_UPD_BFMEE_NG                     ((u32)0x00000003 << 6)          /*!<R/W 0  Grouping of MIMO control field [7:6] for VHT (B9-8) and (B6-5) when HT mode */
-#define BIT_UPD_BFMEE_NG(x)                       ((u32)(((x) & 0x00000003) << 6))
-#define BIT_GET_UPD_BFMEE_NG(x)                   ((u32)(((x >> 6) & 0x00000003)))
-#define BIT_MASK_UPD_BFMEE_NR                     ((u32)0x00000007 << 3)          /*!<R/W 0  Nr Index of MIMO control field [5:3] for VHT (B5-3) ,[4:3] for HT mode (B3-2) */
-#define BIT_UPD_BFMEE_NR(x)                       ((u32)(((x) & 0x00000007) << 3))
-#define BIT_GET_UPD_BFMEE_NR(x)                   ((u32)(((x >> 3) & 0x00000007)))
-#define BIT_MASK_UPD_BFMEE_NC                     ((u32)0x00000007 << 0)          /*!<R/W 0  Nc Index of MIMO control field [2:0] for VHT (B2-0) , [1:0] for HT mode (B1-0) */
-#define BIT_UPD_BFMEE_NC(x)                       ((u32)(((x) & 0x00000007) << 0))
-#define BIT_GET_UPD_BFMEE_NC(x)                   ((u32)(((x >> 0) & 0x00000007)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_IPV6_0
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_MASK_IPV6_MYIPAD_0                    ((u32)0xFFFFFFFF << 0)          /*!<R/W 0   */
-#define BIT_IPV6_MYIPAD_0(x)                      ((u32)(((x) & 0xFFFFFFFF) << 0))
-#define BIT_GET_IPV6_MYIPAD_0(x)                  ((u32)(((x >> 0) & 0xFFFFFFFF)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_IPV6_1
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_MASK_IPV6_MYIPAD_1                    ((u32)0xFFFFFFFF << 0)          /*!<R/W 0   */
-#define BIT_IPV6_MYIPAD_1(x)                      ((u32)(((x) & 0xFFFFFFFF) << 0))
-#define BIT_GET_IPV6_MYIPAD_1(x)                  ((u32)(((x >> 0) & 0xFFFFFFFF)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_IPV6_2
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_MASK_IPV6_MYIPAD_2                    ((u32)0xFFFFFFFF << 0)          /*!<R/W 0   */
-#define BIT_IPV6_MYIPAD_2(x)                      ((u32)(((x) & 0xFFFFFFFF) << 0))
-#define BIT_GET_IPV6_MYIPAD_2(x)                  ((u32)(((x >> 0) & 0xFFFFFFFF)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_IPV6_3
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_MASK_IPV6_MYIPAD_3                    ((u32)0xFFFFFFFF << 0)          /*!<R/W 0   */
-#define BIT_IPV6_MYIPAD_3(x)                      ((u32)(((x) & 0xFFFFFFFF) << 0))
-#define BIT_GET_IPV6_MYIPAD_3(x)                  ((u32)(((x >> 0) & 0xFFFFFFFF)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_ZB_COEX_TABLE_1
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_MASK_ZB_COEX_TABLE_1                  ((u32)0xFFFFFFFF << 0)          /*!<R/W 0  coexistence table between WLAN and Zigbee, selected by BIT_COEX_TABLE_SEL = 0 */
-#define BIT_ZB_COEX_TABLE_1(x)                    ((u32)(((x) & 0xFFFFFFFF) << 0))
-#define BIT_GET_ZB_COEX_TABLE_1(x)                ((u32)(((x >> 0) & 0xFFFFFFFF)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_ZB_COEX_TABLE_2
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_MASK_ZB_COEX_TABLE_2                  ((u32)0xFFFFFFFF << 0)          /*!<R/W 0  coexistence table between WLAN and Zigbee, selected by BIT_COEX_TABLE_SEL = 1 */
-#define BIT_ZB_COEX_TABLE_2(x)                    ((u32)(((x) & 0xFFFFFFFF) << 0))
-#define BIT_GET_ZB_COEX_TABLE_2(x)                ((u32)(((x >> 0) & 0xFFFFFFFF)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_ZB_BREAK_TABLE
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_MASK_ZB_BREAK_TABLE_2                 ((u32)0x0000FFFF << 16)          /*!<R/W 0  Table used to break ZB activity, when new WLAN request is coming and ZB is on transmitting or receiving */
-#define BIT_ZB_BREAK_TABLE_2(x)                   ((u32)(((x) & 0x0000FFFF) << 16))
-#define BIT_GET_ZB_BREAK_TABLE_2(x)               ((u32)(((x >> 16) & 0x0000FFFF)))
-#define BIT_MASK_ZB_BREAK_TABLE_1                 ((u32)0x0000FFFF << 0)          /*!<R/W 0  Table used to break WLAN activity, when new ZB request is coming and WLAN is on transmitting or receiving */
-#define BIT_ZB_BREAK_TABLE_1(x)                   ((u32)(((x) & 0x0000FFFF) << 0))
-#define BIT_GET_ZB_BREAK_TABLE_1(x)               ((u32)(((x >> 0) & 0x0000FFFF)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_EXT_ZB_DETEC_CTRL
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_MASK_ZB_TRX_DETECT_TIME               ((u32)0x000000FF << 24)          /*!<R/W 0x40  Valid if BIT_ZIGBEE_MODE = 1 & BIT_EXT_ZIGBEE_MODE = 0 (external mode, directional PRIORITY) After ZB_PRI_DETECT_TIME duration, if ZB_PRIORITY is low or goes low during ZB_TRX_INIT_DETECT_TIME, Zigbee will receive packets; otherwise, if ZG_PRIORITY is high or goes high, ZB will TX data. Unit 1us. */
-#define BIT_ZB_TRX_DETECT_TIME(x)                 ((u32)(((x) & 0x000000FF) << 24))
-#define BIT_GET_ZB_TRX_DETECT_TIME(x)             ((u32)(((x >> 24) & 0x000000FF)))
-#define BIT_MASK_ZB_PRI_DETECT_TIME               ((u32)0x000000FF << 16)          /*!<R/W 0xC8  Valid if BIT_ZIGBEE_MODE = 1 & BIT_EXT_ZIGBEE_MODE = 0 (external mode, directional PRIORITY) After ZB_REQUEST asserting, if ZG_PRIORITY is asserted within this ZB_PRI_DETECT_TIME duration, ZG will initiate high priority activities; otherwise, if ZB_PRIORITY is not asserted within this duration, it would be low priority activities. Units 1us. (0-255us) */
-#define BIT_ZB_PRI_DETECT_TIME(x)                 ((u32)(((x) & 0x000000FF) << 16))
-#define BIT_GET_ZB_PRI_DETECT_TIME(x)             ((u32)(((x >> 16) & 0x000000FF)))
-#define BIT_MASK_ZB_CNT_THR                       ((u32)0x000000FF << 8)          /*!<R/W 0  ZB count threshold, unit: us */
-#define BIT_ZB_CNT_THR(x)                         ((u32)(((x) & 0x000000FF) << 8))
-#define BIT_GET_ZB_CNT_THR(x)                     ((u32)(((x >> 8) & 0x000000FF)))
-#define BIT_MASK_ZB_ARB_TIME                      ((u32)0x000000FF << 0)          /*!<R/W 0  8 bit timer register : Arbitration window of ZB trx request (unit: us) */
-#define BIT_ZB_ARB_TIME(x)                        ((u32)(((x) & 0x000000FF) << 0))
-#define BIT_GET_ZB_ARB_TIME(x)                    ((u32)(((x >> 0) & 0x000000FF)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_WMAC_RTX_CTX_SUBTYPE
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_MASK_R_WMAC_CTX_SUBTYPE               ((u32)0x0000000F << 4)          /*!<R/W 0x7   */
-#define BIT_R_WMAC_CTX_SUBTYPE(x)                 ((u32)(((x) & 0x0000000F) << 4))
-#define BIT_GET_R_WMAC_CTX_SUBTYPE(x)             ((u32)(((x >> 4) & 0x0000000F)))
-#define BIT_MASK_R_WMAC_RTX_SUBTYPE               ((u32)0x0000000F << 0)          /*!<R/W 0x6   */
-#define BIT_R_WMAC_RTX_SUBTYPE(x)                 ((u32)(((x) & 0x0000000F) << 0))
-#define BIT_GET_R_WMAC_RTX_SUBTYPE(x)             ((u32)(((x >> 0) & 0x0000000F)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_WMAC_RTX_SWAES_RD_1
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_MASK_WMAC_SWAES_RD_0                  ((u32)0xFFFFFFFF << 0)          /*!<R 0   */
-#define BIT_WMAC_SWAES_RD_0(x)                    ((u32)(((x) & 0xFFFFFFFF) << 0))
-#define BIT_GET_WMAC_SWAES_RD_0(x)                ((u32)(((x >> 0) & 0xFFFFFFFF)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_WMAC_RTX_SWAES_RD_2
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_MASK_WMAC_SWAES_RD_1                  ((u32)0xFFFFFFFF << 0)          /*!<R 0   */
-#define BIT_WMAC_SWAES_RD_1(x)                    ((u32)(((x) & 0xFFFFFFFF) << 0))
-#define BIT_GET_WMAC_SWAES_RD_1(x)                ((u32)(((x >> 0) & 0xFFFFFFFF)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_WMAC_RTX_SWAES_RD_3
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_MASK_WMAC_SWAES_RD_2                  ((u32)0xFFFFFFFF << 0)          /*!<R 0   */
-#define BIT_WMAC_SWAES_RD_2(x)                    ((u32)(((x) & 0xFFFFFFFF) << 0))
-#define BIT_GET_WMAC_SWAES_RD_2(x)                ((u32)(((x >> 0) & 0xFFFFFFFF)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_WMAC_SWAES_CFG
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_BTCOEX_SW_RST                         ((u32)0x00000001 << 31)          /*!<R/W 0   */
-#define BIT_GNT_BOTH_POL                          ((u32)0x00000001 << 28)          /*!<R/W 0  grant both choose GNT_BT polarity: 0 : deassert GNT_BT signal as PTA grant both WiFI and BT. 1 : assert GNT_BT signal as PTA grant both WiFi and BT. */
-#define BIT_BT_ARB_INST_EN                        ((u32)0x00000001 << 24)          /*!<R/W 0  1: enable GNT_BT_BYPASS_PRIORITY 0 : disable */
-#define BIT_MASK_BT_ARB_TIME                      ((u32)0x000000FF << 16)          /*!<R/W 0  8 bit timer register : Arbitration window of bt trx request ( in the unit of us) */
-#define BIT_BT_ARB_TIME(x)                        ((u32)(((x) & 0x000000FF) << 16))
-#define BIT_GET_BT_ARB_TIME(x)                    ((u32)(((x >> 16) & 0x000000FF)))
-#define BIT_SWAES_REQ                             ((u32)0x00000001 << 7)          /*!<R 0  software aes engine request polling */
-#define BIT_R_WMAC_SWAES_WE                       ((u32)0x00000001 << 3)          /*!<R/W 0  Write enable of register ro_WMAC_SWAES_RD */
-#define BIT_R_WMAC_SWAES_SEL                      ((u32)0x00000001 << 0)          /*!<R/W 0  When R_WMAC_SWAES_SEL =1,the content of register 0750-075F used to be aes engine data in or data out . When R_WMAC_SWAES_SEL =0, the content of register 0754-075F used to be aes engine security key */
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_BT_COEX_ENH
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_ZIGBEE_EN                             ((u32)0x00000001 << 31)          /*!<R/W 0  Enable ZigBee function */
-#define BIT_ZIGBEE_MODE                           ((u32)0x00000001 << 30)          /*!<R/W 0  0: SOC 1: external */
-#define BIT_EXT_ZIGBEE_MODE                       ((u32)0x00000001 << 29)          /*!<R/W 0  The mode of external ZigBee 1: static PRIORITY 0: directional PRIORITY */
-#define BIT_COEX_TABLE_SEL                        ((u32)0x00000001 << 28)          /*!<R/W 1  Select coexistence table for WLAN & ZB 0: BIT_COEX_TABLE_WL_ZB_1 1: BIT_COEX_TABLE_WL_ZB_2 */
-#define BIT_EXT_ZB_GNT_POLAR                      ((u32)0x00000001 << 27)          /*!<R/W 1  Select the polar of ZB_GRANT, for extarnal ZB 0: low active 1: high active */
-#define BIT_ZB_ARB_INST_EN                        ((u32)0x00000001 << 26)          /*!<R/W 0  1: enable the time limit of ZigBee request (zb_pri | zb_rx | zb_tx), PTA is valid during ( <=BIT_ZB_ARB_TIME) 0: disable Co-work with BIT_ZB_ARB_TIME */
-#define BIT_ZB_CNT_THREN                          ((u32)0x00000001 << 25)          /*!<R/W 0  ZB count threshold enable, for statistics co-work with BIT_ZB_CNT_THR */
-#define BIT_ZB_STATISTIC_EN                       ((u32)0x00000001 << 24)          /*!<R/W 0  enable statistic of ZB */
-#define BIT_GNT_ZB_BB_SW_EN                       ((u32)0x00000001 << 23)          /*!<R/W 0  Enable SW control gnt_zb_bb */
-#define BIT_GNT_ZB_BB_SW                          ((u32)0x00000001 << 22)          /*!<R/W 0  SW value */
-#define BIT_GNT_ZB_RFC_SW_EN                      ((u32)0x00000001 << 21)          /*!<R/W 0  Enable SW control gnt_zb_rfc */
-#define BIT_GNT_ZB_RFC_SW                         ((u32)0x00000001 << 20)          /*!<R/W 0  SW value */
-#define BIT_GNT_ZB_EXT_SW_EN                      ((u32)0x00000001 << 19)          /*!<R/W 0  Enable SW control gnt_zb_o of external ZigBee */
-#define BIT_GNT_ZB_EXT_SW                         ((u32)0x00000001 << 18)          /*!<R/W 0  SW value, external ZigBee */
-#define BIT_EXT_ZB_REQ_POLAR                      ((u32)0x00000001 << 17)          /*!<R/W 1  Select the polar of ZB_REQUEST, for static mode external ZB 0: low active 1: high active */
-#define BIT_DIS_BT_DONT_CARE                      ((u32)0x00000001 << 16)          /*!<R/W 0  1: break table of BT & WL can be all "1" 0: break table of BT & WL cannot be all "1" */
-#define BIT_DIS_ZB_DONT_CARE                      ((u32)0x00000001 << 15)          /*!<R/W 0  1: break table of ZB & WL can be all "1" 0: break table of ZB & WL cannot be all "1" */
-#define BIT_BTG_LNA1_GAIN_SEL                     ((u32)0x00000001 << 14)          /*!<R/W 0  control by Driver 0: mask for WL 1: original BTG */
-#define BIT_R_GNT_BT_RFC_SW                       ((u32)0x00000001 << 12)          /*!<R/W 1  SW control BT RF */
-#define BIT_R_GNT_BT_RFC_SW_EN                    ((u32)0x00000001 << 11)          /*!<R/W 1  SW control BT RF enable */
-#define BIT_R_GNT_BT_BB_SW                        ((u32)0x00000001 << 10)          /*!<R/W 1  SW control BT baseband */
-#define BIT_R_GNT_BT_BB_SW_EN                     ((u32)0x00000001 << 9)          /*!<R/W 1  SW control BT baseband enable */
-#define BIT_R_BT_CNT_THREN                        ((u32)0x00000001 << 8)          /*!<R/W 0  BT count threshold enable */
-#define BIT_MASK_R_BT_CNT_THR                     ((u32)0x000000FF << 0)          /*!<R/W 0  BT count threshold */
-#define BIT_R_BT_CNT_THR(x)                       ((u32)(((x) & 0x000000FF) << 0))
-#define BIT_GET_R_BT_CNT_THR(x)                   ((u32)(((x >> 0) & 0x000000FF)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_WLAN_ACT_MASK_CTRL
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_MASK_RO_PTA_GNT_INFO                  ((u32)0x0000001F << 27)          /*!<R 0  [0]: gnt_wl [1]: gnt_bt_bb [2]: gnt_bt_rfc [3]: gnt_zb_bb [4]: gnt_zb_rfc */
-#define BIT_RO_PTA_GNT_INFO(x)                    ((u32)(((x) & 0x0000001F) << 27))
-#define BIT_GET_RO_PTA_GNT_INFO(x)                ((u32)(((x >> 27) & 0x0000001F)))
-#define BIT_MASK_CYC_PTA_EN_RFC                   ((u32)0x0000001F << 16)          /*!<R/W 0  Enable RFC clock some cycles after gnt_* signals changed. unit: 1 mac_clk */
-#define BIT_CYC_PTA_EN_RFC(x)                     ((u32)(((x) & 0x0000001F) << 16))
-#define BIT_GET_CYC_PTA_EN_RFC(x)                 ((u32)(((x >> 16) & 0x0000001F)))
-#define BIT_MASK_WACTMSK_OFF_DUR                  ((u32)0x000000FF << 8)          /*!<R/W 0  WLAN will reserve channel for BT during MASK OFF duration. Unit 0.625ms */
-#define BIT_WACTMSK_OFF_DUR(x)                    ((u32)(((x) & 0x000000FF) << 8))
-#define BIT_GET_WACTMSK_OFF_DUR(x)                ((u32)(((x >> 8) & 0x000000FF)))
-#define BIT_MASK_WACTMSK_ON_DUR                   ((u32)0x000000FF << 0)          /*!<R/W 0  WLAN can block BT during MASK On duration. Unit 0.625ms */
-#define BIT_WACTMSK_ON_DUR(x)                     ((u32)(((x) & 0x000000FF) << 0))
-#define BIT_GET_WACTMSK_ON_DUR(x)                 ((u32)(((x >> 0) & 0x000000FF)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_WLAN_ACT_MASK_CTRL_1
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_MASK_BT_STAT_DELAY                    ((u32)0x0000000F << 28)          /*!<R/W 0  For CSR, BT_PRI and BT_STAT go high form low at the same time. Thus, BT_STAT need delay BT_STAT_DELAY time to trigger hardware. Unit: 1us */
-#define BIT_BT_STAT_DELAY(x)                      ((u32)(((x) & 0x0000000F) << 28))
-#define BIT_GET_BT_STAT_DELAY(x)                  ((u32)(((x >> 28) & 0x0000000F)))
-#define BIT_MASK_BT_TRX_INIT_DETECT               ((u32)0x0000000F << 24)          /*!<R/W 0  After BT_PRI asserting for BT_TRX_INIT_DETECT us, if BT_STAT is low, then BT will receive packets; otherwise, if BT goes high, BT will TX data. Unit 4us. */
-#define BIT_BT_TRX_INIT_DETECT(x)                 ((u32)(((x) & 0x0000000F) << 24))
-#define BIT_GET_BT_TRX_INIT_DETECT(x)             ((u32)(((x >> 24) & 0x0000000F)))
-#define BIT_MASK_BT_PRI_DETECT_TO                 ((u32)0x0000000F << 20)          /*!<R/W 0  After BT_PRI asserting, if BT_STAT is asserted within this TO duration, BT will initiate high priority activities; otherwise, if BT_STAT is not asserted within this duration, it would be low priority activities. Units 1us. */
-#define BIT_BT_PRI_DETECT_TO(x)                   ((u32)(((x) & 0x0000000F) << 20))
-#define BIT_GET_BT_PRI_DETECT_TO(x)               ((u32)(((x >> 20) & 0x0000000F)))
-#define BIT_R_GRANTALL_WLMASK                     ((u32)0x00000001 << 19)          /*!<R/W 0  grant all mask */
-#define BIT_STATIS_BT_EN                          ((u32)0x00000001 << 18)          /*!<R/W 0  When this bit is set, the BT_ACT_STATISTICS counters starts counting */
-#define BIT_EN_WL_ACT_MASK                        ((u32)0x00000001 << 17)          /*!<R/W 0  Enable WLAN_ACT Mask Function (related to 0x768h-0x76Dh) */
-#define BIT_ENHBT                                 ((u32)0x00000001 << 16)          /*!<R/W 0  Enable Enhanced BT Interface (we suggest to use with BT mode 2) */
-#define BIT_WLRX_TER_BY_CTL_1                     ((u32)0x00000001 << 11)          /*!<R/W 0  When wlan receive a control packet without fit address, whether the signal indicating wlan rx can be terminated as soon as the address check finish is not only controlled by r_WLRX_TER_BY_AD, but also should be refereed to this bit. 1: enable; 0: disable */
-#define BIT_WLRX_TER_BY_AD_1                      ((u32)0x00000001 << 10)          /*!<R/W 0  When wlan receive the packet without fit address, the signal indicating wlan rx can be terminated as soon as the address check finish. This feature can be enabled by this bit. 1: en */
-#define BIT_ANT_DIVERSITY_SEL_1                   ((u32)0x00000001 << 9)          /*!<R/W 0  Antenna diversity for 2 antenna mode: MAC_ANT_SEL = GNT_BT ^ ANT_DIVERDITY_SEL */
-#define BIT_ANTSEL_FOR_BT_CTRL_EN_1               ((u32)0x00000001 << 8)          /*!<R/W 0  Enable the control of antenna selection through GNT_BT: GNT_BT=1: ANT_SEL for BT device; GNT_BT=0: ANT_SEL for WL device. */
-#define BIT_WLACT_LOW_GNTWL_EN_1                  ((u32)0x00000001 << 2)          /*!<R/W 0  When WLACT_LOW_GNTWL_EN = 1, the TRX of WLAN are blocked according to the BTCOEX table arbitration during MASK OFF duration. WLACT_LOW_GNTWL_EN = 0, the TRX of WLAN are paused during MASK OFF duration.. */
-#define BIT_WLACT_HIGH_GNTBT_EN_1                 ((u32)0x00000001 << 1)          /*!<R/W 0  When WLACT_HIGH_GNTBT_EN = 1, the TRX of WLAN are blocked according to the BTCOEX table arbitration during MASK ON duration. When WLACT_HIGH_ GNTBT_EN = 0, the TRX of WLAN are not paused during MASK OFF duration. */
-#define BIT_EN_WLACT_MASK_SYNC                    ((u32)0x00000001 << 0)          /*!<R/W 0  When NAV update is beyond this value, then NAV update is aborted. When this field is 0x00, NAV_UPPER function is disable. The unit is 128us. */
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_BT_ENHANCED_CTRL0
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_MASK_STATIS_BT_31_0                   ((u32)0xFFFFFFFF << 0)          /*!<R 0   */
-#define BIT_STATIS_BT_31_0(x)                     ((u32)(((x) & 0xFFFFFFFF) << 0))
-#define BIT_GET_STATIS_BT_31_0(x)                 ((u32)(((x >> 0) & 0xFFFFFFFF)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_BT_ENHANCED_CTRL1
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_MASK_STATIS_BT_63_32                  ((u32)0xFFFFFFFF << 0)          /*!<R 0   */
-#define BIT_STATIS_BT_63_32(x)                    ((u32)(((x) & 0xFFFFFFFF) << 0))
-#define BIT_GET_STATIS_BT_63_32(x)                ((u32)(((x >> 0) & 0xFFFFFFFF)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_BT_PROPRI
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_MASK_BT_CMD_RPT                       ((u32)0x0000FFFF << 16)          /*!<R 0   */
-#define BIT_BT_CMD_RPT(x)                         ((u32)(((x) & 0x0000FFFF) << 16))
-#define BIT_GET_BT_CMD_RPT(x)                     ((u32)(((x >> 16) & 0x0000FFFF)))
-#define BIT_MASK_RPT_FROM_BT                      ((u32)0x000000FF << 8)          /*!<R 0   */
-#define BIT_RPT_FROM_BT(x)                        ((u32)(((x) & 0x000000FF) << 8))
-#define BIT_GET_RPT_FROM_BT(x)                    ((u32)(((x >> 8) & 0x000000FF)))
-#define BIT_MASK_BT_HID_ISR_SET                   ((u32)0x00000003 << 6)          /*!<R/W 0  When EN_BT_PROFILE_OR_HID is set „1‟, hardware also need to check this value to trigger an interrupt. 0: default, TX and RX 1: TX 2: RX 3: Reserved */
-#define BIT_BT_HID_ISR_SET(x)                     ((u32)(((x) & 0x00000003) << 6))
-#define BIT_GET_BT_HID_ISR_SET(x)                 ((u32)(((x >> 6) & 0x00000003)))
-#define BIT_TDMA_BT_START_NOTIFY                  ((u32)0x00000001 << 5)          /*!<R/W 0  When the control of TDMA mode is firmware and firmware also receive signal that NULL packet for BT had sent, firmware can fill this bit to notify HW PTA to pull WLAN_ACT to low and the interval is Tbt */
-#define BIT_ENABLE_TDMA_HW_MODE                   ((u32)0x00000001 << 4)          /*!<R/W 0  0: default, PTA TDMA mode is hardware mode. 1: enable firmware mode. */
-#define BIT_ENABLE_PTA_TDMA_MODE                  ((u32)0x00000001 << 3)          /*!<R/W 0  0: default, disable PTA TDMA mode 1: enable TDMA mode: a. WLAN_ACT default is high. b. Hardware mode: When NULL packet for BT had sent, hardware will notify PTA to start TDMA mode. Firmware mode: When NULL packet for BT had sent, hardware will trigger an interrupt to notify firmware. Then, firmware need to set TDMA_BT_START_NOTIFY to notify PTA to start TDMA mode. */
-#define BIT_ENABLE_COEXIST_TAB_IN_TDMA            ((u32)0x00000001 << 2)          /*!<R/W 0  0: default, no matter which WLAN_ACT is high or low, PTA doesn't execute co-exist table scheme 1: enable, When WLAN_ACT is high, PTA execute xo-exist table scheme */
-#define BIT_GPIO2_GPIO3_EXANGE_OR_NO_BT_CCA       ((u32)0x00000001 << 1)          /*!<R/W 0  Enable GPIO2 and GPIO3 exchange. (Note: need to enable mode2 and enhance 3 wire) If Enable RTK BT mode, set this bit to 1 to disable granting to BT device when arbitration */
-#define BIT_RTK_BT_ENABLE                         ((u32)0x00000001 << 0)          /*!<R/W 0  Enable RTK BT mode */
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_BT_Status_Report_Register
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_MASK_BT_PROFILE                       ((u32)0x000000FF << 24)          /*!<R 0  When WLAN received CMD_ID 0x3, it will recorder to this. */
-#define BIT_BT_PROFILE(x)                         ((u32)(((x) & 0x000000FF) << 24))
-#define BIT_GET_BT_PROFILE(x)                     ((u32)(((x >> 24) & 0x000000FF)))
-#define BIT_MASK_BT_POWER                         ((u32)0x000000FF << 16)          /*!<R 0  When WLAN received CMD_ID 0x2, it will recorder to this */
-#define BIT_BT_POWER(x)                           ((u32)(((x) & 0x000000FF) << 16))
-#define BIT_GET_BT_POWER(x)                       ((u32)(((x >> 16) & 0x000000FF)))
-#define BIT_MASK_BT_PREDECT_STATUS                ((u32)0x000000FF << 8)          /*!<R 0  When WLAN received CMD_ID 0x0, it will recorder to this */
-#define BIT_BT_PREDECT_STATUS(x)                  ((u32)(((x) & 0x000000FF) << 8))
-#define BIT_GET_BT_PREDECT_STATUS(x)              ((u32)(((x >> 8) & 0x000000FF)))
-#define BIT_MASK_BT_CMD_ID                        ((u32)0x000000FF << 0)          /*!<R 0  command information from BT */
-#define BIT_BT_CMD_ID(x)                          ((u32)(((x) & 0x000000FF) << 0))
-#define BIT_GET_BT_CMD_ID(x)                      ((u32)(((x >> 0) & 0x000000FF)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_BT_Interrupt_Control_Register
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_WLAN_RPT_NOTIFY                       ((u32)0x00000001 << 31)          /*!<R/W 0  When firmware had prepared packet to send to BT, it need to set this bit to notify hardware that it can transmit. 0: There isn't a valid packet in register” WLAN_RPT_ PKT”. 1: There is a valid packet in register” WLAN_RPT_ PKT”. */
-#define BIT_EN_WLAN_RPT_AND_BT_QUERY              ((u32)0x00000001 << 30)          /*!<R/W 0  Enable two interrupt: 1) PTA sent the report packet successfully 2) PTA sent a query packet 0: Disable 1: Enable */
-#define BIT_EN_MAC_NULL_PKT_NOTIFY                ((u32)0x00000001 << 29)          /*!<R/W 0  When MAC had sent NULL packet for BT and firmware also set nav_for_bt bit, hardware triggers an interrupt to notify firmware. 0: Disable 1: Enable */
-#define BIT_EN_BT_STSTUS_RPT                      ((u32)0x00000001 << 28)          /*!<R/W 0  When WLAN receive cmd_id “0”, hardware trigger an interrupt to notify firmware. 0: Disable 1: Enable */
-#define BIT_EN_BT_POWER                           ((u32)0x00000001 << 27)          /*!<R/W 0  When WLAN received the packet including BT Power and check register “BT_STATUS_RPT”, if data contents aren't the same, hardware can trigger an interrupt to notify firmware. 0: Disable 1: Enable */
-#define BIT_EN_BT_CHANNEL                         ((u32)0x00000001 << 26)          /*!<R/W 0  When WLAN received the packet including BT channel number, hardware can trigger an interrupt to notify firmware. 0: Disable 1: Enable */
-#define BIT_EN_BT_SLOT_CHANGE                     ((u32)0x00000001 << 25)          /*!<R/W 0  When WLAN received the packet including that BT had multi-slots, hardware can trigger an interrupt to notify firmware. 0: Disable 1: Enable */
-#define BIT_EN_BT_PROFILE_OR_HID                  ((u32)0x00000001 << 24)          /*!<R/W 0  Enable two interrupt 1) When WLAN received the packet including that WLAN specific profile and check register “BT_STATUS_RPT”, if data contents aren't the same, hardware can trigger an interrupt to notify firmware. 2) When WLAN received the report packet including HID information, hardware will trigger an interrupt to notify firmware. 0: Disable 1: Enable */
-#define BIT_MASK_WLAN_RPT_DATA                    ((u32)0x000000FF << 16)          /*!<R/W 0  Data contents, When the report packet had sent, hardware will clear this register. */
-#define BIT_WLAN_RPT_DATA(x)                      ((u32)(((x) & 0x000000FF) << 16))
-#define BIT_GET_WLAN_RPT_DATA(x)                  ((u32)(((x >> 16) & 0x000000FF)))
-#define BIT_MASK_TO_BT_CMDID                      ((u32)0x000000FF << 8)          /*!<R/W 0  Command id: 0x80~FF */
-#define BIT_TO_BT_CMDID(x)                        ((u32)(((x) & 0x000000FF) << 8))
-#define BIT_GET_TO_BT_CMDID(x)                    ((u32)(((x >> 8) & 0x000000FF)))
-#define BIT_MASK_BT_DATA                          ((u32)0x000000FF << 0)          /*!<R 0  When WLAN received the packet BT sent, hardware will place data to this register in addition to CMD_ID 0x0 ~ 0x3. */
-#define BIT_BT_DATA(x)                            ((u32)(((x) & 0x000000FF) << 0))
-#define BIT_GET_BT_DATA(x)                        ((u32)(((x >> 0) & 0x000000FF)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_WLAN_Report_Time_Out_Control_Register
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_MASK_ISOLATION_CHK_0                  ((u32)0x007FFFFF << 9)          /*!<R/W 0  0: leave PTA 1: enter PTA */
-#define BIT_ISOLATION_CHK_0(x)                    ((u32)(((x) & 0x007FFFFF) << 9))
-#define BIT_GET_ISOLATION_CHK_0(x)                ((u32)(((x >> 9) & 0x007FFFFF)))
-#define BIT_ISOLATION_EN                          ((u32)0x00000001 << 8)          /*!<R/W 0  Isolation table enable bit. 0: disable 1: enable */
-#define BIT_MASK_WLAN_RPT_TO                      ((u32)0x000000FF << 0)          /*!<R/W 0  When WLANＨW received query packet, HW timer counts. If timer equals to WLAN_RPT_TO and HW can‟t send packet, it will give up query packet at this time. When BT sent another query packet, WLAN HW need to send the previous packet and it shouldn't trigger an interrupt to firmware. Unit: 4us. */
-#define BIT_WLAN_RPT_TO(x)                        ((u32)(((x) & 0x000000FF) << 0))
-#define BIT_GET_WLAN_RPT_TO(x)                    ((u32)(((x >> 0) & 0x000000FF)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_BT_Isolation_Table_Register_Register_1
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_MASK_ISOLATION_CHK_1                  ((u32)0xFFFFFFFF << 0)          /*!<R/W 0  0: leave PTA 1: enter PTA */
-#define BIT_ISOLATION_CHK_1(x)                    ((u32)(((x) & 0xFFFFFFFF) << 0))
-#define BIT_GET_ISOLATION_CHK_1(x)                ((u32)(((x >> 0) & 0xFFFFFFFF)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_BT_Interrupt_Status_Register
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_BT_HID_ISR                            ((u32)0x00000001 << 31)          /*!<R/W1C 0  When WLAN received the report packet including HID information, hardware will trigger an interrupt to notify firmware */
-#define BIT_BT_QUERY_ISR                          ((u32)0x00000001 << 30)          /*!<R/W1C 0  When WLAN received a query packet, hardware triggers an interrupt to notify firmware */
-#define BIT_MAC_NULL_PKT_NOTIFY_ISR               ((u32)0x00000001 << 29)          /*!<R/W1C 0  When MAC had sent NULL packet for BT and firmware also set nav_for_bt bit, hardware triggers an interrupt to notify firmware */
-#define BIT_WLAN_RPT_ISR                          ((u32)0x00000001 << 28)          /*!<R/W1C 0  When PTA sent the report packet successfully, hardware triggers an interrupt to notify firmware. */
-#define BIT_BT_POWER_ISR                          ((u32)0x00000001 << 27)          /*!<R/W1C 0  When WLAN received the packet including BT Power and check register “BT_STATUS_RPT”, if data contents aren't the same, hardware can trigger an interrupt to notify firmware */
-#define BIT_BT_CHANNEL_ISR                        ((u32)0x00000001 << 26)          /*!<R/W1C 0  When WLAN received the packet including BT channel number, hardware can trigger an interrupt to notify firmware. */
-#define BIT_BT_SLOT_CHANGE_ISR                    ((u32)0x00000001 << 25)          /*!<R/W1C 0  When WLAN received the packet including that BT had multi-slots, hardware can trigger an interrupt to notify firmware */
-#define BIT_BT_PROFILE_ISR                        ((u32)0x00000001 << 24)          /*!<R/W1C 0  When WLAN received the packet including that WLAN specific profile and check register “BT_STATUS_RPT”, if data contents aren't the same, hardware can trigger an interrupt to notify firmware. */
-#define BIT_MASK_ISOLATION_CHK_2                  ((u32)0x00FFFFFF << 0)          /*!<R/W 0  0: leave PTA 1: enter PTA */
-#define BIT_ISOLATION_CHK_2(x)                    ((u32)(((x) & 0x00FFFFFF) << 0))
-#define BIT_GET_ISOLATION_CHK_2(x)                ((u32)(((x >> 0) & 0x00FFFFFF)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_BT_TDMA_Time_Register
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_MASK_BT_TIME                          ((u32)0x03FFFFFF << 6)          /*!<R/W 0  The time is that WLAN_ACT is low. Unit: us */
-#define BIT_BT_TIME(x)                            ((u32)(((x) & 0x03FFFFFF) << 6))
-#define BIT_GET_BT_TIME(x)                        ((u32)(((x >> 6) & 0x03FFFFFF)))
-#define BIT_MASK_BT_RPT_SAMPLE_RATE               ((u32)0x0000003F << 0)          /*!<R/W 0  When wifi detected the raising edge of BT report packet, wifi need to counter BT_RPT_SAMPLE_RATE. Then hw could detect which is high or low. Uint: 20 ns */
-#define BIT_BT_RPT_SAMPLE_RATE(x)                 ((u32)(((x) & 0x0000003F) << 0))
-#define BIT_GET_BT_RPT_SAMPLE_RATE(x)             ((u32)(((x >> 0) & 0x0000003F)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_BT_ACT_Register
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_B_AX_BT_BLE_EN                        ((u32)0x00000001 << 24)          /*!<R/W 0  Decide the GNT_BT_TX / RX 0: GNT_BT_TX = GNT_BT & BT_TX ; GNT_BT_RX = GNT_BT & BT_RX 1: GNT_BT_TX = GNT_BT & (BT_TX | BT_BLE) ; GNT_BT_RX = GNT_BT & (BT_RX | BT_BLE) */
-#define BIT_MASK_BT_EISR_EN                       ((u32)0x000000FF << 16)          /*!<R/W 0  BT eisr enable */
-#define BIT_BT_EISR_EN(x)                         ((u32)(((x) & 0x000000FF) << 16))
-#define BIT_GET_BT_EISR_EN(x)                     ((u32)(((x >> 16) & 0x000000FF)))
-#define BIT_BT_ACT_FALLING_ISR                    ((u32)0x00000001 << 10)          /*!<R/W1C 0  When BT_ACT signal is falling edge, it will trigger an interrupt. */
-#define BIT_BT_ACT_RISING_ISR                     ((u32)0x00000001 << 9)          /*!<R/W1C 0  When BT_ACT signal is raising edge, it will trigger an interrupt */
-#define BIT_TDMA_TO_ISR                           ((u32)0x00000001 << 8)          /*!<R/W1C 0  When BT_TIME expired, it will trigger an interrupt. */
-#define BIT_MASK_BT_CH                            ((u32)0x0000007F << 0)          /*!<R 0x7f  When hardware receive cm_id “1”, it will recorder to this. */
-#define BIT_BT_CH(x)                              ((u32)(((x) & 0x0000007F) << 0))
-#define BIT_GET_BT_CH(x)                          ((u32)(((x >> 0) & 0x0000007F)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_LTR_IDLE_LATENCY_V2
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_MASK_LTR_IDLE_LATENCY                 ((u32)0x00000003 << 30)          /*!<R/W 0  LTR idle latency. */
-#define BIT_LTR_IDLE_LATENCY(x)                   ((u32)(((x) & 0x00000003) << 30))
-#define BIT_GET_LTR_IDLE_LATENCY(x)               ((u32)(((x >> 30) & 0x00000003)))
-#define BIT_MASK_OBFF_STATE                       ((u32)0x00000003 << 28)          /*!<R 0   */
-#define BIT_OBFF_STATE(x)                         ((u32)(((x) & 0x00000003) << 28))
-#define BIT_GET_OBFF_STATE(x)                     ((u32)(((x >> 28) & 0x00000003)))
-#define BIT_MASK_OBFF_CTRL_1                      ((u32)0x00FFFFFF << 4)          /*!<R/W 0x444440   */
-#define BIT_OBFF_CTRL_1(x)                        ((u32)(((x) & 0x00FFFFFF) << 4))
-#define BIT_GET_OBFF_CTRL_1(x)                    ((u32)(((x >> 4) & 0x00FFFFFF)))
-#define BIT_MASK_OBFF_CTRL_0                      ((u32)0x0000000F << 0)          /*!<R 0   */
-#define BIT_OBFF_CTRL_0(x)                        ((u32)(((x) & 0x0000000F) << 0))
-#define BIT_GET_OBFF_CTRL_0(x)                    ((u32)(((x >> 0) & 0x0000000F)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_LTR_ACTIVE_LATENCY_V2
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_MASK_LTR_ACTIVE_LATENCY               ((u32)0xFFFFFFFF << 0)          /*!<R/W 0x02030405  LTR Active latency. */
-#define BIT_LTR_ACTIVE_LATENCY(x)                 ((u32)(((x) & 0xFFFFFFFF) << 0))
-#define BIT_GET_LTR_ACTIVE_LATENCY(x)             ((u32)(((x >> 0) & 0xFFFFFFFF)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_OBFF_CTRL
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_MASK_LTR_CTRL                         ((u32)0x000000FF << 24)          /*!<R/W 0x4a   */
-#define BIT_LTR_CTRL(x)                           ((u32)(((x) & 0x000000FF) << 24))
-#define BIT_GET_LTR_CTRL(x)                       ((u32)(((x >> 24) & 0x000000FF)))
-#define BIT_LTR_IDLE_FLAG                         ((u32)0x00000001 << 23)          /*!<R 0   */
-#define BIT_LTR_ACT_FLAG                          ((u32)0x00000001 << 22)          /*!<R 0   */
-#define BIT_MASK_OBFF_CTRL                        ((u32)0x003FFFFF << 0)          /*!<R/W 0x4010   */
-#define BIT_OBFF_CTRL(x)                          ((u32)(((x) & 0x003FFFFF) << 0))
-#define BIT_GET_OBFF_CTRL(x)                      ((u32)(((x >> 0) & 0x003FFFFF)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_LTR_CTRL
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_RX_VENDOR_ADV_EN                      ((u32)0x00000001 << 25)          /*!<R/W 1  when set, rx vendor adv function is true */
-#define BIT_TX_VENDOR_ADV_EN                      ((u32)0x00000001 << 24)          /*!<R/W 1  when set, tx vendor adv function is true */
-#define BIT_MASK_WMAC_OPT_SIG2                    ((u32)0x000000FF << 16)          /*!<R/W 8'hec  For rx ofdm ppdu lsig signal filed check when rx vendor adv is true */
-#define BIT_WMAC_OPT_SIG2(x)                      ((u32)(((x) & 0x000000FF) << 16))
-#define BIT_GET_WMAC_OPT_SIG2(x)                  ((u32)(((x >> 16) & 0x000000FF)))
-#define BIT_MASK_WMAC_OPT_SIG1                    ((u32)0x000000FF << 8)          /*!<R/W 8'hec  For rx ofdm ppdu lsig signal filed check when rx vendor adv is true */
-#define BIT_WMAC_OPT_SIG1(x)                      ((u32)(((x) & 0x000000FF) << 8))
-#define BIT_GET_WMAC_OPT_SIG1(x)                  ((u32)(((x >> 8) & 0x000000FF)))
-#define BIT_MASK_WMAC_INI_SIG                     ((u32)0x000000FF << 0)          /*!<R/W 8'hec  For rx ofdm ppdu lsig signal filed check when rx vendor adv is true */
-#define BIT_WMAC_INI_SIG(x)                       ((u32)(((x) & 0x000000FF) << 0))
-#define BIT_GET_WMAC_INI_SIG(x)                   ((u32)(((x >> 0) & 0x000000FF)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_LTR_CTRL2
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_MASK_OBFF_TIMER_ID_HIGH               ((u32)0x00000007 << 29)          /*!<R/W 3'b100  When media rate rx packet in , delay rx dma timeout value index. 0: no delay,1: 12.8us; 2: 102.4us; 3: 204.8us; 4: 819.2 us; 5: 1.638ms; 6: 52ms; 7: always block until obff or cpu active window */
-#define BIT_OBFF_TIMER_ID_HIGH(x)                 ((u32)(((x) & 0x00000007) << 29))
-#define BIT_GET_OBFF_TIMER_ID_HIGH(x)             ((u32)(((x >> 29) & 0x00000007)))
-#define BIT_MASK_HIGH_RATE_BDRY                   ((u32)0x0000007F << 16)          /*!<R/W 7'b1100000  High, media, low rate boundary */
-#define BIT_HIGH_RATE_BDRY(x)                     ((u32)(((x) & 0x0000007F) << 16))
-#define BIT_GET_HIGH_RATE_BDRY(x)                 ((u32)(((x >> 16) & 0x0000007F)))
-#define BIT_MASK_LOW_RATE_BDRY                    ((u32)0x0000007F << 9)          /*!<R/W 7'b1000100  High, media, low rate boundary */
-#define BIT_LOW_RATE_BDRY(x)                      ((u32)(((x) & 0x0000007F) << 9))
-#define BIT_GET_LOW_RATE_BDRY(x)                  ((u32)(((x >> 9) & 0x0000007F)))
-#define BIT_MASK_HIGH_RATE_TRIGS                  ((u32)0x00000003 << 7)          /*!<R/W 2'b01  High rate rx ltr trigger point select: 0 plcp ready;1: rx a1 latch OK; 2: fcs ready. */
-#define BIT_HIGH_RATE_TRIGS(x)                    ((u32)(((x) & 0x00000003) << 7))
-#define BIT_GET_HIGH_RATE_TRIGS(x)                ((u32)(((x >> 7) & 0x00000003)))
-#define BIT_MASK_MEDIA_RATE_TRIGS                 ((u32)0x00000003 << 5)          /*!<R/W 2'b11  Media rate rx ltr trigger point select: 0 plcp ready;1: rx a1 latch OK; 2: fcs ready. */
-#define BIT_MEDIA_RATE_TRIGS(x)                   ((u32)(((x) & 0x00000003) << 5))
-#define BIT_GET_MEDIA_RATE_TRIGS(x)               ((u32)(((x >> 5) & 0x00000003)))
-#define BIT_MASK_LOW_RATE_TRIGS                   ((u32)0x00000003 << 3)          /*!<R/W 2'b00  Low rate rx ltr trigger point select: 0 plcp ready;1: rx a1 latch OK; 2: fcs ready. */
-#define BIT_LOW_RATE_TRIGS(x)                     ((u32)(((x) & 0x00000003) << 3))
-#define BIT_GET_LOW_RATE_TRIGS(x)                 ((u32)(((x >> 3) & 0x00000003)))
-#define BIT_MASK_RX_EXHAUST_ID                    ((u32)0x00000007 << 0)          /*!<R/W 3'b000  When rx page less than this threshold, release obff block rx. */
-#define BIT_RX_EXHAUST_ID(x)                      ((u32)(((x) & 0x00000007) << 0))
-#define BIT_GET_RX_EXHAUST_ID(x)                  ((u32)(((x >> 0) & 0x00000007)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_ANTTRN_CTR_V1
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_MASK_TRAIN_STA_ADDR1                  ((u32)0xFFFFFFFF << 0)          /*!<R/W 0  The Address of the trained station. Only available when ADDR2_MATCH_EN = 1 */
-#define BIT_TRAIN_STA_ADDR1(x)                    ((u32)(((x) & 0xFFFFFFFF) << 0))
-#define BIT_GET_TRAIN_STA_ADDR1(x)                ((u32)(((x >> 0) & 0xFFFFFFFF)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_ANTTRN_CTR_1_V1
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_ANTTRN_SWITCH                         ((u32)0x00000001 << 19)          /*!<R/W 0  Smart antenna use address cam or port register to search A2. 0:Use address cam 1:Use port register */
-#define BIT_APPEND_MACID_IN_RESP_EN               ((u32)0x00000001 << 18)          /*!<R/W 0  Whether to append MACID in the rx descriptor of rx response packet */
-#define BIT_ADDR2_MATCH_EN                        ((u32)0x00000001 << 17)          /*!<R/W 0  Enable the comparison of ADDR2 for the rx packet.. */
-#define BIT_ANTTRN_EN                             ((u32)0x00000001 << 16)          /*!<R/W 0  Enable the antenna training function */
-#define BIT_MASK_TRAIN_STA_ADDR2                  ((u32)0x0000FFFF << 0)          /*!<R/W 0  The Address of the trained station. Only available when ADDR2_MATCH_EN = 1 */
-#define BIT_TRAIN_STA_ADDR2(x)                    ((u32)(((x) & 0x0000FFFF) << 0))
-#define BIT_GET_TRAIN_STA_ADDR2(x)                ((u32)(((x >> 0) & 0x0000FFFF)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_WMAC_PKTCNT_RWD
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_MASK_PKTCNT_BSSIDMAP                  ((u32)0x0000000F << 4)          /*!<R 0  To decide this counter is for which MBSSID (16組), default : 0 for counter 0 1 for counter 1 2 for counter 2 3 for counter 3 4 for counter 4 5 for counter 5 6 for counter 6 7 for counter 7 */
-#define BIT_PKTCNT_BSSIDMAP(x)                    ((u32)(((x) & 0x0000000F) << 4))
-#define BIT_GET_PKTCNT_BSSIDMAP(x)                ((u32)(((x >> 4) & 0x0000000F)))
-#define BIT_PKTCNT_CNTRST                         ((u32)0x00000001 << 1)          /*!<R 0  Write 1 to reset Counter after DRV read all counters , DRV set this bit and HW return 0 after reset */
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_WMAC_PKTCNT_CTRL
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_WMAC_PKTCNT_FEN                       ((u32)0x00000001 << 8)          /*!<R/W 0  Packet counter function enable */
-#define BIT_MASK_WMAC_PKTCNT_CFGAD                ((u32)0x000000FF << 0)          /*!<R/W 0  Packet counter configure register read/write address */
-#define BIT_WMAC_PKTCNT_CFGAD(x)                  ((u32)(((x) & 0x000000FF) << 0))
-#define BIT_GET_WMAC_PKTCNT_CFGAD(x)              ((u32)(((x >> 0) & 0x000000FF)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_IQ_DUMP
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_MASK_DUMP_OK_ADDR                     ((u32)0x0000FFFF << 16)          /*!<R 0  [31] : dump signal addr has round up [30:16] : dump finish addr in txpktbuffer */
-#define BIT_DUMP_OK_ADDR(x)                       ((u32)(((x) & 0x0000FFFF) << 16))
-#define BIT_GET_DUMP_OK_ADDR(x)                   ((u32)(((x >> 16) & 0x0000FFFF)))
-#define BIT_MACDBG_TRIG_IQDUMP                    ((u32)0x00000001 << 15)          /*!<R/W 0  Enable dump bb ADC signal trigger from MAC debug port which controled by r_LEVEL_PULSE_SEL. */
-#define BIT_MASK_R_TRIG_TIME_SEL                  ((u32)0x0000007F << 8)          /*!<R/W 0  dump ok time to finish dump signal(unit is 1us) */
-#define BIT_R_TRIG_TIME_SEL(x)                    ((u32)(((x) & 0x0000007F) << 8))
-#define BIT_GET_R_TRIG_TIME_SEL(x)                ((u32)(((x >> 8) & 0x0000007F)))
-#define BIT_MASK_R_MAC_TRIG_SEL                   ((u32)0x00000003 << 6)          /*!<R/W 0  dump bb ADC sel mac strigger even 2'b00 : rxpkt ok trig dump ok 2'b01 : rxpkt_fauil trig dump ok 2'b10 : rxpkt cca rise edge to trig dump ok */
-#define BIT_R_MAC_TRIG_SEL(x)                     ((u32)(((x) & 0x00000003) << 6))
-#define BIT_GET_R_MAC_TRIG_SEL(x)                 ((u32)(((x >> 6) & 0x00000003)))
-#define BIT_MAC_TRIG_REG                          ((u32)0x00000001 << 5)          /*!<R/W 0  dump bb ADC sel mac strigger even write this reg to 1 to trig dump finish */
-#define BIT_MASK_R_LEVEL_PULSE_SEL                ((u32)0x00000003 << 3)          /*!<R/W 0  if dump bb ADC signal : [3] for sel mac trigger event if dump mac dbg signal [4:3] : 2'b00 : level signal match [4:3] : 2'b01 : posedge match [4:3] : 2'b10 : negdge match */
-#define BIT_R_LEVEL_PULSE_SEL(x)                  ((u32)(((x) & 0x00000003) << 3))
-#define BIT_GET_R_LEVEL_PULSE_SEL(x)              ((u32)(((x >> 3) & 0x00000003)))
-#define BIT_EN_LA_MAC                             ((u32)0x00000001 << 2)          /*!<R/W 0  enable dump mac dbg signal */
-#define BIT_R_EN_IQDUMP                           ((u32)0x00000001 << 1)          /*!<R/W 0  enable dump bb ADC signal */
-#define BIT_R_IQDATA_DUMP                         ((u32)0x00000001 << 0)          /*!<R/W 0  enable data dump for txpktbuffer high 64K */
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_MASK_LA_MAC
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_MASK_MASK_LA_MAC                      ((u32)0xFFFFFFFF << 0)          /*!<R/W 0  used for mask one or more bits of debug port */
-#define BIT_MASK_LA_MAC(x)                        ((u32)(((x) & 0xFFFFFFFF) << 0))
-#define BIT_GET_MASK_LA_MAC(x)                    ((u32)(((x >> 0) & 0xFFFFFFFF)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_MATCH_REF_MAC
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_MASK_MATCH_REF_MAC                    ((u32)0xFFFFFFFF << 0)          /*!<R/W 0  used for compare with debug port */
-#define BIT_MATCH_REF_MAC(x)                      ((u32)(((x) & 0xFFFFFFFF) << 0))
-#define BIT_GET_MATCH_REF_MAC(x)                  ((u32)(((x >> 0) & 0xFFFFFFFF)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_WMAC_DBG_FTM_CTL
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_MASK_SEL_DEBUG_DATA                   ((u32)0x00000003 << 30)          /*!<R/W 0x3  11: data write to sram 10: data after sync_fifo 01: input data (TXD/RXD/IQ_DMA_DATA from BB) 00: RSVD */
-#define BIT_SEL_DEBUG_DATA(x)                     ((u32)(((x) & 0x00000003) << 30))
-#define BIT_GET_SEL_DEBUG_DATA(x)                 ((u32)(((x >> 30) & 0x00000003)))
-#define BIT_EN_TIMEOUT                            ((u32)0x00000001 << 29)          /*!<R/W 0  Set this bit to 1 to reset mdpk read pointer */
-#define BIT_EN_RE_START                           ((u32)0x00000001 << 28)          /*!<R/W 0  Before setting 0x7C0[1:0] =2’b11, set this bit to 1 to enable MDPK access mode */
-#define BIT_MASK_LA_MAC_TIMEOUT_UNIT_SEL          ((u32)0x00000003 << 26)          /*!<R/W 0  LA mode triggered by mac debug port timeout value unit selection. 2'b00: 1us, 2'b01:32us, 2'b10: 1ms, 2'b11:RSVD */
-#define BIT_LA_MAC_TIMEOUT_UNIT_SEL(x)            ((u32)(((x) & 0x00000003) << 26))
-#define BIT_GET_LA_MAC_TIMEOUT_UNIT_SEL(x)        ((u32)(((x >> 26) & 0x00000003)))
-#define BIT_MASK_LA_MAC_TIMEOUT_VALUE             ((u32)0x0000003F << 20)          /*!<R/W 0  LA mode triggered by mac debug port timeout value, available with non-zero value. */
-#define BIT_LA_MAC_TIMEOUT_VALUE(x)               ((u32)(((x) & 0x0000003F) << 20))
-#define BIT_GET_LA_MAC_TIMEOUT_VALUE(x)           ((u32)(((x >> 20) & 0x0000003F)))
-#define BIT_LEVEL_PULSE_SEL_EXT                   ((u32)0x00000001 << 19)          /*!<R/W 0  LA mode triggered by mac debug port timeout event */
-#define BIT_MASK_TRIG_TIME_UNIT_SEL               ((u32)0x00000007 << 16)          /*!<R/W 0  Select trigger time unit of 0x7C0[14:8]. 3’b000 : 1us , 3’b001 : 2us , 3’b010 : 4us , 3’b011 : 8us , 3’b100 : 16us , 3’b101 : 32us , 3’b110 : 64us, 3’b111 : RSV */
-#define BIT_TRIG_TIME_UNIT_SEL(x)                 ((u32)(((x) & 0x00000007) << 16))
-#define BIT_GET_TRIG_TIME_UNIT_SEL(x)             ((u32)(((x >> 16) & 0x00000007)))
-#define BIT_EN_TXD_DEBUG                          ((u32)0x00000001 << 15)          /*!<R/W 0  LA MODE function. enable mactx debug mode */
-#define BIT_EN_RXD_DEBUG                          ((u32)0x00000001 << 14)          /*!<R/W 0  LA MODE function. enable macrx debug mode */
-#define BIT_TRX_TRIG_SEL_DEBUG                    ((u32)0x00000001 << 13)          /*!<R/W 0  LA MODE function. *1: select trig_stop signals from debug port, in MACTX/MACRX mode */
-#define BIT_TRX_TRIG_SEL_PATT                     ((u32)0x00000001 << 12)          /*!<R/W 0  LA MODE function. *1: select trig_stop signals from pattern match (see 0x17F0~0x17FC), in MACTX/MACRX mode */
-#define BIT_EN_IQD_LEN_BREAK                      ((u32)0x00000001 << 11)          /*!<R/W 0  LA MODE function. *1: after "trig_stop" signal asserted, if the iqdata's length over the BIT_IQD_LENGTH_REF, finish the iqdump process *0: only used TRIG_TIME finish the iqdump process */
-#define BIT_MASK_IQD_LENGTH_REF                   ((u32)0x00000007 << 8)          /*!<R/W 0  LA MODE function. Valid when BIT_EN_IQD_LEN_BREAK = 1 Used to finish IQDUMP, unit is (8KB + 1bit) */
-#define BIT_IQD_LENGTH_REF(x)                     ((u32)(((x) & 0x00000007) << 8))
-#define BIT_GET_IQD_LENGTH_REF(x)                 ((u32)(((x >> 8) & 0x00000007)))
-#define BIT_TRX_TRIG_SEL_WMAC                     ((u32)0x00000001 << 7)          /*!<R/W 1  LA MODE function. *1: select trig_stop signals from mactx or macrx, in MACTX/MACRX mode */
-#define BIT_RXFTM_TXACK_SC                        ((u32)0x00000001 << 6)          /*!<R/W 0  When HW receive FTM pkt, HW will use RX FTM BW as response ACK TXBW. */
-#define BIT_RXFTM_TXACK_BW                        ((u32)0x00000001 << 5)          /*!<R/W 0  When HW receive FTM pkt, HW will use RX FTM SC as response ACK TXSC. */
-#define BIT_RXFTM_EN                              ((u32)0x00000001 << 3)          /*!<R/W 0  If BIT_FTM_TYPE = 1 && BIT_RXFTM_EN=1, HW will parsing rx packet, to find FTM request frame. */
-#define BIT_RXFTMREQ_BYDRV                        ((u32)0x00000001 << 2)          /*!<R/W 0  If set this bit to 1,Rx FTMREQ/FTM can be receive into rxpktbuffer. */
-#define BIT_RXFTMREQ_EN                           ((u32)0x00000001 << 1)          /*!<R/W 0  If BIT_FTM_TYPE = 1 && BIT_RXFTMREQ_EN=1, HW will parsing rx packet, to find FTM request frame. */
-#define BIT_FTM_EN                                ((u32)0x00000001 << 0)          /*!<R/W 0  Fine timing measurement function; 0: Disable 1:enable */
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_OFDM_CCK_LEN_MASK
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_MASK_RX_OFDM_LEN_TH                   ((u32)0x0000FFFF << 16)          /*!<R/W 0x0FFF  rx ofdm len over this len to drop pkt(not for ht/vht) */
-#define BIT_RX_OFDM_LEN_TH(x)                     ((u32)(((x) & 0x0000FFFF) << 16))
-#define BIT_GET_RX_OFDM_LEN_TH(x)                 ((u32)(((x >> 16) & 0x0000FFFF)))
-#define BIT_MASK_RX_CCK_LEN_TH                    ((u32)0x0000FFFF << 0)          /*!<R/W 0x0FFF  rx cck len over this length to drop pkt */
-#define BIT_RX_CCK_LEN_TH(x)                      ((u32)(((x) & 0x0000FFFF) << 0))
-#define BIT_GET_RX_CCK_LEN_TH(x)                  ((u32)(((x >> 0) & 0x0000FFFF)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_WMAC_OPTION_FUNCTION_1
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_MASK_R_WMAC_RXFIFO_FULL_TH_1          ((u32)0x000000FF << 24)          /*!<R/W 0x54  csi report mac pause bb almost full threshold */
-#define BIT_R_WMAC_RXFIFO_FULL_TH_1(x)            ((u32)(((x) & 0x000000FF) << 24))
-#define BIT_GET_R_WMAC_RXFIFO_FULL_TH_1(x)        ((u32)(((x >> 24) & 0x000000FF)))
-#define BIT_R_WMAC_RX_SYNCFIFO_SYNC_1             ((u32)0x00000001 << 23)          /*!<R/W 1   */
-#define BIT_R_WMAC_RXRST_DLY_1                    ((u32)0x00000001 << 22)          /*!<R/W 0  when this bit is set 1, rxrst pulse lasts for 20 cycle of MAC clock, when this bit is set 0, rxrst pulse lasts for 10 cycle of MAC clock, */
-#define BIT_R_WMAC_SRCH_TXRPT_REF_DROP_1          ((u32)0x00000001 << 21)          /*!<R/W 0  when this bit is set 1, reference macid drop information when macid search */
-#define BIT_R_WMAC_SRCH_TXRPT_UA1_1               ((u32)0x00000001 << 20)          /*!<R/W 0  when this bit is set 1, use tx A1 to search txrpt when rx ack/cts, when BIT_r_WMAC_SRCH_TXRPT_TYPE is set 0, BIT_r_WMAC_SRCH_TXRPT_UA1 should be set 1 */
-#define BIT_R_WMAC_SRCH_TXRPT_TYPE_1              ((u32)0x00000001 << 19)          /*!<R/W 0  for rx ack/cts pkt not to search txrpt buffer macid */
-#define BIT_R_WMAC_NDP_RST_1                      ((u32)0x00000001 << 18)          /*!<R/W 0  rx pkt is ndp to clr macrx_active */
-#define BIT_R_WMAC_POWINT_EN_1                    ((u32)0x00000001 << 17)          /*!<R/W 0  enable rx pkt fc column power bit int for FISR */
-#define BIT_R_WMAC_SRCH_TXRPT_PERPKT_1            ((u32)0x00000001 << 16)          /*!<R/W 0  enable search txrpt buffer for macid every pkt */
-#define BIT_R_WMAC_SRCH_TXRPT_MID_1               ((u32)0x00000001 << 15)          /*!<R/W 1  enable search txrpt buffer for macid */
-#define BIT_R_WMAC_PFIN_TOEN_1                    ((u32)0x00000001 << 14)          /*!<R/W 0  rx fifo fsm flush state timeout to error stage */
-#define BIT_R_WMAC_FIL_SECERR_1                   ((u32)0x00000001 << 13)          /*!<R/W 1  sec len error drop(sec len is zero) */
-#define BIT_R_WMAC_FIL_CTLPKTLEN_1                ((u32)0x00000001 << 12)          /*!<R/W 0  drop the rx pkt if the rx ctrl pkt len large than r_WMAC_RX_FIL_LEN */
-#define BIT_R_WMAC_FIL_FCTYPE_1                   ((u32)0x00000001 << 11)          /*!<R/W 0  drop the ofdm pkt if the rx ofdm leg pkt fc type is 2'b11 */
-#define BIT_R_WMAC_FIL_FCPROVER_1                 ((u32)0x00000001 << 10)          /*!<R/W 0  drop the ofdm pkt if the rx ofdm leg pkt fc version illegal */
-#define BIT_R_WMAC_PHYSTS_SNIF_1                  ((u32)0x00000001 << 9)          /*!<R/W 0  append sniff info after phy status */
-#define BIT_R_WMAC_PHYSTS_PLCP_1                  ((u32)0x00000001 << 8)          /*!<R/W 0  append plcp header after phy status */
-#define BIT_R_MAC_TCR_VBONF_RD_1                  ((u32)0x00000001 << 7)          /*!<R/W 0  vbon neg edge to read all data of mac rx sync fifo for rx parser */
-#define BIT_R_WMAC_TCR_MPAR_NDP_1                 ((u32)0x00000001 << 6)          /*!<R/W 0  nop ok check bb ndp vld & mac rx ndp check ok */
-#define BIT_R_WMAC_NDP_FILTER_1                   ((u32)0x00000001 << 5)          /*!<R/W 0  mac rx ndp pkt set ppdu len to 0 */
-#define BIT_R_WMAC_RXLEN_SEL_1                    ((u32)0x00000001 << 4)          /*!<R/W 0  rx vht len sel lsig len VHT PPDU length selection 0: 收到VHT PPDU PKT 會根據 VHTSIGB PPDU length 來parsing 與計算 1: 收到VHT PPDU PKT 會根據 BB 算的 LSIG length 來parsing 與計算 */
-#define BIT_R_WMAC_RXLEN_SEL1_1                   ((u32)0x00000001 << 3)          /*!<R/W 0  rx vht len sel lsig len if sigb len is more than lsig len */
-#define BIT_R_OFDM_FILTER_1                       ((u32)0x00000001 << 2)          /*!<R/W 0  RSVD */
-#define BIT_R_WMAC_CHK_OFDM_LEN_1                 ((u32)0x00000001 << 1)          /*!<R/W 0  enable to check ofdm len */
-#define BIT_R_WMAC_CHK_CCK_LEN_1                  ((u32)0x00000001 << 0)          /*!<R/W 0  enable to check rx cck len */
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_RX_FILTER_FUNCTION
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_RXHANG_EN                             ((u32)0x00000001 << 31)          /*!<R/W 0  Force read error content from fifo to solve rxhang. */
-#define BIT_R_WMAC_MHRDDY_LATCH                   ((u32)0x00000001 << 30)          /*!<R/W 0  Adjust mach_rdy timing if rx_parser and rxpktfifo FSM is not sync. */
-#define BIT_R_WMAC_MHRDDY_CLR                     ((u32)0x00000001 << 29)          /*!<R/W 1  Reset mach_rdy_latch when rx parser begin parsing mac header. */
-#define BIT_R_RXPKTCTL_FSM_BASED_MPDURDY1         ((u32)0x00000001 << 28)          /*!<R/W 1  Adjust mpdu_rdy timing to solve FSM behavier error. */
-#define BIT_WMAC_DIS_VHT_PLCP_CHK_MU              ((u32)0x00000001 << 27)          /*!<R/W 0  Disable check sigb crc value of MU plcp header. */
-#define BIT_R_CHK_DELIMIT_LEN                     ((u32)0x00000001 << 26)          /*!<R/W 0  Drop mpdu if delimeter mpdu length smaller than mac header length + 4. */
-#define BIT_R_REAPTER_ADDR_MATCH                  ((u32)0x00000001 << 25)          /*!<R/W 0  when this bit is set 1, physical address is matched when rx A1 is equal to tx A2, used in repeater mode */
-#define BIT_R_RXPKTCTL_FSM_BASED_MPDURDY          ((u32)0x00000001 << 24)          /*!<R/W 0  when this bit is set 1, rxpktfifo_ctl FSM jumps based on mpdu_valid(all MPDU data has been transferred to rxpktbuffer), when this bit is set 0, rxpktfifo_ctl FSM jumps based on fcs_valid(all MPDU data has been parsed by rx_parser) */
-#define BIT_R_LATCH_MACHRDY                       ((u32)0x00000001 << 23)          /*!<R/W 1  when this bit set 1,mach_rdy signal is latched to make sure that rxpktfifo_ctl can detect it */
-#define BIT_R_WMAC_RXFIL_REND                     ((u32)0x00000001 << 22)          /*!<R/W 0  when this bit set 1,icvmic_valid signal is cleared when icvmic_rdy is valid(ICV/MIC is parsed) */
-#define BIT_R_WMAC_MPDURDY_CLR                    ((u32)0x00000001 << 21)          /*!<R/W 0  when the bit is set 1, the last MPDU which will be transferred to rxpktfifo is ready and error occurs, mpdu_rdy signal is also valid(is means all MPDU data has been transferred to rxpktbuffer) */
-#define BIT_R_WMAC_CLRRXSEC                       ((u32)0x00000001 << 20)          /*!<R/W 0  If new rx pkt is coming, reset the previous rx key search result. */
-#define BIT_R_WMAC_RXFIL_RDEL                     ((u32)0x00000001 << 19)          /*!<R/W 0  If new rx pkt is coming, reset the rxpkt_ctl FSM after parsing plcp. */
-#define BIT_R_WMAC_RXFIL_FCSE                     ((u32)0x00000001 << 18)          /*!<R/W 0  If rx pkt is not ampdu and rejected, reset rxpkt_ctl FSM immediately after parsing header */
-#define BIT_R_WMAC_RXFIL_MESH_DEL                 ((u32)0x00000001 << 17)          /*!<R/W 0  drop the ofdm pkt if the rx ofdm leg pkt fc type is 2'b11 */
-#define BIT_R_WMAC_RXFIL_MASKM                    ((u32)0x00000001 << 16)          /*!<R/W 1  drop the ofdm pkt if the rx ofdm leg pkt fc type is 2'b11 */
-#define BIT_MASK_R_WMAC_RX_FIL_LEN_2              ((u32)0x0000FFFF << 0)          /*!<R/W 0x41  use with BIT_r_WMAC_FIL_CTLPKTLEN */
-#define BIT_R_WMAC_RX_FIL_LEN_2(x)                ((u32)(((x) & 0x0000FFFF) << 0))
-#define BIT_GET_R_WMAC_RX_FIL_LEN_2(x)            ((u32)(((x >> 0) & 0x0000FFFF)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_WMAC_OPTION_FUNCTION_3
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_MASK_R_WMAC_TXNDP_SIGB                ((u32)0x001FFFFF << 0)          /*!<R/W 0x1845A5  SIGB for NDP packet when BW =40MHz */
-#define BIT_R_WMAC_TXNDP_SIGB(x)                  ((u32)(((x) & 0x001FFFFF) << 0))
-#define BIT_GET_R_WMAC_TXNDP_SIGB(x)              ((u32)(((x >> 0) & 0x001FFFFF)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_WMAC_DBG_SEL
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_MASK_MAC_DBG_SHIFT                    ((u32)0x00000007 << 8)          /*!<R/W 0   */
-#define BIT_MAC_DBG_SHIFT(x)                      ((u32)(((x) & 0x00000007) << 8))
-#define BIT_GET_MAC_DBG_SHIFT(x)                  ((u32)(((x >> 8) & 0x00000007)))
-#define BIT_MASK_MAC_DBG_SEL                      ((u32)0x00000003 << 0)          /*!<R/W 0   */
-#define BIT_MAC_DBG_SEL(x)                        ((u32)(((x) & 0x00000003) << 0))
-#define BIT_GET_MAC_DBG_SEL(x)                    ((u32)(((x >> 0) & 0x00000003)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_WMAC_DBG_SHIFT
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_MASK_MACTX_CMD_SHIFT                  ((u32)0xFFFFFFFF << 0)          /*!<R 0   */
-#define BIT_MACTX_CMD_SHIFT(x)                    ((u32)(((x) & 0xFFFFFFFF) << 0))
-#define BIT_GET_MACTX_CMD_SHIFT(x)                ((u32)(((x >> 0) & 0xFFFFFFFF)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_WSEC_OPTION
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_RXDEC_BM_MGNT                         ((u32)0x00000001 << 22)          /*!<R/W 1  decryption enable of rx multicast management pkt, 0x680[3] shall also be set valid */
-#define BIT_TXENC_BM_MGNT                         ((u32)0x00000001 << 21)          /*!<R/W 1  encryption enable of tx multicast management pkt, 0x680[2] shall also be set valid */
-#define BIT_RXDEC_UNI_MGNT                        ((u32)0x00000001 << 20)          /*!<R/W 1  decryption enable of rx unicast management pkt, 0x680[3] shall also be set valid */
-#define BIT_TXENC_UNI_MGNT                        ((u32)0x00000001 << 19)          /*!<R/W 1  encryption enable of tx unicast management pkt, 0x680[2] shall also be set valid */
-#define BIT_WMAC_SEC_MASKIV                       ((u32)0x00000001 << 18)          /*!<R/W 0  MASK IV[15:8] for GCMP security */
-#define BIT_MASK_WMAC_SEC_PN_SEL                  ((u32)0x00000003 << 16)          /*!<R/W 0  Security GCMP header PN selection */
-#define BIT_WMAC_SEC_PN_SEL(x)                    ((u32)(((x) & 0x00000003) << 16))
-#define BIT_GET_WMAC_SEC_PN_SEL(x)                ((u32)(((x >> 16) & 0x00000003)))
-#define BIT_WAPI_FC_NOMASK                        ((u32)0x00000001 << 15)          /*!<R/W 0  If set to 1, enable old WAPI ADD format, don't mask FC bit4~6, bit8~15, If set to 0, enable new WAPI ADD format, mask FC bit15 to 0. */
-#define BIT_WAPI_QC_NOMASK                        ((u32)0x00000001 << 14)          /*!<R/W 0  If set to 1, enable old WAPI ADD format, don't mask QC bit4~6, bit8~15, If set to 0, enable new WAPI ADD format, mask QC bit4~6, bit8~15 to 0. */
-#define BIT_GCM_WAPI_FC_NOMASK                    ((u32)0x00000001 << 13)          /*!<R/W 0  If set to 1, enable old GCM-WAPI ADD format, don't mask FC bit4~6, bit8~15, If set to 0, enable new GCM-WAPI ADD format, mask FC bit15 to 0. */
-#define BIT_MASK_BT_TIME_CNT                      ((u32)0x000000FF << 0)          /*!<R/W 0x14  US timer counter boundary of BTCOEXIST */
-#define BIT_BT_TIME_CNT(x)                        ((u32)(((x) & 0x000000FF) << 0))
-#define BIT_GET_BT_TIME_CNT(x)                    ((u32)(((x >> 0) & 0x000000FF)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_RTS_ADDRESS_0
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_MASK_R_WMAC_RTS_ADDR0                 ((u32)0xFFFFFFFF << 0)          /*!<R/W 0  if 0x604[31]=1 & rts is multicast, use this value as Address1 of RTS */
-#define BIT_R_WMAC_RTS_ADDR0(x)                   ((u32)(((x) & 0xFFFFFFFF) << 0))
-#define BIT_GET_R_WMAC_RTS_ADDR0(x)               ((u32)(((x >> 0) & 0xFFFFFFFF)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_RTS_ADDRESS_0_1
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_MASK_R_WMAC_RTS_ADDR0_1               ((u32)0x0000FFFF << 0)          /*!<R/W 0  if 0x604[31]=1 & rts is multicast, use this value as Address1 of RTS */
-#define BIT_R_WMAC_RTS_ADDR0_1(x)                 ((u32)(((x) & 0x0000FFFF) << 0))
-#define BIT_GET_R_WMAC_RTS_ADDR0_1(x)             ((u32)(((x >> 0) & 0x0000FFFF)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_RTS_ADDRESS_1
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_MASK_R_WMAC_RTS_ADDR1                 ((u32)0xFFFFFFFF << 0)          /*!<R/W 0  if 0x604[31]=1 & rts is multicast, use this value as Address1 of RTS */
-#define BIT_R_WMAC_RTS_ADDR1(x)                   ((u32)(((x) & 0xFFFFFFFF) << 0))
-#define BIT_GET_R_WMAC_RTS_ADDR1(x)               ((u32)(((x >> 0) & 0xFFFFFFFF)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_RTS_ADDRESS_1_1
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_MASK_R_WMAC_RTS_ADDR1_1               ((u32)0x0000FFFF << 0)          /*!<R/W 0  if 0x604[31]=1 & rts is multicast, use this value as Address1 of RTS */
-#define BIT_R_WMAC_RTS_ADDR1_1(x)                 ((u32)(((x) & 0x0000FFFF) << 0))
-#define BIT_GET_R_WMAC_RTS_ADDR1_1(x)             ((u32)(((x >> 0) & 0x0000FFFF)))
-/** @} */
-
-
-/*==========PAGE7 Register Address Definition==========*/
-#define REG_MACID1                                   0x0700
-#define REG_MACID1_1                                 0x0704
-#define REG_BSSID1                                   0x0708
-#define REG_BSSID1_1                                 0x070C
-#define REG_BCN_PSR_RPT1                             0x0710
-#define REG_ASSOCIATED_BFMEE_SEL                     0x0714
-#define REG_SND_PTCL_CTRL                            0x0718
-#define REG_BEAMFORM_STATUS                          0x071C
-#define REG_NSARP_CFG                                0x0720
-#define REG_ZB_STATISTIC_1                           0x0724
-#define REG_ZB_STATISTIC_2                           0x0728
-#define REG_BEAMFORMING_INFO_NSARP                   0x072C
-#define REG_IPV6_0                                   0x0730
-#define REG_IPV6_1                                   0x0734
-#define REG_IPV6_2                                   0x0738
-#define REG_IPV6_3                                   0x073C
-#define REG_ZB_COEX_TABLE_1                          0x0740
-#define REG_ZB_COEX_TABLE_2                          0x0744
-#define REG_ZB_BREAK_TABLE                           0x0748
-#define REG_EXT_ZB_DETEC_CTRL                        0x074C
-#define REG_WMAC_RTX_CTX_SUBTYPE                     0x0750
-#define REG_WMAC_RTX_SWAES_RD_1                      0x0754
-#define REG_WMAC_RTX_SWAES_RD_2                      0x0758
-#define REG_WMAC_RTX_SWAES_RD_3                      0x075C
-#define REG_WMAC_SWAES_CFG                           0x0760
-#define REG_BT_COEX_ENH                              0x0764
-#define REG_WLAN_ACT_MASK_CTRL                       0x0768
-#define REG_WLAN_ACT_MASK_CTRL_1                     0x076C
-#define REG_BT_ENHANCED_CTRL0                        0x0770
-#define REG_BT_ENHANCED_CTRL1                        0x0774
-#define REG_BT_PROPRI                                0x0778
-#define REG_BT_STATUS_REPORT_REGISTER                0x077C
-#define REG_BT_INTERRUPT_CONTROL_REGISTER            0x0780
-#define REG_WLAN_REPORT_TIME_OUT_CONTROL_REGISTER    0x0784
-#define REG_BT_ISOLATION_TABLE_REGISTER_REGISTER_1   0x0788
-#define REG_BT_INTERRUPT_STATUS_REGISTER             0x078C
-#define REG_BT_TDMA_TIME_REGISTER                    0x0790
-#define REG_BT_ACT_REGISTER                          0x0794
-#define REG_LTR_IDLE_LATENCY_V2                      0x0798
-#define REG_LTR_ACTIVE_LATENCY_V2                    0x079C
-#define REG_OBFF_CTRL                                0x07A0
-#define REG_LTR_CTRL                                 0x07A4
-#define REG_LTR_CTRL2                                0x07A8
-#define REG_ANTTRN_CTR_V1                            0x07B0
-#define REG_ANTTRN_CTR_1_V1                          0x07B4
-#define REG_WMAC_PKTCNT_RWD                          0x07B8
-#define REG_WMAC_PKTCNT_CTRL                         0x07BC
-#define REG_IQ_DUMP                                  0x07C0
-#define REG_MASK_LA_MAC                              0x07C4
-#define REG_MATCH_REF_MAC                            0x07C8
-#define REG_WMAC_DBG_FTM_CTL                         0x07CC
-#define REG_OFDM_CCK_LEN_MASK                        0x07D0
-#define REG_WMAC_OPTION_FUNCTION_1                   0x07D4
-#define REG_RX_FILTER_FUNCTION                       0x07D8
-#define REG_WMAC_OPTION_FUNCTION_3                   0x07E0
-#define REG_WMAC_DBG_SEL                             0x07E4
-#define REG_WMAC_DBG_SHIFT                           0x07E8
-#define REG_WSEC_OPTION                              0x07EC
-#define REG_RTS_ADDRESS_0                            0x07F0
-#define REG_RTS_ADDRESS_0_1                          0x07F4
-#define REG_RTS_ADDRESS_1                            0x07F8
-#define REG_RTS_ADDRESS_1_1                          0x07FC
-
-/* AUTO_GEN_END */
-
-/* MANUAL_GEN_START */
-
-//Please add your defination here
-
-/* MANUAL_GEN_END */
-
-#endif
diff --git a/os/board/rtl8720e/src/component/wifi/wifi_fw/amebalite/include/wififw_reg_ram.h b/os/board/rtl8720e/src/component/wifi/wifi_fw/amebalite/include/wififw_reg_ram.h
deleted file mode 100644
index 03f8b3343..000000000
--- a/os/board/rtl8720e/src/component/wifi/wifi_fw/amebalite/include/wififw_reg_ram.h
+++ /dev/null
@@ -1,19 +0,0 @@
-#ifndef __WIFIFW_REG_RAM_H__
-#define __WIFIFW_REG_RAM_H__
-
-#include "wififw_reg_page0.h"
-#include "wififw_reg_page1.h"
-#include "wififw_reg_page2.h"
-#include "wififw_reg_page3.h"
-#include "wififw_reg_page4.h"
-#include "wififw_reg_page5.h"
-#include "wififw_reg_page6.h"
-#include "wififw_reg_page7.h"
-#include "wififw_reg_page12.h"
-#include "wififw_reg_page17.h"
-#include "wififw_reg_page26.h"
-#include "wififw_reg_txpwr.h"
-#include "wififw_reg_mac_sram.h"
-
-#endif  //__WIFIFW_REG_H__
-
diff --git a/os/board/rtl8720e/src/component/wifi/wifi_fw/amebalite/include/wififw_reg_txpwr.h b/os/board/rtl8720e/src/component/wifi/wifi_fw/amebalite/include/wififw_reg_txpwr.h
deleted file mode 100644
index b9226ab90..000000000
--- a/os/board/rtl8720e/src/component/wifi/wifi_fw/amebalite/include/wififw_reg_txpwr.h
+++ /dev/null
@@ -1,2833 +0,0 @@
-#ifndef _AMEBAD2_TXPWR_H_
-#define _AMEBAD2_TXPWR_H_
-
-/* AUTO_GEN_START */
-
-/**************************************************************************//**
- * @defgroup REG_AX_PWR_RATE_CTRL
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_R_TXPWR_CTRL_CLR                                        ((u32)0x00000001 << 31)          /*!<R/W 0  (RTL_only) 1: clr txpwr, sync rst */
-#define BIT_MASK_R_FORCE_MODE_IDX                                   ((u32)0x00000007 << 28)          /*!<R/W 0  Force txpwr_bb from specific source 0:FOCRE_NONE (normal) 1:FORCE_PWR_BY_RATE 2:FORCE_MACID 3:FORCE_PWR_LIM 4:FORCE_PWR_RU_LIM 5:FORCE_COEXIST */
-#define BIT_R_FORCE_MODE_IDX(x)                                     ((u32)(((x) & 0x00000007) << 28))
-#define BIT_GET_R_FORCE_MODE_IDX(x)                                 ((u32)(((x >> 28) & 0x00000007)))
-#define BIT_MASK_R_TXAGC_OFDM_REF                                   ((u32)0x000001FF << 19)          /*!<R/W 40h  S(9.2) ofdm ref dbm */
-#define BIT_R_TXAGC_OFDM_REF(x)                                     ((u32)(((x) & 0x000001FF) << 19))
-#define BIT_GET_R_TXAGC_OFDM_REF(x)                                 ((u32)(((x >> 19) & 0x000001FF)))
-#define BIT_MASK_R_TXAGC_CCK_REF                                    ((u32)0x000001FF << 10)          /*!<R/W 40h  S(9.2) cck ref dbm */
-#define BIT_R_TXAGC_CCK_REF(x)                                      ((u32)(((x) & 0x000001FF) << 10))
-#define BIT_GET_R_TXAGC_CCK_REF(x)                                  ((u32)(((x >> 10) & 0x000001FF)))
-#define BIT_R_FORCE_PWR_BY_RATE_EN                                  ((u32)0x00000001 << 9)          /*!<R/W 0  force pwr by rate value_en */
-#define BIT_MASK_R_FORCE_PWR_BY_RATE_VALUE                          ((u32)0x000001FF << 0)          /*!<R/W 0  S(9.2) force pwr by rate value (txagc_ref+pwr_by_rate_tbl) */
-#define BIT_R_FORCE_PWR_BY_RATE_VALUE(x)                            ((u32)(((x) & 0x000001FF) << 0))
-#define BIT_GET_R_FORCE_PWR_BY_RATE_VALUE(x)                        ((u32)(((x >> 0) & 0x000001FF)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_AX_PWR_RATE_OFST_CTRL
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_R_TXAGC_TBL_RD                                          ((u32)0x00000001 << 26)          /*!<R/W 0  (RTL_only) 1:indirecr read enable */
-#define BIT_MASK_R_TXAGC_TBL_RA                                     ((u32)0x0000003F << 20)          /*!<R/W 0  (RTL_only) indirect read of addr of pwr_by_rate */
-#define BIT_R_TXAGC_TBL_RA(x)                                       ((u32)(((x) & 0x0000003F) << 20))
-#define BIT_GET_R_TXAGC_TBL_RA(x)                                   ((u32)(((x >> 20) & 0x0000003F)))
-#define BIT_MASK_R_TXAGC_CCK_HT_OFFSET                              ((u32)0x0000000F << 16)          /*!<R/W 0  S(4.1)CCK-HT pwr offset */
-#define BIT_R_TXAGC_CCK_HT_OFFSET(x)                                ((u32)(((x) & 0x0000000F) << 16))
-#define BIT_GET_R_TXAGC_CCK_HT_OFFSET(x)                            ((u32)(((x >> 16) & 0x0000000F)))
-#define BIT_MASK_R_TXAGC_LEGACY_HT_OFFSET                           ((u32)0x0000000F << 12)          /*!<R/W 0  S(4.1)LEG-HT pwr offset */
-#define BIT_R_TXAGC_LEGACY_HT_OFFSET(x)                             ((u32)(((x) & 0x0000000F) << 12))
-#define BIT_GET_R_TXAGC_LEGACY_HT_OFFSET(x)                         ((u32)(((x >> 12) & 0x0000000F)))
-#define BIT_MASK_R_TXAGC_HT_OFFSET                                  ((u32)0x0000000F << 8)          /*!<R/W 0  (RTL_only) S(4.1) HT-HT pwr bias = 0 */
-#define BIT_R_TXAGC_HT_OFFSET(x)                                    ((u32)(((x) & 0x0000000F) << 8))
-#define BIT_GET_R_TXAGC_HT_OFFSET(x)                                ((u32)(((x >> 8) & 0x0000000F)))
-#define BIT_MASK_R_TXAGC_VHT_HT_OFFSET                              ((u32)0x0000000F << 4)          /*!<R/W 0  S(4.1)VHT-HT pwr offset */
-#define BIT_R_TXAGC_VHT_HT_OFFSET(x)                                ((u32)(((x) & 0x0000000F) << 4))
-#define BIT_GET_R_TXAGC_VHT_HT_OFFSET(x)                            ((u32)(((x >> 4) & 0x0000000F)))
-#define BIT_MASK_R_TXAGC_HE_HT_OFFSET                               ((u32)0x0000000F << 0)          /*!<R/W 0  S(4.1)HE-HT pwr offset */
-#define BIT_R_TXAGC_HE_HT_OFFSET(x)                                 ((u32)(((x) & 0x0000000F) << 0))
-#define BIT_GET_R_TXAGC_HE_HT_OFFSET(x)                             ((u32)(((x >> 0) & 0x0000000F)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_AX_PWR_LMT_CTRL
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_R_FORCE_TF_DCM_EN                                       ((u32)0x00000001 << 26)          /*!<R/W 0  (RTL_only) 1:Force input TF dcm = R_force_TF_dcm_value */
-#define BIT_R_FORCE_TF_DCM_VALUE                                    ((u32)0x00000001 << 25)          /*!<R/W 0  (RTL_only) Force input TF dcm value */
-#define BIT_R_FORCE_NORM_RSP_HE_TB_EN_ON                            ((u32)0x00000001 << 24)          /*!<R/W 0  (RTL_only) 1:Norm resp always In HE_TB */
-#define BIT_R_FORCE_PWR_BY_LIMIT_BF0_EN                             ((u32)0x00000001 << 23)          /*!<R/W 0  (RTL_only) 1: Force pwr_lim_BF0= r_force_pwr_by_limit_bfoff_value (0xd210[17:9]) */
-#define BIT_R_FORCE_PWR_BY_LIMIT_BF1_EN                             ((u32)0x00000001 << 22)          /*!<R/W 0  (RTL_only) 1: Force pwr_lim_BF1= r_force_pwr_by_limit_bfon_value (0xd210[8:0]) */
-#define BIT_R_TXAGC_PWR_LIM_BF0_EN                                  ((u32)0x00000001 << 21)          /*!<R/W 1h  (RTL_only) None BF pwr limit enable */
-#define BIT_R_TXAGC_PWR_LIM_BF1_EN                                  ((u32)0x00000001 << 20)          /*!<R/W 1h  (RTL_only) BF pwr limit enable */
-#define BIT_MASK_R_TXAGC_BW20_BW40_OFFSET                           ((u32)0x0000000F << 16)          /*!<R/W 0  S(4.1)BW20 - BW40 pwr offset */
-#define BIT_R_TXAGC_BW20_BW40_OFFSET(x)                             ((u32)(((x) & 0x0000000F) << 16))
-#define BIT_GET_R_TXAGC_BW20_BW40_OFFSET(x)                         ((u32)(((x >> 16) & 0x0000000F)))
-#define BIT_MASK_R_TXAGC_RFBW_40M_OFFSET                            ((u32)0x0000000F << 12)          /*!<R/W 0  (RTL_only) S(4.1)BW40 - BW40 pwr offset */
-#define BIT_R_TXAGC_RFBW_40M_OFFSET(x)                              ((u32)(((x) & 0x0000000F) << 12))
-#define BIT_GET_R_TXAGC_RFBW_40M_OFFSET(x)                          ((u32)(((x >> 12) & 0x0000000F)))
-#define BIT_MASK_R_TXAGC_BW80_BW40_OFFSET                           ((u32)0x0000000F << 8)          /*!<R/W 0  S(4.1)BW80 - BW40 pwr offset */
-#define BIT_R_TXAGC_BW80_BW40_OFFSET(x)                             ((u32)(((x) & 0x0000000F) << 8))
-#define BIT_GET_R_TXAGC_BW80_BW40_OFFSET(x)                         ((u32)(((x >> 8) & 0x0000000F)))
-#define BIT_MASK_R_TXAGC_BW160_BW40_OFFSET                          ((u32)0x0000000F << 4)          /*!<R/W 0  S(4.1)BW160 - BW40 pwr offset */
-#define BIT_R_TXAGC_BW160_BW40_OFFSET(x)                            ((u32)(((x) & 0x0000000F) << 4))
-#define BIT_GET_R_TXAGC_BW160_BW40_OFFSET(x)                        ((u32)(((x >> 4) & 0x0000000F)))
-#define BIT_MASK_R_TXAGC_BW80_80_BW40_OFFSET                        ((u32)0x0000000F << 0)          /*!<R/W 0  S(4.1) BW80+80 - BW40 pwr offset */
-#define BIT_R_TXAGC_BW80_80_BW40_OFFSET(x)                          ((u32)(((x) & 0x0000000F) << 0))
-#define BIT_GET_R_TXAGC_BW80_80_BW40_OFFSET(x)                      ((u32)(((x >> 0) & 0x0000000F)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_AX_PWR_MACID_CTRL
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_R_TXAGC_PWR_BY_MACID_EN                                 ((u32)0x00000001 << 29)          /*!<R/W 1h  (RTL_only) 1:enable pwr_by_macid */
-#define BIT_R_FORCE_CCA_PWR_TH_VALUE_EN                             ((u32)0x00000001 << 28)          /*!<R/W 0  1:Force CCA_PWR_TH value_en */
-#define BIT_MASK_R_FORCE_CCA_PWR_TH_VALUE                           ((u32)0x000000FF << 20)          /*!<R/W 0  S(8.1)Force CCA_PWR_TH value */
-#define BIT_R_FORCE_CCA_PWR_TH_VALUE(x)                             ((u32)(((x) & 0x000000FF) << 20))
-#define BIT_GET_R_FORCE_CCA_PWR_TH_VALUE(x)                         ((u32)(((x >> 20) & 0x000000FF)))
-#define BIT_R_FORCE_CCA_PWR_TH_EN                                   ((u32)0x00000001 << 17)          /*!<R/W 0  (RTL_only) 1:Force output CCA_PWR_TH_en */
-#define BIT_R_FORCE_PWR_BY_MACID_EN                                 ((u32)0x00000001 << 16)          /*!<R/W 0  1:Force output Pwr_by_macid_en */
-#define BIT_MASK_R_FORCE_PWR_BY_MACID_VALUE                         ((u32)0x000000FF << 8)          /*!<R/W 0  S(8.1)Force Pwr_by_macid_value */
-#define BIT_R_FORCE_PWR_BY_MACID_VALUE(x)                           ((u32)(((x) & 0x000000FF) << 8))
-#define BIT_GET_R_FORCE_PWR_BY_MACID_VALUE(x)                       ((u32)(((x >> 8) & 0x000000FF)))
-#define BIT_R_FORCE_PWR_BY_MACID_VALUE_EN                           ((u32)0x00000001 << 7)          /*!<R/W 1h  (RTL_only) 1:Force output Pwr_by_macid_value */
-#define BIT_R_TXPWR_LIM_TBL_RD                                      ((u32)0x00000001 << 6)          /*!<R/W 0  (RTL_only) 1: pwr lim tbl indirect read en */
-#define BIT_MASK_R_TXPWR_LIM_TBL_RA                                 ((u32)0x0000003F << 0)          /*!<R/W 0  (RTL_only) pwr lim tbl indirect read addr */
-#define BIT_R_TXPWR_LIM_TBL_RA(x)                                   ((u32)(((x) & 0x0000003F) << 0))
-#define BIT_GET_R_TXPWR_LIM_TBL_RA(x)                               ((u32)(((x >> 0) & 0x0000003F)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_AX_PWR_BF_CTRL
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_R_TXAGC_BF_PWR_BOOST_EN                                 ((u32)0x00000001 << 31)          /*!<R/W 1h  1:TxBF will cal pwr boost to BB 0:TxBF pwr_boost =0 & Pwr_lim use BF1_pwr_lim */
-#define BIT_MASK_R_HE_ER_SU_PWR_REDUCE_VAL                          ((u32)0x0000003F << 19)          /*!<R/W Ch  (RTL_only) S(6.2) 3dB=0xC */
-#define BIT_R_HE_ER_SU_PWR_REDUCE_VAL(x)                            ((u32)(((x) & 0x0000003F) << 19))
-#define BIT_GET_R_HE_ER_SU_PWR_REDUCE_VAL(x)                        ((u32)(((x >> 19) & 0x0000003F)))
-#define BIT_R_HE_ER_SU_PWR_REDUCE_EN                                ((u32)0x00000001 << 18)          /*!<R/W 0  1:HE_ER_SU pwr lim output will minus 3dB */
-#define BIT_MASK_R_FORCE_PWR_BY_LIMIT_BFOFF_VALUE                   ((u32)0x000001FF << 9)          /*!<R/W 0  S(9.2) r_force_pwr_by_limit_BF0_en=1 is valid */
-#define BIT_R_FORCE_PWR_BY_LIMIT_BFOFF_VALUE(x)                     ((u32)(((x) & 0x000001FF) << 9))
-#define BIT_GET_R_FORCE_PWR_BY_LIMIT_BFOFF_VALUE(x)                 ((u32)(((x >> 9) & 0x000001FF)))
-#define BIT_MASK_R_FORCE_PWR_BY_LIMIT_BFON_VALUE                    ((u32)0x000001FF << 0)          /*!<R/W 0  S(9.2) r_force_pwr_by_limit_BF1_en=1 is valid */
-#define BIT_R_FORCE_PWR_BY_LIMIT_BFON_VALUE(x)                      ((u32)(((x) & 0x000001FF) << 0))
-#define BIT_GET_R_FORCE_PWR_BY_LIMIT_BFON_VALUE(x)                  ((u32)(((x >> 0) & 0x000001FF)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_AX_PWR_MACID_REG
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_MASK_R_TXPWR_REG3                                       ((u32)0x000000FF << 24)          /*!<R/W 0  S(8.1)pwr by macid when Pwr_mode=5 from MAC */
-#define BIT_R_TXPWR_REG3(x)                                         ((u32)(((x) & 0x000000FF) << 24))
-#define BIT_GET_R_TXPWR_REG3(x)                                     ((u32)(((x >> 24) & 0x000000FF)))
-#define BIT_MASK_R_TXPWR_REG2                                       ((u32)0x000000FF << 16)          /*!<R/W 0  S(8.1)pwr by macid when Pwr_mode=4 from MAC */
-#define BIT_R_TXPWR_REG2(x)                                         ((u32)(((x) & 0x000000FF) << 16))
-#define BIT_GET_R_TXPWR_REG2(x)                                     ((u32)(((x >> 16) & 0x000000FF)))
-#define BIT_MASK_R_TXPWR_REG1                                       ((u32)0x000000FF << 8)          /*!<R/W 0  S(8.1)pwr by macid when Pwr_mode=3 from MAC */
-#define BIT_R_TXPWR_REG1(x)                                         ((u32)(((x) & 0x000000FF) << 8))
-#define BIT_GET_R_TXPWR_REG1(x)                                     ((u32)(((x >> 8) & 0x000000FF)))
-#define BIT_MASK_R_TXPWR_REG0                                       ((u32)0x000000FF << 0)          /*!<R/W 0  S(8.1)pwr by macid when Pwr_mode=2 from MAC */
-#define BIT_R_TXPWR_REG0(x)                                         ((u32)(((x) & 0x000000FF) << 0))
-#define BIT_GET_R_TXPWR_REG0(x)                                     ((u32)(((x >> 0) & 0x000000FF)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_AX_PWR_MACID_REG2
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_R_TXPWR_BY_MACID_TBL_RD                                 ((u32)0x00000001 << 31)          /*!<R/W 0  (RTL_only) 1:Pwr_by_macid indirect read */
-#define BIT_MASK_R_TXPWR_BY_MACID_TBL_RA                            ((u32)0x0000007F << 24)          /*!<R/W 0  (RTL_only) Pwr_by_macid indirect read addr */
-#define BIT_R_TXPWR_BY_MACID_TBL_RA(x)                              ((u32)(((x) & 0x0000007F) << 24))
-#define BIT_GET_R_TXPWR_BY_MACID_TBL_RA(x)                          ((u32)(((x >> 24) & 0x0000007F)))
-#define BIT_R_TXPWR_REG5_EN                                         ((u32)0x00000001 << 21)          /*!<R/W 0  pwr by macid en when Pwr_mode=7 from MAC */
-#define BIT_R_TXPWR_REG4_EN                                         ((u32)0x00000001 << 20)          /*!<R/W 0  pwr by macid en when Pwr_mode=6 from MAC */
-#define BIT_R_TXPWR_REG3_EN                                         ((u32)0x00000001 << 19)          /*!<R/W 0  pwr by macid en when Pwr_mode=5 from MAC */
-#define BIT_R_TXPWR_REG2_EN                                         ((u32)0x00000001 << 18)          /*!<R/W 0  pwr by macid en when pwr_mode=4 from MAC */
-#define BIT_R_TXPWR_REG1_EN                                         ((u32)0x00000001 << 17)          /*!<R/W 0  pwr by macid en when Pwr_mode=3 from MAC */
-#define BIT_R_TXPWR_REG0_EN                                         ((u32)0x00000001 << 16)          /*!<R/W 0  pwr by macid en when Pwr_mode=2 from MAC */
-#define BIT_MASK_R_TXPWR_REG5                                       ((u32)0x000000FF << 8)          /*!<R/W 0  S(8.1)pwr by macid when Pwr_mode=7 from MAC */
-#define BIT_R_TXPWR_REG5(x)                                         ((u32)(((x) & 0x000000FF) << 8))
-#define BIT_GET_R_TXPWR_REG5(x)                                     ((u32)(((x >> 8) & 0x000000FF)))
-#define BIT_MASK_R_TXPWR_REG4                                       ((u32)0x000000FF << 0)          /*!<R/W 0  S(8.1)pwr by macid when Pwr_mode=6 from MAC */
-#define BIT_R_TXPWR_REG4(x)                                         ((u32)(((x) & 0x000000FF) << 0))
-#define BIT_GET_R_TXPWR_REG4(x)                                     ((u32)(((x >> 0) & 0x000000FF)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_AX_PWR_RU_LMT_CTRL
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_MASK_R_TXAGC_LTE                                        ((u32)0x000001FF << 19)          /*!<R/W 0  S(9.2) Coexist LTE pwr dbm */
-#define BIT_R_TXAGC_LTE(x)                                          ((u32)(((x) & 0x000001FF) << 19))
-#define BIT_GET_R_TXAGC_LTE(x)                                      ((u32)(((x >> 19) & 0x000001FF)))
-#define BIT_R_TXPWR_RU_LIM_EN                                       ((u32)0x00000001 << 18)          /*!<R/W 1h  (RTL_only) 1:Ru lim indirect read */
-#define BIT_R_TXPWR_RU_LIM_TBL_RD                                   ((u32)0x00000001 << 17)          /*!<R/W 0  (RTL_only) 1:Ru lim indirect read */
-#define BIT_MASK_R_TXPWR_RU_LIM_TBL_RA                              ((u32)0x0000003F << 11)          /*!<R/W 0  (RTL_only) Ru lim indirect read addr */
-#define BIT_R_TXPWR_RU_LIM_TBL_RA(x)                                ((u32)(((x) & 0x0000003F) << 11))
-#define BIT_GET_R_TXPWR_RU_LIM_TBL_RA(x)                            ((u32)(((x >> 11) & 0x0000003F)))
-#define BIT_R_FORCE_PWR_BY_RU_LIMIT_EN                              ((u32)0x00000001 << 10)          /*!<R/W 0  1: RU_lim = r_force_pwr_by_ru_limit_value */
-#define BIT_R_FORCE_PWR_BY_RU_LIMIT_EN_VALUE                        ((u32)0x00000001 << 9)          /*!<R/W 1h  (ru lim val is valid in HE_TB) */
-#define BIT_MASK_R_FORCE_PWR_BY_RU_LIMIT_VALUE                      ((u32)0x000001FF << 0)          /*!<R/W 0  Force RU lim_val enable */
-#define BIT_R_FORCE_PWR_BY_RU_LIMIT_VALUE(x)                        ((u32)(((x) & 0x000001FF) << 0))
-#define BIT_GET_R_FORCE_PWR_BY_RU_LIMIT_VALUE(x)                    ((u32)(((x >> 0) & 0x000001FF)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_AX_PWR_COEXT_CTRL
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_MASK_R_CCK_NORM_TERM                                    ((u32)0x0000007F << 18)          /*!<R/W 7Ah  (RTL_only) u(6.4) Map txpwr_bb to txpwr_mac 0x7A=20log(20/11)=2.625 */
-#define BIT_R_CCK_NORM_TERM(x)                                      ((u32)(((x) & 0x0000007F) << 18))
-#define BIT_GET_R_CCK_NORM_TERM(x)                                  ((u32)(((x >> 18) & 0x0000007F)))
-#define BIT_MASK_R_TXPWR_MAC_MAX_BND                                ((u32)0x0000003F << 12)          /*!<R/W 3Fh  (RTL_only) u(6.0) txpwr mac max bnd dB */
-#define BIT_R_TXPWR_MAC_MAX_BND(x)                                  ((u32)(((x) & 0x0000003F) << 12))
-#define BIT_GET_R_TXPWR_MAC_MAX_BND(x)                              ((u32)(((x >> 12) & 0x0000003F)))
-#define BIT_MASK_R_TXAGC_BT                                         ((u32)0x000001FF << 3)          /*!<R/W 0  S(9.2) Coexist BT pwr dbm */
-#define BIT_R_TXAGC_BT(x)                                           ((u32)(((x) & 0x000001FF) << 3))
-#define BIT_GET_R_TXAGC_BT(x)                                       ((u32)(((x >> 3) & 0x000001FF)))
-#define BIT_R_TXAGC_LTE_EN                                          ((u32)0x00000001 << 2)          /*!<R/W 1h  Coexist LTE_en */
-#define BIT_R_TXAGC_BT_EN                                           ((u32)0x00000001 << 1)          /*!<R/W 1h  Coexist BT_en */
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_AX_PWR_SWING_LEG_CTRL
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_MASK_R_TXBIAS_LEGACY_BELOW_TH_VAL                       ((u32)0x00000003 << 29)          /*!<R/W 0  Bbswing , txbias mcs below th sel this */
-#define BIT_R_TXBIAS_LEGACY_BELOW_TH_VAL(x)                         ((u32)(((x) & 0x00000003) << 29))
-#define BIT_GET_R_TXBIAS_LEGACY_BELOW_TH_VAL(x)                     ((u32)(((x >> 29) & 0x00000003)))
-#define BIT_MASK_R_TXBIAS_LEGACY_OV_TH_VAL                          ((u32)0x00000003 << 27)          /*!<R/W 0  Bbswing ,txbias mcs ov th sel this */
-#define BIT_R_TXBIAS_LEGACY_OV_TH_VAL(x)                            ((u32)(((x) & 0x00000003) << 27))
-#define BIT_GET_R_TXBIAS_LEGACY_OV_TH_VAL(x)                        ((u32)(((x >> 27) & 0x00000003)))
-#define BIT_MASK_R_TXBBSWING_LEGACY_BELOW_TH_VAL                    ((u32)0x0000000F << 23)          /*!<R/W 0  Bbswing ,txbias mcs below th sel this */
-#define BIT_R_TXBBSWING_LEGACY_BELOW_TH_VAL(x)                      ((u32)(((x) & 0x0000000F) << 23))
-#define BIT_GET_R_TXBBSWING_LEGACY_BELOW_TH_VAL(x)                  ((u32)(((x >> 23) & 0x0000000F)))
-#define BIT_MASK_R_TXBBSWING_LEGACY_OV_TH_VAL                       ((u32)0x0000000F << 19)          /*!<R/W 0  Bbswing ,txbias mcs ov th sel this */
-#define BIT_R_TXBBSWING_LEGACY_OV_TH_VAL(x)                         ((u32)(((x) & 0x0000000F) << 19))
-#define BIT_GET_R_TXBBSWING_LEGACY_OV_TH_VAL(x)                     ((u32)(((x >> 19) & 0x0000000F)))
-#define BIT_MASK_R_TXBBSWING_TXBIAS_LEGACY_TH                       ((u32)0x0000000F << 15)          /*!<R/W 4h  0~4 Bbswing txbias mcs th */
-#define BIT_R_TXBBSWING_TXBIAS_LEGACY_TH(x)                         ((u32)(((x) & 0x0000000F) << 15))
-#define BIT_GET_R_TXBBSWING_TXBIAS_LEGACY_TH(x)                     ((u32)(((x >> 15) & 0x0000000F)))
-#define BIT_MASK_R_TXBIAS_CCK_BELOW_TH_VAL                          ((u32)0x00000003 << 13)          /*!<R/W 0  Bbswing ,txbias mcs below th sel this */
-#define BIT_R_TXBIAS_CCK_BELOW_TH_VAL(x)                            ((u32)(((x) & 0x00000003) << 13))
-#define BIT_GET_R_TXBIAS_CCK_BELOW_TH_VAL(x)                        ((u32)(((x >> 13) & 0x00000003)))
-#define BIT_MASK_R_TXBIAS_CCK_OV_TH_VAL                             ((u32)0x00000003 << 11)          /*!<R/W 0  Bbswing ,txbias mcs ov th sel this */
-#define BIT_R_TXBIAS_CCK_OV_TH_VAL(x)                               ((u32)(((x) & 0x00000003) << 11))
-#define BIT_GET_R_TXBIAS_CCK_OV_TH_VAL(x)                           ((u32)(((x >> 11) & 0x00000003)))
-#define BIT_MASK_R_TXBBSWING_CCK_BELOW_TH_VAL                       ((u32)0x0000000F << 7)          /*!<R/W 0  Bbswing ,txbias mcs below th sel this */
-#define BIT_R_TXBBSWING_CCK_BELOW_TH_VAL(x)                         ((u32)(((x) & 0x0000000F) << 7))
-#define BIT_GET_R_TXBBSWING_CCK_BELOW_TH_VAL(x)                     ((u32)(((x >> 7) & 0x0000000F)))
-#define BIT_MASK_R_TXBBSWING_CCK_OV_TH_VAL                          ((u32)0x0000000F << 3)          /*!<R/W 0  Bbswing ,txbias mcs ov th sel this */
-#define BIT_R_TXBBSWING_CCK_OV_TH_VAL(x)                            ((u32)(((x) & 0x0000000F) << 3))
-#define BIT_GET_R_TXBBSWING_CCK_OV_TH_VAL(x)                        ((u32)(((x >> 3) & 0x0000000F)))
-#define BIT_MASK_R_TXBBSWING_TXBIAS_CCK_TH                          ((u32)0x00000007 << 0)          /*!<R/W 0  0~4 Bbswing txbias mcs th */
-#define BIT_R_TXBBSWING_TXBIAS_CCK_TH(x)                            ((u32)(((x) & 0x00000007) << 0))
-#define BIT_GET_R_TXBBSWING_TXBIAS_CCK_TH(x)                        ((u32)(((x >> 0) & 0x00000007)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_AX_PWR_SWING_VHT_CTRL
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_MASK_R_TXBIAS_VHT_OV_TH_VAL                             ((u32)0x00000003 << 30)          /*!<R/W 0  Bbswing ,txbias mcs ov th sel this */
-#define BIT_R_TXBIAS_VHT_OV_TH_VAL(x)                               ((u32)(((x) & 0x00000003) << 30))
-#define BIT_GET_R_TXBIAS_VHT_OV_TH_VAL(x)                           ((u32)(((x >> 30) & 0x00000003)))
-#define BIT_MASK_R_TXBBSWING_VHT_BELOW_TH_VAL                       ((u32)0x0000000F << 26)          /*!<R/W 0  Bbswing ,txbias mcs below th sel this */
-#define BIT_R_TXBBSWING_VHT_BELOW_TH_VAL(x)                         ((u32)(((x) & 0x0000000F) << 26))
-#define BIT_GET_R_TXBBSWING_VHT_BELOW_TH_VAL(x)                     ((u32)(((x >> 26) & 0x0000000F)))
-#define BIT_MASK_R_TXBBSWING_VHT_OV_TH_VAL                          ((u32)0x0000000F << 22)          /*!<R/W 0  Bbswing ,txbias mcs ov th sel this */
-#define BIT_R_TXBBSWING_VHT_OV_TH_VAL(x)                            ((u32)(((x) & 0x0000000F) << 22))
-#define BIT_GET_R_TXBBSWING_VHT_OV_TH_VAL(x)                        ((u32)(((x >> 22) & 0x0000000F)))
-#define BIT_MASK_R_TXBBSWING_TXBIAS_VHT_TH                          ((u32)0x0000000F << 18)          /*!<R/W 0  0~12 Bbswing txbias mcs th */
-#define BIT_R_TXBBSWING_TXBIAS_VHT_TH(x)                            ((u32)(((x) & 0x0000000F) << 18))
-#define BIT_GET_R_TXBBSWING_TXBIAS_VHT_TH(x)                        ((u32)(((x >> 18) & 0x0000000F)))
-#define BIT_MASK_R_TXBIAS_HT_BELOW_TH_VAL                           ((u32)0x00000003 << 16)          /*!<R/W 0  Bbswing ,txbias mcs below th sel this */
-#define BIT_R_TXBIAS_HT_BELOW_TH_VAL(x)                             ((u32)(((x) & 0x00000003) << 16))
-#define BIT_GET_R_TXBIAS_HT_BELOW_TH_VAL(x)                         ((u32)(((x >> 16) & 0x00000003)))
-#define BIT_MASK_R_TXBIAS_HT_OV_TH_VAL                              ((u32)0x00000003 << 14)          /*!<R/W 0  Bbswing ,txbias mcs ov th sel this */
-#define BIT_R_TXBIAS_HT_OV_TH_VAL(x)                                ((u32)(((x) & 0x00000003) << 14))
-#define BIT_GET_R_TXBIAS_HT_OV_TH_VAL(x)                            ((u32)(((x >> 14) & 0x00000003)))
-#define BIT_MASK_R_TXBBSWING_HT_BELOW_TH_VAL                        ((u32)0x0000000F << 10)          /*!<R/W 0  Bbswing ,txbias mcs below th sel this */
-#define BIT_R_TXBBSWING_HT_BELOW_TH_VAL(x)                          ((u32)(((x) & 0x0000000F) << 10))
-#define BIT_GET_R_TXBBSWING_HT_BELOW_TH_VAL(x)                      ((u32)(((x >> 10) & 0x0000000F)))
-#define BIT_MASK_R_TXBBSWING_HT_OV_TH_VAL                           ((u32)0x0000000F << 6)          /*!<R/W 0  Bbswing ,txbias mcs ov th sel this */
-#define BIT_R_TXBBSWING_HT_OV_TH_VAL(x)                             ((u32)(((x) & 0x0000000F) << 6))
-#define BIT_GET_R_TXBBSWING_HT_OV_TH_VAL(x)                         ((u32)(((x >> 6) & 0x0000000F)))
-#define BIT_MASK_R_TXBBSWING_TXBIAS_HT_TH                           ((u32)0x0000000F << 2)          /*!<R/W 0  0~8 Bbswing txbias mcs th */
-#define BIT_R_TXBBSWING_TXBIAS_HT_TH(x)                             ((u32)(((x) & 0x0000000F) << 2))
-#define BIT_GET_R_TXBBSWING_TXBIAS_HT_TH(x)                         ((u32)(((x >> 2) & 0x0000000F)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_AX_PWR_SWING_HE_CTRL
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_R_DPD_BY_RATE_OFF_LEGACY_BELOW_TH_VAL                   ((u32)0x00000001 << 28)          /*!<R/W 0  Bbswing ,txbias mcs below th sel this */
-#define BIT_R_DPD_BY_RATE_OFF_LEGACY_OV_TH_VAL                      ((u32)0x00000001 << 27)          /*!<R/W 0  Bbswing ,txbias mcs ov th sel this */
-#define BIT_MASK_R_DPD_BY_RATE_OFF_LEGACY_TH                        ((u32)0x0000000F << 23)          /*!<R/W 0  4~8 Bbswing txbias mcs th */
-#define BIT_R_DPD_BY_RATE_OFF_LEGACY_TH(x)                          ((u32)(((x) & 0x0000000F) << 23))
-#define BIT_GET_R_DPD_BY_RATE_OFF_LEGACY_TH(x)                      ((u32)(((x >> 23) & 0x0000000F)))
-#define BIT_R_DPD_BY_RATE_OFF_CCK_BELOW_TH_VAL                      ((u32)0x00000001 << 22)          /*!<R/W 0  Bbswing ,txbias mcs below th sel this */
-#define BIT_R_DPD_BY_RATE_OFF_CCK_OV_TH_VAL                         ((u32)0x00000001 << 21)          /*!<R/W 0  Bbswing ,txbias mcs ov th sel this */
-#define BIT_MASK_R_DPD_BY_RATE_OFF_CCK_TH                           ((u32)0x00000007 << 18)          /*!<R/W 0  0~4 Bbswing txbias mcs th */
-#define BIT_R_DPD_BY_RATE_OFF_CCK_TH(x)                             ((u32)(((x) & 0x00000007) << 18))
-#define BIT_GET_R_DPD_BY_RATE_OFF_CCK_TH(x)                         ((u32)(((x >> 18) & 0x00000007)))
-#define BIT_MASK_R_TXBIAS_HE_BELOW_TH_VAL                           ((u32)0x00000003 << 16)          /*!<R/W 0  Bbswing ,txbias mcs below th sel this */
-#define BIT_R_TXBIAS_HE_BELOW_TH_VAL(x)                             ((u32)(((x) & 0x00000003) << 16))
-#define BIT_GET_R_TXBIAS_HE_BELOW_TH_VAL(x)                         ((u32)(((x >> 16) & 0x00000003)))
-#define BIT_MASK_R_TXBIAS_HE_OV_TH_VAL                              ((u32)0x00000003 << 14)          /*!<R/W 0  Bbswing ,txbias mcs ov th sel this */
-#define BIT_R_TXBIAS_HE_OV_TH_VAL(x)                                ((u32)(((x) & 0x00000003) << 14))
-#define BIT_GET_R_TXBIAS_HE_OV_TH_VAL(x)                            ((u32)(((x >> 14) & 0x00000003)))
-#define BIT_MASK_R_TXBBSWING_HE_BELOW_TH_VAL                        ((u32)0x0000000F << 10)          /*!<R/W 0  Bbswing ,txbias mcs below th sel this */
-#define BIT_R_TXBBSWING_HE_BELOW_TH_VAL(x)                          ((u32)(((x) & 0x0000000F) << 10))
-#define BIT_GET_R_TXBBSWING_HE_BELOW_TH_VAL(x)                      ((u32)(((x >> 10) & 0x0000000F)))
-#define BIT_MASK_R_TXBBSWING_HE_OV_TH_VAL                           ((u32)0x0000000F << 6)          /*!<R/W 0  Bbswing ,txbias mcs ov th sel this */
-#define BIT_R_TXBBSWING_HE_OV_TH_VAL(x)                             ((u32)(((x) & 0x0000000F) << 6))
-#define BIT_GET_R_TXBBSWING_HE_OV_TH_VAL(x)                         ((u32)(((x >> 6) & 0x0000000F)))
-#define BIT_MASK_R_TXBBSWING_TXBIAS_HE_TH                           ((u32)0x0000000F << 2)          /*!<R/W 0  0~12 Bbswing txbias mcs th */
-#define BIT_R_TXBBSWING_TXBIAS_HE_TH(x)                             ((u32)(((x) & 0x0000000F) << 2))
-#define BIT_GET_R_TXBBSWING_TXBIAS_HE_TH(x)                         ((u32)(((x >> 2) & 0x0000000F)))
-#define BIT_MASK_R_TXBIAS_VHT_BELOW_TH_VAL                          ((u32)0x00000003 << 0)          /*!<R/W 0  Bbswing ,txbias mcs ov th sel this */
-#define BIT_R_TXBIAS_VHT_BELOW_TH_VAL(x)                            ((u32)(((x) & 0x00000003) << 0))
-#define BIT_GET_R_TXBIAS_VHT_BELOW_TH_VAL(x)                        ((u32)(((x >> 0) & 0x00000003)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_AX_PWR_SWING_OTHER_CTRL0
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_R_CFIR_BY_RATE_OFF_LEGACY_BELOW_TH_VAL                  ((u32)0x00000001 << 28)          /*!<R/W 0  dpd by rate off mcs below th sel this */
-#define BIT_R_CFIR_BY_RATE_OFF_LEGACY_OV_TH_VAL                     ((u32)0x00000001 << 27)          /*!<R/W 0  dpd by rate off mcs ov th sel this */
-#define BIT_MASK_R_CFIR_BY_RATE_OFF_LEGACY_TH                       ((u32)0x0000000F << 23)          /*!<R/W 0  4~8 dpd by rate off mcs ov th */
-#define BIT_R_CFIR_BY_RATE_OFF_LEGACY_TH(x)                         ((u32)(((x) & 0x0000000F) << 23))
-#define BIT_GET_R_CFIR_BY_RATE_OFF_LEGACY_TH(x)                     ((u32)(((x >> 23) & 0x0000000F)))
-#define BIT_R_CFIR_BY_RATE_OFF_CCK_BELOW_TH_VAL                     ((u32)0x00000001 << 22)          /*!<R/W 0  dpd by rate off mcs below th sel this */
-#define BIT_R_CFIR_BY_RATE_OFF_CCK_OV_TH_VAL                        ((u32)0x00000001 << 21)          /*!<R/W 0  dpd by rate off mcs ov th sel this */
-#define BIT_MASK_R_CFIR_BY_RATE_OFF_CCK_TH                          ((u32)0x00000007 << 18)          /*!<R/W 0  0~4 dpd by rate off mcs th */
-#define BIT_R_CFIR_BY_RATE_OFF_CCK_TH(x)                            ((u32)(((x) & 0x00000007) << 18))
-#define BIT_GET_R_CFIR_BY_RATE_OFF_CCK_TH(x)                        ((u32)(((x >> 18) & 0x00000007)))
-#define BIT_R_DPD_BY_RATE_OFF_HE_BELOW_TH_VAL                       ((u32)0x00000001 << 17)          /*!<R/W 0  cfir by rate_off mcs below th sel this */
-#define BIT_R_DPD_BY_RATE_OFF_HE_OV_TH_VAL                          ((u32)0x00000001 << 16)          /*!<R/W 0  cfir by rate_off mcs ov th sel this */
-#define BIT_MASK_R_DPD_BY_RATE_OFF_HE_TH                            ((u32)0x0000000F << 12)          /*!<R/W 0  0~12 cfir by rate_off mcs th */
-#define BIT_R_DPD_BY_RATE_OFF_HE_TH(x)                              ((u32)(((x) & 0x0000000F) << 12))
-#define BIT_GET_R_DPD_BY_RATE_OFF_HE_TH(x)                          ((u32)(((x >> 12) & 0x0000000F)))
-#define BIT_R_DPD_BY_RATE_OFF_VHT_BELOW_TH_VAL                      ((u32)0x00000001 << 11)          /*!<R/W 0  cfir by rate_off mcs below th sel this */
-#define BIT_R_DPD_BY_RATE_OFF_VHT_OV_TH_VAL                         ((u32)0x00000001 << 10)          /*!<R/W 0  cfir by rate_off mcs ov th sel this */
-#define BIT_MASK_R_DPD_BY_RATE_OFF_VHT_TH                           ((u32)0x0000000F << 6)          /*!<R/W 0  0~12 cfir by rate_off mcs th */
-#define BIT_R_DPD_BY_RATE_OFF_VHT_TH(x)                             ((u32)(((x) & 0x0000000F) << 6))
-#define BIT_GET_R_DPD_BY_RATE_OFF_VHT_TH(x)                         ((u32)(((x >> 6) & 0x0000000F)))
-#define BIT_R_DPD_BY_RATE_OFF_HT_BELOW_TH_VAL                       ((u32)0x00000001 << 5)          /*!<R/W 0  cfir by rate_off mcs below th sel this */
-#define BIT_R_DPD_BY_RATE_OFF_HT_OV_TH_VAL                          ((u32)0x00000001 << 4)          /*!<R/W 0  cfir by rate_off mcs ov th sel this */
-#define BIT_MASK_R_DPD_BY_RATE_OFF_HT_TH                            ((u32)0x0000000F << 0)          /*!<R/W 0  0~8 cfir by rate_off mcs th */
-#define BIT_R_DPD_BY_RATE_OFF_HT_TH(x)                              ((u32)(((x) & 0x0000000F) << 0))
-#define BIT_GET_R_DPD_BY_RATE_OFF_HT_TH(x)                          ((u32)(((x >> 0) & 0x0000000F)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_AX_PWR_SWING_OTHER_CTRL1
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_R_CFIR_BY_RATE_OFF_SR_DONT_APPLY                        ((u32)0x00000001 << 30)          /*!<R/W 0  (RTL_only) 1:Disable at SR */
-#define BIT_R_DPD_BY_RATE_OFF_SR_DONT_APPLY                         ((u32)0x00000001 << 29)          /*!<R/W 0  (RTL_only) 1:Disable at SR */
-#define BIT_R_TXBBSWING_TXBIAS_SR_DONT_APPLY                        ((u32)0x00000001 << 28)          /*!<R/W 0  (RTL_only) 1:Disable at SR */
-#define BIT_R_CFIR_BY_RATE_OFF_HE_BELOW_TH_VAL                      ((u32)0x00000001 << 17)          /*!<R/W 0  dpd by rate off mcs below th sel this */
-#define BIT_R_CFIR_BY_RATE_OFF_HE_OV_TH_VAL                         ((u32)0x00000001 << 16)          /*!<R/W 0  dpd by rate off mcs ov th sel this */
-#define BIT_MASK_R_CFIR_BY_RATE_OFF_HE_TH                           ((u32)0x0000000F << 12)          /*!<R/W 0  0~12 dpd by rate off mcs ov th */
-#define BIT_R_CFIR_BY_RATE_OFF_HE_TH(x)                             ((u32)(((x) & 0x0000000F) << 12))
-#define BIT_GET_R_CFIR_BY_RATE_OFF_HE_TH(x)                         ((u32)(((x >> 12) & 0x0000000F)))
-#define BIT_R_CFIR_BY_RATE_OFF_VHT_BELOW_TH_VAL                     ((u32)0x00000001 << 11)          /*!<R/W 0  dpd by rate off mcs below th sel this */
-#define BIT_R_CFIR_BY_RATE_OFF_VHT_OV_TH_VAL                        ((u32)0x00000001 << 10)          /*!<R/W 0  dpd by rate off mcs ov th sel this */
-#define BIT_MASK_R_CFIR_BY_RATE_OFF_VHT_TH                          ((u32)0x0000000F << 6)          /*!<R/W 0  0~12 dpd by rate off mcs ov th */
-#define BIT_R_CFIR_BY_RATE_OFF_VHT_TH(x)                            ((u32)(((x) & 0x0000000F) << 6))
-#define BIT_GET_R_CFIR_BY_RATE_OFF_VHT_TH(x)                        ((u32)(((x >> 6) & 0x0000000F)))
-#define BIT_R_CFIR_BY_RATE_OFF_HT_BELOW_TH_VAL                      ((u32)0x00000001 << 5)          /*!<R/W 0  dpd by rate off mcs below th sel this */
-#define BIT_R_CFIR_BY_RATE_OFF_HT_OV_TH_VAL                         ((u32)0x00000001 << 4)          /*!<R/W 0  dpd by rate off mcs ov th sel this */
-#define BIT_MASK_R_CFIR_BY_RATE_OFF_HT_TH                           ((u32)0x0000000F << 0)          /*!<R/W 0  0~8 dpd by rate off mcs ov th */
-#define BIT_R_CFIR_BY_RATE_OFF_HT_TH(x)                             ((u32)(((x) & 0x0000000F) << 0))
-#define BIT_GET_R_CFIR_BY_RATE_OFF_HT_TH(x)                         ((u32)(((x >> 0) & 0x0000000F)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_AX_PWR_SR_CTRL0
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_R_SR_PWR_CTRL_DBG_EN                                    ((u32)0x00000001 << 31)          /*!<R/W 1h  (RTL_only) 0:saving pwr */
-#define BIT_MASK_R_SR_RATE_TBL_RD_MCS_TXDIFF                        ((u32)0x0000001F << 20)          /*!<R/W 0  (RTL_only) Rd MEM idx 0~47 */
-#define BIT_R_SR_RATE_TBL_RD_MCS_TXDIFF(x)                          ((u32)(((x) & 0x0000001F) << 20))
-#define BIT_GET_R_SR_RATE_TBL_RD_MCS_TXDIFF(x)                      ((u32)(((x >> 20) & 0x0000001F)))
-#define BIT_R_SR_RATE_MAP_TBL_RD_MCS_SEL                            ((u32)0x00000001 << 19)          /*!<R/W 0  (RTL_only) 1:cckle 0~11 0:ht/vht/he 0~11 */
-#define BIT_R_TXPWR_SR_FORCE_OFF                                    ((u32)0x00000001 << 18)          /*!<R/W 0  (RTL_only) 1:force sr mode off */
-#define BIT_R_TXPWR_STA_UL_FORCE_OFF                                ((u32)0x00000001 << 17)          /*!<R/W 0  (RTL_only) 1:force sta mode off */
-#define BIT_R_SR_TXPWR_PD_WITH_PD_MACID                             ((u32)0x00000001 << 16)          /*!<R/W 1h  (RTL_only) 1:txpwr_PD from internal buffer 0: from MAC */
-#define BIT_R_SR_RATE_MAP_TBL_RD                                    ((u32)0x00000001 << 15)          /*!<R/W 0  (RTL_only) 1:indirect read of addr */
-#define BIT_MASK_R_SR_RATE_MAP_TBL_RD_MCS                           ((u32)0x0000000F << 11)          /*!<R/W 0  (RTL_only) indirect read of addr */
-#define BIT_R_SR_RATE_MAP_TBL_RD_MCS(x)                             ((u32)(((x) & 0x0000000F) << 11))
-#define BIT_GET_R_SR_RATE_MAP_TBL_RD_MCS(x)                         ((u32)(((x >> 11) & 0x0000000F)))
-#define BIT_R_TXPWR_CTRL_NORM_RESP_DBG_EN                           ((u32)0x00000001 << 10)          /*!<R/W 1h  (RTL_only) 0:dbg clk off for saving pwr */
-#define BIT_R_TXAGC_PSEUDO_PWR_EN                                   ((u32)0x00000001 << 9)          /*!<R/W 0  (RTL_only) 1: force on norm resp out txpwr_bb */
-#define BIT_MASK_R_TXAGC_PSEUDO_PWR                                 ((u32)0x000001FF << 0)          /*!<R/W 0  (RTL_only) S(9.2) force norm resp out txpwr_bb */
-#define BIT_R_TXAGC_PSEUDO_PWR(x)                                   ((u32)(((x) & 0x000001FF) << 0))
-#define BIT_GET_R_TXAGC_PSEUDO_PWR(x)                               ((u32)(((x >> 0) & 0x000001FF)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_AX_PWR_SR_CTRL1
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_MASK_R_MCS_TH_HE                                        ((u32)0x0000000F << 24)          /*!<R/W Bh  SR MCS0~MCS11 */
-#define BIT_R_MCS_TH_HE(x)                                          ((u32)(((x) & 0x0000000F) << 24))
-#define BIT_GET_R_MCS_TH_HE(x)                                      ((u32)(((x >> 24) & 0x0000000F)))
-#define BIT_MASK_R_MCS_TH_VHT                                       ((u32)0x0000000F << 20)          /*!<R/W Bh  SR MCS0~MCS11 */
-#define BIT_R_MCS_TH_VHT(x)                                         ((u32)(((x) & 0x0000000F) << 20))
-#define BIT_GET_R_MCS_TH_VHT(x)                                     ((u32)(((x >> 20) & 0x0000000F)))
-#define BIT_MASK_R_MCS_TH_HT_MOD8                                   ((u32)0x0000000F << 16)          /*!<R/W 7h  SR MCS0~MCS7 */
-#define BIT_R_MCS_TH_HT_MOD8(x)                                     ((u32)(((x) & 0x0000000F) << 16))
-#define BIT_GET_R_MCS_TH_HT_MOD8(x)                                 ((u32)(((x >> 16) & 0x0000000F)))
-#define BIT_MASK_R_MCS_TH_LEGACY                                    ((u32)0x0000000F << 12)          /*!<R/W 7h  SR 4~11 */
-#define BIT_R_MCS_TH_LEGACY(x)                                      ((u32)(((x) & 0x0000000F) << 12))
-#define BIT_GET_R_MCS_TH_LEGACY(x)                                  ((u32)(((x >> 12) & 0x0000000F)))
-#define BIT_MASK_R_MCS_TH_CCK                                       ((u32)0x0000000F << 8)          /*!<R/W 3h  SR 0~3 */
-#define BIT_R_MCS_TH_CCK(x)                                         ((u32)(((x) & 0x0000000F) << 8))
-#define BIT_GET_R_MCS_TH_CCK(x)                                     ((u32)(((x >> 8) & 0x0000000F)))
-#define BIT_MASK_R_TXPWR_REF                                        ((u32)0x0000007F << 0)          /*!<R/W 15h  SR txpwr ref(txpwr_mcs diff) */
-#define BIT_R_TXPWR_REF(x)                                          ((u32)(((x) & 0x0000007F) << 0))
-#define BIT_GET_R_TXPWR_REF(x)                                      ((u32)(((x >> 0) & 0x0000007F)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_AX_PWR_UL_CTRL0
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_R_BYPASS_ABORT_TX_FLAG                                  ((u32)0x00000001 << 29)          /*!<R/W 0  1: force off abort_tx flag STA_UL */
-#define BIT_MASK_R_PL_TOLER_RANGE                                   ((u32)0x000001FF << 20)          /*!<R/W 0  U(9.2) STA_UL */
-#define BIT_R_PL_TOLER_RANGE(x)                                     ((u32)(((x) & 0x000001FF) << 20))
-#define BIT_GET_R_PL_TOLER_RANGE(x)                                 ((u32)(((x >> 20) & 0x000001FF)))
-#define BIT_MASK_R_PWR_BB_MIN_DBM                                   ((u32)0x000001FF << 9)          /*!<R/W 1FCh  S(9.2) STA_UL */
-#define BIT_R_PWR_BB_MIN_DBM(x)                                     ((u32)(((x) & 0x000001FF) << 9))
-#define BIT_GET_R_PWR_BB_MIN_DBM(x)                                 ((u32)(((x >> 9) & 0x000001FF)))
-#define BIT_MASK_R_PWR_ERROR_TOLER                                  ((u32)0x000000FF << 0)          /*!<R/W 8h  S(9.2) STA_UL */
-#define BIT_R_PWR_ERROR_TOLER(x)                                    ((u32)(((x) & 0x000000FF) << 0))
-#define BIT_GET_R_PWR_ERROR_TOLER(x)                                ((u32)(((x >> 0) & 0x000000FF)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_AX_PWR_UL_CTRL1
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_MASK_R_MACID3                                           ((u32)0x0000007F << 24)          /*!<R/W 0  STA_UL */
-#define BIT_R_MACID3(x)                                             ((u32)(((x) & 0x0000007F) << 24))
-#define BIT_GET_R_MACID3(x)                                         ((u32)(((x >> 24) & 0x0000007F)))
-#define BIT_MASK_R_MACID2                                           ((u32)0x0000007F << 16)          /*!<R/W 0  STA_UL */
-#define BIT_R_MACID2(x)                                             ((u32)(((x) & 0x0000007F) << 16))
-#define BIT_GET_R_MACID2(x)                                         ((u32)(((x >> 16) & 0x0000007F)))
-#define BIT_MASK_R_MACID1                                           ((u32)0x0000007F << 8)          /*!<R/W 0  STA_UL */
-#define BIT_R_MACID1(x)                                             ((u32)(((x) & 0x0000007F) << 8))
-#define BIT_GET_R_MACID1(x)                                         ((u32)(((x >> 8) & 0x0000007F)))
-#define BIT_MASK_R_MACID0                                           ((u32)0x0000007F << 0)          /*!<R/W 0  STA_UL */
-#define BIT_R_MACID0(x)                                             ((u32)(((x) & 0x0000007F) << 0))
-#define BIT_GET_R_MACID0(x)                                         ((u32)(((x >> 0) & 0x0000007F)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_AX_PWR_UL_CTRL2
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_MASK_R_CFO_COMP_SR                                      ((u32)0x00000007 << 24)          /*!<R/W 7h  (RTL_only) STA_UL no need to set */
-#define BIT_R_CFO_COMP_SR(x)                                        ((u32)(((x) & 0x00000007) << 24))
-#define BIT_GET_R_CFO_COMP_SR(x)                                    ((u32)(((x >> 24) & 0x00000007)))
-#define BIT_MASK_R_CFO_COMP_NORM_RESP                               ((u32)0x00000007 << 20)          /*!<R/W 7h  (RTL_only) STA_UL no need to set */
-#define BIT_R_CFO_COMP_NORM_RESP(x)                                 ((u32)(((x) & 0x00000007) << 20))
-#define BIT_GET_R_CFO_COMP_NORM_RESP(x)                             ((u32)(((x >> 20) & 0x00000007)))
-#define BIT_MASK_R_CFO_COMP4                                        ((u32)0x00000007 << 16)          /*!<R/W 6h  (RTL_only) STA_UL Default 6 no need to set */
-#define BIT_R_CFO_COMP4(x)                                          ((u32)(((x) & 0x00000007) << 16))
-#define BIT_GET_R_CFO_COMP4(x)                                      ((u32)(((x >> 16) & 0x00000007)))
-#define BIT_MASK_R_CFO_COMP3                                        ((u32)0x00000007 << 12)          /*!<R/W 7h  STA_UL */
-#define BIT_R_CFO_COMP3(x)                                          ((u32)(((x) & 0x00000007) << 12))
-#define BIT_GET_R_CFO_COMP3(x)                                      ((u32)(((x >> 12) & 0x00000007)))
-#define BIT_MASK_R_CFO_COMP2                                        ((u32)0x00000007 << 8)          /*!<R/W 7h  STA_UL */
-#define BIT_R_CFO_COMP2(x)                                          ((u32)(((x) & 0x00000007) << 8))
-#define BIT_GET_R_CFO_COMP2(x)                                      ((u32)(((x >> 8) & 0x00000007)))
-#define BIT_MASK_R_CFO_COMP1                                        ((u32)0x00000007 << 4)          /*!<R/W 7h  STA_UL */
-#define BIT_R_CFO_COMP1(x)                                          ((u32)(((x) & 0x00000007) << 4))
-#define BIT_GET_R_CFO_COMP1(x)                                      ((u32)(((x >> 4) & 0x00000007)))
-#define BIT_MASK_R_CFO_COMP0                                        ((u32)0x00000007 << 0)          /*!<R/W 7h  STA_UL */
-#define BIT_R_CFO_COMP0(x)                                          ((u32)(((x) & 0x00000007) << 0))
-#define BIT_GET_R_CFO_COMP0(x)                                      ((u32)(((x >> 0) & 0x00000007)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_AX_PWR_UL_CTRL3
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_R_TF_RDY_TXBF_FORCE_OFF                                 ((u32)0x00000001 << 22)          /*!<R/W 1h  (RTL_only) Jorden Sta_UL doesnt have TxBF */
-#define BIT_R_FORCE_PL_UPPER_EN_EQUL_N_TX_DIVIDE2                   ((u32)0x00000001 << 21)          /*!<R/W 0  (RTL_only) 1:PL_upper_en = is N_tx/2 */
-#define BIT_R_FORCE_N_TX_DIVIDE2_OFF                                ((u32)0x00000001 << 20)          /*!<R/W 0  (RTL_only) 1:force off N_tx/2 */
-#define BIT_MASK_R_STA_PWR_CTRL_PWRMAX_LIM_MAX                      ((u32)0x000001FF << 11)          /*!<R/W FFh  (RTL_only) S(9.2) Limit pwr from norm resp */
-#define BIT_R_STA_PWR_CTRL_PWRMAX_LIM_MAX(x)                        ((u32)(((x) & 0x000001FF) << 11))
-#define BIT_GET_R_STA_PWR_CTRL_PWRMAX_LIM_MAX(x)                    ((u32)(((x >> 11) & 0x000001FF)))
-#define BIT_MASK_R_STA_PWR_CTRL_PWRMAX_LIM_MIN                      ((u32)0x000001FF << 0)          /*!<R/W 100h  (RTL_only) S(9.2) Limit pwr from norm resp */
-#define BIT_R_STA_PWR_CTRL_PWRMAX_LIM_MIN(x)                        ((u32)(((x) & 0x000001FF) << 0))
-#define BIT_GET_R_STA_PWR_CTRL_PWRMAX_LIM_MIN(x)                    ((u32)(((x >> 0) & 0x000001FF)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_AX_PWR_UL_CTRL4
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_MASK_R_STA_PWR_CTRL_RPL_LIM_MIN                         ((u32)0x000003FF << 16)          /*!<R/W 248h  (RTL_only) S(10.2) Min=-110 (-440) Limit RPL */
-#define BIT_R_STA_PWR_CTRL_RPL_LIM_MIN(x)                           ((u32)(((x) & 0x000003FF) << 16))
-#define BIT_GET_R_STA_PWR_CTRL_RPL_LIM_MIN(x)                       ((u32)(((x >> 16) & 0x000003FF)))
-#define BIT_MASK_R_STA_PWR_CTRL_RSSI_TARGET_LIM_MAX                 ((u32)0x000000FF << 8)          /*!<R/W 0  (RTL_only) S(8.0) Max:0 Limit RSSI_Target */
-#define BIT_R_STA_PWR_CTRL_RSSI_TARGET_LIM_MAX(x)                   ((u32)(((x) & 0x000000FF) << 8))
-#define BIT_GET_R_STA_PWR_CTRL_RSSI_TARGET_LIM_MAX(x)               ((u32)(((x >> 8) & 0x000000FF)))
-#define BIT_MASK_R_STA_PWR_CTRL_RSSI_TARGET_LIM_MIN                 ((u32)0x000000FF << 0)          /*!<R/W 92h  (RTL_only) S(8.0) Min=-110 Limit RSSI_Target */
-#define BIT_R_STA_PWR_CTRL_RSSI_TARGET_LIM_MIN(x)                   ((u32)(((x) & 0x000000FF) << 0))
-#define BIT_GET_R_STA_PWR_CTRL_RSSI_TARGET_LIM_MIN(x)               ((u32)(((x >> 0) & 0x000000FF)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_AX_PWR_UL_CTRL5
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_R_SR_TXPWR_RESP_RDY                                     ((u32)0x00000001 << 28)          /*!<R/W 0  (RTL_only) 1: trig when r_SR_txpwr_resp_rdy_force_on */
-#define BIT_R_SR_TXPWR_PD_RDY                                       ((u32)0x00000001 << 27)          /*!<R/W 0  (RTL_only) 1: trig when r_SR_txpwr_pd_rdy_force_on */
-#define BIT_R_SR_TXPWR_RATE_RDY                                     ((u32)0x00000001 << 26)          /*!<R/W 0  (RTL_only) 1: trig when r_SR_txpwr_rate_rdy_force_on */
-#define BIT_R_TF_RDY                                                ((u32)0x00000001 << 25)          /*!<R/W 0  (RTL_only) 1: trig when r_TF_rdy_force_on */
-#define BIT_R_TXCTRL_INFO_RDY                                       ((u32)0x00000001 << 24)          /*!<R/W 0  (RTL_only) 1: trig when r_TxCtrl_info_rdy_force_on */
-#define BIT_R_FORCE_PL_UPPER_EN_VAL                                 ((u32)0x00000001 << 23)          /*!<R/W 0   */
-#define BIT_R_FORCE_PL_UPPER_EN_ON                                  ((u32)0x00000001 << 22)          /*!<R/W 0  (RTL_only) 1 : PL_upper_en = r_force_PL_upper_en_val */
-#define BIT_R_SR_TXPWR_RESP_RDY_FORCE_ON                            ((u32)0x00000001 << 15)          /*!<R/W 0  (RTL_only) 1:force off SR resp trigger */
-#define BIT_R_SR_TXPWR_PD_RDY_FORCE_ON                              ((u32)0x00000001 << 14)          /*!<R/W 0  (RTL_only) 1:force off SR MCS flow trigger */
-#define BIT_R_SR_TXPWR_RATE_RDY_FORCE_ON                            ((u32)0x00000001 << 13)          /*!<R/W 0  (RTL_only) 1:force off SR PD flow trigger */
-#define BIT_R_TF_RDY_FORCE_ON                                       ((u32)0x00000001 << 12)          /*!<R/W 0  (RTL_only) 1:force off TF trigger */
-#define BIT_R_TXCTRL_INFO_RDY_FORCE_ON                              ((u32)0x00000001 << 11)          /*!<R/W 0  (RTL_only) 1:force off norm resp trigger */
-#define BIT_R_STA_PWR_CTRL_DBG_EN                                   ((u32)0x00000001 << 10)          /*!<R/W 0  (RTL_only) 0: pwr saving */
-#define BIT_MASK_R_STA_PWR_CTRL_RPL_LIM_MAX                         ((u32)0x000003FF << 0)          /*!<R/W 0  (RTL_only) S(10.2) Max:0 Limit RPL */
-#define BIT_R_STA_PWR_CTRL_RPL_LIM_MAX(x)                           ((u32)(((x) & 0x000003FF) << 0))
-#define BIT_GET_R_STA_PWR_CTRL_RPL_LIM_MAX(x)                       ((u32)(((x >> 0) & 0x000003FF)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_AX_PWR_UL_CTRL6
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_MASK_R_STA_PWR_CTRL_AP_TXPWR_LIM_MIN                    ((u32)0x0000007F << 24)          /*!<R/W 6Ch  (RTL_only) S(7.0 ) MIN=-20 Limit AP TXPWR */
-#define BIT_R_STA_PWR_CTRL_AP_TXPWR_LIM_MIN(x)                      ((u32)(((x) & 0x0000007F) << 24))
-#define BIT_GET_R_STA_PWR_CTRL_AP_TXPWR_LIM_MIN(x)                  ((u32)(((x >> 24) & 0x0000007F)))
-#define BIT_MASK_R_STA_PWR_CTRL_AP_TXPWR_LIM_MAX                    ((u32)0x0000007F << 16)          /*!<R/W 28h  (RTL_only) S(7.0 ) MAX=+40 Limit AP TXPWR */
-#define BIT_R_STA_PWR_CTRL_AP_TXPWR_LIM_MAX(x)                      ((u32)(((x) & 0x0000007F) << 16))
-#define BIT_GET_R_STA_PWR_CTRL_AP_TXPWR_LIM_MAX(x)                  ((u32)(((x >> 16) & 0x0000007F)))
-#define BIT_R_TXPWR_FORCE_RATE_EN                                   ((u32)0x00000001 << 12)          /*!<R/W 0  (RTL_only) No use */
-#define BIT_MASK_R_TXPWR_FORCE_RATE                                 ((u32)0x00000FFF << 0)          /*!<R/W 0  (RTL_only) No use */
-#define BIT_R_TXPWR_FORCE_RATE(x)                                   ((u32)(((x) & 0x00000FFF) << 0))
-#define BIT_GET_R_TXPWR_FORCE_RATE(x)                               ((u32)(((x >> 0) & 0x00000FFF)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_AX_PWR_NORM_FORCE0
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_R_FORCE_MACID_EN                                        ((u32)0x00000001 << 30)          /*!<R/W 0  (RTL_only) Force input from MAC */
-#define BIT_MASK_R_FORCE_MACID_VALUE                                ((u32)0x0000007F << 23)          /*!<R/W 0  (RTL_only) Force input from MAC */
-#define BIT_R_FORCE_MACID_VALUE(x)                                  ((u32)(((x) & 0x0000007F) << 23))
-#define BIT_GET_R_FORCE_MACID_VALUE(x)                              ((u32)(((x >> 23) & 0x0000007F)))
-#define BIT_R_FORCE_BW80P80_EN_EN                                   ((u32)0x00000001 << 22)          /*!<R/W 0  (RTL_only) Force input from MAC */
-#define BIT_R_FORCE_BW80P80_EN_VALUE                                ((u32)0x00000001 << 21)          /*!<R/W 1h  (RTL_only) Force input from MAC */
-#define BIT_R_FORCE_RF_BW_IDX_EN                                    ((u32)0x00000001 << 20)          /*!<R/W 0  (RTL_only) Force input from MAC */
-#define BIT_MASK_R_FORCE_RF_BW_IDX_VALUE                            ((u32)0x00000003 << 18)          /*!<R/W 0  (RTL_only) Force input from MAC */
-#define BIT_R_FORCE_RF_BW_IDX_VALUE(x)                              ((u32)(((x) & 0x00000003) << 18))
-#define BIT_GET_R_FORCE_RF_BW_IDX_VALUE(x)                          ((u32)(((x >> 18) & 0x00000003)))
-#define BIT_R_FORCE_DCM_EN                                          ((u32)0x00000001 << 17)          /*!<R/W 0  (RTL_only) Force input from MAC */
-#define BIT_R_FORCE_DCM_VALUE                                       ((u32)0x00000001 << 16)          /*!<R/W 0  (RTL_only) Force input from MAC */
-#define BIT_R_FORCE_DBW_IDX_EN                                      ((u32)0x00000001 << 15)          /*!<R/W 0  (RTL_only) Force input from MAC */
-#define BIT_MASK_R_FORCE_DBW_IDX_VALUE                              ((u32)0x00000003 << 13)          /*!<R/W 0  (RTL_only) Force input from MAC */
-#define BIT_R_FORCE_DBW_IDX_VALUE(x)                                ((u32)(((x) & 0x00000003) << 13))
-#define BIT_GET_R_FORCE_DBW_IDX_VALUE(x)                            ((u32)(((x >> 13) & 0x00000003)))
-#define BIT_R_FORCE_MAX_RATE_EN                                     ((u32)0x00000001 << 12)          /*!<R/W 0  (RTL_only) Force input from MAC */
-#define BIT_MASK_R_FORCE_MAX_RATE_VALUE                             ((u32)0x00000FFF << 0)          /*!<R/W 0  (RTL_only) Force input from MAC */
-#define BIT_R_FORCE_MAX_RATE_VALUE(x)                               ((u32)(((x) & 0x00000FFF) << 0))
-#define BIT_GET_R_FORCE_MAX_RATE_VALUE(x)                           ((u32)(((x >> 0) & 0x00000FFF)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_AX_PWR_NORM_FORCE1
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_R_TXAGC_BF_PWR_BOOST_FORCE_VAL_EN                       ((u32)0x00000001 << 29)          /*!<R/W 0  (RTL_only) Force input from MAC en */
-#define BIT_MASK_R_TXAGC_BF_PWR_BOOST_FORCE_VAL                     ((u32)0x0000001F << 24)          /*!<R/W 0  (RTL_only) Force input from MAC */
-#define BIT_R_TXAGC_BF_PWR_BOOST_FORCE_VAL(x)                       ((u32)(((x) & 0x0000001F) << 24))
-#define BIT_GET_R_TXAGC_BF_PWR_BOOST_FORCE_VAL(x)                   ((u32)(((x >> 24) & 0x0000001F)))
-#define BIT_R_FORCE_HE_ER_SU_EN_EN                                  ((u32)0x00000001 << 23)          /*!<R/W 0  (RTL_only) Force input from MAC en */
-#define BIT_R_FORCE_HE_ER_SU_EN_VALUE                               ((u32)0x00000001 << 22)          /*!<R/W 0  (RTL_only) Force input from MAC */
-#define BIT_R_FORCE_MACID_CCA_TH_EN_EN                              ((u32)0x00000001 << 21)          /*!<R/W 0  (RTL_only) Force input from MAC en */
-#define BIT_R_FORCE_MACID_CCA_TH_EN_VALUE                           ((u32)0x00000001 << 20)          /*!<R/W 0  (RTL_only) Force input from MAC */
-#define BIT_R_FORCE_BT_GRANT_EN                                     ((u32)0x00000001 << 19)          /*!<R/W 0  (RTL_only) Force input from MAC en */
-#define BIT_R_FORCE_BT_GRANT_VALUE                                  ((u32)0x00000001 << 18)          /*!<R/W 0  (RTL_only) Force input from MAC */
-#define BIT_R_FORCE_RX_LTE_EN                                       ((u32)0x00000001 << 17)          /*!<R/W 0  (RTL_only) Force input from MAC en */
-#define BIT_R_FORCE_RX_LTE_VALUE                                    ((u32)0x00000001 << 16)          /*!<R/W 0  (RTL_only) Force input from MAC */
-#define BIT_R_FORCE_TXBF_EN_EN                                      ((u32)0x00000001 << 15)          /*!<R/W 0  (RTL_only) Force input from MAC en */
-#define BIT_R_FORCE_TXBF_EN_VALUE                                   ((u32)0x00000001 << 14)          /*!<R/W 0  (RTL_only) Force input from MAC */
-#define BIT_R_FORCE_TXSC_EN                                         ((u32)0x00000001 << 13)          /*!<R/W 0  (RTL_only) Force input from MAC en */
-#define BIT_MASK_R_FORCE_TXSC_VALUE                                 ((u32)0x0000000F << 9)          /*!<R/W 0  (RTL_only) Force input from MAC */
-#define BIT_R_FORCE_TXSC_VALUE(x)                                   ((u32)(((x) & 0x0000000F) << 9))
-#define BIT_GET_R_FORCE_TXSC_VALUE(x)                               ((u32)(((x >> 9) & 0x0000000F)))
-#define BIT_R_FORCE_NTX_EN                                          ((u32)0x00000001 << 6)          /*!<R/W 0  (RTL_only) Force input from MAC en */
-#define BIT_R_FORCE_NTX_VALUE                                       ((u32)0x00000001 << 5)          /*!<R/W 0  (RTL_only) Force input from MAC */
-#define BIT_R_FORCE_PWR_MODE_EN                                     ((u32)0x00000001 << 3)          /*!<R/W 0  (RTL_only) Force input from MAC en */
-#define BIT_MASK_R_FORCE_PWR_MODE_VALUE                             ((u32)0x00000007 << 0)          /*!<R/W 0  (RTL_only) Force input from MAC */
-#define BIT_R_FORCE_PWR_MODE_VALUE(x)                               ((u32)(((x) & 0x00000007) << 0))
-#define BIT_GET_R_FORCE_PWR_MODE_VALUE(x)                           ((u32)(((x >> 0) & 0x00000007)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_AX_PWR_SR_FORCE0
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_R_FORCE_SR_RESP_DCM_EN                                  ((u32)0x00000001 << 30)          /*!<R/W 0  (RTL_only) Force input from MAC en */
-#define BIT_R_FORCE_SR_RESP_DCM_VALUE                               ((u32)0x00000001 << 29)          /*!<R/W 0  (RTL_only) Force input from MAC */
-#define BIT_R_FORCE_SR_RATE_DCM_EN                                  ((u32)0x00000001 << 28)          /*!<R/W 0  (RTL_only) Force input from MAC en */
-#define BIT_R_FORCE_SR_RATE_DCM_VALUE                               ((u32)0x00000001 << 27)          /*!<R/W 0  (RTL_only) Force input from MAC */
-#define BIT_R_FORCE_SR_TXPWR_PD_EN                                  ((u32)0x00000001 << 26)          /*!<R/W 0  (RTL_only) Force input from MAC en */
-#define BIT_MASK_R_FORCE_SR_TXPWR_PD_VALUE                          ((u32)0x0000003F << 20)          /*!<R/W 0  (RTL_only) Force input from MAC */
-#define BIT_R_FORCE_SR_TXPWR_PD_VALUE(x)                            ((u32)(((x) & 0x0000003F) << 20))
-#define BIT_GET_R_FORCE_SR_TXPWR_PD_VALUE(x)                        ((u32)(((x >> 20) & 0x0000003F)))
-#define BIT_R_FORCE_SR_RATE_IDX_EN                                  ((u32)0x00000001 << 19)          /*!<R/W 0  (RTL_only) Force input from MAC en */
-#define BIT_MASK_R_FORCE_SR_RATE_IDX_VALUE                          ((u32)0x00000FFF << 7)          /*!<R/W 0  (RTL_only) Force input from MAC */
-#define BIT_R_FORCE_SR_RATE_IDX_VALUE(x)                            ((u32)(((x) & 0x00000FFF) << 7))
-#define BIT_GET_R_FORCE_SR_RATE_IDX_VALUE(x)                        ((u32)(((x >> 7) & 0x00000FFF)))
-#define BIT_R_FORCE_SR_TXPWR_TOLERANCE_EN                           ((u32)0x00000001 << 6)          /*!<R/W 0  (RTL_only) Force input from MAC en */
-#define BIT_MASK_R_FORCE_SR_TXPWR_TOLERANCE_VALUE                   ((u32)0x0000003F << 0)          /*!<R/W 0  (RTL_only) Force input from MAC */
-#define BIT_R_FORCE_SR_TXPWR_TOLERANCE_VALUE(x)                     ((u32)(((x) & 0x0000003F) << 0))
-#define BIT_GET_R_FORCE_SR_TXPWR_TOLERANCE_VALUE(x)                 ((u32)(((x >> 0) & 0x0000003F)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_AX_PWR_SR_FORCE1
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_R_FORCE_RPL_EN                                          ((u32)0x00000001 << 29)          /*!<R/W 0  (RTL_only) Force input from MAC en */
-#define BIT_MASK_R_FORCE_RPL_VALUE                                  ((u32)0x000001FF << 20)          /*!<R/W 0  (RTL_only) Force input from MAC */
-#define BIT_R_FORCE_RPL_VALUE(x)                                    ((u32)(((x) & 0x000001FF) << 20))
-#define BIT_GET_R_FORCE_RPL_VALUE(x)                                ((u32)(((x >> 20) & 0x000001FF)))
-#define BIT_R_FORCE_SR_RESP_RATE_IDX_EN                             ((u32)0x00000001 << 19)          /*!<R/W 0  (RTL_only) Force input from MAC en */
-#define BIT_MASK_R_FORCE_SR_RESP_RATE_IDX_VALUE                     ((u32)0x00000FFF << 7)          /*!<R/W 0  (RTL_only) Force input from MAC */
-#define BIT_R_FORCE_SR_RESP_RATE_IDX_VALUE(x)                       ((u32)(((x) & 0x00000FFF) << 7))
-#define BIT_GET_R_FORCE_SR_RESP_RATE_IDX_VALUE(x)                   ((u32)(((x >> 7) & 0x00000FFF)))
-#define BIT_R_FORCE_SR_RESP_TXPWR_PD_EN                             ((u32)0x00000001 << 6)          /*!<R/W 0  (RTL_only) Force input from MAC en */
-#define BIT_MASK_R_FORCE_SR_RESP_TXPWR_PD_VALUE                     ((u32)0x0000003F << 0)          /*!<R/W 0  (RTL_only) Force input from MAC */
-#define BIT_R_FORCE_SR_RESP_TXPWR_PD_VALUE(x)                       ((u32)(((x) & 0x0000003F) << 0))
-#define BIT_GET_R_FORCE_SR_RESP_TXPWR_PD_VALUE(x)                   ((u32)(((x >> 0) & 0x0000003F)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_AX_PWR_SR_FORCE2
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_R_FORCE_TF_AP_TX_PWR_EN                                 ((u32)0x00000001 << 31)          /*!<R/W 0  (RTL_only) Force input from MAC en */
-#define BIT_MASK_R_FORCE_TF_AP_TX_PWR_VALUE                         ((u32)0x0000003F << 25)          /*!<R/W 0  (RTL_only) Force input from MAC */
-#define BIT_R_FORCE_TF_AP_TX_PWR_VALUE(x)                           ((u32)(((x) & 0x0000003F) << 25))
-#define BIT_GET_R_FORCE_TF_AP_TX_PWR_VALUE(x)                       ((u32)(((x >> 25) & 0x0000003F)))
-#define BIT_R_FORCE_TF_RATE_IDX_EN                                  ((u32)0x00000001 << 24)          /*!<R/W 0  (RTL_only) Force input from MAC en */
-#define BIT_MASK_R_FORCE_TF_RATE_IDX_VALUE                          ((u32)0x00000FFF << 12)          /*!<R/W 0  (RTL_only) Force input from MAC */
-#define BIT_R_FORCE_TF_RATE_IDX_VALUE(x)                            ((u32)(((x) & 0x00000FFF) << 12))
-#define BIT_GET_R_FORCE_TF_RATE_IDX_VALUE(x)                        ((u32)(((x >> 12) & 0x00000FFF)))
-#define BIT_R_FORCE_RPL_UPPER_EN_EN                                 ((u32)0x00000001 << 11)          /*!<R/W 0  (RTL_only) Force input from MAC en */
-#define BIT_R_FORCE_RPL_UPPER_EN_VALUE                              ((u32)0x00000001 << 10)          /*!<R/W 0  (RTL_only) Force input from MAC */
-#define BIT_R_FORCE_RPL_UPPER_EN                                    ((u32)0x00000001 << 9)          /*!<R/W 0  (RTL_only) Force input from MAC en */
-#define BIT_MASK_R_FORCE_RPL_UPPER_VALUE                            ((u32)0x000001FF << 0)          /*!<R/W 0  (RTL_only) Force input from MAC */
-#define BIT_R_FORCE_RPL_UPPER_VALUE(x)                              ((u32)(((x) & 0x000001FF) << 0))
-#define BIT_GET_R_FORCE_RPL_UPPER_VALUE(x)                          ((u32)(((x >> 0) & 0x000001FF)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_AX_PWR_UL_FORCE0
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_R_FORCE_RU_ALLOC_EN                                     ((u32)0x00000001 << 24)          /*!<R/W 0  (RTL_only) Force input from MAC en */
-#define BIT_MASK_R_FORCE_RU_ALLOC_VALUE                             ((u32)0x000000FF << 16)          /*!<R/W 0  (RTL_only) Force input from MAC */
-#define BIT_R_FORCE_RU_ALLOC_VALUE(x)                               ((u32)(((x) & 0x000000FF) << 16))
-#define BIT_GET_R_FORCE_RU_ALLOC_VALUE(x)                           ((u32)(((x >> 16) & 0x000000FF)))
-#define BIT_R_FORCE_TF_MACID_EN                                     ((u32)0x00000001 << 15)          /*!<R/W 0  (RTL_only) Force input from MAC en */
-#define BIT_MASK_R_FORCE_TF_MACID_VALUE                             ((u32)0x0000007F << 8)          /*!<R/W 0  (RTL_only) Force input from MAC */
-#define BIT_R_FORCE_TF_MACID_VALUE(x)                               ((u32)(((x) & 0x0000007F) << 8))
-#define BIT_GET_R_FORCE_TF_MACID_VALUE(x)                           ((u32)(((x >> 8) & 0x0000007F)))
-#define BIT_R_FORCE_TF_RSSI_TARGET_EN                               ((u32)0x00000001 << 7)          /*!<R/W 0  (RTL_only) Force input from MAC en */
-#define BIT_MASK_R_FORCE_TF_RSSI_TARGET_VALUE                       ((u32)0x0000007F << 0)          /*!<R/W 0  (RTL_only) Force input from MAC */
-#define BIT_R_FORCE_TF_RSSI_TARGET_VALUE(x)                         ((u32)(((x) & 0x0000007F) << 0))
-#define BIT_GET_R_FORCE_TF_RSSI_TARGET_VALUE(x)                     ((u32)(((x >> 0) & 0x0000007F)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_AX_PWR_NORM_FORCE2
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_R_FORCE_OUT_CCA_PWR_TH_EN_ON                            ((u32)0x00000001 << 18)          /*!<R/W 0  (RTL_only) Force output to MAC en */
-#define BIT_R_FORCE_OUT_CCA_PWR_TH_EN                               ((u32)0x00000001 << 17)          /*!<R/W 0  (RTL_only) Force output to MAC */
-#define BIT_R_FORCE_OUT_CCA_PWR_TH_ON                               ((u32)0x00000001 << 16)          /*!<R/W 0  (RTL_only) Force output to MAC en */
-#define BIT_MASK_R_FORCE_OUT_CCA_PWR_TH                             ((u32)0x000000FF << 8)          /*!<R/W 0  (RTL_only) Force output to MAC */
-#define BIT_R_FORCE_OUT_CCA_PWR_TH(x)                               ((u32)(((x) & 0x000000FF) << 8))
-#define BIT_GET_R_FORCE_OUT_CCA_PWR_TH(x)                           ((u32)(((x >> 8) & 0x000000FF)))
-#define BIT_MASK_R_TXPWR_CTRL_DBG_SEL                               ((u32)0x0000003F << 0)          /*!<R/W 0  (RTL_only) dbg port address */
-#define BIT_R_TXPWR_CTRL_DBG_SEL(x)                                 ((u32)(((x) & 0x0000003F) << 0))
-#define BIT_GET_R_TXPWR_CTRL_DBG_SEL(x)                             ((u32)(((x >> 0) & 0x0000003F)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_AX_PWR_UL_FORCE1
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_R_FORCE_OUT_CFO_COMP_ON                                 ((u32)0x00000001 << 31)          /*!<R/W 0  (RTL_only) Force output to MAC en */
-#define BIT_MASK_R_FORCE_OUT_CFO_COMP                               ((u32)0x00000007 << 28)          /*!<R/W 0  (RTL_only) Force output to MAC */
-#define BIT_R_FORCE_OUT_CFO_COMP(x)                                 ((u32)(((x) & 0x00000007) << 28))
-#define BIT_GET_R_FORCE_OUT_CFO_COMP(x)                             ((u32)(((x >> 28) & 0x00000007)))
-#define BIT_R_FORCE_OUT_ABORT_TX_IDX_ON                             ((u32)0x00000001 << 27)          /*!<R/W 0  (RTL_only) Force output to MAC en */
-#define BIT_MASK_R_FORCE_OUT_ABORT_TX_IDX                           ((u32)0x00000003 << 25)          /*!<R/W 0  (RTL_only) Force output to MAC */
-#define BIT_R_FORCE_OUT_ABORT_TX_IDX(x)                             ((u32)(((x) & 0x00000003) << 25))
-#define BIT_GET_R_FORCE_OUT_ABORT_TX_IDX(x)                         ((u32)(((x >> 25) & 0x00000003)))
-#define BIT_R_FORCE_OUT_MIN_TX_PWR_FLAG_ON                          ((u32)0x00000001 << 24)          /*!<R/W 0  (RTL_only) Force output to MAC en */
-#define BIT_R_FORCE_OUT_MIN_TX_PWR_FLAG                             ((u32)0x00000001 << 23)          /*!<R/W 0  (RTL_only) Force output to MAC */
-#define BIT_R_FORCE_OUT_UPH_ON                                      ((u32)0x00000001 << 22)          /*!<R/W 0  (RTL_only) Force output to MAC en */
-#define BIT_MASK_R_FORCE_OUT_UPH                                    ((u32)0x0000001F << 17)          /*!<R/W 0  (RTL_only) Force output to MAC */
-#define BIT_R_FORCE_OUT_UPH(x)                                      ((u32)(((x) & 0x0000001F) << 17))
-#define BIT_GET_R_FORCE_OUT_UPH(x)                                  ((u32)(((x >> 17) & 0x0000001F)))
-#define BIT_R_FORCE_OUT_STA_TXPWR_MAC_ON                            ((u32)0x00000001 << 16)          /*!<R/W 0  (RTL_only) Force output to MAC en */
-#define BIT_MASK_R_FORCE_OUT_STA_TXPWR_MAC                          ((u32)0x0000003F << 10)          /*!<R/W 0  (RTL_only) Force output to MAC */
-#define BIT_R_FORCE_OUT_STA_TXPWR_MAC(x)                            ((u32)(((x) & 0x0000003F) << 10))
-#define BIT_GET_R_FORCE_OUT_STA_TXPWR_MAC(x)                        ((u32)(((x >> 10) & 0x0000003F)))
-#define BIT_R_FORCE_OUT_STA_TXPWR_BB_ON                             ((u32)0x00000001 << 9)          /*!<R/W 0  (RTL_only) Force output to MAC en */
-#define BIT_MASK_R_FORCE_OUT_STA_TXPWR_BB                           ((u32)0x000001FF << 0)          /*!<R/W 0  (RTL_only) Force output to MAC */
-#define BIT_R_FORCE_OUT_STA_TXPWR_BB(x)                             ((u32)(((x) & 0x000001FF) << 0))
-#define BIT_GET_R_FORCE_OUT_STA_TXPWR_BB(x)                         ((u32)(((x >> 0) & 0x000001FF)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_AX_PWR_NORM_FORCE3
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_R_FORCE_OUT_TXAGC_BBSWING_ON                            ((u32)0x00000001 << 31)          /*!<R/W 0  (RTL_only) Force output to MAC en */
-#define BIT_MASK_R_FORCE_OUT_TXAGC_BBSWING                          ((u32)0x0000000F << 27)          /*!<R/W 0  (RTL_only) Force output to MAC */
-#define BIT_R_FORCE_OUT_TXAGC_BBSWING(x)                            ((u32)(((x) & 0x0000000F) << 27))
-#define BIT_GET_R_FORCE_OUT_TXAGC_BBSWING(x)                        ((u32)(((x >> 27) & 0x0000000F)))
-#define BIT_R_FORCE_OUT_TXBIAS_ON                                   ((u32)0x00000001 << 26)          /*!<R/W 0  (RTL_only) Force output to MAC en */
-#define BIT_MASK_R_FORCE_OUT_TXBIAS                                 ((u32)0x00000003 << 24)          /*!<R/W 0  (RTL_only) Force output to MAC */
-#define BIT_R_FORCE_OUT_TXBIAS(x)                                   ((u32)(((x) & 0x00000003) << 24))
-#define BIT_GET_R_FORCE_OUT_TXBIAS(x)                               ((u32)(((x >> 24) & 0x00000003)))
-#define BIT_R_FORCE_OUT_TXPWR_BFON_BOOST_DB_SEG0_ON                 ((u32)0x00000001 << 23)          /*!<R/W 0  (RTL_only) Force output to MAC en */
-#define BIT_MASK_R_FORCE_OUT_TXPWR_BFON_BOOST_DB_SEG0               ((u32)0x0000001F << 18)          /*!<R/W 0  (RTL_only) Force output to MAC */
-#define BIT_R_FORCE_OUT_TXPWR_BFON_BOOST_DB_SEG0(x)                 ((u32)(((x) & 0x0000001F) << 18))
-#define BIT_GET_R_FORCE_OUT_TXPWR_BFON_BOOST_DB_SEG0(x)             ((u32)(((x >> 18) & 0x0000001F)))
-#define BIT_R_FORCE_OUT_TXPWR_BB_ON                                 ((u32)0x00000001 << 17)          /*!<R/W 0  (RTL_only) Force output to MAC en */
-#define BIT_MASK_R_FORCE_OUT_TXPWR_BB                               ((u32)0x000001FF << 8)          /*!<R/W 0  (RTL_only) Force output to MAC */
-#define BIT_R_FORCE_OUT_TXPWR_BB(x)                                 ((u32)(((x) & 0x000001FF) << 8))
-#define BIT_GET_R_FORCE_OUT_TXPWR_BB(x)                             ((u32)(((x >> 8) & 0x000001FF)))
-#define BIT_R_FORCE_OUT_TXPWR_MAC_ON                                ((u32)0x00000001 << 6)          /*!<R/W 0  (RTL_only) Force output to MAC en */
-#define BIT_MASK_R_FORCE_OUT_TXPWR_MAC                              ((u32)0x0000003F << 0)          /*!<R/W 0  (RTL_only) Force output to MAC */
-#define BIT_R_FORCE_OUT_TXPWR_MAC(x)                                ((u32)(((x) & 0x0000003F) << 0))
-#define BIT_GET_R_FORCE_OUT_TXPWR_MAC(x)                            ((u32)(((x >> 0) & 0x0000003F)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_AX_PWR_NORM_FORCE4
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_R_BT_GRANT_WL_FORCE_OFF                                 ((u32)0x00000001 << 31)          /*!<R/W 0  (RTL_only) Force off grant_wl */
-#define BIT_R_BT_GRANT_TX_FORCE_OFF                                 ((u32)0x00000001 << 30)          /*!<R/W 0  (RTL_only) Force off grant_tx */
-#define BIT_R_BT_GRANT_RX_FORCE_OFF                                 ((u32)0x00000001 << 29)          /*!<R/W 0  (RTL_only) Force off grant_rx */
-#define BIT_R_BT_GRANT_WL_VAL                                       ((u32)0x00000001 << 28)          /*!<R/W 0  (RTL_only) grant_wl flag=0 means coexist act */
-#define BIT_R_BT_GRANT_TX_VAL                                       ((u32)0x00000001 << 27)          /*!<R/W 1h  (RTL_only) grant_rx flag=1 means coexist act */
-#define BIT_R_BT_GRANT_RX_VAL                                       ((u32)0x00000001 << 26)          /*!<R/W 1h  (RTL_only) grant_rx flag=1 means coexist act */
-#define BIT_R_FORCE_OUT_SR_DCM_ON                                   ((u32)0x00000001 << 25)          /*!<R/W 0  (RTL_only) Force output to MAC en */
-#define BIT_R_FORCE_OUT_SR_DCM                                      ((u32)0x00000001 << 24)          /*!<R/W 0  (RTL_only) Force output to MAC */
-#define BIT_R_FORCE_OUT_SR_MCS_ON                                   ((u32)0x00000001 << 23)          /*!<R/W 0  (RTL_only) Force output to MAC en */
-#define BIT_MASK_R_FORCE_OUT_SR_MCS                                 ((u32)0x00000FFF << 11)          /*!<R/W 0  (RTL_only) Force output to MAC */
-#define BIT_R_FORCE_OUT_SR_MCS(x)                                   ((u32)(((x) & 0x00000FFF) << 11))
-#define BIT_GET_R_FORCE_OUT_SR_MCS(x)                               ((u32)(((x >> 11) & 0x00000FFF)))
-#define BIT_R_FORCE_OUT_SR_PD_THREHOLD_ON                           ((u32)0x00000001 << 10)          /*!<R/W 0  (RTL_only) Force output to MAC en */
-#define BIT_MASK_R_FORCE_OUT_SR_PD_THREHOLD                         ((u32)0x0000003F << 4)          /*!<R/W 0  (RTL_only) Force output to MAC */
-#define BIT_R_FORCE_OUT_SR_PD_THREHOLD(x)                           ((u32)(((x) & 0x0000003F) << 4))
-#define BIT_GET_R_FORCE_OUT_SR_PD_THREHOLD(x)                       ((u32)(((x >> 4) & 0x0000003F)))
-#define BIT_R_FORCE_OUT_CFIR_BY_RATE_OFF_ON                         ((u32)0x00000001 << 3)          /*!<R/W 0  (RTL_only) Force output to MAC en */
-#define BIT_R_FORCE_OUT_CFIR_BY_RATE_OFF                            ((u32)0x00000001 << 2)          /*!<R/W 0  (RTL_only) Force output to MAC */
-#define BIT_R_FORCE_OUT_DPD_BY_RATE_OFF_ON                          ((u32)0x00000001 << 1)          /*!<R/W 0  (RTL_only) Force output to MAC en */
-#define BIT_R_FORCE_OUT_DPD_BY_RATE_OFF                             ((u32)0x00000001 << 0)          /*!<R/W 0  (RTL_only) Force output to MAC */
-#define BIT_R_RU_PWR_LIM_MUX_EN                                     ((u32)0x00000001 << 31)          /*!<R/W 0  1:by_rate→macid_lim→RU_lim 0:by_rate->macid->BF0_pwr_lim->RU_lim */
-#define BIT_R_RU_NORM_EN                                            ((u32)0x00000001 << 30)          /*!<R/W 0  (RTL_only) RU_norm_enable (RTL_ONLY TEST ) */
-#define BIT_MASK_R_RU_NORM_RU106                                    ((u32)0x000003FF << 20)          /*!<R/W 39h  (RTL_only) S(10.4) RU_lim tbl -RU norm,0x39=3.5625dB */
-#define BIT_R_RU_NORM_RU106(x)                                      ((u32)(((x) & 0x000003FF) << 20))
-#define BIT_GET_R_RU_NORM_RU106(x)                                  ((u32)(((x >> 20) & 0x000003FF)))
-#define BIT_MASK_R_RU_NORM_RU52                                     ((u32)0x000003FF << 10)          /*!<R/W 6Bh  (RTL_only) S(10.4) RU_lim tbl -RU norm,0x6b=6.6875dB */
-#define BIT_R_RU_NORM_RU52(x)                                       ((u32)(((x) & 0x000003FF) << 10))
-#define BIT_GET_R_RU_NORM_RU52(x)                                   ((u32)(((x >> 10) & 0x000003FF)))
-#define BIT_MASK_R_RU_NORM_RU26                                     ((u32)0x000003FF << 0)          /*!<R/W 9Bh  (RTL_only) S(10.4) RU_lim tbl -RU norm ,0x9b=9.6875dB */
-#define BIT_R_RU_NORM_RU26(x)                                       ((u32)(((x) & 0x000003FF) << 0))
-#define BIT_GET_R_RU_NORM_RU26(x)                                   ((u32)(((x >> 0) & 0x000003FF)))
-#define BIT_R_STA_UL_LOG_NORM_EN                                    ((u32)0x00000001 << 31)          /*!<R/W 0  1:sta ul txpwr log norm en 0:log norm=10log(ntx)-10log(dbw) */
-#define BIT_R_STA_UL_INI_UPD_PHASE_DIS                              ((u32)0x00000001 << 30)          /*!<R/W 0  1:tst non eco bug */
-#define BIT_R_SRAM_RST_FORCE_VAL                                    ((u32)0x00000001 << 16)          /*!<R/W 0  rst sram by cr */
-#define BIT_R_SRAM_RST_FORCE_ON                                     ((u32)0x00000001 << 15)          /*!<R/W 0  1:rst sram by cr */
-#define BIT_R_MCS2TXINFO_EN                                         ((u32)0x00000001 << 14)          /*!<R/W 0  1:txinfo_bbswing=MCS */
-#define BIT_MASK_R_FORCE_OUT_PWRCOM_CH20_WITH_DATA_VAL              ((u32)0x000000FF << 6)          /*!<R/W 0  1:force out off */
-#define BIT_R_FORCE_OUT_PWRCOM_CH20_WITH_DATA_VAL(x)                ((u32)(((x) & 0x000000FF) << 6))
-#define BIT_GET_R_FORCE_OUT_PWRCOM_CH20_WITH_DATA_VAL(x)            ((u32)(((x >> 6) & 0x000000FF)))
-#define BIT_R_FORCE_OUT_PWRCOM_CH20_WITH_DATA_ON                    ((u32)0x00000001 << 5)          /*!<R/W 0  1:force out on */
-#define BIT_R_STA_UL_MU_OFF_DIS                                     ((u32)0x00000001 << 4)          /*!<R/W 0  1:MU do sta_ul */
-#define BIT_R_PWRCOM_CH20_WITH_DATA_BIT_REV                         ((u32)0x00000001 << 3)          /*!<R/W 0  bit rev,txpwr_lim */
-#define BIT_R_PWRCOM_CH20_WITH_DATA_BIT_INV                         ((u32)0x00000001 << 2)          /*!<R/W 0  bit inv,txpwr_lim */
-#define BIT_R_FUNC_RST_FORCE_VAL                                    ((u32)0x00000001 << 1)          /*!<R/W 1h  func rst from txpwr_ctrl _CR */
-#define BIT_R_FUNC_RST_FORCE_ON                                     ((u32)0x00000001 << 0)          /*!<R/W 0  Don’t obey func rst from MAC */
-#define BIT_MASK_R_STA_UL_LOG_NORM_BW160_1TX                        ((u32)0x000000FF << 24)          /*!<R/W 0  s(8,2) sta ul txpwr log norm */
-#define BIT_R_STA_UL_LOG_NORM_BW160_1TX(x)                          ((u32)(((x) & 0x000000FF) << 24))
-#define BIT_GET_R_STA_UL_LOG_NORM_BW160_1TX(x)                      ((u32)(((x >> 24) & 0x000000FF)))
-#define BIT_MASK_R_STA_UL_LOG_NORM_BW80_1TX                         ((u32)0x000000FF << 16)          /*!<R/W 0  s(8,2) sta ul txpwr log norm */
-#define BIT_R_STA_UL_LOG_NORM_BW80_1TX(x)                           ((u32)(((x) & 0x000000FF) << 16))
-#define BIT_GET_R_STA_UL_LOG_NORM_BW80_1TX(x)                       ((u32)(((x >> 16) & 0x000000FF)))
-#define BIT_MASK_R_STA_UL_LOG_NORM_BW40_1TX                         ((u32)0x000000FF << 8)          /*!<R/W 0  s(8,2) sta ul txpwr log norm */
-#define BIT_R_STA_UL_LOG_NORM_BW40_1TX(x)                           ((u32)(((x) & 0x000000FF) << 8))
-#define BIT_GET_R_STA_UL_LOG_NORM_BW40_1TX(x)                       ((u32)(((x >> 8) & 0x000000FF)))
-#define BIT_MASK_R_STA_UL_LOG_NORM_BW20_1TX                         ((u32)0x000000FF << 0)          /*!<R/W 0  s(8,2) sta ul txpwr log norm */
-#define BIT_R_STA_UL_LOG_NORM_BW20_1TX(x)                           ((u32)(((x) & 0x000000FF) << 0))
-#define BIT_GET_R_STA_UL_LOG_NORM_BW20_1TX(x)                       ((u32)(((x >> 0) & 0x000000FF)))
-#define BIT_MASK_R_STA_UL_LOG_NORM_BW260_2TX                        ((u32)0x000000FF << 24)          /*!<R/W 0  s(8,2) sta ul txpwr log norm */
-#define BIT_R_STA_UL_LOG_NORM_BW260_2TX(x)                          ((u32)(((x) & 0x000000FF) << 24))
-#define BIT_GET_R_STA_UL_LOG_NORM_BW260_2TX(x)                      ((u32)(((x >> 24) & 0x000000FF)))
-#define BIT_MASK_R_STA_UL_LOG_NORM_BW80_2TX                         ((u32)0x000000FF << 16)          /*!<R/W 0  s(8,2) sta ul txpwr log norm */
-#define BIT_R_STA_UL_LOG_NORM_BW80_2TX(x)                           ((u32)(((x) & 0x000000FF) << 16))
-#define BIT_GET_R_STA_UL_LOG_NORM_BW80_2TX(x)                       ((u32)(((x >> 16) & 0x000000FF)))
-#define BIT_MASK_R_STA_UL_LOG_NORM_BW40_2TX                         ((u32)0x000000FF << 8)          /*!<R/W 0  s(8,2) sta ul txpwr log norm */
-#define BIT_R_STA_UL_LOG_NORM_BW40_2TX(x)                           ((u32)(((x) & 0x000000FF) << 8))
-#define BIT_GET_R_STA_UL_LOG_NORM_BW40_2TX(x)                       ((u32)(((x >> 8) & 0x000000FF)))
-#define BIT_MASK_R_STA_UL_LOG_NORM_BW20_2TX                         ((u32)0x000000FF << 0)          /*!<R/W 0  s(8,2) sta ul txpwr log norm */
-#define BIT_R_STA_UL_LOG_NORM_BW20_2TX(x)                           ((u32)(((x) & 0x000000FF) << 0))
-#define BIT_GET_R_STA_UL_LOG_NORM_BW20_2TX(x)                       ((u32)(((x >> 0) & 0x000000FF)))
-#define BIT_MASK_R_TXBIAS_HT_TH_1                                   ((u32)0x0000000F << 27)          /*!<R/W 0  txbias region */
-#define BIT_R_TXBIAS_HT_TH_1(x)                                     ((u32)(((x) & 0x0000000F) << 27))
-#define BIT_GET_R_TXBIAS_HT_TH_1(x)                                 ((u32)(((x >> 27) & 0x0000000F)))
-#define BIT_MASK_R_TXBIAS_HT_TH_0                                   ((u32)0x0000000F << 23)          /*!<R/W 0  txbias region */
-#define BIT_R_TXBIAS_HT_TH_0(x)                                     ((u32)(((x) & 0x0000000F) << 23))
-#define BIT_GET_R_TXBIAS_HT_TH_0(x)                                 ((u32)(((x >> 23) & 0x0000000F)))
-#define BIT_MASK_R_TXBIAS_LEGACY_TH_2                               ((u32)0x0000000F << 17)          /*!<R/W 0  txbias region */
-#define BIT_R_TXBIAS_LEGACY_TH_2(x)                                 ((u32)(((x) & 0x0000000F) << 17))
-#define BIT_GET_R_TXBIAS_LEGACY_TH_2(x)                             ((u32)(((x >> 17) & 0x0000000F)))
-#define BIT_MASK_R_TXBIAS_LEGACY_TH_1                               ((u32)0x0000000F << 13)          /*!<R/W 0  txbias region */
-#define BIT_R_TXBIAS_LEGACY_TH_1(x)                                 ((u32)(((x) & 0x0000000F) << 13))
-#define BIT_GET_R_TXBIAS_LEGACY_TH_1(x)                             ((u32)(((x >> 13) & 0x0000000F)))
-#define BIT_MASK_R_TXBIAS_LEGACY_TH_0                               ((u32)0x0000000F << 9)          /*!<R/W 0  txbias region */
-#define BIT_R_TXBIAS_LEGACY_TH_0(x)                                 ((u32)(((x) & 0x0000000F) << 9))
-#define BIT_GET_R_TXBIAS_LEGACY_TH_0(x)                             ((u32)(((x >> 9) & 0x0000000F)))
-#define BIT_MASK_R_TXBIAS_CCK_TH_2                                  ((u32)0x00000007 << 6)          /*!<R/W 0  txbias region */
-#define BIT_R_TXBIAS_CCK_TH_2(x)                                    ((u32)(((x) & 0x00000007) << 6))
-#define BIT_GET_R_TXBIAS_CCK_TH_2(x)                                ((u32)(((x >> 6) & 0x00000007)))
-#define BIT_MASK_R_TXBIAS_CCK_TH_1                                  ((u32)0x00000007 << 3)          /*!<R/W 0  txbias region */
-#define BIT_R_TXBIAS_CCK_TH_1(x)                                    ((u32)(((x) & 0x00000007) << 3))
-#define BIT_GET_R_TXBIAS_CCK_TH_1(x)                                ((u32)(((x >> 3) & 0x00000007)))
-#define BIT_MASK_R_TXBIAS_CCK_TH_0                                  ((u32)0x00000007 << 0)          /*!<R/W 0  txbias region */
-#define BIT_R_TXBIAS_CCK_TH_0(x)                                    ((u32)(((x) & 0x00000007) << 0))
-#define BIT_GET_R_TXBIAS_CCK_TH_0(x)                                ((u32)(((x >> 0) & 0x00000007)))
-#define BIT_MASK_R_TXBIAS_CCK_REGION_3                              ((u32)0x00000003 << 30)          /*!<R/W 0  txbias region */
-#define BIT_R_TXBIAS_CCK_REGION_3(x)                                ((u32)(((x) & 0x00000003) << 30))
-#define BIT_GET_R_TXBIAS_CCK_REGION_3(x)                            ((u32)(((x >> 30) & 0x00000003)))
-#define BIT_MASK_R_TXBIAS_CCK_REGION_2                              ((u32)0x00000003 << 28)          /*!<R/W 0  txbias region */
-#define BIT_R_TXBIAS_CCK_REGION_2(x)                                ((u32)(((x) & 0x00000003) << 28))
-#define BIT_GET_R_TXBIAS_CCK_REGION_2(x)                            ((u32)(((x >> 28) & 0x00000003)))
-#define BIT_MASK_R_TXBIAS_HE_TH_2                                   ((u32)0x0000000F << 24)          /*!<R/W 0  txbias region */
-#define BIT_R_TXBIAS_HE_TH_2(x)                                     ((u32)(((x) & 0x0000000F) << 24))
-#define BIT_GET_R_TXBIAS_HE_TH_2(x)                                 ((u32)(((x >> 24) & 0x0000000F)))
-#define BIT_MASK_R_TXBIAS_HE_TH_1                                   ((u32)0x0000000F << 20)          /*!<R/W 0  txbias region */
-#define BIT_R_TXBIAS_HE_TH_1(x)                                     ((u32)(((x) & 0x0000000F) << 20))
-#define BIT_GET_R_TXBIAS_HE_TH_1(x)                                 ((u32)(((x >> 20) & 0x0000000F)))
-#define BIT_MASK_R_TXBIAS_HE_TH_0                                   ((u32)0x0000000F << 16)          /*!<R/W 0  txbias region */
-#define BIT_R_TXBIAS_HE_TH_0(x)                                     ((u32)(((x) & 0x0000000F) << 16))
-#define BIT_GET_R_TXBIAS_HE_TH_0(x)                                 ((u32)(((x >> 16) & 0x0000000F)))
-#define BIT_MASK_R_TXBIAS_VHT_TH_2                                  ((u32)0x0000000F << 12)          /*!<R/W 0  txbias region */
-#define BIT_R_TXBIAS_VHT_TH_2(x)                                    ((u32)(((x) & 0x0000000F) << 12))
-#define BIT_GET_R_TXBIAS_VHT_TH_2(x)                                ((u32)(((x >> 12) & 0x0000000F)))
-#define BIT_MASK_R_TXBIAS_VHT_TH_1                                  ((u32)0x0000000F << 8)          /*!<R/W 0  txbias region */
-#define BIT_R_TXBIAS_VHT_TH_1(x)                                    ((u32)(((x) & 0x0000000F) << 8))
-#define BIT_GET_R_TXBIAS_VHT_TH_1(x)                                ((u32)(((x >> 8) & 0x0000000F)))
-#define BIT_MASK_R_TXBIAS_VHT_TH_0                                  ((u32)0x0000000F << 4)          /*!<R/W 0  txbias region */
-#define BIT_R_TXBIAS_VHT_TH_0(x)                                    ((u32)(((x) & 0x0000000F) << 4))
-#define BIT_GET_R_TXBIAS_VHT_TH_0(x)                                ((u32)(((x >> 4) & 0x0000000F)))
-#define BIT_MASK_R_TXBIAS_HT_TH_2                                   ((u32)0x0000000F << 0)          /*!<R/W 0  txbias region */
-#define BIT_R_TXBIAS_HT_TH_2(x)                                     ((u32)(((x) & 0x0000000F) << 0))
-#define BIT_GET_R_TXBIAS_HT_TH_2(x)                                 ((u32)(((x >> 0) & 0x0000000F)))
-#define BIT_MASK_R_TXBIAS_HE_REGION_3                               ((u32)0x00000003 << 14)          /*!<R/W 0  txbias region */
-#define BIT_R_TXBIAS_HE_REGION_3(x)                                 ((u32)(((x) & 0x00000003) << 14))
-#define BIT_GET_R_TXBIAS_HE_REGION_3(x)                             ((u32)(((x >> 14) & 0x00000003)))
-#define BIT_MASK_R_TXBIAS_HE_REGION_2                               ((u32)0x00000003 << 12)          /*!<R/W 0  txbias region */
-#define BIT_R_TXBIAS_HE_REGION_2(x)                                 ((u32)(((x) & 0x00000003) << 12))
-#define BIT_GET_R_TXBIAS_HE_REGION_2(x)                             ((u32)(((x >> 12) & 0x00000003)))
-#define BIT_MASK_R_TXBIAS_VHT_REGION_3                              ((u32)0x00000003 << 10)          /*!<R/W 0  txbias region */
-#define BIT_R_TXBIAS_VHT_REGION_3(x)                                ((u32)(((x) & 0x00000003) << 10))
-#define BIT_GET_R_TXBIAS_VHT_REGION_3(x)                            ((u32)(((x >> 10) & 0x00000003)))
-#define BIT_MASK_R_TXBIAS_VHT_REGION_2                              ((u32)0x00000003 << 8)          /*!<R/W 0  txbias region */
-#define BIT_R_TXBIAS_VHT_REGION_2(x)                                ((u32)(((x) & 0x00000003) << 8))
-#define BIT_GET_R_TXBIAS_VHT_REGION_2(x)                            ((u32)(((x >> 8) & 0x00000003)))
-#define BIT_MASK_R_TXBIAS_HT_REGION_3                               ((u32)0x00000003 << 6)          /*!<R/W 0  txbias region */
-#define BIT_R_TXBIAS_HT_REGION_3(x)                                 ((u32)(((x) & 0x00000003) << 6))
-#define BIT_GET_R_TXBIAS_HT_REGION_3(x)                             ((u32)(((x >> 6) & 0x00000003)))
-#define BIT_MASK_R_TXBIAS_HT_REGION_2                               ((u32)0x00000003 << 4)          /*!<R/W 0  txbias region */
-#define BIT_R_TXBIAS_HT_REGION_2(x)                                 ((u32)(((x) & 0x00000003) << 4))
-#define BIT_GET_R_TXBIAS_HT_REGION_2(x)                             ((u32)(((x >> 4) & 0x00000003)))
-#define BIT_MASK_R_TXBIAS_LEGACY_REGION_3                           ((u32)0x00000003 << 2)          /*!<R/W 0  txbias region */
-#define BIT_R_TXBIAS_LEGACY_REGION_3(x)                             ((u32)(((x) & 0x00000003) << 2))
-#define BIT_GET_R_TXBIAS_LEGACY_REGION_3(x)                         ((u32)(((x >> 2) & 0x00000003)))
-#define BIT_MASK_R_TXBIAS_LEGACY_REGION_2                           ((u32)0x00000003 << 0)          /*!<R/W 0  txbias region */
-#define BIT_R_TXBIAS_LEGACY_REGION_2(x)                             ((u32)(((x) & 0x00000003) << 0))
-#define BIT_GET_R_TXBIAS_LEGACY_REGION_2(x)                         ((u32)(((x >> 0) & 0x00000003)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_AX_PWR_BY_RATE_TABLE0
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_MASK_R_TXAGC_CCK11M                                     ((u32)0x0000007F << 24)          /*!<R/W 0  s(7.1) */
-#define BIT_R_TXAGC_CCK11M(x)                                       ((u32)(((x) & 0x0000007F) << 24))
-#define BIT_GET_R_TXAGC_CCK11M(x)                                   ((u32)(((x >> 24) & 0x0000007F)))
-#define BIT_MASK_R_TXAGC_CCK5P5M                                    ((u32)0x0000007F << 16)          /*!<R/W 0  s(7.1) */
-#define BIT_R_TXAGC_CCK5P5M(x)                                      ((u32)(((x) & 0x0000007F) << 16))
-#define BIT_GET_R_TXAGC_CCK5P5M(x)                                  ((u32)(((x >> 16) & 0x0000007F)))
-#define BIT_MASK_R_TXAGC_CCK2M                                      ((u32)0x0000007F << 8)          /*!<R/W 0  s(7.1) */
-#define BIT_R_TXAGC_CCK2M(x)                                        ((u32)(((x) & 0x0000007F) << 8))
-#define BIT_GET_R_TXAGC_CCK2M(x)                                    ((u32)(((x >> 8) & 0x0000007F)))
-#define BIT_MASK_R_TXAGC_CCK1M                                      ((u32)0x0000007F << 0)          /*!<R/W 0  s(7.1) */
-#define BIT_R_TXAGC_CCK1M(x)                                        ((u32)(((x) & 0x0000007F) << 0))
-#define BIT_GET_R_TXAGC_CCK1M(x)                                    ((u32)(((x >> 0) & 0x0000007F)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_AX_PWR_BY_RATE_TABLE1
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_MASK_R_TXAGC_LEGACY18M                                  ((u32)0x0000007F << 24)          /*!<R/W 0  s(7.1) */
-#define BIT_R_TXAGC_LEGACY18M(x)                                    ((u32)(((x) & 0x0000007F) << 24))
-#define BIT_GET_R_TXAGC_LEGACY18M(x)                                ((u32)(((x >> 24) & 0x0000007F)))
-#define BIT_MASK_R_TXAGC_LEGACY12M                                  ((u32)0x0000007F << 16)          /*!<R/W 0  s(7.1) */
-#define BIT_R_TXAGC_LEGACY12M(x)                                    ((u32)(((x) & 0x0000007F) << 16))
-#define BIT_GET_R_TXAGC_LEGACY12M(x)                                ((u32)(((x >> 16) & 0x0000007F)))
-#define BIT_MASK_R_TXAGC_LEGACY9M                                   ((u32)0x0000007F << 8)          /*!<R/W 0  s(7.1) */
-#define BIT_R_TXAGC_LEGACY9M(x)                                     ((u32)(((x) & 0x0000007F) << 8))
-#define BIT_GET_R_TXAGC_LEGACY9M(x)                                 ((u32)(((x >> 8) & 0x0000007F)))
-#define BIT_MASK_R_TXAGC_LEGACY6M                                   ((u32)0x0000007F << 0)          /*!<R/W 0  s(7.1) */
-#define BIT_R_TXAGC_LEGACY6M(x)                                     ((u32)(((x) & 0x0000007F) << 0))
-#define BIT_GET_R_TXAGC_LEGACY6M(x)                                 ((u32)(((x >> 0) & 0x0000007F)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_AX_PWR_BY_RATE_TABLE2
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_MASK_R_TXAGC_LEGACY54M                                  ((u32)0x0000007F << 24)          /*!<R/W 0  s(7.1) */
-#define BIT_R_TXAGC_LEGACY54M(x)                                    ((u32)(((x) & 0x0000007F) << 24))
-#define BIT_GET_R_TXAGC_LEGACY54M(x)                                ((u32)(((x >> 24) & 0x0000007F)))
-#define BIT_MASK_R_TXAGC_LEGACY48M                                  ((u32)0x0000007F << 16)          /*!<R/W 0  s(7.1) */
-#define BIT_R_TXAGC_LEGACY48M(x)                                    ((u32)(((x) & 0x0000007F) << 16))
-#define BIT_GET_R_TXAGC_LEGACY48M(x)                                ((u32)(((x >> 16) & 0x0000007F)))
-#define BIT_MASK_R_TXAGC_LEGACY36M                                  ((u32)0x0000007F << 8)          /*!<R/W 0  s(7.1) */
-#define BIT_R_TXAGC_LEGACY36M(x)                                    ((u32)(((x) & 0x0000007F) << 8))
-#define BIT_GET_R_TXAGC_LEGACY36M(x)                                ((u32)(((x >> 8) & 0x0000007F)))
-#define BIT_MASK_R_TXAGC_LEGACY24M                                  ((u32)0x0000007F << 0)          /*!<R/W 0  s(7.1) */
-#define BIT_R_TXAGC_LEGACY24M(x)                                    ((u32)(((x) & 0x0000007F) << 0))
-#define BIT_GET_R_TXAGC_LEGACY24M(x)                                ((u32)(((x >> 0) & 0x0000007F)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_AX_PWR_BY_RATE_TABLE3
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_MASK_R_TXAGC_NONLEGACY_MCS3_1NSS                        ((u32)0x0000007F << 24)          /*!<R/W 0  s(7.1) */
-#define BIT_R_TXAGC_NONLEGACY_MCS3_1NSS(x)                          ((u32)(((x) & 0x0000007F) << 24))
-#define BIT_GET_R_TXAGC_NONLEGACY_MCS3_1NSS(x)                      ((u32)(((x >> 24) & 0x0000007F)))
-#define BIT_MASK_R_TXAGC_NONLEGACY_MCS2_1NSS                        ((u32)0x0000007F << 16)          /*!<R/W 0  s(7.1) */
-#define BIT_R_TXAGC_NONLEGACY_MCS2_1NSS(x)                          ((u32)(((x) & 0x0000007F) << 16))
-#define BIT_GET_R_TXAGC_NONLEGACY_MCS2_1NSS(x)                      ((u32)(((x >> 16) & 0x0000007F)))
-#define BIT_MASK_R_TXAGC_NONLEGACY_MCS1_1NSS                        ((u32)0x0000007F << 8)          /*!<R/W 0  s(7.1) */
-#define BIT_R_TXAGC_NONLEGACY_MCS1_1NSS(x)                          ((u32)(((x) & 0x0000007F) << 8))
-#define BIT_GET_R_TXAGC_NONLEGACY_MCS1_1NSS(x)                      ((u32)(((x >> 8) & 0x0000007F)))
-#define BIT_MASK_R_TXAGC_NONLEGACY_MCS0_1NSS                        ((u32)0x0000007F << 0)          /*!<R/W 0  s(7.1) */
-#define BIT_R_TXAGC_NONLEGACY_MCS0_1NSS(x)                          ((u32)(((x) & 0x0000007F) << 0))
-#define BIT_GET_R_TXAGC_NONLEGACY_MCS0_1NSS(x)                      ((u32)(((x >> 0) & 0x0000007F)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_AX_PWR_BY_RATE_TABLE4
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_MASK_R_TXAGC_NONLEGACY_MCS7_1NSS                        ((u32)0x0000007F << 24)          /*!<R/W 0  s(7.1) */
-#define BIT_R_TXAGC_NONLEGACY_MCS7_1NSS(x)                          ((u32)(((x) & 0x0000007F) << 24))
-#define BIT_GET_R_TXAGC_NONLEGACY_MCS7_1NSS(x)                      ((u32)(((x >> 24) & 0x0000007F)))
-#define BIT_MASK_R_TXAGC_NONLEGACY_MCS6_1NSS                        ((u32)0x0000007F << 16)          /*!<R/W 0  s(7.1) */
-#define BIT_R_TXAGC_NONLEGACY_MCS6_1NSS(x)                          ((u32)(((x) & 0x0000007F) << 16))
-#define BIT_GET_R_TXAGC_NONLEGACY_MCS6_1NSS(x)                      ((u32)(((x >> 16) & 0x0000007F)))
-#define BIT_MASK_R_TXAGC_NONLEGACY_MCS5_1NSS                        ((u32)0x0000007F << 8)          /*!<R/W 0  s(7.1) */
-#define BIT_R_TXAGC_NONLEGACY_MCS5_1NSS(x)                          ((u32)(((x) & 0x0000007F) << 8))
-#define BIT_GET_R_TXAGC_NONLEGACY_MCS5_1NSS(x)                      ((u32)(((x >> 8) & 0x0000007F)))
-#define BIT_MASK_R_TXAGC_NONLEGACY_MCS4_1NSS                        ((u32)0x0000007F << 0)          /*!<R/W 0  s(7.1) */
-#define BIT_R_TXAGC_NONLEGACY_MCS4_1NSS(x)                          ((u32)(((x) & 0x0000007F) << 0))
-#define BIT_GET_R_TXAGC_NONLEGACY_MCS4_1NSS(x)                      ((u32)(((x >> 0) & 0x0000007F)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_AX_PWR_BY_RATE_TABLE5
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_MASK_R_TXAGC_NONLEGACY_MCS11_1NSS                       ((u32)0x0000007F << 24)          /*!<R/W 0  s(7.1) */
-#define BIT_R_TXAGC_NONLEGACY_MCS11_1NSS(x)                         ((u32)(((x) & 0x0000007F) << 24))
-#define BIT_GET_R_TXAGC_NONLEGACY_MCS11_1NSS(x)                     ((u32)(((x >> 24) & 0x0000007F)))
-#define BIT_MASK_R_TXAGC_NONLEGACY_MCS10_1NSS                       ((u32)0x0000007F << 16)          /*!<R/W 0  s(7.1) */
-#define BIT_R_TXAGC_NONLEGACY_MCS10_1NSS(x)                         ((u32)(((x) & 0x0000007F) << 16))
-#define BIT_GET_R_TXAGC_NONLEGACY_MCS10_1NSS(x)                     ((u32)(((x >> 16) & 0x0000007F)))
-#define BIT_MASK_R_TXAGC_NONLEGACY_MCS9_1NSS                        ((u32)0x0000007F << 8)          /*!<R/W 0  s(7.1) */
-#define BIT_R_TXAGC_NONLEGACY_MCS9_1NSS(x)                          ((u32)(((x) & 0x0000007F) << 8))
-#define BIT_GET_R_TXAGC_NONLEGACY_MCS9_1NSS(x)                      ((u32)(((x >> 8) & 0x0000007F)))
-#define BIT_MASK_R_TXAGC_NONLEGACY_MCS8_1NSS                        ((u32)0x0000007F << 0)          /*!<R/W 0  s(7.1) */
-#define BIT_R_TXAGC_NONLEGACY_MCS8_1NSS(x)                          ((u32)(((x) & 0x0000007F) << 0))
-#define BIT_GET_R_TXAGC_NONLEGACY_MCS8_1NSS(x)                      ((u32)(((x >> 0) & 0x0000007F)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_AX_PWR_BY_RATE_TABLE6
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_MASK_R_TXAGC_NONLEGACY_DCM_MCS4_1NSS                    ((u32)0x0000007F << 24)          /*!<R/W 0  s(7.1) */
-#define BIT_R_TXAGC_NONLEGACY_DCM_MCS4_1NSS(x)                      ((u32)(((x) & 0x0000007F) << 24))
-#define BIT_GET_R_TXAGC_NONLEGACY_DCM_MCS4_1NSS(x)                  ((u32)(((x >> 24) & 0x0000007F)))
-#define BIT_MASK_R_TXAGC_NONLEGACY_DCM_MCS3_1NSS                    ((u32)0x0000007F << 16)          /*!<R/W 0  s(7.1) */
-#define BIT_R_TXAGC_NONLEGACY_DCM_MCS3_1NSS(x)                      ((u32)(((x) & 0x0000007F) << 16))
-#define BIT_GET_R_TXAGC_NONLEGACY_DCM_MCS3_1NSS(x)                  ((u32)(((x >> 16) & 0x0000007F)))
-#define BIT_MASK_R_TXAGC_NONLEGACY_DCM_MCS1_1NSS                    ((u32)0x0000007F << 8)          /*!<R/W 0  s(7.1) */
-#define BIT_R_TXAGC_NONLEGACY_DCM_MCS1_1NSS(x)                      ((u32)(((x) & 0x0000007F) << 8))
-#define BIT_GET_R_TXAGC_NONLEGACY_DCM_MCS1_1NSS(x)                  ((u32)(((x >> 8) & 0x0000007F)))
-#define BIT_MASK_R_TXAGC_NONLEGACY_DCM_MCS0_1NSS                    ((u32)0x0000007F << 0)          /*!<R/W 0  s(7.1) */
-#define BIT_R_TXAGC_NONLEGACY_DCM_MCS0_1NSS(x)                      ((u32)(((x) & 0x0000007F) << 0))
-#define BIT_GET_R_TXAGC_NONLEGACY_DCM_MCS0_1NSS(x)                  ((u32)(((x >> 0) & 0x0000007F)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_AX_PWR_LMT_TABLE0
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_MASK_R_TXAGC_MAX_CCK_1TX_BW20M                          ((u32)0x0000007F << 0)          /*!<R/W 0  s(7.1) */
-#define BIT_R_TXAGC_MAX_CCK_1TX_BW20M(x)                            ((u32)(((x) & 0x0000007F) << 0))
-#define BIT_GET_R_TXAGC_MAX_CCK_1TX_BW20M(x)                        ((u32)(((x >> 0) & 0x0000007F)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_AX_PWR_LMT_TABLE1
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_MASK_R_TXAGC_MAX_1TX_BW20_0                             ((u32)0x0000007F << 16)          /*!<R/W 0  s(7.1) */
-#define BIT_R_TXAGC_MAX_1TX_BW20_0(x)                               ((u32)(((x) & 0x0000007F) << 16))
-#define BIT_GET_R_TXAGC_MAX_1TX_BW20_0(x)                           ((u32)(((x >> 16) & 0x0000007F)))
-#define BIT_MASK_R_TXAGC_MAX_LEGACY_NON_DUP_1TX                     ((u32)0x0000007F << 0)          /*!<R/W 0  s(7.1) */
-#define BIT_R_TXAGC_MAX_LEGACY_NON_DUP_1TX(x)                       ((u32)(((x) & 0x0000007F) << 0))
-#define BIT_GET_R_TXAGC_MAX_LEGACY_NON_DUP_1TX(x)                   ((u32)(((x >> 0) & 0x0000007F)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_AX_PWR_RU_LMT_TABLE0
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_MASK_R_RU_LIM_0TX_RU26_BW160_3                          ((u32)0x0000007F << 24)          /*!<R/W 0  s(7.1) */
-#define BIT_R_RU_LIM_0TX_RU26_BW160_3(x)                            ((u32)(((x) & 0x0000007F) << 24))
-#define BIT_GET_R_RU_LIM_0TX_RU26_BW160_3(x)                        ((u32)(((x >> 24) & 0x0000007F)))
-#define BIT_MASK_R_RU_LIM_0TX_RU26_BW160_2                          ((u32)0x0000007F << 16)          /*!<R/W 0  s(7.1) */
-#define BIT_R_RU_LIM_0TX_RU26_BW160_2(x)                            ((u32)(((x) & 0x0000007F) << 16))
-#define BIT_GET_R_RU_LIM_0TX_RU26_BW160_2(x)                        ((u32)(((x >> 16) & 0x0000007F)))
-#define BIT_MASK_R_RU_LIM_0TX_RU26_BW160_1                          ((u32)0x0000007F << 8)          /*!<R/W 0  s(7.1) */
-#define BIT_R_RU_LIM_0TX_RU26_BW160_1(x)                            ((u32)(((x) & 0x0000007F) << 8))
-#define BIT_GET_R_RU_LIM_0TX_RU26_BW160_1(x)                        ((u32)(((x >> 8) & 0x0000007F)))
-#define BIT_MASK_R_RU_LIM_0TX_RU26_BW160_0                          ((u32)0x0000007F << 0)          /*!<R/W 0  s(7.1) */
-#define BIT_R_RU_LIM_0TX_RU26_BW160_0(x)                            ((u32)(((x) & 0x0000007F) << 0))
-#define BIT_GET_R_RU_LIM_0TX_RU26_BW160_0(x)                        ((u32)(((x >> 0) & 0x0000007F)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_AX_PWR_RU_LMT_TABLE1
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_MASK_R_RU_LIM_0TX_RU26_BW160_7                          ((u32)0x0000007F << 24)          /*!<R/W 0  s(7.1) */
-#define BIT_R_RU_LIM_0TX_RU26_BW160_7(x)                            ((u32)(((x) & 0x0000007F) << 24))
-#define BIT_GET_R_RU_LIM_0TX_RU26_BW160_7(x)                        ((u32)(((x >> 24) & 0x0000007F)))
-#define BIT_MASK_R_RU_LIM_0TX_RU26_BW160_6                          ((u32)0x0000007F << 16)          /*!<R/W 0  s(7.1) */
-#define BIT_R_RU_LIM_0TX_RU26_BW160_6(x)                            ((u32)(((x) & 0x0000007F) << 16))
-#define BIT_GET_R_RU_LIM_0TX_RU26_BW160_6(x)                        ((u32)(((x >> 16) & 0x0000007F)))
-#define BIT_MASK_R_RU_LIM_0TX_RU26_BW160_5                          ((u32)0x0000007F << 8)          /*!<R/W 0  s(7.1) */
-#define BIT_R_RU_LIM_0TX_RU26_BW160_5(x)                            ((u32)(((x) & 0x0000007F) << 8))
-#define BIT_GET_R_RU_LIM_0TX_RU26_BW160_5(x)                        ((u32)(((x >> 8) & 0x0000007F)))
-#define BIT_MASK_R_RU_LIM_0TX_RU26_BW160_4                          ((u32)0x0000007F << 0)          /*!<R/W 0  s(7.1) */
-#define BIT_R_RU_LIM_0TX_RU26_BW160_4(x)                            ((u32)(((x) & 0x0000007F) << 0))
-#define BIT_GET_R_RU_LIM_0TX_RU26_BW160_4(x)                        ((u32)(((x >> 0) & 0x0000007F)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_AX_PWR_RU_LMT_TABLE2
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_MASK_R_RU_LIM_0TX_RU52_BW160_3                          ((u32)0x0000007F << 24)          /*!<R/W 0  s(7.1) */
-#define BIT_R_RU_LIM_0TX_RU52_BW160_3(x)                            ((u32)(((x) & 0x0000007F) << 24))
-#define BIT_GET_R_RU_LIM_0TX_RU52_BW160_3(x)                        ((u32)(((x >> 24) & 0x0000007F)))
-#define BIT_MASK_R_RU_LIM_0TX_RU52_BW160_2                          ((u32)0x0000007F << 16)          /*!<R/W 0  s(7.1) */
-#define BIT_R_RU_LIM_0TX_RU52_BW160_2(x)                            ((u32)(((x) & 0x0000007F) << 16))
-#define BIT_GET_R_RU_LIM_0TX_RU52_BW160_2(x)                        ((u32)(((x >> 16) & 0x0000007F)))
-#define BIT_MASK_R_RU_LIM_0TX_RU52_BW160_1                          ((u32)0x0000007F << 8)          /*!<R/W 0  s(7.1) */
-#define BIT_R_RU_LIM_0TX_RU52_BW160_1(x)                            ((u32)(((x) & 0x0000007F) << 8))
-#define BIT_GET_R_RU_LIM_0TX_RU52_BW160_1(x)                        ((u32)(((x >> 8) & 0x0000007F)))
-#define BIT_MASK_R_RU_LIM_0TX_RU52_BW160_0                          ((u32)0x0000007F << 0)          /*!<R/W 0  s(7.1) */
-#define BIT_R_RU_LIM_0TX_RU52_BW160_0(x)                            ((u32)(((x) & 0x0000007F) << 0))
-#define BIT_GET_R_RU_LIM_0TX_RU52_BW160_0(x)                        ((u32)(((x >> 0) & 0x0000007F)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_AX_PWR_RU_LMT_TABLE3
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_MASK_R_RU_LIM_0TX_RU52_BW160_7                          ((u32)0x0000007F << 24)          /*!<R/W 0  s(7.1) */
-#define BIT_R_RU_LIM_0TX_RU52_BW160_7(x)                            ((u32)(((x) & 0x0000007F) << 24))
-#define BIT_GET_R_RU_LIM_0TX_RU52_BW160_7(x)                        ((u32)(((x >> 24) & 0x0000007F)))
-#define BIT_MASK_R_RU_LIM_0TX_RU52_BW160_6                          ((u32)0x0000007F << 16)          /*!<R/W 0  s(7.1) */
-#define BIT_R_RU_LIM_0TX_RU52_BW160_6(x)                            ((u32)(((x) & 0x0000007F) << 16))
-#define BIT_GET_R_RU_LIM_0TX_RU52_BW160_6(x)                        ((u32)(((x >> 16) & 0x0000007F)))
-#define BIT_MASK_R_RU_LIM_0TX_RU52_BW160_5                          ((u32)0x0000007F << 8)          /*!<R/W 0  s(7.1) */
-#define BIT_R_RU_LIM_0TX_RU52_BW160_5(x)                            ((u32)(((x) & 0x0000007F) << 8))
-#define BIT_GET_R_RU_LIM_0TX_RU52_BW160_5(x)                        ((u32)(((x >> 8) & 0x0000007F)))
-#define BIT_MASK_R_RU_LIM_0TX_RU52_BW160_4                          ((u32)0x0000007F << 0)          /*!<R/W 0  s(7.1) */
-#define BIT_R_RU_LIM_0TX_RU52_BW160_4(x)                            ((u32)(((x) & 0x0000007F) << 0))
-#define BIT_GET_R_RU_LIM_0TX_RU52_BW160_4(x)                        ((u32)(((x >> 0) & 0x0000007F)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_AX_PWR_RU_LMT_TABLE4
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_MASK_R_RU_LIM_0TX_RU106_BW160_3                         ((u32)0x0000007F << 24)          /*!<R/W 0  s(7.1) */
-#define BIT_R_RU_LIM_0TX_RU106_BW160_3(x)                           ((u32)(((x) & 0x0000007F) << 24))
-#define BIT_GET_R_RU_LIM_0TX_RU106_BW160_3(x)                       ((u32)(((x >> 24) & 0x0000007F)))
-#define BIT_MASK_R_RU_LIM_0TX_RU106_BW160_2                         ((u32)0x0000007F << 16)          /*!<R/W 0  s(7.1) */
-#define BIT_R_RU_LIM_0TX_RU106_BW160_2(x)                           ((u32)(((x) & 0x0000007F) << 16))
-#define BIT_GET_R_RU_LIM_0TX_RU106_BW160_2(x)                       ((u32)(((x >> 16) & 0x0000007F)))
-#define BIT_MASK_R_RU_LIM_0TX_RU106_BW160_1                         ((u32)0x0000007F << 8)          /*!<R/W 0  s(7.1) */
-#define BIT_R_RU_LIM_0TX_RU106_BW160_1(x)                           ((u32)(((x) & 0x0000007F) << 8))
-#define BIT_GET_R_RU_LIM_0TX_RU106_BW160_1(x)                       ((u32)(((x >> 8) & 0x0000007F)))
-#define BIT_MASK_R_RU_LIM_0TX_RU106_BW160_0                         ((u32)0x0000007F << 0)          /*!<R/W 0  s(7.1) */
-#define BIT_R_RU_LIM_0TX_RU106_BW160_0(x)                           ((u32)(((x) & 0x0000007F) << 0))
-#define BIT_GET_R_RU_LIM_0TX_RU106_BW160_0(x)                       ((u32)(((x >> 0) & 0x0000007F)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_AX_PWR_RU_LMT_TABLE5
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_MASK_R_RU_LIM_0TX_RU106_BW160_7                         ((u32)0x0000007F << 24)          /*!<R/W 0  s(7.1) */
-#define BIT_R_RU_LIM_0TX_RU106_BW160_7(x)                           ((u32)(((x) & 0x0000007F) << 24))
-#define BIT_GET_R_RU_LIM_0TX_RU106_BW160_7(x)                       ((u32)(((x >> 24) & 0x0000007F)))
-#define BIT_MASK_R_RU_LIM_0TX_RU106_BW160_6                         ((u32)0x0000007F << 16)          /*!<R/W 0  s(7.1) */
-#define BIT_R_RU_LIM_0TX_RU106_BW160_6(x)                           ((u32)(((x) & 0x0000007F) << 16))
-#define BIT_GET_R_RU_LIM_0TX_RU106_BW160_6(x)                       ((u32)(((x >> 16) & 0x0000007F)))
-#define BIT_MASK_R_RU_LIM_0TX_RU106_BW160_5                         ((u32)0x0000007F << 8)          /*!<R/W 0  s(7.1) */
-#define BIT_R_RU_LIM_0TX_RU106_BW160_5(x)                           ((u32)(((x) & 0x0000007F) << 8))
-#define BIT_GET_R_RU_LIM_0TX_RU106_BW160_5(x)                       ((u32)(((x >> 8) & 0x0000007F)))
-#define BIT_MASK_R_RU_LIM_0TX_RU106_BW160_4                         ((u32)0x0000007F << 0)          /*!<R/W 0  s(7.1) */
-#define BIT_R_RU_LIM_0TX_RU106_BW160_4(x)                           ((u32)(((x) & 0x0000007F) << 0))
-#define BIT_GET_R_RU_LIM_0TX_RU106_BW160_4(x)                       ((u32)(((x >> 0) & 0x0000007F)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_AX_PWR_MACID_LMT_TABLEx
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_R_MACID_x_CCA_PWR_TH_EN                                 ((u32)0x00000001 << 26)          /*!<R/W 0  u(1.0) */
-#define BIT_R_MACID_x_TXPWR1_EN                                     ((u32)0x00000001 << 25)          /*!<R/W 0  u(1.0) */
-#define BIT_R_MACID_x_TXPWR0_EN                                     ((u32)0x00000001 << 24)          /*!<R/W 0  u(1.0) */
-#define BIT_MASK_R_MACID_x_CCA_PWR_TH                               ((u32)0x000000FF << 16)          /*!<R/W 0  s(8.1) */
-#define BIT_R_MACID_x_CCA_PWR_TH(x)                                 ((u32)(((x) & 0x000000FF) << 16))
-#define BIT_GET_R_MACID_x_CCA_PWR_TH(x)                             ((u32)(((x >> 16) & 0x000000FF)))
-#define BIT_MASK_R_MACID_x_TXPWR1                                   ((u32)0x000000FF << 8)          /*!<R/W 0  s(8.1) */
-#define BIT_R_MACID_x_TXPWR1(x)                                     ((u32)(((x) & 0x000000FF) << 8))
-#define BIT_GET_R_MACID_x_TXPWR1(x)                                 ((u32)(((x >> 8) & 0x000000FF)))
-#define BIT_MASK_R_MACID_x_TXPWR0                                   ((u32)0x000000FF << 0)          /*!<R/W 0  s(8.1) */
-#define BIT_R_MACID_x_TXPWR0(x)                                     ((u32)(((x) & 0x000000FF) << 0))
-#define BIT_GET_R_MACID_x_TXPWR0(x)                                 ((u32)(((x >> 0) & 0x000000FF)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_AX_PWR_SR_MCSx_TXDIFF_TABLE0
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_MASK_R_MCSx_TXDIFF_5DB_MCS_OFFSET                       ((u32)0x0000000F << 16)          /*!<R/W 0  U(4.0) mcs0~11 */
-#define BIT_R_MCSx_TXDIFF_5DB_MCS_OFFSET(x)                         ((u32)(((x) & 0x0000000F) << 16))
-#define BIT_GET_R_MCSx_TXDIFF_5DB_MCS_OFFSET(x)                     ((u32)(((x >> 16) & 0x0000000F)))
-#define BIT_MASK_R_MCSx_TXDIFF_4DB_MCS_OFFSET                       ((u32)0x0000000F << 12)          /*!<R/W 0  U(4.0) mcs0~11 */
-#define BIT_R_MCSx_TXDIFF_4DB_MCS_OFFSET(x)                         ((u32)(((x) & 0x0000000F) << 12))
-#define BIT_GET_R_MCSx_TXDIFF_4DB_MCS_OFFSET(x)                     ((u32)(((x >> 12) & 0x0000000F)))
-#define BIT_MASK_R_MCSx_TXDIFF_3DB_MCS_OFFSET                       ((u32)0x0000000F << 8)          /*!<R/W 0  U(4.0) mcs0~11 */
-#define BIT_R_MCSx_TXDIFF_3DB_MCS_OFFSET(x)                         ((u32)(((x) & 0x0000000F) << 8))
-#define BIT_GET_R_MCSx_TXDIFF_3DB_MCS_OFFSET(x)                     ((u32)(((x >> 8) & 0x0000000F)))
-#define BIT_MASK_R_MCSx_TXDIFF_2DB_MCS_OFFSET                       ((u32)0x0000000F << 4)          /*!<R/W 0  U(4.0) mcs0~11 */
-#define BIT_R_MCSx_TXDIFF_2DB_MCS_OFFSET(x)                         ((u32)(((x) & 0x0000000F) << 4))
-#define BIT_GET_R_MCSx_TXDIFF_2DB_MCS_OFFSET(x)                     ((u32)(((x >> 4) & 0x0000000F)))
-#define BIT_MASK_R_MCSx_TXDIFF_1DB_MCS_OFFSET                       ((u32)0x0000000F << 0)          /*!<R/W 0  U(4.0) mcs0~11 */
-#define BIT_R_MCSx_TXDIFF_1DB_MCS_OFFSET(x)                         ((u32)(((x) & 0x0000000F) << 0))
-#define BIT_GET_R_MCSx_TXDIFF_1DB_MCS_OFFSET(x)                     ((u32)(((x >> 0) & 0x0000000F)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_AX_PWR_SR_MCSx_TXDIFF_TABLE1
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_MASK_R_MCSx_TXDIFF_10DB_MCS_OFFSET                      ((u32)0x0000000F << 16)          /*!<R/W 0  U(4.0) mcs0~11 */
-#define BIT_R_MCSx_TXDIFF_10DB_MCS_OFFSET(x)                        ((u32)(((x) & 0x0000000F) << 16))
-#define BIT_GET_R_MCSx_TXDIFF_10DB_MCS_OFFSET(x)                    ((u32)(((x >> 16) & 0x0000000F)))
-#define BIT_MASK_R_MCSx_TXDIFF_9DB_MCS_OFFSET                       ((u32)0x0000000F << 12)          /*!<R/W 0  U(4.0) mcs0~11 */
-#define BIT_R_MCSx_TXDIFF_9DB_MCS_OFFSET(x)                         ((u32)(((x) & 0x0000000F) << 12))
-#define BIT_GET_R_MCSx_TXDIFF_9DB_MCS_OFFSET(x)                     ((u32)(((x >> 12) & 0x0000000F)))
-#define BIT_MASK_R_MCSx_TXDIFF_8DB_MCS_OFFSET                       ((u32)0x0000000F << 8)          /*!<R/W 0  U(4.0) mcs0~11 */
-#define BIT_R_MCSx_TXDIFF_8DB_MCS_OFFSET(x)                         ((u32)(((x) & 0x0000000F) << 8))
-#define BIT_GET_R_MCSx_TXDIFF_8DB_MCS_OFFSET(x)                     ((u32)(((x >> 8) & 0x0000000F)))
-#define BIT_MASK_R_MCSx_TXDIFF_7DB_MCS_OFFSET                       ((u32)0x0000000F << 4)          /*!<R/W 0  U(4.0) mcs0~11 */
-#define BIT_R_MCSx_TXDIFF_7DB_MCS_OFFSET(x)                         ((u32)(((x) & 0x0000000F) << 4))
-#define BIT_GET_R_MCSx_TXDIFF_7DB_MCS_OFFSET(x)                     ((u32)(((x >> 4) & 0x0000000F)))
-#define BIT_MASK_R_MCSx_TXDIFF_6DB_MCS_OFFSET                       ((u32)0x0000000F << 0)          /*!<R/W 0  U(4.0) mcs0~11 */
-#define BIT_R_MCSx_TXDIFF_6DB_MCS_OFFSET(x)                         ((u32)(((x) & 0x0000000F) << 0))
-#define BIT_GET_R_MCSx_TXDIFF_6DB_MCS_OFFSET(x)                     ((u32)(((x >> 0) & 0x0000000F)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_AX_PWR_SR_MCSx_TXDIFF_TABLE2
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_MASK_R_MCSx_TXDIFF_15DB_MCS_OFFSET                      ((u32)0x0000000F << 16)          /*!<R/W 0  U(4.0) mcs0~11 */
-#define BIT_R_MCSx_TXDIFF_15DB_MCS_OFFSET(x)                        ((u32)(((x) & 0x0000000F) << 16))
-#define BIT_GET_R_MCSx_TXDIFF_15DB_MCS_OFFSET(x)                    ((u32)(((x >> 16) & 0x0000000F)))
-#define BIT_MASK_R_MCSx_TXDIFF_14DB_MCS_OFFSET                      ((u32)0x0000000F << 12)          /*!<R/W 0  U(4.0) mcs0~11 */
-#define BIT_R_MCSx_TXDIFF_14DB_MCS_OFFSET(x)                        ((u32)(((x) & 0x0000000F) << 12))
-#define BIT_GET_R_MCSx_TXDIFF_14DB_MCS_OFFSET(x)                    ((u32)(((x >> 12) & 0x0000000F)))
-#define BIT_MASK_R_MCSx_TXDIFF_13DB_MCS_OFFSET                      ((u32)0x0000000F << 8)          /*!<R/W 0  U(4.0) mcs0~11 */
-#define BIT_R_MCSx_TXDIFF_13DB_MCS_OFFSET(x)                        ((u32)(((x) & 0x0000000F) << 8))
-#define BIT_GET_R_MCSx_TXDIFF_13DB_MCS_OFFSET(x)                    ((u32)(((x >> 8) & 0x0000000F)))
-#define BIT_MASK_R_MCSx_TXDIFF_12DB_MCS_OFFSET                      ((u32)0x0000000F << 4)          /*!<R/W 0  U(4.0) mcs0~11 */
-#define BIT_R_MCSx_TXDIFF_12DB_MCS_OFFSET(x)                        ((u32)(((x) & 0x0000000F) << 4))
-#define BIT_GET_R_MCSx_TXDIFF_12DB_MCS_OFFSET(x)                    ((u32)(((x >> 4) & 0x0000000F)))
-#define BIT_MASK_R_MCSx_TXDIFF_11DB_MCS_OFFSET                      ((u32)0x0000000F << 0)          /*!<R/W 0  U(4.0) mcs0~11 */
-#define BIT_R_MCSx_TXDIFF_11DB_MCS_OFFSET(x)                        ((u32)(((x) & 0x0000000F) << 0))
-#define BIT_GET_R_MCSx_TXDIFF_11DB_MCS_OFFSET(x)                    ((u32)(((x >> 0) & 0x0000000F)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_AX_PWR_SR_MCSx_TXDIFF_TABLE3
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_MASK_R_MCSx_TXDIFF_20DB_MCS_OFFSET                      ((u32)0x0000000F << 16)          /*!<R/W 0  U(4.0) mcs0~11 */
-#define BIT_R_MCSx_TXDIFF_20DB_MCS_OFFSET(x)                        ((u32)(((x) & 0x0000000F) << 16))
-#define BIT_GET_R_MCSx_TXDIFF_20DB_MCS_OFFSET(x)                    ((u32)(((x >> 16) & 0x0000000F)))
-#define BIT_MASK_R_MCSx_TXDIFF_19DB_MCS_OFFSET                      ((u32)0x0000000F << 12)          /*!<R/W 0  U(4.0) mcs0~11 */
-#define BIT_R_MCSx_TXDIFF_19DB_MCS_OFFSET(x)                        ((u32)(((x) & 0x0000000F) << 12))
-#define BIT_GET_R_MCSx_TXDIFF_19DB_MCS_OFFSET(x)                    ((u32)(((x >> 12) & 0x0000000F)))
-#define BIT_MASK_R_MCSx_TXDIFF_18DB_MCS_OFFSET                      ((u32)0x0000000F << 8)          /*!<R/W 0  U(4.0) mcs0~11 */
-#define BIT_R_MCSx_TXDIFF_18DB_MCS_OFFSET(x)                        ((u32)(((x) & 0x0000000F) << 8))
-#define BIT_GET_R_MCSx_TXDIFF_18DB_MCS_OFFSET(x)                    ((u32)(((x >> 8) & 0x0000000F)))
-#define BIT_MASK_R_MCSx_TXDIFF_17DB_MCS_OFFSET                      ((u32)0x0000000F << 4)          /*!<R/W 0  U(4.0) mcs0~11 */
-#define BIT_R_MCSx_TXDIFF_17DB_MCS_OFFSET(x)                        ((u32)(((x) & 0x0000000F) << 4))
-#define BIT_GET_R_MCSx_TXDIFF_17DB_MCS_OFFSET(x)                    ((u32)(((x >> 4) & 0x0000000F)))
-#define BIT_MASK_R_MCSx_TXDIFF_16DB_MCS_OFFSET                      ((u32)0x0000000F << 0)          /*!<R/W 0  U(4.0) mcs0~11 */
-#define BIT_R_MCSx_TXDIFF_16DB_MCS_OFFSET(x)                        ((u32)(((x) & 0x0000000F) << 0))
-#define BIT_GET_R_MCSx_TXDIFF_16DB_MCS_OFFSET(x)                    ((u32)(((x >> 0) & 0x0000000F)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_AX_PWR_cckxM_TXDIFF_TABLE0
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_MASK_R_CCKxM_TXDIFF_5DB_RATE_OFFSET                     ((u32)0x0000000F << 16)          /*!<R/W 0  U(4.0) cck 0~3, 0-cck1M,1=cck2M,2=cck5p5M,3=cck11M */
-#define BIT_R_CCKxM_TXDIFF_5DB_RATE_OFFSET(x)                       ((u32)(((x) & 0x0000000F) << 16))
-#define BIT_GET_R_CCKxM_TXDIFF_5DB_RATE_OFFSET(x)                   ((u32)(((x >> 16) & 0x0000000F)))
-#define BIT_MASK_R_CCKxM_TXDIFF_4DB_RATE_OFFSET                     ((u32)0x0000000F << 12)          /*!<R/W 0  U(4.0) cck 0~3, 0-cck1M,1=cck2M,2=cck5p5M,3=cck11M */
-#define BIT_R_CCKxM_TXDIFF_4DB_RATE_OFFSET(x)                       ((u32)(((x) & 0x0000000F) << 12))
-#define BIT_GET_R_CCKxM_TXDIFF_4DB_RATE_OFFSET(x)                   ((u32)(((x >> 12) & 0x0000000F)))
-#define BIT_MASK_R_CCKxM_TXDIFF_3DB_RATE_OFFSET                     ((u32)0x0000000F << 8)          /*!<R/W 0  U(4.0) cck 0~3, 0-cck1M,1=cck2M,2=cck5p5M,3=cck11M */
-#define BIT_R_CCKxM_TXDIFF_3DB_RATE_OFFSET(x)                       ((u32)(((x) & 0x0000000F) << 8))
-#define BIT_GET_R_CCKxM_TXDIFF_3DB_RATE_OFFSET(x)                   ((u32)(((x >> 8) & 0x0000000F)))
-#define BIT_MASK_R_CCKxM_TXDIFF_2DB_RATE_OFFSET                     ((u32)0x0000000F << 4)          /*!<R/W 0  U(4.0) cck 0~3, 0-cck1M,1=cck2M,2=cck5p5M,3=cck11M */
-#define BIT_R_CCKxM_TXDIFF_2DB_RATE_OFFSET(x)                       ((u32)(((x) & 0x0000000F) << 4))
-#define BIT_GET_R_CCKxM_TXDIFF_2DB_RATE_OFFSET(x)                   ((u32)(((x >> 4) & 0x0000000F)))
-#define BIT_MASK_R_CCKxM_TXDIFF_1DB_RATE_OFFSET                     ((u32)0x0000000F << 0)          /*!<R/W 0  U(4.0) cck 0~3, 0-cck1M,1=cck2M,2=cck5p5M,3=cck11M */
-#define BIT_R_CCKxM_TXDIFF_1DB_RATE_OFFSET(x)                       ((u32)(((x) & 0x0000000F) << 0))
-#define BIT_GET_R_CCKxM_TXDIFF_1DB_RATE_OFFSET(x)                   ((u32)(((x >> 0) & 0x0000000F)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_AX_PWR_cckxM_TXDIFF_TABLE1
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_MASK_R_CCKxM_TXDIFF_10DB_RATE_OFFSET                    ((u32)0x0000000F << 16)          /*!<R/W 0  U(4.0) cck 0~3, 0-cck1M,1=cck2M,2=cck5p5M,3=cck11M */
-#define BIT_R_CCKxM_TXDIFF_10DB_RATE_OFFSET(x)                      ((u32)(((x) & 0x0000000F) << 16))
-#define BIT_GET_R_CCKxM_TXDIFF_10DB_RATE_OFFSET(x)                  ((u32)(((x >> 16) & 0x0000000F)))
-#define BIT_MASK_R_CCKxM_TXDIFF_9DB_RATE_OFFSET                     ((u32)0x0000000F << 12)          /*!<R/W 0  U(4.0) cck 0~3, 0-cck1M,1=cck2M,2=cck5p5M,3=cck11M */
-#define BIT_R_CCKxM_TXDIFF_9DB_RATE_OFFSET(x)                       ((u32)(((x) & 0x0000000F) << 12))
-#define BIT_GET_R_CCKxM_TXDIFF_9DB_RATE_OFFSET(x)                   ((u32)(((x >> 12) & 0x0000000F)))
-#define BIT_MASK_R_CCKxM_TXDIFF_8DB_RATE_OFFSET                     ((u32)0x0000000F << 8)          /*!<R/W 0  U(4.0) cck 0~3, 0-cck1M,1=cck2M,2=cck5p5M,3=cck11M */
-#define BIT_R_CCKxM_TXDIFF_8DB_RATE_OFFSET(x)                       ((u32)(((x) & 0x0000000F) << 8))
-#define BIT_GET_R_CCKxM_TXDIFF_8DB_RATE_OFFSET(x)                   ((u32)(((x >> 8) & 0x0000000F)))
-#define BIT_MASK_R_CCKxM_TXDIFF_7DB_RATE_OFFSET                     ((u32)0x0000000F << 4)          /*!<R/W 0  U(4.0) cck 0~3, 0-cck1M,1=cck2M,2=cck5p5M,3=cck11M */
-#define BIT_R_CCKxM_TXDIFF_7DB_RATE_OFFSET(x)                       ((u32)(((x) & 0x0000000F) << 4))
-#define BIT_GET_R_CCKxM_TXDIFF_7DB_RATE_OFFSET(x)                   ((u32)(((x >> 4) & 0x0000000F)))
-#define BIT_MASK_R_CCKxM_TXDIFF_6DB_RATE_OFFSET                     ((u32)0x0000000F << 0)          /*!<R/W 0  U(4.0) cck 0~3, 0-cck1M,1=cck2M,2=cck5p5M,3=cck11M */
-#define BIT_R_CCKxM_TXDIFF_6DB_RATE_OFFSET(x)                       ((u32)(((x) & 0x0000000F) << 0))
-#define BIT_GET_R_CCKxM_TXDIFF_6DB_RATE_OFFSET(x)                   ((u32)(((x >> 0) & 0x0000000F)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_AX_PWR_cckxM_TXDIFF_TABLE2
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_MASK_R_CCKxM_TXDIFF_15DB_RATE_OFFSET                    ((u32)0x0000000F << 16)          /*!<R/W 0  U(4.0) cck 0~3, 0-cck1M,1=cck2M,2=cck5p5M,3=cck11M */
-#define BIT_R_CCKxM_TXDIFF_15DB_RATE_OFFSET(x)                      ((u32)(((x) & 0x0000000F) << 16))
-#define BIT_GET_R_CCKxM_TXDIFF_15DB_RATE_OFFSET(x)                  ((u32)(((x >> 16) & 0x0000000F)))
-#define BIT_MASK_R_CCKxM_TXDIFF_14DB_RATE_OFFSET                    ((u32)0x0000000F << 12)          /*!<R/W 0  U(4.0) cck 0~3, 0-cck1M,1=cck2M,2=cck5p5M,3=cck11M */
-#define BIT_R_CCKxM_TXDIFF_14DB_RATE_OFFSET(x)                      ((u32)(((x) & 0x0000000F) << 12))
-#define BIT_GET_R_CCKxM_TXDIFF_14DB_RATE_OFFSET(x)                  ((u32)(((x >> 12) & 0x0000000F)))
-#define BIT_MASK_R_CCKxM_TXDIFF_13DB_RATE_OFFSET                    ((u32)0x0000000F << 8)          /*!<R/W 0  U(4.0) cck 0~3, 0-cck1M,1=cck2M,2=cck5p5M,3=cck11M */
-#define BIT_R_CCKxM_TXDIFF_13DB_RATE_OFFSET(x)                      ((u32)(((x) & 0x0000000F) << 8))
-#define BIT_GET_R_CCKxM_TXDIFF_13DB_RATE_OFFSET(x)                  ((u32)(((x >> 8) & 0x0000000F)))
-#define BIT_MASK_R_CCKxM_TXDIFF_12DB_RATE_OFFSET                    ((u32)0x0000000F << 4)          /*!<R/W 0  U(4.0) cck 0~3, 0-cck1M,1=cck2M,2=cck5p5M,3=cck11M */
-#define BIT_R_CCKxM_TXDIFF_12DB_RATE_OFFSET(x)                      ((u32)(((x) & 0x0000000F) << 4))
-#define BIT_GET_R_CCKxM_TXDIFF_12DB_RATE_OFFSET(x)                  ((u32)(((x >> 4) & 0x0000000F)))
-#define BIT_MASK_R_CCKxM_TXDIFF_11DB_RATE_OFFSET                    ((u32)0x0000000F << 0)          /*!<R/W 0  U(4.0) cck 0~3, 0-cck1M,1=cck2M,2=cck5p5M,3=cck11M */
-#define BIT_R_CCKxM_TXDIFF_11DB_RATE_OFFSET(x)                      ((u32)(((x) & 0x0000000F) << 0))
-#define BIT_GET_R_CCKxM_TXDIFF_11DB_RATE_OFFSET(x)                  ((u32)(((x >> 0) & 0x0000000F)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_AX_PWR_cckxM_TXDIFF_TABLE3
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_MASK_R_CCKxM_TXDIFF_20DB_RATE_OFFSET                    ((u32)0x0000000F << 16)          /*!<R/W 0  U(4.0) cck 0~3, 0-cck1M,1=cck2M,2=cck5p5M,3=cck11M */
-#define BIT_R_CCKxM_TXDIFF_20DB_RATE_OFFSET(x)                      ((u32)(((x) & 0x0000000F) << 16))
-#define BIT_GET_R_CCKxM_TXDIFF_20DB_RATE_OFFSET(x)                  ((u32)(((x >> 16) & 0x0000000F)))
-#define BIT_MASK_R_CCKxM_TXDIFF_19DB_RATE_OFFSET                    ((u32)0x0000000F << 12)          /*!<R/W 0  U(4.0) cck 0~3, 0-cck1M,1=cck2M,2=cck5p5M,3=cck11M */
-#define BIT_R_CCKxM_TXDIFF_19DB_RATE_OFFSET(x)                      ((u32)(((x) & 0x0000000F) << 12))
-#define BIT_GET_R_CCKxM_TXDIFF_19DB_RATE_OFFSET(x)                  ((u32)(((x >> 12) & 0x0000000F)))
-#define BIT_MASK_R_CCKxM_TXDIFF_18DB_RATE_OFFSET                    ((u32)0x0000000F << 8)          /*!<R/W 0  U(4.0) cck 0~3, 0-cck1M,1=cck2M,2=cck5p5M,3=cck11M */
-#define BIT_R_CCKxM_TXDIFF_18DB_RATE_OFFSET(x)                      ((u32)(((x) & 0x0000000F) << 8))
-#define BIT_GET_R_CCKxM_TXDIFF_18DB_RATE_OFFSET(x)                  ((u32)(((x >> 8) & 0x0000000F)))
-#define BIT_MASK_R_CCKxM_TXDIFF_17DB_RATE_OFFSET                    ((u32)0x0000000F << 4)          /*!<R/W 0  U(4.0) cck 0~3, 0-cck1M,1=cck2M,2=cck5p5M,3=cck11M */
-#define BIT_R_CCKxM_TXDIFF_17DB_RATE_OFFSET(x)                      ((u32)(((x) & 0x0000000F) << 4))
-#define BIT_GET_R_CCKxM_TXDIFF_17DB_RATE_OFFSET(x)                  ((u32)(((x >> 4) & 0x0000000F)))
-#define BIT_MASK_R_CCKxM_TXDIFF_16DB_RATE_OFFSET                    ((u32)0x0000000F << 0)          /*!<R/W 0  U(4.0) cck 0~3, 0-cck1M,1=cck2M,2=cck5p5M,3=cck11M */
-#define BIT_R_CCKxM_TXDIFF_16DB_RATE_OFFSET(x)                      ((u32)(((x) & 0x0000000F) << 0))
-#define BIT_GET_R_CCKxM_TXDIFF_16DB_RATE_OFFSET(x)                  ((u32)(((x >> 0) & 0x0000000F)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_AX_PWR_legacyxM_TXDIFF_TABLE0
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_MASK_R_LEGACYxM_TXDIFF_5DB_RATE_OFFSET                  ((u32)0x0000000F << 16)          /*!<R/W 0  U(4.0) legacy 4~11,4=legacy6M,5=legacy9M,6=legacy12M,7=legacy18M,8=legacy24M,9=legacy36M,10=legacy48M,11=legacy54M */
-#define BIT_R_LEGACYxM_TXDIFF_5DB_RATE_OFFSET(x)                    ((u32)(((x) & 0x0000000F) << 16))
-#define BIT_GET_R_LEGACYxM_TXDIFF_5DB_RATE_OFFSET(x)                ((u32)(((x >> 16) & 0x0000000F)))
-#define BIT_MASK_R_LEGACYxM_TXDIFF_4DB_RATE_OFFSET                  ((u32)0x0000000F << 12)          /*!<R/W 0  U(4.0) legacy 4~11,4=legacy6M,5=legacy9M,6=legacy12M,7=legacy18M,8=legacy24M,9=legacy36M,10=legacy48M,11=legacy54M */
-#define BIT_R_LEGACYxM_TXDIFF_4DB_RATE_OFFSET(x)                    ((u32)(((x) & 0x0000000F) << 12))
-#define BIT_GET_R_LEGACYxM_TXDIFF_4DB_RATE_OFFSET(x)                ((u32)(((x >> 12) & 0x0000000F)))
-#define BIT_MASK_R_LEGACYxM_TXDIFF_3DB_RATE_OFFSET                  ((u32)0x0000000F << 8)          /*!<R/W 0  U(4.0) legacy 4~11,4=legacy6M,5=legacy9M,6=legacy12M,7=legacy18M,8=legacy24M,9=legacy36M,10=legacy48M,11=legacy54M */
-#define BIT_R_LEGACYxM_TXDIFF_3DB_RATE_OFFSET(x)                    ((u32)(((x) & 0x0000000F) << 8))
-#define BIT_GET_R_LEGACYxM_TXDIFF_3DB_RATE_OFFSET(x)                ((u32)(((x >> 8) & 0x0000000F)))
-#define BIT_MASK_R_LEGACYxM_TXDIFF_2DB_RATE_OFFSET                  ((u32)0x0000000F << 4)          /*!<R/W 0  U(4.0) legacy 4~11,4=legacy6M,5=legacy9M,6=legacy12M,7=legacy18M,8=legacy24M,9=legacy36M,10=legacy48M,11=legacy54M */
-#define BIT_R_LEGACYxM_TXDIFF_2DB_RATE_OFFSET(x)                    ((u32)(((x) & 0x0000000F) << 4))
-#define BIT_GET_R_LEGACYxM_TXDIFF_2DB_RATE_OFFSET(x)                ((u32)(((x >> 4) & 0x0000000F)))
-#define BIT_MASK_R_LEGACYxM_TXDIFF_1DB_RATE_OFFSET                  ((u32)0x0000000F << 0)          /*!<R/W 0  U(4.0) legacy 4~11,4=legacy6M,5=legacy9M,6=legacy12M,7=legacy18M,8=legacy24M,9=legacy36M,10=legacy48M,11=legacy54M */
-#define BIT_R_LEGACYxM_TXDIFF_1DB_RATE_OFFSET(x)                    ((u32)(((x) & 0x0000000F) << 0))
-#define BIT_GET_R_LEGACYxM_TXDIFF_1DB_RATE_OFFSET(x)                ((u32)(((x >> 0) & 0x0000000F)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_AX_PWR_legacyxM_TXDIFF_TABLE1
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_MASK_R_LEGACYxM_TXDIFF_10DB_RATE_OFFSET                 ((u32)0x0000000F << 16)          /*!<R/W 0  U(4.0) legacy 4~11,4=legacy6M,5=legacy9M,6=legacy12M,7=legacy18M,8=legacy24M,9=legacy36M,10=legacy48M,11=legacy54M */
-#define BIT_R_LEGACYxM_TXDIFF_10DB_RATE_OFFSET(x)                   ((u32)(((x) & 0x0000000F) << 16))
-#define BIT_GET_R_LEGACYxM_TXDIFF_10DB_RATE_OFFSET(x)               ((u32)(((x >> 16) & 0x0000000F)))
-#define BIT_MASK_R_LEGACYxM_TXDIFF_9DB_RATE_OFFSET                  ((u32)0x0000000F << 12)          /*!<R/W 0  U(4.0) legacy 4~11,4=legacy6M,5=legacy9M,6=legacy12M,7=legacy18M,8=legacy24M,9=legacy36M,10=legacy48M,11=legacy54M */
-#define BIT_R_LEGACYxM_TXDIFF_9DB_RATE_OFFSET(x)                    ((u32)(((x) & 0x0000000F) << 12))
-#define BIT_GET_R_LEGACYxM_TXDIFF_9DB_RATE_OFFSET(x)                ((u32)(((x >> 12) & 0x0000000F)))
-#define BIT_MASK_R_LEGACYxM_TXDIFF_8DB_RATE_OFFSET                  ((u32)0x0000000F << 8)          /*!<R/W 0  U(4.0) legacy 4~11,4=legacy6M,5=legacy9M,6=legacy12M,7=legacy18M,8=legacy24M,9=legacy36M,10=legacy48M,11=legacy54M */
-#define BIT_R_LEGACYxM_TXDIFF_8DB_RATE_OFFSET(x)                    ((u32)(((x) & 0x0000000F) << 8))
-#define BIT_GET_R_LEGACYxM_TXDIFF_8DB_RATE_OFFSET(x)                ((u32)(((x >> 8) & 0x0000000F)))
-#define BIT_MASK_R_LEGACYxM_TXDIFF_7DB_RATE_OFFSET                  ((u32)0x0000000F << 4)          /*!<R/W 0  U(4.0) legacy 4~11,4=legacy6M,5=legacy9M,6=legacy12M,7=legacy18M,8=legacy24M,9=legacy36M,10=legacy48M,11=legacy54M */
-#define BIT_R_LEGACYxM_TXDIFF_7DB_RATE_OFFSET(x)                    ((u32)(((x) & 0x0000000F) << 4))
-#define BIT_GET_R_LEGACYxM_TXDIFF_7DB_RATE_OFFSET(x)                ((u32)(((x >> 4) & 0x0000000F)))
-#define BIT_MASK_R_LEGACYxM_TXDIFF_6DB_RATE_OFFSET                  ((u32)0x0000000F << 0)          /*!<R/W 0  U(4.0) legacy 4~11,4=legacy6M,5=legacy9M,6=legacy12M,7=legacy18M,8=legacy24M,9=legacy36M,10=legacy48M,11=legacy54M */
-#define BIT_R_LEGACYxM_TXDIFF_6DB_RATE_OFFSET(x)                    ((u32)(((x) & 0x0000000F) << 0))
-#define BIT_GET_R_LEGACYxM_TXDIFF_6DB_RATE_OFFSET(x)                ((u32)(((x >> 0) & 0x0000000F)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_AX_PWR_legacyxM_TXDIFF_TABLE2
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_MASK_R_LEGACYxM_TXDIFF_15DB_RATE_OFFSET                 ((u32)0x0000000F << 16)          /*!<R/W 0  U(4.0) legacy 4~11,4=legacy6M,5=legacy9M,6=legacy12M,7=legacy18M,8=legacy24M,9=legacy36M,10=legacy48M,11=legacy54M */
-#define BIT_R_LEGACYxM_TXDIFF_15DB_RATE_OFFSET(x)                   ((u32)(((x) & 0x0000000F) << 16))
-#define BIT_GET_R_LEGACYxM_TXDIFF_15DB_RATE_OFFSET(x)               ((u32)(((x >> 16) & 0x0000000F)))
-#define BIT_MASK_R_LEGACYxM_TXDIFF_14DB_RATE_OFFSET                 ((u32)0x0000000F << 12)          /*!<R/W 0  U(4.0) legacy 4~11,4=legacy6M,5=legacy9M,6=legacy12M,7=legacy18M,8=legacy24M,9=legacy36M,10=legacy48M,11=legacy54M */
-#define BIT_R_LEGACYxM_TXDIFF_14DB_RATE_OFFSET(x)                   ((u32)(((x) & 0x0000000F) << 12))
-#define BIT_GET_R_LEGACYxM_TXDIFF_14DB_RATE_OFFSET(x)               ((u32)(((x >> 12) & 0x0000000F)))
-#define BIT_MASK_R_LEGACYxM_TXDIFF_13DB_RATE_OFFSET                 ((u32)0x0000000F << 8)          /*!<R/W 0  U(4.0) legacy 4~11,4=legacy6M,5=legacy9M,6=legacy12M,7=legacy18M,8=legacy24M,9=legacy36M,10=legacy48M,11=legacy54M */
-#define BIT_R_LEGACYxM_TXDIFF_13DB_RATE_OFFSET(x)                   ((u32)(((x) & 0x0000000F) << 8))
-#define BIT_GET_R_LEGACYxM_TXDIFF_13DB_RATE_OFFSET(x)               ((u32)(((x >> 8) & 0x0000000F)))
-#define BIT_MASK_R_LEGACYxM_TXDIFF_12DB_RATE_OFFSET                 ((u32)0x0000000F << 4)          /*!<R/W 0  U(4.0) legacy 4~11,4=legacy6M,5=legacy9M,6=legacy12M,7=legacy18M,8=legacy24M,9=legacy36M,10=legacy48M,11=legacy54M */
-#define BIT_R_LEGACYxM_TXDIFF_12DB_RATE_OFFSET(x)                   ((u32)(((x) & 0x0000000F) << 4))
-#define BIT_GET_R_LEGACYxM_TXDIFF_12DB_RATE_OFFSET(x)               ((u32)(((x >> 4) & 0x0000000F)))
-#define BIT_MASK_R_LEGACYxM_TXDIFF_11DB_RATE_OFFSET                 ((u32)0x0000000F << 0)          /*!<R/W 0  U(4.0) legacy 4~11,4=legacy6M,5=legacy9M,6=legacy12M,7=legacy18M,8=legacy24M,9=legacy36M,10=legacy48M,11=legacy54M */
-#define BIT_R_LEGACYxM_TXDIFF_11DB_RATE_OFFSET(x)                   ((u32)(((x) & 0x0000000F) << 0))
-#define BIT_GET_R_LEGACYxM_TXDIFF_11DB_RATE_OFFSET(x)               ((u32)(((x >> 0) & 0x0000000F)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_AX_PWR_legacyxM_TXDIFF_TABLE3
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_MASK_R_LEGACYxM_TXDIFF_20DB_RATE_OFFSET                 ((u32)0x0000000F << 16)          /*!<R/W 0  U(4.0) legacy 4~11,4=legacy6M,5=legacy9M,6=legacy12M,7=legacy18M,8=legacy24M,9=legacy36M,10=legacy48M,11=legacy54M */
-#define BIT_R_LEGACYxM_TXDIFF_20DB_RATE_OFFSET(x)                   ((u32)(((x) & 0x0000000F) << 16))
-#define BIT_GET_R_LEGACYxM_TXDIFF_20DB_RATE_OFFSET(x)               ((u32)(((x >> 16) & 0x0000000F)))
-#define BIT_MASK_R_LEGACYxM_TXDIFF_19DB_RATE_OFFSET                 ((u32)0x0000000F << 12)          /*!<R/W 0  U(4.0) legacy 4~11,4=legacy6M,5=legacy9M,6=legacy12M,7=legacy18M,8=legacy24M,9=legacy36M,10=legacy48M,11=legacy54M */
-#define BIT_R_LEGACYxM_TXDIFF_19DB_RATE_OFFSET(x)                   ((u32)(((x) & 0x0000000F) << 12))
-#define BIT_GET_R_LEGACYxM_TXDIFF_19DB_RATE_OFFSET(x)               ((u32)(((x >> 12) & 0x0000000F)))
-#define BIT_MASK_R_LEGACYxM_TXDIFF_18DB_RATE_OFFSET                 ((u32)0x0000000F << 8)          /*!<R/W 0  U(4.0) legacy 4~11,4=legacy6M,5=legacy9M,6=legacy12M,7=legacy18M,8=legacy24M,9=legacy36M,10=legacy48M,11=legacy54M */
-#define BIT_R_LEGACYxM_TXDIFF_18DB_RATE_OFFSET(x)                   ((u32)(((x) & 0x0000000F) << 8))
-#define BIT_GET_R_LEGACYxM_TXDIFF_18DB_RATE_OFFSET(x)               ((u32)(((x >> 8) & 0x0000000F)))
-#define BIT_MASK_R_LEGACYxM_TXDIFF_17DB_RATE_OFFSET                 ((u32)0x0000000F << 4)          /*!<R/W 0  U(4.0) legacy 4~11,4=legacy6M,5=legacy9M,6=legacy12M,7=legacy18M,8=legacy24M,9=legacy36M,10=legacy48M,11=legacy54M */
-#define BIT_R_LEGACYxM_TXDIFF_17DB_RATE_OFFSET(x)                   ((u32)(((x) & 0x0000000F) << 4))
-#define BIT_GET_R_LEGACYxM_TXDIFF_17DB_RATE_OFFSET(x)               ((u32)(((x >> 4) & 0x0000000F)))
-#define BIT_MASK_R_LEGACYxM_TXDIFF_16DB_RATE_OFFSET                 ((u32)0x0000000F << 0)          /*!<R/W 0  U(4.0) legacy 4~11,4=legacy6M,5=legacy9M,6=legacy12M,7=legacy18M,8=legacy24M,9=legacy36M,10=legacy48M,11=legacy54M */
-#define BIT_R_LEGACYxM_TXDIFF_16DB_RATE_OFFSET(x)                   ((u32)(((x) & 0x0000000F) << 0))
-#define BIT_GET_R_LEGACYxM_TXDIFF_16DB_RATE_OFFSET(x)               ((u32)(((x >> 0) & 0x0000000F)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_AX_PWR_TCM_WRAPPER_CR0
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_R_BF_1STS_ANT_SEL_A                                     ((u32)0x00000001 << 31)          /*!<R/W 0   */
-#define BIT_MASK_R_GRP_2TX_PATH_EN                                  ((u32)0x0000000F << 27)          /*!<R/W 0   */
-#define BIT_R_GRP_2TX_PATH_EN(x)                                    ((u32)(((x) & 0x0000000F) << 27))
-#define BIT_GET_R_GRP_2TX_PATH_EN(x)                                ((u32)(((x >> 27) & 0x0000000F)))
-#define BIT_MASK_R_GRP_1TX_PATH_EN                                  ((u32)0x0000000F << 23)          /*!<R/W 0   */
-#define BIT_R_GRP_1TX_PATH_EN(x)                                    ((u32)(((x) & 0x0000000F) << 23))
-#define BIT_GET_R_GRP_1TX_PATH_EN(x)                                ((u32)(((x >> 23) & 0x0000000F)))
-#define BIT_MASK_R_FORCE_MACID_ANT_PATH_EN_VAL                      ((u32)0x0000000F << 19)          /*!<R/W 0   */
-#define BIT_R_FORCE_MACID_ANT_PATH_EN_VAL(x)                        ((u32)(((x) & 0x0000000F) << 19))
-#define BIT_GET_R_FORCE_MACID_ANT_PATH_EN_VAL(x)                    ((u32)(((x >> 19) & 0x0000000F)))
-#define BIT_MASK_R_FC_PATH_EN                                       ((u32)0x0000000F << 15)          /*!<R/W 0   */
-#define BIT_R_FC_PATH_EN(x)                                         ((u32)(((x) & 0x0000000F) << 15))
-#define BIT_GET_R_FC_PATH_EN(x)                                     ((u32)(((x >> 15) & 0x0000000F)))
-#define BIT_MASK_R_BF_2STS_PATH_EN                                  ((u32)0x0000000F << 11)          /*!<R/W 0   */
-#define BIT_R_BF_2STS_PATH_EN(x)                                    ((u32)(((x) & 0x0000000F) << 11))
-#define BIT_GET_R_BF_2STS_PATH_EN(x)                                ((u32)(((x >> 11) & 0x0000000F)))
-#define BIT_MASK_R_BF_1STS_PATH_EN                                  ((u32)0x0000000F << 7)          /*!<R/W 0   */
-#define BIT_R_BF_1STS_PATH_EN(x)                                    ((u32)(((x) & 0x0000000F) << 7))
-#define BIT_GET_R_BF_1STS_PATH_EN(x)                                ((u32)(((x >> 7) & 0x0000000F)))
-#define BIT_MASK_R_USR_LIST_TBL_RA                                  ((u32)0x0000007F << 0)          /*!<R/W 0   */
-#define BIT_R_USR_LIST_TBL_RA(x)                                    ((u32)(((x) & 0x0000007F) << 0))
-#define BIT_GET_R_USR_LIST_TBL_RA(x)                                ((u32)(((x >> 0) & 0x0000007F)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_AX_PWR_TCM_WRAPPER_CR1
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_MASK_R_NORM_1STS_PATH_EN                                ((u32)0x0000000F << 28)          /*!<R/W 0   */
-#define BIT_R_NORM_1STS_PATH_EN(x)                                  ((u32)(((x) & 0x0000000F) << 28))
-#define BIT_GET_R_NORM_1STS_PATH_EN(x)                              ((u32)(((x >> 28) & 0x0000000F)))
-#define BIT_MASK_R_HANG_PROOF_PATH_EN                               ((u32)0x0000000F << 24)          /*!<R/W 0   */
-#define BIT_R_HANG_PROOF_PATH_EN(x)                                 ((u32)(((x) & 0x0000000F) << 24))
-#define BIT_GET_R_HANG_PROOF_PATH_EN(x)                             ((u32)(((x >> 24) & 0x0000000F)))
-#define BIT_MASK_R_GRP_8TX_PATH_EN                                  ((u32)0x0000000F << 20)          /*!<R/W 0   */
-#define BIT_R_GRP_8TX_PATH_EN(x)                                    ((u32)(((x) & 0x0000000F) << 20))
-#define BIT_GET_R_GRP_8TX_PATH_EN(x)                                ((u32)(((x >> 20) & 0x0000000F)))
-#define BIT_MASK_R_GRP_7TX_PATH_EN                                  ((u32)0x0000000F << 16)          /*!<R/W 0   */
-#define BIT_R_GRP_7TX_PATH_EN(x)                                    ((u32)(((x) & 0x0000000F) << 16))
-#define BIT_GET_R_GRP_7TX_PATH_EN(x)                                ((u32)(((x >> 16) & 0x0000000F)))
-#define BIT_MASK_R_GRP_6TX_PATH_EN                                  ((u32)0x0000000F << 12)          /*!<R/W 0   */
-#define BIT_R_GRP_6TX_PATH_EN(x)                                    ((u32)(((x) & 0x0000000F) << 12))
-#define BIT_GET_R_GRP_6TX_PATH_EN(x)                                ((u32)(((x >> 12) & 0x0000000F)))
-#define BIT_MASK_R_GRP_5TX_PATH_EN                                  ((u32)0x0000000F << 8)          /*!<R/W 0   */
-#define BIT_R_GRP_5TX_PATH_EN(x)                                    ((u32)(((x) & 0x0000000F) << 8))
-#define BIT_GET_R_GRP_5TX_PATH_EN(x)                                ((u32)(((x >> 8) & 0x0000000F)))
-#define BIT_MASK_R_GRP_4TX_PATH_EN                                  ((u32)0x0000000F << 4)          /*!<R/W 0   */
-#define BIT_R_GRP_4TX_PATH_EN(x)                                    ((u32)(((x) & 0x0000000F) << 4))
-#define BIT_GET_R_GRP_4TX_PATH_EN(x)                                ((u32)(((x >> 4) & 0x0000000F)))
-#define BIT_MASK_R_GRP_3TX_PATH_EN                                  ((u32)0x0000000F << 0)          /*!<R/W 0   */
-#define BIT_R_GRP_3TX_PATH_EN(x)                                    ((u32)(((x) & 0x0000000F) << 0))
-#define BIT_GET_R_GRP_3TX_PATH_EN(x)                                ((u32)(((x >> 0) & 0x0000000F)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_AX_PWR_TCM_WRAPPER_CR2
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_MASK_R_BF_1STS_PATH_MAP_A                               ((u32)0x00000003 << 30)          /*!<R/W 0   */
-#define BIT_R_BF_1STS_PATH_MAP_A(x)                                 ((u32)(((x) & 0x00000003) << 30))
-#define BIT_GET_R_BF_1STS_PATH_MAP_A(x)                             ((u32)(((x >> 30) & 0x00000003)))
-#define BIT_MASK_R_FORCE_PAR_MODE_VAL                               ((u32)0x00000007 << 27)          /*!<R/W 0   */
-#define BIT_R_FORCE_PAR_MODE_VAL(x)                                 ((u32)(((x) & 0x00000007) << 27))
-#define BIT_GET_R_FORCE_PAR_MODE_VAL(x)                             ((u32)(((x >> 27) & 0x00000007)))
-#define BIT_MASK_R_FORCE_MACID_ANT_SPATIAL_EXPAN_NUM_VAL            ((u32)0x00000007 << 24)          /*!<R/W 0   */
-#define BIT_R_FORCE_MACID_ANT_SPATIAL_EXPAN_NUM_VAL(x)              ((u32)(((x) & 0x00000007) << 24))
-#define BIT_GET_R_FORCE_MACID_ANT_SPATIAL_EXPAN_NUM_VAL(x)          ((u32)(((x >> 24) & 0x00000007)))
-#define BIT_MASK_R_FC_SPATIAL_EXPAN_NUM                             ((u32)0x00000007 << 21)          /*!<R/W 0   */
-#define BIT_R_FC_SPATIAL_EXPAN_NUM(x)                               ((u32)(((x) & 0x00000007) << 21))
-#define BIT_GET_R_FC_SPATIAL_EXPAN_NUM(x)                           ((u32)(((x >> 21) & 0x00000007)))
-#define BIT_MASK_R_FC_NTX                                           ((u32)0x00000007 << 18)          /*!<R/W 0   */
-#define BIT_R_FC_NTX(x)                                             ((u32)(((x) & 0x00000007) << 18))
-#define BIT_GET_R_FC_NTX(x)                                         ((u32)(((x >> 18) & 0x00000007)))
-#define BIT_MASK_R_BF_2STS_SPATIAL_EXPAN_NUM                        ((u32)0x00000007 << 15)          /*!<R/W 0   */
-#define BIT_R_BF_2STS_SPATIAL_EXPAN_NUM(x)                          ((u32)(((x) & 0x00000007) << 15))
-#define BIT_GET_R_BF_2STS_SPATIAL_EXPAN_NUM(x)                      ((u32)(((x >> 15) & 0x00000007)))
-#define BIT_MASK_R_BF_1STS_SPATIAL_EXPAN_NUM                        ((u32)0x00000007 << 12)          /*!<R/W 0   */
-#define BIT_R_BF_1STS_SPATIAL_EXPAN_NUM(x)                          ((u32)(((x) & 0x00000007) << 12))
-#define BIT_GET_R_BF_1STS_SPATIAL_EXPAN_NUM(x)                      ((u32)(((x >> 12) & 0x00000007)))
-#define BIT_MASK_R_RESP_2STS_PATH_EN                                ((u32)0x0000000F << 8)          /*!<R/W 0   */
-#define BIT_R_RESP_2STS_PATH_EN(x)                                  ((u32)(((x) & 0x0000000F) << 8))
-#define BIT_GET_R_RESP_2STS_PATH_EN(x)                              ((u32)(((x >> 8) & 0x0000000F)))
-#define BIT_MASK_R_RESP_1STS_PATH_EN                                ((u32)0x0000000F << 4)          /*!<R/W 0   */
-#define BIT_R_RESP_1STS_PATH_EN(x)                                  ((u32)(((x) & 0x0000000F) << 4))
-#define BIT_GET_R_RESP_1STS_PATH_EN(x)                              ((u32)(((x >> 4) & 0x0000000F)))
-#define BIT_MASK_R_NORM_2STS_PATH_EN                                ((u32)0x0000000F << 0)          /*!<R/W 0   */
-#define BIT_R_NORM_2STS_PATH_EN(x)                                  ((u32)(((x) & 0x0000000F) << 0))
-#define BIT_GET_R_NORM_2STS_PATH_EN(x)                              ((u32)(((x >> 0) & 0x0000000F)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_AX_PWR_TCM_WRAPPER_CR3
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_MASK_R_BF_1STS_PATH_MAP_B                               ((u32)0x00000003 << 30)          /*!<R/W 0   */
-#define BIT_R_BF_1STS_PATH_MAP_B(x)                                 ((u32)(((x) & 0x00000003) << 30))
-#define BIT_GET_R_BF_1STS_PATH_MAP_B(x)                             ((u32)(((x >> 30) & 0x00000003)))
-#define BIT_MASK_R_NORM_1STS_SPATIAL_EXPAN_NUM                      ((u32)0x00000007 << 27)          /*!<R/W 0   */
-#define BIT_R_NORM_1STS_SPATIAL_EXPAN_NUM(x)                        ((u32)(((x) & 0x00000007) << 27))
-#define BIT_GET_R_NORM_1STS_SPATIAL_EXPAN_NUM(x)                    ((u32)(((x >> 27) & 0x00000007)))
-#define BIT_MASK_R_HANG_PROOF_SPATIAL_EXPAN_NUM                     ((u32)0x00000007 << 24)          /*!<R/W 0   */
-#define BIT_R_HANG_PROOF_SPATIAL_EXPAN_NUM(x)                       ((u32)(((x) & 0x00000007) << 24))
-#define BIT_GET_R_HANG_PROOF_SPATIAL_EXPAN_NUM(x)                   ((u32)(((x >> 24) & 0x00000007)))
-#define BIT_MASK_R_GRP_8TX_SPATIAL_EXPAN_NUM                        ((u32)0x00000007 << 21)          /*!<R/W 0   */
-#define BIT_R_GRP_8TX_SPATIAL_EXPAN_NUM(x)                          ((u32)(((x) & 0x00000007) << 21))
-#define BIT_GET_R_GRP_8TX_SPATIAL_EXPAN_NUM(x)                      ((u32)(((x >> 21) & 0x00000007)))
-#define BIT_MASK_R_GRP_7TX_SPATIAL_EXPAN_NUM                        ((u32)0x00000007 << 18)          /*!<R/W 0   */
-#define BIT_R_GRP_7TX_SPATIAL_EXPAN_NUM(x)                          ((u32)(((x) & 0x00000007) << 18))
-#define BIT_GET_R_GRP_7TX_SPATIAL_EXPAN_NUM(x)                      ((u32)(((x >> 18) & 0x00000007)))
-#define BIT_MASK_R_GRP_6TX_SPATIAL_EXPAN_NUM                        ((u32)0x00000007 << 15)          /*!<R/W 0   */
-#define BIT_R_GRP_6TX_SPATIAL_EXPAN_NUM(x)                          ((u32)(((x) & 0x00000007) << 15))
-#define BIT_GET_R_GRP_6TX_SPATIAL_EXPAN_NUM(x)                      ((u32)(((x >> 15) & 0x00000007)))
-#define BIT_MASK_R_GRP_5TX_SPATIAL_EXPAN_NUM                        ((u32)0x00000007 << 12)          /*!<R/W 0   */
-#define BIT_R_GRP_5TX_SPATIAL_EXPAN_NUM(x)                          ((u32)(((x) & 0x00000007) << 12))
-#define BIT_GET_R_GRP_5TX_SPATIAL_EXPAN_NUM(x)                      ((u32)(((x >> 12) & 0x00000007)))
-#define BIT_MASK_R_GRP_4TX_SPATIAL_EXPAN_NUM                        ((u32)0x00000007 << 9)          /*!<R/W 0   */
-#define BIT_R_GRP_4TX_SPATIAL_EXPAN_NUM(x)                          ((u32)(((x) & 0x00000007) << 9))
-#define BIT_GET_R_GRP_4TX_SPATIAL_EXPAN_NUM(x)                      ((u32)(((x >> 9) & 0x00000007)))
-#define BIT_MASK_R_GRP_3TX_SPATIAL_EXPAN_NUM                        ((u32)0x00000007 << 6)          /*!<R/W 0   */
-#define BIT_R_GRP_3TX_SPATIAL_EXPAN_NUM(x)                          ((u32)(((x) & 0x00000007) << 6))
-#define BIT_GET_R_GRP_3TX_SPATIAL_EXPAN_NUM(x)                      ((u32)(((x >> 6) & 0x00000007)))
-#define BIT_MASK_R_GRP_2TX_SPATIAL_EXPAN_NUM                        ((u32)0x00000007 << 3)          /*!<R/W 0   */
-#define BIT_R_GRP_2TX_SPATIAL_EXPAN_NUM(x)                          ((u32)(((x) & 0x00000007) << 3))
-#define BIT_GET_R_GRP_2TX_SPATIAL_EXPAN_NUM(x)                      ((u32)(((x >> 3) & 0x00000007)))
-#define BIT_MASK_R_GRP_1TX_SPATIAL_EXPAN_NUM                        ((u32)0x00000007 << 0)          /*!<R/W 0   */
-#define BIT_R_GRP_1TX_SPATIAL_EXPAN_NUM(x)                          ((u32)(((x) & 0x00000007) << 0))
-#define BIT_GET_R_GRP_1TX_SPATIAL_EXPAN_NUM(x)                      ((u32)(((x >> 0) & 0x00000007)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_AX_PWR_TCM_WRAPPER_CR4
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_R_BF_1STS_ANT_SEL_B                                     ((u32)0x00000001 << 31)          /*!<R/W 0   */
-#define BIT_MASK_R_FORCE_MACID_ANT_MAP_A_VAL                        ((u32)0x00000003 << 29)          /*!<R/W 0   */
-#define BIT_R_FORCE_MACID_ANT_MAP_A_VAL(x)                          ((u32)(((x) & 0x00000003) << 29))
-#define BIT_GET_R_FORCE_MACID_ANT_MAP_A_VAL(x)                      ((u32)(((x >> 29) & 0x00000003)))
-#define BIT_MASK_R_FC_PATH_MAP_D                                    ((u32)0x00000003 << 27)          /*!<R/W 0   */
-#define BIT_R_FC_PATH_MAP_D(x)                                      ((u32)(((x) & 0x00000003) << 27))
-#define BIT_GET_R_FC_PATH_MAP_D(x)                                  ((u32)(((x >> 27) & 0x00000003)))
-#define BIT_MASK_R_FC_PATH_MAP_C                                    ((u32)0x00000003 << 25)          /*!<R/W 0   */
-#define BIT_R_FC_PATH_MAP_C(x)                                      ((u32)(((x) & 0x00000003) << 25))
-#define BIT_GET_R_FC_PATH_MAP_C(x)                                  ((u32)(((x >> 25) & 0x00000003)))
-#define BIT_MASK_R_FC_PATH_MAP_B                                    ((u32)0x00000003 << 23)          /*!<R/W 0   */
-#define BIT_R_FC_PATH_MAP_B(x)                                      ((u32)(((x) & 0x00000003) << 23))
-#define BIT_GET_R_FC_PATH_MAP_B(x)                                  ((u32)(((x >> 23) & 0x00000003)))
-#define BIT_MASK_R_FC_PATH_MAP_A                                    ((u32)0x00000003 << 21)          /*!<R/W 0   */
-#define BIT_R_FC_PATH_MAP_A(x)                                      ((u32)(((x) & 0x00000003) << 21))
-#define BIT_GET_R_FC_PATH_MAP_A(x)                                  ((u32)(((x >> 21) & 0x00000003)))
-#define BIT_MASK_R_BF_2STS_PATH_MAP_D                               ((u32)0x00000003 << 19)          /*!<R/W 0   */
-#define BIT_R_BF_2STS_PATH_MAP_D(x)                                 ((u32)(((x) & 0x00000003) << 19))
-#define BIT_GET_R_BF_2STS_PATH_MAP_D(x)                             ((u32)(((x >> 19) & 0x00000003)))
-#define BIT_MASK_R_BF_2STS_PATH_MAP_C                               ((u32)0x00000003 << 17)          /*!<R/W 0   */
-#define BIT_R_BF_2STS_PATH_MAP_C(x)                                 ((u32)(((x) & 0x00000003) << 17))
-#define BIT_GET_R_BF_2STS_PATH_MAP_C(x)                             ((u32)(((x >> 17) & 0x00000003)))
-#define BIT_MASK_R_BF_2STS_PATH_MAP_B                               ((u32)0x00000003 << 15)          /*!<R/W 0   */
-#define BIT_R_BF_2STS_PATH_MAP_B(x)                                 ((u32)(((x) & 0x00000003) << 15))
-#define BIT_GET_R_BF_2STS_PATH_MAP_B(x)                             ((u32)(((x >> 15) & 0x00000003)))
-#define BIT_MASK_R_BF_2STS_PATH_MAP_A                               ((u32)0x00000003 << 13)          /*!<R/W 0   */
-#define BIT_R_BF_2STS_PATH_MAP_A(x)                                 ((u32)(((x) & 0x00000003) << 13))
-#define BIT_GET_R_BF_2STS_PATH_MAP_A(x)                             ((u32)(((x >> 13) & 0x00000003)))
-#define BIT_MASK_R_BF_1STS_PATH_MAP_D                               ((u32)0x00000003 << 11)          /*!<R/W 0   */
-#define BIT_R_BF_1STS_PATH_MAP_D(x)                                 ((u32)(((x) & 0x00000003) << 11))
-#define BIT_GET_R_BF_1STS_PATH_MAP_D(x)                             ((u32)(((x >> 11) & 0x00000003)))
-#define BIT_MASK_R_BF_1STS_PATH_MAP_C                               ((u32)0x00000003 << 9)          /*!<R/W 0   */
-#define BIT_R_BF_1STS_PATH_MAP_C(x)                                 ((u32)(((x) & 0x00000003) << 9))
-#define BIT_GET_R_BF_1STS_PATH_MAP_C(x)                             ((u32)(((x >> 9) & 0x00000003)))
-#define BIT_MASK_R_RESP_2STS_SPATIAL_EXPAN_NUM                      ((u32)0x00000007 << 6)          /*!<R/W 0   */
-#define BIT_R_RESP_2STS_SPATIAL_EXPAN_NUM(x)                        ((u32)(((x) & 0x00000007) << 6))
-#define BIT_GET_R_RESP_2STS_SPATIAL_EXPAN_NUM(x)                    ((u32)(((x >> 6) & 0x00000007)))
-#define BIT_MASK_R_RESP_1STS_SPATIAL_EXPAN_NUM                      ((u32)0x00000007 << 3)          /*!<R/W 0   */
-#define BIT_R_RESP_1STS_SPATIAL_EXPAN_NUM(x)                        ((u32)(((x) & 0x00000007) << 3))
-#define BIT_GET_R_RESP_1STS_SPATIAL_EXPAN_NUM(x)                    ((u32)(((x >> 3) & 0x00000007)))
-#define BIT_MASK_R_NORM_2STS_SPATIAL_EXPAN_NUM                      ((u32)0x00000007 << 0)          /*!<R/W 0   */
-#define BIT_R_NORM_2STS_SPATIAL_EXPAN_NUM(x)                        ((u32)(((x) & 0x00000007) << 0))
-#define BIT_GET_R_NORM_2STS_SPATIAL_EXPAN_NUM(x)                    ((u32)(((x >> 0) & 0x00000007)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_AX_PWR_TCM_WRAPPER_CR5
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_MASK_R_GRP_4TX_PATH_MAP_A                               ((u32)0x00000003 << 30)          /*!<R/W 0   */
-#define BIT_R_GRP_4TX_PATH_MAP_A(x)                                 ((u32)(((x) & 0x00000003) << 30))
-#define BIT_GET_R_GRP_4TX_PATH_MAP_A(x)                             ((u32)(((x >> 30) & 0x00000003)))
-#define BIT_MASK_R_GRP_3TX_PATH_MAP_D                               ((u32)0x00000003 << 28)          /*!<R/W 0   */
-#define BIT_R_GRP_3TX_PATH_MAP_D(x)                                 ((u32)(((x) & 0x00000003) << 28))
-#define BIT_GET_R_GRP_3TX_PATH_MAP_D(x)                             ((u32)(((x >> 28) & 0x00000003)))
-#define BIT_MASK_R_GRP_3TX_PATH_MAP_C                               ((u32)0x00000003 << 26)          /*!<R/W 0   */
-#define BIT_R_GRP_3TX_PATH_MAP_C(x)                                 ((u32)(((x) & 0x00000003) << 26))
-#define BIT_GET_R_GRP_3TX_PATH_MAP_C(x)                             ((u32)(((x >> 26) & 0x00000003)))
-#define BIT_MASK_R_GRP_3TX_PATH_MAP_B                               ((u32)0x00000003 << 24)          /*!<R/W 0   */
-#define BIT_R_GRP_3TX_PATH_MAP_B(x)                                 ((u32)(((x) & 0x00000003) << 24))
-#define BIT_GET_R_GRP_3TX_PATH_MAP_B(x)                             ((u32)(((x >> 24) & 0x00000003)))
-#define BIT_MASK_R_GRP_3TX_PATH_MAP_A                               ((u32)0x00000003 << 22)          /*!<R/W 0   */
-#define BIT_R_GRP_3TX_PATH_MAP_A(x)                                 ((u32)(((x) & 0x00000003) << 22))
-#define BIT_GET_R_GRP_3TX_PATH_MAP_A(x)                             ((u32)(((x >> 22) & 0x00000003)))
-#define BIT_MASK_R_GRP_2TX_PATH_MAP_D                               ((u32)0x00000003 << 20)          /*!<R/W 0   */
-#define BIT_R_GRP_2TX_PATH_MAP_D(x)                                 ((u32)(((x) & 0x00000003) << 20))
-#define BIT_GET_R_GRP_2TX_PATH_MAP_D(x)                             ((u32)(((x >> 20) & 0x00000003)))
-#define BIT_MASK_R_GRP_2TX_PATH_MAP_C                               ((u32)0x00000003 << 18)          /*!<R/W 0   */
-#define BIT_R_GRP_2TX_PATH_MAP_C(x)                                 ((u32)(((x) & 0x00000003) << 18))
-#define BIT_GET_R_GRP_2TX_PATH_MAP_C(x)                             ((u32)(((x >> 18) & 0x00000003)))
-#define BIT_MASK_R_GRP_2TX_PATH_MAP_B                               ((u32)0x00000003 << 16)          /*!<R/W 0   */
-#define BIT_R_GRP_2TX_PATH_MAP_B(x)                                 ((u32)(((x) & 0x00000003) << 16))
-#define BIT_GET_R_GRP_2TX_PATH_MAP_B(x)                             ((u32)(((x >> 16) & 0x00000003)))
-#define BIT_MASK_R_GRP_2TX_PATH_MAP_A                               ((u32)0x00000003 << 14)          /*!<R/W 0   */
-#define BIT_R_GRP_2TX_PATH_MAP_A(x)                                 ((u32)(((x) & 0x00000003) << 14))
-#define BIT_GET_R_GRP_2TX_PATH_MAP_A(x)                             ((u32)(((x >> 14) & 0x00000003)))
-#define BIT_MASK_R_GRP_1TX_PATH_MAP_D                               ((u32)0x00000003 << 12)          /*!<R/W 0   */
-#define BIT_R_GRP_1TX_PATH_MAP_D(x)                                 ((u32)(((x) & 0x00000003) << 12))
-#define BIT_GET_R_GRP_1TX_PATH_MAP_D(x)                             ((u32)(((x >> 12) & 0x00000003)))
-#define BIT_MASK_R_GRP_1TX_PATH_MAP_C                               ((u32)0x00000003 << 10)          /*!<R/W 0   */
-#define BIT_R_GRP_1TX_PATH_MAP_C(x)                                 ((u32)(((x) & 0x00000003) << 10))
-#define BIT_GET_R_GRP_1TX_PATH_MAP_C(x)                             ((u32)(((x >> 10) & 0x00000003)))
-#define BIT_MASK_R_GRP_1TX_PATH_MAP_B                               ((u32)0x00000003 << 8)          /*!<R/W 0   */
-#define BIT_R_GRP_1TX_PATH_MAP_B(x)                                 ((u32)(((x) & 0x00000003) << 8))
-#define BIT_GET_R_GRP_1TX_PATH_MAP_B(x)                             ((u32)(((x >> 8) & 0x00000003)))
-#define BIT_MASK_R_GRP_1TX_PATH_MAP_A                               ((u32)0x00000003 << 6)          /*!<R/W 0   */
-#define BIT_R_GRP_1TX_PATH_MAP_A(x)                                 ((u32)(((x) & 0x00000003) << 6))
-#define BIT_GET_R_GRP_1TX_PATH_MAP_A(x)                             ((u32)(((x >> 6) & 0x00000003)))
-#define BIT_MASK_R_FORCE_MACID_ANT_MAP_D_VAL                        ((u32)0x00000003 << 4)          /*!<R/W 0   */
-#define BIT_R_FORCE_MACID_ANT_MAP_D_VAL(x)                          ((u32)(((x) & 0x00000003) << 4))
-#define BIT_GET_R_FORCE_MACID_ANT_MAP_D_VAL(x)                      ((u32)(((x >> 4) & 0x00000003)))
-#define BIT_MASK_R_FORCE_MACID_ANT_MAP_C_VAL                        ((u32)0x00000003 << 2)          /*!<R/W 0   */
-#define BIT_R_FORCE_MACID_ANT_MAP_C_VAL(x)                          ((u32)(((x) & 0x00000003) << 2))
-#define BIT_GET_R_FORCE_MACID_ANT_MAP_C_VAL(x)                      ((u32)(((x >> 2) & 0x00000003)))
-#define BIT_MASK_R_FORCE_MACID_ANT_MAP_B_VAL                        ((u32)0x00000003 << 0)          /*!<R/W 0   */
-#define BIT_R_FORCE_MACID_ANT_MAP_B_VAL(x)                          ((u32)(((x) & 0x00000003) << 0))
-#define BIT_GET_R_FORCE_MACID_ANT_MAP_B_VAL(x)                      ((u32)(((x >> 0) & 0x00000003)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_AX_PWR_TCM_WRAPPER_CR6
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_MASK_R_GRP_8TX_PATH_MAP_A                               ((u32)0x00000003 << 30)          /*!<R/W 0   */
-#define BIT_R_GRP_8TX_PATH_MAP_A(x)                                 ((u32)(((x) & 0x00000003) << 30))
-#define BIT_GET_R_GRP_8TX_PATH_MAP_A(x)                             ((u32)(((x >> 30) & 0x00000003)))
-#define BIT_MASK_R_GRP_7TX_PATH_MAP_D                               ((u32)0x00000003 << 28)          /*!<R/W 0   */
-#define BIT_R_GRP_7TX_PATH_MAP_D(x)                                 ((u32)(((x) & 0x00000003) << 28))
-#define BIT_GET_R_GRP_7TX_PATH_MAP_D(x)                             ((u32)(((x >> 28) & 0x00000003)))
-#define BIT_MASK_R_GRP_7TX_PATH_MAP_C                               ((u32)0x00000003 << 26)          /*!<R/W 0   */
-#define BIT_R_GRP_7TX_PATH_MAP_C(x)                                 ((u32)(((x) & 0x00000003) << 26))
-#define BIT_GET_R_GRP_7TX_PATH_MAP_C(x)                             ((u32)(((x >> 26) & 0x00000003)))
-#define BIT_MASK_R_GRP_7TX_PATH_MAP_B                               ((u32)0x00000003 << 24)          /*!<R/W 0   */
-#define BIT_R_GRP_7TX_PATH_MAP_B(x)                                 ((u32)(((x) & 0x00000003) << 24))
-#define BIT_GET_R_GRP_7TX_PATH_MAP_B(x)                             ((u32)(((x >> 24) & 0x00000003)))
-#define BIT_MASK_R_GRP_7TX_PATH_MAP_A                               ((u32)0x00000003 << 22)          /*!<R/W 0   */
-#define BIT_R_GRP_7TX_PATH_MAP_A(x)                                 ((u32)(((x) & 0x00000003) << 22))
-#define BIT_GET_R_GRP_7TX_PATH_MAP_A(x)                             ((u32)(((x >> 22) & 0x00000003)))
-#define BIT_MASK_R_GRP_6TX_PATH_MAP_D                               ((u32)0x00000003 << 20)          /*!<R/W 0   */
-#define BIT_R_GRP_6TX_PATH_MAP_D(x)                                 ((u32)(((x) & 0x00000003) << 20))
-#define BIT_GET_R_GRP_6TX_PATH_MAP_D(x)                             ((u32)(((x >> 20) & 0x00000003)))
-#define BIT_MASK_R_GRP_6TX_PATH_MAP_C                               ((u32)0x00000003 << 18)          /*!<R/W 0   */
-#define BIT_R_GRP_6TX_PATH_MAP_C(x)                                 ((u32)(((x) & 0x00000003) << 18))
-#define BIT_GET_R_GRP_6TX_PATH_MAP_C(x)                             ((u32)(((x >> 18) & 0x00000003)))
-#define BIT_MASK_R_GRP_6TX_PATH_MAP_B                               ((u32)0x00000003 << 16)          /*!<R/W 0   */
-#define BIT_R_GRP_6TX_PATH_MAP_B(x)                                 ((u32)(((x) & 0x00000003) << 16))
-#define BIT_GET_R_GRP_6TX_PATH_MAP_B(x)                             ((u32)(((x >> 16) & 0x00000003)))
-#define BIT_MASK_R_GRP_6TX_PATH_MAP_A                               ((u32)0x00000003 << 14)          /*!<R/W 0   */
-#define BIT_R_GRP_6TX_PATH_MAP_A(x)                                 ((u32)(((x) & 0x00000003) << 14))
-#define BIT_GET_R_GRP_6TX_PATH_MAP_A(x)                             ((u32)(((x >> 14) & 0x00000003)))
-#define BIT_MASK_R_GRP_5TX_PATH_MAP_D                               ((u32)0x00000003 << 12)          /*!<R/W 0   */
-#define BIT_R_GRP_5TX_PATH_MAP_D(x)                                 ((u32)(((x) & 0x00000003) << 12))
-#define BIT_GET_R_GRP_5TX_PATH_MAP_D(x)                             ((u32)(((x >> 12) & 0x00000003)))
-#define BIT_MASK_R_GRP_5TX_PATH_MAP_C                               ((u32)0x00000003 << 10)          /*!<R/W 0   */
-#define BIT_R_GRP_5TX_PATH_MAP_C(x)                                 ((u32)(((x) & 0x00000003) << 10))
-#define BIT_GET_R_GRP_5TX_PATH_MAP_C(x)                             ((u32)(((x >> 10) & 0x00000003)))
-#define BIT_MASK_R_GRP_5TX_PATH_MAP_B                               ((u32)0x00000003 << 8)          /*!<R/W 0   */
-#define BIT_R_GRP_5TX_PATH_MAP_B(x)                                 ((u32)(((x) & 0x00000003) << 8))
-#define BIT_GET_R_GRP_5TX_PATH_MAP_B(x)                             ((u32)(((x >> 8) & 0x00000003)))
-#define BIT_MASK_R_GRP_5TX_PATH_MAP_A                               ((u32)0x00000003 << 6)          /*!<R/W 0   */
-#define BIT_R_GRP_5TX_PATH_MAP_A(x)                                 ((u32)(((x) & 0x00000003) << 6))
-#define BIT_GET_R_GRP_5TX_PATH_MAP_A(x)                             ((u32)(((x >> 6) & 0x00000003)))
-#define BIT_MASK_R_GRP_4TX_PATH_MAP_D                               ((u32)0x00000003 << 4)          /*!<R/W 0   */
-#define BIT_R_GRP_4TX_PATH_MAP_D(x)                                 ((u32)(((x) & 0x00000003) << 4))
-#define BIT_GET_R_GRP_4TX_PATH_MAP_D(x)                             ((u32)(((x >> 4) & 0x00000003)))
-#define BIT_MASK_R_GRP_4TX_PATH_MAP_C                               ((u32)0x00000003 << 2)          /*!<R/W 0   */
-#define BIT_R_GRP_4TX_PATH_MAP_C(x)                                 ((u32)(((x) & 0x00000003) << 2))
-#define BIT_GET_R_GRP_4TX_PATH_MAP_C(x)                             ((u32)(((x >> 2) & 0x00000003)))
-#define BIT_MASK_R_GRP_4TX_PATH_MAP_B                               ((u32)0x00000003 << 0)          /*!<R/W 0   */
-#define BIT_R_GRP_4TX_PATH_MAP_B(x)                                 ((u32)(((x) & 0x00000003) << 0))
-#define BIT_GET_R_GRP_4TX_PATH_MAP_B(x)                             ((u32)(((x >> 0) & 0x00000003)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_AX_PWR_TCM_WRAPPER_CR7
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_MASK_R_RESP_1STS_PATH_MAP_A                             ((u32)0x00000003 << 30)          /*!<R/W 0   */
-#define BIT_R_RESP_1STS_PATH_MAP_A(x)                               ((u32)(((x) & 0x00000003) << 30))
-#define BIT_GET_R_RESP_1STS_PATH_MAP_A(x)                           ((u32)(((x >> 30) & 0x00000003)))
-#define BIT_MASK_R_NORM_2STS_PATH_MAP_D                             ((u32)0x00000003 << 28)          /*!<R/W 0   */
-#define BIT_R_NORM_2STS_PATH_MAP_D(x)                               ((u32)(((x) & 0x00000003) << 28))
-#define BIT_GET_R_NORM_2STS_PATH_MAP_D(x)                           ((u32)(((x >> 28) & 0x00000003)))
-#define BIT_MASK_R_NORM_2STS_PATH_MAP_C                             ((u32)0x00000003 << 26)          /*!<R/W 0   */
-#define BIT_R_NORM_2STS_PATH_MAP_C(x)                               ((u32)(((x) & 0x00000003) << 26))
-#define BIT_GET_R_NORM_2STS_PATH_MAP_C(x)                           ((u32)(((x >> 26) & 0x00000003)))
-#define BIT_MASK_R_NORM_2STS_PATH_MAP_B                             ((u32)0x00000003 << 24)          /*!<R/W 0   */
-#define BIT_R_NORM_2STS_PATH_MAP_B(x)                               ((u32)(((x) & 0x00000003) << 24))
-#define BIT_GET_R_NORM_2STS_PATH_MAP_B(x)                           ((u32)(((x >> 24) & 0x00000003)))
-#define BIT_MASK_R_NORM_2STS_PATH_MAP_A                             ((u32)0x00000003 << 22)          /*!<R/W 0   */
-#define BIT_R_NORM_2STS_PATH_MAP_A(x)                               ((u32)(((x) & 0x00000003) << 22))
-#define BIT_GET_R_NORM_2STS_PATH_MAP_A(x)                           ((u32)(((x >> 22) & 0x00000003)))
-#define BIT_MASK_R_NORM_1STS_PATH_MAP_D                             ((u32)0x00000003 << 20)          /*!<R/W 0   */
-#define BIT_R_NORM_1STS_PATH_MAP_D(x)                               ((u32)(((x) & 0x00000003) << 20))
-#define BIT_GET_R_NORM_1STS_PATH_MAP_D(x)                           ((u32)(((x >> 20) & 0x00000003)))
-#define BIT_MASK_R_NORM_1STS_PATH_MAP_C                             ((u32)0x00000003 << 18)          /*!<R/W 0   */
-#define BIT_R_NORM_1STS_PATH_MAP_C(x)                               ((u32)(((x) & 0x00000003) << 18))
-#define BIT_GET_R_NORM_1STS_PATH_MAP_C(x)                           ((u32)(((x >> 18) & 0x00000003)))
-#define BIT_MASK_R_NORM_1STS_PATH_MAP_B                             ((u32)0x00000003 << 16)          /*!<R/W 0   */
-#define BIT_R_NORM_1STS_PATH_MAP_B(x)                               ((u32)(((x) & 0x00000003) << 16))
-#define BIT_GET_R_NORM_1STS_PATH_MAP_B(x)                           ((u32)(((x >> 16) & 0x00000003)))
-#define BIT_MASK_R_NORM_1STS_PATH_MAP_A                             ((u32)0x00000003 << 14)          /*!<R/W 0   */
-#define BIT_R_NORM_1STS_PATH_MAP_A(x)                               ((u32)(((x) & 0x00000003) << 14))
-#define BIT_GET_R_NORM_1STS_PATH_MAP_A(x)                           ((u32)(((x >> 14) & 0x00000003)))
-#define BIT_MASK_R_HANG_PROOF_PATH_MAP_D                            ((u32)0x00000003 << 12)          /*!<R/W 0   */
-#define BIT_R_HANG_PROOF_PATH_MAP_D(x)                              ((u32)(((x) & 0x00000003) << 12))
-#define BIT_GET_R_HANG_PROOF_PATH_MAP_D(x)                          ((u32)(((x >> 12) & 0x00000003)))
-#define BIT_MASK_R_HANG_PROOF_PATH_MAP_C                            ((u32)0x00000003 << 10)          /*!<R/W 0   */
-#define BIT_R_HANG_PROOF_PATH_MAP_C(x)                              ((u32)(((x) & 0x00000003) << 10))
-#define BIT_GET_R_HANG_PROOF_PATH_MAP_C(x)                          ((u32)(((x >> 10) & 0x00000003)))
-#define BIT_MASK_R_HANG_PROOF_PATH_MAP_B                            ((u32)0x00000003 << 8)          /*!<R/W 0   */
-#define BIT_R_HANG_PROOF_PATH_MAP_B(x)                              ((u32)(((x) & 0x00000003) << 8))
-#define BIT_GET_R_HANG_PROOF_PATH_MAP_B(x)                          ((u32)(((x >> 8) & 0x00000003)))
-#define BIT_MASK_R_HANG_PROOF_PATH_MAP_A                            ((u32)0x00000003 << 6)          /*!<R/W 0   */
-#define BIT_R_HANG_PROOF_PATH_MAP_A(x)                              ((u32)(((x) & 0x00000003) << 6))
-#define BIT_GET_R_HANG_PROOF_PATH_MAP_A(x)                          ((u32)(((x >> 6) & 0x00000003)))
-#define BIT_MASK_R_GRP_8TX_PATH_MAP_D                               ((u32)0x00000003 << 4)          /*!<R/W 0   */
-#define BIT_R_GRP_8TX_PATH_MAP_D(x)                                 ((u32)(((x) & 0x00000003) << 4))
-#define BIT_GET_R_GRP_8TX_PATH_MAP_D(x)                             ((u32)(((x >> 4) & 0x00000003)))
-#define BIT_MASK_R_GRP_8TX_PATH_MAP_C                               ((u32)0x00000003 << 2)          /*!<R/W 0   */
-#define BIT_R_GRP_8TX_PATH_MAP_C(x)                                 ((u32)(((x) & 0x00000003) << 2))
-#define BIT_GET_R_GRP_8TX_PATH_MAP_C(x)                             ((u32)(((x >> 2) & 0x00000003)))
-#define BIT_MASK_R_GRP_8TX_PATH_MAP_B                               ((u32)0x00000003 << 0)          /*!<R/W 0   */
-#define BIT_R_GRP_8TX_PATH_MAP_B(x)                                 ((u32)(((x) & 0x00000003) << 0))
-#define BIT_GET_R_GRP_8TX_PATH_MAP_B(x)                             ((u32)(((x >> 0) & 0x00000003)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_AX_PWR_TCM_WRAPPER_CR8
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_R_FC_NTX_EN                                             ((u32)0x00000001 << 31)          /*!<R/W 0   */
-#define BIT_R_FC_ANT_SEL_D_EN                                       ((u32)0x00000001 << 30)          /*!<R/W 0   */
-#define BIT_R_FC_ANT_SEL_D                                          ((u32)0x00000001 << 29)          /*!<R/W 0   */
-#define BIT_R_FC_ANT_SEL_C_EN                                       ((u32)0x00000001 << 28)          /*!<R/W 0   */
-#define BIT_R_FC_ANT_SEL_C                                          ((u32)0x00000001 << 27)          /*!<R/W 0   */
-#define BIT_R_FC_ANT_SEL_B_EN                                       ((u32)0x00000001 << 26)          /*!<R/W 0   */
-#define BIT_R_FC_ANT_SEL_B                                          ((u32)0x00000001 << 25)          /*!<R/W 0   */
-#define BIT_R_FC_ANT_SEL_A_EN                                       ((u32)0x00000001 << 24)          /*!<R/W 0   */
-#define BIT_R_FC_ANT_SEL_A                                          ((u32)0x00000001 << 23)          /*!<R/W 0   */
-#define BIT_R_CLR_PROOF_CNT                                         ((u32)0x00000001 << 22)          /*!<R/W 0   */
-#define BIT_R_CBW80P80_EN                                           ((u32)0x00000001 << 21)          /*!<R/W 0   */
-#define BIT_R_BYPASS_ANT_SEL_HETB_BW80P80_EN                        ((u32)0x00000001 << 20)          /*!<R/W 0   */
-#define BIT_R_BF_2STS_ANT_SEL_D                                     ((u32)0x00000001 << 19)          /*!<R/W 0   */
-#define BIT_R_BF_2STS_ANT_SEL_C                                     ((u32)0x00000001 << 18)          /*!<R/W 0   */
-#define BIT_R_BF_2STS_ANT_SEL_B                                     ((u32)0x00000001 << 17)          /*!<R/W 0   */
-#define BIT_R_BF_2STS_ANT_SEL_A                                     ((u32)0x00000001 << 16)          /*!<R/W 0   */
-#define BIT_R_BF_1STS_ANT_SEL_D                                     ((u32)0x00000001 << 15)          /*!<R/W 0   */
-#define BIT_R_BF_1STS_ANT_SEL_C                                     ((u32)0x00000001 << 14)          /*!<R/W 0   */
-#define BIT_MASK_R_RESP_2STS_PATH_MAP_D                             ((u32)0x00000003 << 12)          /*!<R/W 0   */
-#define BIT_R_RESP_2STS_PATH_MAP_D(x)                               ((u32)(((x) & 0x00000003) << 12))
-#define BIT_GET_R_RESP_2STS_PATH_MAP_D(x)                           ((u32)(((x >> 12) & 0x00000003)))
-#define BIT_MASK_R_RESP_2STS_PATH_MAP_C                             ((u32)0x00000003 << 10)          /*!<R/W 0   */
-#define BIT_R_RESP_2STS_PATH_MAP_C(x)                               ((u32)(((x) & 0x00000003) << 10))
-#define BIT_GET_R_RESP_2STS_PATH_MAP_C(x)                           ((u32)(((x >> 10) & 0x00000003)))
-#define BIT_MASK_R_RESP_2STS_PATH_MAP_B                             ((u32)0x00000003 << 8)          /*!<R/W 0   */
-#define BIT_R_RESP_2STS_PATH_MAP_B(x)                               ((u32)(((x) & 0x00000003) << 8))
-#define BIT_GET_R_RESP_2STS_PATH_MAP_B(x)                           ((u32)(((x >> 8) & 0x00000003)))
-#define BIT_MASK_R_RESP_2STS_PATH_MAP_A                             ((u32)0x00000003 << 6)          /*!<R/W 0   */
-#define BIT_R_RESP_2STS_PATH_MAP_A(x)                               ((u32)(((x) & 0x00000003) << 6))
-#define BIT_GET_R_RESP_2STS_PATH_MAP_A(x)                           ((u32)(((x >> 6) & 0x00000003)))
-#define BIT_MASK_R_RESP_1STS_PATH_MAP_D                             ((u32)0x00000003 << 4)          /*!<R/W 0   */
-#define BIT_R_RESP_1STS_PATH_MAP_D(x)                               ((u32)(((x) & 0x00000003) << 4))
-#define BIT_GET_R_RESP_1STS_PATH_MAP_D(x)                           ((u32)(((x >> 4) & 0x00000003)))
-#define BIT_MASK_R_RESP_1STS_PATH_MAP_C                             ((u32)0x00000003 << 2)          /*!<R/W 0   */
-#define BIT_R_RESP_1STS_PATH_MAP_C(x)                               ((u32)(((x) & 0x00000003) << 2))
-#define BIT_GET_R_RESP_1STS_PATH_MAP_C(x)                           ((u32)(((x >> 2) & 0x00000003)))
-#define BIT_MASK_R_RESP_1STS_PATH_MAP_B                             ((u32)0x00000003 << 0)          /*!<R/W 0   */
-#define BIT_R_RESP_1STS_PATH_MAP_B(x)                               ((u32)(((x) & 0x00000003) << 0))
-#define BIT_GET_R_RESP_1STS_PATH_MAP_B(x)                           ((u32)(((x >> 0) & 0x00000003)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_AX_PWR_TCM_WRAPPER_CR9
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_R_GRP_2TX_ANT_SEL_C                                     ((u32)0x00000001 << 31)          /*!<R/W 0   */
-#define BIT_R_GRP_2TX_ANT_SEL_B                                     ((u32)0x00000001 << 30)          /*!<R/W 0   */
-#define BIT_R_GRP_2TX_ANT_SEL_A                                     ((u32)0x00000001 << 29)          /*!<R/W 0   */
-#define BIT_R_GRP_1TX_ANT_SEL_D                                     ((u32)0x00000001 << 28)          /*!<R/W 0   */
-#define BIT_R_GRP_1TX_ANT_SEL_C                                     ((u32)0x00000001 << 27)          /*!<R/W 0   */
-#define BIT_R_GRP_1TX_ANT_SEL_B                                     ((u32)0x00000001 << 26)          /*!<R/W 0   */
-#define BIT_R_GRP_1TX_ANT_SEL_A                                     ((u32)0x00000001 << 25)          /*!<R/W 0   */
-#define BIT_R_FORCE_PAR_MODE_ON                                     ((u32)0x00000001 << 24)          /*!<R/W 0   */
-#define BIT_R_FORCE_MACID_INPUT_MUMIMO_NSTS_HANG_PROOF_EN_VAL       ((u32)0x00000001 << 23)          /*!<R/W 0   */
-#define BIT_R_FORCE_MACID_INPUT_MUMIMO_NSTS_HANG_PROOF_EN_ON        ((u32)0x00000001 << 22)          /*!<R/W 0   */
-#define BIT_R_FORCE_MACID_HANG_PROOF_EN_VAL                         ((u32)0x00000001 << 21)          /*!<R/W 0   */
-#define BIT_R_FORCE_MACID_HANG_PROOF_EN_ON                          ((u32)0x00000001 << 20)          /*!<R/W 0   */
-#define BIT_R_FORCE_MACID_ANT_SPATIAL_EXPAN_NUM_ON                  ((u32)0x00000001 << 19)          /*!<R/W 0   */
-#define BIT_R_FORCE_MACID_ANT_SEL_D_VAL                             ((u32)0x00000001 << 18)          /*!<R/W 0   */
-#define BIT_R_FORCE_MACID_ANT_SEL_D_ON                              ((u32)0x00000001 << 17)          /*!<R/W 0   */
-#define BIT_R_FORCE_MACID_ANT_SEL_C_VAL                             ((u32)0x00000001 << 16)          /*!<R/W 0   */
-#define BIT_R_FORCE_MACID_ANT_SEL_C_ON                              ((u32)0x00000001 << 15)          /*!<R/W 0   */
-#define BIT_R_FORCE_MACID_ANT_SEL_B_VAL                             ((u32)0x00000001 << 14)          /*!<R/W 0   */
-#define BIT_R_FORCE_MACID_ANT_SEL_B_ON                              ((u32)0x00000001 << 13)          /*!<R/W 0   */
-#define BIT_R_FORCE_MACID_ANT_SEL_A_VAL                             ((u32)0x00000001 << 12)          /*!<R/W 0   */
-#define BIT_R_FORCE_MACID_ANT_SEL_A_ON                              ((u32)0x00000001 << 11)          /*!<R/W 0   */
-#define BIT_R_FORCE_MACID_ANT_PATH_EN_ON                            ((u32)0x00000001 << 10)          /*!<R/W 0   */
-#define BIT_R_FORCE_MACID_ANT_MAP_D_ON                              ((u32)0x00000001 << 9)          /*!<R/W 0   */
-#define BIT_R_FORCE_MACID_ANT_MAP_C_ON                              ((u32)0x00000001 << 8)          /*!<R/W 0   */
-#define BIT_R_FORCE_MACID_ANT_MAP_B_ON                              ((u32)0x00000001 << 7)          /*!<R/W 0   */
-#define BIT_R_FORCE_MACID_ANT_MAP_A_ON                              ((u32)0x00000001 << 6)          /*!<R/W 0   */
-#define BIT_R_FC_SPATIAL_EXPAN_NUM_EN                               ((u32)0x00000001 << 5)          /*!<R/W 0   */
-#define BIT_R_FC_PATH_MAP_D_EN                                      ((u32)0x00000001 << 4)          /*!<R/W 0   */
-#define BIT_R_FC_PATH_MAP_C_EN                                      ((u32)0x00000001 << 3)          /*!<R/W 0   */
-#define BIT_R_FC_PATH_MAP_B_EN                                      ((u32)0x00000001 << 2)          /*!<R/W 0   */
-#define BIT_R_FC_PATH_MAP_A_EN                                      ((u32)0x00000001 << 1)          /*!<R/W 0   */
-#define BIT_R_FC_PATH_EN_EN                                         ((u32)0x00000001 << 0)          /*!<R/W 0   */
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_AX_PWR_TCM_WRAPPER_CR10
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_R_INPUT_MUMIMO_NSTS_HANG_PROOF_EN                       ((u32)0x00000001 << 31)          /*!<R/W 0   */
-#define BIT_R_HANG_PROOF_OPT                                        ((u32)0x00000001 << 30)          /*!<R/W 0   */
-#define BIT_R_HANG_PROOF_EN                                         ((u32)0x00000001 << 29)          /*!<R/W 0   */
-#define BIT_R_HANG_PROOF_ANT_SEL_D                                  ((u32)0x00000001 << 28)          /*!<R/W 0   */
-#define BIT_R_HANG_PROOF_ANT_SEL_C                                  ((u32)0x00000001 << 27)          /*!<R/W 0   */
-#define BIT_R_HANG_PROOF_ANT_SEL_B                                  ((u32)0x00000001 << 26)          /*!<R/W 0   */
-#define BIT_R_HANG_PROOF_ANT_SEL_A                                  ((u32)0x00000001 << 25)          /*!<R/W 0   */
-#define BIT_R_GRP_8TX_ANT_SEL_D                                     ((u32)0x00000001 << 24)          /*!<R/W 0   */
-#define BIT_R_GRP_8TX_ANT_SEL_C                                     ((u32)0x00000001 << 23)          /*!<R/W 0   */
-#define BIT_R_GRP_8TX_ANT_SEL_B                                     ((u32)0x00000001 << 22)          /*!<R/W 0   */
-#define BIT_R_GRP_8TX_ANT_SEL_A                                     ((u32)0x00000001 << 21)          /*!<R/W 0   */
-#define BIT_R_GRP_7TX_ANT_SEL_D                                     ((u32)0x00000001 << 20)          /*!<R/W 0   */
-#define BIT_R_GRP_7TX_ANT_SEL_C                                     ((u32)0x00000001 << 19)          /*!<R/W 0   */
-#define BIT_R_GRP_7TX_ANT_SEL_B                                     ((u32)0x00000001 << 18)          /*!<R/W 0   */
-#define BIT_R_GRP_7TX_ANT_SEL_A                                     ((u32)0x00000001 << 17)          /*!<R/W 0   */
-#define BIT_R_GRP_6TX_ANT_SEL_D                                     ((u32)0x00000001 << 16)          /*!<R/W 0   */
-#define BIT_R_GRP_6TX_ANT_SEL_C                                     ((u32)0x00000001 << 15)          /*!<R/W 0   */
-#define BIT_R_GRP_6TX_ANT_SEL_B                                     ((u32)0x00000001 << 14)          /*!<R/W 0   */
-#define BIT_R_GRP_6TX_ANT_SEL_A                                     ((u32)0x00000001 << 13)          /*!<R/W 0   */
-#define BIT_R_GRP_5TX_ANT_SEL_D                                     ((u32)0x00000001 << 12)          /*!<R/W 0   */
-#define BIT_R_GRP_5TX_ANT_SEL_C                                     ((u32)0x00000001 << 11)          /*!<R/W 0   */
-#define BIT_R_GRP_5TX_ANT_SEL_B                                     ((u32)0x00000001 << 10)          /*!<R/W 0   */
-#define BIT_R_GRP_5TX_ANT_SEL_A                                     ((u32)0x00000001 << 9)          /*!<R/W 0   */
-#define BIT_R_GRP_4TX_ANT_SEL_D                                     ((u32)0x00000001 << 8)          /*!<R/W 0   */
-#define BIT_R_GRP_4TX_ANT_SEL_C                                     ((u32)0x00000001 << 7)          /*!<R/W 0   */
-#define BIT_R_GRP_4TX_ANT_SEL_B                                     ((u32)0x00000001 << 6)          /*!<R/W 0   */
-#define BIT_R_GRP_4TX_ANT_SEL_A                                     ((u32)0x00000001 << 5)          /*!<R/W 0   */
-#define BIT_R_GRP_3TX_ANT_SEL_D                                     ((u32)0x00000001 << 4)          /*!<R/W 0   */
-#define BIT_R_GRP_3TX_ANT_SEL_C                                     ((u32)0x00000001 << 3)          /*!<R/W 0   */
-#define BIT_R_GRP_3TX_ANT_SEL_B                                     ((u32)0x00000001 << 2)          /*!<R/W 0   */
-#define BIT_R_GRP_3TX_ANT_SEL_A                                     ((u32)0x00000001 << 1)          /*!<R/W 0   */
-#define BIT_R_GRP_2TX_ANT_SEL_D                                     ((u32)0x00000001 << 0)          /*!<R/W 0   */
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_AX_PWR_TCM_WRAPPER_CR11
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_R_FORCE_HANG_PROOF_ON                                   ((u32)0x00000001 << 20)          /*!<R/W 0   */
-#define BIT_R_USR_LIST_TBL_RD                                       ((u32)0x00000001 << 19)          /*!<R/W 0   */
-#define BIT_R_RESP_2STSANT_SEL_D                                    ((u32)0x00000001 << 18)          /*!<R/W 0   */
-#define BIT_R_RESP_2STSANT_SEL_C                                    ((u32)0x00000001 << 17)          /*!<R/W 0   */
-#define BIT_R_RESP_2STSANT_SEL_B                                    ((u32)0x00000001 << 16)          /*!<R/W 0   */
-#define BIT_R_RESP_2STSANT_SEL_A                                    ((u32)0x00000001 << 15)          /*!<R/W 0   */
-#define BIT_R_RESP_1STSANT_SEL_D                                    ((u32)0x00000001 << 14)          /*!<R/W 0   */
-#define BIT_R_RESP_1STSANT_SEL_C                                    ((u32)0x00000001 << 13)          /*!<R/W 0   */
-#define BIT_R_RESP_1STSANT_SEL_B                                    ((u32)0x00000001 << 12)          /*!<R/W 0   */
-#define BIT_R_RESP_1STSANT_SEL_A                                    ((u32)0x00000001 << 11)          /*!<R/W 0   */
-#define BIT_R_NORM_2STSANT_SEL_D                                    ((u32)0x00000001 << 10)          /*!<R/W 0   */
-#define BIT_R_NORM_2STSANT_SEL_C                                    ((u32)0x00000001 << 9)          /*!<R/W 0   */
-#define BIT_R_NORM_2STSANT_SEL_B                                    ((u32)0x00000001 << 8)          /*!<R/W 0   */
-#define BIT_R_NORM_2STSANT_SEL_A                                    ((u32)0x00000001 << 7)          /*!<R/W 0   */
-#define BIT_R_NORM_1STSANT_SEL_D                                    ((u32)0x00000001 << 6)          /*!<R/W 0   */
-#define BIT_R_NORM_1STSANT_SEL_C                                    ((u32)0x00000001 << 5)          /*!<R/W 0   */
-#define BIT_R_NORM_1STSANT_SEL_B                                    ((u32)0x00000001 << 4)          /*!<R/W 0   */
-#define BIT_R_NORM_1STSANT_SEL_A                                    ((u32)0x00000001 << 3)          /*!<R/W 0   */
-#define BIT_R_N_TX_CAL_MOD_HANG_PROOF                               ((u32)0x00000001 << 2)          /*!<R/W 0   */
-#define BIT_R_N_TX_CAL_MOD                                          ((u32)0x00000001 << 1)          /*!<R/W 0   */
-#define BIT_R_INPUT_MUMIMO_NSTS_HANG_PROOF_OPT                      ((u32)0x00000001 << 0)          /*!<R/W 0   */
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_AX_PWR_TCM_WRAPPER_CR12
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_MASK_R_FORCE_PWRSR_TXPWR_PD_VAL                         ((u32)0x0000003F << 26)          /*!<R/W 0   */
-#define BIT_R_FORCE_PWRSR_TXPWR_PD_VAL(x)                           ((u32)(((x) & 0x0000003F) << 26))
-#define BIT_GET_R_FORCE_PWRSR_TXPWR_PD_VAL(x)                       ((u32)(((x >> 26) & 0x0000003F)))
-#define BIT_MASK_R_FORCE_PWRCOM_RU_ALLOC_VAL                        ((u32)0x000000FF << 18)          /*!<R/W 0   */
-#define BIT_R_FORCE_PWRCOM_RU_ALLOC_VAL(x)                          ((u32)(((x) & 0x000000FF) << 18))
-#define BIT_GET_R_FORCE_PWRCOM_RU_ALLOC_VAL(x)                      ((u32)(((x >> 18) & 0x000000FF)))
-#define BIT_MASK_R_FORCE_PWRUL_RPL_VAL                              ((u32)0x000001FF << 9)          /*!<R/W 0   */
-#define BIT_R_FORCE_PWRUL_RPL_VAL(x)                                ((u32)(((x) & 0x000001FF) << 9))
-#define BIT_GET_R_FORCE_PWRUL_RPL_VAL(x)                            ((u32)(((x >> 9) & 0x000001FF)))
-#define BIT_MASK_R_FORCE_PWRUL_RPL_UP_VAL                           ((u32)0x000001FF << 0)          /*!<R/W 0   */
-#define BIT_R_FORCE_PWRUL_RPL_UP_VAL(x)                             ((u32)(((x) & 0x000001FF) << 0))
-#define BIT_GET_R_FORCE_PWRUL_RPL_UP_VAL(x)                         ((u32)(((x >> 0) & 0x000001FF)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_AX_PWR_TCM_WRAPPER_CR13
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_MASK_R_DBG_ANT_SEL                                      ((u32)0x0000000F << 28)          /*!<R/W 0   */
-#define BIT_R_DBG_ANT_SEL(x)                                        ((u32)(((x) & 0x0000000F) << 28))
-#define BIT_GET_R_DBG_ANT_SEL(x)                                    ((u32)(((x >> 28) & 0x0000000F)))
-#define BIT_MASK_R_FORCE_PWRSR_TXPWR_TOLER_VAL                      ((u32)0x0000003F << 22)          /*!<R/W 0   */
-#define BIT_R_FORCE_PWRSR_TXPWR_TOLER_VAL(x)                        ((u32)(((x) & 0x0000003F) << 22))
-#define BIT_GET_R_FORCE_PWRSR_TXPWR_TOLER_VAL(x)                    ((u32)(((x >> 22) & 0x0000003F)))
-#define BIT_MASK_R_FORCE_PWRUL_TAR_RSSI_VAL                         ((u32)0x0000007F << 15)          /*!<R/W 0   */
-#define BIT_R_FORCE_PWRUL_TAR_RSSI_VAL(x)                           ((u32)(((x) & 0x0000007F) << 15))
-#define BIT_GET_R_FORCE_PWRUL_TAR_RSSI_VAL(x)                       ((u32)(((x >> 15) & 0x0000007F)))
-#define BIT_MASK_R_FORCE_PWRCOM_MACID_VAL                           ((u32)0x0000007F << 8)          /*!<R/W 0   */
-#define BIT_R_FORCE_PWRCOM_MACID_VAL(x)                             ((u32)(((x) & 0x0000007F) << 8))
-#define BIT_GET_R_FORCE_PWRCOM_MACID_VAL(x)                         ((u32)(((x >> 8) & 0x0000007F)))
-#define BIT_MASK_R_FORCE_PWRRU_CH20_WITH_DATA_VAL                   ((u32)0x000000FF << 0)          /*!<R/W 0   */
-#define BIT_R_FORCE_PWRRU_CH20_WITH_DATA_VAL(x)                     ((u32)(((x) & 0x000000FF) << 0))
-#define BIT_GET_R_FORCE_PWRRU_CH20_WITH_DATA_VAL(x)                 ((u32)(((x >> 0) & 0x000000FF)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_AX_PWR_TCM_WRAPPER_CR14
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_MASK_R_FORCE_PWRCOM_CTRL_VAL                            ((u32)0x00000007 << 29)          /*!<R/W 0   */
-#define BIT_R_FORCE_PWRCOM_CTRL_VAL(x)                              ((u32)(((x) & 0x00000007) << 29))
-#define BIT_GET_R_FORCE_PWRCOM_CTRL_VAL(x)                          ((u32)(((x >> 29) & 0x00000007)))
-#define BIT_MASK_R_FORCE_PWRANT_NSTS_VAL                            ((u32)0x00000007 << 26)          /*!<R/W 0   */
-#define BIT_R_FORCE_PWRANT_NSTS_VAL(x)                              ((u32)(((x) & 0x00000007) << 26))
-#define BIT_GET_R_FORCE_PWRANT_NSTS_VAL(x)                          ((u32)(((x >> 26) & 0x00000007)))
-#define BIT_MASK_R_FORCE_MACID_PWR_MODE_VAL                         ((u32)0x00000007 << 23)          /*!<R/W 0   */
-#define BIT_R_FORCE_MACID_PWR_MODE_VAL(x)                           ((u32)(((x) & 0x00000007) << 23))
-#define BIT_GET_R_FORCE_MACID_PWR_MODE_VAL(x)                       ((u32)(((x >> 23) & 0x00000007)))
-#define BIT_MASK_R_FORCE_PWRCOM_TXSC_VAL                            ((u32)0x0000000F << 19)          /*!<R/W 0   */
-#define BIT_R_FORCE_PWRCOM_TXSC_VAL(x)                              ((u32)(((x) & 0x0000000F) << 19))
-#define BIT_GET_R_FORCE_PWRCOM_TXSC_VAL(x)                          ((u32)(((x >> 19) & 0x0000000F)))
-#define BIT_MASK_R_FORCE_PWRCOM_PPDU_TYPE_VAL                       ((u32)0x0000000F << 15)          /*!<R/W 0   */
-#define BIT_R_FORCE_PWRCOM_PPDU_TYPE_VAL(x)                         ((u32)(((x) & 0x0000000F) << 15))
-#define BIT_GET_R_FORCE_PWRCOM_PPDU_TYPE_VAL(x)                     ((u32)(((x >> 15) & 0x0000000F)))
-#define BIT_MASK_R_FORCE_OUT_PWRCOM_MAX_MCS_VAL                     ((u32)0x0000000F << 11)          /*!<R/W 0   */
-#define BIT_R_FORCE_OUT_PWRCOM_MAX_MCS_VAL(x)                       ((u32)(((x) & 0x0000000F) << 11))
-#define BIT_GET_R_FORCE_OUT_PWRCOM_MAX_MCS_VAL(x)                   ((u32)(((x >> 11) & 0x0000000F)))
-#define BIT_MASK_R_FORCE_PWRCOM_MCS_VAL                             ((u32)0x0000001F << 6)          /*!<R/W 0   */
-#define BIT_R_FORCE_PWRCOM_MCS_VAL(x)                               ((u32)(((x) & 0x0000001F) << 6))
-#define BIT_GET_R_FORCE_PWRCOM_MCS_VAL(x)                           ((u32)(((x >> 6) & 0x0000001F)))
-#define BIT_MASK_R_FORCE_PWRUL_AP_TX_PWR_VAL                        ((u32)0x0000003F << 0)          /*!<R/W 0   */
-#define BIT_R_FORCE_PWRUL_AP_TX_PWR_VAL(x)                          ((u32)(((x) & 0x0000003F) << 0))
-#define BIT_GET_R_FORCE_PWRUL_AP_TX_PWR_VAL(x)                      ((u32)(((x >> 0) & 0x0000003F)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_AX_PWR_TCM_WRAPPER_CR15
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_R_FORCE_MACID_TXBF_EN_VAL                               ((u32)0x00000001 << 31)          /*!<R/W 0   */
-#define BIT_R_FORCE_MACID_TXBF_EN_ON                                ((u32)0x00000001 << 30)          /*!<R/W 0   */
-#define BIT_R_FORCE_MACID_RESP_EN_VAL                               ((u32)0x00000001 << 29)          /*!<R/W 0   */
-#define BIT_R_FORCE_MACID_RESP_EN_ON                                ((u32)0x00000001 << 28)          /*!<R/W 0   */
-#define BIT_R_FORCE_MACID_PWR_MODE_ON                               ((u32)0x00000001 << 27)          /*!<R/W 0   */
-#define BIT_R_FORCE_MACID_NORM_EN_VAL                               ((u32)0x00000001 << 26)          /*!<R/W 0   */
-#define BIT_R_FORCE_MACID_NORM_EN_ON                                ((u32)0x00000001 << 25)          /*!<R/W 0   */
-#define BIT_R_FORCE_MACID_NDP_EN_VAL                                ((u32)0x00000001 << 24)          /*!<R/W 0   */
-#define BIT_R_FORCE_MACID_NDP_EN_ON                                 ((u32)0x00000001 << 23)          /*!<R/W 0   */
-#define BIT_R_FORCE_MACID_MUMIMO_EN_VAL                             ((u32)0x00000001 << 22)          /*!<R/W 0   */
-#define BIT_R_FORCE_MACID_MUMIMO_EN_ON                              ((u32)0x00000001 << 21)          /*!<R/W 0   */
-#define BIT_R_FORCE_MACID_CCA_TH_ALLOW_VAL                          ((u32)0x00000001 << 20)          /*!<R/W 0   */
-#define BIT_R_FORCE_MACID_CCA_TH_ALLOW_ON                           ((u32)0x00000001 << 19)          /*!<R/W 0   */
-#define BIT_R_FORCE_CCA_TH_ALLOW_VAL                                ((u32)0x00000001 << 18)          /*!<R/W 0   */
-#define BIT_R_FORCE_CCA_TH_ALLOW_ON                                 ((u32)0x00000001 << 17)          /*!<R/W 0   */
-#define BIT_R_CLR_ANT_SET                                           ((u32)0x00000001 << 16)          /*!<R/W 0   */
-#define BIT_R_ANT_SEL_DBG_EN                                        ((u32)0x00000001 << 15)          /*!<R/W 0   */
-#define BIT_MASK_R_FORCE_PWRCOM_PRECODING_MODE_IDX_VAL              ((u32)0x00000003 << 7)          /*!<R/W 0   */
-#define BIT_R_FORCE_PWRCOM_PRECODING_MODE_IDX_VAL(x)                ((u32)(((x) & 0x00000003) << 7))
-#define BIT_GET_R_FORCE_PWRCOM_PRECODING_MODE_IDX_VAL(x)            ((u32)(((x >> 7) & 0x00000003)))
-#define BIT_MASK_R_FORCE_PWRCOM_DBW_IDX_VAL                         ((u32)0x00000003 << 5)          /*!<R/W 0   */
-#define BIT_R_FORCE_PWRCOM_DBW_IDX_VAL(x)                           ((u32)(((x) & 0x00000003) << 5))
-#define BIT_GET_R_FORCE_PWRCOM_DBW_IDX_VAL(x)                       ((u32)(((x >> 5) & 0x00000003)))
-#define BIT_MASK_R_FORCE_PWRCOM_CBW_IDX_VAL                         ((u32)0x00000003 << 3)          /*!<R/W 0   */
-#define BIT_R_FORCE_PWRCOM_CBW_IDX_VAL(x)                           ((u32)(((x) & 0x00000003) << 3))
-#define BIT_GET_R_FORCE_PWRCOM_CBW_IDX_VAL(x)                       ((u32)(((x >> 3) & 0x00000003)))
-#define BIT_MASK_R_FORCE_PWRRU_GRP_NTX_VAL                          ((u32)0x00000007 << 0)          /*!<R/W 0   */
-#define BIT_R_FORCE_PWRRU_GRP_NTX_VAL(x)                            ((u32)(((x) & 0x00000007) << 0))
-#define BIT_GET_R_FORCE_PWRRU_GRP_NTX_VAL(x)                        ((u32)(((x >> 0) & 0x00000007)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_AX_PWR_TCM_WRAPPER_CR16
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_R_FORCE_PWRUL_RPL_UP_EN_ON                              ((u32)0x00000001 << 31)          /*!<R/W 0   */
-#define BIT_R_FORCE_PWRUL_RPL_ON                                    ((u32)0x00000001 << 30)          /*!<R/W 0   */
-#define BIT_R_FORCE_PWRUL_AP_TX_PWR_ON                              ((u32)0x00000001 << 29)          /*!<R/W 0   */
-#define BIT_R_FORCE_PWRTSSI_FAST_MODE_EN_VAL                        ((u32)0x00000001 << 28)          /*!<R/W 0   */
-#define BIT_R_FORCE_PWRTSSI_FAST_MODE_EN_ON                         ((u32)0x00000001 << 27)          /*!<R/W 0   */
-#define BIT_R_FORCE_PWRSR_TXPWR_TOLER_ON                            ((u32)0x00000001 << 26)          /*!<R/W 0   */
-#define BIT_R_FORCE_PWRSR_TXPWR_PD_ON                               ((u32)0x00000001 << 25)          /*!<R/W 0   */
-#define BIT_R_FORCE_PWRRU_GRP_NTX_ON                                ((u32)0x00000001 << 24)          /*!<R/W 0   */
-#define BIT_R_FORCE_PWRRU_CH20_WITH_DATA_ON                         ((u32)0x00000001 << 23)          /*!<R/W 0   */
-#define BIT_R_FORCE_PWRCOM_TXSC_ON                                  ((u32)0x00000001 << 22)          /*!<R/W 0   */
-#define BIT_R_FORCE_PWRCOM_STBC_EN_VAL                              ((u32)0x00000001 << 21)          /*!<R/W 0   */
-#define BIT_R_FORCE_PWRCOM_STBC_EN_ON                               ((u32)0x00000001 << 20)          /*!<R/W 0   */
-#define BIT_R_FORCE_PWRCOM_RX_LTE_VAL                               ((u32)0x00000001 << 19)          /*!<R/W 0   */
-#define BIT_R_FORCE_PWRCOM_RX_LTE_ON                                ((u32)0x00000001 << 18)          /*!<R/W 0   */
-#define BIT_R_FORCE_PWRCOM_RU_ALLOC_ON                              ((u32)0x00000001 << 17)          /*!<R/W 0   */
-#define BIT_R_FORCE_PWRCOM_PRECODING_MODE_IDX_ON                    ((u32)0x00000001 << 16)          /*!<R/W 0   */
-#define BIT_R_FORCE_PWRCOM_PPDU_TYPE_ON                             ((u32)0x00000001 << 15)          /*!<R/W 0   */
-#define BIT_R_FORCE_PWRCOM_MCS_ON                                   ((u32)0x00000001 << 14)          /*!<R/W 0   */
-#define BIT_R_FORCE_PWRCOM_MACID_ON                                 ((u32)0x00000001 << 13)          /*!<R/W 0   */
-#define BIT_R_FORCE_PWRCOM_DCM_VAL                                  ((u32)0x00000001 << 12)          /*!<R/W 0   */
-#define BIT_R_FORCE_PWRCOM_DCM_ON                                   ((u32)0x00000001 << 11)          /*!<R/W 0   */
-#define BIT_R_FORCE_PWRCOM_DBW_IDX_ON                               ((u32)0x00000001 << 10)          /*!<R/W 0   */
-#define BIT_R_FORCE_PWRCOM_CTRL_REG_VAL                             ((u32)0x00000001 << 9)          /*!<R/W 0   */
-#define BIT_R_FORCE_PWRCOM_CTRL_REG_ON                              ((u32)0x00000001 << 8)          /*!<R/W 0   */
-#define BIT_R_FORCE_PWRCOM_CTRL_ON                                  ((u32)0x00000001 << 7)          /*!<R/W 0   */
-#define BIT_R_FORCE_PWRCOM_CBW_IDX_ON                               ((u32)0x00000001 << 6)          /*!<R/W 0   */
-#define BIT_R_FORCE_PWRANT_NSTS_ON                                  ((u32)0x00000001 << 5)          /*!<R/W 0   */
-#define BIT_R_FORCE_PWRANT_NDP_EN_VAL                               ((u32)0x00000001 << 4)          /*!<R/W 0   */
-#define BIT_R_FORCE_PWRANT_NDP_EN_ON                                ((u32)0x00000001 << 3)          /*!<R/W 0   */
-#define BIT_R_FORCE_PWRANT_ACTIVE_TX_EN_VAL                         ((u32)0x00000001 << 2)          /*!<R/W 0   */
-#define BIT_R_FORCE_PWRANT_ACTIVE_TX_EN_ON                          ((u32)0x00000001 << 1)          /*!<R/W 0   */
-#define BIT_R_FORCE_OUT_PWRCOM_MAX_MCS_ON                           ((u32)0x00000001 << 0)          /*!<R/W 0   */
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_AX_PWR_TCM_WRAPPER_CR17
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_R_TSSI_CTRL_MAC_PWRCOM_CH20_WITH_DATA_BIT_REV           ((u32)0x00000001 << 9)          /*!<R/W 0   */
-#define BIT_R_TSSI_CTRL_MAC_PWRCOM_CH20_WITH_DATA_BIT_INV           ((u32)0x00000001 << 8)          /*!<R/W 0   */
-#define BIT_R_SR_MCS_MASK_DIS                                       ((u32)0x00000001 << 7)          /*!<R/W 0   */
-#define BIT_R_PWRRU_CH20_WITH_DATA_HANG_PROOF_EN                    ((u32)0x00000001 << 6)          /*!<R/W 0   */
-#define BIT_R_MUMIMO_APPLY_PWRLIMBF_EN                              ((u32)0x00000001 << 5)          /*!<R/W 0   */
-#define BIT_R_HERU_MASK_DIS                                         ((u32)0x00000001 << 4)          /*!<R/W 0   */
-#define BIT_R_HERU_CH20_WITH_DATA_FROM_F2P_DIS                      ((u32)0x00000001 << 3)          /*!<R/W 0   */
-#define BIT_R_FORCE_PWRUL_TAR_RSSI_ON                               ((u32)0x00000001 << 2)          /*!<R/W 0   */
-#define BIT_R_FORCE_PWRUL_RPL_UP_ON                                 ((u32)0x00000001 << 1)          /*!<R/W 0   */
-#define BIT_R_FORCE_PWRUL_RPL_UP_EN_VAL                             ((u32)0x00000001 << 0)          /*!<R/W 0   */
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_AX_PWR_TCM_WRAPPER_CR18
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_R_RU_ALLOC_DBW160_FIX_EN                                ((u32)0x00000001 << 28)          /*!<R/W 0   */
-#define BIT_R_PWRTSSICT_TX_BANDEDGE_CFG_FORCE_OUT_ON                ((u32)0x00000001 << 27)          /*!<R/W 0   */
-#define BIT_R_PWRTSSICT_TSSI_MSR_ATHESTF_FORCE_OUT_VAL              ((u32)0x00000001 << 26)          /*!<R/W 0   */
-#define BIT_R_PWRTSSICT_TSSI_MSR_ATHESTF_FORCE_OUT_ON               ((u32)0x00000001 << 25)          /*!<R/W 0   */
-#define BIT_R_PWRTSSICT_TSSI_FAST_MODE_EN_FORCE_OUT_VAL             ((u32)0x00000001 << 24)          /*!<R/W 0   */
-#define BIT_R_PWRTSSICT_TSSI_FAST_MODE_EN_FORCE_OUT_ON              ((u32)0x00000001 << 23)          /*!<R/W 0   */
-#define BIT_R_PWRTSSICT_TSSI_DIFF_SEG0_DB_FORCE_OUT_ON              ((u32)0x00000001 << 22)          /*!<R/W 0   */
-#define BIT_R_PWRTSSICT_PWR_OFST_SEG0_DB_FORCE_OUT_ON               ((u32)0x00000001 << 21)          /*!<R/W 0   */
-#define BIT_R_MAC_DEF_LEGACY_RATE_IDX_BEGIN_AT_4_ON                 ((u32)0x00000001 << 20)          /*!<R/W 0   */
-#define BIT_MASK_R_PWRTSSICT_TX_BANDEDGE_CFG_FORCE_OUT_VAL          ((u32)0x00000003 << 18)          /*!<R/W 0   */
-#define BIT_R_PWRTSSICT_TX_BANDEDGE_CFG_FORCE_OUT_VAL(x)            ((u32)(((x) & 0x00000003) << 18))
-#define BIT_GET_R_PWRTSSICT_TX_BANDEDGE_CFG_FORCE_OUT_VAL(x)        ((u32)(((x >> 18) & 0x00000003)))
-#define BIT_MASK_R_PWRTSSICT_TSSI_DIFF_SEG0_DB_FORCE_OUT_VAL        ((u32)0x000001FF << 9)          /*!<R/W 0   */
-#define BIT_R_PWRTSSICT_TSSI_DIFF_SEG0_DB_FORCE_OUT_VAL(x)          ((u32)(((x) & 0x000001FF) << 9))
-#define BIT_GET_R_PWRTSSICT_TSSI_DIFF_SEG0_DB_FORCE_OUT_VAL(x)      ((u32)(((x >> 9) & 0x000001FF)))
-#define BIT_MASK_R_PWRTSSICT_PWR_OFST_SEG0_DB_FORCE_OUT_VAL         ((u32)0x000001FF << 0)          /*!<R/W 0   */
-#define BIT_R_PWRTSSICT_PWR_OFST_SEG0_DB_FORCE_OUT_VAL(x)           ((u32)(((x) & 0x000001FF) << 0))
-#define BIT_GET_R_PWRTSSICT_PWR_OFST_SEG0_DB_FORCE_OUT_VAL(x)       ((u32)(((x >> 0) & 0x000001FF)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_AX_PWR_TSSI_TABLE0
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_MASK_R_BANDEDGE_NONZERO_CFG_SBW160_3                    ((u32)0x000000FF << 24)          /*!<R/W 0   */
-#define BIT_R_BANDEDGE_NONZERO_CFG_SBW160_3(x)                      ((u32)(((x) & 0x000000FF) << 24))
-#define BIT_GET_R_BANDEDGE_NONZERO_CFG_SBW160_3(x)                  ((u32)(((x >> 24) & 0x000000FF)))
-#define BIT_MASK_R_BANDEDGE_NONZERO_CFG_SBW160_2                    ((u32)0x000000FF << 16)          /*!<R/W 0   */
-#define BIT_R_BANDEDGE_NONZERO_CFG_SBW160_2(x)                      ((u32)(((x) & 0x000000FF) << 16))
-#define BIT_GET_R_BANDEDGE_NONZERO_CFG_SBW160_2(x)                  ((u32)(((x >> 16) & 0x000000FF)))
-#define BIT_MASK_R_BANDEDGE_NONZERO_CFG_SBW160_1                    ((u32)0x000000FF << 8)          /*!<R/W 0   */
-#define BIT_R_BANDEDGE_NONZERO_CFG_SBW160_1(x)                      ((u32)(((x) & 0x000000FF) << 8))
-#define BIT_GET_R_BANDEDGE_NONZERO_CFG_SBW160_1(x)                  ((u32)(((x >> 8) & 0x000000FF)))
-#define BIT_MASK_R_BANDEDGE_NONZERO_CFG_SBW160_0                    ((u32)0x000000FF << 0)          /*!<R/W 0   */
-#define BIT_R_BANDEDGE_NONZERO_CFG_SBW160_0(x)                      ((u32)(((x) & 0x000000FF) << 0))
-#define BIT_GET_R_BANDEDGE_NONZERO_CFG_SBW160_0(x)                  ((u32)(((x >> 0) & 0x000000FF)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_AX_PWR_TSSI_TABLE1
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_MASK_R_BANDEDGE_NONZERO_CFG_SBW160_7                    ((u32)0x000000FF << 24)          /*!<R/W 0   */
-#define BIT_R_BANDEDGE_NONZERO_CFG_SBW160_7(x)                      ((u32)(((x) & 0x000000FF) << 24))
-#define BIT_GET_R_BANDEDGE_NONZERO_CFG_SBW160_7(x)                  ((u32)(((x >> 24) & 0x000000FF)))
-#define BIT_MASK_R_BANDEDGE_NONZERO_CFG_SBW160_6                    ((u32)0x000000FF << 16)          /*!<R/W 0   */
-#define BIT_R_BANDEDGE_NONZERO_CFG_SBW160_6(x)                      ((u32)(((x) & 0x000000FF) << 16))
-#define BIT_GET_R_BANDEDGE_NONZERO_CFG_SBW160_6(x)                  ((u32)(((x >> 16) & 0x000000FF)))
-#define BIT_MASK_R_BANDEDGE_NONZERO_CFG_SBW160_5                    ((u32)0x000000FF << 8)          /*!<R/W 0   */
-#define BIT_R_BANDEDGE_NONZERO_CFG_SBW160_5(x)                      ((u32)(((x) & 0x000000FF) << 8))
-#define BIT_GET_R_BANDEDGE_NONZERO_CFG_SBW160_5(x)                  ((u32)(((x >> 8) & 0x000000FF)))
-#define BIT_MASK_R_BANDEDGE_NONZERO_CFG_SBW160_4                    ((u32)0x000000FF << 0)          /*!<R/W 0   */
-#define BIT_R_BANDEDGE_NONZERO_CFG_SBW160_4(x)                      ((u32)(((x) & 0x000000FF) << 0))
-#define BIT_GET_R_BANDEDGE_NONZERO_CFG_SBW160_4(x)                  ((u32)(((x >> 0) & 0x000000FF)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_AX_PWR_TSSI_TABLE2
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_MASK_R_BANDEDGE_NONZERO_CFG_SBW80_0                     ((u32)0x000000FF << 24)          /*!<R/W 0   */
-#define BIT_R_BANDEDGE_NONZERO_CFG_SBW80_0(x)                       ((u32)(((x) & 0x000000FF) << 24))
-#define BIT_GET_R_BANDEDGE_NONZERO_CFG_SBW80_0(x)                   ((u32)(((x >> 24) & 0x000000FF)))
-#define BIT_MASK_R_BANDEDGE_NONZERO_CFG_SBW40_1                     ((u32)0x000000FF << 16)          /*!<R/W 0   */
-#define BIT_R_BANDEDGE_NONZERO_CFG_SBW40_1(x)                       ((u32)(((x) & 0x000000FF) << 16))
-#define BIT_GET_R_BANDEDGE_NONZERO_CFG_SBW40_1(x)                   ((u32)(((x >> 16) & 0x000000FF)))
-#define BIT_MASK_R_BANDEDGE_NONZERO_CFG_SBW40_0                     ((u32)0x000000FF << 8)          /*!<R/W 0   */
-#define BIT_R_BANDEDGE_NONZERO_CFG_SBW40_0(x)                       ((u32)(((x) & 0x000000FF) << 8))
-#define BIT_GET_R_BANDEDGE_NONZERO_CFG_SBW40_0(x)                   ((u32)(((x >> 8) & 0x000000FF)))
-#define BIT_MASK_R_BANDEDGE_NONZERO_CFG_SBW20                       ((u32)0x000000FF << 0)          /*!<R/W 0   */
-#define BIT_R_BANDEDGE_NONZERO_CFG_SBW20(x)                         ((u32)(((x) & 0x000000FF) << 0))
-#define BIT_GET_R_BANDEDGE_NONZERO_CFG_SBW20(x)                     ((u32)(((x >> 0) & 0x000000FF)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_AX_PWR_TSSI_TABLE3
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_MASK_R_BANDEDGE_ZERO_CFG_SBW160_0                       ((u32)0x000000FF << 24)          /*!<R/W 0   */
-#define BIT_R_BANDEDGE_ZERO_CFG_SBW160_0(x)                         ((u32)(((x) & 0x000000FF) << 24))
-#define BIT_GET_R_BANDEDGE_ZERO_CFG_SBW160_0(x)                     ((u32)(((x >> 24) & 0x000000FF)))
-#define BIT_MASK_R_BANDEDGE_NONZERO_CFG_SBW80_3                     ((u32)0x000000FF << 16)          /*!<R/W 0   */
-#define BIT_R_BANDEDGE_NONZERO_CFG_SBW80_3(x)                       ((u32)(((x) & 0x000000FF) << 16))
-#define BIT_GET_R_BANDEDGE_NONZERO_CFG_SBW80_3(x)                   ((u32)(((x >> 16) & 0x000000FF)))
-#define BIT_MASK_R_BANDEDGE_NONZERO_CFG_SBW80_2                     ((u32)0x000000FF << 8)          /*!<R/W 0   */
-#define BIT_R_BANDEDGE_NONZERO_CFG_SBW80_2(x)                       ((u32)(((x) & 0x000000FF) << 8))
-#define BIT_GET_R_BANDEDGE_NONZERO_CFG_SBW80_2(x)                   ((u32)(((x >> 8) & 0x000000FF)))
-#define BIT_MASK_R_BANDEDGE_NONZERO_CFG_SBW80_1                     ((u32)0x000000FF << 0)          /*!<R/W 0   */
-#define BIT_R_BANDEDGE_NONZERO_CFG_SBW80_1(x)                       ((u32)(((x) & 0x000000FF) << 0))
-#define BIT_GET_R_BANDEDGE_NONZERO_CFG_SBW80_1(x)                   ((u32)(((x >> 0) & 0x000000FF)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_AX_PWR_TSSI_TABLE4
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_MASK_R_BANDEDGE_ZERO_CFG_SBW160_4                       ((u32)0x000000FF << 24)          /*!<R/W 0   */
-#define BIT_R_BANDEDGE_ZERO_CFG_SBW160_4(x)                         ((u32)(((x) & 0x000000FF) << 24))
-#define BIT_GET_R_BANDEDGE_ZERO_CFG_SBW160_4(x)                     ((u32)(((x >> 24) & 0x000000FF)))
-#define BIT_MASK_R_BANDEDGE_ZERO_CFG_SBW160_3                       ((u32)0x000000FF << 16)          /*!<R/W 0   */
-#define BIT_R_BANDEDGE_ZERO_CFG_SBW160_3(x)                         ((u32)(((x) & 0x000000FF) << 16))
-#define BIT_GET_R_BANDEDGE_ZERO_CFG_SBW160_3(x)                     ((u32)(((x >> 16) & 0x000000FF)))
-#define BIT_MASK_R_BANDEDGE_ZERO_CFG_SBW160_2                       ((u32)0x000000FF << 8)          /*!<R/W 0   */
-#define BIT_R_BANDEDGE_ZERO_CFG_SBW160_2(x)                         ((u32)(((x) & 0x000000FF) << 8))
-#define BIT_GET_R_BANDEDGE_ZERO_CFG_SBW160_2(x)                     ((u32)(((x >> 8) & 0x000000FF)))
-#define BIT_MASK_R_BANDEDGE_ZERO_CFG_SBW160_1                       ((u32)0x000000FF << 0)          /*!<R/W 0   */
-#define BIT_R_BANDEDGE_ZERO_CFG_SBW160_1(x)                         ((u32)(((x) & 0x000000FF) << 0))
-#define BIT_GET_R_BANDEDGE_ZERO_CFG_SBW160_1(x)                     ((u32)(((x >> 0) & 0x000000FF)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_AX_PWR_TSSI_TABLE5
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_MASK_R_BANDEDGE_ZERO_CFG_SBW20                          ((u32)0x000000FF << 24)          /*!<R/W 0   */
-#define BIT_R_BANDEDGE_ZERO_CFG_SBW20(x)                            ((u32)(((x) & 0x000000FF) << 24))
-#define BIT_GET_R_BANDEDGE_ZERO_CFG_SBW20(x)                        ((u32)(((x >> 24) & 0x000000FF)))
-#define BIT_MASK_R_BANDEDGE_ZERO_CFG_SBW160_7                       ((u32)0x000000FF << 16)          /*!<R/W 0   */
-#define BIT_R_BANDEDGE_ZERO_CFG_SBW160_7(x)                         ((u32)(((x) & 0x000000FF) << 16))
-#define BIT_GET_R_BANDEDGE_ZERO_CFG_SBW160_7(x)                     ((u32)(((x >> 16) & 0x000000FF)))
-#define BIT_MASK_R_BANDEDGE_ZERO_CFG_SBW160_6                       ((u32)0x000000FF << 8)          /*!<R/W 0   */
-#define BIT_R_BANDEDGE_ZERO_CFG_SBW160_6(x)                         ((u32)(((x) & 0x000000FF) << 8))
-#define BIT_GET_R_BANDEDGE_ZERO_CFG_SBW160_6(x)                     ((u32)(((x >> 8) & 0x000000FF)))
-#define BIT_MASK_R_BANDEDGE_ZERO_CFG_SBW160_5                       ((u32)0x000000FF << 0)          /*!<R/W 0   */
-#define BIT_R_BANDEDGE_ZERO_CFG_SBW160_5(x)                         ((u32)(((x) & 0x000000FF) << 0))
-#define BIT_GET_R_BANDEDGE_ZERO_CFG_SBW160_5(x)                     ((u32)(((x >> 0) & 0x000000FF)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_AX_PWR_TSSI_TABLE6
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_MASK_R_BANDEDGE_ZERO_CFG_SBW80_1                        ((u32)0x000000FF << 24)          /*!<R/W 0   */
-#define BIT_R_BANDEDGE_ZERO_CFG_SBW80_1(x)                          ((u32)(((x) & 0x000000FF) << 24))
-#define BIT_GET_R_BANDEDGE_ZERO_CFG_SBW80_1(x)                      ((u32)(((x >> 24) & 0x000000FF)))
-#define BIT_MASK_R_BANDEDGE_ZERO_CFG_SBW80_0                        ((u32)0x000000FF << 16)          /*!<R/W 0   */
-#define BIT_R_BANDEDGE_ZERO_CFG_SBW80_0(x)                          ((u32)(((x) & 0x000000FF) << 16))
-#define BIT_GET_R_BANDEDGE_ZERO_CFG_SBW80_0(x)                      ((u32)(((x >> 16) & 0x000000FF)))
-#define BIT_MASK_R_BANDEDGE_ZERO_CFG_SBW40_1                        ((u32)0x000000FF << 8)          /*!<R/W 0   */
-#define BIT_R_BANDEDGE_ZERO_CFG_SBW40_1(x)                          ((u32)(((x) & 0x000000FF) << 8))
-#define BIT_GET_R_BANDEDGE_ZERO_CFG_SBW40_1(x)                      ((u32)(((x >> 8) & 0x000000FF)))
-#define BIT_MASK_R_BANDEDGE_ZERO_CFG_SBW40_0                        ((u32)0x000000FF << 0)          /*!<R/W 0   */
-#define BIT_R_BANDEDGE_ZERO_CFG_SBW40_0(x)                          ((u32)(((x) & 0x000000FF) << 0))
-#define BIT_GET_R_BANDEDGE_ZERO_CFG_SBW40_0(x)                      ((u32)(((x >> 0) & 0x000000FF)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_AX_PWR_TSSI_TABLE7
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_MASK_R_BMODE_INIT_OFST_SEG0_DB                          ((u32)0x000000FF << 24)          /*!<R/W 0   */
-#define BIT_R_BMODE_INIT_OFST_SEG0_DB(x)                            ((u32)(((x) & 0x000000FF) << 24))
-#define BIT_GET_R_BMODE_INIT_OFST_SEG0_DB(x)                        ((u32)(((x >> 24) & 0x000000FF)))
-#define BIT_MASK_R_BMODE_INIT_DIFF_SEG0_DB                          ((u32)0x000000FF << 16)          /*!<R/W 0   */
-#define BIT_R_BMODE_INIT_DIFF_SEG0_DB(x)                            ((u32)(((x) & 0x000000FF) << 16))
-#define BIT_GET_R_BMODE_INIT_DIFF_SEG0_DB(x)                        ((u32)(((x >> 16) & 0x000000FF)))
-#define BIT_MASK_R_BANDEDGE_ZERO_CFG_SBW80_3                        ((u32)0x000000FF << 8)          /*!<R/W 0   */
-#define BIT_R_BANDEDGE_ZERO_CFG_SBW80_3(x)                          ((u32)(((x) & 0x000000FF) << 8))
-#define BIT_GET_R_BANDEDGE_ZERO_CFG_SBW80_3(x)                      ((u32)(((x >> 8) & 0x000000FF)))
-#define BIT_MASK_R_BANDEDGE_ZERO_CFG_SBW80_2                        ((u32)0x000000FF << 0)          /*!<R/W 0   */
-#define BIT_R_BANDEDGE_ZERO_CFG_SBW80_2(x)                          ((u32)(((x) & 0x000000FF) << 0))
-#define BIT_GET_R_BANDEDGE_ZERO_CFG_SBW80_2(x)                      ((u32)(((x >> 0) & 0x000000FF)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_AX_PWR_TSSI_TABLE8
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_MASK_R_CBW_SUB20_3                                      ((u32)0x000000FF << 24)          /*!<R/W 0   */
-#define BIT_R_CBW_SUB20_3(x)                                        ((u32)(((x) & 0x000000FF) << 24))
-#define BIT_GET_R_CBW_SUB20_3(x)                                    ((u32)(((x >> 24) & 0x000000FF)))
-#define BIT_MASK_R_CBW_SUB20_2                                      ((u32)0x000000FF << 16)          /*!<R/W 0   */
-#define BIT_R_CBW_SUB20_2(x)                                        ((u32)(((x) & 0x000000FF) << 16))
-#define BIT_GET_R_CBW_SUB20_2(x)                                    ((u32)(((x >> 16) & 0x000000FF)))
-#define BIT_MASK_R_CBW_SUB20_1                                      ((u32)0x000000FF << 8)          /*!<R/W 0   */
-#define BIT_R_CBW_SUB20_1(x)                                        ((u32)(((x) & 0x000000FF) << 8))
-#define BIT_GET_R_CBW_SUB20_1(x)                                    ((u32)(((x >> 8) & 0x000000FF)))
-#define BIT_MASK_R_CBW_SUB20_0                                      ((u32)0x000000FF << 0)          /*!<R/W 0   */
-#define BIT_R_CBW_SUB20_0(x)                                        ((u32)(((x) & 0x000000FF) << 0))
-#define BIT_GET_R_CBW_SUB20_0(x)                                    ((u32)(((x >> 0) & 0x000000FF)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_AX_PWR_TSSI_TABLE9
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_MASK_R_CBW_SUB20_7                                      ((u32)0x000000FF << 24)          /*!<R/W 0   */
-#define BIT_R_CBW_SUB20_7(x)                                        ((u32)(((x) & 0x000000FF) << 24))
-#define BIT_GET_R_CBW_SUB20_7(x)                                    ((u32)(((x >> 24) & 0x000000FF)))
-#define BIT_MASK_R_CBW_SUB20_6                                      ((u32)0x000000FF << 16)          /*!<R/W 0   */
-#define BIT_R_CBW_SUB20_6(x)                                        ((u32)(((x) & 0x000000FF) << 16))
-#define BIT_GET_R_CBW_SUB20_6(x)                                    ((u32)(((x >> 16) & 0x000000FF)))
-#define BIT_MASK_R_CBW_SUB20_5                                      ((u32)0x000000FF << 8)          /*!<R/W 0   */
-#define BIT_R_CBW_SUB20_5(x)                                        ((u32)(((x) & 0x000000FF) << 8))
-#define BIT_GET_R_CBW_SUB20_5(x)                                    ((u32)(((x >> 8) & 0x000000FF)))
-#define BIT_MASK_R_CBW_SUB20_4                                      ((u32)0x000000FF << 0)          /*!<R/W 0   */
-#define BIT_R_CBW_SUB20_4(x)                                        ((u32)(((x) & 0x000000FF) << 0))
-#define BIT_GET_R_CBW_SUB20_4(x)                                    ((u32)(((x >> 0) & 0x000000FF)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_AX_PWR_TSSI_TABLE10
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_MASK_R_CH_COMB_OFST_BANDEDGE_NONZERO_BW40               ((u32)0x000000FF << 24)          /*!<R/W 0   */
-#define BIT_R_CH_COMB_OFST_BANDEDGE_NONZERO_BW40(x)                 ((u32)(((x) & 0x000000FF) << 24))
-#define BIT_GET_R_CH_COMB_OFST_BANDEDGE_NONZERO_BW40(x)             ((u32)(((x >> 24) & 0x000000FF)))
-#define BIT_MASK_R_CH_COMB_OFST_BANDEDGE_NONZERO_BW20               ((u32)0x000000FF << 16)          /*!<R/W 0   */
-#define BIT_R_CH_COMB_OFST_BANDEDGE_NONZERO_BW20(x)                 ((u32)(((x) & 0x000000FF) << 16))
-#define BIT_GET_R_CH_COMB_OFST_BANDEDGE_NONZERO_BW20(x)             ((u32)(((x >> 16) & 0x000000FF)))
-#define BIT_MASK_R_CH_COMB_OFST_BANDEDGE_NONZERO_BW160              ((u32)0x000000FF << 8)          /*!<R/W 0   */
-#define BIT_R_CH_COMB_OFST_BANDEDGE_NONZERO_BW160(x)                ((u32)(((x) & 0x000000FF) << 8))
-#define BIT_GET_R_CH_COMB_OFST_BANDEDGE_NONZERO_BW160(x)            ((u32)(((x >> 8) & 0x000000FF)))
-#define BIT_MASK_R_CH_COMB_COMMON_DIFF_DB                           ((u32)0x000000FF << 0)          /*!<R/W 0   */
-#define BIT_R_CH_COMB_COMMON_DIFF_DB(x)                             ((u32)(((x) & 0x000000FF) << 0))
-#define BIT_GET_R_CH_COMB_COMMON_DIFF_DB(x)                         ((u32)(((x >> 0) & 0x000000FF)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_AX_PWR_TSSI_TABLE11
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_MASK_R_CH_COMB_OFST_BANDEDGE_ZERO_BW40                  ((u32)0x000000FF << 24)          /*!<R/W 0   */
-#define BIT_R_CH_COMB_OFST_BANDEDGE_ZERO_BW40(x)                    ((u32)(((x) & 0x000000FF) << 24))
-#define BIT_GET_R_CH_COMB_OFST_BANDEDGE_ZERO_BW40(x)                ((u32)(((x >> 24) & 0x000000FF)))
-#define BIT_MASK_R_CH_COMB_OFST_BANDEDGE_ZERO_BW20                  ((u32)0x000000FF << 16)          /*!<R/W 0   */
-#define BIT_R_CH_COMB_OFST_BANDEDGE_ZERO_BW20(x)                    ((u32)(((x) & 0x000000FF) << 16))
-#define BIT_GET_R_CH_COMB_OFST_BANDEDGE_ZERO_BW20(x)                ((u32)(((x >> 16) & 0x000000FF)))
-#define BIT_MASK_R_CH_COMB_OFST_BANDEDGE_ZERO_BW160                 ((u32)0x000000FF << 8)          /*!<R/W 0   */
-#define BIT_R_CH_COMB_OFST_BANDEDGE_ZERO_BW160(x)                   ((u32)(((x) & 0x000000FF) << 8))
-#define BIT_GET_R_CH_COMB_OFST_BANDEDGE_ZERO_BW160(x)               ((u32)(((x >> 8) & 0x000000FF)))
-#define BIT_MASK_R_CH_COMB_OFST_BANDEDGE_NONZERO_BW80               ((u32)0x000000FF << 0)          /*!<R/W 0   */
-#define BIT_R_CH_COMB_OFST_BANDEDGE_NONZERO_BW80(x)                 ((u32)(((x) & 0x000000FF) << 0))
-#define BIT_GET_R_CH_COMB_OFST_BANDEDGE_NONZERO_BW80(x)             ((u32)(((x >> 0) & 0x000000FF)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_AX_PWR_TSSI_TABLE12
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_MASK_R_F_PWR_OFST_OUT_SEG0_DB                           ((u32)0x000000FF << 24)          /*!<R/W 0   */
-#define BIT_R_F_PWR_OFST_OUT_SEG0_DB(x)                             ((u32)(((x) & 0x000000FF) << 24))
-#define BIT_GET_R_F_PWR_OFST_OUT_SEG0_DB(x)                         ((u32)(((x >> 24) & 0x000000FF)))
-#define BIT_MASK_R_F_CH20_WITH_DATA_NONLEGACY_VAL                   ((u32)0x000000FF << 16)          /*!<R/W 0   */
-#define BIT_R_F_CH20_WITH_DATA_NONLEGACY_VAL(x)                     ((u32)(((x) & 0x000000FF) << 16))
-#define BIT_GET_R_F_CH20_WITH_DATA_NONLEGACY_VAL(x)                 ((u32)(((x >> 16) & 0x000000FF)))
-#define BIT_MASK_R_F_CH20_WITH_DATA_LEGACY_VAL                      ((u32)0x000000FF << 8)          /*!<R/W 0   */
-#define BIT_R_F_CH20_WITH_DATA_LEGACY_VAL(x)                        ((u32)(((x) & 0x000000FF) << 8))
-#define BIT_GET_R_F_CH20_WITH_DATA_LEGACY_VAL(x)                    ((u32)(((x >> 8) & 0x000000FF)))
-#define BIT_MASK_R_CH_COMB_OFST_BANDEDGE_ZERO_BW80                  ((u32)0x000000FF << 0)          /*!<R/W 0   */
-#define BIT_R_CH_COMB_OFST_BANDEDGE_ZERO_BW80(x)                    ((u32)(((x) & 0x000000FF) << 0))
-#define BIT_GET_R_CH_COMB_OFST_BANDEDGE_ZERO_BW80(x)                ((u32)(((x >> 0) & 0x000000FF)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_AX_PWR_TSSI_TABLE13
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_MASK_R_HEMU_INIT_DIFF_SEG0_DB                           ((u32)0x000000FF << 24)          /*!<R/W 0   */
-#define BIT_R_HEMU_INIT_DIFF_SEG0_DB(x)                             ((u32)(((x) & 0x000000FF) << 24))
-#define BIT_GET_R_HEMU_INIT_DIFF_SEG0_DB(x)                         ((u32)(((x >> 24) & 0x000000FF)))
-#define BIT_MASK_R_HEER_INIT_OFST_SEG0_DB                           ((u32)0x000000FF << 16)          /*!<R/W 0   */
-#define BIT_R_HEER_INIT_OFST_SEG0_DB(x)                             ((u32)(((x) & 0x000000FF) << 16))
-#define BIT_GET_R_HEER_INIT_OFST_SEG0_DB(x)                         ((u32)(((x >> 16) & 0x000000FF)))
-#define BIT_MASK_R_HEER_INIT_DIFF_SEG0_DB                           ((u32)0x000000FF << 8)          /*!<R/W 0   */
-#define BIT_R_HEER_INIT_DIFF_SEG0_DB(x)                             ((u32)(((x) & 0x000000FF) << 8))
-#define BIT_GET_R_HEER_INIT_DIFF_SEG0_DB(x)                         ((u32)(((x >> 8) & 0x000000FF)))
-#define BIT_MASK_R_F_TSSI_DIFF_OUT_SEG0_DB                          ((u32)0x000000FF << 0)          /*!<R/W 0   */
-#define BIT_R_F_TSSI_DIFF_OUT_SEG0_DB(x)                            ((u32)(((x) & 0x000000FF) << 0))
-#define BIT_GET_R_F_TSSI_DIFF_OUT_SEG0_DB(x)                        ((u32)(((x >> 0) & 0x000000FF)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_AX_PWR_TSSI_TABLE14
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_MASK_R_HETB_INIT_DIFF_ATHESTF_SEG0_DB                   ((u32)0x000000FF << 24)          /*!<R/W 0   */
-#define BIT_R_HETB_INIT_DIFF_ATHESTF_SEG0_DB(x)                     ((u32)(((x) & 0x000000FF) << 24))
-#define BIT_GET_R_HETB_INIT_DIFF_ATHESTF_SEG0_DB(x)                 ((u32)(((x >> 24) & 0x000000FF)))
-#define BIT_MASK_R_HESU_INIT_OFST_SEG0_DB                           ((u32)0x000000FF << 16)          /*!<R/W 0   */
-#define BIT_R_HESU_INIT_OFST_SEG0_DB(x)                             ((u32)(((x) & 0x000000FF) << 16))
-#define BIT_GET_R_HESU_INIT_OFST_SEG0_DB(x)                         ((u32)(((x >> 16) & 0x000000FF)))
-#define BIT_MASK_R_HESU_INIT_DIFF_SEG0_DB                           ((u32)0x000000FF << 8)          /*!<R/W 0   */
-#define BIT_R_HESU_INIT_DIFF_SEG0_DB(x)                             ((u32)(((x) & 0x000000FF) << 8))
-#define BIT_GET_R_HESU_INIT_DIFF_SEG0_DB(x)                         ((u32)(((x >> 8) & 0x000000FF)))
-#define BIT_MASK_R_HEMU_INIT_OFST_SEG0_DB                           ((u32)0x000000FF << 0)          /*!<R/W 0   */
-#define BIT_R_HEMU_INIT_OFST_SEG0_DB(x)                             ((u32)(((x) & 0x000000FF) << 0))
-#define BIT_GET_R_HEMU_INIT_OFST_SEG0_DB(x)                         ((u32)(((x >> 0) & 0x000000FF)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_AX_PWR_TSSI_TABLE15
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_MASK_R_HT_INIT_DIFF_SEG0_DB                             ((u32)0x000000FF << 24)          /*!<R/W 0   */
-#define BIT_R_HT_INIT_DIFF_SEG0_DB(x)                               ((u32)(((x) & 0x000000FF) << 24))
-#define BIT_GET_R_HT_INIT_DIFF_SEG0_DB(x)                           ((u32)(((x >> 24) & 0x000000FF)))
-#define BIT_MASK_R_HETB_INIT_OFST_SEG0_DB                           ((u32)0x000000FF << 16)          /*!<R/W 0   */
-#define BIT_R_HETB_INIT_OFST_SEG0_DB(x)                             ((u32)(((x) & 0x000000FF) << 16))
-#define BIT_GET_R_HETB_INIT_OFST_SEG0_DB(x)                         ((u32)(((x >> 16) & 0x000000FF)))
-#define BIT_MASK_R_HETB_INIT_OFST_ATHESTF_SEG0_DB                   ((u32)0x000000FF << 8)          /*!<R/W 0   */
-#define BIT_R_HETB_INIT_OFST_ATHESTF_SEG0_DB(x)                     ((u32)(((x) & 0x000000FF) << 8))
-#define BIT_GET_R_HETB_INIT_OFST_ATHESTF_SEG0_DB(x)                 ((u32)(((x >> 8) & 0x000000FF)))
-#define BIT_MASK_R_HETB_INIT_DIFF_SEG0_DB                           ((u32)0x000000FF << 0)          /*!<R/W 0   */
-#define BIT_R_HETB_INIT_DIFF_SEG0_DB(x)                             ((u32)(((x) & 0x000000FF) << 0))
-#define BIT_GET_R_HETB_INIT_DIFF_SEG0_DB(x)                         ((u32)(((x >> 0) & 0x000000FF)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_AX_PWR_TSSI_TABLE16
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_MASK_R_VHT_INIT_DIFF_SEG0_DB                            ((u32)0x000000FF << 24)          /*!<R/W 0   */
-#define BIT_R_VHT_INIT_DIFF_SEG0_DB(x)                              ((u32)(((x) & 0x000000FF) << 24))
-#define BIT_GET_R_VHT_INIT_DIFF_SEG0_DB(x)                          ((u32)(((x >> 24) & 0x000000FF)))
-#define BIT_MASK_R_LEGACY_INIT_OFST_SEG0_DB                         ((u32)0x000000FF << 16)          /*!<R/W 0   */
-#define BIT_R_LEGACY_INIT_OFST_SEG0_DB(x)                           ((u32)(((x) & 0x000000FF) << 16))
-#define BIT_GET_R_LEGACY_INIT_OFST_SEG0_DB(x)                       ((u32)(((x >> 16) & 0x000000FF)))
-#define BIT_MASK_R_LEGACY_INIT_DIFF_SEG0_DB                         ((u32)0x000000FF << 8)          /*!<R/W 0   */
-#define BIT_R_LEGACY_INIT_DIFF_SEG0_DB(x)                           ((u32)(((x) & 0x000000FF) << 8))
-#define BIT_GET_R_LEGACY_INIT_DIFF_SEG0_DB(x)                       ((u32)(((x >> 8) & 0x000000FF)))
-#define BIT_MASK_R_HT_INIT_OFST_SEG0_DB                             ((u32)0x000000FF << 0)          /*!<R/W 0   */
-#define BIT_R_HT_INIT_OFST_SEG0_DB(x)                               ((u32)(((x) & 0x000000FF) << 0))
-#define BIT_GET_R_HT_INIT_OFST_SEG0_DB(x)                           ((u32)(((x >> 0) & 0x000000FF)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_AX_PWR_TSSI_TABLE17
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_MASK_R_BANDEDGE_CFG                                     ((u32)0x00000003 << 30)          /*!<R/W 0   */
-#define BIT_R_BANDEDGE_CFG(x)                                       ((u32)(((x) & 0x00000003) << 30))
-#define BIT_GET_R_BANDEDGE_CFG(x)                                   ((u32)(((x >> 30) & 0x00000003)))
-#define BIT_MASK_R_F_RATE_IDX                                       ((u32)0x0000000F << 26)          /*!<R/W 0   */
-#define BIT_R_F_RATE_IDX(x)                                         ((u32)(((x) & 0x0000000F) << 26))
-#define BIT_GET_R_F_RATE_IDX(x)                                     ((u32)(((x >> 26) & 0x0000000F)))
-#define BIT_MASK_R_F_FORMAT                                         ((u32)0x0000000F << 22)          /*!<R/W 0   */
-#define BIT_R_F_FORMAT(x)                                           ((u32)(((x) & 0x0000000F) << 22))
-#define BIT_GET_R_F_FORMAT(x)                                       ((u32)(((x >> 22) & 0x0000000F)))
-#define BIT_MASK_R_BANDEDGE_NONLEGACY_RATEIDX_TH                    ((u32)0x0000000F << 18)          /*!<R/W 0   */
-#define BIT_R_BANDEDGE_NONLEGACY_RATEIDX_TH(x)                      ((u32)(((x) & 0x0000000F) << 18))
-#define BIT_GET_R_BANDEDGE_NONLEGACY_RATEIDX_TH(x)                  ((u32)(((x >> 18) & 0x0000000F)))
-#define BIT_MASK_R_BANDEDGE_LEGACY_RATEIDX_TH                       ((u32)0x0000000F << 14)          /*!<R/W 0   */
-#define BIT_R_BANDEDGE_LEGACY_RATEIDX_TH(x)                         ((u32)(((x) & 0x0000000F) << 14))
-#define BIT_GET_R_BANDEDGE_LEGACY_RATEIDX_TH(x)                     ((u32)(((x >> 14) & 0x0000000F)))
-#define BIT_MASK_R_TSSI_CTRL_MAC_DBG_SEL                            ((u32)0x0000003F << 8)          /*!<R/W 0   */
-#define BIT_R_TSSI_CTRL_MAC_DBG_SEL(x)                              ((u32)(((x) & 0x0000003F) << 8))
-#define BIT_GET_R_TSSI_CTRL_MAC_DBG_SEL(x)                          ((u32)(((x >> 8) & 0x0000003F)))
-#define BIT_MASK_R_VHT_INIT_OFST_SEG0_DB                            ((u32)0x000000FF << 0)          /*!<R/W 0   */
-#define BIT_R_VHT_INIT_OFST_SEG0_DB(x)                              ((u32)(((x) & 0x000000FF) << 0))
-#define BIT_GET_R_VHT_INIT_OFST_SEG0_DB(x)                          ((u32)(((x >> 0) & 0x000000FF)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_AX_PWR_TSSI_TABLE18
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_R_F_HEER_BYPASS_CBW_FLTR_EN                             ((u32)0x00000001 << 31)          /*!<R/W 0   */
-#define BIT_R_F_HEER_BANDEDGE_IND_VAL                               ((u32)0x00000001 << 30)          /*!<R/W 0   */
-#define BIT_R_F_HEER_BANDEDGE_IND_EN                                ((u32)0x00000001 << 29)          /*!<R/W 0   */
-#define BIT_R_F_FORMAT_EN                                           ((u32)0x00000001 << 28)          /*!<R/W 0   */
-#define BIT_R_F_FAST_MODE_COMP_INIT_EN                              ((u32)0x00000001 << 27)          /*!<R/W 0   */
-#define BIT_R_F_DBW_EN                                              ((u32)0x00000001 << 26)          /*!<R/W 0   */
-#define BIT_R_F_CH20_WITH_DATA_EN                                   ((u32)0x00000001 << 25)          /*!<R/W 0   */
-#define BIT_R_F_CBW_EN                                              ((u32)0x00000001 << 24)          /*!<R/W 0   */
-#define BIT_R_F_BMODE_OFST_OUT_EN                                   ((u32)0x00000001 << 23)          /*!<R/W 0   */
-#define BIT_R_F_BMODE_DIFF_OUT_EN                                   ((u32)0x00000001 << 22)          /*!<R/W 0   */
-#define BIT_R_F_BMODE_BYPASS_DBW_FLTR_EN                            ((u32)0x00000001 << 21)          /*!<R/W 0   */
-#define BIT_R_F_BMODE_BYPASS_CBW_FLTR_EN                            ((u32)0x00000001 << 20)          /*!<R/W 0   */
-#define BIT_R_F_BMODE_BANDEDGE_IND_VAL                              ((u32)0x00000001 << 19)          /*!<R/W 0   */
-#define BIT_R_F_BMODE_BANDEDGE_IND_EN                               ((u32)0x00000001 << 18)          /*!<R/W 0   */
-#define BIT_R_F_BANDEDGE_CFG_SUSTBC_EN                              ((u32)0x00000001 << 17)          /*!<R/W 0   */
-#define BIT_R_F_BANDEDGE_CFG_SUDCM_EN                               ((u32)0x00000001 << 16)          /*!<R/W 0   */
-#define BIT_R_F_BANDEDGE_CFG_SUBF_EN                                ((u32)0x00000001 << 15)          /*!<R/W 0   */
-#define BIT_R_F_BANDEDGE_CFG_NDP_EN                                 ((u32)0x00000001 << 14)          /*!<R/W 0   */
-#define BIT_R_F_BANDEDGE_CFG_MU_EN                                  ((u32)0x00000001 << 13)          /*!<R/W 0   */
-#define BIT_R_F_BANDEDGE_CFG_HETB_EN                                ((u32)0x00000001 << 12)          /*!<R/W 0   */
-#define BIT_R_CH20_WITH_DATA_NONLEGACY_SWAP                         ((u32)0x00000001 << 11)          /*!<R/W 0   */
-#define BIT_R_CH20_WITH_DATA_LEGACY_SWAP                            ((u32)0x00000001 << 10)          /*!<R/W 0   */
-#define BIT_MASK_R_F_PRECODING_MODE_IDX                             ((u32)0x00000003 << 8)          /*!<R/W 0   */
-#define BIT_R_F_PRECODING_MODE_IDX(x)                               ((u32)(((x) & 0x00000003) << 8))
-#define BIT_GET_R_F_PRECODING_MODE_IDX(x)                           ((u32)(((x >> 8) & 0x00000003)))
-#define BIT_MASK_R_F_DBW                                            ((u32)0x00000003 << 6)          /*!<R/W 0   */
-#define BIT_R_F_DBW(x)                                              ((u32)(((x) & 0x00000003) << 6))
-#define BIT_GET_R_F_DBW(x)                                          ((u32)(((x >> 6) & 0x00000003)))
-#define BIT_MASK_R_F_CBW                                            ((u32)0x00000003 << 4)          /*!<R/W 0   */
-#define BIT_R_F_CBW(x)                                              ((u32)(((x) & 0x00000003) << 4))
-#define BIT_GET_R_F_CBW(x)                                          ((u32)(((x >> 4) & 0x00000003)))
-#define BIT_MASK_R_F_TXSC                                           ((u32)0x0000000F << 0)          /*!<R/W 0   */
-#define BIT_R_F_TXSC(x)                                             ((u32)(((x) & 0x0000000F) << 0))
-#define BIT_GET_R_F_TXSC(x)                                         ((u32)(((x >> 0) & 0x0000000F)))
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_AX_PWR_TSSI_TABLE19
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_R_F_IS_SU_STBC                                          ((u32)0x00000001 << 31)          /*!<R/W 0   */
-#define BIT_R_F_IS_SU_DCM_EN                                        ((u32)0x00000001 << 30)          /*!<R/W 0   */
-#define BIT_R_F_IS_SU_DCM                                           ((u32)0x00000001 << 29)          /*!<R/W 0   */
-#define BIT_R_F_IS_NDP_EN                                           ((u32)0x00000001 << 28)          /*!<R/W 0   */
-#define BIT_R_F_IS_NDP                                              ((u32)0x00000001 << 27)          /*!<R/W 0   */
-#define BIT_R_F_HT_OFST_OUT_EN                                      ((u32)0x00000001 << 26)          /*!<R/W 0   */
-#define BIT_R_F_HT_DIFF_OUT_EN                                      ((u32)0x00000001 << 25)          /*!<R/W 0   */
-#define BIT_R_F_HT_BYPASS_DBW_FLTR_EN                               ((u32)0x00000001 << 24)          /*!<R/W 0   */
-#define BIT_R_F_HT_BYPASS_CBW_FLTR_EN                               ((u32)0x00000001 << 23)          /*!<R/W 0   */
-#define BIT_R_F_HT_BANDEDGE_IND_VAL                                 ((u32)0x00000001 << 22)          /*!<R/W 0   */
-#define BIT_R_F_HT_BANDEDGE_IND_EN                                  ((u32)0x00000001 << 21)          /*!<R/W 0   */
-#define BIT_R_F_HETB_OFST_OUT_EN                                    ((u32)0x00000001 << 20)          /*!<R/W 0   */
-#define BIT_R_F_HETB_DIFF_OUT_EN                                    ((u32)0x00000001 << 19)          /*!<R/W 0   */
-#define BIT_R_F_HETB_BYPASS_DBW_FLTR_EN                             ((u32)0x00000001 << 18)          /*!<R/W 0   */
-#define BIT_R_F_HETB_BYPASS_CBW_FLTR_EN                             ((u32)0x00000001 << 17)          /*!<R/W 0   */
-#define BIT_R_F_HETB_BANDEDGE_IND_VAL                               ((u32)0x00000001 << 16)          /*!<R/W 0   */
-#define BIT_R_F_HETB_BANDEDGE_IND_EN                                ((u32)0x00000001 << 15)          /*!<R/W 0   */
-#define BIT_R_F_HESU_OFST_OUT_EN                                    ((u32)0x00000001 << 14)          /*!<R/W 0   */
-#define BIT_R_F_HESU_DIFF_OUT_EN                                    ((u32)0x00000001 << 13)          /*!<R/W 0   */
-#define BIT_R_F_HESU_BYPASS_DBW_FLTR_EN                             ((u32)0x00000001 << 12)          /*!<R/W 0   */
-#define BIT_R_F_HESU_BYPASS_CBW_FLTR_EN                             ((u32)0x00000001 << 11)          /*!<R/W 0   */
-#define BIT_R_F_HESU_BANDEDGE_IND_VAL                               ((u32)0x00000001 << 10)          /*!<R/W 0   */
-#define BIT_R_F_HESU_BANDEDGE_IND_EN                                ((u32)0x00000001 << 9)          /*!<R/W 0   */
-#define BIT_R_F_HEMU_OFST_OUT_EN                                    ((u32)0x00000001 << 8)          /*!<R/W 0   */
-#define BIT_R_F_HEMU_DIFF_OUT_EN                                    ((u32)0x00000001 << 7)          /*!<R/W 0   */
-#define BIT_R_F_HEMU_BYPASS_DBW_FLTR_EN                             ((u32)0x00000001 << 6)          /*!<R/W 0   */
-#define BIT_R_F_HEMU_BYPASS_CBW_FLTR_EN                             ((u32)0x00000001 << 5)          /*!<R/W 0   */
-#define BIT_R_F_HEMU_BANDEDGE_IND_VAL                               ((u32)0x00000001 << 4)          /*!<R/W 0   */
-#define BIT_R_F_HEMU_BANDEDGE_IND_EN                                ((u32)0x00000001 << 3)          /*!<R/W 0   */
-#define BIT_R_F_HEER_OFST_OUT_EN                                    ((u32)0x00000001 << 2)          /*!<R/W 0   */
-#define BIT_R_F_HEER_DIFF_OUT_EN                                    ((u32)0x00000001 << 1)          /*!<R/W 0   */
-#define BIT_R_F_HEER_BYPASS_DBW_FLTR_EN                             ((u32)0x00000001 << 0)          /*!<R/W 0   */
-/** @} */
-
-/**************************************************************************//**
- * @defgroup REG_AX_PWR_TSSI_TABLE20
- * @brief
- * @{
- *****************************************************************************/
-#define BIT_R_TSSI_CTRL_MAC_USE_NORMAL_RATE_IDX_ONLY                ((u32)0x00000001 << 22)          /*!<R/W 0   */
-#define BIT_R_TSSI_CTRL_MAC_DBG_DIS                                 ((u32)0x00000001 << 21)          /*!<R/W 0   */
-#define BIT_R_TSSI_CTRL_MAC_CLR                                     ((u32)0x00000001 << 20)          /*!<R/W 0   */
-#define BIT_R_HETB_PWR_MSR_MODE                                     ((u32)0x00000001 << 19)          /*!<R/W 0   */
-#define BIT_R_F_VHT_OFST_OUT_EN                                     ((u32)0x00000001 << 18)          /*!<R/W 0   */
-#define BIT_R_F_VHT_DIFF_OUT_EN                                     ((u32)0x00000001 << 17)          /*!<R/W 0   */
-#define BIT_R_F_VHT_BYPASS_DBW_FLTR_EN                              ((u32)0x00000001 << 16)          /*!<R/W 0   */
-#define BIT_R_F_VHT_BYPASS_CBW_FLTR_EN                              ((u32)0x00000001 << 15)          /*!<R/W 0   */
-#define BIT_R_F_VHT_BANDEDGE_IND_VAL                                ((u32)0x00000001 << 14)          /*!<R/W 0   */
-#define BIT_R_F_VHT_BANDEDGE_IND_EN                                 ((u32)0x00000001 << 13)          /*!<R/W 0   */
-#define BIT_R_F_TXSC_EN                                             ((u32)0x00000001 << 12)          /*!<R/W 0   */
-#define BIT_R_F_TSSI_CTRL_OUT_EN                                    ((u32)0x00000001 << 11)          /*!<R/W 0   */
-#define BIT_R_F_TSSI_CTRL_FAST_MODE_IDX_EN                          ((u32)0x00000001 << 10)          /*!<R/W 0   */
-#define BIT_R_F_TSSI_CTRL_FAST_MODE_IDX                             ((u32)0x00000001 << 9)          /*!<R/W 0   */
-#define BIT_R_F_RATE_IDX_EN                                         ((u32)0x00000001 << 8)          /*!<R/W 0   */
-#define BIT_R_F_PRECODING_MODE_IDX_EN                               ((u32)0x00000001 << 7)          /*!<R/W 0   */
-#define BIT_R_F_LEGACY_OFST_OUT_EN                                  ((u32)0x00000001 << 6)          /*!<R/W 0   */
-#define BIT_R_F_LEGACY_DIFF_OUT_EN                                  ((u32)0x00000001 << 5)          /*!<R/W 0   */
-#define BIT_R_F_LEGACY_BYPASS_DBW_FLTR_EN                           ((u32)0x00000001 << 4)          /*!<R/W 0   */
-#define BIT_R_F_LEGACY_BYPASS_CBW_FLTR_EN                           ((u32)0x00000001 << 3)          /*!<R/W 0   */
-#define BIT_R_F_LEGACY_BANDEDGE_IND_VAL                             ((u32)0x00000001 << 2)          /*!<R/W 0   */
-#define BIT_R_F_LEGACY_BANDEDGE_IND_EN                              ((u32)0x00000001 << 1)          /*!<R/W 0   */
-#define BIT_R_F_IS_SU_STBC_EN                                       ((u32)0x00000001 << 0)          /*!<R/W 0   */
-/** @} */
-
-
-/*==========TXPWR Register Address Definition==========*/
-#define REG_AX_PWR_RATE_CTRL                         0xD200
-#define REG_AX_PWR_RATE_OFST_CTRL                    0xD204
-#define REG_AX_PWR_LMT_CTRL                          0xD208
-#define REG_AX_PWR_MACID_CTRL                        0xD20C
-#define REG_AX_PWR_BF_CTRL                           0xD210
-#define REG_AX_PWR_MACID_REG                         0xD214
-#define REG_AX_PWR_MACID_REG2                        0xD218
-#define REG_AX_PWR_RU_LMT_CTRL                       0xD21C
-#define REG_AX_PWR_COEXT_CTRL                        0xD220
-#define REG_AX_PWR_SWING_LEG_CTRL                    0xD224
-#define REG_AX_PWR_SWING_VHT_CTRL                    0xD228
-#define REG_AX_PWR_SWING_HE_CTRL                     0xD22C
-#define REG_AX_PWR_SWING_OTHER_CTRL0                 0xD230
-#define REG_AX_PWR_SWING_OTHER_CTRL1                 0xD234
-#define REG_AX_PWR_SR_CTRL0                          0xD238
-#define REG_AX_PWR_SR_CTRL1                          0xD23C
-#define REG_AX_PWR_UL_CTRL0                          0xD240
-#define REG_AX_PWR_UL_CTRL1                          0xD244
-#define REG_AX_PWR_UL_CTRL2                          0xD248
-#define REG_AX_PWR_UL_CTRL3                          0xD24C
-#define REG_AX_PWR_UL_CTRL4                          0xD250
-#define REG_AX_PWR_UL_CTRL5                          0xD254
-#define REG_AX_PWR_UL_CTRL6                          0xD258
-#define REG_AX_PWR_NORM_FORCE0                       0xD25C
-#define REG_AX_PWR_NORM_FORCE1                       0xD260
-#define REG_AX_PWR_SR_FORCE0                         0xD264
-#define REG_AX_PWR_SR_FORCE1                         0xD268
-#define REG_AX_PWR_SR_FORCE2                         0xD26C
-#define REG_AX_PWR_UL_FORCE0                         0xD270
-#define REG_AX_PWR_NORM_FORCE2                       0xD274
-#define REG_AX_PWR_UL_FORCE1                         0xD278
-#define REG_AX_PWR_NORM_FORCE3                       0xD27C
-#define REG_AX_PWR_NORM_FORCE4                       0xD280
-#define REG_AX_PWR_BY_RATE_TABLE0                    0xD2C0
-#define REG_AX_PWR_BY_RATE_TABLE1                    0xD2C4
-#define REG_AX_PWR_BY_RATE_TABLE2                    0xD2C8
-#define REG_AX_PWR_BY_RATE_TABLE3                    0xD2CC
-#define REG_AX_PWR_BY_RATE_TABLE4                    0xD2D0
-#define REG_AX_PWR_BY_RATE_TABLE5                    0xD2D4
-#define REG_AX_PWR_BY_RATE_TABLE6                    0xD2D8
-#define REG_AX_PWR_LMT_TABLE0                        0xD2EC
-#define REG_AX_PWR_LMT_TABLE1                        0xD2F0
-#define REG_AX_PWR_RU_LMT_TABLE0                     0xD33C
-#define REG_AX_PWR_RU_LMT_TABLE1                     0xD340
-#define REG_AX_PWR_RU_LMT_TABLE2                     0xD344
-#define REG_AX_PWR_RU_LMT_TABLE3                     0xD348
-#define REG_AX_PWR_RU_LMT_TABLE4                     0xD34C
-#define REG_AX_PWR_RU_LMT_TABLE5                     0xD350
-#define REG_AX_PWR_MACID_LMT_TABLE0                  0xD36C
-#define REG_AX_PWR_MACID_LMT_TABLE1                  0xD370
-#define REG_AX_PWR_MACID_LMT_TABLE2                  0xD374
-#define REG_AX_PWR_MACID_LMT_TABLE3                  0xD378
-#define REG_AX_PWR_MACID_LMT_TABLE4                  0xD37C
-#define REG_AX_PWR_MACID_LMT_TABLE5                  0xD380
-#define REG_AX_PWR_MACID_LMT_TABLE6                  0xD384
-#define REG_AX_PWR_MACID_LMT_TABLE7                  0xD388
-#define REG_AX_PWR_MACID_LMT_TABLE8                  0xD38C
-#define REG_AX_PWR_MACID_LMT_TABLE9                  0xD390
-#define REG_AX_PWR_MACID_LMT_TABLE10                 0xD394
-#define REG_AX_PWR_MACID_LMT_TABLE11                 0xD398
-#define REG_AX_PWR_MACID_LMT_TABLE12                 0xD39C
-#define REG_AX_PWR_MACID_LMT_TABLE13                 0xD3A0
-#define REG_AX_PWR_MACID_LMT_TABLE14                 0xD3A4
-#define REG_AX_PWR_MACID_LMT_TABLE15                 0xD3A8
-#define REG_AX_PWR_SR_MCS0_TXDIFF_TABLE0             0xD56C
-#define REG_AX_PWR_SR_MCS0_TXDIFF_TABLE1             0xD570
-#define REG_AX_PWR_SR_MCS0_TXDIFF_TABLE2             0xD574
-#define REG_AX_PWR_SR_MCS0_TXDIFF_TABLE3             0xD578
-#define REG_AX_PWR_SR_MCS1_TXDIFF_TABLE0             0xD57C
-#define REG_AX_PWR_SR_MCS1_TXDIFF_TABLE1             0xD580
-#define REG_AX_PWR_SR_MCS1_TXDIFF_TABLE2             0xD584
-#define REG_AX_PWR_SR_MCS1_TXDIFF_TABLE3             0xD588
-#define REG_AX_PWR_SR_MCS2_TXDIFF_TABLE0             0xD58C
-#define REG_AX_PWR_SR_MCS2_TXDIFF_TABLE1             0xD590
-#define REG_AX_PWR_SR_MCS2_TXDIFF_TABLE2             0xD594
-#define REG_AX_PWR_SR_MCS2_TXDIFF_TABLE3             0xD598
-#define REG_AX_PWR_SR_MCS3_TXDIFF_TABLE0             0xD59C
-#define REG_AX_PWR_SR_MCS3_TXDIFF_TABLE1             0xD5A0
-#define REG_AX_PWR_SR_MCS3_TXDIFF_TABLE2             0xD5A4
-#define REG_AX_PWR_SR_MCS3_TXDIFF_TABLE3             0xD5A8
-#define REG_AX_PWR_SR_MCS4_TXDIFF_TABLE0             0xD5AC
-#define REG_AX_PWR_SR_MCS4_TXDIFF_TABLE1             0xD5B0
-#define REG_AX_PWR_SR_MCS4_TXDIFF_TABLE2             0xD5B4
-#define REG_AX_PWR_SR_MCS4_TXDIFF_TABLE3             0xD5B8
-#define REG_AX_PWR_SR_MCS5_TXDIFF_TABLE0             0xD5BC
-#define REG_AX_PWR_SR_MCS5_TXDIFF_TABLE1             0xD5C0
-#define REG_AX_PWR_SR_MCS5_TXDIFF_TABLE2             0xD5C4
-#define REG_AX_PWR_SR_MCS5_TXDIFF_TABLE3             0xD5C8
-#define REG_AX_PWR_SR_MCS6_TXDIFF_TABLE0             0xD5CC
-#define REG_AX_PWR_SR_MCS6_TXDIFF_TABLE1             0xD5D0
-#define REG_AX_PWR_SR_MCS6_TXDIFF_TABLE2             0xD5D4
-#define REG_AX_PWR_SR_MCS6_TXDIFF_TABLE3             0xD5D8
-#define REG_AX_PWR_SR_MCS7_TXDIFF_TABLE0             0xD5DC
-#define REG_AX_PWR_SR_MCS7_TXDIFF_TABLE1             0xD5E0
-#define REG_AX_PWR_SR_MCS7_TXDIFF_TABLE2             0xD5E4
-#define REG_AX_PWR_SR_MCS7_TXDIFF_TABLE3             0xD5E8
-#define REG_AX_PWR_SR_MCS8_TXDIFF_TABLE0             0xD5EC
-#define REG_AX_PWR_SR_MCS8_TXDIFF_TABLE1             0xD5F0
-#define REG_AX_PWR_SR_MCS8_TXDIFF_TABLE2             0xD5F4
-#define REG_AX_PWR_SR_MCS8_TXDIFF_TABLE3             0xD5F8
-#define REG_AX_PWR_SR_MCS9_TXDIFF_TABLE0             0xD5FC
-#define REG_AX_PWR_SR_MCS9_TXDIFF_TABLE1             0xD600
-#define REG_AX_PWR_SR_MCS9_TXDIFF_TABLE2             0xD604
-#define REG_AX_PWR_SR_MCS9_TXDIFF_TABLE3             0xD608
-#define REG_AX_PWR_SR_MCS10_TXDIFF_TABLE0            0xD60C
-#define REG_AX_PWR_SR_MCS10_TXDIFF_TABLE1            0xD610
-#define REG_AX_PWR_SR_MCS10_TXDIFF_TABLE2            0xD614
-#define REG_AX_PWR_SR_MCS10_TXDIFF_TABLE3            0xD618
-#define REG_AX_PWR_SR_MCS11_TXDIFF_TABLE0            0xD61C
-#define REG_AX_PWR_SR_MCS11_TXDIFF_TABLE1            0xD620
-#define REG_AX_PWR_SR_MCS11_TXDIFF_TABLE2            0xD624
-#define REG_AX_PWR_SR_MCS11_TXDIFF_TABLE3            0xD628
-#define REG_AX_PWR_CCK1M_TXDIFF_TABLE0               0xD62C
-#define REG_AX_PWR_CCK1M_TXDIFF_TABLE1               0xD630
-#define REG_AX_PWR_CCK1M_TXDIFF_TABLE2               0xD634
-#define REG_AX_PWR_CCK1M_TXDIFF_TABLE3               0xD638
-#define REG_AX_PWR_CCK2M_TXDIFF_TABLE0               0xD63C
-#define REG_AX_PWR_CCK2M_TXDIFF_TABLE1               0xD640
-#define REG_AX_PWR_CCK2M_TXDIFF_TABLE2               0xD644
-#define REG_AX_PWR_CCK2M_TXDIFF_TABLE3               0xD648
-#define REG_AX_PWR_CCK5P5M_TXDIFF_TABLE0             0xD64C
-#define REG_AX_PWR_CCK5P5M_TXDIFF_TABLE1             0xD650
-#define REG_AX_PWR_CCK5P5M_TXDIFF_TABLE2             0xD654
-#define REG_AX_PWR_CCK5P5M_TXDIFF_TABLE3             0xD658
-#define REG_AX_PWR_CCK11M_TXDIFF_TABLE0              0xD65C
-#define REG_AX_PWR_CCK11M_TXDIFF_TABLE1              0xD660
-#define REG_AX_PWR_CCK11M_TXDIFF_TABLE2              0xD664
-#define REG_AX_PWR_CCK11M_TXDIFF_TABLE3              0xD668
-#define REG_AX_PWR_LEGACY6M_TXDIFF_TABLE0            0xD66C
-#define REG_AX_PWR_LEGACY6M_TXDIFF_TABLE1            0xD670
-#define REG_AX_PWR_LEGACY6M_TXDIFF_TABLE2            0xD674
-#define REG_AX_PWR_LEGACY6M_TXDIFF_TABLE3            0xD678
-#define REG_AX_PWR_LEGACY9M_TXDIFF_TABLE0            0xD67C
-#define REG_AX_PWR_LEGACY9M_TXDIFF_TABLE1            0xD680
-#define REG_AX_PWR_LEGACY9M_TXDIFF_TABLE2            0xD684
-#define REG_AX_PWR_LEGACY9M_TXDIFF_TABLE3            0xD688
-#define REG_AX_PWR_LEGACY12M_TXDIFF_TABLE0           0xD68C
-#define REG_AX_PWR_LEGACY12M_TXDIFF_TABLE1           0xD690
-#define REG_AX_PWR_LEGACY12M_TXDIFF_TABLE2           0xD694
-#define REG_AX_PWR_LEGACY12M_TXDIFF_TABLE3           0xD698
-#define REG_AX_PWR_LEGACY18M_TXDIFF_TABLE0           0xD69C
-#define REG_AX_PWR_LEGACY18M_TXDIFF_TABLE1           0xD6A0
-#define REG_AX_PWR_LEGACY18M_TXDIFF_TABLE2           0xD6A4
-#define REG_AX_PWR_LEGACY18M_TXDIFF_TABLE3           0xD6A8
-#define REG_AX_PWR_LEGACY24M_TXDIFF_TABLE0           0xD6AC
-#define REG_AX_PWR_LEGACY24M_TXDIFF_TABLE1           0xD6B0
-#define REG_AX_PWR_LEGACY24M_TXDIFF_TABLE2           0xD6B4
-#define REG_AX_PWR_LEGACY24M_TXDIFF_TABLE3           0xD6B8
-#define REG_AX_PWR_LEGACY36M_TXDIFF_TABLE0           0xD6BC
-#define REG_AX_PWR_LEGACY36M_TXDIFF_TABLE1           0xD6C0
-#define REG_AX_PWR_LEGACY36M_TXDIFF_TABLE2           0xD6C4
-#define REG_AX_PWR_LEGACY36M_TXDIFF_TABLE3           0xD6C8
-#define REG_AX_PWR_LEGACY48M_TXDIFF_TABLE0           0xD6CC
-#define REG_AX_PWR_LEGACY48M_TXDIFF_TABLE1           0xD6D0
-#define REG_AX_PWR_LEGACY48M_TXDIFF_TABLE2           0xD6D4
-#define REG_AX_PWR_LEGACY48M_TXDIFF_TABLE3           0xD6D8
-#define REG_AX_PWR_LEGACY54M_TXDIFF_TABLE0           0xD6DC
-#define REG_AX_PWR_LEGACY54M_TXDIFF_TABLE1           0xD6E0
-#define REG_AX_PWR_LEGACY54M_TXDIFF_TABLE2           0xD6E4
-#define REG_AX_PWR_LEGACY54M_TXDIFF_TABLE3           0xD6E8
-#define REG_AX_PWR_TCM_WRAPPER_CR0                   0xD800
-#define REG_AX_PWR_TCM_WRAPPER_CR1                   0xD804
-#define REG_AX_PWR_TCM_WRAPPER_CR2                   0xD808
-#define REG_AX_PWR_TCM_WRAPPER_CR3                   0xD80C
-#define REG_AX_PWR_TCM_WRAPPER_CR4                   0xD810
-#define REG_AX_PWR_TCM_WRAPPER_CR5                   0xD814
-#define REG_AX_PWR_TCM_WRAPPER_CR6                   0xD818
-#define REG_AX_PWR_TCM_WRAPPER_CR7                   0xD81C
-#define REG_AX_PWR_TCM_WRAPPER_CR8                   0xD820
-#define REG_AX_PWR_TCM_WRAPPER_CR9                   0xD824
-#define REG_AX_PWR_TCM_WRAPPER_CR10                  0xD828
-#define REG_AX_PWR_TCM_WRAPPER_CR11                  0xD82C
-#define REG_AX_PWR_TCM_WRAPPER_CR12                  0xD830
-#define REG_AX_PWR_TCM_WRAPPER_CR13                  0xD834
-#define REG_AX_PWR_TCM_WRAPPER_CR14                  0xD838
-#define REG_AX_PWR_TCM_WRAPPER_CR15                  0xD83C
-#define REG_AX_PWR_TCM_WRAPPER_CR16                  0xD840
-#define REG_AX_PWR_TCM_WRAPPER_CR17                  0xD844
-#define REG_AX_PWR_TCM_WRAPPER_CR18                  0xD848
-//#define REG_DUMMY                                    0xD900
-#define REG_AX_PWR_TSSI_TABLE0                       0xD908
-#define REG_AX_PWR_TSSI_TABLE1                       0xD90C
-#define REG_AX_PWR_TSSI_TABLE2                       0xD910
-#define REG_AX_PWR_TSSI_TABLE3                       0xD914
-#define REG_AX_PWR_TSSI_TABLE4                       0xD918
-#define REG_AX_PWR_TSSI_TABLE5                       0xD91C
-#define REG_AX_PWR_TSSI_TABLE6                       0xD920
-#define REG_AX_PWR_TSSI_TABLE7                       0xD924
-#define REG_AX_PWR_TSSI_TABLE8                       0xD928
-#define REG_AX_PWR_TSSI_TABLE9                       0xD92C
-#define REG_AX_PWR_TSSI_TABLE10                      0xD930
-#define REG_AX_PWR_TSSI_TABLE11                      0xD934
-#define REG_AX_PWR_TSSI_TABLE12                      0xD938
-#define REG_AX_PWR_TSSI_TABLE13                      0xD93C
-#define REG_AX_PWR_TSSI_TABLE14                      0xD940
-#define REG_AX_PWR_TSSI_TABLE15                      0xD944
-#define REG_AX_PWR_TSSI_TABLE16                      0xD948
-#define REG_AX_PWR_TSSI_TABLE17                      0xD94C
-#define REG_AX_PWR_TSSI_TABLE18                      0xD950
-#define REG_AX_PWR_TSSI_TABLE19                      0xD954
-#define REG_AX_PWR_TSSI_TABLE20                      0xD958
-#define REG_USR_LIST_SRAM                            0xDB00
-
-/* AUTO_GEN_END */
-
-/* MANUAL_GEN_START */
-
-//Please add your defination here
-
-/* MANUAL_GEN_END */
-
-#endif
diff --git a/os/board/rtl8720e/src/component/wifi/wifi_fw/amebalite/include/wififw_rtlchip.h b/os/board/rtl8720e/src/component/wifi/wifi_fw/amebalite/include/wififw_rtlchip.h
deleted file mode 100644
index ebd234121..000000000
--- a/os/board/rtl8720e/src/component/wifi/wifi_fw/amebalite/include/wififw_rtlchip.h
+++ /dev/null
@@ -1,80 +0,0 @@
-#ifndef _RTLCHIP_H_
-#define _RTLCHIP_H_
-/*
-*****************************************
-
-        Chip Selection
-
-Field    FOUNDRY     RTLCHIP               CHIPCUT
-BITS   [17:16]         [15:4]                 [3:0]
-
-
-*****************************************
-*/
-//#define RTL8721D_CHIP               0x21D0
-#define RTL8720E_CHIP               0x30A0
-#define RTLCHIP_MASK                0xFFF0
-
-/* Cut */
-#define CHIPCUT_TEST                0x0
-#define CHIPCUT_A                   0x1
-#define CHIPCUT_B                   0x2
-#define CHIPCUT_C                   0x3
-#define CHIPCUT_D                   0x4
-#define CHIPCUT_E                   0x5
-
-#define CHIPCUT_MASK                0xF
-
-/* Chip + Cut (Signature) */
-#define CHIP_SIGNATURE_MASK         0xFFFF
-
-/* Foundry */
-#define CHIP_FOUNDRY_SHIFT          16
-#define CHIP_FOUNDRY_MASK           (0x3<<CHIP_FOUNDRY_SHIFT)
-
-#define CHIP_FOUNDRY_TSMC           (0x0<<CHIP_FOUNDRY_SHIFT)
-#define CHIP_FOUNDRY_UMC            (0x1<<CHIP_FOUNDRY_SHIFT)
-#define CHIP_FOUNDRY_SMIC           (0x2<<CHIP_FOUNDRY_SHIFT)
-
-/* Macro for Chip */
-#define IS_CHIP_8720E(CurSel)       ( ((CurSel) & RTLCHIP_MASK) == RTL8720E_CHIP )
-
-#define IS_CHIP_RF_N(CurSel)        (( ((CurSel) & RTLCHIP_MASK) == RTL8188E_CHIP ) \
-                                    || ( ((CurSel) & RTLCHIP_MASK) == RTLWISOC_CHIP ) \
-                                    || ( ((CurSel) & RTLCHIP_MASK) == RTL8192E_CHIP ) \
-                                    || ( ((CurSel) & RTLCHIP_MASK) == RTL8723B_CHIP ) \
-                                    || ( ((CurSel) & RTLCHIP_MASK) == RTL8703B_CHIP ) \
-                                    || ( ((CurSel) & RTLCHIP_MASK) == RTL8188F_CHIP )\
-                                    || ( ((CurSel) & RTLCHIP_MASK) == RTL8710B_CHIP )\
-                                    || ( ((CurSel) & RTLCHIP_MASK) == RTL8192F_CHIP )\
-                                    || ( ((CurSel) & RTLCHIP_MASK) == RTL8721D_CHIP )\
-                                    || ( ((CurSel) & RTLCHIP_MASK) == RTL8720E_CHIP )\
-                                    || ( ((CurSel) & RTLCHIP_MASK) == RTL8723D_CHIP ))
-
-#define IS_CHIP_RF_AC(CurSel)       (( ((CurSel) & RTLCHIP_MASK) == RTL8195_CHIP )\
-                                    || ( ((CurSel) & RTLCHIP_MASK) == RTL8821_CHIP ) \
-                                    || ( ((CurSel) & RTLCHIP_MASK) == RTL8881_CHIP ) )
-
-#define GET_CHIP_ID(CurSel)         ( (CurSel) & RTLCHIP_MASK )
-
-/* Macro for Cut */
-#define IS_CUT_TEST(CurSel)         ( ((CurSel) & CHIPCUT_MASK) == CHIPCUT_TEST )
-#define IS_CUT_A(CurSel)            ( ((CurSel) & CHIPCUT_MASK) == CHIPCUT_A )
-#define IS_CUT_B(CurSel)            ( ((CurSel) & CHIPCUT_MASK) == CHIPCUT_B )
-#define IS_CUT_C(CurSel)            ( ((CurSel) & CHIPCUT_MASK) == CHIPCUT_C )
-#define IS_CUT_D(CurSel)            ( ((CurSel) & CHIPCUT_MASK) == CHIPCUT_D )
-#define GET_CUT(CurSel)             ((CurSel) & CHIPCUT_MASK)
-
-/* Macro for Chip + Cut */
-#define GET_SIGNATURE(CurSel)       ((CurSel) & CHIP_SIGNATURE_MASK)
-
-/* Macro for Foundry */
-#define GET_FOUNDRY(CurSel)         ((CurSel) & CHIP_FOUNDRY_MASK)
-
-/* 3 Final Combination (Chip Select) */
-/* RTL8720E */
-#define RTL8720E_TEST_CHIP_S             (RTL8720E_CHIP  | CHIPCUT_TEST | CHIP_FOUNDRY_SMIC)
-#define RTL8720E_A_CUT_S                 (RTL8720E_CHIP  | CHIPCUT_A    | CHIP_FOUNDRY_SMIC)
-#define RTL8720E_B_CUT_S                 (RTL8720E_CHIP  | CHIPCUT_B    | CHIP_FOUNDRY_SMIC)
-
-#endif  /* #ifndef _RTLCHIP_H_ */
diff --git a/os/board/rtl8720e/src/component/wifi/wifi_fw/amebalite/include/wififw_serial_io.h b/os/board/rtl8720e/src/component/wifi/wifi_fw/amebalite/include/wififw_serial_io.h
deleted file mode 100644
index f4c9b60a0..000000000
--- a/os/board/rtl8720e/src/component/wifi/wifi_fw/amebalite/include/wififw_serial_io.h
+++ /dev/null
@@ -1,60 +0,0 @@
-#ifndef __WIFIFW_SERIAL_IO_H__
-#define __WIFIFW_SERIAL_IO_H__
-
-#define TXBUF_SIZE  256      /* DO NOT CHANGE */
-#define RXBUF_SIZE  15      /* DO NOT CHANGE */
-
-#define MAX_ARGV				16
-#define UART_LOG_HISTORY_ENTRY  8
-
-#define KB_ASCII_NUL    0x00
-#define KB_ASCII_BS     0x08
-#define KB_ASCII_TAB    0x09
-#define KB_ASCII_LF     0x0A
-#define KB_ASCII_CR     0x0D
-#define KB_ASCII_ESC    0x1B
-#define KB_ASCII_SP     0x20
-#define KB_ASCII_BS_7F  0x7F
-#define KB_ASCII_LBRKT  0x5B         //[
-
-#define KB_SPACENO_TAB  1
-
-#define CONSOLE_8720E()   DBG_8195A("RTL8720E>")
-
-typedef struct {
-	u8  BufCount;                           //record the input cmd char number.
-	u8  UARTLogBuf[UART_LOG_CMD_BUFLEN];   //record the input command.
-} FW_UART_LOG_BUF, *PFW_UART_LOG_BUF;
-
-typedef struct {
-	u8 historyNum;
-	u8 wrPtr;
-	u8 rdPtr;
-	u8 historyBuf[UART_LOG_HISTORY_ENTRY][UART_LOG_CMD_BUFLEN + 1];
-} FW_HISTORY_BUF, *PFW_HISTORY_BUF;
-
-typedef struct _FW_COMMAND_TABLE_ {
-	const    u8 *cmd;
-	u8       ArgvCnt;
-	void (*func)(u16 argc, const char *argv[]);
-	const    u8 *msg;
-} FW_COMMAND_TABLE, *PFW_COMMAND_TABLE;
-
-typedef struct {
-	u8  NewIdx;
-	u8  SeeIdx;
-	u8  RevdNo;
-	u8  EscSTS;
-	u8  ExecuteCmd;
-	u8  ExecuteEsc;
-	u8  Resvd;
-	PFW_UART_LOG_BUF   pTmpLogBuf;
-	PFW_HISTORY_BUF    pTmpHistoryBuf;
-	PFW_COMMAND_TABLE  pCmdTbl;
-	u32 CmdTblSz;
-} FW_UART_LOG_CTL, *PFW_UART_LOG_CTL;
-
-extern int _strcmp(const char *cs, const char *ct);
-extern VOID FwRtlConsolInit(u16 TBLSz, VOID *pTBL);
-
-#endif /* __WIFIFW_SERIAL_IO_H__ */
diff --git a/os/board/rtl8720e/src/component/wifi/wifi_fw/amebalite/include/wififw_sysmib_ram.h b/os/board/rtl8720e/src/component/wifi/wifi_fw/amebalite/include/wififw_sysmib_ram.h
deleted file mode 100644
index 3f479b48a..000000000
--- a/os/board/rtl8720e/src/component/wifi/wifi_fw/amebalite/include/wififw_sysmib_ram.h
+++ /dev/null
@@ -1,193 +0,0 @@
-#ifndef __WIFIFW_SYSMIB_H__
-#define __WIFIFW_SYSMIB_H__
-
-
-/*--------------------Define --------------------------------------------*/
-
-/*--------------------Define Enum---------------------------------------*/
-
-/*--------------------Define MACRO--------------------------------------*/
-
-/*--------------------Define Struct---------------------------------------*/
-
-//3 1.) Xdata Section
-typedef struct _mib_info_ {
-	void (*intdis)(void);
-	void (*inten)(void);
-
-	/* 3 Task Bitmap */
-	u32                     TaskBitMap;
-	u8                      TaskBitMap1;
-	u8                      Debug[2];
-
-	u8                      TxPauseReasonCode;
-	u8                      RxPauseReasonCode;	  //3
-	u16 					 RXFF0_BNDY;
-
-	/* 3 HAL */
-	HAL_DATA_8720E          IntHdl;
-
-	/* 3 Wlan */
-	/* Packet Location */
-	RsvdPageLoc             RPL;
-	H2C_EVT                 H2CEvt;
-	C2H_FW_EVT             C2HFWEvt;
-	u8                      H2C_rptr;
-
-	/* Media Status */
-	MEDIA_STATUS            MediaStatus;
-#if CONFIG_RATE_ADAPTIVE
-	struct _PPHYDM 	PPHYDM;
-#endif
-
-	PS_PARM                 PSParm;
-	PS_TUNING_PPARM         PSTParm;
-#if CONFIG_BCNEARLY_ADJUST_V2
-	BCNEARLY_ADJUST_PID   	BcnEarlyAdjustPID;
-#endif /* #if CONFIG_BCNEARLY_ADJUST_V2 */
-
-#if CONFIG_BCNADJ_LPSOFFLOAD_V2
-	BCNEARLY_ADJUST_PID   	BcnEarlyAdjustPID;
-#endif /* #if CONFIG_BCNADJ_LPSOFFLOAD_V2 */
-
-#if CONFIG_BCNEARLY_ADJUST_V1
-	BCNEARLY_ADJUST_Stat	BcnEarlyAdjustStat;
-#endif/* #if CONFIG_BCNEARLY_ADJUST_V1 */
-
-#if CONFIG_BCNADJ_LPSOFFLOAD_V1
-	BCNEARLY_ADJUST_Stat	BcnEarlyAdjustStat;
-#endif/* #if CONFIG_BCNADJ_LPSOFFLOAD_V1 */
-
-#if CONFIG_SAPPS
-	SAPPSParm               SAPPSCtrl;
-#endif  /* CONFIG_SAPPS */
-
-#if CONFIG_INACTIVE_PS
-	INACTIVEPSParm          InactivePSCtrl;
-#endif  /* #if CONFIG_INACTIVE_PS */
-
-	LPSOFFLOADParm	LPSOffloadParm;
-	LPSPG_PARM	   		LPSPGParm;
-	PS_DBGPARM			PSDbgParm;
-#if CONFIG_LPS_I_TWT
-	LPS_ITWT_PARM		LPSITWTParm;
-#endif
-#if CONFIG_BTCOEX
-	BTC_PsTdma_Parm                  BtcPsTdma;
-	H2C_BT_Tdma_Parm                 H2cBtTdma;                //H2C Index: 0x60
-	H2C_Ant_Sel_Reverse_Parm         H2cAntSelReverse;         //H2C Index: 0x65
-	H2C_WL_Opmode_Parm               H2cWlOpmode;              //H2C Index: 0x66
-	H2C_BT_Page_Scan_Interval_Parm   H2cBtPageScanInterval;    //H2C Index: 0x6C
-	H2C_WL_Calibration_Parm          H2cWlCalibration;         //H2C Index: 0x6D
-	H2C_BT_OnlyTest_Parm             H2cBtOnlyTest;            //H2C Index: 0x6F
-	H2C_BT_Init_Parm                 H2cBtInit;                //H2C Index: 0x70
-	H2C_WL_PortID_Parm               H2cWlPortID;              //H2C Index: 0x71
-#endif  /* #if CONFIG_BTCOEX */
-
-#if CONFIG_BTMAILBOX
-	BTC_Mailbox_Parm                 BtcMailbox;
-#endif /* #if CONFIG_BTMAILBOX */
-
-#if CONFIG_BTSCOREBRD
-	BTC_Scoreboard_Parm              BtcScoreboard;
-#endif /* CONFIG_BTSCOREBRD */
-
-	RemoteWakeup_Parm       RemoteWakeUpCtrl;
-	AOAC_INFO               AOACInfo;
-	AOAC_GLOBAL_INFO        AOACGlobalInfo;
-	AOAC_RSVDPAGE1          AOACPage1;
-	AOAC_RSVDPAGE2          AOACPage2;
-	AOAC_RSVDPAGE3          AOACPage3;
-
-	KeepAlive_Parm          KeepAliveParm;
-
-	Disconnect_Parm         DisconnectParm;
-
-#if CONFIG_CSI_REPORT
-	CSIReport_Parm          CSIReportParm;
-#endif
-
-#if CONFIG_TSF_RESET_PATCH
-	u8                      TSF_RST_Port[2];
-#endif  /* #if CONFIG_TSF_RESET_PATCH */
-
-#if CONFIG_TXBEACON_IGNORE_EDCCA
-	u8                      BcnIgnoreEdccaEn;
-#endif  /* CONFIG_TXBEACON_IGNORE_EDCCA */
-
-#if CONFIG_TX_PAUSE_DRV_INFO
-	u8						TxPauseDRVInfo;
-	u8						TxPauseFWInfo_0;
-#endif /* #if CONFIG_TX_PAUSE_DRV_INFO */
-#if CONFIG_TPBASE_RA
-	TPBASE_RA_PARM TPBaseRAParm[MACID_NUM];
-#endif
-
-#if CONFIG_PERIOD_CCA
-	u8						period_cca_en;
-	u8						period_cca_reg_backup_done;
-	u8						preiod_cca_bbreg_backup[7];
-	u8						period_cca_rssi;
-#endif
-	u32                    RF_18;
-} mib_info, *Pmib_info;
-
-#ifdef __WIFIFW_INIT_RAM_C__
-
-mib_info         SysMib;
-
-#else
-
-extern                mib_info         SysMib;
-
-#endif /* #ifdef __WIFIFW_INIT_RAM_C__ */
-
-
-
-
-
-/*--------------------Define --------------------------------------------*/
-
-/*--------------------Define Enum---------------------------------------*/
-
-/*--------------------Define MACRO--------------------------------------*/
-
-/*--------------------Define Struct---------------------------------------*/
-typedef struct _H2C_S1_null1_ctrl_parm_ {
-	u8 S1_null1_ctrl_en: 1;
-	u8 S1_null1_fail_limit: 7;
-	u8 S1_null1_interval;
-} H2C_S1_null1_ctrl_parm, *PH2C_S1_null1_ctrl_parm;
-
-typedef struct _S1_null1_parm_ {
-	u32 S1_null1_unlock_time;
-	u8 S1_null1_fail_cnt;
-	u8 S1_null1_delay_flag: 1;
-	u8 rsvd: 7;
-} S1_null1_parm, *PS1_null1_parm;
-
-typedef struct _S1_null1_ivl_patch_ {
-	S1_null1_parm s1_null1_parm;
-	H2C_S1_null1_ctrl_parm s1_null1_ctrl_parm;
-} S1_null1_ivl_patch, *PS1_null1_ivl_patch;
-
-
-typedef struct _mib_info_8720E_ {
-	S1_null1_ivl_patch s1_null1_ivl_patch;
-} mib_info_8720E, *Pmib_info_8720E;
-
-/*------------------------Export global variable------------------------------*/
-#ifdef  __WIFIFW_INIT_RAM_C__
-
-mib_info_8720E                SysMib8720E;
-
-#else
-
-extern               mib_info_8720E                SysMib8720E;
-
-#endif  /* #ifdef    __WIFIFW_INIT_RAM_C__ */
-
-/*------------------------Export global variable------------------------------*/
-/*------------------------------Function declaration--------------------------*/
-#endif  /* __WIFIFW_SYSMIB_H__ */
-
diff --git a/os/board/rtl8720e/src/component/wifi/wifi_fw/amebalite/include/wififw_txreport_ram.h b/os/board/rtl8720e/src/component/wifi/wifi_fw/amebalite/include/wififw_txreport_ram.h
deleted file mode 100644
index c860215f8..000000000
--- a/os/board/rtl8720e/src/component/wifi/wifi_fw/amebalite/include/wififw_txreport_ram.h
+++ /dev/null
@@ -1,78 +0,0 @@
-#ifndef __WIFIFW_TXREPORT_RAM_H__
-#define __WIFIFW_TXREPORT_RAM_H__
-/*--------------------Define MACRO--------------------------------------*/
-#define TEST_FORCE_TRXRPT_FULL          0       //set 1 to force TRxRPT full
-#define TXRPTFIELD_RPT_SEL              (BIT7|BIT6|BIT5)
-
-/*--------------------Define Struct---------------------------------------*/
-typedef enum _RPT_TYPE_ {
-	TXRPT       = 0,
-	FTMRPT      = 1,
-	CCXRPT      = 2,
-	FTMACKRPT   = 3,
-	TXBCNRPT    = 4,
-	RXBCNRPT    = 6,
-	TXRPTNew	= 7,
-	TRIGGER		= 8,
-} RPT_TYPE, *PRPT_TYPE;
-
-typedef struct _TxRpt_Cfg_ {
-	//offset 0
-	u8 tx_polluted: 1;
-	u8 tx_state: 4;
-	u8 rpt_sel: 3;
-	//offset 1
-	u8 rpt_qsel: 5;
-	u8 collision_head: 1; //for 97G/12F
-	u8 collision_tail: 1; //for 97G/12F
-	u8 fixed_rate: 1; //driver fixed rate
-	//offset 2
-	u16 macid: 7;
-	//offset 3
-	u16 init_rate: 9;
-	//offset 4
-	u8 ok_num: 6;
-	u8 rsvd0: 1;
-	u8 try_rate: 1;
-	//offset 5
-	u8 drop_num: 6;
-	u8 rsvd1: 2;
-	//offset 6
-	u8 sw_def;
-	//offset 7
-	u8 rts_rty_count: 4;
-	u8 tb_ppdu_flag: 1;
-	u8 rts_bmc: 1;
-	u8 rx_polluted: 1;
-	u8 rsvd2: 1;
-	//offset 8
-	u16 data_rty_count: 6;
-	//offset 9
-	u16 final_data_rate: 9;
-	u16 rsvd3: 1;
-	//offset 10
-	u8 rsvd4;
-	//offset 11
-	u8 rsvd5: 2;
-	u8 ch_sc: 4;
-	u8 ch_bw: 2;
-	//offset 12
-	u8 total_cnt: 6; /*total number of MPDU have been transmitted*/
-	u8 ppdu_type: 2;
-	//offset 13
-	u8 zero_retry_pkt_num: 6;
-	u8 rsvd: 2;
-	//offset 14
-	u16 bSR: 1;
-	u16 init_data_gi_ltf: 3;
-	u16 final_gi_ltf: 3;
-	//offset 15
-	u16 txpwr_pd: 5;
-} TxRpt_Cfg, *pTxRpt_Cfg;
-
-
-/*------------------------------Function declaration--------------------------*/
-extern void InitCtrlInfo_8720E(void);
-extern void ParseTRXRpt(void);
-
-#endif  /* #ifndef   __WIFIFW_TXREPORT_RAM_H__ */
diff --git a/os/board/rtl8720e/src/component/wifi/wifi_fw/amebalite/include/wififw_types.h b/os/board/rtl8720e/src/component/wifi/wifi_fw/amebalite/include/wififw_types.h
deleted file mode 100644
index 18f4e3447..000000000
--- a/os/board/rtl8720e/src/component/wifi/wifi_fw/amebalite/include/wififw_types.h
+++ /dev/null
@@ -1,63 +0,0 @@
-#ifndef _ARCH_TYPES_H
-#define _ARCH_TYPES_H
-
-//-------------------------------------------------------
-//
-//      Belows are Keil-C Related.
-//
-//-------------------------------------------------------
-typedef unsigned char           BOOLEAN, *PBOOLEAN;
-typedef unsigned char           u1Byte, *pu1Byte;
-typedef unsigned short          u2Byte, *pu2Byte;
-typedef unsigned long           u4Byte, *pu4Byte;
-typedef unsigned long long		u8Byte, *pu8Byte;
-
-typedef char                    s1Byte, *ps1Byte;
-typedef short                   s2Byte, *ps2Byte;
-typedef long                    s4Byte, *ps4Byte;
-
-#ifndef PVOID
-typedef void                     *PVOID;
-#endif
-
-typedef signed char              s8;
-typedef unsigned char           u8;
-
-typedef short                   s16;
-typedef unsigned short          u16;
-
-#ifndef s32
-typedef long                    s32;
-#endif
-
-#ifndef u32
-typedef unsigned long           u32;
-#endif
-
-#ifndef u64
-typedef unsigned long long 	u64;
-#endif
-
-#define printf                  DBG_8195A
-
-#if !defined(__IARSTDLIB__)
-#ifndef memcmp
-#define memcmp(dst, src, sz)			_memcmp(dst, src, sz)
-#endif
-#ifndef memset
-#define memset(dst, val, sz)			_memset(dst, val, sz)
-#endif
-#ifndef memcpy
-#define memcpy(dst, src, sz)			_memcpy(dst, src, sz)
-#endif
-#endif /* #if !defined(__IARSTDLIB__) */
-
-#define _U16_MSB(x)             (((u16)(x))>>8)
-#define _U16_LSB(x)             ((u8)(x))
-#define _B2W(LSB, MSB)          ((u16)(LSB) | (((u16)(MSB))<<8))
-#define _B2D(x0,x1,x2,x3)       ((u32)(x0)|((u32)(x1)<<8)|((u32)(x2)<<16)|((u32)(x3)<<24))
-#define _D2B(x, idx)            (u8)(((u32)(x))>>(8*(idx)))
-#define _L2B(L)                 (((u32)(L&0xFF000000)>>24)|((u32)(L&0x00FF0000)>>8)|((u32)(L&0x0000FF00)<<8)|((u32)(L&0x000000FF)<<24))
-#define _nop_()
-
-#endif  /* #ifndef _ARCH_TYPES_H */
diff --git a/os/board/rtl8720e/src/component/wifi/wifi_fw/amebalite/include/wififw_wlan_ram.h b/os/board/rtl8720e/src/component/wifi/wifi_fw/amebalite/include/wififw_wlan_ram.h
deleted file mode 100644
index 280e385e7..000000000
--- a/os/board/rtl8720e/src/component/wifi/wifi_fw/amebalite/include/wififw_wlan_ram.h
+++ /dev/null
@@ -1,25 +0,0 @@
-#ifndef __WLAN_RAM_H__
-#define __WLAN_RAM_H__
-
-#include "wififw_reg_ram.h"
-#include "wififw_init_ram.h"
-#include "wififw_interrupt_ram.h"
-#include "wififw_debug_ram.h"
-#include "wififw_hioe_ram.h"
-#include "wififw_dma_ram.h"
-#include "wififw_btconcurr_ram.h"
-#include "wififw_packet_ram.h"
-#include "wififw_powersave_ram.h"
-#include "wififw_powerctrl_ram.h"
-#include "wififw_wowlan_ram.h"
-#include "wififw_lps_offload_ram.h"
-#include "wififw_txreport_ram.h"
-#include "wififw_phydm_ram.h"
-#include "wififw_cmd_ram.h"
-#include "wififw_rate_adaptive_ram.h"
-#include "wififw_sysmib_ram.h"
-#include "wififw_halbb_cmd_ram.h"
-#include "wififw_phydm_offload_ram.h"
-#include "wififw_csireport_ram.h"
-
-#endif  /* __WLAN_RAM_H__ */
diff --git a/os/board/rtl8720e/src/component/wifi/wifi_fw/amebalite/include/wififw_wowlan_ram.h b/os/board/rtl8720e/src/component/wifi/wifi_fw/amebalite/include/wififw_wowlan_ram.h
deleted file mode 100644
index 97b784e2a..000000000
--- a/os/board/rtl8720e/src/component/wifi/wifi_fw/amebalite/include/wififw_wowlan_ram.h
+++ /dev/null
@@ -1,337 +0,0 @@
-#ifndef __WIFIFW_WoWLAN_RAM_H__
-#define __WIFIFW_WoWLAN_RAM_H__
-
-/*--------------------Define MACRO--------------------------------------*/
-#define IOT_WAITHOST_TO     5
-#define UDP_LENGTH_OFFSET                   4
-#define UDP_CHECK_SUM_OFFSET                6
-#define ROL32( A, n )	( ((A) << (n)) | ( ((A)>>(32-(n)))  & ( (1UL << (n)) - 1 ) ) )
-#define ROR32( A, n ) 	ROL32( (A), 32-(n) )
-
-#define FORCE_WAKE_UP								BIT0
-#define PATTERN_MATCH_EN            				BIT1
-#define MAGIC_PKT_EN                				BIT2
-#define UNICAST_EN                  					BIT3
-#define WOWHCI_EN                   					BIT5
-#define REG_WoW_REASON          					REG_DBG_BYTE_5   //1C7
-#define RXDMA_IDLE                  					BIT1
-#define STOP_RXDMA                  					BIT2
-//3 wowlan rx used type
-#define Rx_Pairwisekey          					0x01
-#define Rx_GTK                  						0x02
-#define Rx_Fourway_Handshake    					0x03
-#define Rx_DisAssoc             						0x04
-#define Rx_DeAuth               						0x08
-#define Rx_ArpRequest           					0x09
-#define Rx_NS                       					0x0a
-#define RX_EAPREQ_IDENTIFY 						0x0b
-#define FWDecisionDisconnect    					0x10
-#define Rx_MagicPkt             						0x21
-#define Rx_UnicastPkt           					0x22
-#define Rx_PatternPkt           					0x23
-#define RTD3_SSID_Match         					0x24
-#define HW_RX_WAKEUP_PATTERN    					0x25
-#define RX_RealWoW_V2_WakeupPkt 				0x30
-#define RX_RealWoW_V2_AckLost   				0x31
-#define Enable_Fail_DMAIdle     					0x40
-#define Enable_Fail_DMAPause    					0x41
-#define RTime_Fail_DMAIdle      					0x42
-#define RTime_Fail_DMAPause     					0x43
-#define RxShift_Error      	 						0x44
-#define BT_Wakeup_Host          					0x45
-#define NLO_SSID_Match          					0x55
-#define AP_Offload_WakeUp       					0x66
-#define CLK_32K_UNLOCK          					0xFD
-#define CLK_32K_LOCK            					0xFE
-
-#define DEFAULT_DISCONNECT_COUNT_LIMIT      	8       /*UNIT: beacon interval*/
-#define DEFAULT_TRY_PKT_LIMIT               	3
-#define KeepAliveUnit                       		10      /*UNIT: beacon interval*/
-#define DEFAULT_KEEP_ALIVE_COUNT_LIMIT      	0x0A    /*Unit: BCN interval*/
-#define WAIT_RXDMA_CNT                      		(2000)
-#define CHECK_RXDMA_ONCE_TIME               	(10)
-#define MAGIC_WAKEUP                        		BIT7
-#define UNICAST_WAKEUP                      		BIT6
-#define PATTERN_WAKEUP                      		BIT5
-#define DMAIDLE                             			BIT1
-#define DMAPAUSE                            			BIT2
-#define ProtectedFrame                      		BIT6
-
-#define ARP_SEL_PASSIVE_RESPONSE 				0
-#define ARP_SEL_KEEPALIVE_UNICAST_GATEWAY	1
-
-#define NDP_SEL_PASSIVE_RESPONSE            	0
-#define NDP_SEL_KEEPALIVE_UNICAST_GATEWAY	1
-
-#define KEEPALIVE_TYPE_NULLDATA             	0
-#define KEEPALIVE_TYPE_ARP_RESPONSE         	1
-
-#define ARP_ACTION_ARP_RESPONSE             	0
-#define ARP_ACTION_WAKEUP_HOST              	1
-
-#define WAKEUP_HOST_FROM_AP_OFFLOAD         	0
-#define WAKEUP_HOST_FROM_WOWLAN             	1
-
-/* WakeupHostDecision function Control */
-#define CHECK_WAKEUP_BY_DESC                		BIT0
-#define CHECK_WAKEUP_BY_INT                 		BIT1
-
-/* below is IPv6 header offset */
-#define IPv6_ALEN               						16
-#define IPv6_NEXT_HEADER_OFFSET 				6
-#define IPv6_SRC_ADDRESS_OFFSET 				8
-#define IPv6_DES_ADDRESS_OFFSET		 			24
-#define IPv6_HEADER             						40
-#define ICMPV6_CHECKSUM_OFFSET         2
-
-/* below is IPv6 header offset */
-#define ICMPV6_TARGETADDRESS_OFFSET        	8
-#define ICMPV6_OPTION_TARGET_ADDR_OFFSET	26
-#define ICMPV6_HEADER           					32
-
-#define SHA1_MAC_LEN 								20
-#define LLC_LEN 										8
-#define IEEE802_1X_HDR_LEN 						4
-#define EAPOL_KEY_RPYCNT_SIZE 					8
-#define WPA_REPLAY_COUNTER_LEN 					8
-#define WPA_NONCE_LEN 								32
-#define SYMBOL_CHECK_PTK                    		BIT0
-#define SYMBOL_CHECK_GTK                    		BIT1
-
-#define AOAC_REPORT_VERSION      0x1
-/*--------------------Define Enum---------------------------------------*/
-enum WIFI_FRAME_TYPE {
-	WIFI_MGT_TYPE				= (0),
-	WIFI_CTRL_TYPE 			= (BIT2),
-	WIFI_DATA_TYPE 			= (BIT3),
-};
-//add 80211ax newtype here 20211021
-enum WIFI_FRAME_SUBTYPE {
-	/* below is for mgt frame */
-	WIFI_ASSOCREQ       		= (0 | WIFI_MGT_TYPE),
-	WIFI_ASSOCRSP       		= (BIT4 | WIFI_MGT_TYPE),
-	WIFI_REASSOCREQ     		= (BIT5 | WIFI_MGT_TYPE),
-	WIFI_REASSOCRSP     		= (BIT5 | BIT4 | WIFI_MGT_TYPE),
-	WIFI_PROBEREQ       		= (BIT6 | WIFI_MGT_TYPE),
-	WIFI_PROBERSP       		= (BIT6 | BIT4 | WIFI_MGT_TYPE),
-	WIFI_BEACON         		= (BIT7 | WIFI_MGT_TYPE),
-	WIFI_ATIM          	 		= (BIT7 | BIT4 | WIFI_MGT_TYPE),
-	WIFI_DISASSOC       		= (BIT7 | BIT5 | WIFI_MGT_TYPE),
-	WIFI_AUTH           			= (BIT7 | BIT5 | BIT4 | WIFI_MGT_TYPE),
-	WIFI_DEAUTH         		= (BIT7 | BIT6 | WIFI_MGT_TYPE),
-	WIFI_ACTION         		= (BIT7 | BIT6 | BIT4 | WIFI_MGT_TYPE),
-
-	/* below is for control frame */
-	WIFI_PSPOLL         		= (BIT7 | BIT5 | WIFI_CTRL_TYPE),
-	WIFI_RTS            			= (BIT7 | BIT5 | BIT4 | WIFI_CTRL_TYPE),
-	WIFI_CTS            			= (BIT7 | BIT6 | WIFI_CTRL_TYPE),
-	WIFI_ACK            			= (BIT7 | BIT6 | BIT4 | WIFI_CTRL_TYPE),
-	WIFI_CFEND          		= (BIT7 | BIT6 | BIT5 | WIFI_CTRL_TYPE),
-	WIFI_CFEND_CFACK    		= (BIT7 | BIT6 | BIT5 | BIT4 | WIFI_CTRL_TYPE),
-	//new for ax add 211022 david
-	WIFI_TRIGGER				= (BIT5 | WIFI_CTRL_TYPE),
-	WIFI_NDP_ANCMT			= (BIT6 | BIT4 | WIFI_CTRL_TYPE),
-
-	/* below is for data frame */
-	WIFI_DATA           			= (0 | WIFI_DATA_TYPE),
-	WIFI_DATA_CFACK     		= (BIT4 | WIFI_DATA_TYPE),
-	WIFI_DATA_CFPOLL    		= (BIT5 | WIFI_DATA_TYPE),
-	WIFI_DATA_CFACKPOLL 	= (BIT5 | BIT4 | WIFI_DATA_TYPE),
-	WIFI_DATA_NULL      		= (BIT6 | WIFI_DATA_TYPE),
-	WIFI_CF_ACK         		= (BIT6 | BIT4 | WIFI_DATA_TYPE),
-	WIFI_CF_POLL        		= (BIT6 | BIT5 | WIFI_DATA_TYPE),
-	WIFI_CF_ACKPOLL     		= (BIT6 | BIT5 | BIT4 | WIFI_DATA_TYPE),
-	WIFI_QOS_DATA       		= (BIT7 | WIFI_DATA_TYPE),
-	WIFI_QOS_NULL       		= (BIT7 | BIT6 | WIFI_DATA_TYPE),
-};
-
-/*--------------------Define Struct---------------------------------------*/
-typedef struct _AOAC_REPORT_ {
-	u8		pPTKTXIV[8];
-	u8		pReplayCntEapolKey[8];
-	u8   	pGroupKey[32];          /*the last updated GTK data*/
-	u8   	u1KeyIdx;               /*the last updated GTK index*/
-	u8   	u1SecurityType;         /*per received packet*/
-	u8   	u1WowPatternIdx;        /*per received packet*/
-	u8   	u1RptFormatVer;         /*In old FW, this is a 1-byte rsvd, FW clear this byte certainly*/
-	u8   	u1Rsvd[4];              /*In old FW, these 4 bytes are not include in AOAC rpt. Don't use these 4 bytes. Just for 8-byte alignment*/
-	u8   	u4RxPTKIV[8];           /*Unicast IV*/
-	u8   	u4RxGTKIV_0[8];         /*Broadcast/Mulicast IV, 4 GTK index*/
-	u8   	u4RxGTKIV_1[8];
-	u8   	u4RxGTKIV_2[8];
-	u8   	u4RxGTKIV_3[8];
-} AOAC_REPORT, *PAOAC_REPORT;
-
-typedef enum {
-	NO_Encryption				= 0,
-	WEP40_Encryption  		= 1,
-	TKIP_Encryption   		= 2,
-	Reserved_Encryption  	= 3,
-	AESCCMP_Encryption  		= 4,
-	WEP104_Encryption  		= 5,
-} RT_ENC_ALG, *PRT_ENC_ALG;
-
-typedef struct _ieee802_1x_hdr {
-	u8 		version;
-	u8 		type;
-	u16 	length;
-	/* followed by length octets of data */
-} ieee802_1x_hdr, *pieee802_1x_hdr;
-
-typedef struct _wpa_eapol_key {
-	u8 		type;
-	/* Note: key_info, key_length, and key_data_length are unaligned */
-	u8 		key_info[2];
-	u8 		key_length[2];
-	u8 		replay_counter[WPA_REPLAY_COUNTER_LEN];
-	u8 		key_nonce[WPA_NONCE_LEN];
-	u8 		key_iv[16];
-	u8 		key_rsc[8];
-	u8 		key_id[8]; /* Reserved in IEEE 802.11i/RSN */
-	u8	 	key_mic[16];
-	u8 		key_data_length[2];
-	/* followed by key_data_length bytes of key_data */
-} wpa_eapol_key, *pwpa_eapol_key;
-
-typedef struct _H2C_EAPOL_KEY_STRUCT {
-	ieee802_1x_hdr	ieee802_1x_hdr_data;
-	wpa_eapol_key		eapol_key_data;
-	u8		key_data[128];
-} H2C_EAPOL_KEY_STRUCT, *pH2C_EAPOL_KEY_STRUCT;
-
-typedef struct _H2C_WPA_PTK {
-	u8		kck[16]; /* EAPOL-Key Key Confirmation Key (KCK) */
-	u8		kek[16]; /* EAPOL-Key Key Encryption Key (KEK) */
-	u8  	tk1[16]; /* Temporal Key 1 (TK1) */
-	union {
-		u8		tk2[16]; /*Temporal Key 2 (TK2)*/
-		struct {
-			u8  tx_mic_key[8];
-			u8  rx_mic_key[8];
-		} Athu;
-	} U;
-} H2C_WPA_PTK;
-
-typedef struct _H2C_WPA_TWO_WAY_PARA {
-	H2C_WPA_PTK     wpa_ptk_value;
-} H2C_WPA_TWO_WAY_PARA, *PH2C_WPA_TWO_WAY_PARA;
-
-typedef struct _SECURITY_INFO_ {
-	H2C_WPA_TWO_WAY_PARA wpa_two_way_para;
-	H2C_EAPOL_KEY_STRUCT gtk_req;
-} SECURITY_INFO, *PSECURITY_INFO;
-
-typedef struct _ARP_INFO_ {
-	u8		A3Addr[6];/*gateway's address*/
-	u8		IPV4[4];
-	u8		THA[6];
-	u8 		TPA[4];
-} ARP_INFO, *PARP_INFO;
-
-typedef struct _NDP_INFO_ {
-	u8 		Enable: 1;
-	u8 		bCheckRemoveIP: 1;  /*Need to Check Sender IP or not*/
-	u8 		Rsvd: 6;  /*Need to Check Sender IP or not*/
-	u8 		NumberOfTargetIP; /*Number of Check IP which NA query IP*/
-	u8 		TagetLinkAddress[6];  /*Maybe support change MAC address !!*/
-	u8 		RemoteIPv6Address[16]; /*Just respond IP*/
-	u8 		TargetIP[2][16]; /*target IP*/
-} NDP_INFO, *PNDP_INFO;
-
-typedef struct _IPV6_PSEUDO_HEADER_INFO {
-	u8 		SourceAddress[16];
-	u8 		DestinationAddress[16];
-	u32 	PayPloadLength;
-	u8 		rsvd1[3];
-	u8 		NextHeader;
-} IPV6_PSEUDO_HEADER_INFO, *PIPV6_PSEUDO_HEADER_INFO;
-
-typedef struct _AOAC_INFO_ {
-	ARP_INFO    ARPInfo;
-	NDP_INFO    NDPInfo[2];
-	IPV6_PSEUDO_HEADER_INFO Ipv6PseudoHeaderInfo;
-	SECURITY_INFO SecurityInfo;
-	AOAC_REPORT AOACReport;
-} AOAC_INFO, *PAOAC_INFO;
-
-struct mic_data {
-	u32  	K0, K1;         // Key
-	u32  	L, R;           // Current state
-	u32  	M;              // Message accumulator (single word)
-	u32 	nBytesInM;      // # bytes in M
-};
-/*--------------------Define Enum---------------------------------------*/
-
-typedef enum _CHECK_SUM_PROTOCOL_ {
-	IP_CHECK_SUM    = 0,
-	TCP_CHECK_SUM   = 6,
-	UDP_CHECK_SUM   = 17,
-	ICMPV6_CHECK_SUM = 58,
-} CHECK_SUM_PROTOCOL, *PCHECK_SUM_PROTOCOL;
-
-/*--------------------Function declaration---------------------------------*/
-extern u8 CheckIV_8720E(u8 *IVToCheck, u8 raaddr, BOOLEAN unicast_check);
-extern u8 DropCHK_8720E(void);
-extern BOOLEAN WaitRXDMAIdle_8720E(void);
-extern BOOLEAN CHECKRXPKTNULL_8720E(void);
-extern void UpdateChInfoReadPtr_DropPkt_8720E(u16 RPtr);
-extern void UpdatePhyStsReadPtr_DropPkt_8720E(u16 RPtr);
-extern void RxPHYSTSRelease_8720E(void);
-extern void RxCHInfoRelease_8720E(void);
-extern void EnableWoWLAN_8720E(void);
-extern void DisWoWLAN_8720E(void);
-extern BOOLEAN DropDecision_8720E(void);
-extern void FwDisConnectWakeUpHost_8720E(IN u8 type);
-extern BOOLEAN Ipv4Match_8720E(u16 addrl_frame_ctrl, u8 macHeaderLen);
-extern BOOLEAN MatchUnicastFilter_8720E(u16 addrl_frame_ctrl, u8 macHeaderLen);
-extern BOOLEAN WakeUpHostDecision_8720E(u8 RxDescWakeReason, u8 CheckMode);
-extern BOOLEAN DestinationMatch_8720E(u16 addrl_frame_ctrl);
-extern void UpdateRxFFReadPtr_DropPkt_8720E(u16 RPtr);
-extern void H2CHDL_WoWLAN_8720E(u8 *pbuf);
-extern void H2CHDL_AOACGlobalInfo_8720E(u8 *pbuf);
-extern void H2CHDL_AOACRsvdpage1_8720E(u8 *pbuf);
-extern void H2CHDL_AOACRsvdpage2_8720E(u8 *pbuf);
-extern void H2CHDL_AOACRsvdpage3_8720E(u8 *pbuf);
-extern void GetAddr_8720E(void);
-extern void ARP_hdl_8720E(u8 bFunEnable);
-extern void NDP_hdl_8720E(u8 bFunEnable);
-extern BOOLEAN OnARP_8720E(u16 addrl_frame_ctrl, u8 MacHeaderLen);
-extern void GetARPInfo_8720E(u8 pagenum);
-extern void GetNDPInfo_8720E(u8 pagenum);
-extern BOOLEAN OnNS_8720E(u16 addrl_frame_ctrl, u8 MacHeaderLen);
-extern BOOLEAN IsIPV6_8720E(u16 addrl_frame_ctrl, u8 MacHeaderLen);
-extern void PassSecurityInfoToDriver_8720E(u8 pagenum);
-extern void GetRemoteControlInfo_8720E(u8 pagenum);
-extern void InitDisconnectDecision_8720E(void);
-extern void H2CHDL_DisconnectDecision_8720E(u8 *pbuf);
-extern void InitKeepAlive_8720E(void);
-extern void H2CHDL_KeepAlive_8720E(u8 *pbuf);
-extern u16 PageOffsetAlignment_8720E(IN u16 offset);
-extern void GetIV_8720E(u16 addrl_frame_ctrl, u8 MacHeaderLen, u8 IvLen, u8 *IV);
-extern u8 GetIVLenAndSecurityType_8720E(u8 raaddr);
-extern u8 GetMACHeaderLen_8720E(u8 macheader, u8 FrameCtrl, u8 raaddr);
-extern void UpdateIV_8720E(u8 *buf, u8 retry_bit);
-extern s8 RTmemcmpBackward_8720E(const void *Dest, const void *Src, u8 count);
-extern u8 AesTkipIvCheck_8720E(u8 *rx_iv_ori, u8 *rx_iv, u8 SecurityType);
-extern u8 WepIvCheck_8720E(u8 *rx_iv_ori, u8 *rx_iv);
-extern void AssignIvToKeyRsc_8720E(u8 *pattrib_iv, u8 *KeyRsc, u8 *KeyID, u8 SecurityType);
-extern void AssignKeyRscToIV_8720E(u8 *pattrib_iv, u8 *KeyRsc, u8 SecurityType);
-extern void AesTkipIvFun_8720E(u8 *pattrib_iv, u8 RetryBit, u8 SecurityType);
-extern void WepIvFun_8720E(u8 *iv, u8 retry_bit);
-extern void DisconnectChk_8720E(void);
-extern void DisconnectTxNullChk_8720E(IN u8 pwr);
-extern void InitRemoteWakeUp_8720E(void);
-extern void RemoteWakeUp_8720E(void);
-extern void ClearRxBuff_8720E(void);
-extern void H2CHDL_RemoteWakeUp_8720E(u8 *pbuf);
-extern void issue_ARP_8720E(u8 *TargetIP, u8 *TargetMAC, u8  retry_bit, u8  arpsel);
-extern u32 GetSumValue_8720E(u32 offset, u16 pktLen);
-extern u16 GetCheckSum_8720E(u8 protocol, u16 pktLen, u32 src_addr, u32 dest_addr, u32 input);
-extern void UpdateCheckSumVer2_8720E(u8 mode, u32 offset);
-extern void FillIpv6PseudoHeader_8720E(u8 *TargetIP, u8 *OurIP, u32  PayLoadLength, u8  NextHeader);
-extern void IssueNA_8720E(u8 *TargetIP, u8 *TargetMAC, u8 *OurIP, u8 *OurMAC, u8  retry_bit, u8  ndpsel);
-extern void KeepAliveChk_8720E(void);
-extern void TryPKT_8720E(void);
-extern void WakeUpHost_8720E(u8 source);
-
-#endif  /* __WIFIFW_WoWLAN_RAM_H__ */
diff --git a/os/board/rtl8720e/src/component/wifi/wpa_supplicant/src/crypto/crypto.h b/os/board/rtl8720e/src/component/wifi/wpa_supplicant/src/crypto/crypto.h
deleted file mode 100644
index 79192fe57..000000000
--- a/os/board/rtl8720e/src/component/wifi/wpa_supplicant/src/crypto/crypto.h
+++ /dev/null
@@ -1,460 +0,0 @@
-/*
- * WPA Supplicant / wrapper functions for crypto libraries
- * Copyright (c) 2004-2009, Jouni Malinen <j@w1.fi>
- *
- * This software may be distributed under the terms of the BSD license.
- * See README for more details.
- *
- * This file defines the cryptographic functions that need to be implemented
- * for wpa_supplicant and hostapd. When TLS is not used, internal
- * implementation of MD5, SHA1, and AES is used and no external libraries are
- * required. When TLS is enabled (e.g., by enabling EAP-TLS or EAP-PEAP), the
- * crypto library used by the TLS implementation is expected to be used for
- * non-TLS needs, too, in order to save space by not implementing these
- * functions twice.
- *
- * Wrapper code for using each crypto library is in its own file (crypto*.c)
- * and one of these files is build and linked in to provide the functions
- * defined here.
- */
-
-#ifndef CRYPTO_H
-#define CRYPTO_H
-
-/**
- * md4_vector - MD4 hash for data vector
- * @num_elem: Number of elements in the data vector
- * @addr: Pointers to the data areas
- * @len: Lengths of the data blocks
- * @mac: Buffer for the hash
- * Returns: 0 on success, -1 on failure
- */
-int md4_vector(size_t num_elem, const u8 *addr[], const size_t *len, u8 *mac);
-
-/**
- * md5_vector - MD5 hash for data vector
- * @num_elem: Number of elements in the data vector
- * @addr: Pointers to the data areas
- * @len: Lengths of the data blocks
- * @mac: Buffer for the hash
- * Returns: 0 on success, -1 on failure
- */
-int md5_vector(size_t num_elem, const u8 *addr[], const size_t *len, u8 *mac);
-
-
-/**
- * sha1_vector - SHA-1 hash for data vector
- * @num_elem: Number of elements in the data vector
- * @addr: Pointers to the data areas
- * @len: Lengths of the data blocks
- * @mac: Buffer for the hash
- * Returns: 0 on success, -1 on failure
- */
-int sha1_vector(size_t num_elem, const u8 *addr[], const size_t *len,
-				u8 *mac);
-
-/**
- * fips186_2-prf - NIST FIPS Publication 186-2 change notice 1 PRF
- * @seed: Seed/key for the PRF
- * @seed_len: Seed length in bytes
- * @x: Buffer for PRF output
- * @xlen: Output length in bytes
- * Returns: 0 on success, -1 on failure
- *
- * This function implements random number generation specified in NIST FIPS
- * Publication 186-2 for EAP-SIM. This PRF uses a function that is similar to
- * SHA-1, but has different message padding.
- */
-int __must_check fips186_2_prf(const u8 *seed, size_t seed_len, u8 *x,
-							   size_t xlen);
-
-/**
- * sha256_vector - SHA256 hash for data vector
- * @num_elem: Number of elements in the data vector
- * @addr: Pointers to the data areas
- * @len: Lengths of the data blocks
- * @mac: Buffer for the hash
- * Returns: 0 on success, -1 on failure
- */
-int sha256_vector(size_t num_elem, const u8 *addr[], const size_t *len,
-				  u8 *mac);
-
-/**
- * des_encrypt - Encrypt one block with DES
- * @clear: 8 octets (in)
- * @key: 7 octets (in) (no parity bits included)
- * @cypher: 8 octets (out)
- */
-void des_encrypt(const u8 *clear, const u8 *key, u8 *cypher);
-
-/**
- * aes_encrypt_init - Initialize AES for encryption
- * @key: Encryption key
- * @len: Key length in bytes (usually 16, i.e., 128 bits)
- * Returns: Pointer to context data or %NULL on failure
- */
-void *aes_encrypt_init(const u8 *key, size_t len);
-
-/**
- * aes_encrypt - Encrypt one AES block
- * @ctx: Context pointer from aes_encrypt_init()
- * @plain: Plaintext data to be encrypted (16 bytes)
- * @crypt: Buffer for the encrypted data (16 bytes)
- */
-void aes_encrypt(void *ctx, const u8 *plain, u8 *crypt);
-
-/**
- * aes_encrypt_deinit - Deinitialize AES encryption
- * @ctx: Context pointer from aes_encrypt_init()
- */
-void aes_encrypt_deinit(void *ctx);
-
-/**
- * aes_decrypt_init - Initialize AES for decryption
- * @key: Decryption key
- * @len: Key length in bytes (usually 16, i.e., 128 bits)
- * Returns: Pointer to context data or %NULL on failure
- */
-void *aes_decrypt_init(const u8 *key, size_t len);
-
-/**
- * aes_decrypt - Decrypt one AES block
- * @ctx: Context pointer from aes_encrypt_init()
- * @crypt: Encrypted data (16 bytes)
- * @plain: Buffer for the decrypted data (16 bytes)
- */
-void aes_decrypt(void *ctx, const u8 *crypt, u8 *plain);
-
-/**
- * aes_decrypt_deinit - Deinitialize AES decryption
- * @ctx: Context pointer from aes_encrypt_init()
- */
-void aes_decrypt_deinit(void *ctx);
-
-
-enum crypto_hash_alg {
-	CRYPTO_HASH_ALG_MD5, CRYPTO_HASH_ALG_SHA1,
-	CRYPTO_HASH_ALG_HMAC_MD5, CRYPTO_HASH_ALG_HMAC_SHA1,
-	CRYPTO_HASH_ALG_SHA256, CRYPTO_HASH_ALG_HMAC_SHA256
-};
-
-struct crypto_hash;
-
-/**
- * crypto_hash_init - Initialize hash/HMAC function
- * @alg: Hash algorithm
- * @key: Key for keyed hash (e.g., HMAC) or %NULL if not needed
- * @key_len: Length of the key in bytes
- * Returns: Pointer to hash context to use with other hash functions or %NULL
- * on failure
- *
- * This function is only used with internal TLSv1 implementation
- * (CONFIG_TLS=internal). If that is not used, the crypto wrapper does not need
- * to implement this.
- */
-struct crypto_hash *crypto_hash_init(enum crypto_hash_alg alg, const u8 *key,
-									 size_t key_len);
-
-/**
- * crypto_hash_update - Add data to hash calculation
- * @ctx: Context pointer from crypto_hash_init()
- * @data: Data buffer to add
- * @len: Length of the buffer
- *
- * This function is only used with internal TLSv1 implementation
- * (CONFIG_TLS=internal). If that is not used, the crypto wrapper does not need
- * to implement this.
- */
-void crypto_hash_update(struct crypto_hash *ctx, const u8 *data, size_t len);
-
-/**
- * crypto_hash_finish - Complete hash calculation
- * @ctx: Context pointer from crypto_hash_init()
- * @hash: Buffer for hash value or %NULL if caller is just freeing the hash
- * context
- * @len: Pointer to length of the buffer or %NULL if caller is just freeing the
- * hash context; on return, this is set to the actual length of the hash value
- * Returns: 0 on success, -1 if buffer is too small (len set to needed length),
- * or -2 on other failures (including failed crypto_hash_update() operations)
- *
- * This function calculates the hash value and frees the context buffer that
- * was used for hash calculation.
- *
- * This function is only used with internal TLSv1 implementation
- * (CONFIG_TLS=internal). If that is not used, the crypto wrapper does not need
- * to implement this.
- */
-int crypto_hash_finish(struct crypto_hash *ctx, u8 *hash, size_t *len);
-
-
-enum crypto_cipher_alg {
-	CRYPTO_CIPHER_NULL = 0, CRYPTO_CIPHER_ALG_AES, CRYPTO_CIPHER_ALG_3DES,
-	CRYPTO_CIPHER_ALG_DES, CRYPTO_CIPHER_ALG_RC2, CRYPTO_CIPHER_ALG_RC4
-};
-
-struct crypto_cipher;
-
-/**
- * crypto_cipher_init - Initialize block/stream cipher function
- * @alg: Cipher algorithm
- * @iv: Initialization vector for block ciphers or %NULL for stream ciphers
- * @key: Cipher key
- * @key_len: Length of key in bytes
- * Returns: Pointer to cipher context to use with other cipher functions or
- * %NULL on failure
- *
- * This function is only used with internal TLSv1 implementation
- * (CONFIG_TLS=internal). If that is not used, the crypto wrapper does not need
- * to implement this.
- */
-struct crypto_cipher *crypto_cipher_init(enum crypto_cipher_alg alg,
-		const u8 *iv, const u8 *key,
-		size_t key_len);
-
-/**
- * crypto_cipher_encrypt - Cipher encrypt
- * @ctx: Context pointer from crypto_cipher_init()
- * @plain: Plaintext to cipher
- * @crypt: Resulting ciphertext
- * @len: Length of the plaintext
- * Returns: 0 on success, -1 on failure
- *
- * This function is only used with internal TLSv1 implementation
- * (CONFIG_TLS=internal). If that is not used, the crypto wrapper does not need
- * to implement this.
- */
-int __must_check crypto_cipher_encrypt(struct crypto_cipher *ctx,
-									   const u8 *plain, u8 *crypt, size_t len);
-
-/**
- * crypto_cipher_decrypt - Cipher decrypt
- * @ctx: Context pointer from crypto_cipher_init()
- * @crypt: Ciphertext to decrypt
- * @plain: Resulting plaintext
- * @len: Length of the cipher text
- * Returns: 0 on success, -1 on failure
- *
- * This function is only used with internal TLSv1 implementation
- * (CONFIG_TLS=internal). If that is not used, the crypto wrapper does not need
- * to implement this.
- */
-int __must_check crypto_cipher_decrypt(struct crypto_cipher *ctx,
-									   const u8 *crypt, u8 *plain, size_t len);
-
-/**
- * crypto_cipher_decrypt - Free cipher context
- * @ctx: Context pointer from crypto_cipher_init()
- *
- * This function is only used with internal TLSv1 implementation
- * (CONFIG_TLS=internal). If that is not used, the crypto wrapper does not need
- * to implement this.
- */
-void crypto_cipher_deinit(struct crypto_cipher *ctx);
-
-
-struct crypto_public_key;
-struct crypto_private_key;
-
-/**
- * crypto_public_key_import - Import an RSA public key
- * @key: Key buffer (DER encoded RSA public key)
- * @len: Key buffer length in bytes
- * Returns: Pointer to the public key or %NULL on failure
- *
- * This function can just return %NULL if the crypto library supports X.509
- * parsing. In that case, crypto_public_key_from_cert() is used to import the
- * public key from a certificate.
- *
- * This function is only used with internal TLSv1 implementation
- * (CONFIG_TLS=internal). If that is not used, the crypto wrapper does not need
- * to implement this.
- */
-struct crypto_public_key *crypto_public_key_import(const u8 *key, size_t len);
-
-/**
- * crypto_private_key_import - Import an RSA private key
- * @key: Key buffer (DER encoded RSA private key)
- * @len: Key buffer length in bytes
- * @passwd: Key encryption password or %NULL if key is not encrypted
- * Returns: Pointer to the private key or %NULL on failure
- *
- * This function is only used with internal TLSv1 implementation
- * (CONFIG_TLS=internal). If that is not used, the crypto wrapper does not need
- * to implement this.
- */
-struct crypto_private_key *crypto_private_key_import(const u8 *key,
-		size_t len,
-		const char *passwd);
-
-/**
- * crypto_public_key_from_cert - Import an RSA public key from a certificate
- * @buf: DER encoded X.509 certificate
- * @len: Certificate buffer length in bytes
- * Returns: Pointer to public key or %NULL on failure
- *
- * This function can just return %NULL if the crypto library does not support
- * X.509 parsing. In that case, internal code will be used to parse the
- * certificate and public key is imported using crypto_public_key_import().
- *
- * This function is only used with internal TLSv1 implementation
- * (CONFIG_TLS=internal). If that is not used, the crypto wrapper does not need
- * to implement this.
- */
-struct crypto_public_key *crypto_public_key_from_cert(const u8 *buf,
-		size_t len);
-
-/**
- * crypto_public_key_encrypt_pkcs1_v15 - Public key encryption (PKCS #1 v1.5)
- * @key: Public key
- * @in: Plaintext buffer
- * @inlen: Length of plaintext buffer in bytes
- * @out: Output buffer for encrypted data
- * @outlen: Length of output buffer in bytes; set to used length on success
- * Returns: 0 on success, -1 on failure
- *
- * This function is only used with internal TLSv1 implementation
- * (CONFIG_TLS=internal). If that is not used, the crypto wrapper does not need
- * to implement this.
- */
-int __must_check crypto_public_key_encrypt_pkcs1_v15(
-	struct crypto_public_key *key, const u8 *in, size_t inlen,
-	u8 *out, size_t *outlen);
-
-/**
- * crypto_private_key_decrypt_pkcs1_v15 - Private key decryption (PKCS #1 v1.5)
- * @key: Private key
- * @in: Encrypted buffer
- * @inlen: Length of encrypted buffer in bytes
- * @out: Output buffer for encrypted data
- * @outlen: Length of output buffer in bytes; set to used length on success
- * Returns: 0 on success, -1 on failure
- *
- * This function is only used with internal TLSv1 implementation
- * (CONFIG_TLS=internal). If that is not used, the crypto wrapper does not need
- * to implement this.
- */
-int __must_check crypto_private_key_decrypt_pkcs1_v15(
-	struct crypto_private_key *key, const u8 *in, size_t inlen,
-	u8 *out, size_t *outlen);
-
-/**
- * crypto_private_key_sign_pkcs1 - Sign with private key (PKCS #1)
- * @key: Private key from crypto_private_key_import()
- * @in: Plaintext buffer
- * @inlen: Length of plaintext buffer in bytes
- * @out: Output buffer for encrypted (signed) data
- * @outlen: Length of output buffer in bytes; set to used length on success
- * Returns: 0 on success, -1 on failure
- *
- * This function is only used with internal TLSv1 implementation
- * (CONFIG_TLS=internal). If that is not used, the crypto wrapper does not need
- * to implement this.
- */
-int __must_check crypto_private_key_sign_pkcs1(struct crypto_private_key *key,
-		const u8 *in, size_t inlen,
-		u8 *out, size_t *outlen);
-
-/**
- * crypto_public_key_free - Free public key
- * @key: Public key
- *
- * This function is only used with internal TLSv1 implementation
- * (CONFIG_TLS=internal). If that is not used, the crypto wrapper does not need
- * to implement this.
- */
-void crypto_public_key_free(struct crypto_public_key *key);
-
-/**
- * crypto_private_key_free - Free private key
- * @key: Private key from crypto_private_key_import()
- *
- * This function is only used with internal TLSv1 implementation
- * (CONFIG_TLS=internal). If that is not used, the crypto wrapper does not need
- * to implement this.
- */
-void crypto_private_key_free(struct crypto_private_key *key);
-
-/**
- * crypto_public_key_decrypt_pkcs1 - Decrypt PKCS #1 signature
- * @key: Public key
- * @crypt: Encrypted signature data (using the private key)
- * @crypt_len: Encrypted signature data length
- * @plain: Buffer for plaintext (at least crypt_len bytes)
- * @plain_len: Plaintext length (max buffer size on input, real len on output);
- * Returns: 0 on success, -1 on failure
- */
-int __must_check crypto_public_key_decrypt_pkcs1(
-	struct crypto_public_key *key, const u8 *crypt, size_t crypt_len,
-	u8 *plain, size_t *plain_len);
-
-/**
- * crypto_global_init - Initialize crypto wrapper
- *
- * This function is only used with internal TLSv1 implementation
- * (CONFIG_TLS=internal). If that is not used, the crypto wrapper does not need
- * to implement this.
- */
-int __must_check crypto_global_init(void);
-
-/**
- * crypto_global_deinit - Deinitialize crypto wrapper
- *
- * This function is only used with internal TLSv1 implementation
- * (CONFIG_TLS=internal). If that is not used, the crypto wrapper does not need
- * to implement this.
- */
-void crypto_global_deinit(void);
-
-/**
- * crypto_mod_exp - Modular exponentiation of large integers
- * @base: Base integer (big endian byte array)
- * @base_len: Length of base integer in bytes
- * @power: Power integer (big endian byte array)
- * @power_len: Length of power integer in bytes
- * @modulus: Modulus integer (big endian byte array)
- * @modulus_len: Length of modulus integer in bytes
- * @result: Buffer for the result
- * @result_len: Result length (max buffer size on input, real len on output)
- * Returns: 0 on success, -1 on failure
- *
- * This function calculates result = base ^ power mod modulus. modules_len is
- * used as the maximum size of modulus buffer. It is set to the used size on
- * success.
- *
- * This function is only used with internal TLSv1 implementation
- * (CONFIG_TLS=internal). If that is not used, the crypto wrapper does not need
- * to implement this.
- */
-int __must_check crypto_mod_exp(const u8 *base, size_t base_len,
-								const u8 *power, size_t power_len,
-								const u8 *modulus, size_t modulus_len,
-								u8 *result, size_t *result_len);
-
-/**
- * rc4_skip - XOR RC4 stream to given data with skip-stream-start
- * @key: RC4 key
- * @keylen: RC4 key length
- * @skip: number of bytes to skip from the beginning of the RC4 stream
- * @data: data to be XOR'ed with RC4 stream
- * @data_len: buf length
- * Returns: 0 on success, -1 on failure
- *
- * Generate RC4 pseudo random stream for the given key, skip beginning of the
- * stream, and XOR the end result with the data buffer to perform RC4
- * encryption/decryption.
- */
-int rc4_skip(const u8 *key, size_t keylen, size_t skip,
-			 u8 *data, size_t data_len);
-
-/**
- * crypto_get_random - Generate cryptographically strong pseudy-random bytes
- * @buf: Buffer for data
- * @len: Number of bytes to generate
- * Returns: 0 on success, -1 on failure
- *
- * If the PRNG does not have enough entropy to ensure unpredictable byte
- * sequence, this functions must return -1.
- */
-int crypto_get_random(void *buf, size_t len);
-
-#endif /* CRYPTO_H */
diff --git a/os/board/rtl8720e/src/component/wifi/wpa_supplicant/src/crypto/des_i.h b/os/board/rtl8720e/src/component/wifi/wpa_supplicant/src/crypto/des_i.h
deleted file mode 100644
index c9563d220..000000000
--- a/os/board/rtl8720e/src/component/wifi/wpa_supplicant/src/crypto/des_i.h
+++ /dev/null
@@ -1,25 +0,0 @@
-/*
- * DES and 3DES-EDE ciphers
- * Copyright (c) 2006-2009, Jouni Malinen <j@w1.fi>
- *
- * This software may be distributed under the terms of the BSD license.
- * See README for more details.
- */
-
-#ifndef DES_I_H
-#define DES_I_H
-
-struct des3_key_s {
-	u32 ek[3][32];
-	u32 dk[3][32];
-};
-
-void des_key_setup(const u8 *key, u32 *ek, u32 *dk);
-void des_block_encrypt(const u8 *plain, const u32 *ek, u8 *crypt);
-void des_block_decrypt(const u8 *crypt, const u32 *dk, u8 *plain);
-
-void des3_key_setup(const u8 *key, struct des3_key_s *dkey);
-void des3_encrypt(const u8 *plain, const struct des3_key_s *key, u8 *crypt);
-void des3_decrypt(const u8 *crypt, const struct des3_key_s *key, u8 *plain);
-
-#endif /* DES_I_H */
diff --git a/os/board/rtl8720e/src/component/wifi/wpa_supplicant/src/crypto/dh_group5.h b/os/board/rtl8720e/src/component/wifi/wpa_supplicant/src/crypto/dh_group5.h
deleted file mode 100644
index 84c8f732d..000000000
--- a/os/board/rtl8720e/src/component/wifi/wpa_supplicant/src/crypto/dh_group5.h
+++ /dev/null
@@ -1,10 +0,0 @@
-#ifndef DH_GROUP5_H
-#define DH_GROUP5_H
-
-void *dh5_init(struct wpabuf **priv, struct wpabuf **publ);
-void *dh5_init_fixed(const struct wpabuf *priv, const struct wpabuf *publ);
-struct wpabuf *dh5_derive_shared(void *ctx, const struct wpabuf *peer_public,
-								 const struct wpabuf *own_private);
-void dh5_free(void *ctx);
-
-#endif /* DH_GROUP5_H */
diff --git a/os/board/rtl8720e/src/component/wifi/wpa_supplicant/src/crypto/dh_groups.h b/os/board/rtl8720e/src/component/wifi/wpa_supplicant/src/crypto/dh_groups.h
deleted file mode 100644
index 0c53a1223..000000000
--- a/os/board/rtl8720e/src/component/wifi/wpa_supplicant/src/crypto/dh_groups.h
+++ /dev/null
@@ -1,31 +0,0 @@
-/*
- * Diffie-Hellman groups
- * Copyright (c) 2007, Jouni Malinen <j@w1.fi>
- *
- * This software may be distributed under the terms of the BSD license.
- * See README for more details.
- */
-
-#ifndef DH_GROUPS_H
-#define DH_GROUPS_H
-
-struct dh_group {
-	int id;
-	const u8 *generator;
-	size_t generator_len;
-	const u8 *prime;
-	size_t prime_len;
-#if (CONFIG_SAE_DH_SUPPORT == 1)
-	const u8 *order;
-	size_t order_len;
-	unsigned int safe_prime: 1;
-#endif
-};
-
-const struct dh_group *dh_groups_get(int id);
-struct wpabuf *dh_init(const struct dh_group *dh, struct wpabuf **priv);
-struct wpabuf *dh_derive_shared(const struct wpabuf *peer_public,
-								const struct wpabuf *own_private,
-								const struct dh_group *dh);
-#endif /* DH_GROUPS_H */
-
diff --git a/os/board/rtl8720e/src/component/wifi/wpa_supplicant/src/crypto/ms_funcs.h b/os/board/rtl8720e/src/component/wifi/wpa_supplicant/src/crypto/ms_funcs.h
deleted file mode 100644
index 9508867fa..000000000
--- a/os/board/rtl8720e/src/component/wifi/wpa_supplicant/src/crypto/ms_funcs.h
+++ /dev/null
@@ -1,60 +0,0 @@
-/*
- * WPA Supplicant / shared MSCHAPV2 helper functions / RFC 2433 / RFC 2759
- * Copyright (c) 2004-2009, Jouni Malinen <j@w1.fi>
- *
- * This software may be distributed under the terms of the BSD license.
- * See README for more details.
- */
-
-#ifndef MS_FUNCS_H
-#define MS_FUNCS_H
-
-int generate_nt_response(const u8 *auth_challenge, const u8 *peer_challenge,
-						 const u8 *username, size_t username_len,
-						 const u8 *password, size_t password_len,
-						 u8 *response);
-int generate_nt_response_pwhash(const u8 *auth_challenge,
-								const u8 *peer_challenge,
-								const u8 *username, size_t username_len,
-								const u8 *password_hash,
-								u8 *response);
-int generate_authenticator_response(const u8 *password, size_t password_len,
-									const u8 *peer_challenge,
-									const u8 *auth_challenge,
-									const u8 *username, size_t username_len,
-									const u8 *nt_response, u8 *response);
-int generate_authenticator_response_pwhash(
-	const u8 *password_hash,
-	const u8 *peer_challenge, const u8 *auth_challenge,
-	const u8 *username, size_t username_len,
-	const u8 *nt_response, u8 *response);
-int nt_challenge_response(const u8 *challenge, const u8 *password,
-						  size_t password_len, u8 *response);
-
-void challenge_response(const u8 *challenge, const u8 *password_hash,
-						u8 *response);
-int challenge_hash(const u8 *peer_challenge, const u8 *auth_challenge,
-				   const u8 *username, size_t username_len, u8 *challenge);
-int nt_password_hash(const u8 *password, size_t password_len,
-					 u8 *password_hash);
-int hash_nt_password_hash(const u8 *password_hash, u8 *password_hash_hash);
-int get_master_key(const u8 *password_hash_hash, const u8 *nt_response,
-				   u8 *master_key);
-int get_asymetric_start_key(const u8 *master_key, u8 *session_key,
-							size_t session_key_len, int is_send,
-							int is_server);
-int __must_check encrypt_pw_block_with_password_hash(
-	const u8 *password, size_t password_len,
-	const u8 *password_hash, u8 *pw_block);
-int __must_check new_password_encrypted_with_old_nt_password_hash(
-	const u8 *new_password, size_t new_password_len,
-	const u8 *old_password, size_t old_password_len,
-	u8 *encrypted_pw_block);
-void nt_password_hash_encrypted_with_block(const u8 *password_hash,
-		const u8 *block, u8 *cypher);
-int old_nt_password_hash_encrypted_with_new_nt_password_hash(
-	const u8 *new_password, size_t new_password_len,
-	const u8 *old_password, size_t old_password_len,
-	u8 *encrypted_password_hash);
-
-#endif /* MS_FUNCS_H */
diff --git a/os/board/rtl8720e/src/component/wifi/wpa_supplicant/src/crypto/random.h b/os/board/rtl8720e/src/component/wifi/wpa_supplicant/src/crypto/random.h
deleted file mode 100644
index 81fc61cb8..000000000
--- a/os/board/rtl8720e/src/component/wifi/wpa_supplicant/src/crypto/random.h
+++ /dev/null
@@ -1,30 +0,0 @@
-/*
- * Random number generator
- * Copyright (c) 2010-2011, Jouni Malinen <j@w1.fi>
- *
- * This software may be distributed under the terms of the BSD license.
- * See README for more details.
- */
-
-#ifndef RANDOM_H
-#define RANDOM_H
-
-#ifdef CONFIG_NO_RANDOM_POOL
-//#define random_init(e) do { } while (0)
-//#define random_deinit() do { } while (0)
-//#define random_add_randomness(b, l) do { } while (0)
-#define random_get_bytes(b, l) os_get_random((b), (l))
-#define random_pool_ready() 1
-#define random_mark_pool_ready() do { } while (0)
-#else /* CONFIG_NO_RANDOM_POOL */
-//void random_init(const char *entropy_file);
-//void random_deinit(void);
-//void random_add_randomness(const void *buf, size_t len);
-
-int random_get_bytes(void *buf, size_t len);
-int random_pool_ready(void);
-void random_mark_pool_ready(void);
-#endif /* CONFIG_NO_RANDOM_POOL */
-#endif /* RANDOM_H */
-
-
diff --git a/os/board/rtl8720e/src/component/wifi/wpa_supplicant/src/crypto/sha1.h b/os/board/rtl8720e/src/component/wifi/wpa_supplicant/src/crypto/sha1.h
deleted file mode 100644
index 9824096e7..000000000
--- a/os/board/rtl8720e/src/component/wifi/wpa_supplicant/src/crypto/sha1.h
+++ /dev/null
@@ -1,27 +0,0 @@
-/*
- * SHA1 hash implementation and interface functions
- * Copyright (c) 2003-2009, Jouni Malinen <j@w1.fi>
- *
- * This software may be distributed under the terms of the BSD license.
- * See README for more details.
- */
-
-#ifndef SHA1_H
-#define SHA1_H
-
-#define SHA1_MAC_LEN 20
-
-int hmac_sha1_vector(const u8 *key, size_t key_len, size_t num_elem,
-					 const u8 *addr[], const size_t *len, u8 *mac);
-int hmac_sha1(const u8 *key, size_t key_len, const u8 *data, size_t data_len,
-			  u8 *mac);
-int sha1_prf(const u8 *key, size_t key_len, const char *label,
-			 const u8 *data, size_t data_len, u8 *buf, size_t buf_len);
-int sha1_t_prf(const u8 *key, size_t key_len, const char *label,
-			   const u8 *seed, size_t seed_len, u8 *buf, size_t buf_len);
-int __must_check tls_prf_sha1_md5(const u8 *secret, size_t secret_len,
-								  const char *label, const u8 *seed,
-								  size_t seed_len, u8 *out, size_t outlen);
-int pbkdf2_sha1(const char *passphrase, const u8 *ssid, size_t ssid_len,
-				int iterations, u8 *buf, size_t buflen);
-#endif /* SHA1_H */
diff --git a/os/board/rtl8720e/src/component/wifi/wpa_supplicant/src/crypto/sha1_i.h b/os/board/rtl8720e/src/component/wifi/wpa_supplicant/src/crypto/sha1_i.h
deleted file mode 100644
index 344387e97..000000000
--- a/os/board/rtl8720e/src/component/wifi/wpa_supplicant/src/crypto/sha1_i.h
+++ /dev/null
@@ -1,23 +0,0 @@
-/*
- * SHA1 internal definitions
- * Copyright (c) 2003-2005, Jouni Malinen <j@w1.fi>
- *
- * This software may be distributed under the terms of the BSD license.
- * See README for more details.
- */
-
-#ifndef SHA1_I_H
-#define SHA1_I_H
-
-struct SHA1Context {
-	u32 state[5];
-	u32 count[2];
-	unsigned char buffer[64];
-};
-
-void SHA1Init(struct SHA1Context *context);
-void SHA1Update(struct SHA1Context *context, const void *data, u32 len);
-void SHA1Final(unsigned char digest[20], struct SHA1Context *context);
-void SHA1Transform(u32 state[5], const unsigned char buffer[64]);
-
-#endif /* SHA1_I_H */
diff --git a/os/board/rtl8720e/src/component/wifi/wpa_supplicant/src/crypto/sha256.h b/os/board/rtl8720e/src/component/wifi/wpa_supplicant/src/crypto/sha256.h
deleted file mode 100644
index b47f2cd58..000000000
--- a/os/board/rtl8720e/src/component/wifi/wpa_supplicant/src/crypto/sha256.h
+++ /dev/null
@@ -1,30 +0,0 @@
-/*
- * SHA256 hash implementation and interface functions
- * Copyright (c) 2003-2014, Jouni Malinen <j@w1.fi>
- *
- * This software may be distributed under the terms of the BSD license.
- * See README for more details.
- */
-
-#ifndef SHA256_H
-#define SHA256_H
-
-#define SHA256_MAC_LEN 32
-
-int hmac_sha256_vector(const u8 *key, size_t key_len, size_t num_elem,
-					   const u8 *addr[], const size_t *len, u8 *mac);
-int hmac_sha256(const u8 *key, size_t key_len, const u8 *data,
-				size_t data_len, u8 *mac);
-void sha256_prf(const u8 *key, size_t key_len, const char *label,
-				const u8 *data, size_t data_len, u8 *buf, size_t buf_len);
-void sha256_prf_bits(const u8 *key, size_t key_len, const char *label,
-					 const u8 *data, size_t data_len, u8 *buf,
-					 size_t buf_len_bits);
-void tls_prf_sha256(const u8 *secret, size_t secret_len,
-					const char *label, const u8 *seed, size_t seed_len,
-					u8 *out, size_t outlen);
-int hmac_sha256_kdf(const u8 *secret, size_t secret_len,
-					const char *label, const u8 *seed, size_t seed_len,
-					u8 *out, size_t outlen);
-
-#endif /* SHA256_H */
diff --git a/os/board/rtl8720e/src/component/wifi/wpa_supplicant/src/crypto/tls_polarssl.c b/os/board/rtl8720e/src/component/wifi/wpa_supplicant/src/crypto/tls_polarssl.c
old mode 100644
new mode 100755
index f9814daa0..5ab84a53b
--- a/os/board/rtl8720e/src/component/wifi/wpa_supplicant/src/crypto/tls_polarssl.c
+++ b/os/board/rtl8720e/src/component/wifi/wpa_supplicant/src/crypto/tls_polarssl.c
@@ -697,6 +697,9 @@ struct wpabuf *tls_connection_decrypt(void *tls_ctx,
 	 * to handle the possibility of the decrypted data being longer than
 	 * input data.
 	 */
+	if (NULL == in_data) {
+		return NULL;
+	}
 	size = (wpabuf_len(in_data) + 500) * 3;
 	out_data = wpabuf_alloc(size);
 	if (out_data == NULL) {
diff --git a/os/board/rtl8720e/src/component/wifi/wpa_supplicant/src/utils/os.h b/os/board/rtl8720e/src/component/wifi/wpa_supplicant/src/utils/os.h
old mode 100644
new mode 100755
index 5cc3d3dd1..7197a1597
--- a/os/board/rtl8720e/src/component/wifi/wpa_supplicant/src/utils/os.h
+++ b/os/board/rtl8720e/src/component/wifi/wpa_supplicant/src/utils/os.h
@@ -10,12 +10,13 @@
 #define OS_H
 
 //#include "basic_types.h"
-#include <autoconf.h>
+#include <rtw_wifi_constants.h>
 #include "osdep_service.h"
 #if defined(PLATFORM_ALIOS)
 #include "alios/wrapper.h"
 #else
-#include "freertos/wrapper.h"
+#include <stdio.h>
+#include <string.h>
 #endif
 #include "utils/rom/rom_wps_os.h"
 
@@ -478,12 +479,12 @@ int os_snprintf(char *str, size_t size, const char *format, ...);
 
 #else /* OS_NO_C_LIB_DEFINES */
 
-#if !defined(CONFIG_PLATFORM_8195A) && !defined(CONFIG_PLATFORM_8711B) && !defined(CONFIG_PLATFORM_8721D) && !defined(CONFIG_PLATFORM_AMEBAD2) && !defined(CONFIG_PLATFORM_AMEBADPLUS)
+#if !defined(CONFIG_PLATFORM_8721D) && !defined(CONFIG_PLATFORM_AMEBAD2) && !defined(CONFIG_PLATFORM_AMEBADPLUS)
 #ifndef os_malloc
-#define os_malloc(sz) _rtw_malloc(sz)
+#define os_malloc(sz) rtw_malloc(sz)
 #endif
 #ifndef os_free
-#define os_free(p, sz) _rtw_mfree(((uint8_t*)(p)), (sz))
+#define os_free(p, sz) rtw_mfree(((uint8_t*)(p)), (sz))
 #endif
 #endif
 extern void *os_zalloc(size_t size);
diff --git a/os/board/rtl8720e/src/component/wifi/wpa_supplicant/src/utils/rom/rom_wps_os.h b/os/board/rtl8720e/src/component/wifi/wpa_supplicant/src/utils/rom/rom_wps_os.h
old mode 100644
new mode 100755
index 049f56e33..c5f17b118
--- a/os/board/rtl8720e/src/component/wifi/wpa_supplicant/src/utils/rom/rom_wps_os.h
+++ b/os/board/rtl8720e/src/component/wifi/wpa_supplicant/src/utils/rom/rom_wps_os.h
@@ -9,7 +9,7 @@
 #ifndef ROM_WPS_OS_H
 #define ROM_WPS_OS_H
 
-#if defined(CONFIG_PLATFORM_8195A) || defined(CONFIG_PLATFORM_8711B) || defined(CONFIG_PLATFORM_8721D) || defined(CONFIG_PLATFORM_AMEBAD2) || defined(CONFIG_PLATFORM_AMEBADPLUS)
+#if defined(CONFIG_PLATFORM_8721D) || defined(CONFIG_PLATFORM_AMEBAD2) || defined(CONFIG_PLATFORM_AMEBADPLUS)
 #ifndef CONFIG_AS_INIC_AP
 #include <rom_wlan_ram_map.h>
 extern struct _rom_wlan_ram_map rom_wlan_ram_map;
@@ -17,9 +17,8 @@ extern struct _rom_wlan_ram_map rom_wlan_ram_map;
 #define os_free(p, sz) rom_wlan_ram_map.rtw_mfree(((uint8_t*)(p)), (sz))
 #else
 #include <osdep_service.h>
-extern struct osdep_service_ops osdep_service;
-#define os_malloc(sz) osdep_service.rtw_malloc(sz)
-#define os_free(p, sz) osdep_service.rtw_mfree(((uint8_t*)(p)), (sz))
+#define os_malloc(sz) rtw_malloc(sz)
+#define os_free(p, sz) rtw_mfree(((uint8_t*)(p)), (sz))
 #endif
 #endif
 
diff --git a/os/board/rtl8720e/src/component/wifi/wpa_supplicant/wpa_supplicant/wifi_eap_config.c b/os/board/rtl8720e/src/component/wifi/wpa_supplicant/wpa_supplicant/wifi_eap_config.c
old mode 100644
new mode 100755
index 290258a89..8e20d9edd
--- a/os/board/rtl8720e/src/component/wifi/wpa_supplicant/wpa_supplicant/wifi_eap_config.c
+++ b/os/board/rtl8720e/src/component/wifi/wpa_supplicant/wpa_supplicant/wifi_eap_config.c
@@ -1,16 +1,14 @@
-#if !defined(CONFIG_MBED_ENABLED)
 #include "main.h"
 #if CONFIG_LWIP_LAYER
 #include <lwip_netconf.h>
 #endif
-#endif
 #include <stdio.h>
 #include <string.h>
 #include <stdlib.h>
 #include <osdep_service.h>
 #include "utils/os.h"
 #include "wifi_conf.h"
-#include <platform_stdlib.h>
+#include "wifi_ind.h"
 
 #define WLAN0_NAME "wlan0"
 #ifndef ENABLE
@@ -45,9 +43,7 @@ void eap_eapol_recvd_hdl(char *buf, int buf_len, int flags, void *handler_user_d
 void eap_eapol_start_hdl(char *buf, int buf_len, int flags, void *handler_user_data);
 int connect_by_open_system(char *target_ssid);
 
-#if !defined(CONFIG_MBED_ENABLED)
 int eap_start(char *method);
-#endif
 
 void set_eap_phase(unsigned char is_trigger_eap)
 {
@@ -65,7 +61,6 @@ int get_eap_method(void)
 	return eap_method;
 }
 
-#if !defined(CONFIG_MBED_ENABLED)
 void reset_config(void)
 {
 	eap_target_ssid = NULL;
@@ -103,7 +98,7 @@ void eap_disconnected_hdl(char *buf, int buf_len, int flags, void *handler_user_
 #if (RTL8192E_SUPPORT == 0)//devin_li rtl8192es_temp_mask	
 	wifi_unreg_event_handler(WIFI_EVENT_WPA_EAPOL_RECVD, eap_eapol_recvd_hdl);
 	wifi_unreg_event_handler(WIFI_EVENT_DISCONNECT, eap_disconnected_hdl);
-	eap_peer_unregister_methods();
+	//eap_peer_unregister_methods();
 	eap_sm_deinit();
 	//reset_config();
 #endif
@@ -277,28 +272,18 @@ int eap_start(char *method)
 
 int connect_by_open_system(char *target_ssid)
 {
-	int retry_count = 0, ret;
+	int ret;
 	rtw_network_info_t connect_param = {0};
 	if (target_ssid != NULL) {
 		rtw_memcpy(connect_param.ssid.val, target_ssid, strlen(target_ssid));
 		connect_param.ssid.len = strlen(target_ssid);
 		connect_param.security_type = RTW_SECURITY_OPEN;
-		while (1) {
-			rtw_msleep_os(500);	//wait scan complete.
-			ret = wifi_connect(&connect_param, 1);
-			if (ret == RTW_SUCCESS) {
-				//printf("\r\n[EAP]Associate with AP success\n");
-				break;
-			}
-			if (retry_count == 0) {
-				//printf("\r\n[EAP]Associate with AP failed %d\n", ret);
-				return -1;
-			}
-			retry_count --;
-			printf("Retry connection...\n");
-
-			judge_station_disconnect();
-			set_eap_phase(ENABLE);
+		ret = wifi_connect(&connect_param, 1);
+		if (ret == RTW_SUCCESS) {
+			//printf("\r\n[EAP]Associate with AP success\n");
+			return 0;
+		} else {
+			return -1;
 		}
 	} else {
 		printf("\r\n[EAP]Target SSID is NULL\n");
@@ -313,7 +298,6 @@ void eap_autoreconnect_thread(void *method)
 	eap_start((char *)method);
 	vTaskDelete(NULL);
 }
-#endif
 
 void eap_autoreconnect_hdl(u8 method_id)
 {
@@ -341,7 +325,6 @@ void eap_autoreconnect_hdl(u8 method_id)
 #endif
 }
 
-//#if CONFIG_MBED_ENABLED
 // copy from ssl_client_ext.c
 
 #include <mbedtls/config.h>
diff --git a/os/board/rtl8720e/src/component/wifi/wpa_supplicant/wpa_supplicant/wifi_wps_config.c b/os/board/rtl8720e/src/component/wifi/wpa_supplicant/wpa_supplicant/wifi_wps_config.c
old mode 100644
new mode 100755
index 2ce14a686..3da48d4cf
--- a/os/board/rtl8720e/src/component/wifi/wpa_supplicant/wpa_supplicant/wifi_wps_config.c
+++ b/os/board/rtl8720e/src/component/wifi/wpa_supplicant/wpa_supplicant/wifi_wps_config.c
@@ -10,13 +10,12 @@
 #include <lwip_netconf.h>
 #endif
 #include "wifi_conf.h"
+#include "wifi_ind.h"
 #include "wps/wps_defs.h"
 #include <platform_stdlib.h>
 #include "wifi_wps_config.h"
 
-#if defined(CONFIG_PLATFORM_8721D) || defined(CONFIG_PLATFORM_8710C) || defined(CONFIG_PLATFORM_AMEBAD2) || defined(CONFIG_PLATFORM_8735B) || defined(CONFIG_PLATFORM_AMEBADPLUS)
 #include "platform_opts_bt.h"
-#endif
 
 // The maximum number of WPS credentials. The value should be in range of 1~10.
 int wps_max_cred_count = 10;
@@ -275,7 +274,7 @@ static void wps_config_wifi_setting(rtw_network_info_t *wifi, struct dev_credent
 {
 	printf("\r\nwps_config_wifi_setting\n");
 	//memcpy((void *)wifi->ssid, (void *)dev_cred->ssid, dev_cred->ssid_len);
-	strncpy((char *)wifi->ssid.val, (char *)&dev_cred->ssid[0], sizeof(wifi->ssid.val));
+	strncpy((char *)wifi->ssid.val, (char *)&dev_cred->ssid[0], dev_cred->ssid_len);
 	printf("\r\nwps_wifi.ssid = %s\n", wifi->ssid.val);
 	wifi->ssid.len = dev_cred->ssid_len;
 	printf("\r\nwps_wifi.ssid_len = %d\n", wifi->ssid.len);
@@ -697,7 +696,7 @@ static int wps_find_out_triger_wps_AP(char *target_ssid, unsigned char *target_b
 		printf("\n\rERROR: wifi scan failed");
 		goto exit;
 	}
-	if (rtw_down_timeout_sema(&wps_arg.scan_sema, SCAN_LONGEST_WAIT_TIME) == RTW_FALSE) {
+	if (rtw_down_timeout_sema(&wps_arg.scan_sema, SCAN_LONGEST_WAIT_TIME) == _FAIL) {
 		printf("\r\nWPS scan done early!\r\n");
 	}
 
diff --git a/os/board/rtl8720e/src/libs/cmse_implib.lib b/os/board/rtl8720e/src/libs/cmse_implib.lib
old mode 100644
new mode 100755
diff --git a/os/board/rtl8720e/src/libs/cmse_implib_fpu.lib b/os/board/rtl8720e/src/libs/cmse_implib_fpu.lib
old mode 100644
new mode 100755
diff --git a/os/board/rtl8720e/src/project/realtek_amebaLite_va0_example/inc/inc_km4/main.h b/os/board/rtl8720e/src/project/realtek_amebaLite_va0_example/inc/inc_km4/main.h
old mode 100644
new mode 100755
index fe44cd00a..6c578eb65
--- a/os/board/rtl8720e/src/project/realtek_amebaLite_va0_example/inc/inc_km4/main.h
+++ b/os/board/rtl8720e/src/project/realtek_amebaLite_va0_example/inc/inc_km4/main.h
@@ -1,7 +1,7 @@
 #ifndef MAIN_H
 #define MAIN_H
-#include "platform_stdlib.h"
-#include <autoconf.h>
+
+#include <rtw_wifi_constants.h>
 
 #ifdef CONFIG_WLAN
 #define ATVER_1 1 // For First AT command
diff --git a/os/se/ameba/Make.defs b/os/se/ameba/Make.defs
index 860764f51..45aeb8bc7 100644
--- a/os/se/ameba/Make.defs
+++ b/os/se/ameba/Make.defs
@@ -55,6 +55,6 @@ CFLAGS += -I$(TOPDIR)/board/rtl8720e/src/component/soc/amebalite/misc
 CFLAGS += -I$(TOPDIR)/board/rtl8720e/src/project/realtek_amebaLite_va0_example/inc/inc_km4
 CFLAGS += -I$(TOPDIR)/board/rtl8720e/src/component/soc/amebalite/fwlib/include
 CFLAGS += -I$(TOPDIR)/board/rtl8720e/src/component/ssl/mbedtls_ram_map/rom
-CFLAGS += -I$(TOPDIR)/board/rtl8720e/src/component/os/os_dep/include
+CFLAGS += -I$(TOPDIR)/board/rtl8720e/src/component/os_dep
 endif
 endif
